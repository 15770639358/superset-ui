(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{1382:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DEFAULT_MARGIN; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return createMarginSelector; });\n/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(109);\n\nconst DEFAULT_MARGIN = { bottom: 16, left: 16, right: 16, top: 16 };\nfunction createMarginSelector(defaultMargin = DEFAULT_MARGIN) {\n    return Object(reselect__WEBPACK_IMPORTED_MODULE_0__["createSelector"])((margin) => margin.bottom, margin => margin.left, margin => margin.right, margin => margin.top, (bottom = defaultMargin.bottom, left = defaultMargin.left, right = defaultMargin.right, top = defaultMargin.top) => ({\n        bottom,\n        left,\n        right,\n        top,\n    }));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM4Mi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wcmVzZXQtY2hhcnQteHkvc3JjL3V0aWxzL2NyZWF0ZU1hcmdpblNlbGVjdG9yLnRzeD83NTU1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yIH0gZnJvbSAncmVzZWxlY3QnO1xuaW1wb3J0IHsgTWFyZ2luIH0gZnJvbSAnQHN1cGVyc2V0LXVpL2RpbWVuc2lvbic7XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX01BUkdJTiA9IHsgYm90dG9tOiAxNiwgbGVmdDogMTYsIHJpZ2h0OiAxNiwgdG9wOiAxNiB9O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVNYXJnaW5TZWxlY3RvcihkZWZhdWx0TWFyZ2luOiBNYXJnaW4gPSBERUZBVUxUX01BUkdJTikge1xuICByZXR1cm4gY3JlYXRlU2VsZWN0b3IoXG4gICAgKG1hcmdpbjogUGFydGlhbDxNYXJnaW4+KSA9PiBtYXJnaW4uYm90dG9tLFxuICAgIG1hcmdpbiA9PiBtYXJnaW4ubGVmdCxcbiAgICBtYXJnaW4gPT4gbWFyZ2luLnJpZ2h0LFxuICAgIG1hcmdpbiA9PiBtYXJnaW4udG9wLFxuICAgIChcbiAgICAgIGJvdHRvbSA9IGRlZmF1bHRNYXJnaW4uYm90dG9tLFxuICAgICAgbGVmdCA9IGRlZmF1bHRNYXJnaW4ubGVmdCxcbiAgICAgIHJpZ2h0ID0gZGVmYXVsdE1hcmdpbi5yaWdodCxcbiAgICAgIHRvcCA9IGRlZmF1bHRNYXJnaW4udG9wLFxuICAgICkgPT4gKHtcbiAgICAgIGJvdHRvbSxcbiAgICAgIGxlZnQsXG4gICAgICByaWdodCxcbiAgICAgIHRvcCxcbiAgICB9KSxcbiAgKTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUVBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1382\n')},1383:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return convertScaleToDataUIScale; });\nfunction isCompatibleDomainOrRange(array) {\n    return (typeof array !== 'undefined' &&\n        array.length > 0 &&\n        (typeof array[0] === 'string' || typeof array[0] === 'number'));\n}\n/**\n * Convert encodeable scale object into @data-ui's scale config\n * @param scale\n */\nfunction convertScaleToDataUIScale(scale) {\n    const { type, domain, range } = scale;\n    let outputType;\n    if (type === 'linear' || type === 'time' || type === 'band') {\n        outputType = type;\n    }\n    else if (type === 'utc') {\n        outputType = 'timeUtc';\n    }\n    else {\n        throw new Error(`Unsupported scale type: ${type}`);\n    }\n    const output = { type: outputType };\n    if (isCompatibleDomainOrRange(domain)) {\n        output.domain = domain;\n    }\n    if (isCompatibleDomainOrRange(range)) {\n        output.range = range;\n    }\n    if ('nice' in scale && typeof scale.nice === 'boolean') {\n        output.nice = scale.nice;\n    }\n    if ('paddingInner' in scale && typeof scale.paddingInner !== 'undefined') {\n        output.paddingInner = scale.paddingInner;\n    }\n    if ('paddingOuter' in scale && typeof scale.paddingOuter !== 'undefined') {\n        output.paddingOuter = scale.paddingOuter;\n    }\n    return output;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM4My5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wcmVzZXQtY2hhcnQteHkvc3JjL3V0aWxzL2NvbnZlcnRTY2FsZVRvRGF0YVVJU2NhbGVTaGFwZS50cz8wNDdmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFZhbHVlLCBTY2FsZUNvbmZpZyB9IGZyb20gJ2VuY29kYWJsZSc7XG5cbnR5cGUgRGF0YVVJU2NhbGVUeXBlID0gJ3RpbWUnIHwgJ3RpbWVVdGMnIHwgJ2xpbmVhcicgfCAnYmFuZCc7XG5cbmludGVyZmFjZSBEYXRhVUlTY2FsZSB7XG4gIHR5cGU6IERhdGFVSVNjYWxlVHlwZTtcbiAgZG9tYWluPzogbnVtYmVyW10gfCBzdHJpbmdbXTtcbiAgaW5jbHVkZVplcm8/OiBib29sZWFuO1xuICBuaWNlPzogYm9vbGVhbjtcbiAgcGFkZGluZ0lubmVyPzogbnVtYmVyO1xuICBwYWRkaW5nT3V0ZXI/OiBudW1iZXI7XG4gIHJhbmdlPzogbnVtYmVyW10gfCBzdHJpbmdbXTtcbiAgcmFuZ2VSb3VuZD86IG51bWJlcltdIHwgc3RyaW5nW107XG59XG5cbmZ1bmN0aW9uIGlzQ29tcGF0aWJsZURvbWFpbk9yUmFuZ2UoXG4gIGFycmF5OiBTY2FsZUNvbmZpZ1snZG9tYWluJ10gfCBTY2FsZUNvbmZpZ1sncmFuZ2UnXSxcbik6IGFycmF5IGlzIG51bWJlcltdIHwgc3RyaW5nW10ge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBhcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICBhcnJheS5sZW5ndGggPiAwICYmXG4gICAgKHR5cGVvZiBhcnJheVswXSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGFycmF5WzBdID09PSAnbnVtYmVyJylcbiAgKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGVuY29kZWFibGUgc2NhbGUgb2JqZWN0IGludG8gQGRhdGEtdWkncyBzY2FsZSBjb25maWdcbiAqIEBwYXJhbSBzY2FsZVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb252ZXJ0U2NhbGVUb0RhdGFVSVNjYWxlPE91dHB1dCBleHRlbmRzIFZhbHVlPihcbiAgc2NhbGU6IFNjYWxlQ29uZmlnPE91dHB1dD4sXG4pIHtcbiAgY29uc3QgeyB0eXBlLCBkb21haW4sIHJhbmdlIH0gPSBzY2FsZTtcblxuICBsZXQgb3V0cHV0VHlwZTogRGF0YVVJU2NhbGVUeXBlO1xuXG4gIGlmICh0eXBlID09PSAnbGluZWFyJyB8fCB0eXBlID09PSAndGltZScgfHwgdHlwZSA9PT0gJ2JhbmQnKSB7XG4gICAgb3V0cHV0VHlwZSA9IHR5cGU7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3V0YycpIHtcbiAgICBvdXRwdXRUeXBlID0gJ3RpbWVVdGMnO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgc2NhbGUgdHlwZTogJHt0eXBlfWApO1xuICB9XG5cbiAgY29uc3Qgb3V0cHV0OiBEYXRhVUlTY2FsZSA9IHsgdHlwZTogb3V0cHV0VHlwZSB9O1xuICBpZiAoaXNDb21wYXRpYmxlRG9tYWluT3JSYW5nZShkb21haW4pKSB7XG4gICAgb3V0cHV0LmRvbWFpbiA9IGRvbWFpbjtcbiAgfVxuICBpZiAoaXNDb21wYXRpYmxlRG9tYWluT3JSYW5nZShyYW5nZSkpIHtcbiAgICBvdXRwdXQucmFuZ2UgPSByYW5nZTtcbiAgfVxuICBpZiAoJ25pY2UnIGluIHNjYWxlICYmIHR5cGVvZiBzY2FsZS5uaWNlID09PSAnYm9vbGVhbicpIHtcbiAgICBvdXRwdXQubmljZSA9IHNjYWxlLm5pY2U7XG4gIH1cbiAgaWYgKCdwYWRkaW5nSW5uZXInIGluIHNjYWxlICYmIHR5cGVvZiBzY2FsZS5wYWRkaW5nSW5uZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgb3V0cHV0LnBhZGRpbmdJbm5lciA9IHNjYWxlLnBhZGRpbmdJbm5lcjtcbiAgfVxuICBpZiAoJ3BhZGRpbmdPdXRlcicgaW4gc2NhbGUgJiYgdHlwZW9mIHNjYWxlLnBhZGRpbmdPdXRlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBvdXRwdXQucGFkZGluZ091dGVyID0gc2NhbGUucGFkZGluZ091dGVyO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBZUE7QUFBQTtBQUdBO0FBRUE7QUFDQTtBQUVBO0FBRUE7OztBQUdBO0FBQ0E7QUFHQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1383\n")},1384:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"a\", function() { return /* binding */ getTextDimension; });\n\n// CONCATENATED MODULE: ../superset-ui-dimension/src/svg/updateTextNode.ts\nconst STYLE_FIELDS = [\n    'font',\n    'fontWeight',\n    'fontStyle',\n    'fontSize',\n    'fontFamily',\n    'letterSpacing',\n];\nfunction updateTextNode(node, { className, style = {}, text, } = {}) {\n    const textNode = node;\n    if (textNode.textContent !== text) {\n        textNode.textContent = typeof text === 'undefined' ? null : text;\n    }\n    if (textNode.getAttribute('class') !== className) {\n        textNode.setAttribute('class', className !== null && className !== void 0 ? className : '');\n    }\n    // Clear style\n    // Note: multi-word property names are hyphenated and not camel-cased.\n    textNode.style.removeProperty('font');\n    textNode.style.removeProperty('font-weight');\n    textNode.style.removeProperty('font-style');\n    textNode.style.removeProperty('font-size');\n    textNode.style.removeProperty('font-family');\n    textNode.style.removeProperty('letter-spacing');\n    // Apply new style\n    // Note: the font field will auto-populate other font fields when applicable.\n    STYLE_FIELDS.filter((field) => typeof style[field] !== 'undefined' && style[field] !== null).forEach((field) => {\n        textNode.style[field] = `${style[field]}`;\n    });\n    return textNode;\n}\n\n// CONCATENATED MODULE: ../superset-ui-dimension/src/svg/getBBoxCeil.ts\nconst DEFAULT_DIMENSION = { height: 20, width: 100 };\nfunction getBBoxCeil(node, defaultDimension = DEFAULT_DIMENSION) {\n    const { width, height } = node.getBBox ? node.getBBox() : defaultDimension;\n    return {\n        height: Math.ceil(height),\n        width: Math.ceil(width),\n    };\n}\n\n// CONCATENATED MODULE: ../superset-ui-dimension/src/svg/LazyFactory.ts\nclass LazyFactory {\n    constructor(factoryFn) {\n        this.activeNodes = new Map();\n        this.factoryFn = factoryFn;\n    }\n    createInContainer(container = document.body) {\n        if (this.activeNodes.has(container)) {\n            const entry = this.activeNodes.get(container);\n            entry.counter += 1;\n            return entry.node;\n        }\n        const node = this.factoryFn();\n        container.append(node);\n        this.activeNodes.set(container, { counter: 1, node });\n        return node;\n    }\n    removeFromContainer(container = document.body) {\n        if (this.activeNodes.has(container)) {\n            const entry = this.activeNodes.get(container);\n            entry.counter -= 1;\n            if (entry.counter === 0) {\n                container.removeChild(entry.node);\n                this.activeNodes.delete(container);\n            }\n        }\n    }\n}\n\n// CONCATENATED MODULE: ../superset-ui-dimension/src/svg/constants.ts\n// eslint-disable-next-line import/prefer-default-export\nconst SVG_NS = 'http://www.w3.org/2000/svg';\n\n// CONCATENATED MODULE: ../superset-ui-dimension/src/svg/createHiddenSvgNode.ts\n\nfunction createHiddenSvgNode() {\n    const svgNode = document.createElementNS(SVG_NS, 'svg');\n    svgNode.style.position = 'absolute'; // so it won't disrupt page layout\n    svgNode.style.top = '-100%';\n    svgNode.style.left = '-100%';\n    svgNode.style.width = '0'; // no dimensions\n    svgNode.style.height = '0';\n    svgNode.style.opacity = '0'; // not visible\n    svgNode.style.pointerEvents = 'none'; // won't capture mouse events\n    return svgNode;\n}\n\n// CONCATENATED MODULE: ../superset-ui-dimension/src/svg/createTextNode.ts\n\nfunction createTextNode() {\n    return document.createElementNS(SVG_NS, 'text');\n}\n\n// CONCATENATED MODULE: ../superset-ui-dimension/src/svg/factories.ts\n\n\n\nconst hiddenSvgFactory = new LazyFactory(createHiddenSvgNode);\nconst textFactory = new LazyFactory(createTextNode);\n\n// CONCATENATED MODULE: ../superset-ui-dimension/src/getTextDimension.ts\n\n\n\nfunction getTextDimension(input, defaultDimension) {\n    const { text, className, style, container } = input;\n    // Empty string\n    if (text.length === 0) {\n        return { height: 0, width: 0 };\n    }\n    const svgNode = hiddenSvgFactory.createInContainer(container);\n    const textNode = textFactory.createInContainer(svgNode);\n    updateTextNode(textNode, { className, style, text });\n    const dimension = getBBoxCeil(textNode, defaultDimension);\n    // The nodes are added to the DOM briefly only to make getBBox works.\n    // (If not added to DOM getBBox will always return 0x0.)\n    // After that the svg nodes are not needed.\n    // We delay its removal in case there are subsequent calls to this function\n    // that can reuse the svg nodes.\n    // Experiments have shown that reusing existing nodes\n    // instead of deleting and adding new ones can save lot of time.\n    setTimeout(() => {\n        textFactory.removeFromContainer(svgNode);\n        hiddenSvgFactory.removeFromContainer(container);\n    }, 500);\n    return dimension;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM4NC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9zdXBlcnNldC11aS1kaW1lbnNpb24vc3JjL3N2Zy91cGRhdGVUZXh0Tm9kZS50cz8zZDE4Iiwid2VicGFjazovLy8uLi9zdXBlcnNldC11aS1kaW1lbnNpb24vc3JjL3N2Zy9nZXRCQm94Q2VpbC50cz9hMTc5Iiwid2VicGFjazovLy8uLi9zdXBlcnNldC11aS1kaW1lbnNpb24vc3JjL3N2Zy9MYXp5RmFjdG9yeS50cz9lNTI0Iiwid2VicGFjazovLy8uLi9zdXBlcnNldC11aS1kaW1lbnNpb24vc3JjL3N2Zy9jb25zdGFudHMudHM/NzkzZCIsIndlYnBhY2s6Ly8vLi4vc3VwZXJzZXQtdWktZGltZW5zaW9uL3NyYy9zdmcvY3JlYXRlSGlkZGVuU3ZnTm9kZS50cz82MTYyIiwid2VicGFjazovLy8uLi9zdXBlcnNldC11aS1kaW1lbnNpb24vc3JjL3N2Zy9jcmVhdGVUZXh0Tm9kZS50cz81ZGI3Iiwid2VicGFjazovLy8uLi9zdXBlcnNldC11aS1kaW1lbnNpb24vc3JjL3N2Zy9mYWN0b3JpZXMudHM/ODQyYyIsIndlYnBhY2s6Ly8vLi4vc3VwZXJzZXQtdWktZGltZW5zaW9uL3NyYy9nZXRUZXh0RGltZW5zaW9uLnRzP2U5MzMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVGV4dFN0eWxlIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5jb25zdCBTVFlMRV9GSUVMRFM6IChrZXlvZiBUZXh0U3R5bGUpW10gPSBbXG4gICdmb250JyxcbiAgJ2ZvbnRXZWlnaHQnLFxuICAnZm9udFN0eWxlJyxcbiAgJ2ZvbnRTaXplJyxcbiAgJ2ZvbnRGYW1pbHknLFxuICAnbGV0dGVyU3BhY2luZycsXG5dO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1cGRhdGVUZXh0Tm9kZShcbiAgbm9kZTogU1ZHVGV4dEVsZW1lbnQsXG4gIHtcbiAgICBjbGFzc05hbWUsXG4gICAgc3R5bGUgPSB7fSxcbiAgICB0ZXh0LFxuICB9OiB7XG4gICAgY2xhc3NOYW1lPzogc3RyaW5nO1xuICAgIHN0eWxlPzogVGV4dFN0eWxlO1xuICAgIHRleHQ/OiBzdHJpbmc7XG4gIH0gPSB7fSxcbikge1xuICBjb25zdCB0ZXh0Tm9kZSA9IG5vZGU7XG5cbiAgaWYgKHRleHROb2RlLnRleHRDb250ZW50ICE9PSB0ZXh0KSB7XG4gICAgdGV4dE5vZGUudGV4dENvbnRlbnQgPSB0eXBlb2YgdGV4dCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogdGV4dDtcbiAgfVxuICBpZiAodGV4dE5vZGUuZ2V0QXR0cmlidXRlKCdjbGFzcycpICE9PSBjbGFzc05hbWUpIHtcbiAgICB0ZXh0Tm9kZS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2xhc3NOYW1lID8/ICcnKTtcbiAgfVxuXG4gIC8vIENsZWFyIHN0eWxlXG4gIC8vIE5vdGU6IG11bHRpLXdvcmQgcHJvcGVydHkgbmFtZXMgYXJlIGh5cGhlbmF0ZWQgYW5kIG5vdCBjYW1lbC1jYXNlZC5cbiAgdGV4dE5vZGUuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ2ZvbnQnKTtcbiAgdGV4dE5vZGUuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ2ZvbnQtd2VpZ2h0Jyk7XG4gIHRleHROb2RlLnN0eWxlLnJlbW92ZVByb3BlcnR5KCdmb250LXN0eWxlJyk7XG4gIHRleHROb2RlLnN0eWxlLnJlbW92ZVByb3BlcnR5KCdmb250LXNpemUnKTtcbiAgdGV4dE5vZGUuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ2ZvbnQtZmFtaWx5Jyk7XG4gIHRleHROb2RlLnN0eWxlLnJlbW92ZVByb3BlcnR5KCdsZXR0ZXItc3BhY2luZycpO1xuXG4gIC8vIEFwcGx5IG5ldyBzdHlsZVxuICAvLyBOb3RlOiB0aGUgZm9udCBmaWVsZCB3aWxsIGF1dG8tcG9wdWxhdGUgb3RoZXIgZm9udCBmaWVsZHMgd2hlbiBhcHBsaWNhYmxlLlxuICBTVFlMRV9GSUVMRFMuZmlsdGVyKFxuICAgIChmaWVsZDoga2V5b2YgVGV4dFN0eWxlKSA9PiB0eXBlb2Ygc3R5bGVbZmllbGRdICE9PSAndW5kZWZpbmVkJyAmJiBzdHlsZVtmaWVsZF0gIT09IG51bGwsXG4gICkuZm9yRWFjaCgoZmllbGQ6IGtleW9mIFRleHRTdHlsZSkgPT4ge1xuICAgIHRleHROb2RlLnN0eWxlW2ZpZWxkXSA9IGAke3N0eWxlW2ZpZWxkXX1gO1xuICB9KTtcblxuICByZXR1cm4gdGV4dE5vZGU7XG59XG4iLCJpbXBvcnQgeyBEaW1lbnNpb24gfSBmcm9tICcuLi90eXBlcyc7XG5cbmNvbnN0IERFRkFVTFRfRElNRU5TSU9OID0geyBoZWlnaHQ6IDIwLCB3aWR0aDogMTAwIH07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEJCb3hDZWlsKFxuICBub2RlOiBTVkdHcmFwaGljc0VsZW1lbnQsXG4gIGRlZmF1bHREaW1lbnNpb246IERpbWVuc2lvbiA9IERFRkFVTFRfRElNRU5TSU9OLFxuKSB7XG4gIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gbm9kZS5nZXRCQm94ID8gbm9kZS5nZXRCQm94KCkgOiBkZWZhdWx0RGltZW5zaW9uO1xuXG4gIHJldHVybiB7XG4gICAgaGVpZ2h0OiBNYXRoLmNlaWwoaGVpZ2h0KSxcbiAgICB3aWR0aDogTWF0aC5jZWlsKHdpZHRoKSxcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIExhenlGYWN0b3J5PFQgZXh0ZW5kcyBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnQ+IHtcbiAgcHJpdmF0ZSBhY3RpdmVOb2RlcyA9IG5ldyBNYXA8XG4gICAgSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50LFxuICAgIHtcbiAgICAgIGNvdW50ZXI6IG51bWJlcjtcbiAgICAgIG5vZGU6IFQ7XG4gICAgfVxuICA+KCk7XG5cbiAgcHJpdmF0ZSBmYWN0b3J5Rm46ICgpID0+IFQ7XG5cbiAgY29uc3RydWN0b3IoZmFjdG9yeUZuOiAoKSA9PiBUKSB7XG4gICAgdGhpcy5mYWN0b3J5Rm4gPSBmYWN0b3J5Rm47XG4gIH1cblxuICBjcmVhdGVJbkNvbnRhaW5lcihjb250YWluZXI6IEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudCA9IGRvY3VtZW50LmJvZHkpIHtcbiAgICBpZiAodGhpcy5hY3RpdmVOb2Rlcy5oYXMoY29udGFpbmVyKSkge1xuICAgICAgY29uc3QgZW50cnkgPSB0aGlzLmFjdGl2ZU5vZGVzLmdldChjb250YWluZXIpITtcbiAgICAgIGVudHJ5LmNvdW50ZXIgKz0gMTtcblxuICAgICAgcmV0dXJuIGVudHJ5Lm5vZGU7XG4gICAgfVxuXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuZmFjdG9yeUZuKCk7XG4gICAgY29udGFpbmVyLmFwcGVuZChub2RlKTtcbiAgICB0aGlzLmFjdGl2ZU5vZGVzLnNldChjb250YWluZXIsIHsgY291bnRlcjogMSwgbm9kZSB9KTtcblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcmVtb3ZlRnJvbUNvbnRhaW5lcihjb250YWluZXI6IEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudCA9IGRvY3VtZW50LmJvZHkpIHtcbiAgICBpZiAodGhpcy5hY3RpdmVOb2Rlcy5oYXMoY29udGFpbmVyKSkge1xuICAgICAgY29uc3QgZW50cnkgPSB0aGlzLmFjdGl2ZU5vZGVzLmdldChjb250YWluZXIpITtcbiAgICAgIGVudHJ5LmNvdW50ZXIgLT0gMTtcbiAgICAgIGlmIChlbnRyeS5jb3VudGVyID09PSAwKSB7XG4gICAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChlbnRyeS5ub2RlKTtcbiAgICAgICAgdGhpcy5hY3RpdmVOb2Rlcy5kZWxldGUoY29udGFpbmVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiIsIi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvcHJlZmVyLWRlZmF1bHQtZXhwb3J0XG5leHBvcnQgY29uc3QgU1ZHX05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbiIsImltcG9ydCB7IFNWR19OUyB9IGZyb20gJy4vY29uc3RhbnRzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlSGlkZGVuU3ZnTm9kZSgpIHtcbiAgY29uc3Qgc3ZnTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsICdzdmcnKTtcbiAgc3ZnTm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7IC8vIHNvIGl0IHdvbid0IGRpc3J1cHQgcGFnZSBsYXlvdXRcbiAgc3ZnTm9kZS5zdHlsZS50b3AgPSAnLTEwMCUnO1xuICBzdmdOb2RlLnN0eWxlLmxlZnQgPSAnLTEwMCUnO1xuICBzdmdOb2RlLnN0eWxlLndpZHRoID0gJzAnOyAvLyBubyBkaW1lbnNpb25zXG4gIHN2Z05vZGUuc3R5bGUuaGVpZ2h0ID0gJzAnO1xuICBzdmdOb2RlLnN0eWxlLm9wYWNpdHkgPSAnMCc7IC8vIG5vdCB2aXNpYmxlXG4gIHN2Z05vZGUuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJzsgLy8gd29uJ3QgY2FwdHVyZSBtb3VzZSBldmVudHNcblxuICByZXR1cm4gc3ZnTm9kZTtcbn1cbiIsImltcG9ydCB7IFNWR19OUyB9IGZyb20gJy4vY29uc3RhbnRzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUoKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCAndGV4dCcpO1xufVxuIiwiaW1wb3J0IExhenlGYWN0b3J5IGZyb20gJy4vTGF6eUZhY3RvcnknO1xuaW1wb3J0IGNyZWF0ZUhpZGRlblN2Z05vZGUgZnJvbSAnLi9jcmVhdGVIaWRkZW5TdmdOb2RlJztcbmltcG9ydCBjcmVhdGVUZXh0Tm9kZSBmcm9tICcuL2NyZWF0ZVRleHROb2RlJztcblxuZXhwb3J0IGNvbnN0IGhpZGRlblN2Z0ZhY3RvcnkgPSBuZXcgTGF6eUZhY3RvcnkoY3JlYXRlSGlkZGVuU3ZnTm9kZSk7XG5leHBvcnQgY29uc3QgdGV4dEZhY3RvcnkgPSBuZXcgTGF6eUZhY3RvcnkoY3JlYXRlVGV4dE5vZGUpO1xuIiwiaW1wb3J0IHsgVGV4dFN0eWxlLCBEaW1lbnNpb24gfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB1cGRhdGVUZXh0Tm9kZSBmcm9tICcuL3N2Zy91cGRhdGVUZXh0Tm9kZSc7XG5pbXBvcnQgZ2V0QkJveENlaWwgZnJvbSAnLi9zdmcvZ2V0QkJveENlaWwnO1xuaW1wb3J0IHsgaGlkZGVuU3ZnRmFjdG9yeSwgdGV4dEZhY3RvcnkgfSBmcm9tICcuL3N2Zy9mYWN0b3JpZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIEdldFRleHREaW1lbnNpb25JbnB1dCB7XG4gIGNsYXNzTmFtZT86IHN0cmluZztcbiAgY29udGFpbmVyPzogSFRNTEVsZW1lbnQ7XG4gIHN0eWxlPzogVGV4dFN0eWxlO1xuICB0ZXh0OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFRleHREaW1lbnNpb24oXG4gIGlucHV0OiBHZXRUZXh0RGltZW5zaW9uSW5wdXQsXG4gIGRlZmF1bHREaW1lbnNpb24/OiBEaW1lbnNpb24sXG4pOiBEaW1lbnNpb24ge1xuICBjb25zdCB7IHRleHQsIGNsYXNzTmFtZSwgc3R5bGUsIGNvbnRhaW5lciB9ID0gaW5wdXQ7XG5cbiAgLy8gRW1wdHkgc3RyaW5nXG4gIGlmICh0ZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB7IGhlaWdodDogMCwgd2lkdGg6IDAgfTtcbiAgfVxuXG4gIGNvbnN0IHN2Z05vZGUgPSBoaWRkZW5TdmdGYWN0b3J5LmNyZWF0ZUluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gIGNvbnN0IHRleHROb2RlID0gdGV4dEZhY3RvcnkuY3JlYXRlSW5Db250YWluZXIoc3ZnTm9kZSk7XG4gIHVwZGF0ZVRleHROb2RlKHRleHROb2RlLCB7IGNsYXNzTmFtZSwgc3R5bGUsIHRleHQgfSk7XG4gIGNvbnN0IGRpbWVuc2lvbiA9IGdldEJCb3hDZWlsKHRleHROb2RlLCBkZWZhdWx0RGltZW5zaW9uKTtcblxuICAvLyBUaGUgbm9kZXMgYXJlIGFkZGVkIHRvIHRoZSBET00gYnJpZWZseSBvbmx5IHRvIG1ha2UgZ2V0QkJveCB3b3Jrcy5cbiAgLy8gKElmIG5vdCBhZGRlZCB0byBET00gZ2V0QkJveCB3aWxsIGFsd2F5cyByZXR1cm4gMHgwLilcbiAgLy8gQWZ0ZXIgdGhhdCB0aGUgc3ZnIG5vZGVzIGFyZSBub3QgbmVlZGVkLlxuICAvLyBXZSBkZWxheSBpdHMgcmVtb3ZhbCBpbiBjYXNlIHRoZXJlIGFyZSBzdWJzZXF1ZW50IGNhbGxzIHRvIHRoaXMgZnVuY3Rpb25cbiAgLy8gdGhhdCBjYW4gcmV1c2UgdGhlIHN2ZyBub2Rlcy5cbiAgLy8gRXhwZXJpbWVudHMgaGF2ZSBzaG93biB0aGF0IHJldXNpbmcgZXhpc3Rpbmcgbm9kZXNcbiAgLy8gaW5zdGVhZCBvZiBkZWxldGluZyBhbmQgYWRkaW5nIG5ldyBvbmVzIGNhbiBzYXZlIGxvdCBvZiB0aW1lLlxuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICB0ZXh0RmFjdG9yeS5yZW1vdmVGcm9tQ29udGFpbmVyKHN2Z05vZGUpO1xuICAgIGhpZGRlblN2Z0ZhY3RvcnkucmVtb3ZlRnJvbUNvbnRhaW5lcihjb250YWluZXIpO1xuICB9LCA1MDApO1xuXG4gIHJldHVybiBkaW1lbnNpb247XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBWUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7OztBQ2hEQTtBQUVBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNkQTtBQVdBO0FBVkE7QUFXQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hDQTtBQUNBOzs7QUNEQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7OztBQ2JBO0FBRUE7QUFDQTtBQUNBOzs7QUNKQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7QUNKQTtBQUNBO0FBQ0E7QUFTQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1384\n")},1385:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"a\", function() { return /* binding */ createXYChartLayoutWithTheme; });\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react/index.js\nvar react = __webpack_require__(0);\nvar react_default = /*#__PURE__*/__webpack_require__.n(react);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/axis/XAxis.js\nvar XAxis = __webpack_require__(2338);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/axis/YAxis.js\nvar YAxis = __webpack_require__(2339);\n\n// CONCATENATED MODULE: ../superset-ui-dimension/src/mergeMargin.ts\nfunction mergeOneSide(operation, a = 0, b = 0) {\n    if (Number.isNaN(a) || a === null)\n        return b;\n    if (Number.isNaN(b) || b === null)\n        return a;\n    return operation(a, b);\n}\nfunction mergeMargin(margin1 = {}, margin2 = {}, mode = 'expand') {\n    const { top, left, bottom, right } = margin1;\n    const operation = mode === 'expand' ? Math.max : Math.min;\n    return {\n        bottom: mergeOneSide(operation, bottom, margin2.bottom),\n        left: mergeOneSide(operation, left, margin2.left),\n        right: mergeOneSide(operation, right, margin2.right),\n        top: mergeOneSide(operation, top, margin2.top),\n    };\n}\n\n// EXTERNAL MODULE: ../superset-ui-core/src/utils/isDefined.ts\nvar isDefined = __webpack_require__(1262);\n\n// CONCATENATED MODULE: ../superset-ui-chart-composition/src/ChartFrame.tsx\n\n\nfunction checkNumber(input) {\n    return Object(isDefined[\"a\" /* default */])(input) && typeof input === 'number';\n}\nclass ChartFrame_ChartFrame extends react[\"PureComponent\"] {\n    render() {\n        const { contentWidth, contentHeight, width, height, renderContent } = this.props;\n        const overflowX = checkNumber(contentWidth) && contentWidth > width;\n        const overflowY = checkNumber(contentHeight) && contentHeight > height;\n        if (overflowX || overflowY) {\n            return (react_default.a.createElement(\"div\", { style: {\n                    height,\n                    overflowX: overflowX ? 'auto' : 'hidden',\n                    overflowY: overflowY ? 'auto' : 'hidden',\n                    width,\n                } }, renderContent({\n                height: Math.max(contentHeight !== null && contentHeight !== void 0 ? contentHeight : 0, height),\n                width: Math.max(contentWidth !== null && contentWidth !== void 0 ? contentWidth : 0, width),\n            })));\n        }\n        return renderContent({ height, width });\n    }\n}\nChartFrame_ChartFrame.defaultProps = {\n    renderContent() { },\n};\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/utils/createTickComponent.tsx\nvar __rest = (undefined && undefined.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n\nfunction createTickComponent({ axisWidth, labelAngle, labelFlush, labelOverlap, orient, tickLabels, tickLabelDimensions, tickTextAnchor = 'middle', }) {\n    if (labelOverlap === 'rotate' && labelAngle !== 0) {\n        let xOffset = labelAngle > 0 ? -6 : 6;\n        if (orient === 'top') {\n            xOffset = 0;\n        }\n        const yOffset = orient === 'top' ? -3 : 0;\n        return (_a) => {\n            var { x, y, dy, formattedValue = '' } = _a, textStyle = __rest(_a, [\"x\", \"y\", \"dy\", \"formattedValue\"]);\n            return (react_default.a.createElement(\"g\", { transform: `translate(${x + xOffset}, ${y + yOffset})` },\n                react_default.a.createElement(\"text\", Object.assign({ transform: `rotate(${labelAngle})` }, textStyle, { textAnchor: tickTextAnchor }), formattedValue)));\n        };\n    }\n    if (labelFlush === true || typeof labelFlush === 'number') {\n        const labelToDimensionMap = new Map();\n        tickLabels.forEach((label, i) => {\n            labelToDimensionMap.set(label, tickLabelDimensions[i]);\n        });\n        return (_a) => {\n            var { x, y, dy, formattedValue = '' } = _a, textStyle = __rest(_a, [\"x\", \"y\", \"dy\", \"formattedValue\"]);\n            const dimension = labelToDimensionMap.get(formattedValue);\n            const labelWidth = typeof dimension === 'undefined' ? 0 : dimension.width;\n            let textAnchor = tickTextAnchor;\n            let xOffset = 0;\n            if (x - labelWidth / 2 < 0) {\n                textAnchor = 'start';\n                if (typeof labelFlush === 'number') {\n                    xOffset -= labelFlush;\n                }\n            }\n            else if (x + labelWidth / 2 > axisWidth) {\n                textAnchor = 'end';\n                if (typeof labelFlush === 'number') {\n                    xOffset += labelFlush;\n                }\n            }\n            return (react_default.a.createElement(\"text\", Object.assign({ x: x + xOffset, y: y }, textStyle, { textAnchor: textAnchor }), formattedValue));\n        };\n    }\n    // This will render the tick as horizontal string.\n    return null;\n}\n\n// EXTERNAL MODULE: ../superset-ui-dimension/src/getTextDimension.ts + 7 modules\nvar getTextDimension = __webpack_require__(1384);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/utils/computeAxisLayout.ts\n\nfunction computeAxisLayout(axis, { axisTitleHeight = 20, axisWidth, gapBetweenAxisLabelAndBorder = 4, gapBetweenTickAndTickLabel = 4, defaultTickSize = 8, tickTextStyle = {}, }) {\n    const tickLabels = axis.getTickLabels();\n    const tickLabelDimensions = tickLabels.map((text) => Object(getTextDimension[\"a\" /* default */])({\n        style: tickTextStyle,\n        text,\n    }));\n    const { labelAngle, labelFlush, labelOverlap, labelPadding, orient, tickSize = defaultTickSize, } = axis.config;\n    const maxWidth = Math.max(...tickLabelDimensions.map(d => d.width), 0);\n    // cheap heuristic, can improve\n    const widthPerTick = axisWidth / tickLabels.length;\n    const isLabelOverlap = maxWidth > widthPerTick;\n    const labelAngleIfOverlap = labelOverlap.strategy === 'rotate' ? labelOverlap.labelAngle : 0;\n    const labelAngleAfterOverlapCheck = isLabelOverlap ? labelAngleIfOverlap : 0;\n    const finalLabelAngle = labelAngle === 0 ? labelAngleAfterOverlapCheck : labelAngle;\n    const spaceForAxisTitle = axis.hasTitle() ? labelPadding + axisTitleHeight : 0;\n    let tickTextAnchor = 'middle';\n    let labelOffset = 0;\n    let requiredMargin = tickSize + gapBetweenTickAndTickLabel + spaceForAxisTitle + gapBetweenAxisLabelAndBorder;\n    if (axis.channelEncoder.isX()) {\n        if (finalLabelAngle === 0) {\n            const labelHeight = tickLabelDimensions.length > 0 ? tickLabelDimensions[0].height : 0;\n            labelOffset = labelHeight + labelPadding;\n            requiredMargin += labelHeight;\n        }\n        else {\n            const labelHeight = Math.ceil(Math.abs(maxWidth * Math.sin((finalLabelAngle * Math.PI) / 180)));\n            labelOffset = labelHeight + labelPadding;\n            requiredMargin += labelHeight;\n            tickTextAnchor =\n                (orient === 'top' && finalLabelAngle > 0) || (orient === 'bottom' && finalLabelAngle < 0)\n                    ? 'end'\n                    : 'start';\n        }\n        requiredMargin += 8;\n    }\n    else {\n        labelOffset = maxWidth + spaceForAxisTitle;\n        requiredMargin += maxWidth;\n    }\n    return {\n        axisWidth,\n        labelAngle: finalLabelAngle,\n        labelFlush,\n        labelOffset,\n        labelOverlap: isLabelOverlap ? labelOverlap.strategy : 'flat',\n        minMargin: {\n            [orient]: Math.ceil(requiredMargin),\n        },\n        orient,\n        tickLabelDimensions,\n        tickLabels,\n        tickTextAnchor,\n    };\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/utils/XYChartLayout.tsx\n\n\n\n\n\n\nconst DEFAULT_LABEL_ANGLE = 40;\n// Additional margin to avoid content hidden behind scroll bar\nconst OVERFLOW_MARGIN = 8;\nclass XYChartLayout_XYChartLayout {\n    constructor(config) {\n        const { width, height, minContentWidth = 0, minContentHeight = 0, margin, xEncoder, xTickSize, xTickTextStyle, autoAdjustXMargin = true, yEncoder, yTickSize, yTickTextStyle, autoAdjustYMargin = true, } = config;\n        this.xEncoder = xEncoder;\n        this.yEncoder = yEncoder;\n        if (typeof yEncoder.axis !== 'undefined') {\n            this.yLayout = computeAxisLayout(yEncoder.axis, {\n                axisWidth: Math.max(height - margin.top - margin.bottom),\n                defaultTickSize: yTickSize,\n                tickTextStyle: yTickTextStyle,\n            });\n        }\n        const secondMargin = this.yLayout && autoAdjustYMargin ? mergeMargin(margin, this.yLayout.minMargin) : margin;\n        const innerWidth = Math.max(width - secondMargin.left - secondMargin.right, minContentWidth);\n        if (typeof xEncoder.axis !== 'undefined') {\n            this.xLayout = computeAxisLayout(xEncoder.axis, {\n                axisWidth: innerWidth,\n                defaultTickSize: xTickSize,\n                tickTextStyle: xTickTextStyle,\n            });\n        }\n        const finalMargin = this.xLayout && autoAdjustXMargin\n            ? mergeMargin(secondMargin, this.xLayout.minMargin)\n            : secondMargin;\n        const innerHeight = Math.max(height - finalMargin.top - finalMargin.bottom, minContentHeight);\n        const chartWidth = Math.round(innerWidth + finalMargin.left + finalMargin.right);\n        const chartHeight = Math.round(innerHeight + finalMargin.top + finalMargin.bottom);\n        const isOverFlowX = chartWidth > width;\n        const isOverFlowY = chartHeight > height;\n        if (isOverFlowX) {\n            finalMargin.bottom += OVERFLOW_MARGIN;\n        }\n        if (isOverFlowY) {\n            finalMargin.right += OVERFLOW_MARGIN;\n        }\n        this.chartWidth = isOverFlowX ? chartWidth + OVERFLOW_MARGIN : chartWidth;\n        this.chartHeight = isOverFlowY ? chartHeight + OVERFLOW_MARGIN : chartHeight;\n        this.containerWidth = width;\n        this.containerHeight = height;\n        this.margin = finalMargin;\n    }\n    renderChartWithFrame(renderChart) {\n        return (react_default.a.createElement(ChartFrame_ChartFrame, { width: this.containerWidth, height: this.containerHeight, contentWidth: this.chartWidth, contentHeight: this.chartHeight, renderContent: renderChart }));\n    }\n    renderXAxis(props) {\n        const { axis } = this.xEncoder;\n        return axis && this.xLayout ? (react_default.a.createElement(XAxis[\"a\" /* default */], Object.assign({ label: axis.getTitle(), labelOffset: this.xLayout.labelOffset, numTicks: axis.config.tickCount, orientation: axis.config.orient, tickComponent: createTickComponent(this.xLayout), tickFormat: axis.formatValue }, props))) : null;\n    }\n    renderYAxis(props) {\n        const { axis } = this.yEncoder;\n        return axis && this.yLayout ? (react_default.a.createElement(YAxis[\"a\" /* default */], Object.assign({ label: axis.getTitle(), labelOffset: this.yLayout.labelOffset, numTicks: axis.config.tickCount, orientation: axis.config.orient, tickFormat: axis.formatValue }, props))) : null;\n    }\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/utils/createXYChartLayoutWithTheme.ts\nvar createXYChartLayoutWithTheme_rest = (undefined && undefined.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n\nfunction createXYChartLayoutWithTheme(config) {\n    const { theme } = config, rest = createXYChartLayoutWithTheme_rest(config, [\"theme\"]);\n    return new XYChartLayout_XYChartLayout(Object.assign(Object.assign({}, rest), { \n        // @ts-ignore\n        xTickSize: theme.xTickStyles.length || theme.xTickStyles.tickLength, xTickTextStyle: theme.xTickStyles.label.bottom || theme.xTickStyles.label.top, \n        // @ts-ignore\n        yTickSize: theme.yTickStyles.length || theme.yTickStyles.tickLength, yTickTextStyle: theme.yTickStyles.label.left || theme.yTickStyles.label.right }));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM4NS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9zdXBlcnNldC11aS1kaW1lbnNpb24vc3JjL21lcmdlTWFyZ2luLnRzPzM0NjYiLCJ3ZWJwYWNrOi8vLy4uL3N1cGVyc2V0LXVpLWNoYXJ0LWNvbXBvc2l0aW9uL3NyYy9DaGFydEZyYW1lLnRzeD9lY2MwIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wcmVzZXQtY2hhcnQteHkvc3JjL3V0aWxzL2NyZWF0ZVRpY2tDb21wb25lbnQudHN4P2UxOWQiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9wbHVnaW5zL3ByZXNldC1jaGFydC14eS9zcmMvdXRpbHMvY29tcHV0ZUF4aXNMYXlvdXQudHM/Yjk2ZCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvcHJlc2V0LWNoYXJ0LXh5L3NyYy91dGlscy9YWUNoYXJ0TGF5b3V0LnRzeD83YzZmIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wcmVzZXQtY2hhcnQteHkvc3JjL3V0aWxzL2NyZWF0ZVhZQ2hhcnRMYXlvdXRXaXRoVGhlbWUudHM/ZDI4OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNYXJnaW4gfSBmcm9tICcuL3R5cGVzJztcblxuZnVuY3Rpb24gbWVyZ2VPbmVTaWRlKG9wZXJhdGlvbjogKGE6IG51bWJlciwgYjogbnVtYmVyKSA9PiBudW1iZXIsIGE6IG51bWJlciA9IDAsIGI6IG51bWJlciA9IDApIHtcbiAgaWYgKE51bWJlci5pc05hTihhKSB8fCBhID09PSBudWxsKSByZXR1cm4gYjtcbiAgaWYgKE51bWJlci5pc05hTihiKSB8fCBiID09PSBudWxsKSByZXR1cm4gYTtcblxuICByZXR1cm4gb3BlcmF0aW9uKGEsIGIpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtZXJnZU1hcmdpbihcbiAgbWFyZ2luMTogUGFydGlhbDxNYXJnaW4+ID0ge30sXG4gIG1hcmdpbjI6IFBhcnRpYWw8TWFyZ2luPiA9IHt9LFxuICBtb2RlOiAnZXhwYW5kJyB8ICdzaHJpbmsnID0gJ2V4cGFuZCcsXG4pIHtcbiAgY29uc3QgeyB0b3AsIGxlZnQsIGJvdHRvbSwgcmlnaHQgfSA9IG1hcmdpbjE7XG4gIGNvbnN0IG9wZXJhdGlvbiA9IG1vZGUgPT09ICdleHBhbmQnID8gTWF0aC5tYXggOiBNYXRoLm1pbjtcblxuICByZXR1cm4ge1xuICAgIGJvdHRvbTogbWVyZ2VPbmVTaWRlKG9wZXJhdGlvbiwgYm90dG9tLCBtYXJnaW4yLmJvdHRvbSksXG4gICAgbGVmdDogbWVyZ2VPbmVTaWRlKG9wZXJhdGlvbiwgbGVmdCwgbWFyZ2luMi5sZWZ0KSxcbiAgICByaWdodDogbWVyZ2VPbmVTaWRlKG9wZXJhdGlvbiwgcmlnaHQsIG1hcmdpbjIucmlnaHQpLFxuICAgIHRvcDogbWVyZ2VPbmVTaWRlKG9wZXJhdGlvbiwgdG9wLCBtYXJnaW4yLnRvcCksXG4gIH07XG59XG4iLCJpbXBvcnQgUmVhY3QsIHsgUHVyZUNvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGlzRGVmaW5lZCB9IGZyb20gJ0BzdXBlcnNldC11aS9jb3JlJztcblxuZnVuY3Rpb24gY2hlY2tOdW1iZXIoaW5wdXQ6IHVua25vd24pOiBpbnB1dCBpcyBudW1iZXIge1xuICByZXR1cm4gaXNEZWZpbmVkKGlucHV0KSAmJiB0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInO1xufVxuXG50eXBlIFByb3BzID0ge1xuICBjb250ZW50V2lkdGg/OiBudW1iZXI7XG4gIGNvbnRlbnRIZWlnaHQ/OiBudW1iZXI7XG4gIGhlaWdodDogbnVtYmVyO1xuICByZW5kZXJDb250ZW50OiAoeyBoZWlnaHQsIHdpZHRoIH06IHsgaGVpZ2h0OiBudW1iZXI7IHdpZHRoOiBudW1iZXIgfSkgPT4gUmVhY3QuUmVhY3ROb2RlO1xuICB3aWR0aDogbnVtYmVyO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2hhcnRGcmFtZSBleHRlbmRzIFB1cmVDb21wb25lbnQ8UHJvcHMsIHt9PiB7XG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgcmVuZGVyQ29udGVudCgpIHt9LFxuICB9O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGNvbnRlbnRXaWR0aCwgY29udGVudEhlaWdodCwgd2lkdGgsIGhlaWdodCwgcmVuZGVyQ29udGVudCB9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnN0IG92ZXJmbG93WCA9IGNoZWNrTnVtYmVyKGNvbnRlbnRXaWR0aCkgJiYgY29udGVudFdpZHRoID4gd2lkdGg7XG4gICAgY29uc3Qgb3ZlcmZsb3dZID0gY2hlY2tOdW1iZXIoY29udGVudEhlaWdodCkgJiYgY29udGVudEhlaWdodCA+IGhlaWdodDtcblxuICAgIGlmIChvdmVyZmxvd1ggfHwgb3ZlcmZsb3dZKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2XG4gICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgIG92ZXJmbG93WDogb3ZlcmZsb3dYID8gJ2F1dG8nIDogJ2hpZGRlbicsXG4gICAgICAgICAgICBvdmVyZmxvd1k6IG92ZXJmbG93WSA/ICdhdXRvJyA6ICdoaWRkZW4nLFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgfX1cbiAgICAgICAgPlxuICAgICAgICAgIHtyZW5kZXJDb250ZW50KHtcbiAgICAgICAgICAgIGhlaWdodDogTWF0aC5tYXgoY29udGVudEhlaWdodCA/PyAwLCBoZWlnaHQpLFxuICAgICAgICAgICAgd2lkdGg6IE1hdGgubWF4KGNvbnRlbnRXaWR0aCA/PyAwLCB3aWR0aCksXG4gICAgICAgICAgfSl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVuZGVyQ29udGVudCh7IGhlaWdodCwgd2lkdGggfSk7XG4gIH1cbn1cbiIsImltcG9ydCBSZWFjdCwgeyBDU1NQcm9wZXJ0aWVzIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgRGltZW5zaW9uIH0gZnJvbSAnQHN1cGVyc2V0LXVpL2RpbWVuc2lvbic7XG5pbXBvcnQgeyBBeGlzTGF5b3V0IH0gZnJvbSAnLi9jb21wdXRlQXhpc0xheW91dCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZVRpY2tDb21wb25lbnQoe1xuICBheGlzV2lkdGgsXG4gIGxhYmVsQW5nbGUsXG4gIGxhYmVsRmx1c2gsXG4gIGxhYmVsT3ZlcmxhcCxcbiAgb3JpZW50LFxuICB0aWNrTGFiZWxzLFxuICB0aWNrTGFiZWxEaW1lbnNpb25zLFxuICB0aWNrVGV4dEFuY2hvciA9ICdtaWRkbGUnLFxufTogQXhpc0xheW91dCkge1xuICBpZiAobGFiZWxPdmVybGFwID09PSAncm90YXRlJyAmJiBsYWJlbEFuZ2xlICE9PSAwKSB7XG4gICAgbGV0IHhPZmZzZXQgPSBsYWJlbEFuZ2xlID4gMCA/IC02IDogNjtcbiAgICBpZiAob3JpZW50ID09PSAndG9wJykge1xuICAgICAgeE9mZnNldCA9IDA7XG4gICAgfVxuICAgIGNvbnN0IHlPZmZzZXQgPSBvcmllbnQgPT09ICd0b3AnID8gLTMgOiAwO1xuXG4gICAgcmV0dXJuICh7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIGR5LFxuICAgICAgZm9ybWF0dGVkVmFsdWUgPSAnJyxcbiAgICAgIC4uLnRleHRTdHlsZVxuICAgIH06IHtcbiAgICAgIHg6IG51bWJlcjtcbiAgICAgIHk6IG51bWJlcjtcbiAgICAgIGR5PzogbnVtYmVyO1xuICAgICAgZm9ybWF0dGVkVmFsdWU6IHN0cmluZztcbiAgICAgIHRleHRTdHlsZTogQ1NTUHJvcGVydGllcztcbiAgICB9KSA9PiAoXG4gICAgICA8ZyB0cmFuc2Zvcm09e2B0cmFuc2xhdGUoJHt4ICsgeE9mZnNldH0sICR7eSArIHlPZmZzZXR9KWB9PlxuICAgICAgICA8dGV4dCB0cmFuc2Zvcm09e2Byb3RhdGUoJHtsYWJlbEFuZ2xlfSlgfSB7Li4udGV4dFN0eWxlfSB0ZXh0QW5jaG9yPXt0aWNrVGV4dEFuY2hvcn0+XG4gICAgICAgICAge2Zvcm1hdHRlZFZhbHVlfVxuICAgICAgICA8L3RleHQ+XG4gICAgICA8L2c+XG4gICAgKTtcbiAgfVxuXG4gIGlmIChsYWJlbEZsdXNoID09PSB0cnVlIHx8IHR5cGVvZiBsYWJlbEZsdXNoID09PSAnbnVtYmVyJykge1xuICAgIGNvbnN0IGxhYmVsVG9EaW1lbnNpb25NYXAgPSBuZXcgTWFwPHN0cmluZywgRGltZW5zaW9uPigpO1xuICAgIHRpY2tMYWJlbHMuZm9yRWFjaCgobGFiZWwsIGkpID0+IHtcbiAgICAgIGxhYmVsVG9EaW1lbnNpb25NYXAuc2V0KGxhYmVsLCB0aWNrTGFiZWxEaW1lbnNpb25zW2ldKTtcbiAgICB9KTtcblxuICAgIHJldHVybiAoe1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBkeSxcbiAgICAgIGZvcm1hdHRlZFZhbHVlID0gJycsXG4gICAgICAuLi50ZXh0U3R5bGVcbiAgICB9OiB7XG4gICAgICB4OiBudW1iZXI7XG4gICAgICB5OiBudW1iZXI7XG4gICAgICBkeT86IG51bWJlcjtcbiAgICAgIGZvcm1hdHRlZFZhbHVlOiBzdHJpbmc7XG4gICAgICB0ZXh0U3R5bGU6IENTU1Byb3BlcnRpZXM7XG4gICAgfSkgPT4ge1xuICAgICAgY29uc3QgZGltZW5zaW9uID0gbGFiZWxUb0RpbWVuc2lvbk1hcC5nZXQoZm9ybWF0dGVkVmFsdWUpO1xuICAgICAgY29uc3QgbGFiZWxXaWR0aCA9IHR5cGVvZiBkaW1lbnNpb24gPT09ICd1bmRlZmluZWQnID8gMCA6IGRpbWVuc2lvbi53aWR0aDtcbiAgICAgIGxldCB0ZXh0QW5jaG9yID0gdGlja1RleHRBbmNob3I7XG4gICAgICBsZXQgeE9mZnNldCA9IDA7XG5cbiAgICAgIGlmICh4IC0gbGFiZWxXaWR0aCAvIDIgPCAwKSB7XG4gICAgICAgIHRleHRBbmNob3IgPSAnc3RhcnQnO1xuICAgICAgICBpZiAodHlwZW9mIGxhYmVsRmx1c2ggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgeE9mZnNldCAtPSBsYWJlbEZsdXNoO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHggKyBsYWJlbFdpZHRoIC8gMiA+IGF4aXNXaWR0aCkge1xuICAgICAgICB0ZXh0QW5jaG9yID0gJ2VuZCc7XG4gICAgICAgIGlmICh0eXBlb2YgbGFiZWxGbHVzaCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICB4T2Zmc2V0ICs9IGxhYmVsRmx1c2g7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIChcbiAgICAgICAgPHRleHQgeD17eCArIHhPZmZzZXR9IHk9e3l9IHsuLi50ZXh0U3R5bGV9IHRleHRBbmNob3I9e3RleHRBbmNob3J9PlxuICAgICAgICAgIHtmb3JtYXR0ZWRWYWx1ZX1cbiAgICAgICAgPC90ZXh0PlxuICAgICAgKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gVGhpcyB3aWxsIHJlbmRlciB0aGUgdGljayBhcyBob3Jpem9udGFsIHN0cmluZy5cbiAgcmV0dXJuIG51bGw7XG59XG4iLCJpbXBvcnQgeyBDU1NQcm9wZXJ0aWVzIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZ2V0VGV4dERpbWVuc2lvbiwgTWFyZ2luLCBEaW1lbnNpb24gfSBmcm9tICdAc3VwZXJzZXQtdWkvZGltZW5zaW9uJztcbmltcG9ydCB7IEF4aXNPcmllbnQsIENoYW5uZWxEZWYsIFZhbHVlIH0gZnJvbSAnZW5jb2RhYmxlJztcblxuaW1wb3J0IENoYW5uZWxFbmNvZGVyQXhpcyBmcm9tICdlbmNvZGFibGUvbGliL2VuY29kZXJzL0NoYW5uZWxFbmNvZGVyQXhpcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXhpc0xheW91dCB7XG4gIGF4aXNXaWR0aDogbnVtYmVyO1xuICBsYWJlbEFuZ2xlOiBudW1iZXI7XG4gIGxhYmVsRmx1c2g6IG51bWJlciB8IGJvb2xlYW47XG4gIGxhYmVsT2Zmc2V0OiBudW1iZXI7XG4gIGxhYmVsT3ZlcmxhcDogJ2ZsYXQnIHwgJ3JvdGF0ZSc7XG4gIG1pbk1hcmdpbjogUGFydGlhbDxNYXJnaW4+O1xuICBvcmllbnQ6IEF4aXNPcmllbnQ7XG4gIHRpY2tMYWJlbERpbWVuc2lvbnM6IERpbWVuc2lvbltdO1xuICB0aWNrTGFiZWxzOiBzdHJpbmdbXTtcbiAgdGlja1RleHRBbmNob3I/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXB1dGVBeGlzTGF5b3V0PERlZiBleHRlbmRzIENoYW5uZWxEZWY8T3V0cHV0PiwgT3V0cHV0IGV4dGVuZHMgVmFsdWU+KFxuICBheGlzOiBDaGFubmVsRW5jb2RlckF4aXM8RGVmLCBPdXRwdXQ+LFxuICB7XG4gICAgYXhpc1RpdGxlSGVpZ2h0ID0gMjAsXG4gICAgYXhpc1dpZHRoLFxuICAgIGdhcEJldHdlZW5BeGlzTGFiZWxBbmRCb3JkZXIgPSA0LFxuICAgIGdhcEJldHdlZW5UaWNrQW5kVGlja0xhYmVsID0gNCxcbiAgICBkZWZhdWx0VGlja1NpemUgPSA4LFxuICAgIHRpY2tUZXh0U3R5bGUgPSB7fSxcbiAgfToge1xuICAgIGF4aXNUaXRsZUhlaWdodD86IG51bWJlcjtcbiAgICBheGlzV2lkdGg6IG51bWJlcjtcbiAgICBnYXBCZXR3ZWVuQXhpc0xhYmVsQW5kQm9yZGVyPzogbnVtYmVyO1xuICAgIGdhcEJldHdlZW5UaWNrQW5kVGlja0xhYmVsPzogbnVtYmVyO1xuICAgIGRlZmF1bHRUaWNrU2l6ZT86IG51bWJlcjtcbiAgICB0aWNrVGV4dFN0eWxlPzogQ1NTUHJvcGVydGllcztcbiAgfSxcbik6IEF4aXNMYXlvdXQge1xuICBjb25zdCB0aWNrTGFiZWxzID0gYXhpcy5nZXRUaWNrTGFiZWxzKCk7XG4gIGNvbnN0IHRpY2tMYWJlbERpbWVuc2lvbnMgPSB0aWNrTGFiZWxzLm1hcCgodGV4dDogc3RyaW5nKSA9PlxuICAgIGdldFRleHREaW1lbnNpb24oe1xuICAgICAgc3R5bGU6IHRpY2tUZXh0U3R5bGUsXG4gICAgICB0ZXh0LFxuICAgIH0pLFxuICApO1xuXG4gIGNvbnN0IHtcbiAgICBsYWJlbEFuZ2xlLFxuICAgIGxhYmVsRmx1c2gsXG4gICAgbGFiZWxPdmVybGFwLFxuICAgIGxhYmVsUGFkZGluZyxcbiAgICBvcmllbnQsXG4gICAgdGlja1NpemUgPSBkZWZhdWx0VGlja1NpemUsXG4gIH0gPSBheGlzLmNvbmZpZztcblxuICBjb25zdCBtYXhXaWR0aCA9IE1hdGgubWF4KC4uLnRpY2tMYWJlbERpbWVuc2lvbnMubWFwKGQgPT4gZC53aWR0aCksIDApO1xuXG4gIC8vIGNoZWFwIGhldXJpc3RpYywgY2FuIGltcHJvdmVcbiAgY29uc3Qgd2lkdGhQZXJUaWNrID0gYXhpc1dpZHRoIC8gdGlja0xhYmVscy5sZW5ndGg7XG4gIGNvbnN0IGlzTGFiZWxPdmVybGFwID0gbWF4V2lkdGggPiB3aWR0aFBlclRpY2s7XG4gIGNvbnN0IGxhYmVsQW5nbGVJZk92ZXJsYXAgPSBsYWJlbE92ZXJsYXAuc3RyYXRlZ3kgPT09ICdyb3RhdGUnID8gbGFiZWxPdmVybGFwLmxhYmVsQW5nbGUgOiAwO1xuICBjb25zdCBsYWJlbEFuZ2xlQWZ0ZXJPdmVybGFwQ2hlY2sgPSBpc0xhYmVsT3ZlcmxhcCA/IGxhYmVsQW5nbGVJZk92ZXJsYXAgOiAwO1xuICBjb25zdCBmaW5hbExhYmVsQW5nbGUgPSBsYWJlbEFuZ2xlID09PSAwID8gbGFiZWxBbmdsZUFmdGVyT3ZlcmxhcENoZWNrIDogbGFiZWxBbmdsZTtcblxuICBjb25zdCBzcGFjZUZvckF4aXNUaXRsZSA9IGF4aXMuaGFzVGl0bGUoKSA/IGxhYmVsUGFkZGluZyArIGF4aXNUaXRsZUhlaWdodCA6IDA7XG4gIGxldCB0aWNrVGV4dEFuY2hvciA9ICdtaWRkbGUnO1xuICBsZXQgbGFiZWxPZmZzZXQ6IG51bWJlciA9IDA7XG4gIGxldCByZXF1aXJlZE1hcmdpbiA9XG4gICAgdGlja1NpemUgKyBnYXBCZXR3ZWVuVGlja0FuZFRpY2tMYWJlbCArIHNwYWNlRm9yQXhpc1RpdGxlICsgZ2FwQmV0d2VlbkF4aXNMYWJlbEFuZEJvcmRlcjtcblxuICBpZiAoYXhpcy5jaGFubmVsRW5jb2Rlci5pc1goKSkge1xuICAgIGlmIChmaW5hbExhYmVsQW5nbGUgPT09IDApIHtcbiAgICAgIGNvbnN0IGxhYmVsSGVpZ2h0ID0gdGlja0xhYmVsRGltZW5zaW9ucy5sZW5ndGggPiAwID8gdGlja0xhYmVsRGltZW5zaW9uc1swXS5oZWlnaHQgOiAwO1xuICAgICAgbGFiZWxPZmZzZXQgPSBsYWJlbEhlaWdodCArIGxhYmVsUGFkZGluZztcbiAgICAgIHJlcXVpcmVkTWFyZ2luICs9IGxhYmVsSGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsYWJlbEhlaWdodCA9IE1hdGguY2VpbChcbiAgICAgICAgTWF0aC5hYnMobWF4V2lkdGggKiBNYXRoLnNpbigoZmluYWxMYWJlbEFuZ2xlICogTWF0aC5QSSkgLyAxODApKSxcbiAgICAgICk7XG4gICAgICBsYWJlbE9mZnNldCA9IGxhYmVsSGVpZ2h0ICsgbGFiZWxQYWRkaW5nO1xuICAgICAgcmVxdWlyZWRNYXJnaW4gKz0gbGFiZWxIZWlnaHQ7XG4gICAgICB0aWNrVGV4dEFuY2hvciA9XG4gICAgICAgIChvcmllbnQgPT09ICd0b3AnICYmIGZpbmFsTGFiZWxBbmdsZSA+IDApIHx8IChvcmllbnQgPT09ICdib3R0b20nICYmIGZpbmFsTGFiZWxBbmdsZSA8IDApXG4gICAgICAgICAgPyAnZW5kJ1xuICAgICAgICAgIDogJ3N0YXJ0JztcbiAgICB9XG4gICAgcmVxdWlyZWRNYXJnaW4gKz0gODtcbiAgfSBlbHNlIHtcbiAgICBsYWJlbE9mZnNldCA9IG1heFdpZHRoICsgc3BhY2VGb3JBeGlzVGl0bGU7XG4gICAgcmVxdWlyZWRNYXJnaW4gKz0gbWF4V2lkdGg7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGF4aXNXaWR0aCxcbiAgICBsYWJlbEFuZ2xlOiBmaW5hbExhYmVsQW5nbGUsXG4gICAgbGFiZWxGbHVzaCxcbiAgICBsYWJlbE9mZnNldCxcbiAgICBsYWJlbE92ZXJsYXA6IGlzTGFiZWxPdmVybGFwID8gbGFiZWxPdmVybGFwLnN0cmF0ZWd5IDogJ2ZsYXQnLFxuICAgIG1pbk1hcmdpbjoge1xuICAgICAgW29yaWVudF06IE1hdGguY2VpbChyZXF1aXJlZE1hcmdpbiksXG4gICAgfSxcbiAgICBvcmllbnQsXG4gICAgdGlja0xhYmVsRGltZW5zaW9ucyxcbiAgICB0aWNrTGFiZWxzLFxuICAgIHRpY2tUZXh0QW5jaG9yLFxuICB9O1xufVxuIiwiaW1wb3J0IFJlYWN0LCB7IFJlYWN0Tm9kZSwgQ1NTUHJvcGVydGllcyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFhBeGlzLCBZQXhpcyB9IGZyb20gJ0BkYXRhLXVpL3h5LWNoYXJ0JztcbmltcG9ydCB7IE1hcmdpbiwgbWVyZ2VNYXJnaW4sIERpbWVuc2lvbiB9IGZyb20gJ0BzdXBlcnNldC11aS9kaW1lbnNpb24nO1xuaW1wb3J0IHsgQ2hhcnRGcmFtZSB9IGZyb20gJ0BzdXBlcnNldC11aS9jaGFydC1jb21wb3NpdGlvbic7XG5pbXBvcnQgeyBDaGFubmVsRW5jb2RlciwgUGxhaW5PYmplY3QsIFZhbHVlLCBYRmllbGREZWYsIFlGaWVsZERlZiB9IGZyb20gJ2VuY29kYWJsZSc7XG5pbXBvcnQgY3JlYXRlVGlja0NvbXBvbmVudCBmcm9tICcuL2NyZWF0ZVRpY2tDb21wb25lbnQnO1xuaW1wb3J0IGNvbXB1dGVBeGlzTGF5b3V0LCB7IEF4aXNMYXlvdXQgfSBmcm9tICcuL2NvbXB1dGVBeGlzTGF5b3V0JztcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfTEFCRUxfQU5HTEUgPSA0MDtcblxuLy8gQWRkaXRpb25hbCBtYXJnaW4gdG8gYXZvaWQgY29udGVudCBoaWRkZW4gYmVoaW5kIHNjcm9sbCBiYXJcbmNvbnN0IE9WRVJGTE9XX01BUkdJTiA9IDg7XG5cbmV4cG9ydCBpbnRlcmZhY2UgWFlDaGFydExheW91dENvbmZpZzxYT3V0cHV0IGV4dGVuZHMgVmFsdWUsIFlPdXRwdXQgZXh0ZW5kcyBWYWx1ZT4ge1xuICB3aWR0aDogbnVtYmVyO1xuICBoZWlnaHQ6IG51bWJlcjtcbiAgbWluQ29udGVudFdpZHRoPzogbnVtYmVyO1xuICBtaW5Db250ZW50SGVpZ2h0PzogbnVtYmVyO1xuICBtYXJnaW46IE1hcmdpbjtcbiAgeEVuY29kZXI6IENoYW5uZWxFbmNvZGVyPFhGaWVsZERlZjxYT3V0cHV0PiwgWE91dHB1dD47XG4gIHhUaWNrU2l6ZT86IG51bWJlcjtcbiAgeFRpY2tUZXh0U3R5bGU/OiBDU1NQcm9wZXJ0aWVzO1xuICBhdXRvQWRqdXN0WE1hcmdpbj86IGJvb2xlYW47XG4gIHlFbmNvZGVyOiBDaGFubmVsRW5jb2RlcjxZRmllbGREZWY8WU91dHB1dD4sIFlPdXRwdXQ+O1xuICB5VGlja1NpemU/OiBudW1iZXI7XG4gIHlUaWNrVGV4dFN0eWxlPzogQ1NTUHJvcGVydGllcztcbiAgYXV0b0FkanVzdFlNYXJnaW4/OiBib29sZWFuO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBYWUNoYXJ0TGF5b3V0PFhPdXRwdXQgZXh0ZW5kcyBWYWx1ZSwgWU91dHB1dCBleHRlbmRzIFZhbHVlPiB7XG4gIGNoYXJ0V2lkdGg6IG51bWJlcjtcblxuICBjaGFydEhlaWdodDogbnVtYmVyO1xuXG4gIGNvbnRhaW5lcldpZHRoOiBudW1iZXI7XG5cbiAgY29udGFpbmVySGVpZ2h0OiBudW1iZXI7XG5cbiAgbWFyZ2luOiBNYXJnaW47XG5cbiAgeEVuY29kZXI6IENoYW5uZWxFbmNvZGVyPFhGaWVsZERlZjxYT3V0cHV0PiwgWE91dHB1dD47XG5cbiAgeExheW91dD86IEF4aXNMYXlvdXQ7XG5cbiAgeUVuY29kZXI6IENoYW5uZWxFbmNvZGVyPFlGaWVsZERlZjxZT3V0cHV0PiwgWU91dHB1dD47XG5cbiAgeUxheW91dD86IEF4aXNMYXlvdXQ7XG5cbiAgY29uc3RydWN0b3IoY29uZmlnOiBYWUNoYXJ0TGF5b3V0Q29uZmlnPFhPdXRwdXQsIFlPdXRwdXQ+KSB7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBtaW5Db250ZW50V2lkdGggPSAwLFxuICAgICAgbWluQ29udGVudEhlaWdodCA9IDAsXG4gICAgICBtYXJnaW4sXG4gICAgICB4RW5jb2RlcixcbiAgICAgIHhUaWNrU2l6ZSxcbiAgICAgIHhUaWNrVGV4dFN0eWxlLFxuICAgICAgYXV0b0FkanVzdFhNYXJnaW4gPSB0cnVlLFxuICAgICAgeUVuY29kZXIsXG4gICAgICB5VGlja1NpemUsXG4gICAgICB5VGlja1RleHRTdHlsZSxcbiAgICAgIGF1dG9BZGp1c3RZTWFyZ2luID0gdHJ1ZSxcbiAgICB9ID0gY29uZmlnO1xuXG4gICAgdGhpcy54RW5jb2RlciA9IHhFbmNvZGVyO1xuICAgIHRoaXMueUVuY29kZXIgPSB5RW5jb2RlcjtcblxuICAgIGlmICh0eXBlb2YgeUVuY29kZXIuYXhpcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMueUxheW91dCA9IGNvbXB1dGVBeGlzTGF5b3V0KHlFbmNvZGVyLmF4aXMsIHtcbiAgICAgICAgYXhpc1dpZHRoOiBNYXRoLm1heChoZWlnaHQgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbSksXG4gICAgICAgIGRlZmF1bHRUaWNrU2l6ZTogeVRpY2tTaXplLFxuICAgICAgICB0aWNrVGV4dFN0eWxlOiB5VGlja1RleHRTdHlsZSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHNlY29uZE1hcmdpbiA9XG4gICAgICB0aGlzLnlMYXlvdXQgJiYgYXV0b0FkanVzdFlNYXJnaW4gPyBtZXJnZU1hcmdpbihtYXJnaW4sIHRoaXMueUxheW91dC5taW5NYXJnaW4pIDogbWFyZ2luO1xuICAgIGNvbnN0IGlubmVyV2lkdGggPSBNYXRoLm1heCh3aWR0aCAtIHNlY29uZE1hcmdpbi5sZWZ0IC0gc2Vjb25kTWFyZ2luLnJpZ2h0LCBtaW5Db250ZW50V2lkdGgpO1xuXG4gICAgaWYgKHR5cGVvZiB4RW5jb2Rlci5heGlzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy54TGF5b3V0ID0gY29tcHV0ZUF4aXNMYXlvdXQoeEVuY29kZXIuYXhpcywge1xuICAgICAgICBheGlzV2lkdGg6IGlubmVyV2lkdGgsXG4gICAgICAgIGRlZmF1bHRUaWNrU2l6ZTogeFRpY2tTaXplLFxuICAgICAgICB0aWNrVGV4dFN0eWxlOiB4VGlja1RleHRTdHlsZSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGZpbmFsTWFyZ2luID1cbiAgICAgIHRoaXMueExheW91dCAmJiBhdXRvQWRqdXN0WE1hcmdpblxuICAgICAgICA/IG1lcmdlTWFyZ2luKHNlY29uZE1hcmdpbiwgdGhpcy54TGF5b3V0Lm1pbk1hcmdpbilcbiAgICAgICAgOiBzZWNvbmRNYXJnaW47XG5cbiAgICBjb25zdCBpbm5lckhlaWdodCA9IE1hdGgubWF4KGhlaWdodCAtIGZpbmFsTWFyZ2luLnRvcCAtIGZpbmFsTWFyZ2luLmJvdHRvbSwgbWluQ29udGVudEhlaWdodCk7XG5cbiAgICBjb25zdCBjaGFydFdpZHRoID0gTWF0aC5yb3VuZChpbm5lcldpZHRoICsgZmluYWxNYXJnaW4ubGVmdCArIGZpbmFsTWFyZ2luLnJpZ2h0KTtcbiAgICBjb25zdCBjaGFydEhlaWdodCA9IE1hdGgucm91bmQoaW5uZXJIZWlnaHQgKyBmaW5hbE1hcmdpbi50b3AgKyBmaW5hbE1hcmdpbi5ib3R0b20pO1xuXG4gICAgY29uc3QgaXNPdmVyRmxvd1ggPSBjaGFydFdpZHRoID4gd2lkdGg7XG4gICAgY29uc3QgaXNPdmVyRmxvd1kgPSBjaGFydEhlaWdodCA+IGhlaWdodDtcbiAgICBpZiAoaXNPdmVyRmxvd1gpIHtcbiAgICAgIGZpbmFsTWFyZ2luLmJvdHRvbSArPSBPVkVSRkxPV19NQVJHSU47XG4gICAgfVxuICAgIGlmIChpc092ZXJGbG93WSkge1xuICAgICAgZmluYWxNYXJnaW4ucmlnaHQgKz0gT1ZFUkZMT1dfTUFSR0lOO1xuICAgIH1cbiAgICB0aGlzLmNoYXJ0V2lkdGggPSBpc092ZXJGbG93WCA/IGNoYXJ0V2lkdGggKyBPVkVSRkxPV19NQVJHSU4gOiBjaGFydFdpZHRoO1xuICAgIHRoaXMuY2hhcnRIZWlnaHQgPSBpc092ZXJGbG93WSA/IGNoYXJ0SGVpZ2h0ICsgT1ZFUkZMT1dfTUFSR0lOIDogY2hhcnRIZWlnaHQ7XG4gICAgdGhpcy5jb250YWluZXJXaWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuY29udGFpbmVySGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMubWFyZ2luID0gZmluYWxNYXJnaW47XG4gIH1cblxuICByZW5kZXJDaGFydFdpdGhGcmFtZShyZW5kZXJDaGFydDogKGlucHV0OiBEaW1lbnNpb24pID0+IFJlYWN0Tm9kZSkge1xuICAgIHJldHVybiAoXG4gICAgICA8Q2hhcnRGcmFtZVxuICAgICAgICB3aWR0aD17dGhpcy5jb250YWluZXJXaWR0aH1cbiAgICAgICAgaGVpZ2h0PXt0aGlzLmNvbnRhaW5lckhlaWdodH1cbiAgICAgICAgY29udGVudFdpZHRoPXt0aGlzLmNoYXJ0V2lkdGh9XG4gICAgICAgIGNvbnRlbnRIZWlnaHQ9e3RoaXMuY2hhcnRIZWlnaHR9XG4gICAgICAgIHJlbmRlckNvbnRlbnQ9e3JlbmRlckNoYXJ0fVxuICAgICAgLz5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVyWEF4aXMocHJvcHM/OiBQbGFpbk9iamVjdCkge1xuICAgIGNvbnN0IHsgYXhpcyB9ID0gdGhpcy54RW5jb2RlcjtcblxuICAgIHJldHVybiBheGlzICYmIHRoaXMueExheW91dCA/IChcbiAgICAgIDxYQXhpc1xuICAgICAgICBsYWJlbD17YXhpcy5nZXRUaXRsZSgpfVxuICAgICAgICBsYWJlbE9mZnNldD17dGhpcy54TGF5b3V0LmxhYmVsT2Zmc2V0fVxuICAgICAgICBudW1UaWNrcz17YXhpcy5jb25maWcudGlja0NvdW50fVxuICAgICAgICBvcmllbnRhdGlvbj17YXhpcy5jb25maWcub3JpZW50fVxuICAgICAgICB0aWNrQ29tcG9uZW50PXtjcmVhdGVUaWNrQ29tcG9uZW50KHRoaXMueExheW91dCl9XG4gICAgICAgIHRpY2tGb3JtYXQ9e2F4aXMuZm9ybWF0VmFsdWV9XG4gICAgICAgIHsuLi5wcm9wc31cbiAgICAgIC8+XG4gICAgKSA6IG51bGw7XG4gIH1cblxuICByZW5kZXJZQXhpcyhwcm9wcz86IFBsYWluT2JqZWN0KSB7XG4gICAgY29uc3QgeyBheGlzIH0gPSB0aGlzLnlFbmNvZGVyO1xuXG4gICAgcmV0dXJuIGF4aXMgJiYgdGhpcy55TGF5b3V0ID8gKFxuICAgICAgPFlBeGlzXG4gICAgICAgIGxhYmVsPXtheGlzLmdldFRpdGxlKCl9XG4gICAgICAgIGxhYmVsT2Zmc2V0PXt0aGlzLnlMYXlvdXQubGFiZWxPZmZzZXR9XG4gICAgICAgIG51bVRpY2tzPXtheGlzLmNvbmZpZy50aWNrQ291bnR9XG4gICAgICAgIG9yaWVudGF0aW9uPXtheGlzLmNvbmZpZy5vcmllbnR9XG4gICAgICAgIHRpY2tGb3JtYXQ9e2F4aXMuZm9ybWF0VmFsdWV9XG4gICAgICAgIHsuLi5wcm9wc31cbiAgICAgIC8+XG4gICAgKSA6IG51bGw7XG4gIH1cbn1cbiIsImltcG9ydCB7IENoYXJ0VGhlbWUgfSBmcm9tICdAZGF0YS11aS90aGVtZSc7XG5pbXBvcnQgeyBWYWx1ZSB9IGZyb20gJ2VuY29kYWJsZSc7XG5pbXBvcnQgWFlDaGFydExheW91dCwgeyBYWUNoYXJ0TGF5b3V0Q29uZmlnIH0gZnJvbSAnLi9YWUNoYXJ0TGF5b3V0JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlWFlDaGFydExheW91dFdpdGhUaGVtZTxYT3V0cHV0IGV4dGVuZHMgVmFsdWUsIFlPdXRwdXQgZXh0ZW5kcyBWYWx1ZT4oXG4gIGNvbmZpZzogWFlDaGFydExheW91dENvbmZpZzxYT3V0cHV0LCBZT3V0cHV0PiAmIHtcbiAgICB0aGVtZTogQ2hhcnRUaGVtZTtcbiAgfSxcbikge1xuICBjb25zdCB7IHRoZW1lLCAuLi5yZXN0IH0gPSBjb25maWc7XG5cbiAgcmV0dXJuIG5ldyBYWUNoYXJ0TGF5b3V0PFhPdXRwdXQsIFlPdXRwdXQ+KHtcbiAgICAuLi5yZXN0LFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB4VGlja1NpemU6IHRoZW1lLnhUaWNrU3R5bGVzLmxlbmd0aCB8fCB0aGVtZS54VGlja1N0eWxlcy50aWNrTGVuZ3RoLFxuICAgIHhUaWNrVGV4dFN0eWxlOiB0aGVtZS54VGlja1N0eWxlcy5sYWJlbC5ib3R0b20gfHwgdGhlbWUueFRpY2tTdHlsZXMubGFiZWwudG9wLFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB5VGlja1NpemU6IHRoZW1lLnlUaWNrU3R5bGVzLmxlbmd0aCB8fCB0aGVtZS55VGlja1N0eWxlcy50aWNrTGVuZ3RoLFxuICAgIHlUaWNrVGV4dFN0eWxlOiB0aGVtZS55VGlja1N0eWxlcy5sYWJlbC5sZWZ0IHx8IHRoZW1lLnlUaWNrU3R5bGVzLmxhYmVsLnJpZ2h0LFxuICB9KTtcbn1cbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDdkJBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFVQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7O0FBN0JBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNsQkE7QUFJQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFZQTtBQUVBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7Ozs7OztBQ3ZGQTtBQWtCQTtBQWtCQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFTQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBa0JBO0FBbUJBO0FBQ0E7QUFnQkE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFTQTtBQUVBO0FBQ0E7QUFFQTtBQVdBO0FBRUE7QUFDQTtBQUVBO0FBVUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUN6SkE7QUFFQTtBQUtBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUdBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1385\n")},1386:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"a\", function() { return /* binding */ createRenderLegend; });\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react/index.js\nvar react = __webpack_require__(0);\nvar react_default = /*#__PURE__*/__webpack_require__.n(react);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/legend/esm/legends/Legend/LegendItem.js\nvar LegendItem = __webpack_require__(1788);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/legend/esm/legends/Legend/LegendLabel.js\nvar LegendLabel = __webpack_require__(1789);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/components/legend/DefaultLegendItem.tsx\n\n\nconst MARK_SIZE = 8;\nconst MARK_STYLE = { display: 'inline-block' };\nfunction DefaultLegendItem({ group, item, MarkRenderer, LabelRenderer, }) {\n    var _a, _b, _c, _d;\n    return (react_default.a.createElement(LegendItem[\"a\" /* default */], { key: `legend-item-${group.field}-${item.input}`, margin: \"0 5px\" },\n        typeof MarkRenderer === 'undefined' ? (react_default.a.createElement(\"svg\", { width: MARK_SIZE, height: MARK_SIZE, style: MARK_STYLE },\n            react_default.a.createElement(\"circle\", { fill: \n                // @ts-ignore\n                ((_c = (_b = (_a = item.output.color) !== null && _a !== void 0 ? _a : \n                // @ts-ignore\n                item.output.fill) !== null && _b !== void 0 ? _b : \n                // @ts-ignore\n                item.output.stroke) !== null && _c !== void 0 ? _c : '#ccc'), stroke: \n                // @ts-ignore\n                ((_d = item.output.stroke) !== null && _d !== void 0 ? _d : 'none'), r: MARK_SIZE / 2, cx: MARK_SIZE / 2, cy: MARK_SIZE / 2 }))) : (react_default.a.createElement(MarkRenderer, { group: group, item: item })),\n        typeof LabelRenderer === 'undefined' ? (react_default.a.createElement(LegendLabel[\"a\" /* default */], { align: \"left\", margin: \"0 0 0 4px\" }, item.input)) : (react_default.a.createElement(LabelRenderer, { group: group, item: item }))));\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/components/legend/DefaultLegendGroup.tsx\n\n\nconst LEGEND_GROUP_STYLE = {\n    display: 'flex',\n    flexBasis: 'auto',\n    flexDirection: 'row',\n    flexGrow: 1,\n    flexShrink: 1,\n    flexWrap: 'wrap',\n    fontSize: '0.8em',\n    justifyContent: 'flex-end',\n    padding: 8,\n};\nfunction DefaultLegendGroupRenderer({ group, ItemRenderer = DefaultLegendItem, ItemMarkRenderer, ItemLabelRenderer, style, }) {\n    const combinedStyle = typeof style === 'undefined' ? LEGEND_GROUP_STYLE : Object.assign(Object.assign({}, LEGEND_GROUP_STYLE), style);\n    return (react_default.a.createElement(\"div\", { style: combinedStyle }, 'items' in group &&\n        group.items.map(item => (react_default.a.createElement(ItemRenderer, { key: `legend-item-${group.field}-${item.input}`, group: group, item: item, MarkRenderer: ItemMarkRenderer, LabelRenderer: ItemLabelRenderer })))));\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/components/legend/DefaultLegend.tsx\n\n\nconst LEGEND_CONTAINER_STYLE = {\n    display: 'flex',\n    flexBasis: 'auto',\n    flexGrow: 1,\n    flexShrink: 1,\n    maxHeight: 100,\n    overflowY: 'auto',\n    position: 'relative',\n};\nclass DefaultLegend_DefaultLegend extends react[\"PureComponent\"] {\n    render() {\n        const { groups, LegendGroupRenderer = DefaultLegendGroupRenderer, LegendItemRenderer, LegendItemMarkRenderer, LegendItemLabelRenderer, style, } = this.props;\n        const combinedStyle = typeof style === 'undefined'\n            ? LEGEND_CONTAINER_STYLE\n            : Object.assign(Object.assign({}, LEGEND_CONTAINER_STYLE), style);\n        return (react_default.a.createElement(\"div\", { style: combinedStyle }, groups\n            .filter(group => 'items' in group && group.items.length > 0)\n            .map(group => (react_default.a.createElement(LegendGroupRenderer, { key: group.field, group: group, ItemRenderer: LegendItemRenderer, ItemMarkRenderer: LegendItemMarkRenderer, ItemLabelRenderer: LegendItemLabelRenderer })))));\n    }\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/components/legend/createRenderLegend.tsx\n\n\nfunction createRenderLegend(encoder, data, props) {\n    if (encoder.hasLegend()) {\n        const { LegendRenderer = DefaultLegend_DefaultLegend, LegendGroupRenderer, LegendItemRenderer, LegendItemLabelRenderer, LegendItemMarkRenderer, } = props;\n        return () => (react_default.a.createElement(LegendRenderer, { groups: encoder.getLegendInformation(data), LegendGroupRenderer: LegendGroupRenderer, LegendItemRenderer: LegendItemRenderer, LegendItemMarkRenderer: LegendItemMarkRenderer, LegendItemLabelRenderer: LegendItemLabelRenderer }));\n    }\n    return undefined;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM4Ni5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wcmVzZXQtY2hhcnQteHkvc3JjL2NvbXBvbmVudHMvbGVnZW5kL0RlZmF1bHRMZWdlbmRJdGVtLnRzeD9hMTZmIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wcmVzZXQtY2hhcnQteHkvc3JjL2NvbXBvbmVudHMvbGVnZW5kL0RlZmF1bHRMZWdlbmRHcm91cC50c3g/NWM4MSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvcHJlc2V0LWNoYXJ0LXh5L3NyYy9jb21wb25lbnRzL2xlZ2VuZC9EZWZhdWx0TGVnZW5kLnRzeD9jMzA1Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wcmVzZXQtY2hhcnQteHkvc3JjL2NvbXBvbmVudHMvbGVnZW5kL2NyZWF0ZVJlbmRlckxlZ2VuZC50c3g/YTk1NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgQ1NTUHJvcGVydGllcyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IExlZ2VuZEl0ZW0sIExlZ2VuZExhYmVsIH0gZnJvbSAnQHZ4L2xlZ2VuZCc7XG5pbXBvcnQgeyBFbmNvZGluZ0NvbmZpZyB9IGZyb20gJ2VuY29kYWJsZSc7XG5pbXBvcnQgeyBMZWdlbmRJdGVtUmVuZGVyZXJQcm9wcyB9IGZyb20gJy4vdHlwZXMnO1xuXG5jb25zdCBNQVJLX1NJWkUgPSA4O1xuXG5jb25zdCBNQVJLX1NUWUxFOiBDU1NQcm9wZXJ0aWVzID0geyBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyB9O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEZWZhdWx0TGVnZW5kSXRlbTxDb25maWcgZXh0ZW5kcyBFbmNvZGluZ0NvbmZpZz4oe1xuICBncm91cCxcbiAgaXRlbSxcbiAgTWFya1JlbmRlcmVyLFxuICBMYWJlbFJlbmRlcmVyLFxufTogTGVnZW5kSXRlbVJlbmRlcmVyUHJvcHM8Q29uZmlnPikge1xuICByZXR1cm4gKFxuICAgIDxMZWdlbmRJdGVtIGtleT17YGxlZ2VuZC1pdGVtLSR7Z3JvdXAuZmllbGR9LSR7aXRlbS5pbnB1dH1gfSBtYXJnaW49XCIwIDVweFwiPlxuICAgICAge3R5cGVvZiBNYXJrUmVuZGVyZXIgPT09ICd1bmRlZmluZWQnID8gKFxuICAgICAgICA8c3ZnIHdpZHRoPXtNQVJLX1NJWkV9IGhlaWdodD17TUFSS19TSVpFfSBzdHlsZT17TUFSS19TVFlMRX0+XG4gICAgICAgICAgPGNpcmNsZVxuICAgICAgICAgICAgZmlsbD17XG4gICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgKGl0ZW0ub3V0cHV0LmNvbG9yID8/XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGl0ZW0ub3V0cHV0LmZpbGwgPz9cbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgaXRlbS5vdXRwdXQuc3Ryb2tlID8/XG4gICAgICAgICAgICAgICAgJyNjY2MnKSBhcyBzdHJpbmdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cm9rZT17XG4gICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgKGl0ZW0ub3V0cHV0LnN0cm9rZSA/PyAnbm9uZScpIGFzIHN0cmluZ1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcj17TUFSS19TSVpFIC8gMn1cbiAgICAgICAgICAgIGN4PXtNQVJLX1NJWkUgLyAyfVxuICAgICAgICAgICAgY3k9e01BUktfU0laRSAvIDJ9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9zdmc+XG4gICAgICApIDogKFxuICAgICAgICA8TWFya1JlbmRlcmVyIGdyb3VwPXtncm91cH0gaXRlbT17aXRlbX0gLz5cbiAgICAgICl9XG4gICAgICB7dHlwZW9mIExhYmVsUmVuZGVyZXIgPT09ICd1bmRlZmluZWQnID8gKFxuICAgICAgICA8TGVnZW5kTGFiZWwgYWxpZ249XCJsZWZ0XCIgbWFyZ2luPVwiMCAwIDAgNHB4XCI+XG4gICAgICAgICAge2l0ZW0uaW5wdXR9XG4gICAgICAgIDwvTGVnZW5kTGFiZWw+XG4gICAgICApIDogKFxuICAgICAgICA8TGFiZWxSZW5kZXJlciBncm91cD17Z3JvdXB9IGl0ZW09e2l0ZW19IC8+XG4gICAgICApfVxuICAgIDwvTGVnZW5kSXRlbT5cbiAgKTtcbn1cbiIsImltcG9ydCBSZWFjdCwgeyBDU1NQcm9wZXJ0aWVzIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgRW5jb2RpbmdDb25maWcgfSBmcm9tICdlbmNvZGFibGUnO1xuaW1wb3J0IHsgTGVnZW5kR3JvdXBSZW5kZXJlclByb3BzIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgRGVmYXVsdExlZ2VuZEl0ZW0gZnJvbSAnLi9EZWZhdWx0TGVnZW5kSXRlbSc7XG5cbmNvbnN0IExFR0VORF9HUk9VUF9TVFlMRTogQ1NTUHJvcGVydGllcyA9IHtcbiAgZGlzcGxheTogJ2ZsZXgnLFxuICBmbGV4QmFzaXM6ICdhdXRvJyxcbiAgZmxleERpcmVjdGlvbjogJ3JvdycsXG4gIGZsZXhHcm93OiAxLFxuICBmbGV4U2hyaW5rOiAxLFxuICBmbGV4V3JhcDogJ3dyYXAnLFxuICBmb250U2l6ZTogJzAuOGVtJyxcbiAganVzdGlmeUNvbnRlbnQ6ICdmbGV4LWVuZCcsXG4gIHBhZGRpbmc6IDgsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEZWZhdWx0TGVnZW5kR3JvdXBSZW5kZXJlcjxDb25maWcgZXh0ZW5kcyBFbmNvZGluZ0NvbmZpZz4oe1xuICBncm91cCxcbiAgSXRlbVJlbmRlcmVyID0gRGVmYXVsdExlZ2VuZEl0ZW0sXG4gIEl0ZW1NYXJrUmVuZGVyZXIsXG4gIEl0ZW1MYWJlbFJlbmRlcmVyLFxuICBzdHlsZSxcbn06IExlZ2VuZEdyb3VwUmVuZGVyZXJQcm9wczxDb25maWc+KSB7XG4gIGNvbnN0IGNvbWJpbmVkU3R5bGUgPVxuICAgIHR5cGVvZiBzdHlsZSA9PT0gJ3VuZGVmaW5lZCcgPyBMRUdFTkRfR1JPVVBfU1RZTEUgOiB7IC4uLkxFR0VORF9HUk9VUF9TVFlMRSwgLi4uc3R5bGUgfTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgc3R5bGU9e2NvbWJpbmVkU3R5bGV9PlxuICAgICAgeydpdGVtcycgaW4gZ3JvdXAgJiZcbiAgICAgICAgZ3JvdXAuaXRlbXMubWFwKGl0ZW0gPT4gKFxuICAgICAgICAgIDxJdGVtUmVuZGVyZXJcbiAgICAgICAgICAgIGtleT17YGxlZ2VuZC1pdGVtLSR7Z3JvdXAuZmllbGR9LSR7aXRlbS5pbnB1dH1gfVxuICAgICAgICAgICAgZ3JvdXA9e2dyb3VwfVxuICAgICAgICAgICAgaXRlbT17aXRlbX1cbiAgICAgICAgICAgIE1hcmtSZW5kZXJlcj17SXRlbU1hcmtSZW5kZXJlcn1cbiAgICAgICAgICAgIExhYmVsUmVuZGVyZXI9e0l0ZW1MYWJlbFJlbmRlcmVyfVxuICAgICAgICAgIC8+XG4gICAgICAgICkpfVxuICAgIDwvZGl2PlxuICApO1xufVxuIiwiaW1wb3J0IFJlYWN0LCB7IENTU1Byb3BlcnRpZXMsIFB1cmVDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBFbmNvZGluZ0NvbmZpZyB9IGZyb20gJ2VuY29kYWJsZSc7XG5pbXBvcnQgeyBMZWdlbmRSZW5kZXJlclByb3BzIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgRGVmYXVsdExlZ2VuZEdyb3VwIGZyb20gJy4vRGVmYXVsdExlZ2VuZEdyb3VwJztcblxuY29uc3QgTEVHRU5EX0NPTlRBSU5FUl9TVFlMRTogQ1NTUHJvcGVydGllcyA9IHtcbiAgZGlzcGxheTogJ2ZsZXgnLFxuICBmbGV4QmFzaXM6ICdhdXRvJyxcbiAgZmxleEdyb3c6IDEsXG4gIGZsZXhTaHJpbms6IDEsXG4gIG1heEhlaWdodDogMTAwLFxuICBvdmVyZmxvd1k6ICdhdXRvJyxcbiAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG59O1xuXG5leHBvcnQgdHlwZSBQcm9wczxDb25maWcgZXh0ZW5kcyBFbmNvZGluZ0NvbmZpZz4gPSBMZWdlbmRSZW5kZXJlclByb3BzPENvbmZpZz47XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlZmF1bHRMZWdlbmQ8Q29uZmlnIGV4dGVuZHMgRW5jb2RpbmdDb25maWc+IGV4dGVuZHMgUHVyZUNvbXBvbmVudDxcbiAgUHJvcHM8Q29uZmlnPlxuPiB7XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBncm91cHMsXG4gICAgICBMZWdlbmRHcm91cFJlbmRlcmVyID0gRGVmYXVsdExlZ2VuZEdyb3VwLFxuICAgICAgTGVnZW5kSXRlbVJlbmRlcmVyLFxuICAgICAgTGVnZW5kSXRlbU1hcmtSZW5kZXJlcixcbiAgICAgIExlZ2VuZEl0ZW1MYWJlbFJlbmRlcmVyLFxuICAgICAgc3R5bGUsXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCBjb21iaW5lZFN0eWxlID1cbiAgICAgIHR5cGVvZiBzdHlsZSA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyBMRUdFTkRfQ09OVEFJTkVSX1NUWUxFXG4gICAgICAgIDogeyAuLi5MRUdFTkRfQ09OVEFJTkVSX1NUWUxFLCAuLi5zdHlsZSB9O1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgc3R5bGU9e2NvbWJpbmVkU3R5bGV9PlxuICAgICAgICB7Z3JvdXBzXG4gICAgICAgICAgLmZpbHRlcihncm91cCA9PiAnaXRlbXMnIGluIGdyb3VwICYmIGdyb3VwLml0ZW1zLmxlbmd0aCA+IDApXG4gICAgICAgICAgLm1hcChncm91cCA9PiAoXG4gICAgICAgICAgICA8TGVnZW5kR3JvdXBSZW5kZXJlclxuICAgICAgICAgICAgICBrZXk9e2dyb3VwLmZpZWxkfVxuICAgICAgICAgICAgICBncm91cD17Z3JvdXB9XG4gICAgICAgICAgICAgIEl0ZW1SZW5kZXJlcj17TGVnZW5kSXRlbVJlbmRlcmVyfVxuICAgICAgICAgICAgICBJdGVtTWFya1JlbmRlcmVyPXtMZWdlbmRJdGVtTWFya1JlbmRlcmVyfVxuICAgICAgICAgICAgICBJdGVtTGFiZWxSZW5kZXJlcj17TGVnZW5kSXRlbUxhYmVsUmVuZGVyZXJ9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICkpfVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEVuY29kZXIsIEVuY29kaW5nQ29uZmlnLCBEYXRhc2V0IH0gZnJvbSAnZW5jb2RhYmxlJztcbmltcG9ydCB7IExlZ2VuZEhvb2tzIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgRGVmYXVsdExlZ2VuZCBmcm9tICcuL0RlZmF1bHRMZWdlbmQnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVSZW5kZXJMZWdlbmQ8Q29uZmlnIGV4dGVuZHMgRW5jb2RpbmdDb25maWc+KFxuICBlbmNvZGVyOiBFbmNvZGVyPENvbmZpZz4sXG4gIGRhdGE6IERhdGFzZXQsXG4gIHByb3BzOiBMZWdlbmRIb29rczxDb25maWc+LFxuKSB7XG4gIGlmIChlbmNvZGVyLmhhc0xlZ2VuZCgpKSB7XG4gICAgY29uc3Qge1xuICAgICAgTGVnZW5kUmVuZGVyZXIgPSBEZWZhdWx0TGVnZW5kLFxuICAgICAgTGVnZW5kR3JvdXBSZW5kZXJlcixcbiAgICAgIExlZ2VuZEl0ZW1SZW5kZXJlcixcbiAgICAgIExlZ2VuZEl0ZW1MYWJlbFJlbmRlcmVyLFxuICAgICAgTGVnZW5kSXRlbU1hcmtSZW5kZXJlcixcbiAgICB9ID0gcHJvcHM7XG5cbiAgICByZXR1cm4gKCkgPT4gKFxuICAgICAgPExlZ2VuZFJlbmRlcmVyXG4gICAgICAgIGdyb3Vwcz17ZW5jb2Rlci5nZXRMZWdlbmRJbmZvcm1hdGlvbihkYXRhKX1cbiAgICAgICAgTGVnZW5kR3JvdXBSZW5kZXJlcj17TGVnZW5kR3JvdXBSZW5kZXJlcn1cbiAgICAgICAgTGVnZW5kSXRlbVJlbmRlcmVyPXtMZWdlbmRJdGVtUmVuZGVyZXJ9XG4gICAgICAgIExlZ2VuZEl0ZW1NYXJrUmVuZGVyZXI9e0xlZ2VuZEl0ZW1NYXJrUmVuZGVyZXJ9XG4gICAgICAgIExlZ2VuZEl0ZW1MYWJlbFJlbmRlcmVyPXtMZWdlbmRJdGVtTGFiZWxSZW5kZXJlcn1cbiAgICAgIC8+XG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFJQTtBQUVBO0FBRUE7O0FBTUE7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQVVBO0FBU0E7OztBQ2xEQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBT0E7QUFHQTtBQUdBO0FBV0E7OztBQ3pDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFHQTtBQUNBO0FBU0E7QUFFQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBV0E7QUFDQTs7O0FDbkRBO0FBR0E7QUFFQTtBQUtBO0FBQ0E7QUFRQTtBQVNBO0FBRUE7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1386\n")},1602:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nconst defaultProps = {\n    className: \'\',\n};\nconst CONTAINER_STYLE = { padding: 8 };\nclass TooltipFrame extends react__WEBPACK_IMPORTED_MODULE_0__["PureComponent"] {\n    render() {\n        const { className, children } = this.props;\n        return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", { className: className, style: CONTAINER_STYLE }, children));\n    }\n}\nTooltipFrame.defaultProps = defaultProps;\n/* harmony default export */ __webpack_exports__["a"] = (TooltipFrame);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYwMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9zdXBlcnNldC11aS1jaGFydC1jb21wb3NpdGlvbi9zcmMvdG9vbHRpcC9Ub29sdGlwRnJhbWUudHN4P2Q2N2YiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IFB1cmVDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5cbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgY2xhc3NOYW1lOiAnJyxcbn07XG5cbnR5cGUgUHJvcHMgPSB7XG4gIGNsYXNzTmFtZT86IHN0cmluZztcbiAgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZTtcbn0gJiBSZWFkb25seTx0eXBlb2YgZGVmYXVsdFByb3BzPjtcblxuY29uc3QgQ09OVEFJTkVSX1NUWUxFID0geyBwYWRkaW5nOiA4IH07XG5cbmNsYXNzIFRvb2x0aXBGcmFtZSBleHRlbmRzIFB1cmVDb21wb25lbnQ8UHJvcHMsIHt9PiB7XG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgY2xhc3NOYW1lLCBjaGlsZHJlbiB9ID0gdGhpcy5wcm9wcztcblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3NOYW1lfSBzdHlsZT17Q09OVEFJTkVSX1NUWUxFfT5cbiAgICAgICAge2NoaWxkcmVufVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUb29sdGlwRnJhbWU7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQU9BO0FBRUE7QUFHQTtBQUNBO0FBRUE7QUFLQTs7QUFWQTtBQWFBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1602\n')},1603:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TooltipTable; });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nconst defaultProps = {\n    className: \'\',\n    data: [],\n};\nconst VALUE_CELL_STYLE = { paddingLeft: 8, textAlign: \'right\' };\nclass TooltipTable extends react__WEBPACK_IMPORTED_MODULE_0__["PureComponent"] {\n    render() {\n        const { className, data } = this.props;\n        return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("table", { className: className },\n            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tbody", null, data.map(({ key, keyColumn, keyStyle, valueColumn, valueStyle }) => (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("tr", { key: key },\n                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", { style: keyStyle }, keyColumn !== null && keyColumn !== void 0 ? keyColumn : key),\n                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("td", { style: valueStyle ? Object.assign(Object.assign({}, VALUE_CELL_STYLE), valueStyle) : VALUE_CELL_STYLE }, valueColumn)))))));\n    }\n}\nTooltipTable.defaultProps = defaultProps;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYwMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9zdXBlcnNldC11aS1jaGFydC1jb21wb3NpdGlvbi9zcmMvdG9vbHRpcC9Ub29sdGlwVGFibGUudHN4P2YxOTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IENTU1Byb3BlcnRpZXMsIFB1cmVDb21wb25lbnQsIFJlYWN0Tm9kZSB9IGZyb20gJ3JlYWN0JztcblxuaW50ZXJmYWNlIFRvb2x0aXBSb3dEYXRhIHtcbiAga2V5OiBzdHJpbmcgfCBudW1iZXI7XG4gIGtleUNvbHVtbj86IFJlYWN0Tm9kZTtcbiAga2V5U3R5bGU/OiBDU1NQcm9wZXJ0aWVzO1xuICB2YWx1ZUNvbHVtbjogUmVhY3ROb2RlO1xuICB2YWx1ZVN0eWxlPzogQ1NTUHJvcGVydGllcztcbn1cblxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBjbGFzc05hbWU6ICcnLFxuICBkYXRhOiBbXSBhcyBUb29sdGlwUm93RGF0YVtdLFxufTtcblxudHlwZSBQcm9wcyA9IHtcbiAgY2xhc3NOYW1lPzogc3RyaW5nO1xuICBkYXRhOiBUb29sdGlwUm93RGF0YVtdO1xufSAmIFJlYWRvbmx5PHR5cGVvZiBkZWZhdWx0UHJvcHM+O1xuXG5jb25zdCBWQUxVRV9DRUxMX1NUWUxFOiBDU1NQcm9wZXJ0aWVzID0geyBwYWRkaW5nTGVmdDogOCwgdGV4dEFsaWduOiAncmlnaHQnIH07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRvb2x0aXBUYWJsZSBleHRlbmRzIFB1cmVDb21wb25lbnQ8UHJvcHMsIHt9PiB7XG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgY2xhc3NOYW1lLCBkYXRhIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDx0YWJsZSBjbGFzc05hbWU9e2NsYXNzTmFtZX0+XG4gICAgICAgIDx0Ym9keT5cbiAgICAgICAgICB7ZGF0YS5tYXAoKHsga2V5LCBrZXlDb2x1bW4sIGtleVN0eWxlLCB2YWx1ZUNvbHVtbiwgdmFsdWVTdHlsZSB9KSA9PiAoXG4gICAgICAgICAgICA8dHIga2V5PXtrZXl9PlxuICAgICAgICAgICAgICA8dGQgc3R5bGU9e2tleVN0eWxlfT57a2V5Q29sdW1uID8/IGtleX08L3RkPlxuICAgICAgICAgICAgICA8dGQgc3R5bGU9e3ZhbHVlU3R5bGUgPyB7IC4uLlZBTFVFX0NFTExfU1RZTEUsIC4uLnZhbHVlU3R5bGUgfSA6IFZBTFVFX0NFTExfU1RZTEV9PlxuICAgICAgICAgICAgICAgIHt2YWx1ZUNvbHVtbn1cbiAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgKSl9XG4gICAgICAgIDwvdGJvZHk+XG4gICAgICA8L3RhYmxlPlxuICAgICk7XG4gIH1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBRUE7QUFHQTtBQUNBO0FBRUE7QUFFQTtBQUdBO0FBQ0E7QUFRQTs7QUFuQkE7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1603\n')},1728:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _vx_responsive__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2340);\n\n\nconst defaultProps = {\n    className: '',\n    height: 'auto',\n    position: 'top',\n    width: 'auto',\n};\nconst LEGEND_STYLE_BASE = {\n    display: 'flex',\n    flexGrow: 0,\n    flexShrink: 0,\n    order: -1,\n};\nconst CHART_STYLE_BASE = {\n    flexBasis: 'auto',\n    flexGrow: 1,\n    flexShrink: 1,\n    position: 'relative',\n};\nclass WithLegend extends react__WEBPACK_IMPORTED_MODULE_0__[\"PureComponent\"] {\n    getContainerDirection() {\n        const { position } = this.props;\n        if (position === 'left') {\n            return 'row';\n        }\n        if (position === 'right') {\n            return 'row-reverse';\n        }\n        if (position === 'bottom') {\n            return 'column-reverse';\n        }\n        return 'column';\n    }\n    getLegendJustifyContent() {\n        const { legendJustifyContent, position } = this.props;\n        if (legendJustifyContent) {\n            return legendJustifyContent;\n        }\n        if (position === 'left' || position === 'right') {\n            return 'flex-start';\n        }\n        return 'flex-end';\n    }\n    render() {\n        const { className, debounceTime, width, height, position, renderChart, renderLegend, } = this.props;\n        const isHorizontal = position === 'left' || position === 'right';\n        const style = {\n            display: 'flex',\n            flexDirection: this.getContainerDirection(),\n            height,\n            width,\n        };\n        const chartStyle = Object.assign({}, CHART_STYLE_BASE);\n        if (isHorizontal) {\n            chartStyle.width = 0;\n        }\n        else {\n            chartStyle.height = 0;\n        }\n        const legendDirection = isHorizontal ? 'column' : 'row';\n        const legendStyle = Object.assign(Object.assign({}, LEGEND_STYLE_BASE), { flexDirection: legendDirection, justifyContent: this.getLegendJustifyContent() });\n        return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"div\", { className: `with-legend ${className}`, style: style },\n            renderLegend && (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"div\", { className: \"legend-container\", style: legendStyle }, renderLegend({\n                // Pass flexDirection for @vx/legend to arrange legend items\n                direction: legendDirection,\n            }))),\n            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"div\", { className: \"main-container\", style: chartStyle },\n                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_vx_responsive__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"], { debounceTime: debounceTime }, (parent) => parent.width > 0 && parent.height > 0\n                    ? // Only render when necessary\n                        renderChart(parent)\n                    : null))));\n    }\n}\nWithLegend.defaultProps = defaultProps;\n/* harmony default export */ __webpack_exports__[\"a\"] = (WithLegend);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcyOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9zdXBlcnNldC11aS1jaGFydC1jb21wb3NpdGlvbi9zcmMvbGVnZW5kL1dpdGhMZWdlbmQudHN4PzU5OWIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IENTU1Byb3BlcnRpZXMsIFJlYWN0Tm9kZSwgUHVyZUNvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFBhcmVudFNpemUgfSBmcm9tICdAdngvcmVzcG9uc2l2ZSc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVucmVzb2x2ZWRcbmltcG9ydCB7IEZsZXhEaXJlY3Rpb25Qcm9wZXJ0eSB9IGZyb20gJ2Nzc3R5cGUnO1xuXG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gIGNsYXNzTmFtZTogJycsXG4gIGhlaWdodDogJ2F1dG8nIGFzIG51bWJlciB8IHN0cmluZyxcbiAgcG9zaXRpb246ICd0b3AnLFxuICB3aWR0aDogJ2F1dG8nIGFzIG51bWJlciB8IHN0cmluZyxcbn07XG5cbnR5cGUgUHJvcHMgPSB7XG4gIGNsYXNzTmFtZTogc3RyaW5nO1xuICBkZWJvdW5jZVRpbWU/OiBudW1iZXI7XG4gIHdpZHRoOiBudW1iZXIgfCBzdHJpbmc7XG4gIGhlaWdodDogbnVtYmVyIHwgc3RyaW5nO1xuICBsZWdlbmRKdXN0aWZ5Q29udGVudD86ICdjZW50ZXInIHwgJ2ZsZXgtc3RhcnQnIHwgJ2ZsZXgtZW5kJztcbiAgcG9zaXRpb246ICd0b3AnIHwgJ2xlZnQnIHwgJ2JvdHRvbScgfCAncmlnaHQnO1xuICByZW5kZXJDaGFydDogKGRpbTogeyB3aWR0aDogbnVtYmVyOyBoZWlnaHQ6IG51bWJlciB9KSA9PiBSZWFjdE5vZGU7XG4gIHJlbmRlckxlZ2VuZD86IChwYXJhbXM6IHsgZGlyZWN0aW9uOiBzdHJpbmcgfSkgPT4gUmVhY3ROb2RlO1xufSAmIFJlYWRvbmx5PHR5cGVvZiBkZWZhdWx0UHJvcHM+O1xuXG5jb25zdCBMRUdFTkRfU1RZTEVfQkFTRTogQ1NTUHJvcGVydGllcyA9IHtcbiAgZGlzcGxheTogJ2ZsZXgnLFxuICBmbGV4R3JvdzogMCxcbiAgZmxleFNocmluazogMCxcbiAgb3JkZXI6IC0xLFxufTtcblxuY29uc3QgQ0hBUlRfU1RZTEVfQkFTRTogQ1NTUHJvcGVydGllcyA9IHtcbiAgZmxleEJhc2lzOiAnYXV0bycsXG4gIGZsZXhHcm93OiAxLFxuICBmbGV4U2hyaW5rOiAxLFxuICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbn07XG5cbmNsYXNzIFdpdGhMZWdlbmQgZXh0ZW5kcyBQdXJlQ29tcG9uZW50PFByb3BzLCB7fT4ge1xuICBzdGF0aWMgZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuXG4gIGdldENvbnRhaW5lckRpcmVjdGlvbigpOiBGbGV4RGlyZWN0aW9uUHJvcGVydHkge1xuICAgIGNvbnN0IHsgcG9zaXRpb24gfSA9IHRoaXMucHJvcHM7XG5cbiAgICBpZiAocG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgcmV0dXJuICdyb3cnO1xuICAgIH1cbiAgICBpZiAocG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIHJldHVybiAncm93LXJldmVyc2UnO1xuICAgIH1cbiAgICBpZiAocG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICByZXR1cm4gJ2NvbHVtbi1yZXZlcnNlJztcbiAgICB9XG5cbiAgICByZXR1cm4gJ2NvbHVtbic7XG4gIH1cblxuICBnZXRMZWdlbmRKdXN0aWZ5Q29udGVudCgpIHtcbiAgICBjb25zdCB7IGxlZ2VuZEp1c3RpZnlDb250ZW50LCBwb3NpdGlvbiB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAobGVnZW5kSnVzdGlmeUNvbnRlbnQpIHtcbiAgICAgIHJldHVybiBsZWdlbmRKdXN0aWZ5Q29udGVudDtcbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPT09ICdsZWZ0JyB8fCBwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgcmV0dXJuICdmbGV4LXN0YXJ0JztcbiAgICB9XG5cbiAgICByZXR1cm4gJ2ZsZXgtZW5kJztcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBjbGFzc05hbWUsXG4gICAgICBkZWJvdW5jZVRpbWUsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgcmVuZGVyQ2hhcnQsXG4gICAgICByZW5kZXJMZWdlbmQsXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCBpc0hvcml6b250YWwgPSBwb3NpdGlvbiA9PT0gJ2xlZnQnIHx8IHBvc2l0aW9uID09PSAncmlnaHQnO1xuXG4gICAgY29uc3Qgc3R5bGU6IENTU1Byb3BlcnRpZXMgPSB7XG4gICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICBmbGV4RGlyZWN0aW9uOiB0aGlzLmdldENvbnRhaW5lckRpcmVjdGlvbigpLFxuICAgICAgaGVpZ2h0LFxuICAgICAgd2lkdGgsXG4gICAgfTtcblxuICAgIGNvbnN0IGNoYXJ0U3R5bGU6IENTU1Byb3BlcnRpZXMgPSB7IC4uLkNIQVJUX1NUWUxFX0JBU0UgfTtcbiAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICBjaGFydFN0eWxlLndpZHRoID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hhcnRTdHlsZS5oZWlnaHQgPSAwO1xuICAgIH1cblxuICAgIGNvbnN0IGxlZ2VuZERpcmVjdGlvbiA9IGlzSG9yaXpvbnRhbCA/ICdjb2x1bW4nIDogJ3Jvdyc7XG4gICAgY29uc3QgbGVnZW5kU3R5bGU6IENTU1Byb3BlcnRpZXMgPSB7XG4gICAgICAuLi5MRUdFTkRfU1RZTEVfQkFTRSxcbiAgICAgIGZsZXhEaXJlY3Rpb246IGxlZ2VuZERpcmVjdGlvbixcbiAgICAgIGp1c3RpZnlDb250ZW50OiB0aGlzLmdldExlZ2VuZEp1c3RpZnlDb250ZW50KCksXG4gICAgfTtcblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT17YHdpdGgtbGVnZW5kICR7Y2xhc3NOYW1lfWB9IHN0eWxlPXtzdHlsZX0+XG4gICAgICAgIHtyZW5kZXJMZWdlbmQgJiYgKFxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibGVnZW5kLWNvbnRhaW5lclwiIHN0eWxlPXtsZWdlbmRTdHlsZX0+XG4gICAgICAgICAgICB7cmVuZGVyTGVnZW5kKHtcbiAgICAgICAgICAgICAgLy8gUGFzcyBmbGV4RGlyZWN0aW9uIGZvciBAdngvbGVnZW5kIHRvIGFycmFuZ2UgbGVnZW5kIGl0ZW1zXG4gICAgICAgICAgICAgIGRpcmVjdGlvbjogbGVnZW5kRGlyZWN0aW9uLFxuICAgICAgICAgICAgfSl9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICl9XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibWFpbi1jb250YWluZXJcIiBzdHlsZT17Y2hhcnRTdHlsZX0+XG4gICAgICAgICAgPFBhcmVudFNpemUgZGVib3VuY2VUaW1lPXtkZWJvdW5jZVRpbWV9PlxuICAgICAgICAgICAgeyhwYXJlbnQ6IHsgd2lkdGg6IG51bWJlcjsgaGVpZ2h0OiBudW1iZXIgfSkgPT5cbiAgICAgICAgICAgICAgcGFyZW50LndpZHRoID4gMCAmJiBwYXJlbnQuaGVpZ2h0ID4gMFxuICAgICAgICAgICAgICAgID8gLy8gT25seSByZW5kZXIgd2hlbiBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICAgIHJlbmRlckNoYXJ0KHBhcmVudClcbiAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA8L1BhcmVudFNpemU+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBXaXRoTGVnZW5kO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQVVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBTUE7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFNQTs7QUF2RkE7QUEwRkE7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1728\n")},2342:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, "default", function() { return /* binding */ BoxPlot_BoxPlot; });\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react/index.js\nvar react = __webpack_require__(0);\nvar react_default = /*#__PURE__*/__webpack_require__.n(react);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/chart/XYChart.js + 51 modules\nvar XYChart = __webpack_require__(2344);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/classnames/index.js\nvar classnames = __webpack_require__(130);\nvar classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/@vx/group/dist/vx-group.es.js\n\n\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nfunction Group(_ref) {\n  var _ref$top = _ref.top,\n      top = _ref$top === undefined ? 0 : _ref$top,\n      _ref$left = _ref.left,\n      left = _ref$left === undefined ? 0 : _ref$left,\n      transform = _ref.transform,\n      className = _ref.className,\n      children = _ref.children,\n      restProps = objectWithoutProperties(_ref, [\'top\', \'left\', \'transform\', \'className\', \'children\']);\n\n  return react_default.a.createElement(\n    \'g\',\n    _extends({\n      className: classnames_default()(\'cx-group\', className),\n      transform: transform || \'translate(\' + left + \', \' + top + \')\'\n    }, restProps),\n    children\n  );\n}\n\n\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-array/src/ascending.js\n/* harmony default export */ var ascending = (function(a, b) {\n  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-array/src/bisector.js\n\n\n/* harmony default export */ var bisector = (function(compare) {\n  if (compare.length === 1) compare = ascendingComparator(compare);\n  return {\n    left: function(a, x, lo, hi) {\n      if (lo == null) lo = 0;\n      if (hi == null) hi = a.length;\n      while (lo < hi) {\n        var mid = lo + hi >>> 1;\n        if (compare(a[mid], x) < 0) lo = mid + 1;\n        else hi = mid;\n      }\n      return lo;\n    },\n    right: function(a, x, lo, hi) {\n      if (lo == null) lo = 0;\n      if (hi == null) hi = a.length;\n      while (lo < hi) {\n        var mid = lo + hi >>> 1;\n        if (compare(a[mid], x) > 0) hi = mid;\n        else lo = mid + 1;\n      }\n      return lo;\n    }\n  };\n});\n\nfunction ascendingComparator(f) {\n  return function(d, x) {\n    return ascending(f(d), x);\n  };\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-array/src/bisect.js\n\n\n\nvar ascendingBisect = bisector(ascending);\nvar bisectRight = ascendingBisect.right;\nvar bisectLeft = ascendingBisect.left;\n/* harmony default export */ var bisect = (bisectRight);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-array/src/pairs.js\n/* harmony default export */ var pairs = (function(array, f) {\n  if (f == null) f = pair;\n  var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);\n  while (i < n) pairs[i] = f(p, p = array[++i]);\n  return pairs;\n});\n\nfunction pair(a, b) {\n  return [a, b];\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-array/src/cross.js\n\n\n/* harmony default export */ var cross = (function(values0, values1, reduce) {\n  var n0 = values0.length,\n      n1 = values1.length,\n      values = new Array(n0 * n1),\n      i0,\n      i1,\n      i,\n      value0;\n\n  if (reduce == null) reduce = pair;\n\n  for (i0 = i = 0; i0 < n0; ++i0) {\n    for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {\n      values[i] = reduce(value0, values1[i1]);\n    }\n  }\n\n  return values;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-array/src/descending.js\n/* harmony default export */ var descending = (function(a, b) {\n  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-array/src/number.js\n/* harmony default export */ var number = (function(x) {\n  return x === null ? NaN : +x;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-array/src/variance.js\n\n\n/* harmony default export */ var variance = (function(values, valueof) {\n  var n = values.length,\n      m = 0,\n      i = -1,\n      mean = 0,\n      value,\n      delta,\n      sum = 0;\n\n  if (valueof == null) {\n    while (++i < n) {\n      if (!isNaN(value = number(values[i]))) {\n        delta = value - mean;\n        mean += delta / ++m;\n        sum += delta * (value - mean);\n      }\n    }\n  }\n\n  else {\n    while (++i < n) {\n      if (!isNaN(value = number(valueof(values[i], i, values)))) {\n        delta = value - mean;\n        mean += delta / ++m;\n        sum += delta * (value - mean);\n      }\n    }\n  }\n\n  if (m > 1) return sum / (m - 1);\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-array/src/deviation.js\n\n\n/* harmony default export */ var deviation = (function(array, f) {\n  var v = variance(array, f);\n  return v ? Math.sqrt(v) : v;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-array/src/extent.js\n/* harmony default export */ var extent = (function(values, valueof) {\n  var n = values.length,\n      i = -1,\n      value,\n      min,\n      max;\n\n  if (valueof == null) {\n    while (++i < n) { // Find the first comparable value.\n      if ((value = values[i]) != null && value >= value) {\n        min = max = value;\n        while (++i < n) { // Compare the remaining values.\n          if ((value = values[i]) != null) {\n            if (min > value) min = value;\n            if (max < value) max = value;\n          }\n        }\n      }\n    }\n  }\n\n  else {\n    while (++i < n) { // Find the first comparable value.\n      if ((value = valueof(values[i], i, values)) != null && value >= value) {\n        min = max = value;\n        while (++i < n) { // Compare the remaining values.\n          if ((value = valueof(values[i], i, values)) != null) {\n            if (min > value) min = value;\n            if (max < value) max = value;\n          }\n        }\n      }\n    }\n  }\n\n  return [min, max];\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-array/src/array.js\nvar array_array = Array.prototype;\n\nvar slice = array_array.slice;\nvar map = array_array.map;\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-array/src/constant.js\n/* harmony default export */ var constant = (function(x) {\n  return function() {\n    return x;\n  };\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-array/src/identity.js\n/* harmony default export */ var identity = (function(x) {\n  return x;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-array/src/range.js\n/* harmony default export */ var src_range = (function(start, stop, step) {\n  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;\n\n  var i = -1,\n      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,\n      range = new Array(n);\n\n  while (++i < n) {\n    range[i] = start + i * step;\n  }\n\n  return range;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-array/src/ticks.js\nvar e10 = Math.sqrt(50),\n    e5 = Math.sqrt(10),\n    e2 = Math.sqrt(2);\n\n/* harmony default export */ var src_ticks = (function(start, stop, count) {\n  var reverse,\n      i = -1,\n      n,\n      ticks,\n      step;\n\n  stop = +stop, start = +start, count = +count;\n  if (start === stop && count > 0) return [start];\n  if (reverse = stop < start) n = start, start = stop, stop = n;\n  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];\n\n  if (step > 0) {\n    start = Math.ceil(start / step);\n    stop = Math.floor(stop / step);\n    ticks = new Array(n = Math.ceil(stop - start + 1));\n    while (++i < n) ticks[i] = (start + i) * step;\n  } else {\n    start = Math.floor(start * step);\n    stop = Math.ceil(stop * step);\n    ticks = new Array(n = Math.ceil(start - stop + 1));\n    while (++i < n) ticks[i] = (start - i) / step;\n  }\n\n  if (reverse) ticks.reverse();\n\n  return ticks;\n});\n\nfunction tickIncrement(start, stop, count) {\n  var step = (stop - start) / Math.max(0, count),\n      power = Math.floor(Math.log(step) / Math.LN10),\n      error = step / Math.pow(10, power);\n  return power >= 0\n      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)\n      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);\n}\n\nfunction tickStep(start, stop, count) {\n  var step0 = Math.abs(stop - start) / Math.max(0, count),\n      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),\n      error = step0 / step1;\n  if (error >= e10) step1 *= 10;\n  else if (error >= e5) step1 *= 5;\n  else if (error >= e2) step1 *= 2;\n  return stop < start ? -step1 : step1;\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-array/src/threshold/sturges.js\n/* harmony default export */ var sturges = (function(values) {\n  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-array/src/histogram.js\n\n\n\n\n\n\n\n\n\n/* harmony default export */ var src_histogram = (function() {\n  var value = identity,\n      domain = extent,\n      threshold = sturges;\n\n  function histogram(data) {\n    var i,\n        n = data.length,\n        x,\n        values = new Array(n);\n\n    for (i = 0; i < n; ++i) {\n      values[i] = value(data[i], i, data);\n    }\n\n    var xz = domain(values),\n        x0 = xz[0],\n        x1 = xz[1],\n        tz = threshold(values, x0, x1);\n\n    // Convert number of thresholds into uniform thresholds.\n    if (!Array.isArray(tz)) {\n      tz = tickStep(x0, x1, tz);\n      tz = src_range(Math.ceil(x0 / tz) * tz, x1, tz); // exclusive\n    }\n\n    // Remove any thresholds outside the domain.\n    var m = tz.length;\n    while (tz[0] <= x0) tz.shift(), --m;\n    while (tz[m - 1] > x1) tz.pop(), --m;\n\n    var bins = new Array(m + 1),\n        bin;\n\n    // Initialize bins.\n    for (i = 0; i <= m; ++i) {\n      bin = bins[i] = [];\n      bin.x0 = i > 0 ? tz[i - 1] : x0;\n      bin.x1 = i < m ? tz[i] : x1;\n    }\n\n    // Assign data to bins by value, ignoring any outside the domain.\n    for (i = 0; i < n; ++i) {\n      x = values[i];\n      if (x0 <= x && x <= x1) {\n        bins[bisect(tz, x, 0, m)].push(data[i]);\n      }\n    }\n\n    return bins;\n  }\n\n  histogram.value = function(_) {\n    return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;\n  };\n\n  histogram.domain = function(_) {\n    return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;\n  };\n\n  histogram.thresholds = function(_) {\n    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;\n  };\n\n  return histogram;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-array/src/quantile.js\n\n\n/* harmony default export */ var quantile = (function(values, p, valueof) {\n  if (valueof == null) valueof = number;\n  if (!(n = values.length)) return;\n  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);\n  if (p >= 1) return +valueof(values[n - 1], n - 1, values);\n  var n,\n      i = (n - 1) * p,\n      i0 = Math.floor(i),\n      value0 = +valueof(values[i0], i0, values),\n      value1 = +valueof(values[i0 + 1], i0 + 1, values);\n  return value0 + (value1 - value0) * (i - i0);\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-array/src/threshold/freedmanDiaconis.js\n\n\n\n\n\n/* harmony default export */ var freedmanDiaconis = (function(values, min, max) {\n  values = map.call(values, number).sort(ascending);\n  return Math.ceil((max - min) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(values.length, -1 / 3)));\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-array/src/threshold/scott.js\n\n\n/* harmony default export */ var scott = (function(values, min, max) {\n  return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-array/src/max.js\n/* harmony default export */ var src_max = (function(values, valueof) {\n  var n = values.length,\n      i = -1,\n      value,\n      max;\n\n  if (valueof == null) {\n    while (++i < n) { // Find the first comparable value.\n      if ((value = values[i]) != null && value >= value) {\n        max = value;\n        while (++i < n) { // Compare the remaining values.\n          if ((value = values[i]) != null && value > max) {\n            max = value;\n          }\n        }\n      }\n    }\n  }\n\n  else {\n    while (++i < n) { // Find the first comparable value.\n      if ((value = valueof(values[i], i, values)) != null && value >= value) {\n        max = value;\n        while (++i < n) { // Compare the remaining values.\n          if ((value = valueof(values[i], i, values)) != null && value > max) {\n            max = value;\n          }\n        }\n      }\n    }\n  }\n\n  return max;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-array/src/mean.js\n\n\n/* harmony default export */ var src_mean = (function(values, valueof) {\n  var n = values.length,\n      m = n,\n      i = -1,\n      value,\n      sum = 0;\n\n  if (valueof == null) {\n    while (++i < n) {\n      if (!isNaN(value = number(values[i]))) sum += value;\n      else --m;\n    }\n  }\n\n  else {\n    while (++i < n) {\n      if (!isNaN(value = number(valueof(values[i], i, values)))) sum += value;\n      else --m;\n    }\n  }\n\n  if (m) return sum / m;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-array/src/median.js\n\n\n\n\n/* harmony default export */ var src_median = (function(values, valueof) {\n  var n = values.length,\n      i = -1,\n      value,\n      numbers = [];\n\n  if (valueof == null) {\n    while (++i < n) {\n      if (!isNaN(value = number(values[i]))) {\n        numbers.push(value);\n      }\n    }\n  }\n\n  else {\n    while (++i < n) {\n      if (!isNaN(value = number(valueof(values[i], i, values)))) {\n        numbers.push(value);\n      }\n    }\n  }\n\n  return quantile(numbers.sort(ascending), 0.5);\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-array/src/merge.js\n/* harmony default export */ var merge = (function(arrays) {\n  var n = arrays.length,\n      m,\n      i = -1,\n      j = 0,\n      merged,\n      array;\n\n  while (++i < n) j += arrays[i].length;\n  merged = new Array(j);\n\n  while (--n >= 0) {\n    array = arrays[n];\n    m = array.length;\n    while (--m >= 0) {\n      merged[--j] = array[m];\n    }\n  }\n\n  return merged;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-array/src/min.js\n/* harmony default export */ var src_min = (function(values, valueof) {\n  var n = values.length,\n      i = -1,\n      value,\n      min;\n\n  if (valueof == null) {\n    while (++i < n) { // Find the first comparable value.\n      if ((value = values[i]) != null && value >= value) {\n        min = value;\n        while (++i < n) { // Compare the remaining values.\n          if ((value = values[i]) != null && min > value) {\n            min = value;\n          }\n        }\n      }\n    }\n  }\n\n  else {\n    while (++i < n) { // Find the first comparable value.\n      if ((value = valueof(values[i], i, values)) != null && value >= value) {\n        min = value;\n        while (++i < n) { // Compare the remaining values.\n          if ((value = valueof(values[i], i, values)) != null && min > value) {\n            min = value;\n          }\n        }\n      }\n    }\n  }\n\n  return min;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-array/src/permute.js\n/* harmony default export */ var permute = (function(array, indexes) {\n  var i = indexes.length, permutes = new Array(i);\n  while (i--) permutes[i] = array[indexes[i]];\n  return permutes;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-array/src/scan.js\n\n\n/* harmony default export */ var scan = (function(values, compare) {\n  if (!(n = values.length)) return;\n  var n,\n      i = 0,\n      j = 0,\n      xi,\n      xj = values[j];\n\n  if (compare == null) compare = ascending;\n\n  while (++i < n) {\n    if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {\n      xj = xi, j = i;\n    }\n  }\n\n  if (compare(xj, xj) === 0) return j;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-array/src/shuffle.js\n/* harmony default export */ var shuffle = (function(array, i0, i1) {\n  var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),\n      t,\n      i;\n\n  while (m) {\n    i = Math.random() * m-- | 0;\n    t = array[m + i0];\n    array[m + i0] = array[i + i0];\n    array[i + i0] = t;\n  }\n\n  return array;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-array/src/sum.js\n/* harmony default export */ var src_sum = (function(values, valueof) {\n  var n = values.length,\n      i = -1,\n      value,\n      sum = 0;\n\n  if (valueof == null) {\n    while (++i < n) {\n      if (value = +values[i]) sum += value; // Note: zero and null are equivalent.\n    }\n  }\n\n  else {\n    while (++i < n) {\n      if (value = +valueof(values[i], i, values)) sum += value;\n    }\n  }\n\n  return sum;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-array/src/transpose.js\n\n\n/* harmony default export */ var src_transpose = (function(matrix) {\n  if (!(n = matrix.length)) return [];\n  for (var i = -1, m = src_min(matrix, transpose_length), transpose = new Array(m); ++i < m;) {\n    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {\n      row[j] = matrix[j][i];\n    }\n  }\n  return transpose;\n});\n\nfunction transpose_length(d) {\n  return d.length;\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-array/src/zip.js\n\n\n/* harmony default export */ var zip = (function() {\n  return src_transpose(arguments);\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-array/src/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/init.js\nfunction initRange(domain, range) {\n  switch (arguments.length) {\n    case 0: break;\n    case 1: this.range(domain); break;\n    default: this.range(range).domain(domain); break;\n  }\n  return this;\n}\n\nfunction initInterpolator(domain, interpolator) {\n  switch (arguments.length) {\n    case 0: break;\n    case 1: this.interpolator(domain); break;\n    default: this.interpolator(interpolator).domain(domain); break;\n  }\n  return this;\n}\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-collection/src/index.js + 6 modules\nvar src = __webpack_require__(407);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/array.js\nvar src_array_array = Array.prototype;\n\nvar array_map = src_array_array.map;\nvar array_slice = src_array_array.slice;\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/ordinal.js\n\n\n\n\nvar implicit = {name: "implicit"};\n\nfunction ordinal() {\n  var index = Object(src["map"])(),\n      domain = [],\n      range = [],\n      unknown = implicit;\n\n  function scale(d) {\n    var key = d + "", i = index.get(key);\n    if (!i) {\n      if (unknown !== implicit) return unknown;\n      index.set(key, i = domain.push(d));\n    }\n    return range[(i - 1) % range.length];\n  }\n\n  scale.domain = function(_) {\n    if (!arguments.length) return domain.slice();\n    domain = [], index = Object(src["map"])();\n    var i = -1, n = _.length, d, key;\n    while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));\n    return scale;\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = array_slice.call(_), scale) : range.slice();\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  scale.copy = function() {\n    return ordinal(domain, range).unknown(unknown);\n  };\n\n  initRange.apply(scale, arguments);\n\n  return scale;\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/band.js\n\n\n\n\nfunction band() {\n  var scale = ordinal().unknown(undefined),\n      domain = scale.domain,\n      ordinalRange = scale.range,\n      range = [0, 1],\n      step,\n      bandwidth,\n      round = false,\n      paddingInner = 0,\n      paddingOuter = 0,\n      align = 0.5;\n\n  delete scale.unknown;\n\n  function rescale() {\n    var n = domain().length,\n        reverse = range[1] < range[0],\n        start = range[reverse - 0],\n        stop = range[1 - reverse];\n    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);\n    if (round) step = Math.floor(step);\n    start += (stop - start - step * (n - paddingInner)) * align;\n    bandwidth = step * (1 - paddingInner);\n    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);\n    var values = src_range(n).map(function(i) { return start + step * i; });\n    return ordinalRange(reverse ? values.reverse() : values);\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain(_), rescale()) : domain();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = [+_[0], +_[1]], rescale()) : range.slice();\n  };\n\n  scale.rangeRound = function(_) {\n    return range = [+_[0], +_[1]], round = true, rescale();\n  };\n\n  scale.bandwidth = function() {\n    return bandwidth;\n  };\n\n  scale.step = function() {\n    return step;\n  };\n\n  scale.round = function(_) {\n    return arguments.length ? (round = !!_, rescale()) : round;\n  };\n\n  scale.padding = function(_) {\n    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;\n  };\n\n  scale.paddingInner = function(_) {\n    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;\n  };\n\n  scale.paddingOuter = function(_) {\n    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;\n  };\n\n  scale.align = function(_) {\n    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;\n  };\n\n  scale.copy = function() {\n    return band(domain(), range)\n        .round(round)\n        .paddingInner(paddingInner)\n        .paddingOuter(paddingOuter)\n        .align(align);\n  };\n\n  return initRange.apply(rescale(), arguments);\n}\n\nfunction pointish(scale) {\n  var copy = scale.copy;\n\n  scale.padding = scale.paddingOuter;\n  delete scale.paddingInner;\n  delete scale.paddingOuter;\n\n  scale.copy = function() {\n    return pointish(copy());\n  };\n\n  return scale;\n}\n\nfunction point() {\n  return pointish(band.apply(null, arguments).paddingInner(1));\n}\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-interpolate/src/value.js\nvar src_value = __webpack_require__(167);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-interpolate/src/number.js\nvar src_number = __webpack_require__(51);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-interpolate/src/round.js\nvar src_round = __webpack_require__(527);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/constant.js\n/* harmony default export */ var src_constant = (function(x) {\n  return function() {\n    return x;\n  };\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/number.js\n/* harmony default export */ var d3_scale_src_number = (function(x) {\n  return +x;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/continuous.js\n\n\n\n\n\n\nvar unit = [0, 1];\n\nfunction continuous_identity(x) {\n  return x;\n}\n\nfunction normalize(a, b) {\n  return (b -= (a = +a))\n      ? function(x) { return (x - a) / b; }\n      : src_constant(isNaN(b) ? NaN : 0.5);\n}\n\nfunction clamper(domain) {\n  var a = domain[0], b = domain[domain.length - 1], t;\n  if (a > b) t = a, a = b, b = t;\n  return function(x) { return Math.max(a, Math.min(b, x)); };\n}\n\n// normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].\n// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].\nfunction bimap(domain, range, interpolate) {\n  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];\n  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);\n  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);\n  return function(x) { return r0(d0(x)); };\n}\n\nfunction polymap(domain, range, interpolate) {\n  var j = Math.min(domain.length, range.length) - 1,\n      d = new Array(j),\n      r = new Array(j),\n      i = -1;\n\n  // Reverse descending domains.\n  if (domain[j] < domain[0]) {\n    domain = domain.slice().reverse();\n    range = range.slice().reverse();\n  }\n\n  while (++i < j) {\n    d[i] = normalize(domain[i], domain[i + 1]);\n    r[i] = interpolate(range[i], range[i + 1]);\n  }\n\n  return function(x) {\n    var i = bisect(domain, x, 1, j) - 1;\n    return r[i](d[i](x));\n  };\n}\n\nfunction copy(source, target) {\n  return target\n      .domain(source.domain())\n      .range(source.range())\n      .interpolate(source.interpolate())\n      .clamp(source.clamp())\n      .unknown(source.unknown());\n}\n\nfunction transformer() {\n  var domain = unit,\n      range = unit,\n      interpolate = src_value["a" /* default */],\n      transform,\n      untransform,\n      unknown,\n      clamp = continuous_identity,\n      piecewise,\n      output,\n      input;\n\n  function rescale() {\n    piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;\n    output = input = null;\n    return scale;\n  }\n\n  function scale(x) {\n    return isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));\n  }\n\n  scale.invert = function(y) {\n    return clamp(untransform((input || (input = piecewise(range, domain.map(transform), src_number["a" /* default */])))(y)));\n  };\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain = array_map.call(_, d3_scale_src_number), clamp === continuous_identity || (clamp = clamper(domain)), rescale()) : domain.slice();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = array_slice.call(_), rescale()) : range.slice();\n  };\n\n  scale.rangeRound = function(_) {\n    return range = array_slice.call(_), interpolate = src_round["a" /* default */], rescale();\n  };\n\n  scale.clamp = function(_) {\n    return arguments.length ? (clamp = _ ? clamper(domain) : continuous_identity, scale) : clamp !== continuous_identity;\n  };\n\n  scale.interpolate = function(_) {\n    return arguments.length ? (interpolate = _, rescale()) : interpolate;\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  return function(t, u) {\n    transform = t, untransform = u;\n    return rescale();\n  };\n}\n\nfunction continuous(transform, untransform) {\n  return transformer()(transform, untransform);\n}\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-format/src/formatSpecifier.js\nvar formatSpecifier = __webpack_require__(267);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-format/src/precisionPrefix.js\nvar precisionPrefix = __webpack_require__(655);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-format/src/defaultLocale.js\nvar defaultLocale = __webpack_require__(313);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-format/src/precisionRound.js\nvar precisionRound = __webpack_require__(656);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-format/src/precisionFixed.js\nvar precisionFixed = __webpack_require__(657);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/tickFormat.js\n\n\n\n/* harmony default export */ var src_tickFormat = (function(start, stop, count, specifier) {\n  var step = tickStep(start, stop, count),\n      precision;\n  specifier = Object(formatSpecifier["b" /* default */])(specifier == null ? ",f" : specifier);\n  switch (specifier.type) {\n    case "s": {\n      var value = Math.max(Math.abs(start), Math.abs(stop));\n      if (specifier.precision == null && !isNaN(precision = Object(precisionPrefix["a" /* default */])(step, value))) specifier.precision = precision;\n      return Object(defaultLocale["c" /* formatPrefix */])(specifier, value);\n    }\n    case "":\n    case "e":\n    case "g":\n    case "p":\n    case "r": {\n      if (specifier.precision == null && !isNaN(precision = Object(precisionRound["a" /* default */])(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");\n      break;\n    }\n    case "f":\n    case "%": {\n      if (specifier.precision == null && !isNaN(precision = Object(precisionFixed["a" /* default */])(step))) specifier.precision = precision - (specifier.type === "%") * 2;\n      break;\n    }\n  }\n  return Object(defaultLocale["b" /* format */])(specifier);\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/linear.js\n\n\n\n\n\nfunction linearish(scale) {\n  var domain = scale.domain;\n\n  scale.ticks = function(count) {\n    var d = domain();\n    return src_ticks(d[0], d[d.length - 1], count == null ? 10 : count);\n  };\n\n  scale.tickFormat = function(count, specifier) {\n    var d = domain();\n    return src_tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);\n  };\n\n  scale.nice = function(count) {\n    if (count == null) count = 10;\n\n    var d = domain(),\n        i0 = 0,\n        i1 = d.length - 1,\n        start = d[i0],\n        stop = d[i1],\n        step;\n\n    if (stop < start) {\n      step = start, start = stop, stop = step;\n      step = i0, i0 = i1, i1 = step;\n    }\n\n    step = tickIncrement(start, stop, count);\n\n    if (step > 0) {\n      start = Math.floor(start / step) * step;\n      stop = Math.ceil(stop / step) * step;\n      step = tickIncrement(start, stop, count);\n    } else if (step < 0) {\n      start = Math.ceil(start * step) / step;\n      stop = Math.floor(stop * step) / step;\n      step = tickIncrement(start, stop, count);\n    }\n\n    if (step > 0) {\n      d[i0] = Math.floor(start / step) * step;\n      d[i1] = Math.ceil(stop / step) * step;\n      domain(d);\n    } else if (step < 0) {\n      d[i0] = Math.ceil(start * step) / step;\n      d[i1] = Math.floor(stop * step) / step;\n      domain(d);\n    }\n\n    return scale;\n  };\n\n  return scale;\n}\n\nfunction linear() {\n  var scale = continuous(continuous_identity, continuous_identity);\n\n  scale.copy = function() {\n    return copy(scale, linear());\n  };\n\n  initRange.apply(scale, arguments);\n\n  return linearish(scale);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/identity.js\n\n\n\n\nfunction identity_identity(domain) {\n  var unknown;\n\n  function scale(x) {\n    return isNaN(x = +x) ? unknown : x;\n  }\n\n  scale.invert = scale;\n\n  scale.domain = scale.range = function(_) {\n    return arguments.length ? (domain = array_map.call(_, d3_scale_src_number), scale) : domain.slice();\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  scale.copy = function() {\n    return identity_identity(domain).unknown(unknown);\n  };\n\n  domain = arguments.length ? array_map.call(domain, d3_scale_src_number) : [0, 1];\n\n  return linearish(scale);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/nice.js\n/* harmony default export */ var src_nice = (function(domain, interval) {\n  domain = domain.slice();\n\n  var i0 = 0,\n      i1 = domain.length - 1,\n      x0 = domain[i0],\n      x1 = domain[i1],\n      t;\n\n  if (x1 < x0) {\n    t = i0, i0 = i1, i1 = t;\n    t = x0, x0 = x1, x1 = t;\n  }\n\n  domain[i0] = interval.floor(x0);\n  domain[i1] = interval.ceil(x1);\n  return domain;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/log.js\n\n\n\n\n\n\nfunction transformLog(x) {\n  return Math.log(x);\n}\n\nfunction transformExp(x) {\n  return Math.exp(x);\n}\n\nfunction transformLogn(x) {\n  return -Math.log(-x);\n}\n\nfunction transformExpn(x) {\n  return -Math.exp(-x);\n}\n\nfunction pow10(x) {\n  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;\n}\n\nfunction powp(base) {\n  return base === 10 ? pow10\n      : base === Math.E ? Math.exp\n      : function(x) { return Math.pow(base, x); };\n}\n\nfunction logp(base) {\n  return base === Math.E ? Math.log\n      : base === 10 && Math.log10\n      || base === 2 && Math.log2\n      || (base = Math.log(base), function(x) { return Math.log(x) / base; });\n}\n\nfunction reflect(f) {\n  return function(x) {\n    return -f(-x);\n  };\n}\n\nfunction loggish(transform) {\n  var scale = transform(transformLog, transformExp),\n      domain = scale.domain,\n      base = 10,\n      logs,\n      pows;\n\n  function rescale() {\n    logs = logp(base), pows = powp(base);\n    if (domain()[0] < 0) {\n      logs = reflect(logs), pows = reflect(pows);\n      transform(transformLogn, transformExpn);\n    } else {\n      transform(transformLog, transformExp);\n    }\n    return scale;\n  }\n\n  scale.base = function(_) {\n    return arguments.length ? (base = +_, rescale()) : base;\n  };\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain(_), rescale()) : domain();\n  };\n\n  scale.ticks = function(count) {\n    var d = domain(),\n        u = d[0],\n        v = d[d.length - 1],\n        r;\n\n    if (r = v < u) i = u, u = v, v = i;\n\n    var i = logs(u),\n        j = logs(v),\n        p,\n        k,\n        t,\n        n = count == null ? 10 : +count,\n        z = [];\n\n    if (!(base % 1) && j - i < n) {\n      i = Math.round(i) - 1, j = Math.round(j) + 1;\n      if (u > 0) for (; i < j; ++i) {\n        for (k = 1, p = pows(i); k < base; ++k) {\n          t = p * k;\n          if (t < u) continue;\n          if (t > v) break;\n          z.push(t);\n        }\n      } else for (; i < j; ++i) {\n        for (k = base - 1, p = pows(i); k >= 1; --k) {\n          t = p * k;\n          if (t < u) continue;\n          if (t > v) break;\n          z.push(t);\n        }\n      }\n    } else {\n      z = src_ticks(i, j, Math.min(j - i, n)).map(pows);\n    }\n\n    return r ? z.reverse() : z;\n  };\n\n  scale.tickFormat = function(count, specifier) {\n    if (specifier == null) specifier = base === 10 ? ".0e" : ",";\n    if (typeof specifier !== "function") specifier = Object(defaultLocale["b" /* format */])(specifier);\n    if (count === Infinity) return specifier;\n    if (count == null) count = 10;\n    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?\n    return function(d) {\n      var i = d / pows(Math.round(logs(d)));\n      if (i * base < base - 0.5) i *= base;\n      return i <= k ? specifier(d) : "";\n    };\n  };\n\n  scale.nice = function() {\n    return domain(src_nice(domain(), {\n      floor: function(x) { return pows(Math.floor(logs(x))); },\n      ceil: function(x) { return pows(Math.ceil(logs(x))); }\n    }));\n  };\n\n  return scale;\n}\n\nfunction log() {\n  var scale = loggish(transformer()).domain([1, 10]);\n\n  scale.copy = function() {\n    return copy(scale, log()).base(scale.base());\n  };\n\n  initRange.apply(scale, arguments);\n\n  return scale;\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/symlog.js\n\n\n\n\nfunction transformSymlog(c) {\n  return function(x) {\n    return Math.sign(x) * Math.log1p(Math.abs(x / c));\n  };\n}\n\nfunction transformSymexp(c) {\n  return function(x) {\n    return Math.sign(x) * Math.expm1(Math.abs(x)) * c;\n  };\n}\n\nfunction symlogish(transform) {\n  var c = 1, scale = transform(transformSymlog(c), transformSymexp(c));\n\n  scale.constant = function(_) {\n    return arguments.length ? transform(transformSymlog(c = +_), transformSymexp(c)) : c;\n  };\n\n  return linearish(scale);\n}\n\nfunction symlog() {\n  var scale = symlogish(transformer());\n\n  scale.copy = function() {\n    return copy(scale, symlog()).constant(scale.constant());\n  };\n\n  return initRange.apply(scale, arguments);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/pow.js\n\n\n\n\nfunction transformPow(exponent) {\n  return function(x) {\n    return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);\n  };\n}\n\nfunction transformSqrt(x) {\n  return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);\n}\n\nfunction transformSquare(x) {\n  return x < 0 ? -x * x : x * x;\n}\n\nfunction powish(transform) {\n  var scale = transform(continuous_identity, continuous_identity),\n      exponent = 1;\n\n  function rescale() {\n    return exponent === 1 ? transform(continuous_identity, continuous_identity)\n        : exponent === 0.5 ? transform(transformSqrt, transformSquare)\n        : transform(transformPow(exponent), transformPow(1 / exponent));\n  }\n\n  scale.exponent = function(_) {\n    return arguments.length ? (exponent = +_, rescale()) : exponent;\n  };\n\n  return linearish(scale);\n}\n\nfunction pow() {\n  var scale = powish(transformer());\n\n  scale.copy = function() {\n    return copy(scale, pow()).exponent(scale.exponent());\n  };\n\n  initRange.apply(scale, arguments);\n\n  return scale;\n}\n\nfunction sqrt() {\n  return pow.apply(null, arguments).exponent(0.5);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/quantile.js\n\n\n\n\nfunction quantile_quantile() {\n  var domain = [],\n      range = [],\n      thresholds = [],\n      unknown;\n\n  function rescale() {\n    var i = 0, n = Math.max(1, range.length);\n    thresholds = new Array(n - 1);\n    while (++i < n) thresholds[i - 1] = quantile(domain, i / n);\n    return scale;\n  }\n\n  function scale(x) {\n    return isNaN(x = +x) ? unknown : range[bisect(thresholds, x)];\n  }\n\n  scale.invertExtent = function(y) {\n    var i = range.indexOf(y);\n    return i < 0 ? [NaN, NaN] : [\n      i > 0 ? thresholds[i - 1] : domain[0],\n      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]\n    ];\n  };\n\n  scale.domain = function(_) {\n    if (!arguments.length) return domain.slice();\n    domain = [];\n    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);\n    domain.sort(ascending);\n    return rescale();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = array_slice.call(_), rescale()) : range.slice();\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  scale.quantiles = function() {\n    return thresholds.slice();\n  };\n\n  scale.copy = function() {\n    return quantile_quantile()\n        .domain(domain)\n        .range(range)\n        .unknown(unknown);\n  };\n\n  return initRange.apply(scale, arguments);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/quantize.js\n\n\n\n\n\nfunction quantize() {\n  var x0 = 0,\n      x1 = 1,\n      n = 1,\n      domain = [0.5],\n      range = [0, 1],\n      unknown;\n\n  function scale(x) {\n    return x <= x ? range[bisect(domain, x, 0, n)] : unknown;\n  }\n\n  function rescale() {\n    var i = -1;\n    domain = new Array(n);\n    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);\n    return scale;\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (n = (range = array_slice.call(_)).length - 1, rescale()) : range.slice();\n  };\n\n  scale.invertExtent = function(y) {\n    var i = range.indexOf(y);\n    return i < 0 ? [NaN, NaN]\n        : i < 1 ? [x0, domain[0]]\n        : i >= n ? [domain[n - 1], x1]\n        : [domain[i - 1], domain[i]];\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : scale;\n  };\n\n  scale.thresholds = function() {\n    return domain.slice();\n  };\n\n  scale.copy = function() {\n    return quantize()\n        .domain([x0, x1])\n        .range(range)\n        .unknown(unknown);\n  };\n\n  return initRange.apply(linearish(scale), arguments);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/threshold.js\n\n\n\n\nfunction threshold_threshold() {\n  var domain = [0.5],\n      range = [0, 1],\n      unknown,\n      n = 1;\n\n  function scale(x) {\n    return x <= x ? range[bisect(domain, x, 0, n)] : unknown;\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain = array_slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = array_slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();\n  };\n\n  scale.invertExtent = function(y) {\n    var i = range.indexOf(y);\n    return [domain[i - 1], domain[i]];\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  scale.copy = function() {\n    return threshold_threshold()\n        .domain(domain)\n        .range(range)\n        .unknown(unknown);\n  };\n\n  return initRange.apply(scale, arguments);\n}\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/year.js\nvar src_year = __webpack_require__(125);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/month.js\nvar src_month = __webpack_require__(376);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/week.js\nvar src_week = __webpack_require__(26);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/day.js\nvar src_day = __webpack_require__(225);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/hour.js\nvar src_hour = __webpack_require__(377);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/minute.js\nvar src_minute = __webpack_require__(378);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/second.js\nvar src_second = __webpack_require__(212);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/millisecond.js\nvar src_millisecond = __webpack_require__(213);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time-format/src/defaultLocale.js\nvar src_defaultLocale = __webpack_require__(650);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/time.js\n\n\n\n\n\n\n\n\nvar durationSecond = 1000,\n    durationMinute = durationSecond * 60,\n    durationHour = durationMinute * 60,\n    durationDay = durationHour * 24,\n    durationWeek = durationDay * 7,\n    durationMonth = durationDay * 30,\n    durationYear = durationDay * 365;\n\nfunction date(t) {\n  return new Date(t);\n}\n\nfunction time_number(t) {\n  return t instanceof Date ? +t : +new Date(+t);\n}\n\nfunction calendar(year, month, week, day, hour, minute, second, millisecond, format) {\n  var scale = continuous(continuous_identity, continuous_identity),\n      invert = scale.invert,\n      domain = scale.domain;\n\n  var formatMillisecond = format(".%L"),\n      formatSecond = format(":%S"),\n      formatMinute = format("%I:%M"),\n      formatHour = format("%I %p"),\n      formatDay = format("%a %d"),\n      formatWeek = format("%b %d"),\n      formatMonth = format("%B"),\n      formatYear = format("%Y");\n\n  var tickIntervals = [\n    [second,  1,      durationSecond],\n    [second,  5,  5 * durationSecond],\n    [second, 15, 15 * durationSecond],\n    [second, 30, 30 * durationSecond],\n    [minute,  1,      durationMinute],\n    [minute,  5,  5 * durationMinute],\n    [minute, 15, 15 * durationMinute],\n    [minute, 30, 30 * durationMinute],\n    [  hour,  1,      durationHour  ],\n    [  hour,  3,  3 * durationHour  ],\n    [  hour,  6,  6 * durationHour  ],\n    [  hour, 12, 12 * durationHour  ],\n    [   day,  1,      durationDay   ],\n    [   day,  2,  2 * durationDay   ],\n    [  week,  1,      durationWeek  ],\n    [ month,  1,      durationMonth ],\n    [ month,  3,  3 * durationMonth ],\n    [  year,  1,      durationYear  ]\n  ];\n\n  function tickFormat(date) {\n    return (second(date) < date ? formatMillisecond\n        : minute(date) < date ? formatSecond\n        : hour(date) < date ? formatMinute\n        : day(date) < date ? formatHour\n        : month(date) < date ? (week(date) < date ? formatDay : formatWeek)\n        : year(date) < date ? formatMonth\n        : formatYear)(date);\n  }\n\n  function tickInterval(interval, start, stop, step) {\n    if (interval == null) interval = 10;\n\n    // If a desired tick count is specified, pick a reasonable tick interval\n    // based on the extent of the domain and a rough estimate of tick size.\n    // Otherwise, assume interval is already a time interval and use it.\n    if (typeof interval === "number") {\n      var target = Math.abs(stop - start) / interval,\n          i = bisector(function(i) { return i[2]; }).right(tickIntervals, target);\n      if (i === tickIntervals.length) {\n        step = tickStep(start / durationYear, stop / durationYear, interval);\n        interval = year;\n      } else if (i) {\n        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];\n        step = i[1];\n        interval = i[0];\n      } else {\n        step = Math.max(tickStep(start, stop, interval), 1);\n        interval = millisecond;\n      }\n    }\n\n    return step == null ? interval : interval.every(step);\n  }\n\n  scale.invert = function(y) {\n    return new Date(invert(y));\n  };\n\n  scale.domain = function(_) {\n    return arguments.length ? domain(array_map.call(_, time_number)) : domain().map(date);\n  };\n\n  scale.ticks = function(interval, step) {\n    var d = domain(),\n        t0 = d[0],\n        t1 = d[d.length - 1],\n        r = t1 < t0,\n        t;\n    if (r) t = t0, t0 = t1, t1 = t;\n    t = tickInterval(interval, t0, t1, step);\n    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop\n    return r ? t.reverse() : t;\n  };\n\n  scale.tickFormat = function(count, specifier) {\n    return specifier == null ? tickFormat : format(specifier);\n  };\n\n  scale.nice = function(interval, step) {\n    var d = domain();\n    return (interval = tickInterval(interval, d[0], d[d.length - 1], step))\n        ? domain(src_nice(d, interval))\n        : scale;\n  };\n\n  scale.copy = function() {\n    return copy(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));\n  };\n\n  return scale;\n}\n\n/* harmony default export */ var time = (function() {\n  return initRange.apply(calendar(src_year["a" /* default */], src_month["a" /* default */], src_week["g" /* sunday */], src_day["b" /* default */], src_hour["a" /* default */], src_minute["a" /* default */], src_second["a" /* default */], src_millisecond["a" /* default */], src_defaultLocale["a" /* timeFormat */]).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);\n});\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/utcYear.js\nvar utcYear = __webpack_require__(126);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/utcMonth.js\nvar utcMonth = __webpack_require__(379);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/utcWeek.js\nvar utcWeek = __webpack_require__(27);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/utcDay.js\nvar utcDay = __webpack_require__(226);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/utcHour.js\nvar utcHour = __webpack_require__(380);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/utcMinute.js\nvar utcMinute = __webpack_require__(381);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/utcTime.js\n\n\n\n\n\n/* harmony default export */ var utcTime = (function() {\n  return initRange.apply(calendar(utcYear["a" /* default */], utcMonth["a" /* default */], utcWeek["g" /* utcSunday */], utcDay["a" /* default */], utcHour["a" /* default */], utcMinute["a" /* default */], src_second["a" /* default */], src_millisecond["a" /* default */], src_defaultLocale["b" /* utcFormat */]).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]), arguments);\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/sequential.js\n\n\n\n\n\n\n\nfunction sequential_transformer() {\n  var x0 = 0,\n      x1 = 1,\n      t0,\n      t1,\n      k10,\n      transform,\n      interpolator = continuous_identity,\n      clamp = false,\n      unknown;\n\n  function scale(x) {\n    return isNaN(x = +x) ? unknown : interpolator(k10 === 0 ? 0.5 : (x = (transform(x) - t0) * k10, clamp ? Math.max(0, Math.min(1, x)) : x));\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (t0 = transform(x0 = +_[0]), t1 = transform(x1 = +_[1]), k10 = t0 === t1 ? 0 : 1 / (t1 - t0), scale) : [x0, x1];\n  };\n\n  scale.clamp = function(_) {\n    return arguments.length ? (clamp = !!_, scale) : clamp;\n  };\n\n  scale.interpolator = function(_) {\n    return arguments.length ? (interpolator = _, scale) : interpolator;\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  return function(t) {\n    transform = t, t0 = t(x0), t1 = t(x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0);\n    return scale;\n  };\n}\n\nfunction sequential_copy(source, target) {\n  return target\n      .domain(source.domain())\n      .interpolator(source.interpolator())\n      .clamp(source.clamp())\n      .unknown(source.unknown());\n}\n\nfunction sequential() {\n  var scale = linearish(sequential_transformer()(continuous_identity));\n\n  scale.copy = function() {\n    return sequential_copy(scale, sequential());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction sequentialLog() {\n  var scale = loggish(sequential_transformer()).domain([1, 10]);\n\n  scale.copy = function() {\n    return sequential_copy(scale, sequentialLog()).base(scale.base());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction sequentialSymlog() {\n  var scale = symlogish(sequential_transformer());\n\n  scale.copy = function() {\n    return sequential_copy(scale, sequentialSymlog()).constant(scale.constant());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction sequentialPow() {\n  var scale = powish(sequential_transformer());\n\n  scale.copy = function() {\n    return sequential_copy(scale, sequentialPow()).exponent(scale.exponent());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction sequentialSqrt() {\n  return sequentialPow.apply(null, arguments).exponent(0.5);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/sequentialQuantile.js\n\n\n\n\nfunction sequentialQuantile() {\n  var domain = [],\n      interpolator = continuous_identity;\n\n  function scale(x) {\n    if (!isNaN(x = +x)) return interpolator((bisect(domain, x) - 1) / (domain.length - 1));\n  }\n\n  scale.domain = function(_) {\n    if (!arguments.length) return domain.slice();\n    domain = [];\n    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);\n    domain.sort(ascending);\n    return scale;\n  };\n\n  scale.interpolator = function(_) {\n    return arguments.length ? (interpolator = _, scale) : interpolator;\n  };\n\n  scale.copy = function() {\n    return sequentialQuantile(interpolator).domain(domain);\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/diverging.js\n\n\n\n\n\n\n\n\nfunction diverging_transformer() {\n  var x0 = 0,\n      x1 = 0.5,\n      x2 = 1,\n      t0,\n      t1,\n      t2,\n      k10,\n      k21,\n      interpolator = continuous_identity,\n      transform,\n      clamp = false,\n      unknown;\n\n  function scale(x) {\n    return isNaN(x = +x) ? unknown : (x = 0.5 + ((x = +transform(x)) - t1) * (x < t1 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x)) : x));\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (t0 = transform(x0 = +_[0]), t1 = transform(x1 = +_[1]), t2 = transform(x2 = +_[2]), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), scale) : [x0, x1, x2];\n  };\n\n  scale.clamp = function(_) {\n    return arguments.length ? (clamp = !!_, scale) : clamp;\n  };\n\n  scale.interpolator = function(_) {\n    return arguments.length ? (interpolator = _, scale) : interpolator;\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  return function(t) {\n    transform = t, t0 = t(x0), t1 = t(x1), t2 = t(x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1);\n    return scale;\n  };\n}\n\nfunction diverging() {\n  var scale = linearish(diverging_transformer()(continuous_identity));\n\n  scale.copy = function() {\n    return sequential_copy(scale, diverging());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction divergingLog() {\n  var scale = loggish(diverging_transformer()).domain([0.1, 1, 10]);\n\n  scale.copy = function() {\n    return sequential_copy(scale, divergingLog()).base(scale.base());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction divergingSymlog() {\n  var scale = symlogish(diverging_transformer());\n\n  scale.copy = function() {\n    return sequential_copy(scale, divergingSymlog()).constant(scale.constant());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction divergingPow() {\n  var scale = powish(diverging_transformer());\n\n  scale.copy = function() {\n    return sequential_copy(scale, divergingPow()).exponent(scale.exponent());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction divergingSqrt() {\n  return divergingPow.apply(null, arguments).exponent(0.5);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/@vx/scale/dist/vx-scale.es.js\n\n\nvar vx_scale_es_band = (function (_ref) {\n  var range = _ref.range,\n      rangeRound = _ref.rangeRound,\n      domain = _ref.domain,\n      padding = _ref.padding,\n      paddingInner = _ref.paddingInner,\n      paddingOuter = _ref.paddingOuter,\n      align = _ref.align,\n      tickFormat = _ref.tickFormat;\n\n  var scale = band();\n\n  if (range) scale.range(range);\n  if (rangeRound) scale.rangeRound(rangeRound);\n  if (domain) scale.domain(domain);\n  if (padding) scale.padding(padding);\n  if (paddingInner) scale.paddingInner(paddingInner);\n  if (paddingOuter) scale.paddingOuter(paddingOuter);\n  if (align) scale.align(align);\n  if (tickFormat) scale.tickFormat = tickFormat;\n\n  return scale;\n});\n\nvar vx_scale_es_point = (function (_ref) {\n  var range = _ref.range,\n      rangeRound = _ref.rangeRound,\n      domain = _ref.domain,\n      padding = _ref.padding,\n      align = _ref.align,\n      _ref$nice = _ref.nice,\n      nice = _ref$nice === undefined ? false : _ref$nice;\n\n  var scale = point();\n\n  if (range) scale.range(range);\n  if (rangeRound) scale.rangeRound(rangeRound);\n  if (domain) scale.domain(domain);\n  if (nice) scale.nice();\n  if (padding) scale.padding(padding);\n  if (align) scale.align(align);\n\n  return scale;\n});\n\nvar vx_scale_es_linear = (function (_ref) {\n  var range = _ref.range,\n      rangeRound = _ref.rangeRound,\n      domain = _ref.domain,\n      _ref$nice = _ref.nice,\n      nice = _ref$nice === undefined ? false : _ref$nice,\n      _ref$clamp = _ref.clamp,\n      clamp = _ref$clamp === undefined ? false : _ref$clamp;\n\n  var scale = linear();\n\n  if (range) scale.range(range);\n  if (rangeRound) scale.rangeRound(rangeRound);\n  if (domain) scale.domain(domain);\n  if (nice) scale.nice();\n  if (clamp) scale.clamp(true);\n\n  return scale;\n});\n\nvar vx_scale_es_time = (function (_ref) {\n  var range = _ref.range,\n      rangeRound = _ref.rangeRound,\n      domain = _ref.domain,\n      _ref$nice = _ref.nice,\n      nice = _ref$nice === undefined ? false : _ref$nice,\n      _ref$clamp = _ref.clamp,\n      clamp = _ref$clamp === undefined ? false : _ref$clamp;\n\n  var scale = time();\n\n  if (range) scale.range(range);\n  if (rangeRound) scale.rangeRound(rangeRound);\n  if (domain) scale.domain(domain);\n  if (nice) scale.nice();\n  if (clamp) scale.clamp(true);\n\n  return scale;\n});\n\nvar utc = (function (_ref) {\n  var range = _ref.range,\n      rangeRound = _ref.rangeRound,\n      domain = _ref.domain,\n      _ref$nice = _ref.nice,\n      nice = _ref$nice === undefined ? false : _ref$nice,\n      _ref$clamp = _ref.clamp,\n      clamp = _ref$clamp === undefined ? false : _ref$clamp;\n\n  var scale = utcTime();\n\n  if (range) scale.range(range);\n  if (rangeRound) scale.rangeRound(rangeRound);\n  if (domain) scale.domain(domain);\n  if (nice) scale.nice();\n  if (clamp) scale.clamp(true);\n\n  return scale;\n});\n\nvar vx_scale_es_log = (function (_ref) {\n  var range = _ref.range,\n      rangeRound = _ref.rangeRound,\n      domain = _ref.domain,\n      base = _ref.base,\n      _ref$nice = _ref.nice,\n      nice = _ref$nice === undefined ? false : _ref$nice,\n      _ref$clamp = _ref.clamp,\n      clamp = _ref$clamp === undefined ? false : _ref$clamp;\n\n  var scale = log();\n\n  if (range) scale.range(range);\n  if (rangeRound) scale.rangeRound(rangeRound);\n  if (domain) scale.domain(domain);\n  if (nice) scale.nice();\n  if (clamp) scale.clamp(true);\n  if (base) scale.base(base);\n\n  return scale;\n});\n\nvar power = (function (_ref) {\n  var range = _ref.range,\n      rangeRound = _ref.rangeRound,\n      domain = _ref.domain,\n      exponent = _ref.exponent,\n      _ref$nice = _ref.nice,\n      nice = _ref$nice === undefined ? false : _ref$nice,\n      _ref$clamp = _ref.clamp,\n      clamp = _ref$clamp === undefined ? false : _ref$clamp;\n\n  var scale = pow();\n\n  if (range) scale.range(range);\n  if (rangeRound) scale.rangeRound(rangeRound);\n  if (domain) scale.domain(domain);\n  if (nice) scale.nice();\n  if (clamp) scale.clamp(true);\n  if (exponent) scale.exponent(exponent);\n\n  return scale;\n});\n\nvar vx_scale_es_ordinal = (function (_ref) {\n  var range = _ref.range,\n      domain = _ref.domain,\n      unknown = _ref.unknown;\n\n  var scale = ordinal();\n\n  if (range) scale.range(range);\n  if (domain) scale.domain(domain);\n  if (unknown) scale.unknown(unknown);\n\n  return scale;\n});\n\nvar vx_scale_es_quantize = (function (_ref) {\n  var range = _ref.range,\n      domain = _ref.domain,\n      ticks = _ref.ticks,\n      tickFormat = _ref.tickFormat,\n      _ref$nice = _ref.nice,\n      nice = _ref$nice === undefined ? false : _ref$nice;\n\n  var scale = quantize();\n\n  if (range) scale.range(range);\n  if (domain) scale.domain(domain);\n  if (nice) scale.nice();\n  if (ticks) scale.ticks(ticks);\n  if (tickFormat) scale.tickFormat(tickFormat);\n\n  return scale;\n});\n\nvar vx_scale_es_quantile = (function (_ref) {\n  var range = _ref.range,\n      domain = _ref.domain;\n\n  var scale = quantile_quantile();\n\n  if (range) scale.range(range);\n  if (domain) scale.domain(domain);\n\n  return scale;\n});\n\nvar vx_scale_es_threshold = (function (_ref) {\n  var range = _ref.range,\n      domain = _ref.domain;\n\n  var scale = threshold_threshold();\n\n  if (range) scale.range(range);\n  if (domain) scale.domain(domain);\n\n  return scale;\n});\n\nvar vx_scale_es_objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nfunction updateScale(scale, _ref) {\n  var args = vx_scale_es_objectWithoutProperties(_ref, []);\n\n  var nextScale = scale.copy();\n  Object.keys(args).forEach(function (key) {\n    if (nextScale.hasOwnProperty(key)) nextScale[key](args[key]);\n  });\n  return nextScale;\n}\n\n\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-shape/src/line.js\nvar line = __webpack_require__(1388);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-shape/src/curve/cardinal.js\nvar cardinal = __webpack_require__(1330);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/dist/vx-stats.es.js\n\n\n\n\n\n\nfunction callOrValue(maybeFn, data) {\n  if (typeof maybeFn === \'function\') {\n    return maybeFn(data);\n  }\n  return maybeFn;\n}\n\nfunction additionalProps(restProps, data) {\n  return Object.keys(restProps).reduce(function (ret, cur) {\n    ret[cur] = callOrValue(restProps[cur], data);\n    return ret;\n  }, {});\n}\n\nvar vx_stats_es_extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar vx_stats_es_objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i["return"]) _i["return"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError("Invalid attempt to destructure non-iterable instance");\n    }\n  };\n}();\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\nfunction verticalToHorizontal(_ref) {\n  var _ref2 = slicedToArray(_ref, 4),\n      x1 = _ref2[0],\n      y1 = _ref2[1],\n      x2 = _ref2[2],\n      y2 = _ref2[3];\n\n  return [y1, x1, y2, x2];\n}\n\nfunction vx_stats_es_BoxPlot(_ref3) {\n  var _ref3$left = _ref3.left,\n      left = _ref3$left === undefined ? 0 : _ref3$left,\n      _ref3$top = _ref3.top,\n      top = _ref3$top === undefined ? 0 : _ref3$top,\n      className = _ref3.className,\n      data = _ref3.data,\n      max = _ref3.max,\n      min = _ref3.min,\n      firstQuartile = _ref3.firstQuartile,\n      thirdQuartile = _ref3.thirdQuartile,\n      median = _ref3.median,\n      boxWidth = _ref3.boxWidth,\n      fill = _ref3.fill,\n      fillOpacity = _ref3.fillOpacity,\n      stroke = _ref3.stroke,\n      strokeWidth = _ref3.strokeWidth,\n      _ref3$rx = _ref3.rx,\n      rx = _ref3$rx === undefined ? 2 : _ref3$rx,\n      _ref3$ry = _ref3.ry,\n      ry = _ref3$ry === undefined ? 2 : _ref3$ry,\n      valueScale = _ref3.valueScale,\n      outliers = _ref3.outliers,\n      horizontal = _ref3.horizontal,\n      _ref3$medianProps = _ref3.medianProps,\n      medianProps = _ref3$medianProps === undefined ? {} : _ref3$medianProps,\n      _ref3$maxProps = _ref3.maxProps,\n      maxProps = _ref3$maxProps === undefined ? {} : _ref3$maxProps,\n      _ref3$minProps = _ref3.minProps,\n      minProps = _ref3$minProps === undefined ? {} : _ref3$minProps,\n      _ref3$boxProps = _ref3.boxProps,\n      boxProps = _ref3$boxProps === undefined ? {} : _ref3$boxProps,\n      _ref3$outlierProps = _ref3.outlierProps,\n      outlierProps = _ref3$outlierProps === undefined ? {} : _ref3$outlierProps,\n      _ref3$container = _ref3.container,\n      container = _ref3$container === undefined ? false : _ref3$container,\n      _ref3$containerProps = _ref3.containerProps,\n      containerProps = _ref3$containerProps === undefined ? {} : _ref3$containerProps,\n      restProps = vx_stats_es_objectWithoutProperties(_ref3, [\'left\', \'top\', \'className\', \'data\', \'max\', \'min\', \'firstQuartile\', \'thirdQuartile\', \'median\', \'boxWidth\', \'fill\', \'fillOpacity\', \'stroke\', \'strokeWidth\', \'rx\', \'ry\', \'valueScale\', \'outliers\', \'horizontal\', \'medianProps\', \'maxProps\', \'minProps\', \'boxProps\', \'outlierProps\', \'container\', \'containerProps\']);\n\n  var offset = horizontal ? top : left;\n  var center = offset + boxWidth / 2;\n\n  var maxLinePos = Array(4).fill(0);\n  var maxToBoxLinePos = Array(4).fill(0);\n  var boxPos = Array(4).fill(0);\n  var medianLinePos = Array(4).fill(0);\n  var minToBoxLinePos = Array(4).fill(0);\n  var minLinePos = Array(4).fill(0);\n  var containerPos = Array(4).fill(0);\n\n  // all of these are [x0, y0, x1, y1]\n  maxLinePos[0] = center - boxWidth / 4;\n  maxLinePos[1] = valueScale(max);\n  maxLinePos[2] = center + boxWidth / 4;\n  maxLinePos[3] = valueScale(max);\n\n  maxToBoxLinePos[0] = center;\n  maxToBoxLinePos[1] = valueScale(max);\n  maxToBoxLinePos[2] = center;\n  maxToBoxLinePos[3] = valueScale(thirdQuartile);\n\n  boxPos[0] = offset;\n  boxPos[1] = valueScale(thirdQuartile);\n  boxPos[2] = boxWidth;\n  boxPos[3] = Math.abs(valueScale(thirdQuartile) - valueScale(firstQuartile));\n\n  medianLinePos[0] = offset;\n  medianLinePos[1] = valueScale(median);\n  medianLinePos[2] = offset + boxWidth;\n  medianLinePos[3] = valueScale(median);\n\n  minToBoxLinePos[0] = center;\n  minToBoxLinePos[1] = valueScale(firstQuartile);\n  minToBoxLinePos[2] = center;\n  minToBoxLinePos[3] = valueScale(min);\n\n  minLinePos[0] = center - boxWidth / 4;\n  minLinePos[1] = valueScale(min);\n  minLinePos[2] = center + boxWidth / 4;\n  minLinePos[3] = valueScale(min);\n\n  var valueRange = valueScale.range();\n  containerPos[0] = boxPos[0];\n  containerPos[1] = Math.min.apply(Math, toConsumableArray(valueRange));\n  containerPos[2] = boxPos[2];\n  containerPos[3] = Math.abs(valueRange[0] - valueRange[1]);\n\n  if (horizontal) {\n    maxLinePos = verticalToHorizontal(maxLinePos);\n    maxToBoxLinePos = verticalToHorizontal(maxToBoxLinePos);\n    boxPos = verticalToHorizontal(boxPos);\n    boxPos[0] = valueScale(firstQuartile);\n    medianLinePos = verticalToHorizontal(medianLinePos);\n    minToBoxLinePos = verticalToHorizontal(minToBoxLinePos);\n    minLinePos = verticalToHorizontal(minLinePos);\n    containerPos = verticalToHorizontal(containerPos);\n    containerPos[0] = Math.min.apply(Math, toConsumableArray(valueRange));\n  }\n  return react_default.a.createElement(\n    Group,\n    { className: classnames_default()(\'vx-boxplot\', className) },\n    outliers.map(function (d, i) {\n      var cx = horizontal ? valueScale(d) : center;\n      var cy = horizontal ? center : valueScale(d);\n      return react_default.a.createElement(\'circle\', vx_stats_es_extends({\n        key: i,\n        className: \'vx-boxplot-outlier\',\n        cx: cx,\n        cy: cy,\n        stroke: stroke,\n        strokeWidth: 1,\n        fill: fill,\n        fillOpacity: fillOpacity,\n        r: \'4\'\n      }, additionalProps(outlierProps, {\n        data: d,\n        cx: cx,\n        cy: cy\n      })));\n    }),\n    react_default.a.createElement(\'line\', vx_stats_es_extends({\n      className: \'vx-boxplot-max\',\n      x1: maxLinePos[0],\n      y1: maxLinePos[1],\n      x2: maxLinePos[2],\n      y2: maxLinePos[3],\n      stroke: stroke,\n      strokeWidth: strokeWidth\n    }, additionalProps(maxProps, {\n      data: data,\n      max: max,\n      x1: maxLinePos[0],\n      x2: maxLinePos[2],\n      y1: maxLinePos[1],\n      y2: maxLinePos[3]\n    }))),\n    react_default.a.createElement(\'line\', {\n      x1: maxToBoxLinePos[0],\n      y1: maxToBoxLinePos[1],\n      x2: maxToBoxLinePos[2],\n      y2: maxToBoxLinePos[3],\n      stroke: stroke,\n      strokeWidth: strokeWidth\n    }),\n    react_default.a.createElement(\'rect\', vx_stats_es_extends({\n      className: \'vx-boxplot-box\',\n      x: boxPos[0],\n      y: boxPos[1],\n      width: boxPos[2],\n      height: boxPos[3],\n      stroke: stroke,\n      strokeWidth: strokeWidth,\n      fill: fill,\n      fillOpacity: fillOpacity,\n      rx: rx,\n      ry: ry\n    }, additionalProps(boxProps, {\n      data: data,\n      height: boxPos[3],\n      median: median,\n      firstQuartile: firstQuartile,\n      thirdQuartile: thirdQuartile,\n      min: min,\n      max: max,\n      x1: boxPos[0],\n      x2: boxPos[0] + boxPos[2],\n      y1: boxPos[1],\n      y2: boxPos[1] + boxPos[3]\n    }))),\n    react_default.a.createElement(\'line\', vx_stats_es_extends({\n      className: \'vx-boxplot-median\',\n      x1: medianLinePos[0],\n      y1: medianLinePos[1],\n      x2: medianLinePos[2],\n      y2: medianLinePos[3],\n      stroke: stroke,\n      strokeWidth: strokeWidth\n    }, additionalProps(medianProps, {\n      data: data,\n      median: median,\n      x1: medianLinePos[0],\n      x2: medianLinePos[2],\n      y1: medianLinePos[1],\n      y2: medianLinePos[3]\n    }))),\n    react_default.a.createElement(\'line\', {\n      x1: minToBoxLinePos[0],\n      y1: minToBoxLinePos[1],\n      x2: minToBoxLinePos[2],\n      y2: minToBoxLinePos[3],\n      stroke: stroke,\n      strokeWidth: strokeWidth\n    }),\n    react_default.a.createElement(\'line\', vx_stats_es_extends({\n      className: \'vx-boxplot-min\',\n      x1: minLinePos[0],\n      y1: minLinePos[1],\n      x2: minLinePos[2],\n      y2: minLinePos[3],\n      stroke: stroke,\n      strokeWidth: strokeWidth\n    }, additionalProps(minProps, {\n      data: data,\n      min: min,\n      x1: minLinePos[0],\n      x2: minLinePos[2],\n      y1: minLinePos[1],\n      y2: minLinePos[3]\n    }))),\n    container && react_default.a.createElement(\'rect\', vx_stats_es_extends({\n      x: containerPos[0],\n      y: containerPos[1],\n      width: containerPos[2],\n      height: containerPos[3],\n      fillOpacity: \'0\'\n    }, additionalProps(containerProps, {\n      data: data,\n      x1: containerPos[0],\n      x2: containerPos[0] + containerPos[2],\n      y1: containerPos[1],\n      y2: containerPos[1] + containerPos[3],\n      median: median,\n      max: max,\n      min: min,\n      thirdQuartile: thirdQuartile,\n      firstQuartile: firstQuartile\n    })))\n  );\n}\n\nfunction ViolinPlot(_ref) {\n  var _ref$left = _ref.left,\n      left = _ref$left === undefined ? 0 : _ref$left,\n      _ref$top = _ref.top,\n      top = _ref$top === undefined ? 0 : _ref$top,\n      className = _ref.className,\n      binData = _ref.binData,\n      _ref$stroke = _ref.stroke,\n      stroke = _ref$stroke === undefined ? \'black\' : _ref$stroke,\n      _ref$fill = _ref.fill,\n      fill = _ref$fill === undefined ? \'rgba(0,0,0,0.3)\' : _ref$fill,\n      opacity = _ref.opacity,\n      strokeWidth = _ref.strokeWidth,\n      width = _ref.width,\n      valueScale = _ref.valueScale,\n      strokeDasharray = _ref.strokeDasharray,\n      horizontal = _ref.horizontal,\n      restProps = vx_stats_es_objectWithoutProperties(_ref, [\'left\', \'top\', \'className\', \'binData\', \'stroke\', \'fill\', \'opacity\', \'strokeWidth\', \'width\', \'valueScale\', \'strokeDasharray\', \'horizontal\']);\n\n  var center = (horizontal ? top : left) + width / 2;\n  var binCounts = binData.map(function (bin) {\n    return bin.count;\n  });\n  var widthScale = vx_scale_es_linear({\n    rangeRound: [0, width / 2],\n    domain: [0, Math.max.apply(Math, toConsumableArray(binCounts))]\n  });\n\n  var path = \'\';\n  if (horizontal) {\n    var topCurve = Object(line["a" /* default */])().x(function (d) {\n      return valueScale(d.value);\n    }).y(function (d) {\n      return center - widthScale(d.count);\n    }).curve(cardinal["b" /* default */]);\n\n    var bottomCurve = Object(line["a" /* default */])().x(function (d) {\n      return valueScale(d.value);\n    }).y(function (d) {\n      return center + widthScale(d.count);\n    }).curve(cardinal["b" /* default */]);\n\n    var topCurvePath = topCurve(binData);\n    var bottomCurvePath = bottomCurve([].concat(toConsumableArray(binData)).reverse());\n    path = topCurvePath + \' \' + bottomCurvePath.replace(\'M\', \'L\') + \' Z\';\n  } else {\n    var rightCurve = Object(line["a" /* default */])().x(function (d) {\n      return center + widthScale(d.count);\n    }).y(function (d) {\n      return valueScale(d.value);\n    }).curve(cardinal["b" /* default */]);\n\n    var leftCurve = Object(line["a" /* default */])().x(function (d) {\n      return center - widthScale(d.count);\n    }).y(function (d) {\n      return valueScale(d.value);\n    }).curve(cardinal["b" /* default */]);\n\n    var rightCurvePath = rightCurve(binData);\n    var leftCurvePath = leftCurve([].concat(toConsumableArray(binData)).reverse());\n    path = rightCurvePath + \' \' + leftCurvePath.replace(\'M\', \'L\') + \' Z\';\n  }\n  return react_default.a.createElement(\n    Group,\n    { className: classnames_default()(\'vx-violin\', className) },\n    react_default.a.createElement(\'path\', vx_stats_es_extends({\n      d: path,\n      stroke: stroke,\n      strokeWidth: strokeWidth,\n      strokeDasharray: strokeDasharray,\n      fill: fill,\n      fillOpacity: opacity\n    }, additionalProps(restProps, binData)))\n  );\n}\n\nfunction computeStats (numericalArray) {\n  var points = [].concat(toConsumableArray(numericalArray)).sort(function (a, b) {\n    return a - b;\n  });\n  var sampleSize = points.length;\n  var firstQuartile = points[Math.round(sampleSize / 4)];\n  var thirdQuartile = points[Math.round(3 * sampleSize / 4)];\n  var IQR = thirdQuartile - firstQuartile;\n\n  var min = firstQuartile - 1.5 * IQR;\n  var max = thirdQuartile + 1.5 * IQR;\n\n  var outliers = points.filter(function (p) {\n    return p < min || p > max;\n  });\n  var binWidth = 2 * IQR * Math.pow(sampleSize - outliers.length, -1 / 3);\n  var binNum = Math.round((max - min) / binWidth);\n  var actualBinWidth = (max - min) / binNum;\n\n  var bins = Array(binNum + 2).fill(0);\n  var values = Array(binNum + 2).fill(min);\n\n  for (var i = 1; i <= binNum; i += 1) {\n    values[i] += actualBinWidth * (i - 0.5);\n  }\n\n  values[values.length - 1] = max;\n\n  points.filter(function (p) {\n    return p >= min && p <= max;\n  }).forEach(function (p) {\n    bins[Math.floor((p - min) / actualBinWidth) + 1] += 1;\n  });\n\n  var binData = values.map(function (v, i) {\n    return {\n      value: v,\n      count: bins[i]\n    };\n  });\n\n  var boxPlot = {\n    min: min,\n    firstQuartile: firstQuartile,\n    median: points[Math.round(sampleSize / 2)],\n    thirdQuartile: thirdQuartile,\n    max: max,\n    outliers: outliers\n  };\n\n  return {\n    boxPlot: boxPlot,\n    binData: binData\n  };\n}\n\n\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/shared/esm/components/FocusBlurHandler.js\nvar FocusBlurHandler = __webpack_require__(2335);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/node_modules/@vx/group/dist/vx-group.es.js\nvar vx_group_es = __webpack_require__(1303);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/prop-types/index.js\nvar prop_types = __webpack_require__(6);\nvar prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/theme/esm/color.js\nvar esm_color = __webpack_require__(1393);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/utils/chartUtils.js\nvar chartUtils = __webpack_require__(1300);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/utils/propShapes.js\nvar propShapes = __webpack_require__(1305);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/utils/sharedSeriesProps.js\nvar sharedSeriesProps = __webpack_require__(1357);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/series/BoxPlotSeries.js\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nfunction BoxPlotSeries_extends() { BoxPlotSeries_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return BoxPlotSeries_extends.apply(this, arguments); }\n\n\n\n\n\n\n\n\n\n\n\nvar propTypes = BoxPlotSeries_extends({}, sharedSeriesProps["a" /* default */], {\n  containerEvents: prop_types_default.a.bool,\n  data: propShapes["c" /* boxPlotSeriesDataShape */].isRequired,\n  fill: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.string]),\n  horizontal: prop_types_default.a.bool,\n  stroke: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.string]),\n  strokeWidth: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  fillOpacity: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  widthRatio: prop_types_default.a.number,\n  containerProps: prop_types_default.a.object,\n  // eslint-disable-line react/forbid-prop-types\n  outlierProps: prop_types_default.a.object,\n  // eslint-disable-line react/forbid-prop-types\n  boxProps: prop_types_default.a.object,\n  // eslint-disable-line react/forbid-prop-types\n  minProps: prop_types_default.a.object,\n  // eslint-disable-line react/forbid-prop-types\n  maxProps: prop_types_default.a.object,\n  // eslint-disable-line react/forbid-prop-types\n  medianProps: prop_types_default.a.object // eslint-disable-line react/forbid-prop-types\n\n});\n\nvar defaultProps = {\n  containerEvents: true,\n  stroke: esm_color["a" /* default */].darkGray,\n  strokeWidth: 2,\n  fill: esm_color["a" /* default */].default,\n  fillOpacity: 1,\n  horizontal: false,\n  widthRatio: 1,\n  containerProps: null,\n  outlierProps: null,\n  boxProps: null,\n  minProps: null,\n  maxProps: null,\n  medianProps: null\n};\nvar MAX_BOX_WIDTH = 50;\n\nvar BoxPlotSeries_x = function x(d) {\n  return d.x;\n};\n\nvar BoxPlotSeries_y = function y(d) {\n  return d.y;\n};\n\nvar BoxPlotSeries_min = function min(d) {\n  return d.min;\n};\n\nvar BoxPlotSeries_max = function max(d) {\n  return d.max;\n};\n\nvar BoxPlotSeries_median = function median(d) {\n  return d.median;\n};\n\nvar BoxPlotSeries_firstQuartile = function firstQuartile(d) {\n  return d.firstQuartile;\n};\n\nvar BoxPlotSeries_thirdQuartile = function thirdQuartile(d) {\n  return d.thirdQuartile;\n};\n\nvar BoxPlotSeries_outliers = function outliers(d) {\n  return d.outliers || [];\n};\n\nvar BoxPlotSeries_BoxPlotSeries =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inheritsLoose(BoxPlotSeries, _React$PureComponent);\n\n  function BoxPlotSeries() {\n    return _React$PureComponent.apply(this, arguments) || this;\n  }\n\n  var _proto = BoxPlotSeries.prototype;\n\n  _proto.render = function render() {\n    var _this$props = this.props,\n        containerEvents = _this$props.containerEvents,\n        data = _this$props.data,\n        fill = _this$props.fill,\n        stroke = _this$props.stroke,\n        strokeWidth = _this$props.strokeWidth,\n        xScale = _this$props.xScale,\n        yScale = _this$props.yScale,\n        horizontal = _this$props.horizontal,\n        widthRatio = _this$props.widthRatio,\n        fillOpacity = _this$props.fillOpacity,\n        containerProps = _this$props.containerProps,\n        outlierProps = _this$props.outlierProps,\n        boxProps = _this$props.boxProps,\n        minProps = _this$props.minProps,\n        maxProps = _this$props.maxProps,\n        medianProps = _this$props.medianProps,\n        onMouseMove = _this$props.onMouseMove,\n        onMouseLeave = _this$props.onMouseLeave,\n        disableMouseEvents = _this$props.disableMouseEvents,\n        onClick = _this$props.onClick;\n    if (!xScale || !yScale) return null;\n    var offsetScale = horizontal ? yScale : xScale;\n    var offsetValue = horizontal ? BoxPlotSeries_y : BoxPlotSeries_x;\n    var valueScale = horizontal ? xScale : yScale;\n    var boxWidth = offsetScale.bandwidth();\n    var actualWidth = Math.min(MAX_BOX_WIDTH, boxWidth);\n    var offset = (offsetScale.offset || 0) - (boxWidth - actualWidth) / 2;\n    var offsetPropName = horizontal ? \'top\' : \'left\';\n\n    var offsetProp = function offsetProp(d) {\n      var _ref;\n\n      return _ref = {}, _ref[offsetPropName] = offsetScale(offsetValue(d)) - offset + (1 - widthRatio) / 2 * actualWidth, _ref;\n    };\n\n    var mouseEventProps = function mouseEventProps(d, i) {\n      return {\n        onMouseMove: disableMouseEvents ? null : onMouseMove && function () {\n          return function (event) {\n            onMouseMove({\n              event: event,\n              data: data,\n              datum: d,\n              index: i\n            });\n          };\n        },\n        onMouseLeave: disableMouseEvents ? null : onMouseLeave && function () {\n          return onMouseLeave;\n        },\n        onClick: disableMouseEvents ? null : onClick && function () {\n          return function (event) {\n            onClick({\n              event: event,\n              data: data,\n              datum: d,\n              index: i\n            });\n          };\n        }\n      };\n    };\n\n    return react_default.a.createElement(vx_group_es["a" /* Group */], null, data.map(function (d, i) {\n      var mouseEvents = mouseEventProps(d, i);\n      return Object(chartUtils["j" /* isDefined */])(BoxPlotSeries_min(d)) && react_default.a.createElement(FocusBlurHandler["a" /* default */], {\n        key: offsetValue(d),\n        xlinkHref: "#",\n        onBlur: disableMouseEvents ? null : onMouseLeave,\n        onFocus: disableMouseEvents ? null : function (event) {\n          onMouseMove({\n            event: event,\n            data: data,\n            datum: d,\n            index: i\n          });\n        }\n      }, react_default.a.createElement(vx_stats_es_BoxPlot, BoxPlotSeries_extends({\n        min: BoxPlotSeries_min(d),\n        max: BoxPlotSeries_max(d)\n      }, offsetProp(d), {\n        firstQuartile: BoxPlotSeries_firstQuartile(d),\n        thirdQuartile: BoxPlotSeries_thirdQuartile(d),\n        median: BoxPlotSeries_median(d),\n        boxWidth: actualWidth * widthRatio,\n        outliers: BoxPlotSeries_outliers(d),\n        fill: d.fill || Object(chartUtils["b" /* callOrValue */])(fill, d, i),\n        stroke: d.stroke || Object(chartUtils["b" /* callOrValue */])(stroke, d, i),\n        strokeWidth: d.strokeWidth || Object(chartUtils["b" /* callOrValue */])(strokeWidth, d, i),\n        fillOpacity: d.fillOpacity || Object(chartUtils["b" /* callOrValue */])(fillOpacity, d, i),\n        valueScale: valueScale,\n        horizontal: horizontal,\n        container: containerEvents,\n        containerProps: (containerEvents || containerProps || undefined) && BoxPlotSeries_extends({}, containerProps, containerEvents && mouseEvents),\n        outlierProps: (!containerEvents || outlierProps || undefined) && BoxPlotSeries_extends({}, outlierProps, !containerEvents && mouseEvents),\n        boxProps: (!containerEvents || boxProps || undefined) && BoxPlotSeries_extends({}, boxProps, !containerEvents && mouseEvents),\n        minProps: (!containerEvents || minProps || undefined) && BoxPlotSeries_extends({}, minProps, !containerEvents && mouseEvents),\n        maxProps: (!containerEvents || maxProps || undefined) && BoxPlotSeries_extends({}, maxProps, !containerEvents && mouseEvents),\n        medianProps: (!containerEvents || medianProps || undefined) && BoxPlotSeries_extends({}, medianProps, !containerEvents && mouseEvents)\n      })));\n    }));\n  };\n\n  return BoxPlotSeries;\n}(react_default.a.PureComponent);\n\n\nBoxPlotSeries_BoxPlotSeries.propTypes = propTypes;\nBoxPlotSeries_BoxPlotSeries.defaultProps = defaultProps;\nBoxPlotSeries_BoxPlotSeries.displayName = \'BoxPlotSeries\';\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/theme/esm/chartTheme.js + 2 modules\nvar chartTheme = __webpack_require__(2364);\n\n// EXTERNAL MODULE: ../superset-ui-chart-composition/src/legend/WithLegend.tsx\nvar WithLegend = __webpack_require__(1728);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/node_modules/encodable/esm/index.js\nvar esm = __webpack_require__(408);\n\n// EXTERNAL MODULE: ../superset-ui-core/src/utils/isDefined.ts\nvar isDefined = __webpack_require__(1262);\n\n// EXTERNAL MODULE: ../superset-ui-chart-composition/src/tooltip/TooltipFrame.tsx\nvar TooltipFrame = __webpack_require__(1602);\n\n// EXTERNAL MODULE: ../superset-ui-chart-composition/src/tooltip/TooltipTable.tsx\nvar TooltipTable = __webpack_require__(1603);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/components/BoxPlot/DefaultTooltipRenderer.tsx\n\n\n\nfunction DefaultTooltipRenderer({ datum, color, encoder, }) {\n    const { label, min, max, median, firstQuartile, thirdQuartile, outliers } = datum;\n    const { channels } = encoder;\n    const { formatValue } = channels.y;\n    const data = [];\n    if (Object(isDefined["a" /* default */])(min)) {\n        data.push({ key: \'Min\', valueColumn: formatValue(min) });\n    }\n    if (Object(isDefined["a" /* default */])(max)) {\n        data.push({ key: \'Max\', valueColumn: formatValue(max) });\n    }\n    if (Object(isDefined["a" /* default */])(median)) {\n        data.push({ key: \'Median\', valueColumn: formatValue(median) });\n    }\n    if (Object(isDefined["a" /* default */])(firstQuartile)) {\n        data.push({ key: \'1st Quartile\', valueColumn: formatValue(firstQuartile) });\n    }\n    if (Object(isDefined["a" /* default */])(thirdQuartile)) {\n        data.push({ key: \'3rd Quartile\', valueColumn: formatValue(thirdQuartile) });\n    }\n    if (Object(isDefined["a" /* default */])(outliers) && outliers.length > 0) {\n        data.push({ key: \'# Outliers\', valueColumn: outliers.length });\n    }\n    return (react_default.a.createElement(TooltipFrame["a" /* default */], null,\n        react_default.a.createElement("div", null,\n            react_default.a.createElement("strong", { style: { color } }, label)),\n        data.length > 0 && react_default.a.createElement("br", null),\n        react_default.a.createElement(TooltipTable["a" /* default */], { data: data })));\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/components/BoxPlot/Encoder.ts\n\nconst boxPlotEncoderFactory = Object(esm["createEncoderFactory"])({\n    channelTypes: {\n        x: \'XBand\',\n        y: \'YBand\',\n        color: \'Color\',\n    },\n    defaultEncoding: {\n        x: { field: \'x\', type: \'nominal\' },\n        y: { field: \'y\', type: \'quantitative\' },\n        color: { value: \'#222\' },\n    },\n});\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/utils/createMarginSelector.tsx\nvar createMarginSelector = __webpack_require__(1382);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/utils/convertScaleToDataUIScaleShape.ts\nvar convertScaleToDataUIScaleShape = __webpack_require__(1383);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/utils/createXYChartLayoutWithTheme.ts + 5 modules\nvar createXYChartLayoutWithTheme = __webpack_require__(1385);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/components/legend/createRenderLegend.tsx + 3 modules\nvar createRenderLegend = __webpack_require__(1386);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/components/BoxPlot/BoxPlot.tsx\n\n\n\n\n\n\n\n\n\n\n\nconst BoxPlot_defaultProps = {\n    className: \'\',\n    margin: createMarginSelector["a" /* DEFAULT_MARGIN */],\n    encoding: {},\n    theme: chartTheme["a" /* default */],\n    TooltipRenderer: DefaultTooltipRenderer,\n};\nclass BoxPlot_BoxPlot extends react_default.a.PureComponent {\n    constructor() {\n        super(...arguments);\n        this.createEncoder = boxPlotEncoderFactory.createSelector();\n        this.createMargin = Object(createMarginSelector["b" /* default */])();\n        this.renderChart = (dim) => {\n            const { width, height } = dim;\n            const { data, margin, theme, TooltipRenderer, encoding } = this.props;\n            const encoder = this.createEncoder(encoding);\n            const { channels } = encoder;\n            const isHorizontal = Object(esm["isFieldDef"])(channels.y.definition) && channels.y.definition.type === \'nominal\';\n            encoder.setDomainFromDataset(data);\n            const layout = Object(createXYChartLayoutWithTheme["a" /* default */])({\n                width,\n                height,\n                margin: this.createMargin(margin),\n                theme,\n                xEncoder: channels.x,\n                yEncoder: channels.y,\n            });\n            return layout.renderChartWithFrame((chartDim) => (react_default.a.createElement(XYChart["a" /* default */], { showYGrid: true, width: chartDim.width, height: chartDim.height, ariaLabel: "BoxPlot", margin: layout.margin, renderTooltip: ({ datum, color }) => (react_default.a.createElement(TooltipRenderer, { datum: datum, color: color, encoder: encoder })), theme: theme, \n                // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-explicit-any\n                xScale: Object(convertScaleToDataUIScaleShape["a" /* default */])(channels.x.definition.scale), \n                // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-explicit-any\n                yScale: Object(convertScaleToDataUIScaleShape["a" /* default */])(channels.y.definition.scale) },\n                layout.renderXAxis(),\n                layout.renderYAxis(),\n                react_default.a.createElement(BoxPlotSeries_BoxPlotSeries, { key: Object(esm["isFieldDef"])(channels.x.definition) ? channels.x.definition.field : \'\', animated: true, data: isHorizontal\n                        ? data.map(row => (Object.assign(Object.assign({}, row), { y: channels.y.getValueFromDatum(row) })))\n                        : data.map(row => (Object.assign(Object.assign({}, row), { x: channels.x.getValueFromDatum(row) }))), fill: (datum) => channels.color.encodeDatum(datum, \'#55acee\'), fillOpacity: 0.4, stroke: (datum) => channels.color.encodeDatum(datum), strokeWidth: 1, widthRatio: 0.6, horizontal: isHorizontal }))));\n        };\n    }\n    render() {\n        const { className, data, encoding, width, height } = this.props;\n        return (react_default.a.createElement(WithLegend["a" /* default */], { className: `superset-chart-box-plot ${className}`, width: width, height: height, position: "top", renderLegend: Object(createRenderLegend["a" /* default */])(this.createEncoder(encoding), data, this.props), renderChart: this.renderChart }));\n    }\n}\nBoxPlot_BoxPlot.defaultProps = BoxPlot_defaultProps;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjM0Mi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0B2eC9zdGF0cy9ub2RlX21vZHVsZXMvQHZ4L2dyb3VwL2Rpc3QvdngtZ3JvdXAuZXMuanM/YzlmMCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9Adngvc3RhdHMvbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9hc2NlbmRpbmcuanM/YWNkNCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9Adngvc3RhdHMvbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9iaXNlY3Rvci5qcz8wMjNjIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0B2eC9zdGF0cy9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2Jpc2VjdC5qcz8xNWM3Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0B2eC9zdGF0cy9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL3BhaXJzLmpzP2RiYzkiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L3N0YXRzL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvY3Jvc3MuanM/ZGE2OCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9Adngvc3RhdHMvbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9kZXNjZW5kaW5nLmpzPzAyNjQiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L3N0YXRzL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvbnVtYmVyLmpzPzkxZGQiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L3N0YXRzL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvdmFyaWFuY2UuanM/MjdiMyIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9Adngvc3RhdHMvbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9kZXZpYXRpb24uanM/MDEyOCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9Adngvc3RhdHMvbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9leHRlbnQuanM/MzAzYSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9Adngvc3RhdHMvbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9hcnJheS5qcz81NDlhIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0B2eC9zdGF0cy9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2NvbnN0YW50LmpzPzlkY2IiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L3N0YXRzL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvaWRlbnRpdHkuanM/ZTJlMyIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9Adngvc3RhdHMvbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9yYW5nZS5qcz9hZDU4Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0B2eC9zdGF0cy9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL3RpY2tzLmpzPzhmNjEiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L3N0YXRzL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvdGhyZXNob2xkL3N0dXJnZXMuanM/YTM0YiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9Adngvc3RhdHMvbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9oaXN0b2dyYW0uanM/ODhmNSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9Adngvc3RhdHMvbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9xdWFudGlsZS5qcz9iMWY0Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0B2eC9zdGF0cy9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL3RocmVzaG9sZC9mcmVlZG1hbkRpYWNvbmlzLmpzPzc4ZDQiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L3N0YXRzL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvdGhyZXNob2xkL3Njb3R0LmpzP2IyNDgiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L3N0YXRzL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvbWF4LmpzPzAzNDAiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L3N0YXRzL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvbWVhbi5qcz83NjVkIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0B2eC9zdGF0cy9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL21lZGlhbi5qcz9jMWQxIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0B2eC9zdGF0cy9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL21lcmdlLmpzPzA0ZTIiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L3N0YXRzL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvbWluLmpzPzU5MWYiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L3N0YXRzL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvcGVybXV0ZS5qcz84MmJiIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0B2eC9zdGF0cy9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL3NjYW4uanM/NzZlOCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9Adngvc3RhdHMvbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9zaHVmZmxlLmpzP2E3YzciLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L3N0YXRzL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvc3VtLmpzPzU2MjIiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L3N0YXRzL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvdHJhbnNwb3NlLmpzP2ViYmEiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L3N0YXRzL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvemlwLmpzPzk2NWEiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L3N0YXRzL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvaW5kZXguanM/ODExMiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9Adngvc3RhdHMvbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9pbml0LmpzPzc5OGUiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L3N0YXRzL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvYXJyYXkuanM/ZDIyNyIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9Adngvc3RhdHMvbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9vcmRpbmFsLmpzP2M2N2EiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L3N0YXRzL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvYmFuZC5qcz83ODE2Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0B2eC9zdGF0cy9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL2NvbnN0YW50LmpzPzI4MTciLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L3N0YXRzL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvbnVtYmVyLmpzPzk3NmQiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L3N0YXRzL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvY29udGludW91cy5qcz8zMGUxIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0B2eC9zdGF0cy9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL3RpY2tGb3JtYXQuanM/ZjJiMCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9Adngvc3RhdHMvbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9saW5lYXIuanM/ODlkZCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9Adngvc3RhdHMvbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9pZGVudGl0eS5qcz85ZGRkIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0B2eC9zdGF0cy9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL25pY2UuanM/YzkzMCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9Adngvc3RhdHMvbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9sb2cuanM/MDQ0ZCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9Adngvc3RhdHMvbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9zeW1sb2cuanM/MzY1NSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9Adngvc3RhdHMvbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9wb3cuanM/ODEzZCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9Adngvc3RhdHMvbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9xdWFudGlsZS5qcz80MzI1Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0B2eC9zdGF0cy9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL3F1YW50aXplLmpzP2MxYTkiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L3N0YXRzL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvdGhyZXNob2xkLmpzPzFhNjciLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L3N0YXRzL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvdGltZS5qcz80YWVkIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0B2eC9zdGF0cy9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL3V0Y1RpbWUuanM/ODU5YiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9Adngvc3RhdHMvbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9zZXF1ZW50aWFsLmpzP2M2M2IiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L3N0YXRzL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvc2VxdWVudGlhbFF1YW50aWxlLmpzPzQ4MTYiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L3N0YXRzL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvZGl2ZXJnaW5nLmpzPzI1ODMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L3N0YXRzL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvaW5kZXguanM/N2I4MyIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9Adngvc3RhdHMvbm9kZV9tb2R1bGVzL0B2eC9zY2FsZS9kaXN0L3Z4LXNjYWxlLmVzLmpzPzcxYzYiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L3N0YXRzL2Rpc3Qvdngtc3RhdHMuZXMuanM/YmRiNSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS94eS1jaGFydC9lc20vc2VyaWVzL0JveFBsb3RTZXJpZXMuanM/NTQ2YiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvcHJlc2V0LWNoYXJ0LXh5L3NyYy9jb21wb25lbnRzL0JveFBsb3QvRGVmYXVsdFRvb2x0aXBSZW5kZXJlci50c3g/ZWViNiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvcHJlc2V0LWNoYXJ0LXh5L3NyYy9jb21wb25lbnRzL0JveFBsb3QvRW5jb2Rlci50cz9iYzFiIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wcmVzZXQtY2hhcnQteHkvc3JjL2NvbXBvbmVudHMvQm94UGxvdC9Cb3hQbG90LnRzeD82Y2M5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY3ggZnJvbSAnY2xhc3NuYW1lcyc7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG52YXIgb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgPSBmdW5jdGlvbiAob2JqLCBrZXlzKSB7XG4gIHZhciB0YXJnZXQgPSB7fTtcblxuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7XG4gICAgdGFyZ2V0W2ldID0gb2JqW2ldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbmZ1bmN0aW9uIEdyb3VwKF9yZWYpIHtcbiAgdmFyIF9yZWYkdG9wID0gX3JlZi50b3AsXG4gICAgICB0b3AgPSBfcmVmJHRvcCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkdG9wLFxuICAgICAgX3JlZiRsZWZ0ID0gX3JlZi5sZWZ0LFxuICAgICAgbGVmdCA9IF9yZWYkbGVmdCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkbGVmdCxcbiAgICAgIHRyYW5zZm9ybSA9IF9yZWYudHJhbnNmb3JtLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ3RvcCcsICdsZWZ0JywgJ3RyYW5zZm9ybScsICdjbGFzc05hbWUnLCAnY2hpbGRyZW4nXSk7XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgJ2cnLFxuICAgIF9leHRlbmRzKHtcbiAgICAgIGNsYXNzTmFtZTogY3goJ2N4LWdyb3VwJywgY2xhc3NOYW1lKSxcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtIHx8ICd0cmFuc2xhdGUoJyArIGxlZnQgKyAnLCAnICsgdG9wICsgJyknXG4gICAgfSwgcmVzdFByb3BzKSxcbiAgICBjaGlsZHJlblxuICApO1xufVxuXG5leHBvcnQgeyBHcm91cCB9O1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IGEgPj0gYiA/IDAgOiBOYU47XG59XG4iLCJpbXBvcnQgYXNjZW5kaW5nIGZyb20gXCIuL2FzY2VuZGluZ1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb21wYXJlKSB7XG4gIGlmIChjb21wYXJlLmxlbmd0aCA9PT0gMSkgY29tcGFyZSA9IGFzY2VuZGluZ0NvbXBhcmF0b3IoY29tcGFyZSk7XG4gIHJldHVybiB7XG4gICAgbGVmdDogZnVuY3Rpb24oYSwgeCwgbG8sIGhpKSB7XG4gICAgICBpZiAobG8gPT0gbnVsbCkgbG8gPSAwO1xuICAgICAgaWYgKGhpID09IG51bGwpIGhpID0gYS5sZW5ndGg7XG4gICAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgICB2YXIgbWlkID0gbG8gKyBoaSA+Pj4gMTtcbiAgICAgICAgaWYgKGNvbXBhcmUoYVttaWRdLCB4KSA8IDApIGxvID0gbWlkICsgMTtcbiAgICAgICAgZWxzZSBoaSA9IG1pZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsbztcbiAgICB9LFxuICAgIHJpZ2h0OiBmdW5jdGlvbihhLCB4LCBsbywgaGkpIHtcbiAgICAgIGlmIChsbyA9PSBudWxsKSBsbyA9IDA7XG4gICAgICBpZiAoaGkgPT0gbnVsbCkgaGkgPSBhLmxlbmd0aDtcbiAgICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICAgIHZhciBtaWQgPSBsbyArIGhpID4+PiAxO1xuICAgICAgICBpZiAoY29tcGFyZShhW21pZF0sIHgpID4gMCkgaGkgPSBtaWQ7XG4gICAgICAgIGVsc2UgbG8gPSBtaWQgKyAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxvO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gYXNjZW5kaW5nQ29tcGFyYXRvcihmKSB7XG4gIHJldHVybiBmdW5jdGlvbihkLCB4KSB7XG4gICAgcmV0dXJuIGFzY2VuZGluZyhmKGQpLCB4KTtcbiAgfTtcbn1cbiIsImltcG9ydCBhc2NlbmRpbmcgZnJvbSBcIi4vYXNjZW5kaW5nXCI7XG5pbXBvcnQgYmlzZWN0b3IgZnJvbSBcIi4vYmlzZWN0b3JcIjtcblxudmFyIGFzY2VuZGluZ0Jpc2VjdCA9IGJpc2VjdG9yKGFzY2VuZGluZyk7XG5leHBvcnQgdmFyIGJpc2VjdFJpZ2h0ID0gYXNjZW5kaW5nQmlzZWN0LnJpZ2h0O1xuZXhwb3J0IHZhciBiaXNlY3RMZWZ0ID0gYXNjZW5kaW5nQmlzZWN0LmxlZnQ7XG5leHBvcnQgZGVmYXVsdCBiaXNlY3RSaWdodDtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGFycmF5LCBmKSB7XG4gIGlmIChmID09IG51bGwpIGYgPSBwYWlyO1xuICB2YXIgaSA9IDAsIG4gPSBhcnJheS5sZW5ndGggLSAxLCBwID0gYXJyYXlbMF0sIHBhaXJzID0gbmV3IEFycmF5KG4gPCAwID8gMCA6IG4pO1xuICB3aGlsZSAoaSA8IG4pIHBhaXJzW2ldID0gZihwLCBwID0gYXJyYXlbKytpXSk7XG4gIHJldHVybiBwYWlycztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhaXIoYSwgYikge1xuICByZXR1cm4gW2EsIGJdO1xufVxuIiwiaW1wb3J0IHtwYWlyfSBmcm9tIFwiLi9wYWlyc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZXMwLCB2YWx1ZXMxLCByZWR1Y2UpIHtcbiAgdmFyIG4wID0gdmFsdWVzMC5sZW5ndGgsXG4gICAgICBuMSA9IHZhbHVlczEubGVuZ3RoLFxuICAgICAgdmFsdWVzID0gbmV3IEFycmF5KG4wICogbjEpLFxuICAgICAgaTAsXG4gICAgICBpMSxcbiAgICAgIGksXG4gICAgICB2YWx1ZTA7XG5cbiAgaWYgKHJlZHVjZSA9PSBudWxsKSByZWR1Y2UgPSBwYWlyO1xuXG4gIGZvciAoaTAgPSBpID0gMDsgaTAgPCBuMDsgKytpMCkge1xuICAgIGZvciAodmFsdWUwID0gdmFsdWVzMFtpMF0sIGkxID0gMDsgaTEgPCBuMTsgKytpMSwgKytpKSB7XG4gICAgICB2YWx1ZXNbaV0gPSByZWR1Y2UodmFsdWUwLCB2YWx1ZXMxW2kxXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlcztcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIGIgPCBhID8gLTEgOiBiID4gYSA/IDEgOiBiID49IGEgPyAwIDogTmFOO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4geCA9PT0gbnVsbCA/IE5hTiA6ICt4O1xufVxuIiwiaW1wb3J0IG51bWJlciBmcm9tIFwiLi9udW1iZXJcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWVzLCB2YWx1ZW9mKSB7XG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG0gPSAwLFxuICAgICAgaSA9IC0xLFxuICAgICAgbWVhbiA9IDAsXG4gICAgICB2YWx1ZSxcbiAgICAgIGRlbHRhLFxuICAgICAgc3VtID0gMDtcblxuICBpZiAodmFsdWVvZiA9PSBudWxsKSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGlmICghaXNOYU4odmFsdWUgPSBudW1iZXIodmFsdWVzW2ldKSkpIHtcbiAgICAgICAgZGVsdGEgPSB2YWx1ZSAtIG1lYW47XG4gICAgICAgIG1lYW4gKz0gZGVsdGEgLyArK207XG4gICAgICAgIHN1bSArPSBkZWx0YSAqICh2YWx1ZSAtIG1lYW4pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGVsc2Uge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBpZiAoIWlzTmFOKHZhbHVlID0gbnVtYmVyKHZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSkpIHtcbiAgICAgICAgZGVsdGEgPSB2YWx1ZSAtIG1lYW47XG4gICAgICAgIG1lYW4gKz0gZGVsdGEgLyArK207XG4gICAgICAgIHN1bSArPSBkZWx0YSAqICh2YWx1ZSAtIG1lYW4pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChtID4gMSkgcmV0dXJuIHN1bSAvIChtIC0gMSk7XG59XG4iLCJpbXBvcnQgdmFyaWFuY2UgZnJvbSBcIi4vdmFyaWFuY2VcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYXJyYXksIGYpIHtcbiAgdmFyIHYgPSB2YXJpYW5jZShhcnJheSwgZik7XG4gIHJldHVybiB2ID8gTWF0aC5zcXJ0KHYpIDogdjtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlcywgdmFsdWVvZikge1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBpID0gLTEsXG4gICAgICB2YWx1ZSxcbiAgICAgIG1pbixcbiAgICAgIG1heDtcblxuICBpZiAodmFsdWVvZiA9PSBudWxsKSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIHsgLy8gRmluZCB0aGUgZmlyc3QgY29tcGFyYWJsZSB2YWx1ZS5cbiAgICAgIGlmICgodmFsdWUgPSB2YWx1ZXNbaV0pICE9IG51bGwgJiYgdmFsdWUgPj0gdmFsdWUpIHtcbiAgICAgICAgbWluID0gbWF4ID0gdmFsdWU7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIENvbXBhcmUgdGhlIHJlbWFpbmluZyB2YWx1ZXMuXG4gICAgICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlc1tpXSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKG1pbiA+IHZhbHVlKSBtaW4gPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChtYXggPCB2YWx1ZSkgbWF4ID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZWxzZSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIHsgLy8gRmluZCB0aGUgZmlyc3QgY29tcGFyYWJsZSB2YWx1ZS5cbiAgICAgIGlmICgodmFsdWUgPSB2YWx1ZW9mKHZhbHVlc1tpXSwgaSwgdmFsdWVzKSkgIT0gbnVsbCAmJiB2YWx1ZSA+PSB2YWx1ZSkge1xuICAgICAgICBtaW4gPSBtYXggPSB2YWx1ZTtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHsgLy8gQ29tcGFyZSB0aGUgcmVtYWluaW5nIHZhbHVlcy5cbiAgICAgICAgICBpZiAoKHZhbHVlID0gdmFsdWVvZih2YWx1ZXNbaV0sIGksIHZhbHVlcykpICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChtaW4gPiB2YWx1ZSkgbWluID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAobWF4IDwgdmFsdWUpIG1heCA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbbWluLCBtYXhdO1xufVxuIiwidmFyIGFycmF5ID0gQXJyYXkucHJvdG90eXBlO1xuXG5leHBvcnQgdmFyIHNsaWNlID0gYXJyYXkuc2xpY2U7XG5leHBvcnQgdmFyIG1hcCA9IGFycmF5Lm1hcDtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4geDtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gIHN0YXJ0ID0gK3N0YXJ0LCBzdG9wID0gK3N0b3AsIHN0ZXAgPSAobiA9IGFyZ3VtZW50cy5sZW5ndGgpIDwgMiA/IChzdG9wID0gc3RhcnQsIHN0YXJ0ID0gMCwgMSkgOiBuIDwgMyA/IDEgOiArc3RlcDtcblxuICB2YXIgaSA9IC0xLFxuICAgICAgbiA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXApKSB8IDAsXG4gICAgICByYW5nZSA9IG5ldyBBcnJheShuKTtcblxuICB3aGlsZSAoKytpIDwgbikge1xuICAgIHJhbmdlW2ldID0gc3RhcnQgKyBpICogc3RlcDtcbiAgfVxuXG4gIHJldHVybiByYW5nZTtcbn1cbiIsInZhciBlMTAgPSBNYXRoLnNxcnQoNTApLFxuICAgIGU1ID0gTWF0aC5zcXJ0KDEwKSxcbiAgICBlMiA9IE1hdGguc3FydCgyKTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc3RhcnQsIHN0b3AsIGNvdW50KSB7XG4gIHZhciByZXZlcnNlLFxuICAgICAgaSA9IC0xLFxuICAgICAgbixcbiAgICAgIHRpY2tzLFxuICAgICAgc3RlcDtcblxuICBzdG9wID0gK3N0b3AsIHN0YXJ0ID0gK3N0YXJ0LCBjb3VudCA9ICtjb3VudDtcbiAgaWYgKHN0YXJ0ID09PSBzdG9wICYmIGNvdW50ID4gMCkgcmV0dXJuIFtzdGFydF07XG4gIGlmIChyZXZlcnNlID0gc3RvcCA8IHN0YXJ0KSBuID0gc3RhcnQsIHN0YXJ0ID0gc3RvcCwgc3RvcCA9IG47XG4gIGlmICgoc3RlcCA9IHRpY2tJbmNyZW1lbnQoc3RhcnQsIHN0b3AsIGNvdW50KSkgPT09IDAgfHwgIWlzRmluaXRlKHN0ZXApKSByZXR1cm4gW107XG5cbiAgaWYgKHN0ZXAgPiAwKSB7XG4gICAgc3RhcnQgPSBNYXRoLmNlaWwoc3RhcnQgLyBzdGVwKTtcbiAgICBzdG9wID0gTWF0aC5mbG9vcihzdG9wIC8gc3RlcCk7XG4gICAgdGlja3MgPSBuZXcgQXJyYXkobiA9IE1hdGguY2VpbChzdG9wIC0gc3RhcnQgKyAxKSk7XG4gICAgd2hpbGUgKCsraSA8IG4pIHRpY2tzW2ldID0gKHN0YXJ0ICsgaSkgKiBzdGVwO1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0ID0gTWF0aC5mbG9vcihzdGFydCAqIHN0ZXApO1xuICAgIHN0b3AgPSBNYXRoLmNlaWwoc3RvcCAqIHN0ZXApO1xuICAgIHRpY2tzID0gbmV3IEFycmF5KG4gPSBNYXRoLmNlaWwoc3RhcnQgLSBzdG9wICsgMSkpO1xuICAgIHdoaWxlICgrK2kgPCBuKSB0aWNrc1tpXSA9IChzdGFydCAtIGkpIC8gc3RlcDtcbiAgfVxuXG4gIGlmIChyZXZlcnNlKSB0aWNrcy5yZXZlcnNlKCk7XG5cbiAgcmV0dXJuIHRpY2tzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGlja0luY3JlbWVudChzdGFydCwgc3RvcCwgY291bnQpIHtcbiAgdmFyIHN0ZXAgPSAoc3RvcCAtIHN0YXJ0KSAvIE1hdGgubWF4KDAsIGNvdW50KSxcbiAgICAgIHBvd2VyID0gTWF0aC5mbG9vcihNYXRoLmxvZyhzdGVwKSAvIE1hdGguTE4xMCksXG4gICAgICBlcnJvciA9IHN0ZXAgLyBNYXRoLnBvdygxMCwgcG93ZXIpO1xuICByZXR1cm4gcG93ZXIgPj0gMFxuICAgICAgPyAoZXJyb3IgPj0gZTEwID8gMTAgOiBlcnJvciA+PSBlNSA/IDUgOiBlcnJvciA+PSBlMiA/IDIgOiAxKSAqIE1hdGgucG93KDEwLCBwb3dlcilcbiAgICAgIDogLU1hdGgucG93KDEwLCAtcG93ZXIpIC8gKGVycm9yID49IGUxMCA/IDEwIDogZXJyb3IgPj0gZTUgPyA1IDogZXJyb3IgPj0gZTIgPyAyIDogMSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aWNrU3RlcChzdGFydCwgc3RvcCwgY291bnQpIHtcbiAgdmFyIHN0ZXAwID0gTWF0aC5hYnMoc3RvcCAtIHN0YXJ0KSAvIE1hdGgubWF4KDAsIGNvdW50KSxcbiAgICAgIHN0ZXAxID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoTWF0aC5sb2coc3RlcDApIC8gTWF0aC5MTjEwKSksXG4gICAgICBlcnJvciA9IHN0ZXAwIC8gc3RlcDE7XG4gIGlmIChlcnJvciA+PSBlMTApIHN0ZXAxICo9IDEwO1xuICBlbHNlIGlmIChlcnJvciA+PSBlNSkgc3RlcDEgKj0gNTtcbiAgZWxzZSBpZiAoZXJyb3IgPj0gZTIpIHN0ZXAxICo9IDI7XG4gIHJldHVybiBzdG9wIDwgc3RhcnQgPyAtc3RlcDEgOiBzdGVwMTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlcykge1xuICByZXR1cm4gTWF0aC5jZWlsKE1hdGgubG9nKHZhbHVlcy5sZW5ndGgpIC8gTWF0aC5MTjIpICsgMTtcbn1cbiIsImltcG9ydCB7c2xpY2V9IGZyb20gXCIuL2FycmF5XCI7XG5pbXBvcnQgYmlzZWN0IGZyb20gXCIuL2Jpc2VjdFwiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50XCI7XG5pbXBvcnQgZXh0ZW50IGZyb20gXCIuL2V4dGVudFwiO1xuaW1wb3J0IGlkZW50aXR5IGZyb20gXCIuL2lkZW50aXR5XCI7XG5pbXBvcnQgcmFuZ2UgZnJvbSBcIi4vcmFuZ2VcIjtcbmltcG9ydCB7dGlja1N0ZXB9IGZyb20gXCIuL3RpY2tzXCI7XG5pbXBvcnQgc3R1cmdlcyBmcm9tIFwiLi90aHJlc2hvbGQvc3R1cmdlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIHZhbHVlID0gaWRlbnRpdHksXG4gICAgICBkb21haW4gPSBleHRlbnQsXG4gICAgICB0aHJlc2hvbGQgPSBzdHVyZ2VzO1xuXG4gIGZ1bmN0aW9uIGhpc3RvZ3JhbShkYXRhKSB7XG4gICAgdmFyIGksXG4gICAgICAgIG4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgeCxcbiAgICAgICAgdmFsdWVzID0gbmV3IEFycmF5KG4pO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgdmFsdWVzW2ldID0gdmFsdWUoZGF0YVtpXSwgaSwgZGF0YSk7XG4gICAgfVxuXG4gICAgdmFyIHh6ID0gZG9tYWluKHZhbHVlcyksXG4gICAgICAgIHgwID0geHpbMF0sXG4gICAgICAgIHgxID0geHpbMV0sXG4gICAgICAgIHR6ID0gdGhyZXNob2xkKHZhbHVlcywgeDAsIHgxKTtcblxuICAgIC8vIENvbnZlcnQgbnVtYmVyIG9mIHRocmVzaG9sZHMgaW50byB1bmlmb3JtIHRocmVzaG9sZHMuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHR6KSkge1xuICAgICAgdHogPSB0aWNrU3RlcCh4MCwgeDEsIHR6KTtcbiAgICAgIHR6ID0gcmFuZ2UoTWF0aC5jZWlsKHgwIC8gdHopICogdHosIHgxLCB0eik7IC8vIGV4Y2x1c2l2ZVxuICAgIH1cblxuICAgIC8vIFJlbW92ZSBhbnkgdGhyZXNob2xkcyBvdXRzaWRlIHRoZSBkb21haW4uXG4gICAgdmFyIG0gPSB0ei5sZW5ndGg7XG4gICAgd2hpbGUgKHR6WzBdIDw9IHgwKSB0ei5zaGlmdCgpLCAtLW07XG4gICAgd2hpbGUgKHR6W20gLSAxXSA+IHgxKSB0ei5wb3AoKSwgLS1tO1xuXG4gICAgdmFyIGJpbnMgPSBuZXcgQXJyYXkobSArIDEpLFxuICAgICAgICBiaW47XG5cbiAgICAvLyBJbml0aWFsaXplIGJpbnMuXG4gICAgZm9yIChpID0gMDsgaSA8PSBtOyArK2kpIHtcbiAgICAgIGJpbiA9IGJpbnNbaV0gPSBbXTtcbiAgICAgIGJpbi54MCA9IGkgPiAwID8gdHpbaSAtIDFdIDogeDA7XG4gICAgICBiaW4ueDEgPSBpIDwgbSA/IHR6W2ldIDogeDE7XG4gICAgfVxuXG4gICAgLy8gQXNzaWduIGRhdGEgdG8gYmlucyBieSB2YWx1ZSwgaWdub3JpbmcgYW55IG91dHNpZGUgdGhlIGRvbWFpbi5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICB4ID0gdmFsdWVzW2ldO1xuICAgICAgaWYgKHgwIDw9IHggJiYgeCA8PSB4MSkge1xuICAgICAgICBiaW5zW2Jpc2VjdCh0eiwgeCwgMCwgbSldLnB1c2goZGF0YVtpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJpbnM7XG4gIH1cblxuICBoaXN0b2dyYW0udmFsdWUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodmFsdWUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KF8pLCBoaXN0b2dyYW0pIDogdmFsdWU7XG4gIH07XG5cbiAgaGlzdG9ncmFtLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4gPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KFtfWzBdLCBfWzFdXSksIGhpc3RvZ3JhbSkgOiBkb21haW47XG4gIH07XG5cbiAgaGlzdG9ncmFtLnRocmVzaG9sZHMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGhyZXNob2xkID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBBcnJheS5pc0FycmF5KF8pID8gY29uc3RhbnQoc2xpY2UuY2FsbChfKSkgOiBjb25zdGFudChfKSwgaGlzdG9ncmFtKSA6IHRocmVzaG9sZDtcbiAgfTtcblxuICByZXR1cm4gaGlzdG9ncmFtO1xufVxuIiwiaW1wb3J0IG51bWJlciBmcm9tIFwiLi9udW1iZXJcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWVzLCBwLCB2YWx1ZW9mKSB7XG4gIGlmICh2YWx1ZW9mID09IG51bGwpIHZhbHVlb2YgPSBudW1iZXI7XG4gIGlmICghKG4gPSB2YWx1ZXMubGVuZ3RoKSkgcmV0dXJuO1xuICBpZiAoKHAgPSArcCkgPD0gMCB8fCBuIDwgMikgcmV0dXJuICt2YWx1ZW9mKHZhbHVlc1swXSwgMCwgdmFsdWVzKTtcbiAgaWYgKHAgPj0gMSkgcmV0dXJuICt2YWx1ZW9mKHZhbHVlc1tuIC0gMV0sIG4gLSAxLCB2YWx1ZXMpO1xuICB2YXIgbixcbiAgICAgIGkgPSAobiAtIDEpICogcCxcbiAgICAgIGkwID0gTWF0aC5mbG9vcihpKSxcbiAgICAgIHZhbHVlMCA9ICt2YWx1ZW9mKHZhbHVlc1tpMF0sIGkwLCB2YWx1ZXMpLFxuICAgICAgdmFsdWUxID0gK3ZhbHVlb2YodmFsdWVzW2kwICsgMV0sIGkwICsgMSwgdmFsdWVzKTtcbiAgcmV0dXJuIHZhbHVlMCArICh2YWx1ZTEgLSB2YWx1ZTApICogKGkgLSBpMCk7XG59XG4iLCJpbXBvcnQge21hcH0gZnJvbSBcIi4uL2FycmF5XCI7XG5pbXBvcnQgYXNjZW5kaW5nIGZyb20gXCIuLi9hc2NlbmRpbmdcIjtcbmltcG9ydCBudW1iZXIgZnJvbSBcIi4uL251bWJlclwiO1xuaW1wb3J0IHF1YW50aWxlIGZyb20gXCIuLi9xdWFudGlsZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZXMsIG1pbiwgbWF4KSB7XG4gIHZhbHVlcyA9IG1hcC5jYWxsKHZhbHVlcywgbnVtYmVyKS5zb3J0KGFzY2VuZGluZyk7XG4gIHJldHVybiBNYXRoLmNlaWwoKG1heCAtIG1pbikgLyAoMiAqIChxdWFudGlsZSh2YWx1ZXMsIDAuNzUpIC0gcXVhbnRpbGUodmFsdWVzLCAwLjI1KSkgKiBNYXRoLnBvdyh2YWx1ZXMubGVuZ3RoLCAtMSAvIDMpKSk7XG59XG4iLCJpbXBvcnQgZGV2aWF0aW9uIGZyb20gXCIuLi9kZXZpYXRpb25cIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWVzLCBtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5jZWlsKChtYXggLSBtaW4pIC8gKDMuNSAqIGRldmlhdGlvbih2YWx1ZXMpICogTWF0aC5wb3codmFsdWVzLmxlbmd0aCwgLTEgLyAzKSkpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWVzLCB2YWx1ZW9mKSB7XG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIGkgPSAtMSxcbiAgICAgIHZhbHVlLFxuICAgICAgbWF4O1xuXG4gIGlmICh2YWx1ZW9mID09IG51bGwpIHtcbiAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBGaW5kIHRoZSBmaXJzdCBjb21wYXJhYmxlIHZhbHVlLlxuICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlc1tpXSkgIT0gbnVsbCAmJiB2YWx1ZSA+PSB2YWx1ZSkge1xuICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHsgLy8gQ29tcGFyZSB0aGUgcmVtYWluaW5nIHZhbHVlcy5cbiAgICAgICAgICBpZiAoKHZhbHVlID0gdmFsdWVzW2ldKSAhPSBudWxsICYmIHZhbHVlID4gbWF4KSB7XG4gICAgICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBlbHNlIHtcbiAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBGaW5kIHRoZSBmaXJzdCBjb21wYXJhYmxlIHZhbHVlLlxuICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSAhPSBudWxsICYmIHZhbHVlID49IHZhbHVlKSB7XG4gICAgICAgIG1heCA9IHZhbHVlO1xuICAgICAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBDb21wYXJlIHRoZSByZW1haW5pbmcgdmFsdWVzLlxuICAgICAgICAgIGlmICgodmFsdWUgPSB2YWx1ZW9mKHZhbHVlc1tpXSwgaSwgdmFsdWVzKSkgIT0gbnVsbCAmJiB2YWx1ZSA+IG1heCkge1xuICAgICAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1heDtcbn1cbiIsImltcG9ydCBudW1iZXIgZnJvbSBcIi4vbnVtYmVyXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlcywgdmFsdWVvZikge1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBtID0gbixcbiAgICAgIGkgPSAtMSxcbiAgICAgIHZhbHVlLFxuICAgICAgc3VtID0gMDtcblxuICBpZiAodmFsdWVvZiA9PSBudWxsKSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGlmICghaXNOYU4odmFsdWUgPSBudW1iZXIodmFsdWVzW2ldKSkpIHN1bSArPSB2YWx1ZTtcbiAgICAgIGVsc2UgLS1tO1xuICAgIH1cbiAgfVxuXG4gIGVsc2Uge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBpZiAoIWlzTmFOKHZhbHVlID0gbnVtYmVyKHZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSkpIHN1bSArPSB2YWx1ZTtcbiAgICAgIGVsc2UgLS1tO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtKSByZXR1cm4gc3VtIC8gbTtcbn1cbiIsImltcG9ydCBhc2NlbmRpbmcgZnJvbSBcIi4vYXNjZW5kaW5nXCI7XG5pbXBvcnQgbnVtYmVyIGZyb20gXCIuL251bWJlclwiO1xuaW1wb3J0IHF1YW50aWxlIGZyb20gXCIuL3F1YW50aWxlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlcywgdmFsdWVvZikge1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBpID0gLTEsXG4gICAgICB2YWx1ZSxcbiAgICAgIG51bWJlcnMgPSBbXTtcblxuICBpZiAodmFsdWVvZiA9PSBudWxsKSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGlmICghaXNOYU4odmFsdWUgPSBudW1iZXIodmFsdWVzW2ldKSkpIHtcbiAgICAgICAgbnVtYmVycy5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBlbHNlIHtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgaWYgKCFpc05hTih2YWx1ZSA9IG51bWJlcih2YWx1ZW9mKHZhbHVlc1tpXSwgaSwgdmFsdWVzKSkpKSB7XG4gICAgICAgIG51bWJlcnMucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHF1YW50aWxlKG51bWJlcnMuc29ydChhc2NlbmRpbmcpLCAwLjUpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYXJyYXlzKSB7XG4gIHZhciBuID0gYXJyYXlzLmxlbmd0aCxcbiAgICAgIG0sXG4gICAgICBpID0gLTEsXG4gICAgICBqID0gMCxcbiAgICAgIG1lcmdlZCxcbiAgICAgIGFycmF5O1xuXG4gIHdoaWxlICgrK2kgPCBuKSBqICs9IGFycmF5c1tpXS5sZW5ndGg7XG4gIG1lcmdlZCA9IG5ldyBBcnJheShqKTtcblxuICB3aGlsZSAoLS1uID49IDApIHtcbiAgICBhcnJheSA9IGFycmF5c1tuXTtcbiAgICBtID0gYXJyYXkubGVuZ3RoO1xuICAgIHdoaWxlICgtLW0gPj0gMCkge1xuICAgICAgbWVyZ2VkWy0tal0gPSBhcnJheVttXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWVyZ2VkO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWVzLCB2YWx1ZW9mKSB7XG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIGkgPSAtMSxcbiAgICAgIHZhbHVlLFxuICAgICAgbWluO1xuXG4gIGlmICh2YWx1ZW9mID09IG51bGwpIHtcbiAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBGaW5kIHRoZSBmaXJzdCBjb21wYXJhYmxlIHZhbHVlLlxuICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlc1tpXSkgIT0gbnVsbCAmJiB2YWx1ZSA+PSB2YWx1ZSkge1xuICAgICAgICBtaW4gPSB2YWx1ZTtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHsgLy8gQ29tcGFyZSB0aGUgcmVtYWluaW5nIHZhbHVlcy5cbiAgICAgICAgICBpZiAoKHZhbHVlID0gdmFsdWVzW2ldKSAhPSBudWxsICYmIG1pbiA+IHZhbHVlKSB7XG4gICAgICAgICAgICBtaW4gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBlbHNlIHtcbiAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBGaW5kIHRoZSBmaXJzdCBjb21wYXJhYmxlIHZhbHVlLlxuICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSAhPSBudWxsICYmIHZhbHVlID49IHZhbHVlKSB7XG4gICAgICAgIG1pbiA9IHZhbHVlO1xuICAgICAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBDb21wYXJlIHRoZSByZW1haW5pbmcgdmFsdWVzLlxuICAgICAgICAgIGlmICgodmFsdWUgPSB2YWx1ZW9mKHZhbHVlc1tpXSwgaSwgdmFsdWVzKSkgIT0gbnVsbCAmJiBtaW4gPiB2YWx1ZSkge1xuICAgICAgICAgICAgbWluID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1pbjtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGFycmF5LCBpbmRleGVzKSB7XG4gIHZhciBpID0gaW5kZXhlcy5sZW5ndGgsIHBlcm11dGVzID0gbmV3IEFycmF5KGkpO1xuICB3aGlsZSAoaS0tKSBwZXJtdXRlc1tpXSA9IGFycmF5W2luZGV4ZXNbaV1dO1xuICByZXR1cm4gcGVybXV0ZXM7XG59XG4iLCJpbXBvcnQgYXNjZW5kaW5nIGZyb20gXCIuL2FzY2VuZGluZ1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZXMsIGNvbXBhcmUpIHtcbiAgaWYgKCEobiA9IHZhbHVlcy5sZW5ndGgpKSByZXR1cm47XG4gIHZhciBuLFxuICAgICAgaSA9IDAsXG4gICAgICBqID0gMCxcbiAgICAgIHhpLFxuICAgICAgeGogPSB2YWx1ZXNbal07XG5cbiAgaWYgKGNvbXBhcmUgPT0gbnVsbCkgY29tcGFyZSA9IGFzY2VuZGluZztcblxuICB3aGlsZSAoKytpIDwgbikge1xuICAgIGlmIChjb21wYXJlKHhpID0gdmFsdWVzW2ldLCB4aikgPCAwIHx8IGNvbXBhcmUoeGosIHhqKSAhPT0gMCkge1xuICAgICAgeGogPSB4aSwgaiA9IGk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNvbXBhcmUoeGosIHhqKSA9PT0gMCkgcmV0dXJuIGo7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhcnJheSwgaTAsIGkxKSB7XG4gIHZhciBtID0gKGkxID09IG51bGwgPyBhcnJheS5sZW5ndGggOiBpMSkgLSAoaTAgPSBpMCA9PSBudWxsID8gMCA6ICtpMCksXG4gICAgICB0LFxuICAgICAgaTtcblxuICB3aGlsZSAobSkge1xuICAgIGkgPSBNYXRoLnJhbmRvbSgpICogbS0tIHwgMDtcbiAgICB0ID0gYXJyYXlbbSArIGkwXTtcbiAgICBhcnJheVttICsgaTBdID0gYXJyYXlbaSArIGkwXTtcbiAgICBhcnJheVtpICsgaTBdID0gdDtcbiAgfVxuXG4gIHJldHVybiBhcnJheTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlcywgdmFsdWVvZikge1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBpID0gLTEsXG4gICAgICB2YWx1ZSxcbiAgICAgIHN1bSA9IDA7XG5cbiAgaWYgKHZhbHVlb2YgPT0gbnVsbCkge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBpZiAodmFsdWUgPSArdmFsdWVzW2ldKSBzdW0gKz0gdmFsdWU7IC8vIE5vdGU6IHplcm8gYW5kIG51bGwgYXJlIGVxdWl2YWxlbnQuXG4gICAgfVxuICB9XG5cbiAgZWxzZSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGlmICh2YWx1ZSA9ICt2YWx1ZW9mKHZhbHVlc1tpXSwgaSwgdmFsdWVzKSkgc3VtICs9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdW07XG59XG4iLCJpbXBvcnQgbWluIGZyb20gXCIuL21pblwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihtYXRyaXgpIHtcbiAgaWYgKCEobiA9IG1hdHJpeC5sZW5ndGgpKSByZXR1cm4gW107XG4gIGZvciAodmFyIGkgPSAtMSwgbSA9IG1pbihtYXRyaXgsIGxlbmd0aCksIHRyYW5zcG9zZSA9IG5ldyBBcnJheShtKTsgKytpIDwgbTspIHtcbiAgICBmb3IgKHZhciBqID0gLTEsIG4sIHJvdyA9IHRyYW5zcG9zZVtpXSA9IG5ldyBBcnJheShuKTsgKytqIDwgbjspIHtcbiAgICAgIHJvd1tqXSA9IG1hdHJpeFtqXVtpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRyYW5zcG9zZTtcbn1cblxuZnVuY3Rpb24gbGVuZ3RoKGQpIHtcbiAgcmV0dXJuIGQubGVuZ3RoO1xufVxuIiwiaW1wb3J0IHRyYW5zcG9zZSBmcm9tIFwiLi90cmFuc3Bvc2VcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0cmFuc3Bvc2UoYXJndW1lbnRzKTtcbn1cbiIsImV4cG9ydCB7ZGVmYXVsdCBhcyBiaXNlY3QsIGJpc2VjdFJpZ2h0LCBiaXNlY3RMZWZ0fSBmcm9tIFwiLi9iaXNlY3RcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBhc2NlbmRpbmd9IGZyb20gXCIuL2FzY2VuZGluZ1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGJpc2VjdG9yfSBmcm9tIFwiLi9iaXNlY3RvclwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGNyb3NzfSBmcm9tIFwiLi9jcm9zc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGRlc2NlbmRpbmd9IGZyb20gXCIuL2Rlc2NlbmRpbmdcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBkZXZpYXRpb259IGZyb20gXCIuL2RldmlhdGlvblwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGV4dGVudH0gZnJvbSBcIi4vZXh0ZW50XCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaGlzdG9ncmFtfSBmcm9tIFwiLi9oaXN0b2dyYW1cIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB0aHJlc2hvbGRGcmVlZG1hbkRpYWNvbmlzfSBmcm9tIFwiLi90aHJlc2hvbGQvZnJlZWRtYW5EaWFjb25pc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHRocmVzaG9sZFNjb3R0fSBmcm9tIFwiLi90aHJlc2hvbGQvc2NvdHRcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB0aHJlc2hvbGRTdHVyZ2VzfSBmcm9tIFwiLi90aHJlc2hvbGQvc3R1cmdlc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIG1heH0gZnJvbSBcIi4vbWF4XCI7XG5leHBvcnQge2RlZmF1bHQgYXMgbWVhbn0gZnJvbSBcIi4vbWVhblwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIG1lZGlhbn0gZnJvbSBcIi4vbWVkaWFuXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgbWVyZ2V9IGZyb20gXCIuL21lcmdlXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgbWlufSBmcm9tIFwiLi9taW5cIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBwYWlyc30gZnJvbSBcIi4vcGFpcnNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBwZXJtdXRlfSBmcm9tIFwiLi9wZXJtdXRlXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgcXVhbnRpbGV9IGZyb20gXCIuL3F1YW50aWxlXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgcmFuZ2V9IGZyb20gXCIuL3JhbmdlXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc2Nhbn0gZnJvbSBcIi4vc2NhblwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHNodWZmbGV9IGZyb20gXCIuL3NodWZmbGVcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzdW19IGZyb20gXCIuL3N1bVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHRpY2tzLCB0aWNrSW5jcmVtZW50LCB0aWNrU3RlcH0gZnJvbSBcIi4vdGlja3NcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB0cmFuc3Bvc2V9IGZyb20gXCIuL3RyYW5zcG9zZVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHZhcmlhbmNlfSBmcm9tIFwiLi92YXJpYW5jZVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHppcH0gZnJvbSBcIi4vemlwXCI7XG4iLCJleHBvcnQgZnVuY3Rpb24gaW5pdFJhbmdlKGRvbWFpbiwgcmFuZ2UpIHtcbiAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiBicmVhaztcbiAgICBjYXNlIDE6IHRoaXMucmFuZ2UoZG9tYWluKTsgYnJlYWs7XG4gICAgZGVmYXVsdDogdGhpcy5yYW5nZShyYW5nZSkuZG9tYWluKGRvbWFpbik7IGJyZWFrO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdEludGVycG9sYXRvcihkb21haW4sIGludGVycG9sYXRvcikge1xuICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IGJyZWFrO1xuICAgIGNhc2UgMTogdGhpcy5pbnRlcnBvbGF0b3IoZG9tYWluKTsgYnJlYWs7XG4gICAgZGVmYXVsdDogdGhpcy5pbnRlcnBvbGF0b3IoaW50ZXJwb2xhdG9yKS5kb21haW4oZG9tYWluKTsgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJ2YXIgYXJyYXkgPSBBcnJheS5wcm90b3R5cGU7XG5cbmV4cG9ydCB2YXIgbWFwID0gYXJyYXkubWFwO1xuZXhwb3J0IHZhciBzbGljZSA9IGFycmF5LnNsaWNlO1xuIiwiaW1wb3J0IHttYXB9IGZyb20gXCJkMy1jb2xsZWN0aW9uXCI7XG5pbXBvcnQge3NsaWNlfSBmcm9tIFwiLi9hcnJheVwiO1xuaW1wb3J0IHtpbml0UmFuZ2V9IGZyb20gXCIuL2luaXRcIjtcblxuZXhwb3J0IHZhciBpbXBsaWNpdCA9IHtuYW1lOiBcImltcGxpY2l0XCJ9O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBvcmRpbmFsKCkge1xuICB2YXIgaW5kZXggPSBtYXAoKSxcbiAgICAgIGRvbWFpbiA9IFtdLFxuICAgICAgcmFuZ2UgPSBbXSxcbiAgICAgIHVua25vd24gPSBpbXBsaWNpdDtcblxuICBmdW5jdGlvbiBzY2FsZShkKSB7XG4gICAgdmFyIGtleSA9IGQgKyBcIlwiLCBpID0gaW5kZXguZ2V0KGtleSk7XG4gICAgaWYgKCFpKSB7XG4gICAgICBpZiAodW5rbm93biAhPT0gaW1wbGljaXQpIHJldHVybiB1bmtub3duO1xuICAgICAgaW5kZXguc2V0KGtleSwgaSA9IGRvbWFpbi5wdXNoKGQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlWyhpIC0gMSkgJSByYW5nZS5sZW5ndGhdO1xuICB9XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbi5zbGljZSgpO1xuICAgIGRvbWFpbiA9IFtdLCBpbmRleCA9IG1hcCgpO1xuICAgIHZhciBpID0gLTEsIG4gPSBfLmxlbmd0aCwgZCwga2V5O1xuICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoIWluZGV4LmhhcyhrZXkgPSAoZCA9IF9baV0pICsgXCJcIikpIGluZGV4LnNldChrZXksIGRvbWFpbi5wdXNoKGQpKTtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFuZ2UgPSBzbGljZS5jYWxsKF8pLCBzY2FsZSkgOiByYW5nZS5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBvcmRpbmFsKGRvbWFpbiwgcmFuZ2UpLnVua25vd24odW5rbm93bik7XG4gIH07XG5cbiAgaW5pdFJhbmdlLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xuXG4gIHJldHVybiBzY2FsZTtcbn1cbiIsImltcG9ydCB7cmFuZ2UgYXMgc2VxdWVuY2V9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHtpbml0UmFuZ2V9IGZyb20gXCIuL2luaXRcIjtcbmltcG9ydCBvcmRpbmFsIGZyb20gXCIuL29yZGluYWxcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYmFuZCgpIHtcbiAgdmFyIHNjYWxlID0gb3JkaW5hbCgpLnVua25vd24odW5kZWZpbmVkKSxcbiAgICAgIGRvbWFpbiA9IHNjYWxlLmRvbWFpbixcbiAgICAgIG9yZGluYWxSYW5nZSA9IHNjYWxlLnJhbmdlLFxuICAgICAgcmFuZ2UgPSBbMCwgMV0sXG4gICAgICBzdGVwLFxuICAgICAgYmFuZHdpZHRoLFxuICAgICAgcm91bmQgPSBmYWxzZSxcbiAgICAgIHBhZGRpbmdJbm5lciA9IDAsXG4gICAgICBwYWRkaW5nT3V0ZXIgPSAwLFxuICAgICAgYWxpZ24gPSAwLjU7XG5cbiAgZGVsZXRlIHNjYWxlLnVua25vd247XG5cbiAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICB2YXIgbiA9IGRvbWFpbigpLmxlbmd0aCxcbiAgICAgICAgcmV2ZXJzZSA9IHJhbmdlWzFdIDwgcmFuZ2VbMF0sXG4gICAgICAgIHN0YXJ0ID0gcmFuZ2VbcmV2ZXJzZSAtIDBdLFxuICAgICAgICBzdG9wID0gcmFuZ2VbMSAtIHJldmVyc2VdO1xuICAgIHN0ZXAgPSAoc3RvcCAtIHN0YXJ0KSAvIE1hdGgubWF4KDEsIG4gLSBwYWRkaW5nSW5uZXIgKyBwYWRkaW5nT3V0ZXIgKiAyKTtcbiAgICBpZiAocm91bmQpIHN0ZXAgPSBNYXRoLmZsb29yKHN0ZXApO1xuICAgIHN0YXJ0ICs9IChzdG9wIC0gc3RhcnQgLSBzdGVwICogKG4gLSBwYWRkaW5nSW5uZXIpKSAqIGFsaWduO1xuICAgIGJhbmR3aWR0aCA9IHN0ZXAgKiAoMSAtIHBhZGRpbmdJbm5lcik7XG4gICAgaWYgKHJvdW5kKSBzdGFydCA9IE1hdGgucm91bmQoc3RhcnQpLCBiYW5kd2lkdGggPSBNYXRoLnJvdW5kKGJhbmR3aWR0aCk7XG4gICAgdmFyIHZhbHVlcyA9IHNlcXVlbmNlKG4pLm1hcChmdW5jdGlvbihpKSB7IHJldHVybiBzdGFydCArIHN0ZXAgKiBpOyB9KTtcbiAgICByZXR1cm4gb3JkaW5hbFJhbmdlKHJldmVyc2UgPyB2YWx1ZXMucmV2ZXJzZSgpIDogdmFsdWVzKTtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4oXyksIHJlc2NhbGUoKSkgOiBkb21haW4oKTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYW5nZSA9IFsrX1swXSwgK19bMV1dLCByZXNjYWxlKCkpIDogcmFuZ2Uuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZVJvdW5kID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiByYW5nZSA9IFsrX1swXSwgK19bMV1dLCByb3VuZCA9IHRydWUsIHJlc2NhbGUoKTtcbiAgfTtcblxuICBzY2FsZS5iYW5kd2lkdGggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYmFuZHdpZHRoO1xuICB9O1xuXG4gIHNjYWxlLnN0ZXAgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc3RlcDtcbiAgfTtcblxuICBzY2FsZS5yb3VuZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyb3VuZCA9ICEhXywgcmVzY2FsZSgpKSA6IHJvdW5kO1xuICB9O1xuXG4gIHNjYWxlLnBhZGRpbmcgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ0lubmVyID0gTWF0aC5taW4oMSwgcGFkZGluZ091dGVyID0gK18pLCByZXNjYWxlKCkpIDogcGFkZGluZ0lubmVyO1xuICB9O1xuXG4gIHNjYWxlLnBhZGRpbmdJbm5lciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nSW5uZXIgPSBNYXRoLm1pbigxLCBfKSwgcmVzY2FsZSgpKSA6IHBhZGRpbmdJbm5lcjtcbiAgfTtcblxuICBzY2FsZS5wYWRkaW5nT3V0ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ091dGVyID0gK18sIHJlc2NhbGUoKSkgOiBwYWRkaW5nT3V0ZXI7XG4gIH07XG5cbiAgc2NhbGUuYWxpZ24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYWxpZ24gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBfKSksIHJlc2NhbGUoKSkgOiBhbGlnbjtcbiAgfTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGJhbmQoZG9tYWluKCksIHJhbmdlKVxuICAgICAgICAucm91bmQocm91bmQpXG4gICAgICAgIC5wYWRkaW5nSW5uZXIocGFkZGluZ0lubmVyKVxuICAgICAgICAucGFkZGluZ091dGVyKHBhZGRpbmdPdXRlcilcbiAgICAgICAgLmFsaWduKGFsaWduKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdFJhbmdlLmFwcGx5KHJlc2NhbGUoKSwgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gcG9pbnRpc2goc2NhbGUpIHtcbiAgdmFyIGNvcHkgPSBzY2FsZS5jb3B5O1xuXG4gIHNjYWxlLnBhZGRpbmcgPSBzY2FsZS5wYWRkaW5nT3V0ZXI7XG4gIGRlbGV0ZSBzY2FsZS5wYWRkaW5nSW5uZXI7XG4gIGRlbGV0ZSBzY2FsZS5wYWRkaW5nT3V0ZXI7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBwb2ludGlzaChjb3B5KCkpO1xuICB9O1xuXG4gIHJldHVybiBzY2FsZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvaW50KCkge1xuICByZXR1cm4gcG9pbnRpc2goYmFuZC5hcHBseShudWxsLCBhcmd1bWVudHMpLnBhZGRpbmdJbm5lcigxKSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuICt4O1xufVxuIiwiaW1wb3J0IHtiaXNlY3R9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHtpbnRlcnBvbGF0ZSBhcyBpbnRlcnBvbGF0ZVZhbHVlLCBpbnRlcnBvbGF0ZU51bWJlciwgaW50ZXJwb2xhdGVSb3VuZH0gZnJvbSBcImQzLWludGVycG9sYXRlXCI7XG5pbXBvcnQge21hcCwgc2xpY2V9IGZyb20gXCIuL2FycmF5XCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnRcIjtcbmltcG9ydCBudW1iZXIgZnJvbSBcIi4vbnVtYmVyXCI7XG5cbnZhciB1bml0ID0gWzAsIDFdO1xuXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpdHkoeCkge1xuICByZXR1cm4geDtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplKGEsIGIpIHtcbiAgcmV0dXJuIChiIC09IChhID0gK2EpKVxuICAgICAgPyBmdW5jdGlvbih4KSB7IHJldHVybiAoeCAtIGEpIC8gYjsgfVxuICAgICAgOiBjb25zdGFudChpc05hTihiKSA/IE5hTiA6IDAuNSk7XG59XG5cbmZ1bmN0aW9uIGNsYW1wZXIoZG9tYWluKSB7XG4gIHZhciBhID0gZG9tYWluWzBdLCBiID0gZG9tYWluW2RvbWFpbi5sZW5ndGggLSAxXSwgdDtcbiAgaWYgKGEgPiBiKSB0ID0gYSwgYSA9IGIsIGIgPSB0O1xuICByZXR1cm4gZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5tYXgoYSwgTWF0aC5taW4oYiwgeCkpOyB9O1xufVxuXG4vLyBub3JtYWxpemUoYSwgYikoeCkgdGFrZXMgYSBkb21haW4gdmFsdWUgeCBpbiBbYSxiXSBhbmQgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwYXJhbWV0ZXIgdCBpbiBbMCwxXS5cbi8vIGludGVycG9sYXRlKGEsIGIpKHQpIHRha2VzIGEgcGFyYW1ldGVyIHQgaW4gWzAsMV0gYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcmFuZ2UgdmFsdWUgeCBpbiBbYSxiXS5cbmZ1bmN0aW9uIGJpbWFwKGRvbWFpbiwgcmFuZ2UsIGludGVycG9sYXRlKSB7XG4gIHZhciBkMCA9IGRvbWFpblswXSwgZDEgPSBkb21haW5bMV0sIHIwID0gcmFuZ2VbMF0sIHIxID0gcmFuZ2VbMV07XG4gIGlmIChkMSA8IGQwKSBkMCA9IG5vcm1hbGl6ZShkMSwgZDApLCByMCA9IGludGVycG9sYXRlKHIxLCByMCk7XG4gIGVsc2UgZDAgPSBub3JtYWxpemUoZDAsIGQxKSwgcjAgPSBpbnRlcnBvbGF0ZShyMCwgcjEpO1xuICByZXR1cm4gZnVuY3Rpb24oeCkgeyByZXR1cm4gcjAoZDAoeCkpOyB9O1xufVxuXG5mdW5jdGlvbiBwb2x5bWFwKGRvbWFpbiwgcmFuZ2UsIGludGVycG9sYXRlKSB7XG4gIHZhciBqID0gTWF0aC5taW4oZG9tYWluLmxlbmd0aCwgcmFuZ2UubGVuZ3RoKSAtIDEsXG4gICAgICBkID0gbmV3IEFycmF5KGopLFxuICAgICAgciA9IG5ldyBBcnJheShqKSxcbiAgICAgIGkgPSAtMTtcblxuICAvLyBSZXZlcnNlIGRlc2NlbmRpbmcgZG9tYWlucy5cbiAgaWYgKGRvbWFpbltqXSA8IGRvbWFpblswXSkge1xuICAgIGRvbWFpbiA9IGRvbWFpbi5zbGljZSgpLnJldmVyc2UoKTtcbiAgICByYW5nZSA9IHJhbmdlLnNsaWNlKCkucmV2ZXJzZSgpO1xuICB9XG5cbiAgd2hpbGUgKCsraSA8IGopIHtcbiAgICBkW2ldID0gbm9ybWFsaXplKGRvbWFpbltpXSwgZG9tYWluW2kgKyAxXSk7XG4gICAgcltpXSA9IGludGVycG9sYXRlKHJhbmdlW2ldLCByYW5nZVtpICsgMV0pO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgaSA9IGJpc2VjdChkb21haW4sIHgsIDEsIGopIC0gMTtcbiAgICByZXR1cm4gcltpXShkW2ldKHgpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkoc291cmNlLCB0YXJnZXQpIHtcbiAgcmV0dXJuIHRhcmdldFxuICAgICAgLmRvbWFpbihzb3VyY2UuZG9tYWluKCkpXG4gICAgICAucmFuZ2Uoc291cmNlLnJhbmdlKCkpXG4gICAgICAuaW50ZXJwb2xhdGUoc291cmNlLmludGVycG9sYXRlKCkpXG4gICAgICAuY2xhbXAoc291cmNlLmNsYW1wKCkpXG4gICAgICAudW5rbm93bihzb3VyY2UudW5rbm93bigpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybWVyKCkge1xuICB2YXIgZG9tYWluID0gdW5pdCxcbiAgICAgIHJhbmdlID0gdW5pdCxcbiAgICAgIGludGVycG9sYXRlID0gaW50ZXJwb2xhdGVWYWx1ZSxcbiAgICAgIHRyYW5zZm9ybSxcbiAgICAgIHVudHJhbnNmb3JtLFxuICAgICAgdW5rbm93bixcbiAgICAgIGNsYW1wID0gaWRlbnRpdHksXG4gICAgICBwaWVjZXdpc2UsXG4gICAgICBvdXRwdXQsXG4gICAgICBpbnB1dDtcblxuICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgIHBpZWNld2lzZSA9IE1hdGgubWluKGRvbWFpbi5sZW5ndGgsIHJhbmdlLmxlbmd0aCkgPiAyID8gcG9seW1hcCA6IGJpbWFwO1xuICAgIG91dHB1dCA9IGlucHV0ID0gbnVsbDtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH1cblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgcmV0dXJuIGlzTmFOKHggPSAreCkgPyB1bmtub3duIDogKG91dHB1dCB8fCAob3V0cHV0ID0gcGllY2V3aXNlKGRvbWFpbi5tYXAodHJhbnNmb3JtKSwgcmFuZ2UsIGludGVycG9sYXRlKSkpKHRyYW5zZm9ybShjbGFtcCh4KSkpO1xuICB9XG5cbiAgc2NhbGUuaW52ZXJ0ID0gZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiBjbGFtcCh1bnRyYW5zZm9ybSgoaW5wdXQgfHwgKGlucHV0ID0gcGllY2V3aXNlKHJhbmdlLCBkb21haW4ubWFwKHRyYW5zZm9ybSksIGludGVycG9sYXRlTnVtYmVyKSkpKHkpKSk7XG4gIH07XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRvbWFpbiA9IG1hcC5jYWxsKF8sIG51bWJlciksIGNsYW1wID09PSBpZGVudGl0eSB8fCAoY2xhbXAgPSBjbGFtcGVyKGRvbWFpbikpLCByZXNjYWxlKCkpIDogZG9tYWluLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFuZ2UgPSBzbGljZS5jYWxsKF8pLCByZXNjYWxlKCkpIDogcmFuZ2Uuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZVJvdW5kID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiByYW5nZSA9IHNsaWNlLmNhbGwoXyksIGludGVycG9sYXRlID0gaW50ZXJwb2xhdGVSb3VuZCwgcmVzY2FsZSgpO1xuICB9O1xuXG4gIHNjYWxlLmNsYW1wID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNsYW1wID0gXyA/IGNsYW1wZXIoZG9tYWluKSA6IGlkZW50aXR5LCBzY2FsZSkgOiBjbGFtcCAhPT0gaWRlbnRpdHk7XG4gIH07XG5cbiAgc2NhbGUuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaW50ZXJwb2xhdGUgPSBfLCByZXNjYWxlKCkpIDogaW50ZXJwb2xhdGU7XG4gIH07XG5cbiAgc2NhbGUudW5rbm93biA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh1bmtub3duID0gXywgc2NhbGUpIDogdW5rbm93bjtcbiAgfTtcblxuICByZXR1cm4gZnVuY3Rpb24odCwgdSkge1xuICAgIHRyYW5zZm9ybSA9IHQsIHVudHJhbnNmb3JtID0gdTtcbiAgICByZXR1cm4gcmVzY2FsZSgpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb250aW51b3VzKHRyYW5zZm9ybSwgdW50cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIHRyYW5zZm9ybWVyKCkodHJhbnNmb3JtLCB1bnRyYW5zZm9ybSk7XG59XG4iLCJpbXBvcnQge3RpY2tTdGVwfSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7Zm9ybWF0LCBmb3JtYXRQcmVmaXgsIGZvcm1hdFNwZWNpZmllciwgcHJlY2lzaW9uRml4ZWQsIHByZWNpc2lvblByZWZpeCwgcHJlY2lzaW9uUm91bmR9IGZyb20gXCJkMy1mb3JtYXRcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc3RhcnQsIHN0b3AsIGNvdW50LCBzcGVjaWZpZXIpIHtcbiAgdmFyIHN0ZXAgPSB0aWNrU3RlcChzdGFydCwgc3RvcCwgY291bnQpLFxuICAgICAgcHJlY2lzaW9uO1xuICBzcGVjaWZpZXIgPSBmb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyID09IG51bGwgPyBcIixmXCIgOiBzcGVjaWZpZXIpO1xuICBzd2l0Y2ggKHNwZWNpZmllci50eXBlKSB7XG4gICAgY2FzZSBcInNcIjoge1xuICAgICAgdmFyIHZhbHVlID0gTWF0aC5tYXgoTWF0aC5hYnMoc3RhcnQpLCBNYXRoLmFicyhzdG9wKSk7XG4gICAgICBpZiAoc3BlY2lmaWVyLnByZWNpc2lvbiA9PSBudWxsICYmICFpc05hTihwcmVjaXNpb24gPSBwcmVjaXNpb25QcmVmaXgoc3RlcCwgdmFsdWUpKSkgc3BlY2lmaWVyLnByZWNpc2lvbiA9IHByZWNpc2lvbjtcbiAgICAgIHJldHVybiBmb3JtYXRQcmVmaXgoc3BlY2lmaWVyLCB2YWx1ZSk7XG4gICAgfVxuICAgIGNhc2UgXCJcIjpcbiAgICBjYXNlIFwiZVwiOlxuICAgIGNhc2UgXCJnXCI6XG4gICAgY2FzZSBcInBcIjpcbiAgICBjYXNlIFwiclwiOiB7XG4gICAgICBpZiAoc3BlY2lmaWVyLnByZWNpc2lvbiA9PSBudWxsICYmICFpc05hTihwcmVjaXNpb24gPSBwcmVjaXNpb25Sb3VuZChzdGVwLCBNYXRoLm1heChNYXRoLmFicyhzdGFydCksIE1hdGguYWJzKHN0b3ApKSkpKSBzcGVjaWZpZXIucHJlY2lzaW9uID0gcHJlY2lzaW9uIC0gKHNwZWNpZmllci50eXBlID09PSBcImVcIik7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImZcIjpcbiAgICBjYXNlIFwiJVwiOiB7XG4gICAgICBpZiAoc3BlY2lmaWVyLnByZWNpc2lvbiA9PSBudWxsICYmICFpc05hTihwcmVjaXNpb24gPSBwcmVjaXNpb25GaXhlZChzdGVwKSkpIHNwZWNpZmllci5wcmVjaXNpb24gPSBwcmVjaXNpb24gLSAoc3BlY2lmaWVyLnR5cGUgPT09IFwiJVwiKSAqIDI7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZvcm1hdChzcGVjaWZpZXIpO1xufVxuIiwiaW1wb3J0IHt0aWNrcywgdGlja0luY3JlbWVudH0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQgY29udGludW91cywge2NvcHksIGlkZW50aXR5fSBmcm9tIFwiLi9jb250aW51b3VzXCI7XG5pbXBvcnQge2luaXRSYW5nZX0gZnJvbSBcIi4vaW5pdFwiO1xuaW1wb3J0IHRpY2tGb3JtYXQgZnJvbSBcIi4vdGlja0Zvcm1hdFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gbGluZWFyaXNoKHNjYWxlKSB7XG4gIHZhciBkb21haW4gPSBzY2FsZS5kb21haW47XG5cbiAgc2NhbGUudGlja3MgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIHZhciBkID0gZG9tYWluKCk7XG4gICAgcmV0dXJuIHRpY2tzKGRbMF0sIGRbZC5sZW5ndGggLSAxXSwgY291bnQgPT0gbnVsbCA/IDEwIDogY291bnQpO1xuICB9O1xuXG4gIHNjYWxlLnRpY2tGb3JtYXQgPSBmdW5jdGlvbihjb3VudCwgc3BlY2lmaWVyKSB7XG4gICAgdmFyIGQgPSBkb21haW4oKTtcbiAgICByZXR1cm4gdGlja0Zvcm1hdChkWzBdLCBkW2QubGVuZ3RoIC0gMV0sIGNvdW50ID09IG51bGwgPyAxMCA6IGNvdW50LCBzcGVjaWZpZXIpO1xuICB9O1xuXG4gIHNjYWxlLm5pY2UgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIGlmIChjb3VudCA9PSBudWxsKSBjb3VudCA9IDEwO1xuXG4gICAgdmFyIGQgPSBkb21haW4oKSxcbiAgICAgICAgaTAgPSAwLFxuICAgICAgICBpMSA9IGQubGVuZ3RoIC0gMSxcbiAgICAgICAgc3RhcnQgPSBkW2kwXSxcbiAgICAgICAgc3RvcCA9IGRbaTFdLFxuICAgICAgICBzdGVwO1xuXG4gICAgaWYgKHN0b3AgPCBzdGFydCkge1xuICAgICAgc3RlcCA9IHN0YXJ0LCBzdGFydCA9IHN0b3AsIHN0b3AgPSBzdGVwO1xuICAgICAgc3RlcCA9IGkwLCBpMCA9IGkxLCBpMSA9IHN0ZXA7XG4gICAgfVxuXG4gICAgc3RlcCA9IHRpY2tJbmNyZW1lbnQoc3RhcnQsIHN0b3AsIGNvdW50KTtcblxuICAgIGlmIChzdGVwID4gMCkge1xuICAgICAgc3RhcnQgPSBNYXRoLmZsb29yKHN0YXJ0IC8gc3RlcCkgKiBzdGVwO1xuICAgICAgc3RvcCA9IE1hdGguY2VpbChzdG9wIC8gc3RlcCkgKiBzdGVwO1xuICAgICAgc3RlcCA9IHRpY2tJbmNyZW1lbnQoc3RhcnQsIHN0b3AsIGNvdW50KTtcbiAgICB9IGVsc2UgaWYgKHN0ZXAgPCAwKSB7XG4gICAgICBzdGFydCA9IE1hdGguY2VpbChzdGFydCAqIHN0ZXApIC8gc3RlcDtcbiAgICAgIHN0b3AgPSBNYXRoLmZsb29yKHN0b3AgKiBzdGVwKSAvIHN0ZXA7XG4gICAgICBzdGVwID0gdGlja0luY3JlbWVudChzdGFydCwgc3RvcCwgY291bnQpO1xuICAgIH1cblxuICAgIGlmIChzdGVwID4gMCkge1xuICAgICAgZFtpMF0gPSBNYXRoLmZsb29yKHN0YXJ0IC8gc3RlcCkgKiBzdGVwO1xuICAgICAgZFtpMV0gPSBNYXRoLmNlaWwoc3RvcCAvIHN0ZXApICogc3RlcDtcbiAgICAgIGRvbWFpbihkKTtcbiAgICB9IGVsc2UgaWYgKHN0ZXAgPCAwKSB7XG4gICAgICBkW2kwXSA9IE1hdGguY2VpbChzdGFydCAqIHN0ZXApIC8gc3RlcDtcbiAgICAgIGRbaTFdID0gTWF0aC5mbG9vcihzdG9wICogc3RlcCkgLyBzdGVwO1xuICAgICAgZG9tYWluKGQpO1xuICAgIH1cblxuICAgIHJldHVybiBzY2FsZTtcbiAgfTtcblxuICByZXR1cm4gc2NhbGU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxpbmVhcigpIHtcbiAgdmFyIHNjYWxlID0gY29udGludW91cyhpZGVudGl0eSwgaWRlbnRpdHkpO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgbGluZWFyKCkpO1xuICB9O1xuXG4gIGluaXRSYW5nZS5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcblxuICByZXR1cm4gbGluZWFyaXNoKHNjYWxlKTtcbn1cbiIsImltcG9ydCB7bWFwfSBmcm9tIFwiLi9hcnJheVwiO1xuaW1wb3J0IHtsaW5lYXJpc2h9IGZyb20gXCIuL2xpbmVhclwiO1xuaW1wb3J0IG51bWJlciBmcm9tIFwiLi9udW1iZXJcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaWRlbnRpdHkoZG9tYWluKSB7XG4gIHZhciB1bmtub3duO1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICByZXR1cm4gaXNOYU4oeCA9ICt4KSA/IHVua25vd24gOiB4O1xuICB9XG5cbiAgc2NhbGUuaW52ZXJ0ID0gc2NhbGU7XG5cbiAgc2NhbGUuZG9tYWluID0gc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZG9tYWluID0gbWFwLmNhbGwoXywgbnVtYmVyKSwgc2NhbGUpIDogZG9tYWluLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUudW5rbm93biA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh1bmtub3duID0gXywgc2NhbGUpIDogdW5rbm93bjtcbiAgfTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGlkZW50aXR5KGRvbWFpbikudW5rbm93bih1bmtub3duKTtcbiAgfTtcblxuICBkb21haW4gPSBhcmd1bWVudHMubGVuZ3RoID8gbWFwLmNhbGwoZG9tYWluLCBudW1iZXIpIDogWzAsIDFdO1xuXG4gIHJldHVybiBsaW5lYXJpc2goc2NhbGUpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZG9tYWluLCBpbnRlcnZhbCkge1xuICBkb21haW4gPSBkb21haW4uc2xpY2UoKTtcblxuICB2YXIgaTAgPSAwLFxuICAgICAgaTEgPSBkb21haW4ubGVuZ3RoIC0gMSxcbiAgICAgIHgwID0gZG9tYWluW2kwXSxcbiAgICAgIHgxID0gZG9tYWluW2kxXSxcbiAgICAgIHQ7XG5cbiAgaWYgKHgxIDwgeDApIHtcbiAgICB0ID0gaTAsIGkwID0gaTEsIGkxID0gdDtcbiAgICB0ID0geDAsIHgwID0geDEsIHgxID0gdDtcbiAgfVxuXG4gIGRvbWFpbltpMF0gPSBpbnRlcnZhbC5mbG9vcih4MCk7XG4gIGRvbWFpbltpMV0gPSBpbnRlcnZhbC5jZWlsKHgxKTtcbiAgcmV0dXJuIGRvbWFpbjtcbn1cbiIsImltcG9ydCB7dGlja3N9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHtmb3JtYXR9IGZyb20gXCJkMy1mb3JtYXRcIjtcbmltcG9ydCBuaWNlIGZyb20gXCIuL25pY2VcIjtcbmltcG9ydCB7Y29weSwgdHJhbnNmb3JtZXJ9IGZyb20gXCIuL2NvbnRpbnVvdXNcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0XCI7XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybUxvZyh4KSB7XG4gIHJldHVybiBNYXRoLmxvZyh4KTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtRXhwKHgpIHtcbiAgcmV0dXJuIE1hdGguZXhwKHgpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Mb2duKHgpIHtcbiAgcmV0dXJuIC1NYXRoLmxvZygteCk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybUV4cG4oeCkge1xuICByZXR1cm4gLU1hdGguZXhwKC14KTtcbn1cblxuZnVuY3Rpb24gcG93MTAoeCkge1xuICByZXR1cm4gaXNGaW5pdGUoeCkgPyArKFwiMWVcIiArIHgpIDogeCA8IDAgPyAwIDogeDtcbn1cblxuZnVuY3Rpb24gcG93cChiYXNlKSB7XG4gIHJldHVybiBiYXNlID09PSAxMCA/IHBvdzEwXG4gICAgICA6IGJhc2UgPT09IE1hdGguRSA/IE1hdGguZXhwXG4gICAgICA6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgucG93KGJhc2UsIHgpOyB9O1xufVxuXG5mdW5jdGlvbiBsb2dwKGJhc2UpIHtcbiAgcmV0dXJuIGJhc2UgPT09IE1hdGguRSA/IE1hdGgubG9nXG4gICAgICA6IGJhc2UgPT09IDEwICYmIE1hdGgubG9nMTBcbiAgICAgIHx8IGJhc2UgPT09IDIgJiYgTWF0aC5sb2cyXG4gICAgICB8fCAoYmFzZSA9IE1hdGgubG9nKGJhc2UpLCBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLmxvZyh4KSAvIGJhc2U7IH0pO1xufVxuXG5mdW5jdGlvbiByZWZsZWN0KGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gLWYoLXgpO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9nZ2lzaCh0cmFuc2Zvcm0pIHtcbiAgdmFyIHNjYWxlID0gdHJhbnNmb3JtKHRyYW5zZm9ybUxvZywgdHJhbnNmb3JtRXhwKSxcbiAgICAgIGRvbWFpbiA9IHNjYWxlLmRvbWFpbixcbiAgICAgIGJhc2UgPSAxMCxcbiAgICAgIGxvZ3MsXG4gICAgICBwb3dzO1xuXG4gIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgbG9ncyA9IGxvZ3AoYmFzZSksIHBvd3MgPSBwb3dwKGJhc2UpO1xuICAgIGlmIChkb21haW4oKVswXSA8IDApIHtcbiAgICAgIGxvZ3MgPSByZWZsZWN0KGxvZ3MpLCBwb3dzID0gcmVmbGVjdChwb3dzKTtcbiAgICAgIHRyYW5zZm9ybSh0cmFuc2Zvcm1Mb2duLCB0cmFuc2Zvcm1FeHBuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNmb3JtKHRyYW5zZm9ybUxvZywgdHJhbnNmb3JtRXhwKTtcbiAgICB9XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9XG5cbiAgc2NhbGUuYmFzZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChiYXNlID0gK18sIHJlc2NhbGUoKSkgOiBiYXNlO1xuICB9O1xuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4oXyksIHJlc2NhbGUoKSkgOiBkb21haW4oKTtcbiAgfTtcblxuICBzY2FsZS50aWNrcyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgdmFyIGQgPSBkb21haW4oKSxcbiAgICAgICAgdSA9IGRbMF0sXG4gICAgICAgIHYgPSBkW2QubGVuZ3RoIC0gMV0sXG4gICAgICAgIHI7XG5cbiAgICBpZiAociA9IHYgPCB1KSBpID0gdSwgdSA9IHYsIHYgPSBpO1xuXG4gICAgdmFyIGkgPSBsb2dzKHUpLFxuICAgICAgICBqID0gbG9ncyh2KSxcbiAgICAgICAgcCxcbiAgICAgICAgayxcbiAgICAgICAgdCxcbiAgICAgICAgbiA9IGNvdW50ID09IG51bGwgPyAxMCA6ICtjb3VudCxcbiAgICAgICAgeiA9IFtdO1xuXG4gICAgaWYgKCEoYmFzZSAlIDEpICYmIGogLSBpIDwgbikge1xuICAgICAgaSA9IE1hdGgucm91bmQoaSkgLSAxLCBqID0gTWF0aC5yb3VuZChqKSArIDE7XG4gICAgICBpZiAodSA+IDApIGZvciAoOyBpIDwgajsgKytpKSB7XG4gICAgICAgIGZvciAoayA9IDEsIHAgPSBwb3dzKGkpOyBrIDwgYmFzZTsgKytrKSB7XG4gICAgICAgICAgdCA9IHAgKiBrO1xuICAgICAgICAgIGlmICh0IDwgdSkgY29udGludWU7XG4gICAgICAgICAgaWYgKHQgPiB2KSBicmVhaztcbiAgICAgICAgICB6LnB1c2godCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBmb3IgKDsgaSA8IGo7ICsraSkge1xuICAgICAgICBmb3IgKGsgPSBiYXNlIC0gMSwgcCA9IHBvd3MoaSk7IGsgPj0gMTsgLS1rKSB7XG4gICAgICAgICAgdCA9IHAgKiBrO1xuICAgICAgICAgIGlmICh0IDwgdSkgY29udGludWU7XG4gICAgICAgICAgaWYgKHQgPiB2KSBicmVhaztcbiAgICAgICAgICB6LnB1c2godCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgeiA9IHRpY2tzKGksIGosIE1hdGgubWluKGogLSBpLCBuKSkubWFwKHBvd3MpO1xuICAgIH1cblxuICAgIHJldHVybiByID8gei5yZXZlcnNlKCkgOiB6O1xuICB9O1xuXG4gIHNjYWxlLnRpY2tGb3JtYXQgPSBmdW5jdGlvbihjb3VudCwgc3BlY2lmaWVyKSB7XG4gICAgaWYgKHNwZWNpZmllciA9PSBudWxsKSBzcGVjaWZpZXIgPSBiYXNlID09PSAxMCA/IFwiLjBlXCIgOiBcIixcIjtcbiAgICBpZiAodHlwZW9mIHNwZWNpZmllciAhPT0gXCJmdW5jdGlvblwiKSBzcGVjaWZpZXIgPSBmb3JtYXQoc3BlY2lmaWVyKTtcbiAgICBpZiAoY291bnQgPT09IEluZmluaXR5KSByZXR1cm4gc3BlY2lmaWVyO1xuICAgIGlmIChjb3VudCA9PSBudWxsKSBjb3VudCA9IDEwO1xuICAgIHZhciBrID0gTWF0aC5tYXgoMSwgYmFzZSAqIGNvdW50IC8gc2NhbGUudGlja3MoKS5sZW5ndGgpOyAvLyBUT0RPIGZhc3QgZXN0aW1hdGU/XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGQpIHtcbiAgICAgIHZhciBpID0gZCAvIHBvd3MoTWF0aC5yb3VuZChsb2dzKGQpKSk7XG4gICAgICBpZiAoaSAqIGJhc2UgPCBiYXNlIC0gMC41KSBpICo9IGJhc2U7XG4gICAgICByZXR1cm4gaSA8PSBrID8gc3BlY2lmaWVyKGQpIDogXCJcIjtcbiAgICB9O1xuICB9O1xuXG4gIHNjYWxlLm5pY2UgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZG9tYWluKG5pY2UoZG9tYWluKCksIHtcbiAgICAgIGZsb29yOiBmdW5jdGlvbih4KSB7IHJldHVybiBwb3dzKE1hdGguZmxvb3IobG9ncyh4KSkpOyB9LFxuICAgICAgY2VpbDogZnVuY3Rpb24oeCkgeyByZXR1cm4gcG93cyhNYXRoLmNlaWwobG9ncyh4KSkpOyB9XG4gICAgfSkpO1xuICB9O1xuXG4gIHJldHVybiBzY2FsZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbG9nKCkge1xuICB2YXIgc2NhbGUgPSBsb2dnaXNoKHRyYW5zZm9ybWVyKCkpLmRvbWFpbihbMSwgMTBdKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIGxvZygpKS5iYXNlKHNjYWxlLmJhc2UoKSk7XG4gIH07XG5cbiAgaW5pdFJhbmdlLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xuXG4gIHJldHVybiBzY2FsZTtcbn1cbiIsImltcG9ydCB7bGluZWFyaXNofSBmcm9tIFwiLi9saW5lYXJcIjtcbmltcG9ydCB7Y29weSwgdHJhbnNmb3JtZXJ9IGZyb20gXCIuL2NvbnRpbnVvdXNcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0XCI7XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN5bWxvZyhjKSB7XG4gIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIE1hdGguc2lnbih4KSAqIE1hdGgubG9nMXAoTWF0aC5hYnMoeCAvIGMpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtU3ltZXhwKGMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gTWF0aC5zaWduKHgpICogTWF0aC5leHBtMShNYXRoLmFicyh4KSkgKiBjO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3ltbG9naXNoKHRyYW5zZm9ybSkge1xuICB2YXIgYyA9IDEsIHNjYWxlID0gdHJhbnNmb3JtKHRyYW5zZm9ybVN5bWxvZyhjKSwgdHJhbnNmb3JtU3ltZXhwKGMpKTtcblxuICBzY2FsZS5jb25zdGFudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRyYW5zZm9ybSh0cmFuc2Zvcm1TeW1sb2coYyA9ICtfKSwgdHJhbnNmb3JtU3ltZXhwKGMpKSA6IGM7XG4gIH07XG5cbiAgcmV0dXJuIGxpbmVhcmlzaChzY2FsZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHN5bWxvZygpIHtcbiAgdmFyIHNjYWxlID0gc3ltbG9naXNoKHRyYW5zZm9ybWVyKCkpO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgc3ltbG9nKCkpLmNvbnN0YW50KHNjYWxlLmNvbnN0YW50KCkpO1xuICB9O1xuXG4gIHJldHVybiBpbml0UmFuZ2UuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG4iLCJpbXBvcnQge2xpbmVhcmlzaH0gZnJvbSBcIi4vbGluZWFyXCI7XG5pbXBvcnQge2NvcHksIGlkZW50aXR5LCB0cmFuc2Zvcm1lcn0gZnJvbSBcIi4vY29udGludW91c1wiO1xuaW1wb3J0IHtpbml0UmFuZ2V9IGZyb20gXCIuL2luaXRcIjtcblxuZnVuY3Rpb24gdHJhbnNmb3JtUG93KGV4cG9uZW50KSB7XG4gIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHggPCAwID8gLU1hdGgucG93KC14LCBleHBvbmVudCkgOiBNYXRoLnBvdyh4LCBleHBvbmVudCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVNxcnQoeCkge1xuICByZXR1cm4geCA8IDAgPyAtTWF0aC5zcXJ0KC14KSA6IE1hdGguc3FydCh4KTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtU3F1YXJlKHgpIHtcbiAgcmV0dXJuIHggPCAwID8gLXggKiB4IDogeCAqIHg7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb3dpc2godHJhbnNmb3JtKSB7XG4gIHZhciBzY2FsZSA9IHRyYW5zZm9ybShpZGVudGl0eSwgaWRlbnRpdHkpLFxuICAgICAgZXhwb25lbnQgPSAxO1xuXG4gIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgcmV0dXJuIGV4cG9uZW50ID09PSAxID8gdHJhbnNmb3JtKGlkZW50aXR5LCBpZGVudGl0eSlcbiAgICAgICAgOiBleHBvbmVudCA9PT0gMC41ID8gdHJhbnNmb3JtKHRyYW5zZm9ybVNxcnQsIHRyYW5zZm9ybVNxdWFyZSlcbiAgICAgICAgOiB0cmFuc2Zvcm0odHJhbnNmb3JtUG93KGV4cG9uZW50KSwgdHJhbnNmb3JtUG93KDEgLyBleHBvbmVudCkpO1xuICB9XG5cbiAgc2NhbGUuZXhwb25lbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZXhwb25lbnQgPSArXywgcmVzY2FsZSgpKSA6IGV4cG9uZW50O1xuICB9O1xuXG4gIHJldHVybiBsaW5lYXJpc2goc2NhbGUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwb3coKSB7XG4gIHZhciBzY2FsZSA9IHBvd2lzaCh0cmFuc2Zvcm1lcigpKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIHBvdygpKS5leHBvbmVudChzY2FsZS5leHBvbmVudCgpKTtcbiAgfTtcblxuICBpbml0UmFuZ2UuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG5cbiAgcmV0dXJuIHNjYWxlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3FydCgpIHtcbiAgcmV0dXJuIHBvdy5hcHBseShudWxsLCBhcmd1bWVudHMpLmV4cG9uZW50KDAuNSk7XG59XG4iLCJpbXBvcnQge2FzY2VuZGluZywgYmlzZWN0LCBxdWFudGlsZSBhcyB0aHJlc2hvbGR9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHtzbGljZX0gZnJvbSBcIi4vYXJyYXlcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHF1YW50aWxlKCkge1xuICB2YXIgZG9tYWluID0gW10sXG4gICAgICByYW5nZSA9IFtdLFxuICAgICAgdGhyZXNob2xkcyA9IFtdLFxuICAgICAgdW5rbm93bjtcblxuICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgIHZhciBpID0gMCwgbiA9IE1hdGgubWF4KDEsIHJhbmdlLmxlbmd0aCk7XG4gICAgdGhyZXNob2xkcyA9IG5ldyBBcnJheShuIC0gMSk7XG4gICAgd2hpbGUgKCsraSA8IG4pIHRocmVzaG9sZHNbaSAtIDFdID0gdGhyZXNob2xkKGRvbWFpbiwgaSAvIG4pO1xuICAgIHJldHVybiBzY2FsZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICByZXR1cm4gaXNOYU4oeCA9ICt4KSA/IHVua25vd24gOiByYW5nZVtiaXNlY3QodGhyZXNob2xkcywgeCldO1xuICB9XG5cbiAgc2NhbGUuaW52ZXJ0RXh0ZW50ID0gZnVuY3Rpb24oeSkge1xuICAgIHZhciBpID0gcmFuZ2UuaW5kZXhPZih5KTtcbiAgICByZXR1cm4gaSA8IDAgPyBbTmFOLCBOYU5dIDogW1xuICAgICAgaSA+IDAgPyB0aHJlc2hvbGRzW2kgLSAxXSA6IGRvbWFpblswXSxcbiAgICAgIGkgPCB0aHJlc2hvbGRzLmxlbmd0aCA/IHRocmVzaG9sZHNbaV0gOiBkb21haW5bZG9tYWluLmxlbmd0aCAtIDFdXG4gICAgXTtcbiAgfTtcblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZG9tYWluLnNsaWNlKCk7XG4gICAgZG9tYWluID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBfLmxlbmd0aCwgZDsgaSA8IG47ICsraSkgaWYgKGQgPSBfW2ldLCBkICE9IG51bGwgJiYgIWlzTmFOKGQgPSArZCkpIGRvbWFpbi5wdXNoKGQpO1xuICAgIGRvbWFpbi5zb3J0KGFzY2VuZGluZyk7XG4gICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYW5nZSA9IHNsaWNlLmNhbGwoXyksIHJlc2NhbGUoKSkgOiByYW5nZS5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XG4gIH07XG5cbiAgc2NhbGUucXVhbnRpbGVzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRocmVzaG9sZHMuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHF1YW50aWxlKClcbiAgICAgICAgLmRvbWFpbihkb21haW4pXG4gICAgICAgIC5yYW5nZShyYW5nZSlcbiAgICAgICAgLnVua25vd24odW5rbm93bik7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRSYW5nZS5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cbiIsImltcG9ydCB7YmlzZWN0fSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7c2xpY2V9IGZyb20gXCIuL2FycmF5XCI7XG5pbXBvcnQge2xpbmVhcmlzaH0gZnJvbSBcIi4vbGluZWFyXCI7XG5pbXBvcnQge2luaXRSYW5nZX0gZnJvbSBcIi4vaW5pdFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBxdWFudGl6ZSgpIHtcbiAgdmFyIHgwID0gMCxcbiAgICAgIHgxID0gMSxcbiAgICAgIG4gPSAxLFxuICAgICAgZG9tYWluID0gWzAuNV0sXG4gICAgICByYW5nZSA9IFswLCAxXSxcbiAgICAgIHVua25vd247XG5cbiAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgIHJldHVybiB4IDw9IHggPyByYW5nZVtiaXNlY3QoZG9tYWluLCB4LCAwLCBuKV0gOiB1bmtub3duO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICB2YXIgaSA9IC0xO1xuICAgIGRvbWFpbiA9IG5ldyBBcnJheShuKTtcbiAgICB3aGlsZSAoKytpIDwgbikgZG9tYWluW2ldID0gKChpICsgMSkgKiB4MSAtIChpIC0gbikgKiB4MCkgLyAobiArIDEpO1xuICAgIHJldHVybiBzY2FsZTtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4MCA9ICtfWzBdLCB4MSA9ICtfWzFdLCByZXNjYWxlKCkpIDogW3gwLCB4MV07XG4gIH07XG5cbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobiA9IChyYW5nZSA9IHNsaWNlLmNhbGwoXykpLmxlbmd0aCAtIDEsIHJlc2NhbGUoKSkgOiByYW5nZS5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLmludmVydEV4dGVudCA9IGZ1bmN0aW9uKHkpIHtcbiAgICB2YXIgaSA9IHJhbmdlLmluZGV4T2YoeSk7XG4gICAgcmV0dXJuIGkgPCAwID8gW05hTiwgTmFOXVxuICAgICAgICA6IGkgPCAxID8gW3gwLCBkb21haW5bMF1dXG4gICAgICAgIDogaSA+PSBuID8gW2RvbWFpbltuIC0gMV0sIHgxXVxuICAgICAgICA6IFtkb21haW5baSAtIDFdLCBkb21haW5baV1dO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHNjYWxlO1xuICB9O1xuXG4gIHNjYWxlLnRocmVzaG9sZHMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZG9tYWluLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBxdWFudGl6ZSgpXG4gICAgICAgIC5kb21haW4oW3gwLCB4MV0pXG4gICAgICAgIC5yYW5nZShyYW5nZSlcbiAgICAgICAgLnVua25vd24odW5rbm93bik7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRSYW5nZS5hcHBseShsaW5lYXJpc2goc2NhbGUpLCBhcmd1bWVudHMpO1xufVxuIiwiaW1wb3J0IHtiaXNlY3R9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHtzbGljZX0gZnJvbSBcIi4vYXJyYXlcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRocmVzaG9sZCgpIHtcbiAgdmFyIGRvbWFpbiA9IFswLjVdLFxuICAgICAgcmFuZ2UgPSBbMCwgMV0sXG4gICAgICB1bmtub3duLFxuICAgICAgbiA9IDE7XG5cbiAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgIHJldHVybiB4IDw9IHggPyByYW5nZVtiaXNlY3QoZG9tYWluLCB4LCAwLCBuKV0gOiB1bmtub3duO1xuICB9XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRvbWFpbiA9IHNsaWNlLmNhbGwoXyksIG4gPSBNYXRoLm1pbihkb21haW4ubGVuZ3RoLCByYW5nZS5sZW5ndGggLSAxKSwgc2NhbGUpIDogZG9tYWluLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFuZ2UgPSBzbGljZS5jYWxsKF8pLCBuID0gTWF0aC5taW4oZG9tYWluLmxlbmd0aCwgcmFuZ2UubGVuZ3RoIC0gMSksIHNjYWxlKSA6IHJhbmdlLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUuaW52ZXJ0RXh0ZW50ID0gZnVuY3Rpb24oeSkge1xuICAgIHZhciBpID0gcmFuZ2UuaW5kZXhPZih5KTtcbiAgICByZXR1cm4gW2RvbWFpbltpIC0gMV0sIGRvbWFpbltpXV07XG4gIH07XG5cbiAgc2NhbGUudW5rbm93biA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh1bmtub3duID0gXywgc2NhbGUpIDogdW5rbm93bjtcbiAgfTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRocmVzaG9sZCgpXG4gICAgICAgIC5kb21haW4oZG9tYWluKVxuICAgICAgICAucmFuZ2UocmFuZ2UpXG4gICAgICAgIC51bmtub3duKHVua25vd24pO1xuICB9O1xuXG4gIHJldHVybiBpbml0UmFuZ2UuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG4iLCJpbXBvcnQge2Jpc2VjdG9yLCB0aWNrU3RlcH0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge3RpbWVZZWFyLCB0aW1lTW9udGgsIHRpbWVXZWVrLCB0aW1lRGF5LCB0aW1lSG91ciwgdGltZU1pbnV0ZSwgdGltZVNlY29uZCwgdGltZU1pbGxpc2Vjb25kfSBmcm9tIFwiZDMtdGltZVwiO1xuaW1wb3J0IHt0aW1lRm9ybWF0fSBmcm9tIFwiZDMtdGltZS1mb3JtYXRcIjtcbmltcG9ydCB7bWFwfSBmcm9tIFwiLi9hcnJheVwiO1xuaW1wb3J0IGNvbnRpbnVvdXMsIHtjb3B5LCBpZGVudGl0eX0gZnJvbSBcIi4vY29udGludW91c1wiO1xuaW1wb3J0IHtpbml0UmFuZ2V9IGZyb20gXCIuL2luaXRcIjtcbmltcG9ydCBuaWNlIGZyb20gXCIuL25pY2VcIjtcblxudmFyIGR1cmF0aW9uU2Vjb25kID0gMTAwMCxcbiAgICBkdXJhdGlvbk1pbnV0ZSA9IGR1cmF0aW9uU2Vjb25kICogNjAsXG4gICAgZHVyYXRpb25Ib3VyID0gZHVyYXRpb25NaW51dGUgKiA2MCxcbiAgICBkdXJhdGlvbkRheSA9IGR1cmF0aW9uSG91ciAqIDI0LFxuICAgIGR1cmF0aW9uV2VlayA9IGR1cmF0aW9uRGF5ICogNyxcbiAgICBkdXJhdGlvbk1vbnRoID0gZHVyYXRpb25EYXkgKiAzMCxcbiAgICBkdXJhdGlvblllYXIgPSBkdXJhdGlvbkRheSAqIDM2NTtcblxuZnVuY3Rpb24gZGF0ZSh0KSB7XG4gIHJldHVybiBuZXcgRGF0ZSh0KTtcbn1cblxuZnVuY3Rpb24gbnVtYmVyKHQpIHtcbiAgcmV0dXJuIHQgaW5zdGFuY2VvZiBEYXRlID8gK3QgOiArbmV3IERhdGUoK3QpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsZW5kYXIoeWVhciwgbW9udGgsIHdlZWssIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBmb3JtYXQpIHtcbiAgdmFyIHNjYWxlID0gY29udGludW91cyhpZGVudGl0eSwgaWRlbnRpdHkpLFxuICAgICAgaW52ZXJ0ID0gc2NhbGUuaW52ZXJ0LFxuICAgICAgZG9tYWluID0gc2NhbGUuZG9tYWluO1xuXG4gIHZhciBmb3JtYXRNaWxsaXNlY29uZCA9IGZvcm1hdChcIi4lTFwiKSxcbiAgICAgIGZvcm1hdFNlY29uZCA9IGZvcm1hdChcIjolU1wiKSxcbiAgICAgIGZvcm1hdE1pbnV0ZSA9IGZvcm1hdChcIiVJOiVNXCIpLFxuICAgICAgZm9ybWF0SG91ciA9IGZvcm1hdChcIiVJICVwXCIpLFxuICAgICAgZm9ybWF0RGF5ID0gZm9ybWF0KFwiJWEgJWRcIiksXG4gICAgICBmb3JtYXRXZWVrID0gZm9ybWF0KFwiJWIgJWRcIiksXG4gICAgICBmb3JtYXRNb250aCA9IGZvcm1hdChcIiVCXCIpLFxuICAgICAgZm9ybWF0WWVhciA9IGZvcm1hdChcIiVZXCIpO1xuXG4gIHZhciB0aWNrSW50ZXJ2YWxzID0gW1xuICAgIFtzZWNvbmQsICAxLCAgICAgIGR1cmF0aW9uU2Vjb25kXSxcbiAgICBbc2Vjb25kLCAgNSwgIDUgKiBkdXJhdGlvblNlY29uZF0sXG4gICAgW3NlY29uZCwgMTUsIDE1ICogZHVyYXRpb25TZWNvbmRdLFxuICAgIFtzZWNvbmQsIDMwLCAzMCAqIGR1cmF0aW9uU2Vjb25kXSxcbiAgICBbbWludXRlLCAgMSwgICAgICBkdXJhdGlvbk1pbnV0ZV0sXG4gICAgW21pbnV0ZSwgIDUsICA1ICogZHVyYXRpb25NaW51dGVdLFxuICAgIFttaW51dGUsIDE1LCAxNSAqIGR1cmF0aW9uTWludXRlXSxcbiAgICBbbWludXRlLCAzMCwgMzAgKiBkdXJhdGlvbk1pbnV0ZV0sXG4gICAgWyAgaG91ciwgIDEsICAgICAgZHVyYXRpb25Ib3VyICBdLFxuICAgIFsgIGhvdXIsICAzLCAgMyAqIGR1cmF0aW9uSG91ciAgXSxcbiAgICBbICBob3VyLCAgNiwgIDYgKiBkdXJhdGlvbkhvdXIgIF0sXG4gICAgWyAgaG91ciwgMTIsIDEyICogZHVyYXRpb25Ib3VyICBdLFxuICAgIFsgICBkYXksICAxLCAgICAgIGR1cmF0aW9uRGF5ICAgXSxcbiAgICBbICAgZGF5LCAgMiwgIDIgKiBkdXJhdGlvbkRheSAgIF0sXG4gICAgWyAgd2VlaywgIDEsICAgICAgZHVyYXRpb25XZWVrICBdLFxuICAgIFsgbW9udGgsICAxLCAgICAgIGR1cmF0aW9uTW9udGggXSxcbiAgICBbIG1vbnRoLCAgMywgIDMgKiBkdXJhdGlvbk1vbnRoIF0sXG4gICAgWyAgeWVhciwgIDEsICAgICAgZHVyYXRpb25ZZWFyICBdXG4gIF07XG5cbiAgZnVuY3Rpb24gdGlja0Zvcm1hdChkYXRlKSB7XG4gICAgcmV0dXJuIChzZWNvbmQoZGF0ZSkgPCBkYXRlID8gZm9ybWF0TWlsbGlzZWNvbmRcbiAgICAgICAgOiBtaW51dGUoZGF0ZSkgPCBkYXRlID8gZm9ybWF0U2Vjb25kXG4gICAgICAgIDogaG91cihkYXRlKSA8IGRhdGUgPyBmb3JtYXRNaW51dGVcbiAgICAgICAgOiBkYXkoZGF0ZSkgPCBkYXRlID8gZm9ybWF0SG91clxuICAgICAgICA6IG1vbnRoKGRhdGUpIDwgZGF0ZSA/ICh3ZWVrKGRhdGUpIDwgZGF0ZSA/IGZvcm1hdERheSA6IGZvcm1hdFdlZWspXG4gICAgICAgIDogeWVhcihkYXRlKSA8IGRhdGUgPyBmb3JtYXRNb250aFxuICAgICAgICA6IGZvcm1hdFllYXIpKGRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGlja0ludGVydmFsKGludGVydmFsLCBzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgIGlmIChpbnRlcnZhbCA9PSBudWxsKSBpbnRlcnZhbCA9IDEwO1xuXG4gICAgLy8gSWYgYSBkZXNpcmVkIHRpY2sgY291bnQgaXMgc3BlY2lmaWVkLCBwaWNrIGEgcmVhc29uYWJsZSB0aWNrIGludGVydmFsXG4gICAgLy8gYmFzZWQgb24gdGhlIGV4dGVudCBvZiB0aGUgZG9tYWluIGFuZCBhIHJvdWdoIGVzdGltYXRlIG9mIHRpY2sgc2l6ZS5cbiAgICAvLyBPdGhlcndpc2UsIGFzc3VtZSBpbnRlcnZhbCBpcyBhbHJlYWR5IGEgdGltZSBpbnRlcnZhbCBhbmQgdXNlIGl0LlxuICAgIGlmICh0eXBlb2YgaW50ZXJ2YWwgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBNYXRoLmFicyhzdG9wIC0gc3RhcnQpIC8gaW50ZXJ2YWwsXG4gICAgICAgICAgaSA9IGJpc2VjdG9yKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIGlbMl07IH0pLnJpZ2h0KHRpY2tJbnRlcnZhbHMsIHRhcmdldCk7XG4gICAgICBpZiAoaSA9PT0gdGlja0ludGVydmFscy5sZW5ndGgpIHtcbiAgICAgICAgc3RlcCA9IHRpY2tTdGVwKHN0YXJ0IC8gZHVyYXRpb25ZZWFyLCBzdG9wIC8gZHVyYXRpb25ZZWFyLCBpbnRlcnZhbCk7XG4gICAgICAgIGludGVydmFsID0geWVhcjtcbiAgICAgIH0gZWxzZSBpZiAoaSkge1xuICAgICAgICBpID0gdGlja0ludGVydmFsc1t0YXJnZXQgLyB0aWNrSW50ZXJ2YWxzW2kgLSAxXVsyXSA8IHRpY2tJbnRlcnZhbHNbaV1bMl0gLyB0YXJnZXQgPyBpIC0gMSA6IGldO1xuICAgICAgICBzdGVwID0gaVsxXTtcbiAgICAgICAgaW50ZXJ2YWwgPSBpWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RlcCA9IE1hdGgubWF4KHRpY2tTdGVwKHN0YXJ0LCBzdG9wLCBpbnRlcnZhbCksIDEpO1xuICAgICAgICBpbnRlcnZhbCA9IG1pbGxpc2Vjb25kO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdGVwID09IG51bGwgPyBpbnRlcnZhbCA6IGludGVydmFsLmV2ZXJ5KHN0ZXApO1xuICB9XG5cbiAgc2NhbGUuaW52ZXJ0ID0gZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShpbnZlcnQoeSkpO1xuICB9O1xuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IGRvbWFpbihtYXAuY2FsbChfLCBudW1iZXIpKSA6IGRvbWFpbigpLm1hcChkYXRlKTtcbiAgfTtcblxuICBzY2FsZS50aWNrcyA9IGZ1bmN0aW9uKGludGVydmFsLCBzdGVwKSB7XG4gICAgdmFyIGQgPSBkb21haW4oKSxcbiAgICAgICAgdDAgPSBkWzBdLFxuICAgICAgICB0MSA9IGRbZC5sZW5ndGggLSAxXSxcbiAgICAgICAgciA9IHQxIDwgdDAsXG4gICAgICAgIHQ7XG4gICAgaWYgKHIpIHQgPSB0MCwgdDAgPSB0MSwgdDEgPSB0O1xuICAgIHQgPSB0aWNrSW50ZXJ2YWwoaW50ZXJ2YWwsIHQwLCB0MSwgc3RlcCk7XG4gICAgdCA9IHQgPyB0LnJhbmdlKHQwLCB0MSArIDEpIDogW107IC8vIGluY2x1c2l2ZSBzdG9wXG4gICAgcmV0dXJuIHIgPyB0LnJldmVyc2UoKSA6IHQ7XG4gIH07XG5cbiAgc2NhbGUudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKGNvdW50LCBzcGVjaWZpZXIpIHtcbiAgICByZXR1cm4gc3BlY2lmaWVyID09IG51bGwgPyB0aWNrRm9ybWF0IDogZm9ybWF0KHNwZWNpZmllcik7XG4gIH07XG5cbiAgc2NhbGUubmljZSA9IGZ1bmN0aW9uKGludGVydmFsLCBzdGVwKSB7XG4gICAgdmFyIGQgPSBkb21haW4oKTtcbiAgICByZXR1cm4gKGludGVydmFsID0gdGlja0ludGVydmFsKGludGVydmFsLCBkWzBdLCBkW2QubGVuZ3RoIC0gMV0sIHN0ZXApKVxuICAgICAgICA/IGRvbWFpbihuaWNlKGQsIGludGVydmFsKSlcbiAgICAgICAgOiBzY2FsZTtcbiAgfTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIGNhbGVuZGFyKHllYXIsIG1vbnRoLCB3ZWVrLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgZm9ybWF0KSk7XG4gIH07XG5cbiAgcmV0dXJuIHNjYWxlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGluaXRSYW5nZS5hcHBseShjYWxlbmRhcih0aW1lWWVhciwgdGltZU1vbnRoLCB0aW1lV2VlaywgdGltZURheSwgdGltZUhvdXIsIHRpbWVNaW51dGUsIHRpbWVTZWNvbmQsIHRpbWVNaWxsaXNlY29uZCwgdGltZUZvcm1hdCkuZG9tYWluKFtuZXcgRGF0ZSgyMDAwLCAwLCAxKSwgbmV3IERhdGUoMjAwMCwgMCwgMildKSwgYXJndW1lbnRzKTtcbn1cbiIsImltcG9ydCB7Y2FsZW5kYXJ9IGZyb20gXCIuL3RpbWVcIjtcbmltcG9ydCB7dXRjRm9ybWF0fSBmcm9tIFwiZDMtdGltZS1mb3JtYXRcIjtcbmltcG9ydCB7dXRjWWVhciwgdXRjTW9udGgsIHV0Y1dlZWssIHV0Y0RheSwgdXRjSG91ciwgdXRjTWludXRlLCB1dGNTZWNvbmQsIHV0Y01pbGxpc2Vjb25kfSBmcm9tIFwiZDMtdGltZVwiO1xuaW1wb3J0IHtpbml0UmFuZ2V9IGZyb20gXCIuL2luaXRcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBpbml0UmFuZ2UuYXBwbHkoY2FsZW5kYXIodXRjWWVhciwgdXRjTW9udGgsIHV0Y1dlZWssIHV0Y0RheSwgdXRjSG91ciwgdXRjTWludXRlLCB1dGNTZWNvbmQsIHV0Y01pbGxpc2Vjb25kLCB1dGNGb3JtYXQpLmRvbWFpbihbRGF0ZS5VVEMoMjAwMCwgMCwgMSksIERhdGUuVVRDKDIwMDAsIDAsIDIpXSksIGFyZ3VtZW50cyk7XG59XG4iLCJpbXBvcnQge2lkZW50aXR5fSBmcm9tIFwiLi9jb250aW51b3VzXCI7XG5pbXBvcnQge2luaXRJbnRlcnBvbGF0b3J9IGZyb20gXCIuL2luaXRcIjtcbmltcG9ydCB7bGluZWFyaXNofSBmcm9tIFwiLi9saW5lYXJcIjtcbmltcG9ydCB7bG9nZ2lzaH0gZnJvbSBcIi4vbG9nXCI7XG5pbXBvcnQge3N5bWxvZ2lzaH0gZnJvbSBcIi4vc3ltbG9nXCI7XG5pbXBvcnQge3Bvd2lzaH0gZnJvbSBcIi4vcG93XCI7XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybWVyKCkge1xuICB2YXIgeDAgPSAwLFxuICAgICAgeDEgPSAxLFxuICAgICAgdDAsXG4gICAgICB0MSxcbiAgICAgIGsxMCxcbiAgICAgIHRyYW5zZm9ybSxcbiAgICAgIGludGVycG9sYXRvciA9IGlkZW50aXR5LFxuICAgICAgY2xhbXAgPSBmYWxzZSxcbiAgICAgIHVua25vd247XG5cbiAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgIHJldHVybiBpc05hTih4ID0gK3gpID8gdW5rbm93biA6IGludGVycG9sYXRvcihrMTAgPT09IDAgPyAwLjUgOiAoeCA9ICh0cmFuc2Zvcm0oeCkgLSB0MCkgKiBrMTAsIGNsYW1wID8gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgeCkpIDogeCkpO1xuICB9XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHQwID0gdHJhbnNmb3JtKHgwID0gK19bMF0pLCB0MSA9IHRyYW5zZm9ybSh4MSA9ICtfWzFdKSwgazEwID0gdDAgPT09IHQxID8gMCA6IDEgLyAodDEgLSB0MCksIHNjYWxlKSA6IFt4MCwgeDFdO1xuICB9O1xuXG4gIHNjYWxlLmNsYW1wID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNsYW1wID0gISFfLCBzY2FsZSkgOiBjbGFtcDtcbiAgfTtcblxuICBzY2FsZS5pbnRlcnBvbGF0b3IgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaW50ZXJwb2xhdG9yID0gXywgc2NhbGUpIDogaW50ZXJwb2xhdG9yO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB0cmFuc2Zvcm0gPSB0LCB0MCA9IHQoeDApLCB0MSA9IHQoeDEpLCBrMTAgPSB0MCA9PT0gdDEgPyAwIDogMSAvICh0MSAtIHQwKTtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KHNvdXJjZSwgdGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXRcbiAgICAgIC5kb21haW4oc291cmNlLmRvbWFpbigpKVxuICAgICAgLmludGVycG9sYXRvcihzb3VyY2UuaW50ZXJwb2xhdG9yKCkpXG4gICAgICAuY2xhbXAoc291cmNlLmNsYW1wKCkpXG4gICAgICAudW5rbm93bihzb3VyY2UudW5rbm93bigpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2VxdWVudGlhbCgpIHtcbiAgdmFyIHNjYWxlID0gbGluZWFyaXNoKHRyYW5zZm9ybWVyKCkoaWRlbnRpdHkpKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIHNlcXVlbnRpYWwoKSk7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRJbnRlcnBvbGF0b3IuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXF1ZW50aWFsTG9nKCkge1xuICB2YXIgc2NhbGUgPSBsb2dnaXNoKHRyYW5zZm9ybWVyKCkpLmRvbWFpbihbMSwgMTBdKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIHNlcXVlbnRpYWxMb2coKSkuYmFzZShzY2FsZS5iYXNlKCkpO1xuICB9O1xuXG4gIHJldHVybiBpbml0SW50ZXJwb2xhdG9yLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VxdWVudGlhbFN5bWxvZygpIHtcbiAgdmFyIHNjYWxlID0gc3ltbG9naXNoKHRyYW5zZm9ybWVyKCkpO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgc2VxdWVudGlhbFN5bWxvZygpKS5jb25zdGFudChzY2FsZS5jb25zdGFudCgpKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdEludGVycG9sYXRvci5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlcXVlbnRpYWxQb3coKSB7XG4gIHZhciBzY2FsZSA9IHBvd2lzaCh0cmFuc2Zvcm1lcigpKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIHNlcXVlbnRpYWxQb3coKSkuZXhwb25lbnQoc2NhbGUuZXhwb25lbnQoKSk7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRJbnRlcnBvbGF0b3IuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXF1ZW50aWFsU3FydCgpIHtcbiAgcmV0dXJuIHNlcXVlbnRpYWxQb3cuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5leHBvbmVudCgwLjUpO1xufVxuIiwiaW1wb3J0IHthc2NlbmRpbmcsIGJpc2VjdH0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge2lkZW50aXR5fSBmcm9tIFwiLi9jb250aW51b3VzXCI7XG5pbXBvcnQge2luaXRJbnRlcnBvbGF0b3J9IGZyb20gXCIuL2luaXRcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2VxdWVudGlhbFF1YW50aWxlKCkge1xuICB2YXIgZG9tYWluID0gW10sXG4gICAgICBpbnRlcnBvbGF0b3IgPSBpZGVudGl0eTtcblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgaWYgKCFpc05hTih4ID0gK3gpKSByZXR1cm4gaW50ZXJwb2xhdG9yKChiaXNlY3QoZG9tYWluLCB4KSAtIDEpIC8gKGRvbWFpbi5sZW5ndGggLSAxKSk7XG4gIH1cblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZG9tYWluLnNsaWNlKCk7XG4gICAgZG9tYWluID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBfLmxlbmd0aCwgZDsgaSA8IG47ICsraSkgaWYgKGQgPSBfW2ldLCBkICE9IG51bGwgJiYgIWlzTmFOKGQgPSArZCkpIGRvbWFpbi5wdXNoKGQpO1xuICAgIGRvbWFpbi5zb3J0KGFzY2VuZGluZyk7XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9O1xuXG4gIHNjYWxlLmludGVycG9sYXRvciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpbnRlcnBvbGF0b3IgPSBfLCBzY2FsZSkgOiBpbnRlcnBvbGF0b3I7XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzZXF1ZW50aWFsUXVhbnRpbGUoaW50ZXJwb2xhdG9yKS5kb21haW4oZG9tYWluKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdEludGVycG9sYXRvci5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cbiIsImltcG9ydCB7aWRlbnRpdHl9IGZyb20gXCIuL2NvbnRpbnVvdXNcIjtcbmltcG9ydCB7aW5pdEludGVycG9sYXRvcn0gZnJvbSBcIi4vaW5pdFwiO1xuaW1wb3J0IHtsaW5lYXJpc2h9IGZyb20gXCIuL2xpbmVhclwiO1xuaW1wb3J0IHtsb2dnaXNofSBmcm9tIFwiLi9sb2dcIjtcbmltcG9ydCB7Y29weX0gZnJvbSBcIi4vc2VxdWVudGlhbFwiO1xuaW1wb3J0IHtzeW1sb2dpc2h9IGZyb20gXCIuL3N5bWxvZ1wiO1xuaW1wb3J0IHtwb3dpc2h9IGZyb20gXCIuL3Bvd1wiO1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1lcigpIHtcbiAgdmFyIHgwID0gMCxcbiAgICAgIHgxID0gMC41LFxuICAgICAgeDIgPSAxLFxuICAgICAgdDAsXG4gICAgICB0MSxcbiAgICAgIHQyLFxuICAgICAgazEwLFxuICAgICAgazIxLFxuICAgICAgaW50ZXJwb2xhdG9yID0gaWRlbnRpdHksXG4gICAgICB0cmFuc2Zvcm0sXG4gICAgICBjbGFtcCA9IGZhbHNlLFxuICAgICAgdW5rbm93bjtcblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgcmV0dXJuIGlzTmFOKHggPSAreCkgPyB1bmtub3duIDogKHggPSAwLjUgKyAoKHggPSArdHJhbnNmb3JtKHgpKSAtIHQxKSAqICh4IDwgdDEgPyBrMTAgOiBrMjEpLCBpbnRlcnBvbGF0b3IoY2xhbXAgPyBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCB4KSkgOiB4KSk7XG4gIH1cblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodDAgPSB0cmFuc2Zvcm0oeDAgPSArX1swXSksIHQxID0gdHJhbnNmb3JtKHgxID0gK19bMV0pLCB0MiA9IHRyYW5zZm9ybSh4MiA9ICtfWzJdKSwgazEwID0gdDAgPT09IHQxID8gMCA6IDAuNSAvICh0MSAtIHQwKSwgazIxID0gdDEgPT09IHQyID8gMCA6IDAuNSAvICh0MiAtIHQxKSwgc2NhbGUpIDogW3gwLCB4MSwgeDJdO1xuICB9O1xuXG4gIHNjYWxlLmNsYW1wID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNsYW1wID0gISFfLCBzY2FsZSkgOiBjbGFtcDtcbiAgfTtcblxuICBzY2FsZS5pbnRlcnBvbGF0b3IgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaW50ZXJwb2xhdG9yID0gXywgc2NhbGUpIDogaW50ZXJwb2xhdG9yO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB0cmFuc2Zvcm0gPSB0LCB0MCA9IHQoeDApLCB0MSA9IHQoeDEpLCB0MiA9IHQoeDIpLCBrMTAgPSB0MCA9PT0gdDEgPyAwIDogMC41IC8gKHQxIC0gdDApLCBrMjEgPSB0MSA9PT0gdDIgPyAwIDogMC41IC8gKHQyIC0gdDEpO1xuICAgIHJldHVybiBzY2FsZTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGl2ZXJnaW5nKCkge1xuICB2YXIgc2NhbGUgPSBsaW5lYXJpc2godHJhbnNmb3JtZXIoKShpZGVudGl0eSkpO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgZGl2ZXJnaW5nKCkpO1xuICB9O1xuXG4gIHJldHVybiBpbml0SW50ZXJwb2xhdG9yLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGl2ZXJnaW5nTG9nKCkge1xuICB2YXIgc2NhbGUgPSBsb2dnaXNoKHRyYW5zZm9ybWVyKCkpLmRvbWFpbihbMC4xLCAxLCAxMF0pO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgZGl2ZXJnaW5nTG9nKCkpLmJhc2Uoc2NhbGUuYmFzZSgpKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdEludGVycG9sYXRvci5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpdmVyZ2luZ1N5bWxvZygpIHtcbiAgdmFyIHNjYWxlID0gc3ltbG9naXNoKHRyYW5zZm9ybWVyKCkpO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgZGl2ZXJnaW5nU3ltbG9nKCkpLmNvbnN0YW50KHNjYWxlLmNvbnN0YW50KCkpO1xuICB9O1xuXG4gIHJldHVybiBpbml0SW50ZXJwb2xhdG9yLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGl2ZXJnaW5nUG93KCkge1xuICB2YXIgc2NhbGUgPSBwb3dpc2godHJhbnNmb3JtZXIoKSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBkaXZlcmdpbmdQb3coKSkuZXhwb25lbnQoc2NhbGUuZXhwb25lbnQoKSk7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRJbnRlcnBvbGF0b3IuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXZlcmdpbmdTcXJ0KCkge1xuICByZXR1cm4gZGl2ZXJnaW5nUG93LmFwcGx5KG51bGwsIGFyZ3VtZW50cykuZXhwb25lbnQoMC41KTtcbn1cbiIsImV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgc2NhbGVCYW5kLFxuICBwb2ludCBhcyBzY2FsZVBvaW50XG59IGZyb20gXCIuL2JhbmRcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyBzY2FsZUlkZW50aXR5XG59IGZyb20gXCIuL2lkZW50aXR5XCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgc2NhbGVMaW5lYXJcbn0gZnJvbSBcIi4vbGluZWFyXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgc2NhbGVMb2dcbn0gZnJvbSBcIi4vbG9nXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgc2NhbGVTeW1sb2dcbn0gZnJvbSBcIi4vc3ltbG9nXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgc2NhbGVPcmRpbmFsLFxuICBpbXBsaWNpdCBhcyBzY2FsZUltcGxpY2l0XG59IGZyb20gXCIuL29yZGluYWxcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyBzY2FsZVBvdyxcbiAgc3FydCBhcyBzY2FsZVNxcnRcbn0gZnJvbSBcIi4vcG93XCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgc2NhbGVRdWFudGlsZVxufSBmcm9tIFwiLi9xdWFudGlsZVwiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIHNjYWxlUXVhbnRpemVcbn0gZnJvbSBcIi4vcXVhbnRpemVcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyBzY2FsZVRocmVzaG9sZFxufSBmcm9tIFwiLi90aHJlc2hvbGRcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyBzY2FsZVRpbWVcbn0gZnJvbSBcIi4vdGltZVwiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIHNjYWxlVXRjXG59IGZyb20gXCIuL3V0Y1RpbWVcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyBzY2FsZVNlcXVlbnRpYWwsXG4gIHNlcXVlbnRpYWxMb2cgYXMgc2NhbGVTZXF1ZW50aWFsTG9nLFxuICBzZXF1ZW50aWFsUG93IGFzIHNjYWxlU2VxdWVudGlhbFBvdyxcbiAgc2VxdWVudGlhbFNxcnQgYXMgc2NhbGVTZXF1ZW50aWFsU3FydCxcbiAgc2VxdWVudGlhbFN5bWxvZyBhcyBzY2FsZVNlcXVlbnRpYWxTeW1sb2dcbn0gZnJvbSBcIi4vc2VxdWVudGlhbFwiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIHNjYWxlU2VxdWVudGlhbFF1YW50aWxlXG59IGZyb20gXCIuL3NlcXVlbnRpYWxRdWFudGlsZVwiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIHNjYWxlRGl2ZXJnaW5nLFxuICBkaXZlcmdpbmdMb2cgYXMgc2NhbGVEaXZlcmdpbmdMb2csXG4gIGRpdmVyZ2luZ1BvdyBhcyBzY2FsZURpdmVyZ2luZ1BvdyxcbiAgZGl2ZXJnaW5nU3FydCBhcyBzY2FsZURpdmVyZ2luZ1NxcnQsXG4gIGRpdmVyZ2luZ1N5bWxvZyBhcyBzY2FsZURpdmVyZ2luZ1N5bWxvZ1xufSBmcm9tIFwiLi9kaXZlcmdpbmdcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyB0aWNrRm9ybWF0XG59IGZyb20gXCIuL3RpY2tGb3JtYXRcIjtcbiIsImltcG9ydCB7IHNjYWxlQmFuZCwgc2NhbGVQb2ludCwgc2NhbGVMaW5lYXIsIHNjYWxlVGltZSwgc2NhbGVVdGMsIHNjYWxlTG9nLCBzY2FsZVBvdywgc2NhbGVPcmRpbmFsLCBzY2FsZVF1YW50aXplLCBzY2FsZVF1YW50aWxlLCBzY2FsZVRocmVzaG9sZCB9IGZyb20gJ2QzLXNjYWxlJztcblxudmFyIGJhbmQgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHJhbmdlID0gX3JlZi5yYW5nZSxcbiAgICAgIHJhbmdlUm91bmQgPSBfcmVmLnJhbmdlUm91bmQsXG4gICAgICBkb21haW4gPSBfcmVmLmRvbWFpbixcbiAgICAgIHBhZGRpbmcgPSBfcmVmLnBhZGRpbmcsXG4gICAgICBwYWRkaW5nSW5uZXIgPSBfcmVmLnBhZGRpbmdJbm5lcixcbiAgICAgIHBhZGRpbmdPdXRlciA9IF9yZWYucGFkZGluZ091dGVyLFxuICAgICAgYWxpZ24gPSBfcmVmLmFsaWduLFxuICAgICAgdGlja0Zvcm1hdCA9IF9yZWYudGlja0Zvcm1hdDtcblxuICB2YXIgc2NhbGUgPSBzY2FsZUJhbmQoKTtcblxuICBpZiAocmFuZ2UpIHNjYWxlLnJhbmdlKHJhbmdlKTtcbiAgaWYgKHJhbmdlUm91bmQpIHNjYWxlLnJhbmdlUm91bmQocmFuZ2VSb3VuZCk7XG4gIGlmIChkb21haW4pIHNjYWxlLmRvbWFpbihkb21haW4pO1xuICBpZiAocGFkZGluZykgc2NhbGUucGFkZGluZyhwYWRkaW5nKTtcbiAgaWYgKHBhZGRpbmdJbm5lcikgc2NhbGUucGFkZGluZ0lubmVyKHBhZGRpbmdJbm5lcik7XG4gIGlmIChwYWRkaW5nT3V0ZXIpIHNjYWxlLnBhZGRpbmdPdXRlcihwYWRkaW5nT3V0ZXIpO1xuICBpZiAoYWxpZ24pIHNjYWxlLmFsaWduKGFsaWduKTtcbiAgaWYgKHRpY2tGb3JtYXQpIHNjYWxlLnRpY2tGb3JtYXQgPSB0aWNrRm9ybWF0O1xuXG4gIHJldHVybiBzY2FsZTtcbn0pO1xuXG52YXIgcG9pbnQgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHJhbmdlID0gX3JlZi5yYW5nZSxcbiAgICAgIHJhbmdlUm91bmQgPSBfcmVmLnJhbmdlUm91bmQsXG4gICAgICBkb21haW4gPSBfcmVmLmRvbWFpbixcbiAgICAgIHBhZGRpbmcgPSBfcmVmLnBhZGRpbmcsXG4gICAgICBhbGlnbiA9IF9yZWYuYWxpZ24sXG4gICAgICBfcmVmJG5pY2UgPSBfcmVmLm5pY2UsXG4gICAgICBuaWNlID0gX3JlZiRuaWNlID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkbmljZTtcblxuICB2YXIgc2NhbGUgPSBzY2FsZVBvaW50KCk7XG5cbiAgaWYgKHJhbmdlKSBzY2FsZS5yYW5nZShyYW5nZSk7XG4gIGlmIChyYW5nZVJvdW5kKSBzY2FsZS5yYW5nZVJvdW5kKHJhbmdlUm91bmQpO1xuICBpZiAoZG9tYWluKSBzY2FsZS5kb21haW4oZG9tYWluKTtcbiAgaWYgKG5pY2UpIHNjYWxlLm5pY2UoKTtcbiAgaWYgKHBhZGRpbmcpIHNjYWxlLnBhZGRpbmcocGFkZGluZyk7XG4gIGlmIChhbGlnbikgc2NhbGUuYWxpZ24oYWxpZ24pO1xuXG4gIHJldHVybiBzY2FsZTtcbn0pO1xuXG52YXIgbGluZWFyID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciByYW5nZSA9IF9yZWYucmFuZ2UsXG4gICAgICByYW5nZVJvdW5kID0gX3JlZi5yYW5nZVJvdW5kLFxuICAgICAgZG9tYWluID0gX3JlZi5kb21haW4sXG4gICAgICBfcmVmJG5pY2UgPSBfcmVmLm5pY2UsXG4gICAgICBuaWNlID0gX3JlZiRuaWNlID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkbmljZSxcbiAgICAgIF9yZWYkY2xhbXAgPSBfcmVmLmNsYW1wLFxuICAgICAgY2xhbXAgPSBfcmVmJGNsYW1wID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkY2xhbXA7XG5cbiAgdmFyIHNjYWxlID0gc2NhbGVMaW5lYXIoKTtcblxuICBpZiAocmFuZ2UpIHNjYWxlLnJhbmdlKHJhbmdlKTtcbiAgaWYgKHJhbmdlUm91bmQpIHNjYWxlLnJhbmdlUm91bmQocmFuZ2VSb3VuZCk7XG4gIGlmIChkb21haW4pIHNjYWxlLmRvbWFpbihkb21haW4pO1xuICBpZiAobmljZSkgc2NhbGUubmljZSgpO1xuICBpZiAoY2xhbXApIHNjYWxlLmNsYW1wKHRydWUpO1xuXG4gIHJldHVybiBzY2FsZTtcbn0pO1xuXG52YXIgdGltZSA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgcmFuZ2UgPSBfcmVmLnJhbmdlLFxuICAgICAgcmFuZ2VSb3VuZCA9IF9yZWYucmFuZ2VSb3VuZCxcbiAgICAgIGRvbWFpbiA9IF9yZWYuZG9tYWluLFxuICAgICAgX3JlZiRuaWNlID0gX3JlZi5uaWNlLFxuICAgICAgbmljZSA9IF9yZWYkbmljZSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJG5pY2UsXG4gICAgICBfcmVmJGNsYW1wID0gX3JlZi5jbGFtcCxcbiAgICAgIGNsYW1wID0gX3JlZiRjbGFtcCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJGNsYW1wO1xuXG4gIHZhciBzY2FsZSA9IHNjYWxlVGltZSgpO1xuXG4gIGlmIChyYW5nZSkgc2NhbGUucmFuZ2UocmFuZ2UpO1xuICBpZiAocmFuZ2VSb3VuZCkgc2NhbGUucmFuZ2VSb3VuZChyYW5nZVJvdW5kKTtcbiAgaWYgKGRvbWFpbikgc2NhbGUuZG9tYWluKGRvbWFpbik7XG4gIGlmIChuaWNlKSBzY2FsZS5uaWNlKCk7XG4gIGlmIChjbGFtcCkgc2NhbGUuY2xhbXAodHJ1ZSk7XG5cbiAgcmV0dXJuIHNjYWxlO1xufSk7XG5cbnZhciB1dGMgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHJhbmdlID0gX3JlZi5yYW5nZSxcbiAgICAgIHJhbmdlUm91bmQgPSBfcmVmLnJhbmdlUm91bmQsXG4gICAgICBkb21haW4gPSBfcmVmLmRvbWFpbixcbiAgICAgIF9yZWYkbmljZSA9IF9yZWYubmljZSxcbiAgICAgIG5pY2UgPSBfcmVmJG5pY2UgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiRuaWNlLFxuICAgICAgX3JlZiRjbGFtcCA9IF9yZWYuY2xhbXAsXG4gICAgICBjbGFtcCA9IF9yZWYkY2xhbXAgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiRjbGFtcDtcblxuICB2YXIgc2NhbGUgPSBzY2FsZVV0YygpO1xuXG4gIGlmIChyYW5nZSkgc2NhbGUucmFuZ2UocmFuZ2UpO1xuICBpZiAocmFuZ2VSb3VuZCkgc2NhbGUucmFuZ2VSb3VuZChyYW5nZVJvdW5kKTtcbiAgaWYgKGRvbWFpbikgc2NhbGUuZG9tYWluKGRvbWFpbik7XG4gIGlmIChuaWNlKSBzY2FsZS5uaWNlKCk7XG4gIGlmIChjbGFtcCkgc2NhbGUuY2xhbXAodHJ1ZSk7XG5cbiAgcmV0dXJuIHNjYWxlO1xufSk7XG5cbnZhciBsb2cgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHJhbmdlID0gX3JlZi5yYW5nZSxcbiAgICAgIHJhbmdlUm91bmQgPSBfcmVmLnJhbmdlUm91bmQsXG4gICAgICBkb21haW4gPSBfcmVmLmRvbWFpbixcbiAgICAgIGJhc2UgPSBfcmVmLmJhc2UsXG4gICAgICBfcmVmJG5pY2UgPSBfcmVmLm5pY2UsXG4gICAgICBuaWNlID0gX3JlZiRuaWNlID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkbmljZSxcbiAgICAgIF9yZWYkY2xhbXAgPSBfcmVmLmNsYW1wLFxuICAgICAgY2xhbXAgPSBfcmVmJGNsYW1wID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkY2xhbXA7XG5cbiAgdmFyIHNjYWxlID0gc2NhbGVMb2coKTtcblxuICBpZiAocmFuZ2UpIHNjYWxlLnJhbmdlKHJhbmdlKTtcbiAgaWYgKHJhbmdlUm91bmQpIHNjYWxlLnJhbmdlUm91bmQocmFuZ2VSb3VuZCk7XG4gIGlmIChkb21haW4pIHNjYWxlLmRvbWFpbihkb21haW4pO1xuICBpZiAobmljZSkgc2NhbGUubmljZSgpO1xuICBpZiAoY2xhbXApIHNjYWxlLmNsYW1wKHRydWUpO1xuICBpZiAoYmFzZSkgc2NhbGUuYmFzZShiYXNlKTtcblxuICByZXR1cm4gc2NhbGU7XG59KTtcblxudmFyIHBvd2VyID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciByYW5nZSA9IF9yZWYucmFuZ2UsXG4gICAgICByYW5nZVJvdW5kID0gX3JlZi5yYW5nZVJvdW5kLFxuICAgICAgZG9tYWluID0gX3JlZi5kb21haW4sXG4gICAgICBleHBvbmVudCA9IF9yZWYuZXhwb25lbnQsXG4gICAgICBfcmVmJG5pY2UgPSBfcmVmLm5pY2UsXG4gICAgICBuaWNlID0gX3JlZiRuaWNlID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkbmljZSxcbiAgICAgIF9yZWYkY2xhbXAgPSBfcmVmLmNsYW1wLFxuICAgICAgY2xhbXAgPSBfcmVmJGNsYW1wID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkY2xhbXA7XG5cbiAgdmFyIHNjYWxlID0gc2NhbGVQb3coKTtcblxuICBpZiAocmFuZ2UpIHNjYWxlLnJhbmdlKHJhbmdlKTtcbiAgaWYgKHJhbmdlUm91bmQpIHNjYWxlLnJhbmdlUm91bmQocmFuZ2VSb3VuZCk7XG4gIGlmIChkb21haW4pIHNjYWxlLmRvbWFpbihkb21haW4pO1xuICBpZiAobmljZSkgc2NhbGUubmljZSgpO1xuICBpZiAoY2xhbXApIHNjYWxlLmNsYW1wKHRydWUpO1xuICBpZiAoZXhwb25lbnQpIHNjYWxlLmV4cG9uZW50KGV4cG9uZW50KTtcblxuICByZXR1cm4gc2NhbGU7XG59KTtcblxudmFyIG9yZGluYWwgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHJhbmdlID0gX3JlZi5yYW5nZSxcbiAgICAgIGRvbWFpbiA9IF9yZWYuZG9tYWluLFxuICAgICAgdW5rbm93biA9IF9yZWYudW5rbm93bjtcblxuICB2YXIgc2NhbGUgPSBzY2FsZU9yZGluYWwoKTtcblxuICBpZiAocmFuZ2UpIHNjYWxlLnJhbmdlKHJhbmdlKTtcbiAgaWYgKGRvbWFpbikgc2NhbGUuZG9tYWluKGRvbWFpbik7XG4gIGlmICh1bmtub3duKSBzY2FsZS51bmtub3duKHVua25vd24pO1xuXG4gIHJldHVybiBzY2FsZTtcbn0pO1xuXG52YXIgcXVhbnRpemUgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHJhbmdlID0gX3JlZi5yYW5nZSxcbiAgICAgIGRvbWFpbiA9IF9yZWYuZG9tYWluLFxuICAgICAgdGlja3MgPSBfcmVmLnRpY2tzLFxuICAgICAgdGlja0Zvcm1hdCA9IF9yZWYudGlja0Zvcm1hdCxcbiAgICAgIF9yZWYkbmljZSA9IF9yZWYubmljZSxcbiAgICAgIG5pY2UgPSBfcmVmJG5pY2UgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiRuaWNlO1xuXG4gIHZhciBzY2FsZSA9IHNjYWxlUXVhbnRpemUoKTtcblxuICBpZiAocmFuZ2UpIHNjYWxlLnJhbmdlKHJhbmdlKTtcbiAgaWYgKGRvbWFpbikgc2NhbGUuZG9tYWluKGRvbWFpbik7XG4gIGlmIChuaWNlKSBzY2FsZS5uaWNlKCk7XG4gIGlmICh0aWNrcykgc2NhbGUudGlja3ModGlja3MpO1xuICBpZiAodGlja0Zvcm1hdCkgc2NhbGUudGlja0Zvcm1hdCh0aWNrRm9ybWF0KTtcblxuICByZXR1cm4gc2NhbGU7XG59KTtcblxudmFyIHF1YW50aWxlID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciByYW5nZSA9IF9yZWYucmFuZ2UsXG4gICAgICBkb21haW4gPSBfcmVmLmRvbWFpbjtcblxuICB2YXIgc2NhbGUgPSBzY2FsZVF1YW50aWxlKCk7XG5cbiAgaWYgKHJhbmdlKSBzY2FsZS5yYW5nZShyYW5nZSk7XG4gIGlmIChkb21haW4pIHNjYWxlLmRvbWFpbihkb21haW4pO1xuXG4gIHJldHVybiBzY2FsZTtcbn0pO1xuXG52YXIgdGhyZXNob2xkID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciByYW5nZSA9IF9yZWYucmFuZ2UsXG4gICAgICBkb21haW4gPSBfcmVmLmRvbWFpbjtcblxuICB2YXIgc2NhbGUgPSBzY2FsZVRocmVzaG9sZCgpO1xuXG4gIGlmIChyYW5nZSkgc2NhbGUucmFuZ2UocmFuZ2UpO1xuICBpZiAoZG9tYWluKSBzY2FsZS5kb21haW4oZG9tYWluKTtcblxuICByZXR1cm4gc2NhbGU7XG59KTtcblxudmFyIG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG9iaiwga2V5cykge1xuICB2YXIgdGFyZ2V0ID0ge307XG5cbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlO1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlO1xuICAgIHRhcmdldFtpXSA9IG9ialtpXTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG5mdW5jdGlvbiB1cGRhdGVTY2FsZShzY2FsZSwgX3JlZikge1xuICB2YXIgYXJncyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFtdKTtcblxuICB2YXIgbmV4dFNjYWxlID0gc2NhbGUuY29weSgpO1xuICBPYmplY3Qua2V5cyhhcmdzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAobmV4dFNjYWxlLmhhc093blByb3BlcnR5KGtleSkpIG5leHRTY2FsZVtrZXldKGFyZ3Nba2V5XSk7XG4gIH0pO1xuICByZXR1cm4gbmV4dFNjYWxlO1xufVxuXG5leHBvcnQgeyBiYW5kIGFzIHNjYWxlQmFuZCwgcG9pbnQgYXMgc2NhbGVQb2ludCwgbGluZWFyIGFzIHNjYWxlTGluZWFyLCB0aW1lIGFzIHNjYWxlVGltZSwgdXRjIGFzIHNjYWxlVXRjLCBsb2cgYXMgc2NhbGVMb2csIHBvd2VyIGFzIHNjYWxlUG93ZXIsIG9yZGluYWwgYXMgc2NhbGVPcmRpbmFsLCBxdWFudGl6ZSBhcyBzY2FsZVF1YW50aXplLCBxdWFudGlsZSBhcyBzY2FsZVF1YW50aWxlLCB0aHJlc2hvbGQgYXMgc2NhbGVUaHJlc2hvbGQsIHVwZGF0ZVNjYWxlIH07XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgeyBHcm91cCB9IGZyb20gJ0B2eC9ncm91cCc7XG5pbXBvcnQgeyBzY2FsZUxpbmVhciB9IGZyb20gJ0B2eC9zY2FsZSc7XG5pbXBvcnQgeyBsaW5lLCBjdXJ2ZUNhcmRpbmFsIH0gZnJvbSAnZDMtc2hhcGUnO1xuXG5mdW5jdGlvbiBjYWxsT3JWYWx1ZShtYXliZUZuLCBkYXRhKSB7XG4gIGlmICh0eXBlb2YgbWF5YmVGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUZuKGRhdGEpO1xuICB9XG4gIHJldHVybiBtYXliZUZuO1xufVxuXG5mdW5jdGlvbiBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzLCBkYXRhKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhyZXN0UHJvcHMpLnJlZHVjZShmdW5jdGlvbiAocmV0LCBjdXIpIHtcbiAgICByZXRbY3VyXSA9IGNhbGxPclZhbHVlKHJlc3RQcm9wc1tjdXJdLCBkYXRhKTtcbiAgICByZXR1cm4gcmV0O1xuICB9LCB7fSk7XG59XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG52YXIgb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgPSBmdW5jdGlvbiAob2JqLCBrZXlzKSB7XG4gIHZhciB0YXJnZXQgPSB7fTtcblxuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7XG4gICAgdGFyZ2V0W2ldID0gb2JqW2ldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbnZhciBzbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkge1xuICAgIHZhciBfYXJyID0gW107XG4gICAgdmFyIF9uID0gdHJ1ZTtcbiAgICB2YXIgX2QgPSBmYWxzZTtcbiAgICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9kID0gdHJ1ZTtcbiAgICAgIF9lID0gZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX2FycjtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgcmV0dXJuIGFycjtcbiAgICB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkge1xuICAgICAgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG4gICAgfVxuICB9O1xufSgpO1xuXG52YXIgdG9Db25zdW1hYmxlQXJyYXkgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gICAgcmV0dXJuIGFycjI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oYXJyKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gdmVydGljYWxUb0hvcml6b250YWwoX3JlZikge1xuICB2YXIgX3JlZjIgPSBzbGljZWRUb0FycmF5KF9yZWYsIDQpLFxuICAgICAgeDEgPSBfcmVmMlswXSxcbiAgICAgIHkxID0gX3JlZjJbMV0sXG4gICAgICB4MiA9IF9yZWYyWzJdLFxuICAgICAgeTIgPSBfcmVmMlszXTtcblxuICByZXR1cm4gW3kxLCB4MSwgeTIsIHgyXTtcbn1cblxuZnVuY3Rpb24gQm94UGxvdChfcmVmMykge1xuICB2YXIgX3JlZjMkbGVmdCA9IF9yZWYzLmxlZnQsXG4gICAgICBsZWZ0ID0gX3JlZjMkbGVmdCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYzJGxlZnQsXG4gICAgICBfcmVmMyR0b3AgPSBfcmVmMy50b3AsXG4gICAgICB0b3AgPSBfcmVmMyR0b3AgPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmMyR0b3AsXG4gICAgICBjbGFzc05hbWUgPSBfcmVmMy5jbGFzc05hbWUsXG4gICAgICBkYXRhID0gX3JlZjMuZGF0YSxcbiAgICAgIG1heCA9IF9yZWYzLm1heCxcbiAgICAgIG1pbiA9IF9yZWYzLm1pbixcbiAgICAgIGZpcnN0UXVhcnRpbGUgPSBfcmVmMy5maXJzdFF1YXJ0aWxlLFxuICAgICAgdGhpcmRRdWFydGlsZSA9IF9yZWYzLnRoaXJkUXVhcnRpbGUsXG4gICAgICBtZWRpYW4gPSBfcmVmMy5tZWRpYW4sXG4gICAgICBib3hXaWR0aCA9IF9yZWYzLmJveFdpZHRoLFxuICAgICAgZmlsbCA9IF9yZWYzLmZpbGwsXG4gICAgICBmaWxsT3BhY2l0eSA9IF9yZWYzLmZpbGxPcGFjaXR5LFxuICAgICAgc3Ryb2tlID0gX3JlZjMuc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGggPSBfcmVmMy5zdHJva2VXaWR0aCxcbiAgICAgIF9yZWYzJHJ4ID0gX3JlZjMucngsXG4gICAgICByeCA9IF9yZWYzJHJ4ID09PSB1bmRlZmluZWQgPyAyIDogX3JlZjMkcngsXG4gICAgICBfcmVmMyRyeSA9IF9yZWYzLnJ5LFxuICAgICAgcnkgPSBfcmVmMyRyeSA9PT0gdW5kZWZpbmVkID8gMiA6IF9yZWYzJHJ5LFxuICAgICAgdmFsdWVTY2FsZSA9IF9yZWYzLnZhbHVlU2NhbGUsXG4gICAgICBvdXRsaWVycyA9IF9yZWYzLm91dGxpZXJzLFxuICAgICAgaG9yaXpvbnRhbCA9IF9yZWYzLmhvcml6b250YWwsXG4gICAgICBfcmVmMyRtZWRpYW5Qcm9wcyA9IF9yZWYzLm1lZGlhblByb3BzLFxuICAgICAgbWVkaWFuUHJvcHMgPSBfcmVmMyRtZWRpYW5Qcm9wcyA9PT0gdW5kZWZpbmVkID8ge30gOiBfcmVmMyRtZWRpYW5Qcm9wcyxcbiAgICAgIF9yZWYzJG1heFByb3BzID0gX3JlZjMubWF4UHJvcHMsXG4gICAgICBtYXhQcm9wcyA9IF9yZWYzJG1heFByb3BzID09PSB1bmRlZmluZWQgPyB7fSA6IF9yZWYzJG1heFByb3BzLFxuICAgICAgX3JlZjMkbWluUHJvcHMgPSBfcmVmMy5taW5Qcm9wcyxcbiAgICAgIG1pblByb3BzID0gX3JlZjMkbWluUHJvcHMgPT09IHVuZGVmaW5lZCA/IHt9IDogX3JlZjMkbWluUHJvcHMsXG4gICAgICBfcmVmMyRib3hQcm9wcyA9IF9yZWYzLmJveFByb3BzLFxuICAgICAgYm94UHJvcHMgPSBfcmVmMyRib3hQcm9wcyA9PT0gdW5kZWZpbmVkID8ge30gOiBfcmVmMyRib3hQcm9wcyxcbiAgICAgIF9yZWYzJG91dGxpZXJQcm9wcyA9IF9yZWYzLm91dGxpZXJQcm9wcyxcbiAgICAgIG91dGxpZXJQcm9wcyA9IF9yZWYzJG91dGxpZXJQcm9wcyA9PT0gdW5kZWZpbmVkID8ge30gOiBfcmVmMyRvdXRsaWVyUHJvcHMsXG4gICAgICBfcmVmMyRjb250YWluZXIgPSBfcmVmMy5jb250YWluZXIsXG4gICAgICBjb250YWluZXIgPSBfcmVmMyRjb250YWluZXIgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZjMkY29udGFpbmVyLFxuICAgICAgX3JlZjMkY29udGFpbmVyUHJvcHMgPSBfcmVmMy5jb250YWluZXJQcm9wcyxcbiAgICAgIGNvbnRhaW5lclByb3BzID0gX3JlZjMkY29udGFpbmVyUHJvcHMgPT09IHVuZGVmaW5lZCA/IHt9IDogX3JlZjMkY29udGFpbmVyUHJvcHMsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMywgWydsZWZ0JywgJ3RvcCcsICdjbGFzc05hbWUnLCAnZGF0YScsICdtYXgnLCAnbWluJywgJ2ZpcnN0UXVhcnRpbGUnLCAndGhpcmRRdWFydGlsZScsICdtZWRpYW4nLCAnYm94V2lkdGgnLCAnZmlsbCcsICdmaWxsT3BhY2l0eScsICdzdHJva2UnLCAnc3Ryb2tlV2lkdGgnLCAncngnLCAncnknLCAndmFsdWVTY2FsZScsICdvdXRsaWVycycsICdob3Jpem9udGFsJywgJ21lZGlhblByb3BzJywgJ21heFByb3BzJywgJ21pblByb3BzJywgJ2JveFByb3BzJywgJ291dGxpZXJQcm9wcycsICdjb250YWluZXInLCAnY29udGFpbmVyUHJvcHMnXSk7XG5cbiAgdmFyIG9mZnNldCA9IGhvcml6b250YWwgPyB0b3AgOiBsZWZ0O1xuICB2YXIgY2VudGVyID0gb2Zmc2V0ICsgYm94V2lkdGggLyAyO1xuXG4gIHZhciBtYXhMaW5lUG9zID0gQXJyYXkoNCkuZmlsbCgwKTtcbiAgdmFyIG1heFRvQm94TGluZVBvcyA9IEFycmF5KDQpLmZpbGwoMCk7XG4gIHZhciBib3hQb3MgPSBBcnJheSg0KS5maWxsKDApO1xuICB2YXIgbWVkaWFuTGluZVBvcyA9IEFycmF5KDQpLmZpbGwoMCk7XG4gIHZhciBtaW5Ub0JveExpbmVQb3MgPSBBcnJheSg0KS5maWxsKDApO1xuICB2YXIgbWluTGluZVBvcyA9IEFycmF5KDQpLmZpbGwoMCk7XG4gIHZhciBjb250YWluZXJQb3MgPSBBcnJheSg0KS5maWxsKDApO1xuXG4gIC8vIGFsbCBvZiB0aGVzZSBhcmUgW3gwLCB5MCwgeDEsIHkxXVxuICBtYXhMaW5lUG9zWzBdID0gY2VudGVyIC0gYm94V2lkdGggLyA0O1xuICBtYXhMaW5lUG9zWzFdID0gdmFsdWVTY2FsZShtYXgpO1xuICBtYXhMaW5lUG9zWzJdID0gY2VudGVyICsgYm94V2lkdGggLyA0O1xuICBtYXhMaW5lUG9zWzNdID0gdmFsdWVTY2FsZShtYXgpO1xuXG4gIG1heFRvQm94TGluZVBvc1swXSA9IGNlbnRlcjtcbiAgbWF4VG9Cb3hMaW5lUG9zWzFdID0gdmFsdWVTY2FsZShtYXgpO1xuICBtYXhUb0JveExpbmVQb3NbMl0gPSBjZW50ZXI7XG4gIG1heFRvQm94TGluZVBvc1szXSA9IHZhbHVlU2NhbGUodGhpcmRRdWFydGlsZSk7XG5cbiAgYm94UG9zWzBdID0gb2Zmc2V0O1xuICBib3hQb3NbMV0gPSB2YWx1ZVNjYWxlKHRoaXJkUXVhcnRpbGUpO1xuICBib3hQb3NbMl0gPSBib3hXaWR0aDtcbiAgYm94UG9zWzNdID0gTWF0aC5hYnModmFsdWVTY2FsZSh0aGlyZFF1YXJ0aWxlKSAtIHZhbHVlU2NhbGUoZmlyc3RRdWFydGlsZSkpO1xuXG4gIG1lZGlhbkxpbmVQb3NbMF0gPSBvZmZzZXQ7XG4gIG1lZGlhbkxpbmVQb3NbMV0gPSB2YWx1ZVNjYWxlKG1lZGlhbik7XG4gIG1lZGlhbkxpbmVQb3NbMl0gPSBvZmZzZXQgKyBib3hXaWR0aDtcbiAgbWVkaWFuTGluZVBvc1szXSA9IHZhbHVlU2NhbGUobWVkaWFuKTtcblxuICBtaW5Ub0JveExpbmVQb3NbMF0gPSBjZW50ZXI7XG4gIG1pblRvQm94TGluZVBvc1sxXSA9IHZhbHVlU2NhbGUoZmlyc3RRdWFydGlsZSk7XG4gIG1pblRvQm94TGluZVBvc1syXSA9IGNlbnRlcjtcbiAgbWluVG9Cb3hMaW5lUG9zWzNdID0gdmFsdWVTY2FsZShtaW4pO1xuXG4gIG1pbkxpbmVQb3NbMF0gPSBjZW50ZXIgLSBib3hXaWR0aCAvIDQ7XG4gIG1pbkxpbmVQb3NbMV0gPSB2YWx1ZVNjYWxlKG1pbik7XG4gIG1pbkxpbmVQb3NbMl0gPSBjZW50ZXIgKyBib3hXaWR0aCAvIDQ7XG4gIG1pbkxpbmVQb3NbM10gPSB2YWx1ZVNjYWxlKG1pbik7XG5cbiAgdmFyIHZhbHVlUmFuZ2UgPSB2YWx1ZVNjYWxlLnJhbmdlKCk7XG4gIGNvbnRhaW5lclBvc1swXSA9IGJveFBvc1swXTtcbiAgY29udGFpbmVyUG9zWzFdID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgdG9Db25zdW1hYmxlQXJyYXkodmFsdWVSYW5nZSkpO1xuICBjb250YWluZXJQb3NbMl0gPSBib3hQb3NbMl07XG4gIGNvbnRhaW5lclBvc1szXSA9IE1hdGguYWJzKHZhbHVlUmFuZ2VbMF0gLSB2YWx1ZVJhbmdlWzFdKTtcblxuICBpZiAoaG9yaXpvbnRhbCkge1xuICAgIG1heExpbmVQb3MgPSB2ZXJ0aWNhbFRvSG9yaXpvbnRhbChtYXhMaW5lUG9zKTtcbiAgICBtYXhUb0JveExpbmVQb3MgPSB2ZXJ0aWNhbFRvSG9yaXpvbnRhbChtYXhUb0JveExpbmVQb3MpO1xuICAgIGJveFBvcyA9IHZlcnRpY2FsVG9Ib3Jpem9udGFsKGJveFBvcyk7XG4gICAgYm94UG9zWzBdID0gdmFsdWVTY2FsZShmaXJzdFF1YXJ0aWxlKTtcbiAgICBtZWRpYW5MaW5lUG9zID0gdmVydGljYWxUb0hvcml6b250YWwobWVkaWFuTGluZVBvcyk7XG4gICAgbWluVG9Cb3hMaW5lUG9zID0gdmVydGljYWxUb0hvcml6b250YWwobWluVG9Cb3hMaW5lUG9zKTtcbiAgICBtaW5MaW5lUG9zID0gdmVydGljYWxUb0hvcml6b250YWwobWluTGluZVBvcyk7XG4gICAgY29udGFpbmVyUG9zID0gdmVydGljYWxUb0hvcml6b250YWwoY29udGFpbmVyUG9zKTtcbiAgICBjb250YWluZXJQb3NbMF0gPSBNYXRoLm1pbi5hcHBseShNYXRoLCB0b0NvbnN1bWFibGVBcnJheSh2YWx1ZVJhbmdlKSk7XG4gIH1cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgR3JvdXAsXG4gICAgeyBjbGFzc05hbWU6IGNsYXNzbmFtZXMoJ3Z4LWJveHBsb3QnLCBjbGFzc05hbWUpIH0sXG4gICAgb3V0bGllcnMubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICB2YXIgY3ggPSBob3Jpem9udGFsID8gdmFsdWVTY2FsZShkKSA6IGNlbnRlcjtcbiAgICAgIHZhciBjeSA9IGhvcml6b250YWwgPyBjZW50ZXIgOiB2YWx1ZVNjYWxlKGQpO1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2NpcmNsZScsIF9leHRlbmRzKHtcbiAgICAgICAga2V5OiBpLFxuICAgICAgICBjbGFzc05hbWU6ICd2eC1ib3hwbG90LW91dGxpZXInLFxuICAgICAgICBjeDogY3gsXG4gICAgICAgIGN5OiBjeSxcbiAgICAgICAgc3Ryb2tlOiBzdHJva2UsXG4gICAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgICBmaWxsOiBmaWxsLFxuICAgICAgICBmaWxsT3BhY2l0eTogZmlsbE9wYWNpdHksXG4gICAgICAgIHI6ICc0J1xuICAgICAgfSwgYWRkaXRpb25hbFByb3BzKG91dGxpZXJQcm9wcywge1xuICAgICAgICBkYXRhOiBkLFxuICAgICAgICBjeDogY3gsXG4gICAgICAgIGN5OiBjeVxuICAgICAgfSkpKTtcbiAgICB9KSxcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdsaW5lJywgX2V4dGVuZHMoe1xuICAgICAgY2xhc3NOYW1lOiAndngtYm94cGxvdC1tYXgnLFxuICAgICAgeDE6IG1heExpbmVQb3NbMF0sXG4gICAgICB5MTogbWF4TGluZVBvc1sxXSxcbiAgICAgIHgyOiBtYXhMaW5lUG9zWzJdLFxuICAgICAgeTI6IG1heExpbmVQb3NbM10sXG4gICAgICBzdHJva2U6IHN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aFxuICAgIH0sIGFkZGl0aW9uYWxQcm9wcyhtYXhQcm9wcywge1xuICAgICAgZGF0YTogZGF0YSxcbiAgICAgIG1heDogbWF4LFxuICAgICAgeDE6IG1heExpbmVQb3NbMF0sXG4gICAgICB4MjogbWF4TGluZVBvc1syXSxcbiAgICAgIHkxOiBtYXhMaW5lUG9zWzFdLFxuICAgICAgeTI6IG1heExpbmVQb3NbM11cbiAgICB9KSkpLFxuICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2xpbmUnLCB7XG4gICAgICB4MTogbWF4VG9Cb3hMaW5lUG9zWzBdLFxuICAgICAgeTE6IG1heFRvQm94TGluZVBvc1sxXSxcbiAgICAgIHgyOiBtYXhUb0JveExpbmVQb3NbMl0sXG4gICAgICB5MjogbWF4VG9Cb3hMaW5lUG9zWzNdLFxuICAgICAgc3Ryb2tlOiBzdHJva2UsXG4gICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGhcbiAgICB9KSxcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdyZWN0JywgX2V4dGVuZHMoe1xuICAgICAgY2xhc3NOYW1lOiAndngtYm94cGxvdC1ib3gnLFxuICAgICAgeDogYm94UG9zWzBdLFxuICAgICAgeTogYm94UG9zWzFdLFxuICAgICAgd2lkdGg6IGJveFBvc1syXSxcbiAgICAgIGhlaWdodDogYm94UG9zWzNdLFxuICAgICAgc3Ryb2tlOiBzdHJva2UsXG4gICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgICBmaWxsOiBmaWxsLFxuICAgICAgZmlsbE9wYWNpdHk6IGZpbGxPcGFjaXR5LFxuICAgICAgcng6IHJ4LFxuICAgICAgcnk6IHJ5XG4gICAgfSwgYWRkaXRpb25hbFByb3BzKGJveFByb3BzLCB7XG4gICAgICBkYXRhOiBkYXRhLFxuICAgICAgaGVpZ2h0OiBib3hQb3NbM10sXG4gICAgICBtZWRpYW46IG1lZGlhbixcbiAgICAgIGZpcnN0UXVhcnRpbGU6IGZpcnN0UXVhcnRpbGUsXG4gICAgICB0aGlyZFF1YXJ0aWxlOiB0aGlyZFF1YXJ0aWxlLFxuICAgICAgbWluOiBtaW4sXG4gICAgICBtYXg6IG1heCxcbiAgICAgIHgxOiBib3hQb3NbMF0sXG4gICAgICB4MjogYm94UG9zWzBdICsgYm94UG9zWzJdLFxuICAgICAgeTE6IGJveFBvc1sxXSxcbiAgICAgIHkyOiBib3hQb3NbMV0gKyBib3hQb3NbM11cbiAgICB9KSkpLFxuICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2xpbmUnLCBfZXh0ZW5kcyh7XG4gICAgICBjbGFzc05hbWU6ICd2eC1ib3hwbG90LW1lZGlhbicsXG4gICAgICB4MTogbWVkaWFuTGluZVBvc1swXSxcbiAgICAgIHkxOiBtZWRpYW5MaW5lUG9zWzFdLFxuICAgICAgeDI6IG1lZGlhbkxpbmVQb3NbMl0sXG4gICAgICB5MjogbWVkaWFuTGluZVBvc1szXSxcbiAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoXG4gICAgfSwgYWRkaXRpb25hbFByb3BzKG1lZGlhblByb3BzLCB7XG4gICAgICBkYXRhOiBkYXRhLFxuICAgICAgbWVkaWFuOiBtZWRpYW4sXG4gICAgICB4MTogbWVkaWFuTGluZVBvc1swXSxcbiAgICAgIHgyOiBtZWRpYW5MaW5lUG9zWzJdLFxuICAgICAgeTE6IG1lZGlhbkxpbmVQb3NbMV0sXG4gICAgICB5MjogbWVkaWFuTGluZVBvc1szXVxuICAgIH0pKSksXG4gICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnbGluZScsIHtcbiAgICAgIHgxOiBtaW5Ub0JveExpbmVQb3NbMF0sXG4gICAgICB5MTogbWluVG9Cb3hMaW5lUG9zWzFdLFxuICAgICAgeDI6IG1pblRvQm94TGluZVBvc1syXSxcbiAgICAgIHkyOiBtaW5Ub0JveExpbmVQb3NbM10sXG4gICAgICBzdHJva2U6IHN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aFxuICAgIH0pLFxuICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2xpbmUnLCBfZXh0ZW5kcyh7XG4gICAgICBjbGFzc05hbWU6ICd2eC1ib3hwbG90LW1pbicsXG4gICAgICB4MTogbWluTGluZVBvc1swXSxcbiAgICAgIHkxOiBtaW5MaW5lUG9zWzFdLFxuICAgICAgeDI6IG1pbkxpbmVQb3NbMl0sXG4gICAgICB5MjogbWluTGluZVBvc1szXSxcbiAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoXG4gICAgfSwgYWRkaXRpb25hbFByb3BzKG1pblByb3BzLCB7XG4gICAgICBkYXRhOiBkYXRhLFxuICAgICAgbWluOiBtaW4sXG4gICAgICB4MTogbWluTGluZVBvc1swXSxcbiAgICAgIHgyOiBtaW5MaW5lUG9zWzJdLFxuICAgICAgeTE6IG1pbkxpbmVQb3NbMV0sXG4gICAgICB5MjogbWluTGluZVBvc1szXVxuICAgIH0pKSksXG4gICAgY29udGFpbmVyICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3JlY3QnLCBfZXh0ZW5kcyh7XG4gICAgICB4OiBjb250YWluZXJQb3NbMF0sXG4gICAgICB5OiBjb250YWluZXJQb3NbMV0sXG4gICAgICB3aWR0aDogY29udGFpbmVyUG9zWzJdLFxuICAgICAgaGVpZ2h0OiBjb250YWluZXJQb3NbM10sXG4gICAgICBmaWxsT3BhY2l0eTogJzAnXG4gICAgfSwgYWRkaXRpb25hbFByb3BzKGNvbnRhaW5lclByb3BzLCB7XG4gICAgICBkYXRhOiBkYXRhLFxuICAgICAgeDE6IGNvbnRhaW5lclBvc1swXSxcbiAgICAgIHgyOiBjb250YWluZXJQb3NbMF0gKyBjb250YWluZXJQb3NbMl0sXG4gICAgICB5MTogY29udGFpbmVyUG9zWzFdLFxuICAgICAgeTI6IGNvbnRhaW5lclBvc1sxXSArIGNvbnRhaW5lclBvc1szXSxcbiAgICAgIG1lZGlhbjogbWVkaWFuLFxuICAgICAgbWF4OiBtYXgsXG4gICAgICBtaW46IG1pbixcbiAgICAgIHRoaXJkUXVhcnRpbGU6IHRoaXJkUXVhcnRpbGUsXG4gICAgICBmaXJzdFF1YXJ0aWxlOiBmaXJzdFF1YXJ0aWxlXG4gICAgfSkpKVxuICApO1xufVxuXG5mdW5jdGlvbiBWaW9saW5QbG90KF9yZWYpIHtcbiAgdmFyIF9yZWYkbGVmdCA9IF9yZWYubGVmdCxcbiAgICAgIGxlZnQgPSBfcmVmJGxlZnQgPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmJGxlZnQsXG4gICAgICBfcmVmJHRvcCA9IF9yZWYudG9wLFxuICAgICAgdG9wID0gX3JlZiR0b3AgPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmJHRvcCxcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgYmluRGF0YSA9IF9yZWYuYmluRGF0YSxcbiAgICAgIF9yZWYkc3Ryb2tlID0gX3JlZi5zdHJva2UsXG4gICAgICBzdHJva2UgPSBfcmVmJHN0cm9rZSA9PT0gdW5kZWZpbmVkID8gJ2JsYWNrJyA6IF9yZWYkc3Ryb2tlLFxuICAgICAgX3JlZiRmaWxsID0gX3JlZi5maWxsLFxuICAgICAgZmlsbCA9IF9yZWYkZmlsbCA9PT0gdW5kZWZpbmVkID8gJ3JnYmEoMCwwLDAsMC4zKScgOiBfcmVmJGZpbGwsXG4gICAgICBvcGFjaXR5ID0gX3JlZi5vcGFjaXR5LFxuICAgICAgc3Ryb2tlV2lkdGggPSBfcmVmLnN0cm9rZVdpZHRoLFxuICAgICAgd2lkdGggPSBfcmVmLndpZHRoLFxuICAgICAgdmFsdWVTY2FsZSA9IF9yZWYudmFsdWVTY2FsZSxcbiAgICAgIHN0cm9rZURhc2hhcnJheSA9IF9yZWYuc3Ryb2tlRGFzaGFycmF5LFxuICAgICAgaG9yaXpvbnRhbCA9IF9yZWYuaG9yaXpvbnRhbCxcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnbGVmdCcsICd0b3AnLCAnY2xhc3NOYW1lJywgJ2JpbkRhdGEnLCAnc3Ryb2tlJywgJ2ZpbGwnLCAnb3BhY2l0eScsICdzdHJva2VXaWR0aCcsICd3aWR0aCcsICd2YWx1ZVNjYWxlJywgJ3N0cm9rZURhc2hhcnJheScsICdob3Jpem9udGFsJ10pO1xuXG4gIHZhciBjZW50ZXIgPSAoaG9yaXpvbnRhbCA/IHRvcCA6IGxlZnQpICsgd2lkdGggLyAyO1xuICB2YXIgYmluQ291bnRzID0gYmluRGF0YS5tYXAoZnVuY3Rpb24gKGJpbikge1xuICAgIHJldHVybiBiaW4uY291bnQ7XG4gIH0pO1xuICB2YXIgd2lkdGhTY2FsZSA9IHNjYWxlTGluZWFyKHtcbiAgICByYW5nZVJvdW5kOiBbMCwgd2lkdGggLyAyXSxcbiAgICBkb21haW46IFswLCBNYXRoLm1heC5hcHBseShNYXRoLCB0b0NvbnN1bWFibGVBcnJheShiaW5Db3VudHMpKV1cbiAgfSk7XG5cbiAgdmFyIHBhdGggPSAnJztcbiAgaWYgKGhvcml6b250YWwpIHtcbiAgICB2YXIgdG9wQ3VydmUgPSBsaW5lKCkueChmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIHZhbHVlU2NhbGUoZC52YWx1ZSk7XG4gICAgfSkueShmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIGNlbnRlciAtIHdpZHRoU2NhbGUoZC5jb3VudCk7XG4gICAgfSkuY3VydmUoY3VydmVDYXJkaW5hbCk7XG5cbiAgICB2YXIgYm90dG9tQ3VydmUgPSBsaW5lKCkueChmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIHZhbHVlU2NhbGUoZC52YWx1ZSk7XG4gICAgfSkueShmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIGNlbnRlciArIHdpZHRoU2NhbGUoZC5jb3VudCk7XG4gICAgfSkuY3VydmUoY3VydmVDYXJkaW5hbCk7XG5cbiAgICB2YXIgdG9wQ3VydmVQYXRoID0gdG9wQ3VydmUoYmluRGF0YSk7XG4gICAgdmFyIGJvdHRvbUN1cnZlUGF0aCA9IGJvdHRvbUN1cnZlKFtdLmNvbmNhdCh0b0NvbnN1bWFibGVBcnJheShiaW5EYXRhKSkucmV2ZXJzZSgpKTtcbiAgICBwYXRoID0gdG9wQ3VydmVQYXRoICsgJyAnICsgYm90dG9tQ3VydmVQYXRoLnJlcGxhY2UoJ00nLCAnTCcpICsgJyBaJztcbiAgfSBlbHNlIHtcbiAgICB2YXIgcmlnaHRDdXJ2ZSA9IGxpbmUoKS54KGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gY2VudGVyICsgd2lkdGhTY2FsZShkLmNvdW50KTtcbiAgICB9KS55KGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gdmFsdWVTY2FsZShkLnZhbHVlKTtcbiAgICB9KS5jdXJ2ZShjdXJ2ZUNhcmRpbmFsKTtcblxuICAgIHZhciBsZWZ0Q3VydmUgPSBsaW5lKCkueChmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIGNlbnRlciAtIHdpZHRoU2NhbGUoZC5jb3VudCk7XG4gICAgfSkueShmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIHZhbHVlU2NhbGUoZC52YWx1ZSk7XG4gICAgfSkuY3VydmUoY3VydmVDYXJkaW5hbCk7XG5cbiAgICB2YXIgcmlnaHRDdXJ2ZVBhdGggPSByaWdodEN1cnZlKGJpbkRhdGEpO1xuICAgIHZhciBsZWZ0Q3VydmVQYXRoID0gbGVmdEN1cnZlKFtdLmNvbmNhdCh0b0NvbnN1bWFibGVBcnJheShiaW5EYXRhKSkucmV2ZXJzZSgpKTtcbiAgICBwYXRoID0gcmlnaHRDdXJ2ZVBhdGggKyAnICcgKyBsZWZ0Q3VydmVQYXRoLnJlcGxhY2UoJ00nLCAnTCcpICsgJyBaJztcbiAgfVxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICBHcm91cCxcbiAgICB7IGNsYXNzTmFtZTogY2xhc3NuYW1lcygndngtdmlvbGluJywgY2xhc3NOYW1lKSB9LFxuICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCBfZXh0ZW5kcyh7XG4gICAgICBkOiBwYXRoLFxuICAgICAgc3Ryb2tlOiBzdHJva2UsXG4gICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgICBzdHJva2VEYXNoYXJyYXk6IHN0cm9rZURhc2hhcnJheSxcbiAgICAgIGZpbGw6IGZpbGwsXG4gICAgICBmaWxsT3BhY2l0eTogb3BhY2l0eVxuICAgIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGJpbkRhdGEpKSlcbiAgKTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZVN0YXRzIChudW1lcmljYWxBcnJheSkge1xuICB2YXIgcG9pbnRzID0gW10uY29uY2F0KHRvQ29uc3VtYWJsZUFycmF5KG51bWVyaWNhbEFycmF5KSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhIC0gYjtcbiAgfSk7XG4gIHZhciBzYW1wbGVTaXplID0gcG9pbnRzLmxlbmd0aDtcbiAgdmFyIGZpcnN0UXVhcnRpbGUgPSBwb2ludHNbTWF0aC5yb3VuZChzYW1wbGVTaXplIC8gNCldO1xuICB2YXIgdGhpcmRRdWFydGlsZSA9IHBvaW50c1tNYXRoLnJvdW5kKDMgKiBzYW1wbGVTaXplIC8gNCldO1xuICB2YXIgSVFSID0gdGhpcmRRdWFydGlsZSAtIGZpcnN0UXVhcnRpbGU7XG5cbiAgdmFyIG1pbiA9IGZpcnN0UXVhcnRpbGUgLSAxLjUgKiBJUVI7XG4gIHZhciBtYXggPSB0aGlyZFF1YXJ0aWxlICsgMS41ICogSVFSO1xuXG4gIHZhciBvdXRsaWVycyA9IHBvaW50cy5maWx0ZXIoZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gcCA8IG1pbiB8fCBwID4gbWF4O1xuICB9KTtcbiAgdmFyIGJpbldpZHRoID0gMiAqIElRUiAqIE1hdGgucG93KHNhbXBsZVNpemUgLSBvdXRsaWVycy5sZW5ndGgsIC0xIC8gMyk7XG4gIHZhciBiaW5OdW0gPSBNYXRoLnJvdW5kKChtYXggLSBtaW4pIC8gYmluV2lkdGgpO1xuICB2YXIgYWN0dWFsQmluV2lkdGggPSAobWF4IC0gbWluKSAvIGJpbk51bTtcblxuICB2YXIgYmlucyA9IEFycmF5KGJpbk51bSArIDIpLmZpbGwoMCk7XG4gIHZhciB2YWx1ZXMgPSBBcnJheShiaW5OdW0gKyAyKS5maWxsKG1pbik7XG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPD0gYmluTnVtOyBpICs9IDEpIHtcbiAgICB2YWx1ZXNbaV0gKz0gYWN0dWFsQmluV2lkdGggKiAoaSAtIDAuNSk7XG4gIH1cblxuICB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdID0gbWF4O1xuXG4gIHBvaW50cy5maWx0ZXIoZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gcCA+PSBtaW4gJiYgcCA8PSBtYXg7XG4gIH0pLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICBiaW5zW01hdGguZmxvb3IoKHAgLSBtaW4pIC8gYWN0dWFsQmluV2lkdGgpICsgMV0gKz0gMTtcbiAgfSk7XG5cbiAgdmFyIGJpbkRhdGEgPSB2YWx1ZXMubWFwKGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiB2LFxuICAgICAgY291bnQ6IGJpbnNbaV1cbiAgICB9O1xuICB9KTtcblxuICB2YXIgYm94UGxvdCA9IHtcbiAgICBtaW46IG1pbixcbiAgICBmaXJzdFF1YXJ0aWxlOiBmaXJzdFF1YXJ0aWxlLFxuICAgIG1lZGlhbjogcG9pbnRzW01hdGgucm91bmQoc2FtcGxlU2l6ZSAvIDIpXSxcbiAgICB0aGlyZFF1YXJ0aWxlOiB0aGlyZFF1YXJ0aWxlLFxuICAgIG1heDogbWF4LFxuICAgIG91dGxpZXJzOiBvdXRsaWVyc1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgYm94UGxvdDogYm94UGxvdCxcbiAgICBiaW5EYXRhOiBiaW5EYXRhXG4gIH07XG59XG5cbmV4cG9ydCB7IEJveFBsb3QsIFZpb2xpblBsb3QsIGNvbXB1dGVTdGF0cyB9O1xuIiwiZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmltcG9ydCB7IEJveFBsb3QgfSBmcm9tICdAdngvc3RhdHMnO1xuaW1wb3J0IHsgRm9jdXNCbHVySGFuZGxlciB9IGZyb20gJ0BkYXRhLXVpL3NoYXJlZCc7XG5pbXBvcnQgeyBHcm91cCB9IGZyb20gJ0B2eC9ncm91cCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNvbG9yIGFzIHRoZW1lQ29sb3JzIH0gZnJvbSAnQGRhdGEtdWkvdGhlbWUnO1xuaW1wb3J0IHsgY2FsbE9yVmFsdWUsIGlzRGVmaW5lZCB9IGZyb20gJy4uL3V0aWxzL2NoYXJ0VXRpbHMnO1xuaW1wb3J0IHsgYm94UGxvdFNlcmllc0RhdGFTaGFwZSB9IGZyb20gJy4uL3V0aWxzL3Byb3BTaGFwZXMnO1xuaW1wb3J0IHNoYXJlZFNlcmllc1Byb3BzIGZyb20gJy4uL3V0aWxzL3NoYXJlZFNlcmllc1Byb3BzJztcblxudmFyIHByb3BUeXBlcyA9IF9leHRlbmRzKHt9LCBzaGFyZWRTZXJpZXNQcm9wcywge1xuICBjb250YWluZXJFdmVudHM6IFByb3BUeXBlcy5ib29sLFxuICBkYXRhOiBib3hQbG90U2VyaWVzRGF0YVNoYXBlLmlzUmVxdWlyZWQsXG4gIGZpbGw6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMuc3RyaW5nXSksXG4gIGhvcml6b250YWw6IFByb3BUeXBlcy5ib29sLFxuICBzdHJva2U6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMuc3RyaW5nXSksXG4gIHN0cm9rZVdpZHRoOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm51bWJlcl0pLFxuICBmaWxsT3BhY2l0eTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgd2lkdGhSYXRpbzogUHJvcFR5cGVzLm51bWJlcixcbiAgY29udGFpbmVyUHJvcHM6IFByb3BUeXBlcy5vYmplY3QsXG4gIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVhY3QvZm9yYmlkLXByb3AtdHlwZXNcbiAgb3V0bGllclByb3BzOiBQcm9wVHlwZXMub2JqZWN0LFxuICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlYWN0L2ZvcmJpZC1wcm9wLXR5cGVzXG4gIGJveFByb3BzOiBQcm9wVHlwZXMub2JqZWN0LFxuICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlYWN0L2ZvcmJpZC1wcm9wLXR5cGVzXG4gIG1pblByb3BzOiBQcm9wVHlwZXMub2JqZWN0LFxuICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlYWN0L2ZvcmJpZC1wcm9wLXR5cGVzXG4gIG1heFByb3BzOiBQcm9wVHlwZXMub2JqZWN0LFxuICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlYWN0L2ZvcmJpZC1wcm9wLXR5cGVzXG4gIG1lZGlhblByb3BzOiBQcm9wVHlwZXMub2JqZWN0IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVhY3QvZm9yYmlkLXByb3AtdHlwZXNcblxufSk7XG5cbnZhciBkZWZhdWx0UHJvcHMgPSB7XG4gIGNvbnRhaW5lckV2ZW50czogdHJ1ZSxcbiAgc3Ryb2tlOiB0aGVtZUNvbG9ycy5kYXJrR3JheSxcbiAgc3Ryb2tlV2lkdGg6IDIsXG4gIGZpbGw6IHRoZW1lQ29sb3JzLmRlZmF1bHQsXG4gIGZpbGxPcGFjaXR5OiAxLFxuICBob3Jpem9udGFsOiBmYWxzZSxcbiAgd2lkdGhSYXRpbzogMSxcbiAgY29udGFpbmVyUHJvcHM6IG51bGwsXG4gIG91dGxpZXJQcm9wczogbnVsbCxcbiAgYm94UHJvcHM6IG51bGwsXG4gIG1pblByb3BzOiBudWxsLFxuICBtYXhQcm9wczogbnVsbCxcbiAgbWVkaWFuUHJvcHM6IG51bGxcbn07XG52YXIgTUFYX0JPWF9XSURUSCA9IDUwO1xuXG52YXIgeCA9IGZ1bmN0aW9uIHgoZCkge1xuICByZXR1cm4gZC54O1xufTtcblxudmFyIHkgPSBmdW5jdGlvbiB5KGQpIHtcbiAgcmV0dXJuIGQueTtcbn07XG5cbnZhciBtaW4gPSBmdW5jdGlvbiBtaW4oZCkge1xuICByZXR1cm4gZC5taW47XG59O1xuXG52YXIgbWF4ID0gZnVuY3Rpb24gbWF4KGQpIHtcbiAgcmV0dXJuIGQubWF4O1xufTtcblxudmFyIG1lZGlhbiA9IGZ1bmN0aW9uIG1lZGlhbihkKSB7XG4gIHJldHVybiBkLm1lZGlhbjtcbn07XG5cbnZhciBmaXJzdFF1YXJ0aWxlID0gZnVuY3Rpb24gZmlyc3RRdWFydGlsZShkKSB7XG4gIHJldHVybiBkLmZpcnN0UXVhcnRpbGU7XG59O1xuXG52YXIgdGhpcmRRdWFydGlsZSA9IGZ1bmN0aW9uIHRoaXJkUXVhcnRpbGUoZCkge1xuICByZXR1cm4gZC50aGlyZFF1YXJ0aWxlO1xufTtcblxudmFyIG91dGxpZXJzID0gZnVuY3Rpb24gb3V0bGllcnMoZCkge1xuICByZXR1cm4gZC5vdXRsaWVycyB8fCBbXTtcbn07XG5cbnZhciBCb3hQbG90U2VyaWVzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUmVhY3QkUHVyZUNvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShCb3hQbG90U2VyaWVzLCBfUmVhY3QkUHVyZUNvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gQm94UGxvdFNlcmllcygpIHtcbiAgICByZXR1cm4gX1JlYWN0JFB1cmVDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEJveFBsb3RTZXJpZXMucHJvdG90eXBlO1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgY29udGFpbmVyRXZlbnRzID0gX3RoaXMkcHJvcHMuY29udGFpbmVyRXZlbnRzLFxuICAgICAgICBkYXRhID0gX3RoaXMkcHJvcHMuZGF0YSxcbiAgICAgICAgZmlsbCA9IF90aGlzJHByb3BzLmZpbGwsXG4gICAgICAgIHN0cm9rZSA9IF90aGlzJHByb3BzLnN0cm9rZSxcbiAgICAgICAgc3Ryb2tlV2lkdGggPSBfdGhpcyRwcm9wcy5zdHJva2VXaWR0aCxcbiAgICAgICAgeFNjYWxlID0gX3RoaXMkcHJvcHMueFNjYWxlLFxuICAgICAgICB5U2NhbGUgPSBfdGhpcyRwcm9wcy55U2NhbGUsXG4gICAgICAgIGhvcml6b250YWwgPSBfdGhpcyRwcm9wcy5ob3Jpem9udGFsLFxuICAgICAgICB3aWR0aFJhdGlvID0gX3RoaXMkcHJvcHMud2lkdGhSYXRpbyxcbiAgICAgICAgZmlsbE9wYWNpdHkgPSBfdGhpcyRwcm9wcy5maWxsT3BhY2l0eSxcbiAgICAgICAgY29udGFpbmVyUHJvcHMgPSBfdGhpcyRwcm9wcy5jb250YWluZXJQcm9wcyxcbiAgICAgICAgb3V0bGllclByb3BzID0gX3RoaXMkcHJvcHMub3V0bGllclByb3BzLFxuICAgICAgICBib3hQcm9wcyA9IF90aGlzJHByb3BzLmJveFByb3BzLFxuICAgICAgICBtaW5Qcm9wcyA9IF90aGlzJHByb3BzLm1pblByb3BzLFxuICAgICAgICBtYXhQcm9wcyA9IF90aGlzJHByb3BzLm1heFByb3BzLFxuICAgICAgICBtZWRpYW5Qcm9wcyA9IF90aGlzJHByb3BzLm1lZGlhblByb3BzLFxuICAgICAgICBvbk1vdXNlTW92ZSA9IF90aGlzJHByb3BzLm9uTW91c2VNb3ZlLFxuICAgICAgICBvbk1vdXNlTGVhdmUgPSBfdGhpcyRwcm9wcy5vbk1vdXNlTGVhdmUsXG4gICAgICAgIGRpc2FibGVNb3VzZUV2ZW50cyA9IF90aGlzJHByb3BzLmRpc2FibGVNb3VzZUV2ZW50cyxcbiAgICAgICAgb25DbGljayA9IF90aGlzJHByb3BzLm9uQ2xpY2s7XG4gICAgaWYgKCF4U2NhbGUgfHwgIXlTY2FsZSkgcmV0dXJuIG51bGw7XG4gICAgdmFyIG9mZnNldFNjYWxlID0gaG9yaXpvbnRhbCA/IHlTY2FsZSA6IHhTY2FsZTtcbiAgICB2YXIgb2Zmc2V0VmFsdWUgPSBob3Jpem9udGFsID8geSA6IHg7XG4gICAgdmFyIHZhbHVlU2NhbGUgPSBob3Jpem9udGFsID8geFNjYWxlIDogeVNjYWxlO1xuICAgIHZhciBib3hXaWR0aCA9IG9mZnNldFNjYWxlLmJhbmR3aWR0aCgpO1xuICAgIHZhciBhY3R1YWxXaWR0aCA9IE1hdGgubWluKE1BWF9CT1hfV0lEVEgsIGJveFdpZHRoKTtcbiAgICB2YXIgb2Zmc2V0ID0gKG9mZnNldFNjYWxlLm9mZnNldCB8fCAwKSAtIChib3hXaWR0aCAtIGFjdHVhbFdpZHRoKSAvIDI7XG4gICAgdmFyIG9mZnNldFByb3BOYW1lID0gaG9yaXpvbnRhbCA/ICd0b3AnIDogJ2xlZnQnO1xuXG4gICAgdmFyIG9mZnNldFByb3AgPSBmdW5jdGlvbiBvZmZzZXRQcm9wKGQpIHtcbiAgICAgIHZhciBfcmVmO1xuXG4gICAgICByZXR1cm4gX3JlZiA9IHt9LCBfcmVmW29mZnNldFByb3BOYW1lXSA9IG9mZnNldFNjYWxlKG9mZnNldFZhbHVlKGQpKSAtIG9mZnNldCArICgxIC0gd2lkdGhSYXRpbykgLyAyICogYWN0dWFsV2lkdGgsIF9yZWY7XG4gICAgfTtcblxuICAgIHZhciBtb3VzZUV2ZW50UHJvcHMgPSBmdW5jdGlvbiBtb3VzZUV2ZW50UHJvcHMoZCwgaSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb25Nb3VzZU1vdmU6IGRpc2FibGVNb3VzZUV2ZW50cyA/IG51bGwgOiBvbk1vdXNlTW92ZSAmJiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgb25Nb3VzZU1vdmUoe1xuICAgICAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICAgIGRhdHVtOiBkLFxuICAgICAgICAgICAgICBpbmRleDogaVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Nb3VzZUxlYXZlOiBkaXNhYmxlTW91c2VFdmVudHMgPyBudWxsIDogb25Nb3VzZUxlYXZlICYmIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gb25Nb3VzZUxlYXZlO1xuICAgICAgICB9LFxuICAgICAgICBvbkNsaWNrOiBkaXNhYmxlTW91c2VFdmVudHMgPyBudWxsIDogb25DbGljayAmJiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgb25DbGljayh7XG4gICAgICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgICAgZGF0dW06IGQsXG4gICAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChHcm91cCwgbnVsbCwgZGF0YS5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgIHZhciBtb3VzZUV2ZW50cyA9IG1vdXNlRXZlbnRQcm9wcyhkLCBpKTtcbiAgICAgIHJldHVybiBpc0RlZmluZWQobWluKGQpKSAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KEZvY3VzQmx1ckhhbmRsZXIsIHtcbiAgICAgICAga2V5OiBvZmZzZXRWYWx1ZShkKSxcbiAgICAgICAgeGxpbmtIcmVmOiBcIiNcIixcbiAgICAgICAgb25CbHVyOiBkaXNhYmxlTW91c2VFdmVudHMgPyBudWxsIDogb25Nb3VzZUxlYXZlLFxuICAgICAgICBvbkZvY3VzOiBkaXNhYmxlTW91c2VFdmVudHMgPyBudWxsIDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgb25Nb3VzZU1vdmUoe1xuICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIGRhdHVtOiBkLFxuICAgICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChCb3hQbG90LCBfZXh0ZW5kcyh7XG4gICAgICAgIG1pbjogbWluKGQpLFxuICAgICAgICBtYXg6IG1heChkKVxuICAgICAgfSwgb2Zmc2V0UHJvcChkKSwge1xuICAgICAgICBmaXJzdFF1YXJ0aWxlOiBmaXJzdFF1YXJ0aWxlKGQpLFxuICAgICAgICB0aGlyZFF1YXJ0aWxlOiB0aGlyZFF1YXJ0aWxlKGQpLFxuICAgICAgICBtZWRpYW46IG1lZGlhbihkKSxcbiAgICAgICAgYm94V2lkdGg6IGFjdHVhbFdpZHRoICogd2lkdGhSYXRpbyxcbiAgICAgICAgb3V0bGllcnM6IG91dGxpZXJzKGQpLFxuICAgICAgICBmaWxsOiBkLmZpbGwgfHwgY2FsbE9yVmFsdWUoZmlsbCwgZCwgaSksXG4gICAgICAgIHN0cm9rZTogZC5zdHJva2UgfHwgY2FsbE9yVmFsdWUoc3Ryb2tlLCBkLCBpKSxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IGQuc3Ryb2tlV2lkdGggfHwgY2FsbE9yVmFsdWUoc3Ryb2tlV2lkdGgsIGQsIGkpLFxuICAgICAgICBmaWxsT3BhY2l0eTogZC5maWxsT3BhY2l0eSB8fCBjYWxsT3JWYWx1ZShmaWxsT3BhY2l0eSwgZCwgaSksXG4gICAgICAgIHZhbHVlU2NhbGU6IHZhbHVlU2NhbGUsXG4gICAgICAgIGhvcml6b250YWw6IGhvcml6b250YWwsXG4gICAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyRXZlbnRzLFxuICAgICAgICBjb250YWluZXJQcm9wczogKGNvbnRhaW5lckV2ZW50cyB8fCBjb250YWluZXJQcm9wcyB8fCB1bmRlZmluZWQpICYmIF9leHRlbmRzKHt9LCBjb250YWluZXJQcm9wcywgY29udGFpbmVyRXZlbnRzICYmIG1vdXNlRXZlbnRzKSxcbiAgICAgICAgb3V0bGllclByb3BzOiAoIWNvbnRhaW5lckV2ZW50cyB8fCBvdXRsaWVyUHJvcHMgfHwgdW5kZWZpbmVkKSAmJiBfZXh0ZW5kcyh7fSwgb3V0bGllclByb3BzLCAhY29udGFpbmVyRXZlbnRzICYmIG1vdXNlRXZlbnRzKSxcbiAgICAgICAgYm94UHJvcHM6ICghY29udGFpbmVyRXZlbnRzIHx8IGJveFByb3BzIHx8IHVuZGVmaW5lZCkgJiYgX2V4dGVuZHMoe30sIGJveFByb3BzLCAhY29udGFpbmVyRXZlbnRzICYmIG1vdXNlRXZlbnRzKSxcbiAgICAgICAgbWluUHJvcHM6ICghY29udGFpbmVyRXZlbnRzIHx8IG1pblByb3BzIHx8IHVuZGVmaW5lZCkgJiYgX2V4dGVuZHMoe30sIG1pblByb3BzLCAhY29udGFpbmVyRXZlbnRzICYmIG1vdXNlRXZlbnRzKSxcbiAgICAgICAgbWF4UHJvcHM6ICghY29udGFpbmVyRXZlbnRzIHx8IG1heFByb3BzIHx8IHVuZGVmaW5lZCkgJiYgX2V4dGVuZHMoe30sIG1heFByb3BzLCAhY29udGFpbmVyRXZlbnRzICYmIG1vdXNlRXZlbnRzKSxcbiAgICAgICAgbWVkaWFuUHJvcHM6ICghY29udGFpbmVyRXZlbnRzIHx8IG1lZGlhblByb3BzIHx8IHVuZGVmaW5lZCkgJiYgX2V4dGVuZHMoe30sIG1lZGlhblByb3BzLCAhY29udGFpbmVyRXZlbnRzICYmIG1vdXNlRXZlbnRzKVxuICAgICAgfSkpKTtcbiAgICB9KSk7XG4gIH07XG5cbiAgcmV0dXJuIEJveFBsb3RTZXJpZXM7XG59KFJlYWN0LlB1cmVDb21wb25lbnQpO1xuXG5leHBvcnQgeyBCb3hQbG90U2VyaWVzIGFzIGRlZmF1bHQgfTtcbkJveFBsb3RTZXJpZXMucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xuQm94UGxvdFNlcmllcy5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5Cb3hQbG90U2VyaWVzLmRpc3BsYXlOYW1lID0gJ0JveFBsb3RTZXJpZXMnOyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBpc0RlZmluZWQgfSBmcm9tICdAc3VwZXJzZXQtdWkvY29yZSc7XG5pbXBvcnQgeyBUb29sdGlwRnJhbWUsIFRvb2x0aXBUYWJsZSB9IGZyb20gJ0BzdXBlcnNldC11aS9jaGFydC1jb21wb3NpdGlvbic7XG5pbXBvcnQgeyBCb3hQbG90RW5jb2RlciB9IGZyb20gJy4vRW5jb2Rlcic7XG5pbXBvcnQgeyBCb3hQbG90RGF0YVJvdyB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEZWZhdWx0VG9vbHRpcFJlbmRlcmVyKHtcbiAgZGF0dW0sXG4gIGNvbG9yLFxuICBlbmNvZGVyLFxufToge1xuICBkYXR1bTogQm94UGxvdERhdGFSb3c7XG4gIGNvbG9yOiBzdHJpbmc7XG4gIGVuY29kZXI6IEJveFBsb3RFbmNvZGVyO1xufSkge1xuICBjb25zdCB7IGxhYmVsLCBtaW4sIG1heCwgbWVkaWFuLCBmaXJzdFF1YXJ0aWxlLCB0aGlyZFF1YXJ0aWxlLCBvdXRsaWVycyB9ID0gZGF0dW07XG4gIGNvbnN0IHsgY2hhbm5lbHMgfSA9IGVuY29kZXI7XG5cbiAgY29uc3QgeyBmb3JtYXRWYWx1ZSB9ID0gY2hhbm5lbHMueTtcblxuICBjb25zdCBkYXRhOiB7IGtleTogc3RyaW5nOyB2YWx1ZUNvbHVtbjogbnVtYmVyIHwgc3RyaW5nIH1bXSA9IFtdO1xuICBpZiAoaXNEZWZpbmVkKG1pbikpIHtcbiAgICBkYXRhLnB1c2goeyBrZXk6ICdNaW4nLCB2YWx1ZUNvbHVtbjogZm9ybWF0VmFsdWUobWluKSB9KTtcbiAgfVxuICBpZiAoaXNEZWZpbmVkKG1heCkpIHtcbiAgICBkYXRhLnB1c2goeyBrZXk6ICdNYXgnLCB2YWx1ZUNvbHVtbjogZm9ybWF0VmFsdWUobWF4KSB9KTtcbiAgfVxuICBpZiAoaXNEZWZpbmVkKG1lZGlhbikpIHtcbiAgICBkYXRhLnB1c2goeyBrZXk6ICdNZWRpYW4nLCB2YWx1ZUNvbHVtbjogZm9ybWF0VmFsdWUobWVkaWFuKSB9KTtcbiAgfVxuICBpZiAoaXNEZWZpbmVkKGZpcnN0UXVhcnRpbGUpKSB7XG4gICAgZGF0YS5wdXNoKHsga2V5OiAnMXN0IFF1YXJ0aWxlJywgdmFsdWVDb2x1bW46IGZvcm1hdFZhbHVlKGZpcnN0UXVhcnRpbGUpIH0pO1xuICB9XG4gIGlmIChpc0RlZmluZWQodGhpcmRRdWFydGlsZSkpIHtcbiAgICBkYXRhLnB1c2goeyBrZXk6ICczcmQgUXVhcnRpbGUnLCB2YWx1ZUNvbHVtbjogZm9ybWF0VmFsdWUodGhpcmRRdWFydGlsZSkgfSk7XG4gIH1cbiAgaWYgKGlzRGVmaW5lZChvdXRsaWVycykgJiYgb3V0bGllcnMubGVuZ3RoID4gMCkge1xuICAgIGRhdGEucHVzaCh7IGtleTogJyMgT3V0bGllcnMnLCB2YWx1ZUNvbHVtbjogb3V0bGllcnMubGVuZ3RoIH0pO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8VG9vbHRpcEZyYW1lPlxuICAgICAgPGRpdj5cbiAgICAgICAgPHN0cm9uZyBzdHlsZT17eyBjb2xvciB9fT57bGFiZWx9PC9zdHJvbmc+XG4gICAgICA8L2Rpdj5cbiAgICAgIHtkYXRhLmxlbmd0aCA+IDAgJiYgPGJyIC8+fVxuICAgICAgPFRvb2x0aXBUYWJsZSBkYXRhPXtkYXRhfSAvPlxuICAgIDwvVG9vbHRpcEZyYW1lPlxuICApO1xufVxuIiwiaW1wb3J0IHsgY3JlYXRlRW5jb2RlckZhY3RvcnksIEVuY29kZXIsIERlcml2ZUVuY29kaW5nIH0gZnJvbSAnZW5jb2RhYmxlJztcblxuZXhwb3J0IHR5cGUgQm94UGxvdEVuY29kaW5nQ29uZmlnID0ge1xuICB4OiBbJ1hCYW5kJywgbnVtYmVyXTtcbiAgeTogWydZQmFuZCcsIG51bWJlcl07XG4gIGNvbG9yOiBbJ0NvbG9yJywgc3RyaW5nXTtcbn07XG5cbmV4cG9ydCBjb25zdCBib3hQbG90RW5jb2RlckZhY3RvcnkgPSBjcmVhdGVFbmNvZGVyRmFjdG9yeTxCb3hQbG90RW5jb2RpbmdDb25maWc+KHtcbiAgY2hhbm5lbFR5cGVzOiB7XG4gICAgeDogJ1hCYW5kJyxcbiAgICB5OiAnWUJhbmQnLFxuICAgIGNvbG9yOiAnQ29sb3InLFxuICB9LFxuICBkZWZhdWx0RW5jb2Rpbmc6IHtcbiAgICB4OiB7IGZpZWxkOiAneCcsIHR5cGU6ICdub21pbmFsJyB9LFxuICAgIHk6IHsgZmllbGQ6ICd5JywgdHlwZTogJ3F1YW50aXRhdGl2ZScgfSxcbiAgICBjb2xvcjogeyB2YWx1ZTogJyMyMjInIH0sXG4gIH0sXG59KTtcblxuZXhwb3J0IHR5cGUgQm94UGxvdEVuY29kaW5nID0gRGVyaXZlRW5jb2Rpbmc8Qm94UGxvdEVuY29kaW5nQ29uZmlnPjtcblxuZXhwb3J0IHR5cGUgQm94UGxvdEVuY29kZXIgPSBFbmNvZGVyPEJveFBsb3RFbmNvZGluZ0NvbmZpZz47XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQm94UGxvdFNlcmllcywgWFlDaGFydCB9IGZyb20gJ0BkYXRhLXVpL3h5LWNoYXJ0JztcbmltcG9ydCB7IGNoYXJ0VGhlbWUsIENoYXJ0VGhlbWUgfSBmcm9tICdAZGF0YS11aS90aGVtZSc7XG5pbXBvcnQgeyBNYXJnaW4sIERpbWVuc2lvbiB9IGZyb20gJ0BzdXBlcnNldC11aS9kaW1lbnNpb24nO1xuaW1wb3J0IHsgV2l0aExlZ2VuZCB9IGZyb20gJ0BzdXBlcnNldC11aS9jaGFydC1jb21wb3NpdGlvbic7XG5pbXBvcnQgeyBEYXRhc2V0LCBQbGFpbk9iamVjdCwgaXNGaWVsZERlZiB9IGZyb20gJ2VuY29kYWJsZSc7XG5pbXBvcnQgRGVmYXVsdFRvb2x0aXBSZW5kZXJlciBmcm9tICcuL0RlZmF1bHRUb29sdGlwUmVuZGVyZXInO1xuaW1wb3J0IHtcbiAgQm94UGxvdEVuY29kaW5nQ29uZmlnLFxuICBCb3hQbG90RW5jb2RpbmcsXG4gIEJveFBsb3RFbmNvZGVyLFxuICBib3hQbG90RW5jb2RlckZhY3RvcnksXG59IGZyb20gJy4vRW5jb2Rlcic7XG5pbXBvcnQgY3JlYXRlTWFyZ2luU2VsZWN0b3IsIHsgREVGQVVMVF9NQVJHSU4gfSBmcm9tICcuLi8uLi91dGlscy9jcmVhdGVNYXJnaW5TZWxlY3Rvcic7XG5pbXBvcnQgeyBCb3hQbG90RGF0YVJvdyB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IGNvbnZlcnRTY2FsZVRvRGF0YVVJU2NhbGUgZnJvbSAnLi4vLi4vdXRpbHMvY29udmVydFNjYWxlVG9EYXRhVUlTY2FsZVNoYXBlJztcbmltcG9ydCBjcmVhdGVYWUNoYXJ0TGF5b3V0V2l0aFRoZW1lIGZyb20gJy4uLy4uL3V0aWxzL2NyZWF0ZVhZQ2hhcnRMYXlvdXRXaXRoVGhlbWUnO1xuaW1wb3J0IGNyZWF0ZVJlbmRlckxlZ2VuZCBmcm9tICcuLi9sZWdlbmQvY3JlYXRlUmVuZGVyTGVnZW5kJztcbmltcG9ydCB7IExlZ2VuZEhvb2tzIH0gZnJvbSAnLi4vbGVnZW5kL3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBUb29sdGlwUHJvcHMge1xuICBkYXR1bTogQm94UGxvdERhdGFSb3c7XG4gIGNvbG9yOiBzdHJpbmc7XG4gIGVuY29kZXI6IEJveFBsb3RFbmNvZGVyO1xufVxuXG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gIGNsYXNzTmFtZTogJycsXG4gIG1hcmdpbjogREVGQVVMVF9NQVJHSU4sXG4gIGVuY29kaW5nOiB7fSxcbiAgdGhlbWU6IGNoYXJ0VGhlbWUsXG4gIFRvb2x0aXBSZW5kZXJlcjogRGVmYXVsdFRvb2x0aXBSZW5kZXJlcixcbn0gYXMgY29uc3Q7XG5cbmV4cG9ydCB0eXBlIEhvb2tQcm9wcyA9IHtcbiAgVG9vbHRpcFJlbmRlcmVyPzogUmVhY3QuQ29tcG9uZW50VHlwZTxUb29sdGlwUHJvcHM+O1xufSAmIExlZ2VuZEhvb2tzPEJveFBsb3RFbmNvZGluZ0NvbmZpZz47XG5cbnR5cGUgUHJvcHMgPSB7XG4gIGNsYXNzTmFtZT86IHN0cmluZztcbiAgd2lkdGg6IHN0cmluZyB8IG51bWJlcjtcbiAgaGVpZ2h0OiBzdHJpbmcgfCBudW1iZXI7XG4gIG1hcmdpbj86IE1hcmdpbjtcbiAgZW5jb2Rpbmc/OiBQYXJ0aWFsPEJveFBsb3RFbmNvZGluZz47XG4gIGRhdGE6IERhdGFzZXQ7XG4gIHRoZW1lPzogQ2hhcnRUaGVtZTtcbn0gJiBIb29rUHJvcHMgJlxuICBSZWFkb25seTx0eXBlb2YgZGVmYXVsdFByb3BzPjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQm94UGxvdCBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQ8UHJvcHM+IHtcbiAgcHJpdmF0ZSBjcmVhdGVFbmNvZGVyID0gYm94UGxvdEVuY29kZXJGYWN0b3J5LmNyZWF0ZVNlbGVjdG9yKCk7XG5cbiAgcHJpdmF0ZSBjcmVhdGVNYXJnaW4gPSBjcmVhdGVNYXJnaW5TZWxlY3RvcigpO1xuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5cbiAgcmVuZGVyQ2hhcnQgPSAoZGltOiBEaW1lbnNpb24pID0+IHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGRpbTtcbiAgICBjb25zdCB7IGRhdGEsIG1hcmdpbiwgdGhlbWUsIFRvb2x0aXBSZW5kZXJlciwgZW5jb2RpbmcgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgZW5jb2RlciA9IHRoaXMuY3JlYXRlRW5jb2RlcihlbmNvZGluZyk7XG4gICAgY29uc3QgeyBjaGFubmVscyB9ID0gZW5jb2RlcjtcblxuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9XG4gICAgICBpc0ZpZWxkRGVmKGNoYW5uZWxzLnkuZGVmaW5pdGlvbikgJiYgY2hhbm5lbHMueS5kZWZpbml0aW9uLnR5cGUgPT09ICdub21pbmFsJztcblxuICAgIGVuY29kZXIuc2V0RG9tYWluRnJvbURhdGFzZXQoZGF0YSk7XG5cbiAgICBjb25zdCBsYXlvdXQgPSBjcmVhdGVYWUNoYXJ0TGF5b3V0V2l0aFRoZW1lKHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgbWFyZ2luOiB0aGlzLmNyZWF0ZU1hcmdpbihtYXJnaW4pLFxuICAgICAgdGhlbWUsXG4gICAgICB4RW5jb2RlcjogY2hhbm5lbHMueCxcbiAgICAgIHlFbmNvZGVyOiBjaGFubmVscy55LFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGxheW91dC5yZW5kZXJDaGFydFdpdGhGcmFtZSgoY2hhcnREaW06IERpbWVuc2lvbikgPT4gKFxuICAgICAgPFhZQ2hhcnRcbiAgICAgICAgc2hvd1lHcmlkXG4gICAgICAgIHdpZHRoPXtjaGFydERpbS53aWR0aH1cbiAgICAgICAgaGVpZ2h0PXtjaGFydERpbS5oZWlnaHR9XG4gICAgICAgIGFyaWFMYWJlbD1cIkJveFBsb3RcIlxuICAgICAgICBtYXJnaW49e2xheW91dC5tYXJnaW59XG4gICAgICAgIHJlbmRlclRvb2x0aXA9eyh7IGRhdHVtLCBjb2xvciB9OiB7IGRhdHVtOiBCb3hQbG90RGF0YVJvdzsgY29sb3I6IHN0cmluZyB9KSA9PiAoXG4gICAgICAgICAgPFRvb2x0aXBSZW5kZXJlciBkYXR1bT17ZGF0dW19IGNvbG9yPXtjb2xvcn0gZW5jb2Rlcj17ZW5jb2Rlcn0gLz5cbiAgICAgICAgKX1cbiAgICAgICAgdGhlbWU9e3RoZW1lfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1jYWxsLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHhTY2FsZT17Y29udmVydFNjYWxlVG9EYXRhVUlTY2FsZShjaGFubmVscy54LmRlZmluaXRpb24uc2NhbGUgYXMgYW55KX1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtY2FsbCwgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICB5U2NhbGU9e2NvbnZlcnRTY2FsZVRvRGF0YVVJU2NhbGUoY2hhbm5lbHMueS5kZWZpbml0aW9uLnNjYWxlIGFzIGFueSl9XG4gICAgICA+XG4gICAgICAgIHtsYXlvdXQucmVuZGVyWEF4aXMoKX1cbiAgICAgICAge2xheW91dC5yZW5kZXJZQXhpcygpfVxuICAgICAgICA8Qm94UGxvdFNlcmllc1xuICAgICAgICAgIGtleT17aXNGaWVsZERlZihjaGFubmVscy54LmRlZmluaXRpb24pID8gY2hhbm5lbHMueC5kZWZpbml0aW9uLmZpZWxkIDogJyd9XG4gICAgICAgICAgYW5pbWF0ZWRcbiAgICAgICAgICBkYXRhPXtcbiAgICAgICAgICAgIGlzSG9yaXpvbnRhbFxuICAgICAgICAgICAgICA/IGRhdGEubWFwKHJvdyA9PiAoeyAuLi5yb3csIHk6IGNoYW5uZWxzLnkuZ2V0VmFsdWVGcm9tRGF0dW0ocm93KSB9KSlcbiAgICAgICAgICAgICAgOiBkYXRhLm1hcChyb3cgPT4gKHsgLi4ucm93LCB4OiBjaGFubmVscy54LmdldFZhbHVlRnJvbURhdHVtKHJvdykgfSkpXG4gICAgICAgICAgfVxuICAgICAgICAgIGZpbGw9eyhkYXR1bTogUGxhaW5PYmplY3QpID0+IGNoYW5uZWxzLmNvbG9yLmVuY29kZURhdHVtKGRhdHVtLCAnIzU1YWNlZScpfVxuICAgICAgICAgIGZpbGxPcGFjaXR5PXswLjR9XG4gICAgICAgICAgc3Ryb2tlPXsoZGF0dW06IFBsYWluT2JqZWN0KSA9PiBjaGFubmVscy5jb2xvci5lbmNvZGVEYXR1bShkYXR1bSl9XG4gICAgICAgICAgc3Ryb2tlV2lkdGg9ezF9XG4gICAgICAgICAgd2lkdGhSYXRpbz17MC42fVxuICAgICAgICAgIGhvcml6b250YWw9e2lzSG9yaXpvbnRhbH1cbiAgICAgICAgLz5cbiAgICAgIDwvWFlDaGFydD5cbiAgICApKTtcbiAgfTtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBjbGFzc05hbWUsIGRhdGEsIGVuY29kaW5nLCB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzLnByb3BzO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxXaXRoTGVnZW5kXG4gICAgICAgIGNsYXNzTmFtZT17YHN1cGVyc2V0LWNoYXJ0LWJveC1wbG90ICR7Y2xhc3NOYW1lfWB9XG4gICAgICAgIHdpZHRoPXt3aWR0aH1cbiAgICAgICAgaGVpZ2h0PXtoZWlnaHR9XG4gICAgICAgIHBvc2l0aW9uPVwidG9wXCJcbiAgICAgICAgcmVuZGVyTGVnZW5kPXtjcmVhdGVSZW5kZXJMZWdlbmQodGhpcy5jcmVhdGVFbmNvZGVyKGVuY29kaW5nKSwgZGF0YSwgdGhpcy5wcm9wcyl9XG4gICAgICAgIHJlbmRlckNoYXJ0PXt0aGlzLnJlbmRlckNoYXJ0fVxuICAgICAgLz5cbiAgICApO1xuICB9XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pEQTtBQUNBO0FBQ0E7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwQkE7QUFDQTtBQUNBOzs7QUNGQTtBQUNBO0FBQ0E7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDSkE7QUFDQTtBQUNBOzs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsREE7QUFDQTtBQUNBOzs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNKQTtBQUNBO0FBQ0E7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdkZBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBSUE7QUFDQTtBQUlBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQU9BO0FBQ0E7QUFHQTtBQUNBO0FBT0E7QUFDQTtBQUdBOzs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUN0T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbmRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaE5BO0FBQ0E7QUFDQTtBQUlBO0FBU0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7OztBQ2pEQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFFQTtBQUNBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWlCQTtBQUFBOztBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQVdBO0FBZ0JBO0FBZEE7QUFDQTtBQUVBO0FBVUE7O0FBeEVBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2342\n')}}]);