(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{2497:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, "default", function() { return /* binding */ TableChart; });\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react/index.js\nvar react = __webpack_require__(0);\nvar react_default = /*#__PURE__*/__webpack_require__.n(react);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/node_modules/d3-array/src/max.js\nvar max = __webpack_require__(2489);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/node_modules/d3-array/src/extent.js\nvar extent = __webpack_require__(2490);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react-icons/fa/index.esm.js + 4 modules\nvar index_esm = __webpack_require__(2446);\n\n// EXTERNAL MODULE: ../superset-ui-core/src/query/types/QueryResponse.ts\nvar QueryResponse = __webpack_require__(164);\n\n// EXTERNAL MODULE: ../superset-ui-core/src/translation/TranslatorSingleton.ts + 1 modules\nvar TranslatorSingleton = __webpack_require__(13);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react-table/index.js\nvar react_table = __webpack_require__(2224);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/match-sorter/dist/match-sorter.esm.js\nvar match_sorter_esm = __webpack_require__(2439);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/regenerator-runtime/runtime.js\nvar runtime = __webpack_require__(294);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/DataTable/utils/useAsyncState.ts\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\n// useAsyncDebounce in dist build of `react-table` requires regeneratorRuntime\n\n/**\n * Hook useState to allow always return latest initialValue\n */\nfunction useAsyncState(initialValue, callback, wait = 200) {\n    const [value, setValue] = Object(react["useState"])(initialValue);\n    const valueRef = Object(react["useRef"])(initialValue);\n    const onChange = Object(react_table["useAsyncDebounce"])(callback, wait);\n    // sync updated initialValue\n    if (valueRef.current !== initialValue) {\n        valueRef.current = initialValue;\n        if (value !== initialValue) {\n            setValue(initialValue);\n        }\n    }\n    const setBoth = (newValue) => {\n        setValue(newValue);\n        onChange(newValue);\n    };\n    return [value, setBoth];\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/DataTable/components/GlobalFilter.tsx\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\nfunction DefaultSearchInput({ count, value, onChange }) {\n    return (react_default.a.createElement("span", { className: "dt-global-filter" },\n        "Search",\n        \' \',\n        react_default.a.createElement("input", { className: "form-control input-sm", placeholder: `${count} records...`, value: value, onChange: onChange })));\n}\n/* harmony default export */ var components_GlobalFilter = (react_default.a.memo(function GlobalFilter({ preGlobalFilteredRows, filterValue = \'\', searchInput, setGlobalFilter, }) {\n    const count = preGlobalFilteredRows.length;\n    const [value, setValue] = useAsyncState(filterValue, (newValue) => {\n        setGlobalFilter(newValue || undefined);\n    }, 200);\n    const SearchInput = searchInput || DefaultSearchInput;\n    return (react_default.a.createElement(SearchInput, { count: count, value: value, onChange: e => {\n            const target = e.target;\n            e.preventDefault();\n            setValue(target.value);\n        } }));\n}));\n\n// EXTERNAL MODULE: ../superset-ui-chart-controls/src/utils/selectOptions.ts\nvar selectOptions = __webpack_require__(168);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/DataTable/components/SelectPageSize.tsx\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\nfunction DefaultSelectRenderer({ current, options, onChange }) {\n    return (react_default.a.createElement("span", { className: "dt-select-page-size form-inline" },\n        "Show",\n        \' \',\n        react_default.a.createElement("select", { className: "form-control input-sm", value: current, onBlur: () => { }, onChange: e => {\n                onChange(Number(e.target.value));\n            } }, options.map(option => {\n            const [size, text] = Array.isArray(option) ? option : [option, option];\n            return (react_default.a.createElement("option", { key: size, value: size }, text));\n        })),\n        \' \',\n        "entries"));\n}\nfunction getOptionValue(x) {\n    return Array.isArray(x) ? x[0] : x;\n}\n/* harmony default export */ var components_SelectPageSize = (react_default.a.memo(function SelectPageSize({ total, options: sizeOptions, current: currentSize, selectRenderer, onChange, }) {\n    const sizeOptionValues = sizeOptions.map(getOptionValue);\n    let options = [...sizeOptions];\n    // insert current size to list\n    if (currentSize !== undefined &&\n        (currentSize !== total || !sizeOptionValues.includes(0)) &&\n        !sizeOptionValues.includes(currentSize)) {\n        options = [...sizeOptions];\n        options.splice(sizeOptionValues.findIndex(x => x > currentSize), 0, Object(selectOptions["a" /* formatSelectOptions */])([currentSize])[0]);\n    }\n    const current = currentSize === undefined ? sizeOptionValues[0] : currentSize;\n    const SelectRenderer = selectRenderer || DefaultSelectRenderer;\n    return react_default.a.createElement(SelectRenderer, { current: current, options: options, onChange: onChange });\n}));\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/DataTable/components/Pagination.tsx\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n// first, ..., prev, current, next, ..., last\nconst MINIMAL_PAGE_ITEM_COUNT = 7;\n/**\n * Generate numeric page items around current page.\n *   - Always include first and last page\n *   - Add ellipsis if needed\n */\nfunction generatePageItems(total, current, width) {\n    if (width < MINIMAL_PAGE_ITEM_COUNT) {\n        throw new Error(`Must allow at least ${MINIMAL_PAGE_ITEM_COUNT} page items`);\n    }\n    if (width % 2 === 0) {\n        throw new Error(`Must allow odd number of page items`);\n    }\n    if (total < width) {\n        return [...new Array(total).keys()];\n    }\n    const left = Math.max(0, Math.min(total - width, current - Math.floor(width / 2)));\n    const items = new Array(width);\n    for (let i = 0; i < width; i += 1) {\n        items[i] = i + left;\n    }\n    // replace non-ending items with placeholders\n    if (items[0] > 0) {\n        items[0] = 0;\n        items[1] = \'prev-more\';\n    }\n    if (items[items.length - 1] < total - 1) {\n        items[items.length - 1] = total - 1;\n        items[items.length - 2] = \'next-more\';\n    }\n    return items;\n}\n/* harmony default export */ var components_Pagination = (react_default.a.memo(react_default.a.forwardRef(function Pagination({ style, pageCount, currentPage = 0, maxPageItemCount = 9, onPageChange }, ref) {\n    const pageItems = generatePageItems(pageCount, currentPage, maxPageItemCount);\n    return (react_default.a.createElement("div", { ref: ref, className: "dt-pagination", style: style },\n        react_default.a.createElement("ul", { className: "pagination pagination-sm" }, pageItems.map(item => typeof item === \'number\' ? (\n        // actual page number\n        react_default.a.createElement("li", { key: item, className: currentPage === item ? \'active\' : undefined },\n            react_default.a.createElement("a", { href: `#page-${item}`, role: "button", onClick: e => {\n                    e.preventDefault();\n                    onPageChange(item);\n                } }, item + 1))) : (react_default.a.createElement("li", { key: item, className: "dt-pagination-ellipsis" },\n            react_default.a.createElement("span", null, "\\u2026")))))));\n})));\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/DataTable/utils/getScrollBarSize.ts\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nlet cached;\nconst css = (x) => x.join(\'\\n\');\nfunction getScrollBarSize(forceRefresh = false) {\n    if (typeof document === \'undefined\') {\n        return 0;\n    }\n    if (cached === undefined || forceRefresh) {\n        const inner = document.createElement(\'div\');\n        const outer = document.createElement(\'div\');\n        inner.style.cssText = css `\n      width: auto;\n      height: 100%;\n      overflow: scroll;\n    `;\n        outer.style.cssText = css `\n      position: absolute;\n      visibility: hidden;\n      overflow: hidden;\n      width: 100px;\n      height: 50px;\n    `;\n        outer.append(inner);\n        document.body.append(outer);\n        cached = outer.clientWidth - inner.clientWidth;\n        outer.remove();\n    }\n    return cached;\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/DataTable/utils/needScrollBar.ts\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/**\n * Whether a container need scroll bars when in another container.\n */\nfunction needScrollBar({ width, height, innerHeight, innerWidth, scrollBarSize, }) {\n    const hasVerticalScroll = innerHeight > height;\n    const hasHorizontalScroll = innerWidth > width - (hasVerticalScroll ? scrollBarSize : 0);\n    return [hasVerticalScroll, hasHorizontalScroll];\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/DataTable/utils/useMountedMemo.ts\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n/**\n * Execute a memoized callback only when mounted. Execute again when factory updated.\n * Returns undefined if not mounted yet.\n */\nfunction useMountedMemo(factory, deps) {\n    const mounted = Object(react["useRef"])();\n    Object(react["useLayoutEffect"])(() => {\n        mounted.current = factory;\n    });\n    return Object(react["useMemo"])(() => {\n        if (mounted.current) {\n            return factory();\n        }\n        return undefined;\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [mounted.current, mounted.current === factory, ...(deps || [])]);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/DataTable/hooks/useSticky.tsx\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\n\n\nvar ReducerActions;\n(function (ReducerActions) {\n    ReducerActions["init"] = "init";\n    ReducerActions["setStickyState"] = "setStickyState";\n})(ReducerActions || (ReducerActions = {}));\nconst sum = (a, b) => a + b;\nconst mergeStyleProp = (node, style) => ({\n    style: Object.assign(Object.assign({}, node.props.style), style),\n});\nconst fixedTableLayout = { tableLayout: \'fixed\' };\n/**\n * An HOC for generating sticky header and fixed-height scrollable area\n */\nfunction StickyWrap({ sticky = {}, width: maxWidth, height: maxHeight, children: table, setStickyState, }) {\n    if (!table || table.type !== \'table\') {\n        throw new Error(\'<StickyWrap> must have only one <table> element as child\');\n    }\n    let thead;\n    let tbody;\n    react_default.a.Children.forEach(table.props.children, node => {\n        if (node.type === \'thead\') {\n            thead = node;\n        }\n        else if (node.type === \'tbody\') {\n            tbody = node;\n        }\n    });\n    if (!thead || !tbody) {\n        throw new Error(\'<table> in <StickyWrap> must contain both thead and tbody.\');\n    }\n    const columnCount = Object(react["useMemo"])(() => {\n        const headerRows = react_default.a.Children.toArray(thead === null || thead === void 0 ? void 0 : thead.props.children).pop();\n        return headerRows.props.children.length;\n    }, [thead]);\n    const theadRef = Object(react["useRef"])(null); // original thead for layout computation\n    const scrollHeaderRef = Object(react["useRef"])(null); // fixed header\n    const scrollBodyRef = Object(react["useRef"])(null); // main body\n    const scrollBarSize = getScrollBarSize();\n    const { bodyHeight, columnWidths } = sticky;\n    const needSizer = !columnWidths ||\n        sticky.width !== maxWidth ||\n        sticky.height !== maxHeight ||\n        sticky.setStickyState !== setStickyState;\n    // update scrollable area and header column sizes when mounted\n    Object(react["useLayoutEffect"])(() => {\n        if (theadRef.current) {\n            const bodyThead = theadRef.current;\n            const theadHeight = bodyThead.clientHeight;\n            if (!theadHeight) {\n                return;\n            }\n            const fullTableHeight = bodyThead.parentNode.clientHeight;\n            const ths = bodyThead.childNodes[0].childNodes;\n            const widths = Array.from(ths).map(th => th.clientWidth);\n            const [hasVerticalScroll, hasHorizontalScroll] = needScrollBar({\n                width: maxWidth,\n                height: maxHeight - theadHeight,\n                innerHeight: fullTableHeight,\n                innerWidth: widths.reduce(sum),\n                scrollBarSize,\n            });\n            // real container height, include table header and space for\n            // horizontal scroll bar\n            const realHeight = Math.min(maxHeight, hasHorizontalScroll ? fullTableHeight + scrollBarSize : fullTableHeight);\n            setStickyState({\n                hasVerticalScroll,\n                hasHorizontalScroll,\n                setStickyState,\n                width: maxWidth,\n                height: maxHeight,\n                realHeight,\n                tableHeight: fullTableHeight,\n                bodyHeight: realHeight - theadHeight,\n                columnWidths: widths,\n            });\n        }\n    }, [maxWidth, maxHeight, setStickyState, scrollBarSize]);\n    let sizerTable;\n    let headerTable;\n    let bodyTable;\n    if (needSizer) {\n        const theadWithRef = react_default.a.cloneElement(thead, { ref: theadRef });\n        sizerTable = (react_default.a.createElement("div", { key: "sizer", style: {\n                height: maxHeight,\n                overflow: \'auto\',\n                visibility: \'hidden\',\n            } }, react_default.a.cloneElement(table, {}, theadWithRef, tbody)));\n    }\n    // reuse previously column widths, will be updated by `useLayoutEffect` above\n    const colWidths = columnWidths === null || columnWidths === void 0 ? void 0 : columnWidths.slice(0, columnCount);\n    if (colWidths && bodyHeight) {\n        const bodyColgroup = (react_default.a.createElement("colgroup", null, colWidths.map((w, i) => (\n        // eslint-disable-next-line react/no-array-index-key\n        react_default.a.createElement("col", { key: i, width: w })))));\n        // header columns do not have vertical scroll bars,\n        // so we add scroll bar size to the last column\n        const headerColgroup = sticky.hasVerticalScroll && scrollBarSize ? (react_default.a.createElement("colgroup", null, colWidths.map((x, i) => (\n        // eslint-disable-next-line react/no-array-index-key\n        react_default.a.createElement("col", { key: i, width: x + (i === colWidths.length - 1 ? scrollBarSize : 0) }))))) : (bodyColgroup);\n        headerTable = (react_default.a.createElement("div", { key: "header", ref: scrollHeaderRef, style: {\n                overflow: \'hidden\',\n            } },\n            react_default.a.cloneElement(table, mergeStyleProp(table, fixedTableLayout), headerColgroup, thead),\n            headerTable));\n        const onScroll = e => {\n            if (scrollHeaderRef.current) {\n                scrollHeaderRef.current.scrollLeft = e.currentTarget.scrollLeft;\n            }\n        };\n        bodyTable = (react_default.a.createElement("div", { key: "body", ref: scrollBodyRef, style: {\n                height: bodyHeight,\n                overflow: \'auto\',\n            }, onScroll: sticky.hasHorizontalScroll ? onScroll : undefined }, react_default.a.cloneElement(table, mergeStyleProp(table, fixedTableLayout), bodyColgroup, tbody)));\n    }\n    return (react_default.a.createElement("div", { style: {\n            width: maxWidth,\n            height: sticky.realHeight || maxHeight,\n            overflow: \'hidden\',\n        } },\n        headerTable,\n        bodyTable,\n        sizerTable));\n}\nfunction useInstance(instance) {\n    const { dispatch, state: { sticky }, data, page, rows, getTableSize = () => undefined, } = instance;\n    const setStickyState = Object(react["useCallback"])((size) => {\n        dispatch({\n            type: ReducerActions.setStickyState,\n            size,\n        });\n    }, \n    // turning pages would also trigger a resize\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [dispatch, getTableSize, page, rows]);\n    const useStickyWrap = (renderer) => {\n        const { width, height } = useMountedMemo(getTableSize, [getTableSize]) || sticky;\n        // only change of data should trigger re-render\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        const table = Object(react["useMemo"])(renderer, [page, rows]);\n        Object(react["useLayoutEffect"])(() => {\n            if (!width || !height) {\n                setStickyState();\n            }\n        }, [width, height]);\n        if (!width || !height) {\n            return null;\n        }\n        if (data.length === 0) {\n            return table;\n        }\n        return (react_default.a.createElement(StickyWrap, { width: width, height: height, sticky: sticky, setStickyState: setStickyState }, table));\n    };\n    Object.assign(instance, {\n        setStickyState,\n        wrapStickyTable: useStickyWrap,\n    });\n}\nfunction useSticky(hooks) {\n    hooks.useInstance.push(useInstance);\n    hooks.stateReducers.push((newState, action_, prevState) => {\n        const action = action_;\n        if (action.type === ReducerActions.init) {\n            return Object.assign(Object.assign({}, newState), { sticky: Object.assign({}, prevState === null || prevState === void 0 ? void 0 : prevState.sticky) });\n        }\n        if (action.type === ReducerActions.setStickyState) {\n            const { size } = action;\n            if (!size) {\n                return Object.assign({}, newState);\n            }\n            return Object.assign(Object.assign({}, newState), { sticky: Object.assign(Object.assign(Object.assign({}, prevState === null || prevState === void 0 ? void 0 : prevState.sticky), newState === null || newState === void 0 ? void 0 : newState.sticky), action.size) });\n        }\n        return newState;\n    });\n}\nuseSticky.pluginName = \'useSticky\';\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/consts.ts\nvar consts = __webpack_require__(553);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/DataTable/DataTable.tsx\nvar __rest = (undefined && undefined.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === "function")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\n\n\n\n\n\n\n// Be sure to pass our updateMyData and the skipReset option\nfunction DataTable(_a) {\n    var _b, _c;\n    var { tableClassName, columns, data, serverPaginationData, width: initialWidth = \'100%\', height: initialHeight = 300, pageSize: initialPageSize = 0, initialState: initialState_ = {}, pageSizeOptions = consts["a" /* PAGE_SIZE_OPTIONS */], maxPageItemCount = 9, sticky: doSticky, searchInput = true, onServerPaginationChange, rowCount, selectPageSize, noResults: noResultsText = \'No data found\', hooks, serverPagination, wrapperRef: userWrapperRef } = _a, moreUseTableOptions = __rest(_a, ["tableClassName", "columns", "data", "serverPaginationData", "width", "height", "pageSize", "initialState", "pageSizeOptions", "maxPageItemCount", "sticky", "searchInput", "onServerPaginationChange", "rowCount", "selectPageSize", "noResults", "hooks", "serverPagination", "wrapperRef"]);\n    const tableHooks = [\n        react_table["useGlobalFilter"],\n        react_table["useSortBy"],\n        react_table["usePagination"],\n        doSticky ? useSticky : [],\n        hooks || [],\n    ].flat();\n    const resultsSize = serverPagination ? rowCount : data.length;\n    const sortByRef = Object(react["useRef"])([]); // cache initial `sortby` so sorting doesn\'t trigger page reset\n    const pageSizeRef = Object(react["useRef"])([initialPageSize, resultsSize]);\n    const hasPagination = initialPageSize > 0 && resultsSize > 0; // pageSize == 0 means no pagination\n    const hasGlobalControl = hasPagination || !!searchInput;\n    const initialState = Object.assign(Object.assign({}, initialState_), { \n        // zero length means all pages, the `usePagination` plugin does not\n        // understand pageSize = 0\n        sortBy: sortByRef.current, pageSize: initialPageSize > 0 ? initialPageSize : resultsSize || 10 });\n    const defaultWrapperRef = Object(react["useRef"])(null);\n    const globalControlRef = Object(react["useRef"])(null);\n    const paginationRef = Object(react["useRef"])(null);\n    const wrapperRef = userWrapperRef || defaultWrapperRef;\n    const paginationData = JSON.stringify(serverPaginationData);\n    const defaultGetTableSize = Object(react["useCallback"])(() => {\n        var _a, _b;\n        if (wrapperRef.current) {\n            // `initialWidth` and `initialHeight` could be also parameters like `100%`\n            // `Number` reaturns `NaN` on them, then we fallback to computed size\n            const width = Number(initialWidth) || wrapperRef.current.clientWidth;\n            const height = (Number(initialHeight) || wrapperRef.current.clientHeight) -\n                (((_a = globalControlRef.current) === null || _a === void 0 ? void 0 : _a.clientHeight) || 0) -\n                (((_b = paginationRef.current) === null || _b === void 0 ? void 0 : _b.clientHeight) || 0);\n            return { width, height };\n        }\n        return undefined;\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        initialHeight,\n        initialWidth,\n        wrapperRef,\n        hasPagination,\n        hasGlobalControl,\n        paginationRef,\n        resultsSize,\n        paginationData,\n    ]);\n    const defaultGlobalFilter = Object(react["useCallback"])((rows, columnIds, filterValue) => {\n        // allow searching by "col1_value col2_value"\n        const joinedString = (row) => columnIds.map(x => row.values[x]).join(\' \');\n        return Object(match_sorter_esm["a" /* matchSorter */])(rows, filterValue, {\n            keys: [...columnIds, joinedString],\n            threshold: match_sorter_esm["b" /* rankings */].ACRONYM,\n        });\n    }, []);\n    const { getTableProps, getTableBodyProps, prepareRow, headerGroups, page, pageCount, gotoPage, preGlobalFilteredRows, setGlobalFilter, setPageSize: setPageSize_, wrapStickyTable, state: { pageIndex, pageSize, globalFilter: filterValue, sticky = {} }, } = Object(react_table["useTable"])(Object.assign({ columns,\n        data,\n        initialState, getTableSize: defaultGetTableSize, globalFilter: defaultGlobalFilter }, moreUseTableOptions), ...tableHooks);\n    // make setPageSize accept 0\n    const setPageSize = (size) => {\n        if (serverPagination) {\n            onServerPaginationChange(0, size);\n        }\n        // keep the original size if data is empty\n        if (size || resultsSize !== 0) {\n            setPageSize_(size === 0 ? resultsSize : size);\n        }\n    };\n    const noResults = typeof noResultsText === \'function\' ? noResultsText(filterValue) : noResultsText;\n    const getNoResults = () => react_default.a.createElement("div", { className: "dt-no-results" }, noResults);\n    if (!columns || columns.length === 0) {\n        return (wrapStickyTable ? wrapStickyTable(getNoResults) : getNoResults());\n    }\n    const renderTable = () => (react_default.a.createElement("table", Object.assign({}, getTableProps({ className: tableClassName })),\n        react_default.a.createElement("thead", null, headerGroups.map(headerGroup => {\n            const _a = headerGroup.getHeaderGroupProps(), { key: headerGroupKey } = _a, headerGroupProps = __rest(_a, ["key"]);\n            return (react_default.a.createElement("tr", Object.assign({ key: headerGroupKey || headerGroup.id }, headerGroupProps), headerGroup.headers.map(column => column.render(\'Header\', Object.assign({ key: column.id }, column.getSortByToggleProps())))));\n        })),\n        react_default.a.createElement("tbody", Object.assign({}, getTableBodyProps()), page && page.length > 0 ? (page.map(row => {\n            prepareRow(row);\n            const _a = row.getRowProps(), { key: rowKey } = _a, rowProps = __rest(_a, ["key"]);\n            return (react_default.a.createElement("tr", Object.assign({ key: rowKey || row.id }, rowProps), row.cells.map(cell => cell.render(\'Cell\', { key: cell.column.id }))));\n        })) : (react_default.a.createElement("tr", null,\n            react_default.a.createElement("td", { className: "dt-no-results", colSpan: columns.length }, noResults))))));\n    // force update the pageSize when it\'s been update from the initial state\n    if (pageSizeRef.current[0] !== initialPageSize ||\n        // when initialPageSize stays as zero, but total number of records changed,\n        // we\'d also need to update page size\n        (initialPageSize === 0 && pageSizeRef.current[1] !== resultsSize)) {\n        pageSizeRef.current = [initialPageSize, resultsSize];\n        setPageSize(initialPageSize);\n    }\n    const paginationStyle = sticky.height ? {} : { visibility: \'hidden\' };\n    let resultPageCount = pageCount;\n    let resultCurrentPageSize = pageSize;\n    let resultCurrentPage = pageIndex;\n    let resultOnPageChange = gotoPage;\n    if (serverPagination) {\n        const serverPageSize = (_b = serverPaginationData.pageSize) !== null && _b !== void 0 ? _b : initialPageSize;\n        resultPageCount = Math.ceil(rowCount / serverPageSize);\n        if (!Number.isFinite(resultPageCount)) {\n            resultPageCount = 0;\n        }\n        resultCurrentPageSize = serverPageSize;\n        const foundPageSizeIndex = pageSizeOptions.findIndex(([option]) => option >= resultCurrentPageSize);\n        if (foundPageSizeIndex === -1) {\n            resultCurrentPageSize = 0;\n        }\n        resultCurrentPage = (_c = serverPaginationData.currentPage) !== null && _c !== void 0 ? _c : 0;\n        resultOnPageChange = (pageNumber) => onServerPaginationChange(pageNumber, serverPageSize);\n    }\n    return (react_default.a.createElement("div", { ref: wrapperRef, style: { width: initialWidth, height: initialHeight } },\n        hasGlobalControl ? (react_default.a.createElement("div", { ref: globalControlRef, className: "form-inline dt-controls" },\n            react_default.a.createElement("div", { className: "row" },\n                react_default.a.createElement("div", { className: "col-sm-6" }, hasPagination ? (react_default.a.createElement(components_SelectPageSize, { total: resultsSize, current: resultCurrentPageSize, options: pageSizeOptions, selectRenderer: typeof selectPageSize === \'boolean\' ? undefined : selectPageSize, onChange: setPageSize })) : null),\n                searchInput ? (react_default.a.createElement("div", { className: "col-sm-6" },\n                    react_default.a.createElement(components_GlobalFilter, { searchInput: typeof searchInput === \'boolean\' ? undefined : searchInput, preGlobalFilteredRows: preGlobalFilteredRows, setGlobalFilter: setGlobalFilter, filterValue: filterValue }))) : null))) : null,\n        wrapStickyTable ? wrapStickyTable(renderTable) : renderTable(),\n        hasPagination && resultPageCount > 1 ? (react_default.a.createElement(components_Pagination, { ref: paginationRef, style: paginationStyle, maxPageItemCount: maxPageItemCount, pageCount: resultPageCount, currentPage: resultCurrentPage, onPageChange: resultOnPageChange })) : null));\n}\n\n// EXTERNAL MODULE: ../superset-ui-core/src/style/index.ts\nvar src_style = __webpack_require__(435);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/Styles.tsx\n\n/* harmony default export */ var Styles = (src_style["d" /* styled */].div `\n  table {\n    width: 100%;\n    min-width: auto;\n    max-width: none;\n    margin: 0;\n  }\n\n  th,\n  td {\n    min-width: 4.3em;\n  }\n\n  thead > tr > th {\n    padding-right: 1.4em;\n    position: relative;\n    background: #fff;\n  }\n  th svg {\n    color: #ccc;\n    position: absolute;\n    bottom: 0.6em;\n    right: 0.2em;\n  }\n  th.is-sorted svg {\n    color: #a8a8a8;\n  }\n  .table > tbody > tr:first-of-type > td,\n  .table > tbody > tr:first-of-type > th {\n    border-top: 0;\n  }\n\n  .dt-controls {\n    padding-bottom: 0.65em;\n  }\n  .dt-metric {\n    text-align: right;\n  }\n  .dt-is-null {\n    color: ${({ theme: { colors } }) => colors.grayscale.light1};\n  }\n  td.dt-is-filter {\n    cursor: pointer;\n  }\n  td.dt-is-filter:hover {\n    background-color: linen;\n  }\n  td.dt-is-active-filter,\n  td.dt-is-active-filter:hover {\n    background-color: lightcyan;\n  }\n\n  .dt-global-filter {\n    float: right;\n  }\n\n  .dt-pagination {\n    text-align: right;\n    /* use padding instead of margin so clientHeight can capture it */\n    padding-top: 0.5em;\n  }\n  .dt-pagination .pagination {\n    margin: 0;\n  }\n\n  .pagination > li > span.dt-pagination-ellipsis:focus,\n  .pagination > li > span.dt-pagination-ellipsis:hover {\n    background: #fff;\n  }\n\n  .dt-no-results {\n    text-align: center;\n    padding: 1em 0.6em;\n  }\n`);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/xss/lib/index.js\nvar lib = __webpack_require__(2434);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/utils/formatValue.ts\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nconst xss = new lib["FilterXSS"]({\n    whiteList: Object.assign(Object.assign({}, Object(lib["getDefaultWhiteList"])()), { span: [\'style\', \'class\', \'title\'], div: [\'style\', \'class\'], a: [\'style\', \'class\', \'href\', \'title\', \'target\'], img: [\'style\', \'class\', \'src\', \'alt\', \'title\', \'width\', \'height\'] }),\n    stripIgnoreTag: true,\n    css: false,\n});\nfunction isProbablyHTML(text) {\n    return /<[^>]+>/.test(text);\n}\n/**\n * Format text for cell value.\n */\nfunction formatValue({ formatter }, value) {\n    if (value === null) {\n        return [false, \'N/A\'];\n    }\n    if (formatter) {\n        // in case percent metric can specify percent format in the future\n        return [false, formatter(value)];\n    }\n    if (typeof value === \'string\') {\n        return isProbablyHTML(value) ? [true, xss.process(value)] : [false, value];\n    }\n    return [false, value.toString()];\n}\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/DataTable/utils/externalAPIs.ts\nvar externalAPIs = __webpack_require__(1050);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/TableChart.tsx\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\n\n\n\n\n\n\n\n/**\n * Return sortType based on data type\n */\nfunction getSortTypeByDataType(dataType) {\n    if (dataType === QueryResponse["a" /* GenericDataType */].TEMPORAL) {\n        return \'datetime\';\n    }\n    if (dataType === QueryResponse["a" /* GenericDataType */].STRING) {\n        return \'alphanumeric\';\n    }\n    return \'basic\';\n}\n/**\n * Cell background to render columns as horizontal bar chart\n */\nfunction cellBar({ value, valueRange, colorPositiveNegative = false, alignPositiveNegative, }) {\n    const [minValue, maxValue] = valueRange;\n    const r = colorPositiveNegative && value < 0 ? 150 : 0;\n    if (alignPositiveNegative) {\n        const perc = Math.abs(Math.round((value / maxValue) * 100));\n        // The 0.01 to 0.001 is a workaround for what appears to be a\n        // CSS rendering bug on flat, transparent colors\n        return (`linear-gradient(to right, rgba(${r},0,0,0.2), rgba(${r},0,0,0.2) ${perc}%, ` +\n            `rgba(0,0,0,0.01) ${perc}%, rgba(0,0,0,0.001) 100%)`);\n    }\n    const posExtent = Math.abs(Math.max(maxValue, 0));\n    const negExtent = Math.abs(Math.min(minValue, 0));\n    const tot = posExtent + negExtent;\n    const perc1 = Math.round((Math.min(negExtent + value, negExtent) / tot) * 100);\n    const perc2 = Math.round((Math.abs(value) / tot) * 100);\n    // The 0.01 to 0.001 is a workaround for what appears to be a\n    // CSS rendering bug on flat, transparent colors\n    return (`linear-gradient(to right, rgba(0,0,0,0.01), rgba(0,0,0,0.001) ${perc1}%, ` +\n        `rgba(${r},0,0,0.2) ${perc1}%, rgba(${r},0,0,0.2) ${perc1 + perc2}%, ` +\n        `rgba(0,0,0,0.01) ${perc1 + perc2}%, rgba(0,0,0,0.001) 100%)`);\n}\nfunction SortIcon({ column }) {\n    const { isSorted, isSortedDesc } = column;\n    let sortIcon = react_default.a.createElement(index_esm["a" /* FaSort */], null);\n    if (isSorted) {\n        sortIcon = isSortedDesc ? react_default.a.createElement(index_esm["b" /* FaSortDown */], null) : react_default.a.createElement(index_esm["c" /* FaSortUp */], null);\n    }\n    return sortIcon;\n}\nfunction TableChart_SearchInput({ count, value, onChange }) {\n    return (react_default.a.createElement("span", { className: "dt-global-filter" },\n        Object(TranslatorSingleton["e" /* t */])(\'Search\'),\n        \' \',\n        react_default.a.createElement("input", { className: "form-control input-sm", placeholder: Object(TranslatorSingleton["f" /* tn */])(\'search.num_records\', count), value: value, onChange: onChange })));\n}\nfunction TableChart_SelectPageSize({ options, current, onChange }) {\n    return (react_default.a.createElement("span", { className: "dt-select-page-size form-inline" },\n        Object(TranslatorSingleton["e" /* t */])(\'page_size.show\'),\n        \' \',\n        react_default.a.createElement("select", { className: "form-control input-sm", value: current, onBlur: () => { }, onChange: e => {\n                onChange(Number(e.target.value));\n            } }, options.map(option => {\n            const [size, text] = Array.isArray(option) ? option : [option, option];\n            return (react_default.a.createElement("option", { key: size, value: size }, text));\n        })),\n        \' \',\n        Object(TranslatorSingleton["e" /* t */])(\'page_size.entries\')));\n}\nfunction TableChart(props) {\n    const { height, width, data, isRawRecords, rowCount = 0, columns: columnsMeta, alignPositiveNegative: defaultAlignPN = false, colorPositiveNegative: defaultColorPN = false, includeSearch = false, pageSize = 0, serverPagination = false, serverPaginationData, setDataMask, showCellBars = true, emitFilter = false, sortDesc = false, onChangeFilter, filters: initialFilters, sticky = true, } = props;\n    const [filters, setFilters] = Object(react["useState"])(initialFilters);\n    // only take relevant page size options\n    const pageSizeOptions = Object(react["useMemo"])(() => {\n        const getServerPagination = (n) => n <= rowCount;\n        return consts["a" /* PAGE_SIZE_OPTIONS */].filter(([n]) => serverPagination ? getServerPagination(n) : n <= 2 * data.length);\n    }, [data.length, rowCount, serverPagination]);\n    const getValueRange = Object(react["useCallback"])(function getValueRange(key, alignPositiveNegative) {\n        var _a;\n        if (typeof ((_a = data === null || data === void 0 ? void 0 : data[0]) === null || _a === void 0 ? void 0 : _a[key]) === \'number\') {\n            const nums = data.map(row => row[key]);\n            return (alignPositiveNegative\n                ? [0, Object(max["a" /* default */])(nums.map(Math.abs))]\n                : Object(extent["a" /* default */])(nums));\n        }\n        return null;\n    }, [data]);\n    const isActiveFilterValue = Object(react["useCallback"])(function isActiveFilterValue(key, val) {\n        var _a;\n        return !!filters && ((_a = filters[key]) === null || _a === void 0 ? void 0 : _a.includes(val));\n    }, [filters]);\n    const toggleFilter = Object(react["useCallback"])(function toggleFilter(key, val) {\n        const updatedFilters = Object.assign({}, (filters || {}));\n        if (filters && isActiveFilterValue(key, val)) {\n            updatedFilters[key] = filters[key].filter((x) => x !== val);\n        }\n        else {\n            updatedFilters[key] = [...((filters === null || filters === void 0 ? void 0 : filters[key]) || []), val];\n        }\n        setFilters(updatedFilters);\n        if (onChangeFilter) {\n            onChangeFilter(updatedFilters);\n        }\n    }, [filters, isActiveFilterValue, onChangeFilter]);\n    const getColumnConfigs = Object(react["useCallback"])((column, i) => {\n        const { key, label, dataType, isMetric, config = {} } = column;\n        const isNumber = dataType === QueryResponse["a" /* GenericDataType */].NUMERIC;\n        const isFilter = !isNumber && emitFilter;\n        const textAlign = config.horizontalAlign\n            ? config.horizontalAlign\n            : isNumber\n                ? \'right\'\n                : \'left\';\n        const columnWidth = Number.isNaN(Number(config.columnWidth))\n            ? config.columnWidth\n            : Number(config.columnWidth);\n        const alignPositiveNegative = config.alignPositiveNegative === undefined ? defaultAlignPN : config.alignPositiveNegative;\n        const colorPositiveNegative = config.colorPositiveNegative === undefined ? defaultColorPN : config.colorPositiveNegative;\n        const fractionDigits = isNumber ? config.fractionDigits : undefined;\n        const valueRange = (config.showCellBars === undefined ? showCellBars : config.showCellBars) &&\n            (isMetric || isRawRecords) &&\n            getValueRange(key, alignPositiveNegative);\n        let className = \'\';\n        if (isFilter) {\n            className += \' dt-is-filter\';\n        }\n        return {\n            id: String(i),\n            // must use custom accessor to allow `.` in column names\n            // typing is incorrect in current version of `@types/react-table`\n            // so we ask TS not to check.\n            accessor: ((datum) => datum[key]),\n            Cell: ({ value }) => {\n                let rounded = value;\n                if (fractionDigits !== undefined && typeof value === \'number\') {\n                    rounded = Number(value.toFixed(fractionDigits));\n                }\n                const [isHtml, text] = formatValue(column, rounded);\n                const html = isHtml ? { __html: text } : undefined;\n                const style = {\n                    background: valueRange\n                        ? cellBar({\n                            value: value,\n                            valueRange,\n                            alignPositiveNegative,\n                            colorPositiveNegative,\n                        })\n                        : undefined,\n                    textAlign,\n                };\n                const cellProps = {\n                    // show raw number in title in case of numeric values\n                    title: typeof value === \'number\' ? String(value) : undefined,\n                    onClick: emitFilter && !valueRange ? () => toggleFilter(key, value) : undefined,\n                    className: [\n                        className,\n                        value == null ? \'dt-is-null\' : \'\',\n                        isActiveFilterValue(key, value) ? \' dt-is-active-filter\' : \'\',\n                    ].join(\' \'),\n                    style,\n                };\n                if (html) {\n                    // eslint-disable-next-line react/no-danger\n                    return react_default.a.createElement("td", Object.assign({}, cellProps, { dangerouslySetInnerHTML: html }));\n                }\n                // If cellProps renderes textContent already, then we don\'t have to\n                // render `Cell`. This saves some time for large tables.\n                return react_default.a.createElement("td", Object.assign({}, cellProps), text);\n            },\n            Header: ({ column: col, onClick, style }) => (react_default.a.createElement("th", { title: "Shift + Click to sort by multiple columns", className: [className, col.isSorted ? \'is-sorted\' : \'\'].join(\' \'), style: Object.assign({}, style), onClick: onClick },\n                config.columnWidth ? (\n                // column width hint\n                react_default.a.createElement("div", { style: {\n                        width: columnWidth,\n                        height: 0.01,\n                    } })) : null,\n                label,\n                react_default.a.createElement(SortIcon, { column: col }))),\n            sortDescFirst: sortDesc,\n            sortType: getSortTypeByDataType(dataType),\n        };\n    }, [\n        defaultAlignPN,\n        defaultColorPN,\n        emitFilter,\n        getValueRange,\n        isActiveFilterValue,\n        isRawRecords,\n        showCellBars,\n        sortDesc,\n        toggleFilter,\n    ]);\n    const columns = Object(react["useMemo"])(() => columnsMeta.map(getColumnConfigs), [columnsMeta, getColumnConfigs]);\n    const handleServerPaginationChange = (pageNumber, pageSize) => {\n        Object(externalAPIs["a" /* updateExternalFormData */])(setDataMask, pageNumber, pageSize);\n    };\n    return (react_default.a.createElement(Styles, null,\n        react_default.a.createElement(DataTable, { columns: columns, data: data, rowCount: rowCount, tableClassName: "table table-striped table-condensed", pageSize: pageSize, serverPaginationData: serverPaginationData, pageSizeOptions: pageSizeOptions, height: height, serverPagination: serverPagination, onServerPaginationChange: handleServerPaginationChange, \n            // 9 page items in > 340px works well even for 100+ pages\n            maxPageItemCount: width > 340 ? 9 : 7, noResults: (filter) => Object(TranslatorSingleton["e" /* t */])(filter ? \'No matching records found\' : \'No records found\'), searchInput: includeSearch && TableChart_SearchInput, selectPageSize: pageSize !== null && TableChart_SelectPageSize, \n            // not in use in Superset, but needed for unit tests\n            sticky: sticky })));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQ5Ny5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wbHVnaW4tY2hhcnQtdGFibGUvc3JjL0RhdGFUYWJsZS91dGlscy91c2VBc3luY1N0YXRlLnRzP2Q0MmUiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9wbHVnaW5zL3BsdWdpbi1jaGFydC10YWJsZS9zcmMvRGF0YVRhYmxlL2NvbXBvbmVudHMvR2xvYmFsRmlsdGVyLnRzeD82NmM3Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wbHVnaW4tY2hhcnQtdGFibGUvc3JjL0RhdGFUYWJsZS9jb21wb25lbnRzL1NlbGVjdFBhZ2VTaXplLnRzeD80MWU4Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wbHVnaW4tY2hhcnQtdGFibGUvc3JjL0RhdGFUYWJsZS9jb21wb25lbnRzL1BhZ2luYXRpb24udHN4PzlhOTIiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9wbHVnaW5zL3BsdWdpbi1jaGFydC10YWJsZS9zcmMvRGF0YVRhYmxlL3V0aWxzL2dldFNjcm9sbEJhclNpemUudHM/NDI0OCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvcGx1Z2luLWNoYXJ0LXRhYmxlL3NyYy9EYXRhVGFibGUvdXRpbHMvbmVlZFNjcm9sbEJhci50cz8xNzUzIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wbHVnaW4tY2hhcnQtdGFibGUvc3JjL0RhdGFUYWJsZS91dGlscy91c2VNb3VudGVkTWVtby50cz85YzI5Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wbHVnaW4tY2hhcnQtdGFibGUvc3JjL0RhdGFUYWJsZS9ob29rcy91c2VTdGlja3kudHN4P2YwNGUiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9wbHVnaW5zL3BsdWdpbi1jaGFydC10YWJsZS9zcmMvRGF0YVRhYmxlL0RhdGFUYWJsZS50c3g/Mzg2NCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvcGx1Z2luLWNoYXJ0LXRhYmxlL3NyYy9TdHlsZXMudHN4PzNjMmYiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9wbHVnaW5zL3BsdWdpbi1jaGFydC10YWJsZS9zcmMvdXRpbHMvZm9ybWF0VmFsdWUudHM/MDE1NCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvcGx1Z2luLWNoYXJ0LXRhYmxlL3NyYy9UYWJsZUNoYXJ0LnRzeD8yODI1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VBc3luY0RlYm91bmNlIH0gZnJvbSAncmVhY3QtdGFibGUnO1xuXG4vLyB1c2VBc3luY0RlYm91bmNlIGluIGRpc3QgYnVpbGQgb2YgYHJlYWN0LXRhYmxlYCByZXF1aXJlcyByZWdlbmVyYXRvclJ1bnRpbWVcbmltcG9ydCAncmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lJztcblxuLyoqXG4gKiBIb29rIHVzZVN0YXRlIHRvIGFsbG93IGFsd2F5cyByZXR1cm4gbGF0ZXN0IGluaXRpYWxWYWx1ZVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1c2VBc3luY1N0YXRlPFQsIEYgZXh0ZW5kcyAobmV3VmFsdWU6IFQpID0+IHVua25vd24+KFxuICBpbml0aWFsVmFsdWU6IFQsXG4gIGNhbGxiYWNrOiBGLFxuICB3YWl0ID0gMjAwLFxuKSB7XG4gIGNvbnN0IFt2YWx1ZSwgc2V0VmFsdWVdID0gdXNlU3RhdGUoaW5pdGlhbFZhbHVlKTtcbiAgY29uc3QgdmFsdWVSZWYgPSB1c2VSZWYoaW5pdGlhbFZhbHVlKTtcbiAgY29uc3Qgb25DaGFuZ2UgPSB1c2VBc3luY0RlYm91bmNlKGNhbGxiYWNrLCB3YWl0KTtcblxuICAvLyBzeW5jIHVwZGF0ZWQgaW5pdGlhbFZhbHVlXG4gIGlmICh2YWx1ZVJlZi5jdXJyZW50ICE9PSBpbml0aWFsVmFsdWUpIHtcbiAgICB2YWx1ZVJlZi5jdXJyZW50ID0gaW5pdGlhbFZhbHVlO1xuICAgIGlmICh2YWx1ZSAhPT0gaW5pdGlhbFZhbHVlKSB7XG4gICAgICBzZXRWYWx1ZShpbml0aWFsVmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHNldEJvdGggPSAobmV3VmFsdWU6IFQpID0+IHtcbiAgICBzZXRWYWx1ZShuZXdWYWx1ZSk7XG4gICAgb25DaGFuZ2UobmV3VmFsdWUpO1xuICB9O1xuXG4gIHJldHVybiBbdmFsdWUsIHNldEJvdGhdIGFzIFt0eXBlb2YgdmFsdWUsIHR5cGVvZiBzZXRWYWx1ZV07XG59XG4iLCIvKipcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50VHlwZSwgQ2hhbmdlRXZlbnRIYW5kbGVyIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUm93LCBGaWx0ZXJWYWx1ZSB9IGZyb20gJ3JlYWN0LXRhYmxlJztcbmltcG9ydCB1c2VBc3luY1N0YXRlIGZyb20gJy4uL3V0aWxzL3VzZUFzeW5jU3RhdGUnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNlYXJjaElucHV0UHJvcHMge1xuICBjb3VudDogbnVtYmVyO1xuICB2YWx1ZTogc3RyaW5nO1xuICBvbkNoYW5nZTogQ2hhbmdlRXZlbnRIYW5kbGVyPEhUTUxJbnB1dEVsZW1lbnQ+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdsb2JhbEZpbHRlclByb3BzPEQgZXh0ZW5kcyBvYmplY3Q+IHtcbiAgcHJlR2xvYmFsRmlsdGVyZWRSb3dzOiBSb3c8RD5bXTtcbiAgLy8gZmlsdGVyIHZhbHVlIGNhbm5vdCBiZSBgdW5kZWZpbmVkYCBvdGhlcndpc2UgUmVhY3Qgd2lsbCByZXBvcnQgY29tcG9uZW50XG4gIC8vIGNvbnRyb2wgdHlwZSB1bmRlZmluZWQgZXJyb3JcbiAgZmlsdGVyVmFsdWU6IHN0cmluZztcbiAgc2V0R2xvYmFsRmlsdGVyOiAoZmlsdGVyVmFsdWU6IEZpbHRlclZhbHVlKSA9PiB2b2lkO1xuICBzZWFyY2hJbnB1dD86IENvbXBvbmVudFR5cGU8U2VhcmNoSW5wdXRQcm9wcz47XG59XG5cbmZ1bmN0aW9uIERlZmF1bHRTZWFyY2hJbnB1dCh7IGNvdW50LCB2YWx1ZSwgb25DaGFuZ2UgfTogU2VhcmNoSW5wdXRQcm9wcykge1xuICByZXR1cm4gKFxuICAgIDxzcGFuIGNsYXNzTmFtZT1cImR0LWdsb2JhbC1maWx0ZXJcIj5cbiAgICAgIFNlYXJjaHsnICd9XG4gICAgICA8aW5wdXRcbiAgICAgICAgY2xhc3NOYW1lPVwiZm9ybS1jb250cm9sIGlucHV0LXNtXCJcbiAgICAgICAgcGxhY2Vob2xkZXI9e2Ake2NvdW50fSByZWNvcmRzLi4uYH1cbiAgICAgICAgdmFsdWU9e3ZhbHVlfVxuICAgICAgICBvbkNoYW5nZT17b25DaGFuZ2V9XG4gICAgICAvPlxuICAgIDwvc3Bhbj5cbiAgKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgKFJlYWN0Lm1lbW8gYXMgPFQ+KGZuOiBUKSA9PiBUKShmdW5jdGlvbiBHbG9iYWxGaWx0ZXI8RCBleHRlbmRzIG9iamVjdD4oe1xuICBwcmVHbG9iYWxGaWx0ZXJlZFJvd3MsXG4gIGZpbHRlclZhbHVlID0gJycsXG4gIHNlYXJjaElucHV0LFxuICBzZXRHbG9iYWxGaWx0ZXIsXG59OiBHbG9iYWxGaWx0ZXJQcm9wczxEPikge1xuICBjb25zdCBjb3VudCA9IHByZUdsb2JhbEZpbHRlcmVkUm93cy5sZW5ndGg7XG4gIGNvbnN0IFt2YWx1ZSwgc2V0VmFsdWVdID0gdXNlQXN5bmNTdGF0ZShcbiAgICBmaWx0ZXJWYWx1ZSxcbiAgICAobmV3VmFsdWU6IHN0cmluZykgPT4ge1xuICAgICAgc2V0R2xvYmFsRmlsdGVyKG5ld1ZhbHVlIHx8IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICAyMDAsXG4gICk7XG5cbiAgY29uc3QgU2VhcmNoSW5wdXQgPSBzZWFyY2hJbnB1dCB8fCBEZWZhdWx0U2VhcmNoSW5wdXQ7XG5cbiAgcmV0dXJuIChcbiAgICA8U2VhcmNoSW5wdXRcbiAgICAgIGNvdW50PXtjb3VudH1cbiAgICAgIHZhbHVlPXt2YWx1ZX1cbiAgICAgIG9uQ2hhbmdlPXtlID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudDtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBzZXRWYWx1ZSh0YXJnZXQudmFsdWUpO1xuICAgICAgfX1cbiAgICAvPlxuICApO1xufSk7XG4iLCIvKipcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZm9ybWF0U2VsZWN0T3B0aW9ucyB9IGZyb20gJ0BzdXBlcnNldC11aS9jaGFydC1jb250cm9scyc7XG5cbmV4cG9ydCB0eXBlIFNpemVPcHRpb24gPSBbbnVtYmVyLCBzdHJpbmddO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNlbGVjdFBhZ2VTaXplUmVuZGVyZXJQcm9wcyB7XG4gIGN1cnJlbnQ6IG51bWJlcjtcbiAgb3B0aW9uczogU2l6ZU9wdGlvbltdO1xuICBvbkNoYW5nZTogU2VsZWN0UGFnZVNpemVQcm9wc1snb25DaGFuZ2UnXTtcbn1cblxuZnVuY3Rpb24gRGVmYXVsdFNlbGVjdFJlbmRlcmVyKHsgY3VycmVudCwgb3B0aW9ucywgb25DaGFuZ2UgfTogU2VsZWN0UGFnZVNpemVSZW5kZXJlclByb3BzKSB7XG4gIHJldHVybiAoXG4gICAgPHNwYW4gY2xhc3NOYW1lPVwiZHQtc2VsZWN0LXBhZ2Utc2l6ZSBmb3JtLWlubGluZVwiPlxuICAgICAgU2hvd3snICd9XG4gICAgICA8c2VsZWN0XG4gICAgICAgIGNsYXNzTmFtZT1cImZvcm0tY29udHJvbCBpbnB1dC1zbVwiXG4gICAgICAgIHZhbHVlPXtjdXJyZW50fVxuICAgICAgICBvbkJsdXI9eygpID0+IHt9fVxuICAgICAgICBvbkNoYW5nZT17ZSA9PiB7XG4gICAgICAgICAgb25DaGFuZ2UoTnVtYmVyKChlLnRhcmdldCBhcyBIVE1MU2VsZWN0RWxlbWVudCkudmFsdWUpKTtcbiAgICAgICAgfX1cbiAgICAgID5cbiAgICAgICAge29wdGlvbnMubWFwKG9wdGlvbiA9PiB7XG4gICAgICAgICAgY29uc3QgW3NpemUsIHRleHRdID0gQXJyYXkuaXNBcnJheShvcHRpb24pID8gb3B0aW9uIDogW29wdGlvbiwgb3B0aW9uXTtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPG9wdGlvbiBrZXk9e3NpemV9IHZhbHVlPXtzaXplfT5cbiAgICAgICAgICAgICAge3RleHR9XG4gICAgICAgICAgICA8L29wdGlvbj5cbiAgICAgICAgICApO1xuICAgICAgICB9KX1cbiAgICAgIDwvc2VsZWN0PnsnICd9XG4gICAgICBlbnRyaWVzXG4gICAgPC9zcGFuPlxuICApO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlbGVjdFBhZ2VTaXplUHJvcHMgZXh0ZW5kcyBTZWxlY3RQYWdlU2l6ZVJlbmRlcmVyUHJvcHMge1xuICB0b3RhbD86IG51bWJlcjtcbiAgc2VsZWN0UmVuZGVyZXI/OiB0eXBlb2YgRGVmYXVsdFNlbGVjdFJlbmRlcmVyO1xuICBvbkNoYW5nZTogKHBhZ2VTaXplOiBudW1iZXIpID0+IHZvaWQ7XG59XG5cbmZ1bmN0aW9uIGdldE9wdGlvblZhbHVlKHg6IFNpemVPcHRpb24pIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoeCkgPyB4WzBdIDogeDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVhY3QubWVtbyhmdW5jdGlvbiBTZWxlY3RQYWdlU2l6ZSh7XG4gIHRvdGFsLFxuICBvcHRpb25zOiBzaXplT3B0aW9ucyxcbiAgY3VycmVudDogY3VycmVudFNpemUsXG4gIHNlbGVjdFJlbmRlcmVyLFxuICBvbkNoYW5nZSxcbn06IFNlbGVjdFBhZ2VTaXplUHJvcHMpIHtcbiAgY29uc3Qgc2l6ZU9wdGlvblZhbHVlcyA9IHNpemVPcHRpb25zLm1hcChnZXRPcHRpb25WYWx1ZSk7XG4gIGxldCBvcHRpb25zID0gWy4uLnNpemVPcHRpb25zXTtcbiAgLy8gaW5zZXJ0IGN1cnJlbnQgc2l6ZSB0byBsaXN0XG4gIGlmIChcbiAgICBjdXJyZW50U2l6ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgKGN1cnJlbnRTaXplICE9PSB0b3RhbCB8fCAhc2l6ZU9wdGlvblZhbHVlcy5pbmNsdWRlcygwKSkgJiZcbiAgICAhc2l6ZU9wdGlvblZhbHVlcy5pbmNsdWRlcyhjdXJyZW50U2l6ZSlcbiAgKSB7XG4gICAgb3B0aW9ucyA9IFsuLi5zaXplT3B0aW9uc107XG4gICAgb3B0aW9ucy5zcGxpY2UoXG4gICAgICBzaXplT3B0aW9uVmFsdWVzLmZpbmRJbmRleCh4ID0+IHggPiBjdXJyZW50U2l6ZSksXG4gICAgICAwLFxuICAgICAgZm9ybWF0U2VsZWN0T3B0aW9ucyhbY3VycmVudFNpemVdKVswXSxcbiAgICApO1xuICB9XG4gIGNvbnN0IGN1cnJlbnQgPSBjdXJyZW50U2l6ZSA9PT0gdW5kZWZpbmVkID8gc2l6ZU9wdGlvblZhbHVlc1swXSA6IGN1cnJlbnRTaXplO1xuICBjb25zdCBTZWxlY3RSZW5kZXJlciA9IHNlbGVjdFJlbmRlcmVyIHx8IERlZmF1bHRTZWxlY3RSZW5kZXJlcjtcbiAgcmV0dXJuIDxTZWxlY3RSZW5kZXJlciBjdXJyZW50PXtjdXJyZW50fSBvcHRpb25zPXtvcHRpb25zfSBvbkNoYW5nZT17b25DaGFuZ2V9IC8+O1xufSk7XG4iLCIvKipcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgUmVhY3QsIHsgQ1NTUHJvcGVydGllcyB9IGZyb20gJ3JlYWN0JztcblxuZXhwb3J0IGludGVyZmFjZSBQYWdpbmF0aW9uUHJvcHMge1xuICBwYWdlQ291bnQ6IG51bWJlcjsgLy8gbnVtYmVyIG9mIHBhZ2VzXG4gIGN1cnJlbnRQYWdlPzogbnVtYmVyOyAvLyBpbmRleCBvZiBjdXJyZW50IHBhZ2UsIHplcm8tYmFzZWRcbiAgbWF4UGFnZUl0ZW1Db3VudD86IG51bWJlcjtcbiAgZWxsaXBzaXM/OiBzdHJpbmc7IC8vIGNvbnRlbnQgZm9yIGVsbGlwc2lzIGl0ZW1cbiAgb25QYWdlQ2hhbmdlOiAocGFnZTogbnVtYmVyKSA9PiB2b2lkOyAvLyBgcGFnZWAgaXMgemVyby1iYXNlZFxuICBzdHlsZT86IENTU1Byb3BlcnRpZXM7XG59XG5cbi8vIGZpcnN0LCAuLi4sIHByZXYsIGN1cnJlbnQsIG5leHQsIC4uLiwgbGFzdFxuY29uc3QgTUlOSU1BTF9QQUdFX0lURU1fQ09VTlQgPSA3O1xuXG4vKipcbiAqIEdlbmVyYXRlIG51bWVyaWMgcGFnZSBpdGVtcyBhcm91bmQgY3VycmVudCBwYWdlLlxuICogICAtIEFsd2F5cyBpbmNsdWRlIGZpcnN0IGFuZCBsYXN0IHBhZ2VcbiAqICAgLSBBZGQgZWxsaXBzaXMgaWYgbmVlZGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVBhZ2VJdGVtcyh0b3RhbDogbnVtYmVyLCBjdXJyZW50OiBudW1iZXIsIHdpZHRoOiBudW1iZXIpIHtcbiAgaWYgKHdpZHRoIDwgTUlOSU1BTF9QQUdFX0lURU1fQ09VTlQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE11c3QgYWxsb3cgYXQgbGVhc3QgJHtNSU5JTUFMX1BBR0VfSVRFTV9DT1VOVH0gcGFnZSBpdGVtc2ApO1xuICB9XG4gIGlmICh3aWR0aCAlIDIgPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE11c3QgYWxsb3cgb2RkIG51bWJlciBvZiBwYWdlIGl0ZW1zYCk7XG4gIH1cbiAgaWYgKHRvdGFsIDwgd2lkdGgpIHtcbiAgICByZXR1cm4gWy4uLm5ldyBBcnJheSh0b3RhbCkua2V5cygpXTtcbiAgfVxuICBjb25zdCBsZWZ0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odG90YWwgLSB3aWR0aCwgY3VycmVudCAtIE1hdGguZmxvb3Iod2lkdGggLyAyKSkpO1xuICBjb25zdCBpdGVtczogKHN0cmluZyB8IG51bWJlcilbXSA9IG5ldyBBcnJheSh3aWR0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgd2lkdGg7IGkgKz0gMSkge1xuICAgIGl0ZW1zW2ldID0gaSArIGxlZnQ7XG4gIH1cbiAgLy8gcmVwbGFjZSBub24tZW5kaW5nIGl0ZW1zIHdpdGggcGxhY2Vob2xkZXJzXG4gIGlmIChpdGVtc1swXSA+IDApIHtcbiAgICBpdGVtc1swXSA9IDA7XG4gICAgaXRlbXNbMV0gPSAncHJldi1tb3JlJztcbiAgfVxuICBpZiAoaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV0gPCB0b3RhbCAtIDEpIHtcbiAgICBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXSA9IHRvdGFsIC0gMTtcbiAgICBpdGVtc1tpdGVtcy5sZW5ndGggLSAyXSA9ICduZXh0LW1vcmUnO1xuICB9XG4gIHJldHVybiBpdGVtcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVhY3QubWVtbyhcbiAgUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBQYWdpbmF0aW9uKFxuICAgIHsgc3R5bGUsIHBhZ2VDb3VudCwgY3VycmVudFBhZ2UgPSAwLCBtYXhQYWdlSXRlbUNvdW50ID0gOSwgb25QYWdlQ2hhbmdlIH06IFBhZ2luYXRpb25Qcm9wcyxcbiAgICByZWY6IFJlYWN0LlJlZjxIVE1MRGl2RWxlbWVudD4sXG4gICkge1xuICAgIGNvbnN0IHBhZ2VJdGVtcyA9IGdlbmVyYXRlUGFnZUl0ZW1zKHBhZ2VDb3VudCwgY3VycmVudFBhZ2UsIG1heFBhZ2VJdGVtQ291bnQpO1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IHJlZj17cmVmfSBjbGFzc05hbWU9XCJkdC1wYWdpbmF0aW9uXCIgc3R5bGU9e3N0eWxlfT5cbiAgICAgICAgPHVsIGNsYXNzTmFtZT1cInBhZ2luYXRpb24gcGFnaW5hdGlvbi1zbVwiPlxuICAgICAgICAgIHtwYWdlSXRlbXMubWFwKGl0ZW0gPT5cbiAgICAgICAgICAgIHR5cGVvZiBpdGVtID09PSAnbnVtYmVyJyA/IChcbiAgICAgICAgICAgICAgLy8gYWN0dWFsIHBhZ2UgbnVtYmVyXG4gICAgICAgICAgICAgIDxsaSBrZXk9e2l0ZW19IGNsYXNzTmFtZT17Y3VycmVudFBhZ2UgPT09IGl0ZW0gPyAnYWN0aXZlJyA6IHVuZGVmaW5lZH0+XG4gICAgICAgICAgICAgICAgPGFcbiAgICAgICAgICAgICAgICAgIGhyZWY9e2AjcGFnZS0ke2l0ZW19YH1cbiAgICAgICAgICAgICAgICAgIHJvbGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICAgICAgb25DbGljaz17ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgb25QYWdlQ2hhbmdlKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICB7aXRlbSArIDF9XG4gICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgPGxpIGtleT17aXRlbX0gY2xhc3NOYW1lPVwiZHQtcGFnaW5hdGlvbi1lbGxpcHNpc1wiPlxuICAgICAgICAgICAgICAgIDxzcGFuPuKApjwvc3Bhbj5cbiAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgICksXG4gICAgICAgICAgKX1cbiAgICAgICAgPC91bD5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH0pLFxuKTtcbiIsIi8qKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmxldCBjYWNoZWQ6IG51bWJlciB8IHVuZGVmaW5lZDtcblxuY29uc3QgY3NzID0gKHg6IFRlbXBsYXRlU3RyaW5nc0FycmF5KSA9PiB4LmpvaW4oJ1xcbicpO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRTY3JvbGxCYXJTaXplKGZvcmNlUmVmcmVzaCA9IGZhbHNlKSB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKGNhY2hlZCA9PT0gdW5kZWZpbmVkIHx8IGZvcmNlUmVmcmVzaCkge1xuICAgIGNvbnN0IGlubmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29uc3Qgb3V0ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBpbm5lci5zdHlsZS5jc3NUZXh0ID0gY3NzYFxuICAgICAgd2lkdGg6IGF1dG87XG4gICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICBvdmVyZmxvdzogc2Nyb2xsO1xuICAgIGA7XG4gICAgb3V0ZXIuc3R5bGUuY3NzVGV4dCA9IGNzc2BcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICB3aWR0aDogMTAwcHg7XG4gICAgICBoZWlnaHQ6IDUwcHg7XG4gICAgYDtcbiAgICBvdXRlci5hcHBlbmQoaW5uZXIpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKG91dGVyKTtcbiAgICBjYWNoZWQgPSBvdXRlci5jbGllbnRXaWR0aCAtIGlubmVyLmNsaWVudFdpZHRoO1xuICAgIG91dGVyLnJlbW92ZSgpO1xuICB9XG4gIHJldHVybiBjYWNoZWQ7XG59XG4iLCIvKipcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFdoZXRoZXIgYSBjb250YWluZXIgbmVlZCBzY3JvbGwgYmFycyB3aGVuIGluIGFub3RoZXIgY29udGFpbmVyLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBuZWVkU2Nyb2xsQmFyKHtcbiAgd2lkdGgsXG4gIGhlaWdodCxcbiAgaW5uZXJIZWlnaHQsXG4gIGlubmVyV2lkdGgsXG4gIHNjcm9sbEJhclNpemUsXG59OiB7XG4gIHdpZHRoOiBudW1iZXI7XG4gIGhlaWdodDogbnVtYmVyO1xuICBpbm5lckhlaWdodDogbnVtYmVyO1xuICBzY3JvbGxCYXJTaXplOiBudW1iZXI7XG4gIGlubmVyV2lkdGg6IG51bWJlcjtcbn0pOiBbYm9vbGVhbiwgYm9vbGVhbl0ge1xuICBjb25zdCBoYXNWZXJ0aWNhbFNjcm9sbCA9IGlubmVySGVpZ2h0ID4gaGVpZ2h0O1xuICBjb25zdCBoYXNIb3Jpem9udGFsU2Nyb2xsID0gaW5uZXJXaWR0aCA+IHdpZHRoIC0gKGhhc1ZlcnRpY2FsU2Nyb2xsID8gc2Nyb2xsQmFyU2l6ZSA6IDApO1xuICByZXR1cm4gW2hhc1ZlcnRpY2FsU2Nyb2xsLCBoYXNIb3Jpem9udGFsU2Nyb2xsXTtcbn1cbiIsIi8qKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCwgdXNlUmVmLCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIEV4ZWN1dGUgYSBtZW1vaXplZCBjYWxsYmFjayBvbmx5IHdoZW4gbW91bnRlZC4gRXhlY3V0ZSBhZ2FpbiB3aGVuIGZhY3RvcnkgdXBkYXRlZC5cbiAqIFJldHVybnMgdW5kZWZpbmVkIGlmIG5vdCBtb3VudGVkIHlldC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXNlTW91bnRlZE1lbW88VD4oZmFjdG9yeTogKCkgPT4gVCwgZGVwcz86IHVua25vd25bXSk6IFQgfCB1bmRlZmluZWQge1xuICBjb25zdCBtb3VudGVkID0gdXNlUmVmPHR5cGVvZiBmYWN0b3J5PigpO1xuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIG1vdW50ZWQuY3VycmVudCA9IGZhY3Rvcnk7XG4gIH0pO1xuICByZXR1cm4gdXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKG1vdW50ZWQuY3VycmVudCkge1xuICAgICAgcmV0dXJuIGZhY3RvcnkoKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFttb3VudGVkLmN1cnJlbnQsIG1vdW50ZWQuY3VycmVudCA9PT0gZmFjdG9yeSwgLi4uKGRlcHMgfHwgW10pXSk7XG59XG4iLCIvKipcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgUmVhY3QsIHtcbiAgdXNlUmVmLFxuICB1c2VNZW1vLFxuICB1c2VMYXlvdXRFZmZlY3QsXG4gIHVzZUNhbGxiYWNrLFxuICBSZWFjdE5vZGUsXG4gIFJlYWN0RWxlbWVudCxcbiAgQ29tcG9uZW50UHJvcHNXaXRoUmVmLFxuICBDU1NQcm9wZXJ0aWVzLFxuICBVSUV2ZW50SGFuZGxlcixcbn0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgVGFibGVJbnN0YW5jZSwgSG9va3MgfSBmcm9tICdyZWFjdC10YWJsZSc7XG5pbXBvcnQgZ2V0U2Nyb2xsQmFyU2l6ZSBmcm9tICcuLi91dGlscy9nZXRTY3JvbGxCYXJTaXplJztcbmltcG9ydCBuZWVkU2Nyb2xsQmFyIGZyb20gJy4uL3V0aWxzL25lZWRTY3JvbGxCYXInO1xuaW1wb3J0IHVzZU1vdW50ZWRNZW1vIGZyb20gJy4uL3V0aWxzL3VzZU1vdW50ZWRNZW1vJztcblxudHlwZSBSZWFjdEVsZW1lbnRXaXRoQ2hpbGRyZW48XG4gIFQgZXh0ZW5kcyBrZXlvZiBKU1guSW50cmluc2ljRWxlbWVudHMsXG4gIEMgZXh0ZW5kcyBSZWFjdE5vZGUgPSBSZWFjdE5vZGVcbj4gPSBSZWFjdEVsZW1lbnQ8Q29tcG9uZW50UHJvcHNXaXRoUmVmPFQ+ICYgeyBjaGlsZHJlbjogQyB9LCBUPjtcblxudHlwZSBUaCA9IFJlYWN0RWxlbWVudFdpdGhDaGlsZHJlbjwndGgnPjtcbnR5cGUgVGQgPSBSZWFjdEVsZW1lbnRXaXRoQ2hpbGRyZW48J3RkJz47XG50eXBlIFRyV2l0aFRoID0gUmVhY3RFbGVtZW50V2l0aENoaWxkcmVuPCd0cicsIFRoW10+O1xudHlwZSBUcldpdGhUZCA9IFJlYWN0RWxlbWVudFdpdGhDaGlsZHJlbjwndHInLCBUZFtdPjtcbnR5cGUgVGhlYWQgPSBSZWFjdEVsZW1lbnRXaXRoQ2hpbGRyZW48J3RoZWFkJywgVHJXaXRoVGg+O1xudHlwZSBUYm9keSA9IFJlYWN0RWxlbWVudFdpdGhDaGlsZHJlbjwndGJvZHknLCBUcldpdGhUZD47XG50eXBlIENvbCA9IFJlYWN0RWxlbWVudFdpdGhDaGlsZHJlbjwnY29sJywgbnVsbD47XG50eXBlIENvbEdyb3VwID0gUmVhY3RFbGVtZW50V2l0aENoaWxkcmVuPCdjb2xncm91cCcsIENvbD47XG5cbmV4cG9ydCB0eXBlIFRhYmxlID0gUmVhY3RFbGVtZW50V2l0aENoaWxkcmVuPCd0YWJsZScsIChUaGVhZCB8IFRib2R5IHwgQ29sR3JvdXApW10+O1xuZXhwb3J0IHR5cGUgVGFibGVSZW5kZXJlciA9ICgpID0+IFRhYmxlO1xuZXhwb3J0IHR5cGUgR2V0VGFibGVTaXplID0gKCkgPT4gUGFydGlhbDxTdGlja3lTdGF0ZT4gfCB1bmRlZmluZWQ7XG5leHBvcnQgdHlwZSBTZXRTdGlja3lTdGF0ZSA9IChzaXplPzogUGFydGlhbDxTdGlja3lTdGF0ZT4pID0+IHZvaWQ7XG5cbmV4cG9ydCBlbnVtIFJlZHVjZXJBY3Rpb25zIHtcbiAgaW5pdCA9ICdpbml0JywgLy8gdGhpcyBpcyBmcm9tIGdsb2JhbCByZWR1Y2VyXG4gIHNldFN0aWNreVN0YXRlID0gJ3NldFN0aWNreVN0YXRlJyxcbn1cblxuZXhwb3J0IHR5cGUgUmVkdWNlckFjdGlvbjxUIGV4dGVuZHMgc3RyaW5nLCBQIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4+ID0gUCAmIHsgdHlwZTogVCB9O1xuXG5leHBvcnQgdHlwZSBDb2x1bW5XaWR0aHMgPSBudW1iZXJbXTtcblxuZXhwb3J0IGludGVyZmFjZSBTdGlja3lTdGF0ZSB7XG4gIHdpZHRoPzogbnVtYmVyOyAvLyBtYXhpbXVtIGZ1bGwgdGFibGUgd2lkdGhcbiAgaGVpZ2h0PzogbnVtYmVyOyAvLyBtYXhpbXVtIGZ1bGwgdGFibGUgaGVpZ2h0XG4gIHJlYWxIZWlnaHQ/OiBudW1iZXI7IC8vIGFjdHVhbCB0YWJsZSB2aWV3cG9ydCBoZWlnaHQgKGhlYWRlciArIHNjcm9sbGFibGUgYXJlYSlcbiAgYm9keUhlaWdodD86IG51bWJlcjsgLy8gc2Nyb2xsYWJsZSBhcmVhIGhlaWdodFxuICB0YWJsZUhlaWdodD86IG51bWJlcjsgLy8gdGhlIGZ1bGwgdGFibGUgaGVpZ2h0XG4gIGNvbHVtbldpZHRocz86IENvbHVtbldpZHRocztcbiAgaGFzSG9yaXpvbnRhbFNjcm9sbD86IGJvb2xlYW47XG4gIGhhc1ZlcnRpY2FsU2Nyb2xsPzogYm9vbGVhbjtcbiAgcmVuZGVyaW5nPzogYm9vbGVhbjtcbiAgc2V0U3RpY2t5U3RhdGU/OiBTZXRTdGlja3lTdGF0ZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VTdGlja3lUYWJsZU9wdGlvbnMge1xuICBnZXRUYWJsZVNpemU/OiBHZXRUYWJsZVNpemU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU3RpY2t5SW5zdGFuY2VQcm9wcyB7XG4gIC8vIG1hbmlwdWxhdGUgRE9NcyBpbiA8dGFibGU+IHRvIG1ha2UgdGhlIGhlYWRlciBzdGlja3lcbiAgd3JhcFN0aWNreVRhYmxlOiAocmVuZGVyZXI6IFRhYmxlUmVuZGVyZXIpID0+IFJlYWN0Tm9kZTtcbiAgLy8gdXBkYXRlIG9yIHJlY29tcHV0ZSB0aGUgc3RpY2t5IHRhYmxlIHNpemVcbiAgc2V0U3RpY2t5U3RhdGU6IFNldFN0aWNreVN0YXRlO1xufVxuXG5leHBvcnQgdHlwZSBVc2VTdGlja3lTdGF0ZSA9IHtcbiAgc3RpY2t5OiBTdGlja3lTdGF0ZTtcbn07XG5cbmNvbnN0IHN1bSA9IChhOiBudW1iZXIsIGI6IG51bWJlcikgPT4gYSArIGI7XG5jb25zdCBtZXJnZVN0eWxlUHJvcCA9IChub2RlOiBSZWFjdEVsZW1lbnQ8eyBzdHlsZT86IENTU1Byb3BlcnRpZXMgfT4sIHN0eWxlOiBDU1NQcm9wZXJ0aWVzKSA9PiAoe1xuICBzdHlsZToge1xuICAgIC4uLm5vZGUucHJvcHMuc3R5bGUsXG4gICAgLi4uc3R5bGUsXG4gIH0sXG59KTtcbmNvbnN0IGZpeGVkVGFibGVMYXlvdXQ6IENTU1Byb3BlcnRpZXMgPSB7IHRhYmxlTGF5b3V0OiAnZml4ZWQnIH07XG5cbi8qKlxuICogQW4gSE9DIGZvciBnZW5lcmF0aW5nIHN0aWNreSBoZWFkZXIgYW5kIGZpeGVkLWhlaWdodCBzY3JvbGxhYmxlIGFyZWFcbiAqL1xuZnVuY3Rpb24gU3RpY2t5V3JhcCh7XG4gIHN0aWNreSA9IHt9LFxuICB3aWR0aDogbWF4V2lkdGgsXG4gIGhlaWdodDogbWF4SGVpZ2h0LFxuICBjaGlsZHJlbjogdGFibGUsXG4gIHNldFN0aWNreVN0YXRlLFxufToge1xuICB3aWR0aDogbnVtYmVyO1xuICBoZWlnaHQ6IG51bWJlcjtcbiAgc2V0U3RpY2t5U3RhdGU6IFNldFN0aWNreVN0YXRlO1xuICBjaGlsZHJlbjogVGFibGU7XG4gIHN0aWNreT86IFN0aWNreVN0YXRlOyAvLyBjdXJyZW50IHN0aWNreSBlbGVtZW50IHNpemVzXG59KSB7XG4gIGlmICghdGFibGUgfHwgdGFibGUudHlwZSAhPT0gJ3RhYmxlJykge1xuICAgIHRocm93IG5ldyBFcnJvcignPFN0aWNreVdyYXA+IG11c3QgaGF2ZSBvbmx5IG9uZSA8dGFibGU+IGVsZW1lbnQgYXMgY2hpbGQnKTtcbiAgfVxuICBsZXQgdGhlYWQ6IFRoZWFkIHwgdW5kZWZpbmVkO1xuICBsZXQgdGJvZHk6IFRib2R5IHwgdW5kZWZpbmVkO1xuICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKHRhYmxlLnByb3BzLmNoaWxkcmVuLCBub2RlID0+IHtcbiAgICBpZiAobm9kZS50eXBlID09PSAndGhlYWQnKSB7XG4gICAgICB0aGVhZCA9IG5vZGU7XG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09ICd0Ym9keScpIHtcbiAgICAgIHRib2R5ID0gbm9kZTtcbiAgICB9XG4gIH0pO1xuICBpZiAoIXRoZWFkIHx8ICF0Ym9keSkge1xuICAgIHRocm93IG5ldyBFcnJvcignPHRhYmxlPiBpbiA8U3RpY2t5V3JhcD4gbXVzdCBjb250YWluIGJvdGggdGhlYWQgYW5kIHRib2R5LicpO1xuICB9XG4gIGNvbnN0IGNvbHVtbkNvdW50ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgaGVhZGVyUm93cyA9IFJlYWN0LkNoaWxkcmVuLnRvQXJyYXkodGhlYWQ/LnByb3BzLmNoaWxkcmVuKS5wb3AoKSBhcyBUcldpdGhUaDtcbiAgICByZXR1cm4gaGVhZGVyUm93cy5wcm9wcy5jaGlsZHJlbi5sZW5ndGg7XG4gIH0sIFt0aGVhZF0pO1xuXG4gIGNvbnN0IHRoZWFkUmVmID0gdXNlUmVmPEhUTUxUYWJsZVNlY3Rpb25FbGVtZW50PihudWxsKTsgLy8gb3JpZ2luYWwgdGhlYWQgZm9yIGxheW91dCBjb21wdXRhdGlvblxuICBjb25zdCBzY3JvbGxIZWFkZXJSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpOyAvLyBmaXhlZCBoZWFkZXJcbiAgY29uc3Qgc2Nyb2xsQm9keVJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCk7IC8vIG1haW4gYm9keVxuXG4gIGNvbnN0IHNjcm9sbEJhclNpemUgPSBnZXRTY3JvbGxCYXJTaXplKCk7XG4gIGNvbnN0IHsgYm9keUhlaWdodCwgY29sdW1uV2lkdGhzIH0gPSBzdGlja3k7XG4gIGNvbnN0IG5lZWRTaXplciA9XG4gICAgIWNvbHVtbldpZHRocyB8fFxuICAgIHN0aWNreS53aWR0aCAhPT0gbWF4V2lkdGggfHxcbiAgICBzdGlja3kuaGVpZ2h0ICE9PSBtYXhIZWlnaHQgfHxcbiAgICBzdGlja3kuc2V0U3RpY2t5U3RhdGUgIT09IHNldFN0aWNreVN0YXRlO1xuXG4gIC8vIHVwZGF0ZSBzY3JvbGxhYmxlIGFyZWEgYW5kIGhlYWRlciBjb2x1bW4gc2l6ZXMgd2hlbiBtb3VudGVkXG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHRoZWFkUmVmLmN1cnJlbnQpIHtcbiAgICAgIGNvbnN0IGJvZHlUaGVhZCA9IHRoZWFkUmVmLmN1cnJlbnQ7XG4gICAgICBjb25zdCB0aGVhZEhlaWdodCA9IGJvZHlUaGVhZC5jbGllbnRIZWlnaHQ7XG4gICAgICBpZiAoIXRoZWFkSGVpZ2h0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZ1bGxUYWJsZUhlaWdodCA9IChib2R5VGhlYWQucGFyZW50Tm9kZSBhcyBIVE1MVGFibGVFbGVtZW50KS5jbGllbnRIZWlnaHQ7XG4gICAgICBjb25zdCB0aHMgPSBib2R5VGhlYWQuY2hpbGROb2Rlc1swXS5jaGlsZE5vZGVzIGFzIE5vZGVMaXN0T2Y8SFRNTFRhYmxlSGVhZGVyQ2VsbEVsZW1lbnQ+O1xuICAgICAgY29uc3Qgd2lkdGhzID0gQXJyYXkuZnJvbSh0aHMpLm1hcCh0aCA9PiB0aC5jbGllbnRXaWR0aCk7XG4gICAgICBjb25zdCBbaGFzVmVydGljYWxTY3JvbGwsIGhhc0hvcml6b250YWxTY3JvbGxdID0gbmVlZFNjcm9sbEJhcih7XG4gICAgICAgIHdpZHRoOiBtYXhXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiBtYXhIZWlnaHQgLSB0aGVhZEhlaWdodCxcbiAgICAgICAgaW5uZXJIZWlnaHQ6IGZ1bGxUYWJsZUhlaWdodCxcbiAgICAgICAgaW5uZXJXaWR0aDogd2lkdGhzLnJlZHVjZShzdW0pLFxuICAgICAgICBzY3JvbGxCYXJTaXplLFxuICAgICAgfSk7XG4gICAgICAvLyByZWFsIGNvbnRhaW5lciBoZWlnaHQsIGluY2x1ZGUgdGFibGUgaGVhZGVyIGFuZCBzcGFjZSBmb3JcbiAgICAgIC8vIGhvcml6b250YWwgc2Nyb2xsIGJhclxuICAgICAgY29uc3QgcmVhbEhlaWdodCA9IE1hdGgubWluKFxuICAgICAgICBtYXhIZWlnaHQsXG4gICAgICAgIGhhc0hvcml6b250YWxTY3JvbGwgPyBmdWxsVGFibGVIZWlnaHQgKyBzY3JvbGxCYXJTaXplIDogZnVsbFRhYmxlSGVpZ2h0LFxuICAgICAgKTtcbiAgICAgIHNldFN0aWNreVN0YXRlKHtcbiAgICAgICAgaGFzVmVydGljYWxTY3JvbGwsXG4gICAgICAgIGhhc0hvcml6b250YWxTY3JvbGwsXG4gICAgICAgIHNldFN0aWNreVN0YXRlLFxuICAgICAgICB3aWR0aDogbWF4V2lkdGgsXG4gICAgICAgIGhlaWdodDogbWF4SGVpZ2h0LFxuICAgICAgICByZWFsSGVpZ2h0LFxuICAgICAgICB0YWJsZUhlaWdodDogZnVsbFRhYmxlSGVpZ2h0LFxuICAgICAgICBib2R5SGVpZ2h0OiByZWFsSGVpZ2h0IC0gdGhlYWRIZWlnaHQsXG4gICAgICAgIGNvbHVtbldpZHRoczogd2lkdGhzLFxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbbWF4V2lkdGgsIG1heEhlaWdodCwgc2V0U3RpY2t5U3RhdGUsIHNjcm9sbEJhclNpemVdKTtcblxuICBsZXQgc2l6ZXJUYWJsZTogUmVhY3RFbGVtZW50IHwgdW5kZWZpbmVkO1xuICBsZXQgaGVhZGVyVGFibGU6IFJlYWN0RWxlbWVudCB8IHVuZGVmaW5lZDtcbiAgbGV0IGJvZHlUYWJsZTogUmVhY3RFbGVtZW50IHwgdW5kZWZpbmVkO1xuICBpZiAobmVlZFNpemVyKSB7XG4gICAgY29uc3QgdGhlYWRXaXRoUmVmID0gUmVhY3QuY2xvbmVFbGVtZW50KHRoZWFkLCB7IHJlZjogdGhlYWRSZWYgfSk7XG4gICAgc2l6ZXJUYWJsZSA9IChcbiAgICAgIDxkaXZcbiAgICAgICAga2V5PVwic2l6ZXJcIlxuICAgICAgICBzdHlsZT17e1xuICAgICAgICAgIGhlaWdodDogbWF4SGVpZ2h0LFxuICAgICAgICAgIG92ZXJmbG93OiAnYXV0bycsXG4gICAgICAgICAgdmlzaWJpbGl0eTogJ2hpZGRlbicsXG4gICAgICAgIH19XG4gICAgICA+XG4gICAgICAgIHtSZWFjdC5jbG9uZUVsZW1lbnQodGFibGUsIHt9LCB0aGVhZFdpdGhSZWYsIHRib2R5KX1cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICAvLyByZXVzZSBwcmV2aW91c2x5IGNvbHVtbiB3aWR0aHMsIHdpbGwgYmUgdXBkYXRlZCBieSBgdXNlTGF5b3V0RWZmZWN0YCBhYm92ZVxuICBjb25zdCBjb2xXaWR0aHMgPSBjb2x1bW5XaWR0aHM/LnNsaWNlKDAsIGNvbHVtbkNvdW50KTtcblxuICBpZiAoY29sV2lkdGhzICYmIGJvZHlIZWlnaHQpIHtcbiAgICBjb25zdCBib2R5Q29sZ3JvdXAgPSAoXG4gICAgICA8Y29sZ3JvdXA+XG4gICAgICAgIHtjb2xXaWR0aHMubWFwKCh3LCBpKSA9PiAoXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L25vLWFycmF5LWluZGV4LWtleVxuICAgICAgICAgIDxjb2wga2V5PXtpfSB3aWR0aD17d30gLz5cbiAgICAgICAgKSl9XG4gICAgICA8L2NvbGdyb3VwPlxuICAgICk7XG5cbiAgICAvLyBoZWFkZXIgY29sdW1ucyBkbyBub3QgaGF2ZSB2ZXJ0aWNhbCBzY3JvbGwgYmFycyxcbiAgICAvLyBzbyB3ZSBhZGQgc2Nyb2xsIGJhciBzaXplIHRvIHRoZSBsYXN0IGNvbHVtblxuICAgIGNvbnN0IGhlYWRlckNvbGdyb3VwID1cbiAgICAgIHN0aWNreS5oYXNWZXJ0aWNhbFNjcm9sbCAmJiBzY3JvbGxCYXJTaXplID8gKFxuICAgICAgICA8Y29sZ3JvdXA+XG4gICAgICAgICAge2NvbFdpZHRocy5tYXAoKHgsIGkpID0+IChcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9uby1hcnJheS1pbmRleC1rZXlcbiAgICAgICAgICAgIDxjb2wga2V5PXtpfSB3aWR0aD17eCArIChpID09PSBjb2xXaWR0aHMubGVuZ3RoIC0gMSA/IHNjcm9sbEJhclNpemUgOiAwKX0gLz5cbiAgICAgICAgICApKX1cbiAgICAgICAgPC9jb2xncm91cD5cbiAgICAgICkgOiAoXG4gICAgICAgIGJvZHlDb2xncm91cFxuICAgICAgKTtcblxuICAgIGhlYWRlclRhYmxlID0gKFxuICAgICAgPGRpdlxuICAgICAgICBrZXk9XCJoZWFkZXJcIlxuICAgICAgICByZWY9e3Njcm9sbEhlYWRlclJlZn1cbiAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgIH19XG4gICAgICA+XG4gICAgICAgIHtSZWFjdC5jbG9uZUVsZW1lbnQodGFibGUsIG1lcmdlU3R5bGVQcm9wKHRhYmxlLCBmaXhlZFRhYmxlTGF5b3V0KSwgaGVhZGVyQ29sZ3JvdXAsIHRoZWFkKX1cbiAgICAgICAge2hlYWRlclRhYmxlfVxuICAgICAgPC9kaXY+XG4gICAgKTtcblxuICAgIGNvbnN0IG9uU2Nyb2xsOiBVSUV2ZW50SGFuZGxlcjxIVE1MRGl2RWxlbWVudD4gPSBlID0+IHtcbiAgICAgIGlmIChzY3JvbGxIZWFkZXJSZWYuY3VycmVudCkge1xuICAgICAgICBzY3JvbGxIZWFkZXJSZWYuY3VycmVudC5zY3JvbGxMZWZ0ID0gZS5jdXJyZW50VGFyZ2V0LnNjcm9sbExlZnQ7XG4gICAgICB9XG4gICAgfTtcbiAgICBib2R5VGFibGUgPSAoXG4gICAgICA8ZGl2XG4gICAgICAgIGtleT1cImJvZHlcIlxuICAgICAgICByZWY9e3Njcm9sbEJvZHlSZWZ9XG4gICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgaGVpZ2h0OiBib2R5SGVpZ2h0LFxuICAgICAgICAgIG92ZXJmbG93OiAnYXV0bycsXG4gICAgICAgIH19XG4gICAgICAgIG9uU2Nyb2xsPXtzdGlja3kuaGFzSG9yaXpvbnRhbFNjcm9sbCA/IG9uU2Nyb2xsIDogdW5kZWZpbmVkfVxuICAgICAgPlxuICAgICAgICB7UmVhY3QuY2xvbmVFbGVtZW50KHRhYmxlLCBtZXJnZVN0eWxlUHJvcCh0YWJsZSwgZml4ZWRUYWJsZUxheW91dCksIGJvZHlDb2xncm91cCwgdGJvZHkpfVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPGRpdlxuICAgICAgc3R5bGU9e3tcbiAgICAgICAgd2lkdGg6IG1heFdpZHRoLFxuICAgICAgICBoZWlnaHQ6IHN0aWNreS5yZWFsSGVpZ2h0IHx8IG1heEhlaWdodCxcbiAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgfX1cbiAgICA+XG4gICAgICB7aGVhZGVyVGFibGV9XG4gICAgICB7Ym9keVRhYmxlfVxuICAgICAge3NpemVyVGFibGV9XG4gICAgPC9kaXY+XG4gICk7XG59XG5cbmZ1bmN0aW9uIHVzZUluc3RhbmNlPEQgZXh0ZW5kcyBvYmplY3Q+KGluc3RhbmNlOiBUYWJsZUluc3RhbmNlPEQ+KSB7XG4gIGNvbnN0IHtcbiAgICBkaXNwYXRjaCxcbiAgICBzdGF0ZTogeyBzdGlja3kgfSxcbiAgICBkYXRhLFxuICAgIHBhZ2UsXG4gICAgcm93cyxcbiAgICBnZXRUYWJsZVNpemUgPSAoKSA9PiB1bmRlZmluZWQsXG4gIH0gPSBpbnN0YW5jZTtcblxuICBjb25zdCBzZXRTdGlja3lTdGF0ZSA9IHVzZUNhbGxiYWNrKFxuICAgIChzaXplPzogUGFydGlhbDxTdGlja3lTdGF0ZT4pID0+IHtcbiAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogUmVkdWNlckFjdGlvbnMuc2V0U3RpY2t5U3RhdGUsXG4gICAgICAgIHNpemUsXG4gICAgICB9KTtcbiAgICB9LFxuICAgIC8vIHR1cm5pbmcgcGFnZXMgd291bGQgYWxzbyB0cmlnZ2VyIGEgcmVzaXplXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIFtkaXNwYXRjaCwgZ2V0VGFibGVTaXplLCBwYWdlLCByb3dzXSxcbiAgKTtcblxuICBjb25zdCB1c2VTdGlja3lXcmFwID0gKHJlbmRlcmVyOiBUYWJsZVJlbmRlcmVyKSA9PiB7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSB1c2VNb3VudGVkTWVtbyhnZXRUYWJsZVNpemUsIFtnZXRUYWJsZVNpemVdKSB8fCBzdGlja3k7XG4gICAgLy8gb25seSBjaGFuZ2Ugb2YgZGF0YSBzaG91bGQgdHJpZ2dlciByZS1yZW5kZXJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgY29uc3QgdGFibGUgPSB1c2VNZW1vKHJlbmRlcmVyLCBbcGFnZSwgcm93c10pO1xuXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgIGlmICghd2lkdGggfHwgIWhlaWdodCkge1xuICAgICAgICBzZXRTdGlja3lTdGF0ZSgpO1xuICAgICAgfVxuICAgIH0sIFt3aWR0aCwgaGVpZ2h0XSk7XG5cbiAgICBpZiAoIXdpZHRoIHx8ICFoZWlnaHQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0YWJsZTtcbiAgICB9XG4gICAgcmV0dXJuIChcbiAgICAgIDxTdGlja3lXcmFwIHdpZHRoPXt3aWR0aH0gaGVpZ2h0PXtoZWlnaHR9IHN0aWNreT17c3RpY2t5fSBzZXRTdGlja3lTdGF0ZT17c2V0U3RpY2t5U3RhdGV9PlxuICAgICAgICB7dGFibGV9XG4gICAgICA8L1N0aWNreVdyYXA+XG4gICAgKTtcbiAgfTtcblxuICBPYmplY3QuYXNzaWduKGluc3RhbmNlLCB7XG4gICAgc2V0U3RpY2t5U3RhdGUsXG4gICAgd3JhcFN0aWNreVRhYmxlOiB1c2VTdGlja3lXcmFwLFxuICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXNlU3RpY2t5PEQgZXh0ZW5kcyBvYmplY3Q+KGhvb2tzOiBIb29rczxEPikge1xuICBob29rcy51c2VJbnN0YW5jZS5wdXNoKHVzZUluc3RhbmNlKTtcbiAgaG9va3Muc3RhdGVSZWR1Y2Vycy5wdXNoKChuZXdTdGF0ZSwgYWN0aW9uXywgcHJldlN0YXRlKSA9PiB7XG4gICAgY29uc3QgYWN0aW9uID0gYWN0aW9uXyBhcyBSZWR1Y2VyQWN0aW9uPFJlZHVjZXJBY3Rpb25zLCB7IHNpemU6IFN0aWNreVN0YXRlIH0+O1xuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gUmVkdWNlckFjdGlvbnMuaW5pdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubmV3U3RhdGUsXG4gICAgICAgIHN0aWNreToge1xuICAgICAgICAgIC4uLnByZXZTdGF0ZT8uc3RpY2t5LFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBSZWR1Y2VyQWN0aW9ucy5zZXRTdGlja3lTdGF0ZSkge1xuICAgICAgY29uc3QgeyBzaXplIH0gPSBhY3Rpb247XG4gICAgICBpZiAoIXNpemUpIHtcbiAgICAgICAgcmV0dXJuIHsgLi4ubmV3U3RhdGUgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm5ld1N0YXRlLFxuICAgICAgICBzdGlja3k6IHtcbiAgICAgICAgICAuLi5wcmV2U3RhdGU/LnN0aWNreSxcbiAgICAgICAgICAuLi5uZXdTdGF0ZT8uc3RpY2t5LFxuICAgICAgICAgIC4uLmFjdGlvbi5zaXplLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1N0YXRlO1xuICB9KTtcbn1cbnVzZVN0aWNreS5wbHVnaW5OYW1lID0gJ3VzZVN0aWNreSc7XG4iLCIvKipcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgUmVhY3QsIHtcbiAgdXNlQ2FsbGJhY2ssXG4gIHVzZVJlZixcbiAgUmVhY3ROb2RlLFxuICBIVE1MUHJvcHMsXG4gIE11dGFibGVSZWZPYmplY3QsXG4gIENTU1Byb3BlcnRpZXMsXG59IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7XG4gIHVzZVRhYmxlLFxuICB1c2VQYWdpbmF0aW9uLFxuICB1c2VTb3J0QnksXG4gIHVzZUdsb2JhbEZpbHRlcixcbiAgUGx1Z2luSG9vayxcbiAgVGFibGVPcHRpb25zLFxuICBGaWx0ZXJUeXBlLFxuICBJZFR5cGUsXG4gIFJvdyxcbn0gZnJvbSAncmVhY3QtdGFibGUnO1xuaW1wb3J0IHsgbWF0Y2hTb3J0ZXIsIHJhbmtpbmdzIH0gZnJvbSAnbWF0Y2gtc29ydGVyJztcbmltcG9ydCBHbG9iYWxGaWx0ZXIsIHsgR2xvYmFsRmlsdGVyUHJvcHMgfSBmcm9tICcuL2NvbXBvbmVudHMvR2xvYmFsRmlsdGVyJztcbmltcG9ydCBTZWxlY3RQYWdlU2l6ZSwgeyBTZWxlY3RQYWdlU2l6ZVByb3BzLCBTaXplT3B0aW9uIH0gZnJvbSAnLi9jb21wb25lbnRzL1NlbGVjdFBhZ2VTaXplJztcbmltcG9ydCBTaW1wbGVQYWdpbmF0aW9uIGZyb20gJy4vY29tcG9uZW50cy9QYWdpbmF0aW9uJztcbmltcG9ydCB1c2VTdGlja3kgZnJvbSAnLi9ob29rcy91c2VTdGlja3knO1xuaW1wb3J0IHsgUEFHRV9TSVpFX09QVElPTlMgfSBmcm9tICcuLi9jb25zdHMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIERhdGFUYWJsZVByb3BzPEQgZXh0ZW5kcyBvYmplY3Q+IGV4dGVuZHMgVGFibGVPcHRpb25zPEQ+IHtcbiAgdGFibGVDbGFzc05hbWU/OiBzdHJpbmc7XG4gIHNlYXJjaElucHV0PzogYm9vbGVhbiB8IEdsb2JhbEZpbHRlclByb3BzPEQ+WydzZWFyY2hJbnB1dCddO1xuICBzZWxlY3RQYWdlU2l6ZT86IGJvb2xlYW4gfCBTZWxlY3RQYWdlU2l6ZVByb3BzWydzZWxlY3RSZW5kZXJlciddO1xuICBwYWdlU2l6ZU9wdGlvbnM/OiBTaXplT3B0aW9uW107IC8vIGF2YWlsYWJsZSBwYWdlIHNpemUgb3B0aW9uc1xuICBtYXhQYWdlSXRlbUNvdW50PzogbnVtYmVyO1xuICBob29rcz86IFBsdWdpbkhvb2s8RD5bXTsgLy8gYW55IGFkZGl0aW9uYWwgaG9va3NcbiAgd2lkdGg/OiBzdHJpbmcgfCBudW1iZXI7XG4gIGhlaWdodD86IHN0cmluZyB8IG51bWJlcjtcbiAgc2VydmVyUGFnaW5hdGlvbj86IGJvb2xlYW47XG4gIG9uU2VydmVyUGFnaW5hdGlvbkNoYW5nZTogKHBhZ2VOdW1iZXI6IG51bWJlciwgcGFnZVNpemU6IG51bWJlcikgPT4gdm9pZDtcbiAgc2VydmVyUGFnaW5hdGlvbkRhdGE6IHsgcGFnZVNpemU/OiBudW1iZXI7IGN1cnJlbnRQYWdlPzogbnVtYmVyIH07XG4gIHBhZ2VTaXplPzogbnVtYmVyO1xuICBub1Jlc3VsdHM/OiBzdHJpbmcgfCAoKGZpbHRlclN0cmluZzogc3RyaW5nKSA9PiBSZWFjdE5vZGUpO1xuICBzdGlja3k/OiBib29sZWFuO1xuICByb3dDb3VudDogbnVtYmVyO1xuICB3cmFwcGVyUmVmPzogTXV0YWJsZVJlZk9iamVjdDxIVE1MRGl2RWxlbWVudD47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVuZGVySFRNTENlbGxQcm9wcyBleHRlbmRzIEhUTUxQcm9wczxIVE1MVGFibGVDZWxsRWxlbWVudD4ge1xuICBjZWxsQ29udGVudDogUmVhY3ROb2RlO1xufVxuXG4vLyBCZSBzdXJlIHRvIHBhc3Mgb3VyIHVwZGF0ZU15RGF0YSBhbmQgdGhlIHNraXBSZXNldCBvcHRpb25cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERhdGFUYWJsZTxEIGV4dGVuZHMgb2JqZWN0Pih7XG4gIHRhYmxlQ2xhc3NOYW1lLFxuICBjb2x1bW5zLFxuICBkYXRhLFxuICBzZXJ2ZXJQYWdpbmF0aW9uRGF0YSxcbiAgd2lkdGg6IGluaXRpYWxXaWR0aCA9ICcxMDAlJyxcbiAgaGVpZ2h0OiBpbml0aWFsSGVpZ2h0ID0gMzAwLFxuICBwYWdlU2l6ZTogaW5pdGlhbFBhZ2VTaXplID0gMCxcbiAgaW5pdGlhbFN0YXRlOiBpbml0aWFsU3RhdGVfID0ge30sXG4gIHBhZ2VTaXplT3B0aW9ucyA9IFBBR0VfU0laRV9PUFRJT05TLFxuICBtYXhQYWdlSXRlbUNvdW50ID0gOSxcbiAgc3RpY2t5OiBkb1N0aWNreSxcbiAgc2VhcmNoSW5wdXQgPSB0cnVlLFxuICBvblNlcnZlclBhZ2luYXRpb25DaGFuZ2UsXG4gIHJvd0NvdW50LFxuICBzZWxlY3RQYWdlU2l6ZSxcbiAgbm9SZXN1bHRzOiBub1Jlc3VsdHNUZXh0ID0gJ05vIGRhdGEgZm91bmQnLFxuICBob29rcyxcbiAgc2VydmVyUGFnaW5hdGlvbixcbiAgd3JhcHBlclJlZjogdXNlcldyYXBwZXJSZWYsXG4gIC4uLm1vcmVVc2VUYWJsZU9wdGlvbnNcbn06IERhdGFUYWJsZVByb3BzPEQ+KTogSlNYLkVsZW1lbnQge1xuICBjb25zdCB0YWJsZUhvb2tzOiBQbHVnaW5Ib29rPEQ+W10gPSBbXG4gICAgdXNlR2xvYmFsRmlsdGVyLFxuICAgIHVzZVNvcnRCeSxcbiAgICB1c2VQYWdpbmF0aW9uLFxuICAgIGRvU3RpY2t5ID8gdXNlU3RpY2t5IDogW10sXG4gICAgaG9va3MgfHwgW10sXG4gIF0uZmxhdCgpO1xuICBjb25zdCByZXN1bHRzU2l6ZSA9IHNlcnZlclBhZ2luYXRpb24gPyByb3dDb3VudCA6IGRhdGEubGVuZ3RoO1xuICBjb25zdCBzb3J0QnlSZWYgPSB1c2VSZWYoW10pOyAvLyBjYWNoZSBpbml0aWFsIGBzb3J0YnlgIHNvIHNvcnRpbmcgZG9lc24ndCB0cmlnZ2VyIHBhZ2UgcmVzZXRcbiAgY29uc3QgcGFnZVNpemVSZWYgPSB1c2VSZWYoW2luaXRpYWxQYWdlU2l6ZSwgcmVzdWx0c1NpemVdKTtcbiAgY29uc3QgaGFzUGFnaW5hdGlvbiA9IGluaXRpYWxQYWdlU2l6ZSA+IDAgJiYgcmVzdWx0c1NpemUgPiAwOyAvLyBwYWdlU2l6ZSA9PSAwIG1lYW5zIG5vIHBhZ2luYXRpb25cbiAgY29uc3QgaGFzR2xvYmFsQ29udHJvbCA9IGhhc1BhZ2luYXRpb24gfHwgISFzZWFyY2hJbnB1dDtcbiAgY29uc3QgaW5pdGlhbFN0YXRlID0ge1xuICAgIC4uLmluaXRpYWxTdGF0ZV8sXG4gICAgLy8gemVybyBsZW5ndGggbWVhbnMgYWxsIHBhZ2VzLCB0aGUgYHVzZVBhZ2luYXRpb25gIHBsdWdpbiBkb2VzIG5vdFxuICAgIC8vIHVuZGVyc3RhbmQgcGFnZVNpemUgPSAwXG4gICAgc29ydEJ5OiBzb3J0QnlSZWYuY3VycmVudCxcbiAgICBwYWdlU2l6ZTogaW5pdGlhbFBhZ2VTaXplID4gMCA/IGluaXRpYWxQYWdlU2l6ZSA6IHJlc3VsdHNTaXplIHx8IDEwLFxuICB9O1xuICBjb25zdCBkZWZhdWx0V3JhcHBlclJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCk7XG4gIGNvbnN0IGdsb2JhbENvbnRyb2xSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpO1xuICBjb25zdCBwYWdpbmF0aW9uUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTtcbiAgY29uc3Qgd3JhcHBlclJlZiA9IHVzZXJXcmFwcGVyUmVmIHx8IGRlZmF1bHRXcmFwcGVyUmVmO1xuICBjb25zdCBwYWdpbmF0aW9uRGF0YSA9IEpTT04uc3RyaW5naWZ5KHNlcnZlclBhZ2luYXRpb25EYXRhKTtcblxuICBjb25zdCBkZWZhdWx0R2V0VGFibGVTaXplID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmICh3cmFwcGVyUmVmLmN1cnJlbnQpIHtcbiAgICAgIC8vIGBpbml0aWFsV2lkdGhgIGFuZCBgaW5pdGlhbEhlaWdodGAgY291bGQgYmUgYWxzbyBwYXJhbWV0ZXJzIGxpa2UgYDEwMCVgXG4gICAgICAvLyBgTnVtYmVyYCByZWF0dXJucyBgTmFOYCBvbiB0aGVtLCB0aGVuIHdlIGZhbGxiYWNrIHRvIGNvbXB1dGVkIHNpemVcbiAgICAgIGNvbnN0IHdpZHRoID0gTnVtYmVyKGluaXRpYWxXaWR0aCkgfHwgd3JhcHBlclJlZi5jdXJyZW50LmNsaWVudFdpZHRoO1xuICAgICAgY29uc3QgaGVpZ2h0ID1cbiAgICAgICAgKE51bWJlcihpbml0aWFsSGVpZ2h0KSB8fCB3cmFwcGVyUmVmLmN1cnJlbnQuY2xpZW50SGVpZ2h0KSAtXG4gICAgICAgIChnbG9iYWxDb250cm9sUmVmLmN1cnJlbnQ/LmNsaWVudEhlaWdodCB8fCAwKSAtXG4gICAgICAgIChwYWdpbmF0aW9uUmVmLmN1cnJlbnQ/LmNsaWVudEhlaWdodCB8fCAwKTtcbiAgICAgIHJldHVybiB7IHdpZHRoLCBoZWlnaHQgfTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtcbiAgICBpbml0aWFsSGVpZ2h0LFxuICAgIGluaXRpYWxXaWR0aCxcbiAgICB3cmFwcGVyUmVmLFxuICAgIGhhc1BhZ2luYXRpb24sXG4gICAgaGFzR2xvYmFsQ29udHJvbCxcbiAgICBwYWdpbmF0aW9uUmVmLFxuICAgIHJlc3VsdHNTaXplLFxuICAgIHBhZ2luYXRpb25EYXRhLFxuICBdKTtcblxuICBjb25zdCBkZWZhdWx0R2xvYmFsRmlsdGVyOiBGaWx0ZXJUeXBlPEQ+ID0gdXNlQ2FsbGJhY2soXG4gICAgKHJvd3M6IFJvdzxEPltdLCBjb2x1bW5JZHM6IElkVHlwZTxEPltdLCBmaWx0ZXJWYWx1ZTogc3RyaW5nKSA9PiB7XG4gICAgICAvLyBhbGxvdyBzZWFyY2hpbmcgYnkgXCJjb2wxX3ZhbHVlIGNvbDJfdmFsdWVcIlxuICAgICAgY29uc3Qgam9pbmVkU3RyaW5nID0gKHJvdzogUm93PEQ+KSA9PiBjb2x1bW5JZHMubWFwKHggPT4gcm93LnZhbHVlc1t4XSkuam9pbignICcpO1xuICAgICAgcmV0dXJuIG1hdGNoU29ydGVyKHJvd3MsIGZpbHRlclZhbHVlLCB7XG4gICAgICAgIGtleXM6IFsuLi5jb2x1bW5JZHMsIGpvaW5lZFN0cmluZ10sXG4gICAgICAgIHRocmVzaG9sZDogcmFua2luZ3MuQUNST05ZTSxcbiAgICAgIH0pIGFzIHR5cGVvZiByb3dzO1xuICAgIH0sXG4gICAgW10sXG4gICk7XG5cbiAgY29uc3Qge1xuICAgIGdldFRhYmxlUHJvcHMsXG4gICAgZ2V0VGFibGVCb2R5UHJvcHMsXG4gICAgcHJlcGFyZVJvdyxcbiAgICBoZWFkZXJHcm91cHMsXG4gICAgcGFnZSxcbiAgICBwYWdlQ291bnQsXG4gICAgZ290b1BhZ2UsXG4gICAgcHJlR2xvYmFsRmlsdGVyZWRSb3dzLFxuICAgIHNldEdsb2JhbEZpbHRlcixcbiAgICBzZXRQYWdlU2l6ZTogc2V0UGFnZVNpemVfLFxuICAgIHdyYXBTdGlja3lUYWJsZSxcbiAgICBzdGF0ZTogeyBwYWdlSW5kZXgsIHBhZ2VTaXplLCBnbG9iYWxGaWx0ZXI6IGZpbHRlclZhbHVlLCBzdGlja3kgPSB7fSB9LFxuICB9ID0gdXNlVGFibGU8RD4oXG4gICAge1xuICAgICAgY29sdW1ucyxcbiAgICAgIGRhdGEsXG4gICAgICBpbml0aWFsU3RhdGUsXG4gICAgICBnZXRUYWJsZVNpemU6IGRlZmF1bHRHZXRUYWJsZVNpemUsXG4gICAgICBnbG9iYWxGaWx0ZXI6IGRlZmF1bHRHbG9iYWxGaWx0ZXIsXG4gICAgICAuLi5tb3JlVXNlVGFibGVPcHRpb25zLFxuICAgIH0sXG4gICAgLi4udGFibGVIb29rcyxcbiAgKTtcbiAgLy8gbWFrZSBzZXRQYWdlU2l6ZSBhY2NlcHQgMFxuICBjb25zdCBzZXRQYWdlU2l6ZSA9IChzaXplOiBudW1iZXIpID0+IHtcbiAgICBpZiAoc2VydmVyUGFnaW5hdGlvbikge1xuICAgICAgb25TZXJ2ZXJQYWdpbmF0aW9uQ2hhbmdlKDAsIHNpemUpO1xuICAgIH1cbiAgICAvLyBrZWVwIHRoZSBvcmlnaW5hbCBzaXplIGlmIGRhdGEgaXMgZW1wdHlcbiAgICBpZiAoc2l6ZSB8fCByZXN1bHRzU2l6ZSAhPT0gMCkge1xuICAgICAgc2V0UGFnZVNpemVfKHNpemUgPT09IDAgPyByZXN1bHRzU2l6ZSA6IHNpemUpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBub1Jlc3VsdHMgPVxuICAgIHR5cGVvZiBub1Jlc3VsdHNUZXh0ID09PSAnZnVuY3Rpb24nID8gbm9SZXN1bHRzVGV4dChmaWx0ZXJWYWx1ZSBhcyBzdHJpbmcpIDogbm9SZXN1bHRzVGV4dDtcblxuICBjb25zdCBnZXROb1Jlc3VsdHMgPSAoKSA9PiA8ZGl2IGNsYXNzTmFtZT1cImR0LW5vLXJlc3VsdHNcIj57bm9SZXN1bHRzfTwvZGl2PjtcblxuICBpZiAoIWNvbHVtbnMgfHwgY29sdW1ucy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gKHdyYXBTdGlja3lUYWJsZSA/IHdyYXBTdGlja3lUYWJsZShnZXROb1Jlc3VsdHMpIDogZ2V0Tm9SZXN1bHRzKCkpIGFzIEpTWC5FbGVtZW50O1xuICB9XG5cbiAgY29uc3QgcmVuZGVyVGFibGUgPSAoKSA9PiAoXG4gICAgPHRhYmxlIHsuLi5nZXRUYWJsZVByb3BzKHsgY2xhc3NOYW1lOiB0YWJsZUNsYXNzTmFtZSB9KX0+XG4gICAgICA8dGhlYWQ+XG4gICAgICAgIHtoZWFkZXJHcm91cHMubWFwKGhlYWRlckdyb3VwID0+IHtcbiAgICAgICAgICBjb25zdCB7IGtleTogaGVhZGVyR3JvdXBLZXksIC4uLmhlYWRlckdyb3VwUHJvcHMgfSA9IGhlYWRlckdyb3VwLmdldEhlYWRlckdyb3VwUHJvcHMoKTtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPHRyIGtleT17aGVhZGVyR3JvdXBLZXkgfHwgaGVhZGVyR3JvdXAuaWR9IHsuLi5oZWFkZXJHcm91cFByb3BzfT5cbiAgICAgICAgICAgICAge2hlYWRlckdyb3VwLmhlYWRlcnMubWFwKGNvbHVtbiA9PlxuICAgICAgICAgICAgICAgIGNvbHVtbi5yZW5kZXIoJ0hlYWRlcicsIHtcbiAgICAgICAgICAgICAgICAgIGtleTogY29sdW1uLmlkLFxuICAgICAgICAgICAgICAgICAgLi4uY29sdW1uLmdldFNvcnRCeVRvZ2dsZVByb3BzKCksXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICl9XG4gICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICk7XG4gICAgICAgIH0pfVxuICAgICAgPC90aGVhZD5cbiAgICAgIDx0Ym9keSB7Li4uZ2V0VGFibGVCb2R5UHJvcHMoKX0+XG4gICAgICAgIHtwYWdlICYmIHBhZ2UubGVuZ3RoID4gMCA/IChcbiAgICAgICAgICBwYWdlLm1hcChyb3cgPT4ge1xuICAgICAgICAgICAgcHJlcGFyZVJvdyhyb3cpO1xuICAgICAgICAgICAgY29uc3QgeyBrZXk6IHJvd0tleSwgLi4ucm93UHJvcHMgfSA9IHJvdy5nZXRSb3dQcm9wcygpO1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgPHRyIGtleT17cm93S2V5IHx8IHJvdy5pZH0gey4uLnJvd1Byb3BzfT5cbiAgICAgICAgICAgICAgICB7cm93LmNlbGxzLm1hcChjZWxsID0+IGNlbGwucmVuZGVyKCdDZWxsJywgeyBrZXk6IGNlbGwuY29sdW1uLmlkIH0pKX1cbiAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSlcbiAgICAgICAgKSA6IChcbiAgICAgICAgICA8dHI+XG4gICAgICAgICAgICA8dGQgY2xhc3NOYW1lPVwiZHQtbm8tcmVzdWx0c1wiIGNvbFNwYW49e2NvbHVtbnMubGVuZ3RofT5cbiAgICAgICAgICAgICAge25vUmVzdWx0c31cbiAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgPC90cj5cbiAgICAgICAgKX1cbiAgICAgIDwvdGJvZHk+XG4gICAgPC90YWJsZT5cbiAgKTtcblxuICAvLyBmb3JjZSB1cGRhdGUgdGhlIHBhZ2VTaXplIHdoZW4gaXQncyBiZWVuIHVwZGF0ZSBmcm9tIHRoZSBpbml0aWFsIHN0YXRlXG4gIGlmIChcbiAgICBwYWdlU2l6ZVJlZi5jdXJyZW50WzBdICE9PSBpbml0aWFsUGFnZVNpemUgfHxcbiAgICAvLyB3aGVuIGluaXRpYWxQYWdlU2l6ZSBzdGF5cyBhcyB6ZXJvLCBidXQgdG90YWwgbnVtYmVyIG9mIHJlY29yZHMgY2hhbmdlZCxcbiAgICAvLyB3ZSdkIGFsc28gbmVlZCB0byB1cGRhdGUgcGFnZSBzaXplXG4gICAgKGluaXRpYWxQYWdlU2l6ZSA9PT0gMCAmJiBwYWdlU2l6ZVJlZi5jdXJyZW50WzFdICE9PSByZXN1bHRzU2l6ZSlcbiAgKSB7XG4gICAgcGFnZVNpemVSZWYuY3VycmVudCA9IFtpbml0aWFsUGFnZVNpemUsIHJlc3VsdHNTaXplXTtcbiAgICBzZXRQYWdlU2l6ZShpbml0aWFsUGFnZVNpemUpO1xuICB9XG5cbiAgY29uc3QgcGFnaW5hdGlvblN0eWxlOiBDU1NQcm9wZXJ0aWVzID0gc3RpY2t5LmhlaWdodCA/IHt9IDogeyB2aXNpYmlsaXR5OiAnaGlkZGVuJyB9O1xuXG4gIGxldCByZXN1bHRQYWdlQ291bnQgPSBwYWdlQ291bnQ7XG4gIGxldCByZXN1bHRDdXJyZW50UGFnZVNpemUgPSBwYWdlU2l6ZTtcbiAgbGV0IHJlc3VsdEN1cnJlbnRQYWdlID0gcGFnZUluZGV4O1xuICBsZXQgcmVzdWx0T25QYWdlQ2hhbmdlOiAocGFnZTogbnVtYmVyKSA9PiB2b2lkID0gZ290b1BhZ2U7XG4gIGlmIChzZXJ2ZXJQYWdpbmF0aW9uKSB7XG4gICAgY29uc3Qgc2VydmVyUGFnZVNpemUgPSBzZXJ2ZXJQYWdpbmF0aW9uRGF0YS5wYWdlU2l6ZSA/PyBpbml0aWFsUGFnZVNpemU7XG4gICAgcmVzdWx0UGFnZUNvdW50ID0gTWF0aC5jZWlsKHJvd0NvdW50IC8gc2VydmVyUGFnZVNpemUpO1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHJlc3VsdFBhZ2VDb3VudCkpIHtcbiAgICAgIHJlc3VsdFBhZ2VDb3VudCA9IDA7XG4gICAgfVxuICAgIHJlc3VsdEN1cnJlbnRQYWdlU2l6ZSA9IHNlcnZlclBhZ2VTaXplO1xuICAgIGNvbnN0IGZvdW5kUGFnZVNpemVJbmRleCA9IHBhZ2VTaXplT3B0aW9ucy5maW5kSW5kZXgoXG4gICAgICAoW29wdGlvbl0pID0+IG9wdGlvbiA+PSByZXN1bHRDdXJyZW50UGFnZVNpemUsXG4gICAgKTtcbiAgICBpZiAoZm91bmRQYWdlU2l6ZUluZGV4ID09PSAtMSkge1xuICAgICAgcmVzdWx0Q3VycmVudFBhZ2VTaXplID0gMDtcbiAgICB9XG4gICAgcmVzdWx0Q3VycmVudFBhZ2UgPSBzZXJ2ZXJQYWdpbmF0aW9uRGF0YS5jdXJyZW50UGFnZSA/PyAwO1xuICAgIHJlc3VsdE9uUGFnZUNoYW5nZSA9IChwYWdlTnVtYmVyOiBudW1iZXIpID0+XG4gICAgICBvblNlcnZlclBhZ2luYXRpb25DaGFuZ2UocGFnZU51bWJlciwgc2VydmVyUGFnZVNpemUpO1xuICB9XG4gIHJldHVybiAoXG4gICAgPGRpdiByZWY9e3dyYXBwZXJSZWZ9IHN0eWxlPXt7IHdpZHRoOiBpbml0aWFsV2lkdGgsIGhlaWdodDogaW5pdGlhbEhlaWdodCB9fT5cbiAgICAgIHtoYXNHbG9iYWxDb250cm9sID8gKFxuICAgICAgICA8ZGl2IHJlZj17Z2xvYmFsQ29udHJvbFJlZn0gY2xhc3NOYW1lPVwiZm9ybS1pbmxpbmUgZHQtY29udHJvbHNcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInJvd1wiPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb2wtc20tNlwiPlxuICAgICAgICAgICAgICB7aGFzUGFnaW5hdGlvbiA/IChcbiAgICAgICAgICAgICAgICA8U2VsZWN0UGFnZVNpemVcbiAgICAgICAgICAgICAgICAgIHRvdGFsPXtyZXN1bHRzU2l6ZX1cbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQ9e3Jlc3VsdEN1cnJlbnRQYWdlU2l6ZX1cbiAgICAgICAgICAgICAgICAgIG9wdGlvbnM9e3BhZ2VTaXplT3B0aW9uc31cbiAgICAgICAgICAgICAgICAgIHNlbGVjdFJlbmRlcmVyPXt0eXBlb2Ygc2VsZWN0UGFnZVNpemUgPT09ICdib29sZWFuJyA/IHVuZGVmaW5lZCA6IHNlbGVjdFBhZ2VTaXplfVxuICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e3NldFBhZ2VTaXplfVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICkgOiBudWxsfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICB7c2VhcmNoSW5wdXQgPyAoXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29sLXNtLTZcIj5cbiAgICAgICAgICAgICAgICA8R2xvYmFsRmlsdGVyPEQ+XG4gICAgICAgICAgICAgICAgICBzZWFyY2hJbnB1dD17dHlwZW9mIHNlYXJjaElucHV0ID09PSAnYm9vbGVhbicgPyB1bmRlZmluZWQgOiBzZWFyY2hJbnB1dH1cbiAgICAgICAgICAgICAgICAgIHByZUdsb2JhbEZpbHRlcmVkUm93cz17cHJlR2xvYmFsRmlsdGVyZWRSb3dzfVxuICAgICAgICAgICAgICAgICAgc2V0R2xvYmFsRmlsdGVyPXtzZXRHbG9iYWxGaWx0ZXJ9XG4gICAgICAgICAgICAgICAgICBmaWx0ZXJWYWx1ZT17ZmlsdGVyVmFsdWV9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApIDogbnVsbH1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICApIDogbnVsbH1cbiAgICAgIHt3cmFwU3RpY2t5VGFibGUgPyB3cmFwU3RpY2t5VGFibGUocmVuZGVyVGFibGUpIDogcmVuZGVyVGFibGUoKX1cbiAgICAgIHtoYXNQYWdpbmF0aW9uICYmIHJlc3VsdFBhZ2VDb3VudCA+IDEgPyAoXG4gICAgICAgIDxTaW1wbGVQYWdpbmF0aW9uXG4gICAgICAgICAgcmVmPXtwYWdpbmF0aW9uUmVmfVxuICAgICAgICAgIHN0eWxlPXtwYWdpbmF0aW9uU3R5bGV9XG4gICAgICAgICAgbWF4UGFnZUl0ZW1Db3VudD17bWF4UGFnZUl0ZW1Db3VudH1cbiAgICAgICAgICBwYWdlQ291bnQ9e3Jlc3VsdFBhZ2VDb3VudH1cbiAgICAgICAgICBjdXJyZW50UGFnZT17cmVzdWx0Q3VycmVudFBhZ2V9XG4gICAgICAgICAgb25QYWdlQ2hhbmdlPXtyZXN1bHRPblBhZ2VDaGFuZ2V9XG4gICAgICAgIC8+XG4gICAgICApIDogbnVsbH1cbiAgICA8L2Rpdj5cbiAgKTtcbn1cbiIsImltcG9ydCB7IHN0eWxlZCB9IGZyb20gJ0BzdXBlcnNldC11aS9jb3JlJztcblxuZXhwb3J0IGRlZmF1bHQgc3R5bGVkLmRpdmBcbiAgdGFibGUge1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIG1pbi13aWR0aDogYXV0bztcbiAgICBtYXgtd2lkdGg6IG5vbmU7XG4gICAgbWFyZ2luOiAwO1xuICB9XG5cbiAgdGgsXG4gIHRkIHtcbiAgICBtaW4td2lkdGg6IDQuM2VtO1xuICB9XG5cbiAgdGhlYWQgPiB0ciA+IHRoIHtcbiAgICBwYWRkaW5nLXJpZ2h0OiAxLjRlbTtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgYmFja2dyb3VuZDogI2ZmZjtcbiAgfVxuICB0aCBzdmcge1xuICAgIGNvbG9yOiAjY2NjO1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBib3R0b206IDAuNmVtO1xuICAgIHJpZ2h0OiAwLjJlbTtcbiAgfVxuICB0aC5pcy1zb3J0ZWQgc3ZnIHtcbiAgICBjb2xvcjogI2E4YThhODtcbiAgfVxuICAudGFibGUgPiB0Ym9keSA+IHRyOmZpcnN0LW9mLXR5cGUgPiB0ZCxcbiAgLnRhYmxlID4gdGJvZHkgPiB0cjpmaXJzdC1vZi10eXBlID4gdGgge1xuICAgIGJvcmRlci10b3A6IDA7XG4gIH1cblxuICAuZHQtY29udHJvbHMge1xuICAgIHBhZGRpbmctYm90dG9tOiAwLjY1ZW07XG4gIH1cbiAgLmR0LW1ldHJpYyB7XG4gICAgdGV4dC1hbGlnbjogcmlnaHQ7XG4gIH1cbiAgLmR0LWlzLW51bGwge1xuICAgIGNvbG9yOiAkeyh7IHRoZW1lOiB7IGNvbG9ycyB9IH0pID0+IGNvbG9ycy5ncmF5c2NhbGUubGlnaHQxfTtcbiAgfVxuICB0ZC5kdC1pcy1maWx0ZXIge1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgfVxuICB0ZC5kdC1pcy1maWx0ZXI6aG92ZXIge1xuICAgIGJhY2tncm91bmQtY29sb3I6IGxpbmVuO1xuICB9XG4gIHRkLmR0LWlzLWFjdGl2ZS1maWx0ZXIsXG4gIHRkLmR0LWlzLWFjdGl2ZS1maWx0ZXI6aG92ZXIge1xuICAgIGJhY2tncm91bmQtY29sb3I6IGxpZ2h0Y3lhbjtcbiAgfVxuXG4gIC5kdC1nbG9iYWwtZmlsdGVyIHtcbiAgICBmbG9hdDogcmlnaHQ7XG4gIH1cblxuICAuZHQtcGFnaW5hdGlvbiB7XG4gICAgdGV4dC1hbGlnbjogcmlnaHQ7XG4gICAgLyogdXNlIHBhZGRpbmcgaW5zdGVhZCBvZiBtYXJnaW4gc28gY2xpZW50SGVpZ2h0IGNhbiBjYXB0dXJlIGl0ICovXG4gICAgcGFkZGluZy10b3A6IDAuNWVtO1xuICB9XG4gIC5kdC1wYWdpbmF0aW9uIC5wYWdpbmF0aW9uIHtcbiAgICBtYXJnaW46IDA7XG4gIH1cblxuICAucGFnaW5hdGlvbiA+IGxpID4gc3Bhbi5kdC1wYWdpbmF0aW9uLWVsbGlwc2lzOmZvY3VzLFxuICAucGFnaW5hdGlvbiA+IGxpID4gc3Bhbi5kdC1wYWdpbmF0aW9uLWVsbGlwc2lzOmhvdmVyIHtcbiAgICBiYWNrZ3JvdW5kOiAjZmZmO1xuICB9XG5cbiAgLmR0LW5vLXJlc3VsdHMge1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICBwYWRkaW5nOiAxZW0gMC42ZW07XG4gIH1cbmA7XG4iLCIvKipcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBGaWx0ZXJYU1MsIGdldERlZmF1bHRXaGl0ZUxpc3QgfSBmcm9tICd4c3MnO1xuaW1wb3J0IHsgRGF0YVJlY29yZFZhbHVlIH0gZnJvbSAnQHN1cGVyc2V0LXVpL2NvcmUnO1xuaW1wb3J0IHsgRGF0YUNvbHVtbk1ldGEgfSBmcm9tICcuLi90eXBlcyc7XG5cbmNvbnN0IHhzcyA9IG5ldyBGaWx0ZXJYU1Moe1xuICB3aGl0ZUxpc3Q6IHtcbiAgICAuLi5nZXREZWZhdWx0V2hpdGVMaXN0KCksXG4gICAgc3BhbjogWydzdHlsZScsICdjbGFzcycsICd0aXRsZSddLFxuICAgIGRpdjogWydzdHlsZScsICdjbGFzcyddLFxuICAgIGE6IFsnc3R5bGUnLCAnY2xhc3MnLCAnaHJlZicsICd0aXRsZScsICd0YXJnZXQnXSxcbiAgICBpbWc6IFsnc3R5bGUnLCAnY2xhc3MnLCAnc3JjJywgJ2FsdCcsICd0aXRsZScsICd3aWR0aCcsICdoZWlnaHQnXSxcbiAgfSxcbiAgc3RyaXBJZ25vcmVUYWc6IHRydWUsXG4gIGNzczogZmFsc2UsXG59KTtcblxuZnVuY3Rpb24gaXNQcm9iYWJseUhUTUwodGV4dDogc3RyaW5nKSB7XG4gIHJldHVybiAvPFtePl0rPi8udGVzdCh0ZXh0KTtcbn1cbi8qKlxuICogRm9ybWF0IHRleHQgZm9yIGNlbGwgdmFsdWUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZvcm1hdFZhbHVlKFxuICB7IGZvcm1hdHRlciB9OiBEYXRhQ29sdW1uTWV0YSxcbiAgdmFsdWU6IERhdGFSZWNvcmRWYWx1ZSxcbik6IFtib29sZWFuLCBzdHJpbmddIHtcbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFtmYWxzZSwgJ04vQSddO1xuICB9XG4gIGlmIChmb3JtYXR0ZXIpIHtcbiAgICAvLyBpbiBjYXNlIHBlcmNlbnQgbWV0cmljIGNhbiBzcGVjaWZ5IHBlcmNlbnQgZm9ybWF0IGluIHRoZSBmdXR1cmVcbiAgICByZXR1cm4gW2ZhbHNlLCBmb3JtYXR0ZXIodmFsdWUgYXMgbnVtYmVyKV07XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gaXNQcm9iYWJseUhUTUwodmFsdWUpID8gW3RydWUsIHhzcy5wcm9jZXNzKHZhbHVlKV0gOiBbZmFsc2UsIHZhbHVlXTtcbiAgfVxuICByZXR1cm4gW2ZhbHNlLCB2YWx1ZS50b1N0cmluZygpXTtcbn1cbiIsIi8qKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSwgdXNlTWVtbywgdXNlQ2FsbGJhY2ssIENTU1Byb3BlcnRpZXMgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBDb2x1bW5JbnN0YW5jZSwgRGVmYXVsdFNvcnRUeXBlcywgQ29sdW1uV2l0aExvb3NlQWNjZXNzb3IgfSBmcm9tICdyZWFjdC10YWJsZSc7XG5pbXBvcnQgeyBleHRlbnQgYXMgZDNFeHRlbnQsIG1heCBhcyBkM01heCB9IGZyb20gJ2QzLWFycmF5JztcbmltcG9ydCB7IEZhU29ydCwgRmFTb3J0VXAgYXMgRmFTb3J0QXNjLCBGYVNvcnREb3duIGFzIEZhU29ydERlc2MgfSBmcm9tICdyZWFjdC1pY29ucy9mYSc7XG5pbXBvcnQgeyB0LCB0biwgRGF0YVJlY29yZFZhbHVlLCBEYXRhUmVjb3JkLCBHZW5lcmljRGF0YVR5cGUgfSBmcm9tICdAc3VwZXJzZXQtdWkvY29yZSc7XG5cbmltcG9ydCB7IFRhYmxlQ2hhcnRUcmFuc2Zvcm1lZFByb3BzLCBEYXRhQ29sdW1uTWV0YSB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IERhdGFUYWJsZSwge1xuICBEYXRhVGFibGVQcm9wcyxcbiAgU2VhcmNoSW5wdXRQcm9wcyxcbiAgU2VsZWN0UGFnZVNpemVSZW5kZXJlclByb3BzLFxuICBTaXplT3B0aW9uLFxufSBmcm9tICcuL0RhdGFUYWJsZSc7XG5cbmltcG9ydCBTdHlsZXMgZnJvbSAnLi9TdHlsZXMnO1xuaW1wb3J0IGZvcm1hdFZhbHVlIGZyb20gJy4vdXRpbHMvZm9ybWF0VmFsdWUnO1xuaW1wb3J0IHsgUEFHRV9TSVpFX09QVElPTlMgfSBmcm9tICcuL2NvbnN0cyc7XG5pbXBvcnQgeyB1cGRhdGVFeHRlcm5hbEZvcm1EYXRhIH0gZnJvbSAnLi9EYXRhVGFibGUvdXRpbHMvZXh0ZXJuYWxBUElzJztcblxudHlwZSBWYWx1ZVJhbmdlID0gW251bWJlciwgbnVtYmVyXTtcblxuLyoqXG4gKiBSZXR1cm4gc29ydFR5cGUgYmFzZWQgb24gZGF0YSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGdldFNvcnRUeXBlQnlEYXRhVHlwZShkYXRhVHlwZTogR2VuZXJpY0RhdGFUeXBlKTogRGVmYXVsdFNvcnRUeXBlcyB7XG4gIGlmIChkYXRhVHlwZSA9PT0gR2VuZXJpY0RhdGFUeXBlLlRFTVBPUkFMKSB7XG4gICAgcmV0dXJuICdkYXRldGltZSc7XG4gIH1cbiAgaWYgKGRhdGFUeXBlID09PSBHZW5lcmljRGF0YVR5cGUuU1RSSU5HKSB7XG4gICAgcmV0dXJuICdhbHBoYW51bWVyaWMnO1xuICB9XG4gIHJldHVybiAnYmFzaWMnO1xufVxuXG4vKipcbiAqIENlbGwgYmFja2dyb3VuZCB0byByZW5kZXIgY29sdW1ucyBhcyBob3Jpem9udGFsIGJhciBjaGFydFxuICovXG5mdW5jdGlvbiBjZWxsQmFyKHtcbiAgdmFsdWUsXG4gIHZhbHVlUmFuZ2UsXG4gIGNvbG9yUG9zaXRpdmVOZWdhdGl2ZSA9IGZhbHNlLFxuICBhbGlnblBvc2l0aXZlTmVnYXRpdmUsXG59OiB7XG4gIHZhbHVlOiBudW1iZXI7XG4gIHZhbHVlUmFuZ2U6IFZhbHVlUmFuZ2U7XG4gIGNvbG9yUG9zaXRpdmVOZWdhdGl2ZTogYm9vbGVhbjtcbiAgYWxpZ25Qb3NpdGl2ZU5lZ2F0aXZlOiBib29sZWFuO1xufSkge1xuICBjb25zdCBbbWluVmFsdWUsIG1heFZhbHVlXSA9IHZhbHVlUmFuZ2U7XG4gIGNvbnN0IHIgPSBjb2xvclBvc2l0aXZlTmVnYXRpdmUgJiYgdmFsdWUgPCAwID8gMTUwIDogMDtcbiAgaWYgKGFsaWduUG9zaXRpdmVOZWdhdGl2ZSkge1xuICAgIGNvbnN0IHBlcmMgPSBNYXRoLmFicyhNYXRoLnJvdW5kKCh2YWx1ZSAvIG1heFZhbHVlKSAqIDEwMCkpO1xuICAgIC8vIFRoZSAwLjAxIHRvIDAuMDAxIGlzIGEgd29ya2Fyb3VuZCBmb3Igd2hhdCBhcHBlYXJzIHRvIGJlIGFcbiAgICAvLyBDU1MgcmVuZGVyaW5nIGJ1ZyBvbiBmbGF0LCB0cmFuc3BhcmVudCBjb2xvcnNcbiAgICByZXR1cm4gKFxuICAgICAgYGxpbmVhci1ncmFkaWVudCh0byByaWdodCwgcmdiYSgke3J9LDAsMCwwLjIpLCByZ2JhKCR7cn0sMCwwLDAuMikgJHtwZXJjfSUsIGAgK1xuICAgICAgYHJnYmEoMCwwLDAsMC4wMSkgJHtwZXJjfSUsIHJnYmEoMCwwLDAsMC4wMDEpIDEwMCUpYFxuICAgICk7XG4gIH1cbiAgY29uc3QgcG9zRXh0ZW50ID0gTWF0aC5hYnMoTWF0aC5tYXgobWF4VmFsdWUsIDApKTtcbiAgY29uc3QgbmVnRXh0ZW50ID0gTWF0aC5hYnMoTWF0aC5taW4obWluVmFsdWUsIDApKTtcbiAgY29uc3QgdG90ID0gcG9zRXh0ZW50ICsgbmVnRXh0ZW50O1xuICBjb25zdCBwZXJjMSA9IE1hdGgucm91bmQoKE1hdGgubWluKG5lZ0V4dGVudCArIHZhbHVlLCBuZWdFeHRlbnQpIC8gdG90KSAqIDEwMCk7XG4gIGNvbnN0IHBlcmMyID0gTWF0aC5yb3VuZCgoTWF0aC5hYnModmFsdWUpIC8gdG90KSAqIDEwMCk7XG4gIC8vIFRoZSAwLjAxIHRvIDAuMDAxIGlzIGEgd29ya2Fyb3VuZCBmb3Igd2hhdCBhcHBlYXJzIHRvIGJlIGFcbiAgLy8gQ1NTIHJlbmRlcmluZyBidWcgb24gZmxhdCwgdHJhbnNwYXJlbnQgY29sb3JzXG4gIHJldHVybiAoXG4gICAgYGxpbmVhci1ncmFkaWVudCh0byByaWdodCwgcmdiYSgwLDAsMCwwLjAxKSwgcmdiYSgwLDAsMCwwLjAwMSkgJHtwZXJjMX0lLCBgICtcbiAgICBgcmdiYSgke3J9LDAsMCwwLjIpICR7cGVyYzF9JSwgcmdiYSgke3J9LDAsMCwwLjIpICR7cGVyYzEgKyBwZXJjMn0lLCBgICtcbiAgICBgcmdiYSgwLDAsMCwwLjAxKSAke3BlcmMxICsgcGVyYzJ9JSwgcmdiYSgwLDAsMCwwLjAwMSkgMTAwJSlgXG4gICk7XG59XG5cbmZ1bmN0aW9uIFNvcnRJY29uPEQgZXh0ZW5kcyBvYmplY3Q+KHsgY29sdW1uIH06IHsgY29sdW1uOiBDb2x1bW5JbnN0YW5jZTxEPiB9KSB7XG4gIGNvbnN0IHsgaXNTb3J0ZWQsIGlzU29ydGVkRGVzYyB9ID0gY29sdW1uO1xuICBsZXQgc29ydEljb24gPSA8RmFTb3J0IC8+O1xuICBpZiAoaXNTb3J0ZWQpIHtcbiAgICBzb3J0SWNvbiA9IGlzU29ydGVkRGVzYyA/IDxGYVNvcnREZXNjIC8+IDogPEZhU29ydEFzYyAvPjtcbiAgfVxuICByZXR1cm4gc29ydEljb247XG59XG5cbmZ1bmN0aW9uIFNlYXJjaElucHV0KHsgY291bnQsIHZhbHVlLCBvbkNoYW5nZSB9OiBTZWFyY2hJbnB1dFByb3BzKSB7XG4gIHJldHVybiAoXG4gICAgPHNwYW4gY2xhc3NOYW1lPVwiZHQtZ2xvYmFsLWZpbHRlclwiPlxuICAgICAge3QoJ1NlYXJjaCcpfXsnICd9XG4gICAgICA8aW5wdXRcbiAgICAgICAgY2xhc3NOYW1lPVwiZm9ybS1jb250cm9sIGlucHV0LXNtXCJcbiAgICAgICAgcGxhY2Vob2xkZXI9e3RuKCdzZWFyY2gubnVtX3JlY29yZHMnLCBjb3VudCl9XG4gICAgICAgIHZhbHVlPXt2YWx1ZX1cbiAgICAgICAgb25DaGFuZ2U9e29uQ2hhbmdlfVxuICAgICAgLz5cbiAgICA8L3NwYW4+XG4gICk7XG59XG5cbmZ1bmN0aW9uIFNlbGVjdFBhZ2VTaXplKHsgb3B0aW9ucywgY3VycmVudCwgb25DaGFuZ2UgfTogU2VsZWN0UGFnZVNpemVSZW5kZXJlclByb3BzKSB7XG4gIHJldHVybiAoXG4gICAgPHNwYW4gY2xhc3NOYW1lPVwiZHQtc2VsZWN0LXBhZ2Utc2l6ZSBmb3JtLWlubGluZVwiPlxuICAgICAge3QoJ3BhZ2Vfc2l6ZS5zaG93Jyl9eycgJ31cbiAgICAgIDxzZWxlY3RcbiAgICAgICAgY2xhc3NOYW1lPVwiZm9ybS1jb250cm9sIGlucHV0LXNtXCJcbiAgICAgICAgdmFsdWU9e2N1cnJlbnR9XG4gICAgICAgIG9uQmx1cj17KCkgPT4ge319XG4gICAgICAgIG9uQ2hhbmdlPXtlID0+IHtcbiAgICAgICAgICBvbkNoYW5nZShOdW1iZXIoKGUudGFyZ2V0IGFzIEhUTUxTZWxlY3RFbGVtZW50KS52YWx1ZSkpO1xuICAgICAgICB9fVxuICAgICAgPlxuICAgICAgICB7b3B0aW9ucy5tYXAob3B0aW9uID0+IHtcbiAgICAgICAgICBjb25zdCBbc2l6ZSwgdGV4dF0gPSBBcnJheS5pc0FycmF5KG9wdGlvbikgPyBvcHRpb24gOiBbb3B0aW9uLCBvcHRpb25dO1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8b3B0aW9uIGtleT17c2l6ZX0gdmFsdWU9e3NpemV9PlxuICAgICAgICAgICAgICB7dGV4dH1cbiAgICAgICAgICAgIDwvb3B0aW9uPlxuICAgICAgICAgICk7XG4gICAgICAgIH0pfVxuICAgICAgPC9zZWxlY3Q+eycgJ31cbiAgICAgIHt0KCdwYWdlX3NpemUuZW50cmllcycpfVxuICAgIDwvc3Bhbj5cbiAgKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gVGFibGVDaGFydDxEIGV4dGVuZHMgRGF0YVJlY29yZCA9IERhdGFSZWNvcmQ+KFxuICBwcm9wczogVGFibGVDaGFydFRyYW5zZm9ybWVkUHJvcHM8RD4gJiB7XG4gICAgc3RpY2t5PzogRGF0YVRhYmxlUHJvcHM8RD5bJ3N0aWNreSddO1xuICB9LFxuKSB7XG4gIGNvbnN0IHtcbiAgICBoZWlnaHQsXG4gICAgd2lkdGgsXG4gICAgZGF0YSxcbiAgICBpc1Jhd1JlY29yZHMsXG4gICAgcm93Q291bnQgPSAwLFxuICAgIGNvbHVtbnM6IGNvbHVtbnNNZXRhLFxuICAgIGFsaWduUG9zaXRpdmVOZWdhdGl2ZTogZGVmYXVsdEFsaWduUE4gPSBmYWxzZSxcbiAgICBjb2xvclBvc2l0aXZlTmVnYXRpdmU6IGRlZmF1bHRDb2xvclBOID0gZmFsc2UsXG4gICAgaW5jbHVkZVNlYXJjaCA9IGZhbHNlLFxuICAgIHBhZ2VTaXplID0gMCxcbiAgICBzZXJ2ZXJQYWdpbmF0aW9uID0gZmFsc2UsXG4gICAgc2VydmVyUGFnaW5hdGlvbkRhdGEsXG4gICAgc2V0RGF0YU1hc2ssXG4gICAgc2hvd0NlbGxCYXJzID0gdHJ1ZSxcbiAgICBlbWl0RmlsdGVyID0gZmFsc2UsXG4gICAgc29ydERlc2MgPSBmYWxzZSxcbiAgICBvbkNoYW5nZUZpbHRlcixcbiAgICBmaWx0ZXJzOiBpbml0aWFsRmlsdGVycyxcbiAgICBzdGlja3kgPSB0cnVlLCAvLyB3aGV0aGVyIHRvIHVzZSBzdGlja3kgaGVhZGVyXG4gIH0gPSBwcm9wcztcblxuICBjb25zdCBbZmlsdGVycywgc2V0RmlsdGVyc10gPSB1c2VTdGF0ZShpbml0aWFsRmlsdGVycyk7XG5cbiAgLy8gb25seSB0YWtlIHJlbGV2YW50IHBhZ2Ugc2l6ZSBvcHRpb25zXG4gIGNvbnN0IHBhZ2VTaXplT3B0aW9ucyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IGdldFNlcnZlclBhZ2luYXRpb24gPSAobjogbnVtYmVyKSA9PiBuIDw9IHJvd0NvdW50O1xuICAgIHJldHVybiBQQUdFX1NJWkVfT1BUSU9OUy5maWx0ZXIoKFtuXSkgPT5cbiAgICAgIHNlcnZlclBhZ2luYXRpb24gPyBnZXRTZXJ2ZXJQYWdpbmF0aW9uKG4pIDogbiA8PSAyICogZGF0YS5sZW5ndGgsXG4gICAgKSBhcyBTaXplT3B0aW9uW107XG4gIH0sIFtkYXRhLmxlbmd0aCwgcm93Q291bnQsIHNlcnZlclBhZ2luYXRpb25dKTtcblxuICBjb25zdCBnZXRWYWx1ZVJhbmdlID0gdXNlQ2FsbGJhY2soXG4gICAgZnVuY3Rpb24gZ2V0VmFsdWVSYW5nZShrZXk6IHN0cmluZywgYWxpZ25Qb3NpdGl2ZU5lZ2F0aXZlOiBib29sZWFuKSB7XG4gICAgICBpZiAodHlwZW9mIGRhdGE/LlswXT8uW2tleV0gPT09ICdudW1iZXInKSB7XG4gICAgICAgIGNvbnN0IG51bXMgPSBkYXRhLm1hcChyb3cgPT4gcm93W2tleV0pIGFzIG51bWJlcltdO1xuICAgICAgICByZXR1cm4gKGFsaWduUG9zaXRpdmVOZWdhdGl2ZVxuICAgICAgICAgID8gWzAsIGQzTWF4KG51bXMubWFwKE1hdGguYWJzKSldXG4gICAgICAgICAgOiBkM0V4dGVudChudW1zKSkgYXMgVmFsdWVSYW5nZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgW2RhdGFdLFxuICApO1xuXG4gIGNvbnN0IGlzQWN0aXZlRmlsdGVyVmFsdWUgPSB1c2VDYWxsYmFjayhcbiAgICBmdW5jdGlvbiBpc0FjdGl2ZUZpbHRlclZhbHVlKGtleTogc3RyaW5nLCB2YWw6IERhdGFSZWNvcmRWYWx1ZSkge1xuICAgICAgcmV0dXJuICEhZmlsdGVycyAmJiBmaWx0ZXJzW2tleV0/LmluY2x1ZGVzKHZhbCk7XG4gICAgfSxcbiAgICBbZmlsdGVyc10sXG4gICk7XG5cbiAgY29uc3QgdG9nZ2xlRmlsdGVyID0gdXNlQ2FsbGJhY2soXG4gICAgZnVuY3Rpb24gdG9nZ2xlRmlsdGVyKGtleTogc3RyaW5nLCB2YWw6IERhdGFSZWNvcmRWYWx1ZSkge1xuICAgICAgY29uc3QgdXBkYXRlZEZpbHRlcnMgPSB7IC4uLihmaWx0ZXJzIHx8IHt9KSB9O1xuICAgICAgaWYgKGZpbHRlcnMgJiYgaXNBY3RpdmVGaWx0ZXJWYWx1ZShrZXksIHZhbCkpIHtcbiAgICAgICAgdXBkYXRlZEZpbHRlcnNba2V5XSA9IGZpbHRlcnNba2V5XS5maWx0ZXIoKHg6IERhdGFSZWNvcmRWYWx1ZSkgPT4geCAhPT0gdmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVwZGF0ZWRGaWx0ZXJzW2tleV0gPSBbLi4uKGZpbHRlcnM/LltrZXldIHx8IFtdKSwgdmFsXTtcbiAgICAgIH1cbiAgICAgIHNldEZpbHRlcnModXBkYXRlZEZpbHRlcnMpO1xuICAgICAgaWYgKG9uQ2hhbmdlRmlsdGVyKSB7XG4gICAgICAgIG9uQ2hhbmdlRmlsdGVyKHVwZGF0ZWRGaWx0ZXJzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtmaWx0ZXJzLCBpc0FjdGl2ZUZpbHRlclZhbHVlLCBvbkNoYW5nZUZpbHRlcl0sXG4gICk7XG5cbiAgY29uc3QgZ2V0Q29sdW1uQ29uZmlncyA9IHVzZUNhbGxiYWNrKFxuICAgIChjb2x1bW46IERhdGFDb2x1bW5NZXRhLCBpOiBudW1iZXIpOiBDb2x1bW5XaXRoTG9vc2VBY2Nlc3NvcjxEPiA9PiB7XG4gICAgICBjb25zdCB7IGtleSwgbGFiZWwsIGRhdGFUeXBlLCBpc01ldHJpYywgY29uZmlnID0ge30gfSA9IGNvbHVtbjtcbiAgICAgIGNvbnN0IGlzTnVtYmVyID0gZGF0YVR5cGUgPT09IEdlbmVyaWNEYXRhVHlwZS5OVU1FUklDO1xuICAgICAgY29uc3QgaXNGaWx0ZXIgPSAhaXNOdW1iZXIgJiYgZW1pdEZpbHRlcjtcbiAgICAgIGNvbnN0IHRleHRBbGlnbiA9IGNvbmZpZy5ob3Jpem9udGFsQWxpZ25cbiAgICAgICAgPyBjb25maWcuaG9yaXpvbnRhbEFsaWduXG4gICAgICAgIDogaXNOdW1iZXJcbiAgICAgICAgPyAncmlnaHQnXG4gICAgICAgIDogJ2xlZnQnO1xuICAgICAgY29uc3QgY29sdW1uV2lkdGggPSBOdW1iZXIuaXNOYU4oTnVtYmVyKGNvbmZpZy5jb2x1bW5XaWR0aCkpXG4gICAgICAgID8gY29uZmlnLmNvbHVtbldpZHRoXG4gICAgICAgIDogTnVtYmVyKGNvbmZpZy5jb2x1bW5XaWR0aCk7XG4gICAgICBjb25zdCBhbGlnblBvc2l0aXZlTmVnYXRpdmUgPVxuICAgICAgICBjb25maWcuYWxpZ25Qb3NpdGl2ZU5lZ2F0aXZlID09PSB1bmRlZmluZWQgPyBkZWZhdWx0QWxpZ25QTiA6IGNvbmZpZy5hbGlnblBvc2l0aXZlTmVnYXRpdmU7XG4gICAgICBjb25zdCBjb2xvclBvc2l0aXZlTmVnYXRpdmUgPVxuICAgICAgICBjb25maWcuY29sb3JQb3NpdGl2ZU5lZ2F0aXZlID09PSB1bmRlZmluZWQgPyBkZWZhdWx0Q29sb3JQTiA6IGNvbmZpZy5jb2xvclBvc2l0aXZlTmVnYXRpdmU7XG4gICAgICBjb25zdCBmcmFjdGlvbkRpZ2l0cyA9IGlzTnVtYmVyID8gY29uZmlnLmZyYWN0aW9uRGlnaXRzIDogdW5kZWZpbmVkO1xuXG4gICAgICBjb25zdCB2YWx1ZVJhbmdlID1cbiAgICAgICAgKGNvbmZpZy5zaG93Q2VsbEJhcnMgPT09IHVuZGVmaW5lZCA/IHNob3dDZWxsQmFycyA6IGNvbmZpZy5zaG93Q2VsbEJhcnMpICYmXG4gICAgICAgIChpc01ldHJpYyB8fCBpc1Jhd1JlY29yZHMpICYmXG4gICAgICAgIGdldFZhbHVlUmFuZ2Uoa2V5LCBhbGlnblBvc2l0aXZlTmVnYXRpdmUpO1xuXG4gICAgICBsZXQgY2xhc3NOYW1lID0gJyc7XG4gICAgICBpZiAoaXNGaWx0ZXIpIHtcbiAgICAgICAgY2xhc3NOYW1lICs9ICcgZHQtaXMtZmlsdGVyJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IFN0cmluZyhpKSwgLy8gdG8gYWxsb3cgZHVwbGljYXRlIGNvbHVtbiBrZXlzXG4gICAgICAgIC8vIG11c3QgdXNlIGN1c3RvbSBhY2Nlc3NvciB0byBhbGxvdyBgLmAgaW4gY29sdW1uIG5hbWVzXG4gICAgICAgIC8vIHR5cGluZyBpcyBpbmNvcnJlY3QgaW4gY3VycmVudCB2ZXJzaW9uIG9mIGBAdHlwZXMvcmVhY3QtdGFibGVgXG4gICAgICAgIC8vIHNvIHdlIGFzayBUUyBub3QgdG8gY2hlY2suXG4gICAgICAgIGFjY2Vzc29yOiAoKGRhdHVtOiBEKSA9PiBkYXR1bVtrZXldKSBhcyBuZXZlcixcbiAgICAgICAgQ2VsbDogKHsgdmFsdWUgfTogeyBjb2x1bW46IENvbHVtbkluc3RhbmNlPEQ+OyB2YWx1ZTogRGF0YVJlY29yZFZhbHVlIH0pID0+IHtcbiAgICAgICAgICBsZXQgcm91bmRlZCA9IHZhbHVlO1xuICAgICAgICAgIGlmIChmcmFjdGlvbkRpZ2l0cyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJvdW5kZWQgPSBOdW1iZXIodmFsdWUudG9GaXhlZChmcmFjdGlvbkRpZ2l0cykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBbaXNIdG1sLCB0ZXh0XSA9IGZvcm1hdFZhbHVlKGNvbHVtbiwgcm91bmRlZCk7XG4gICAgICAgICAgY29uc3QgaHRtbCA9IGlzSHRtbCA/IHsgX19odG1sOiB0ZXh0IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgY29uc3Qgc3R5bGU6IENTU1Byb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiB2YWx1ZVJhbmdlXG4gICAgICAgICAgICAgID8gY2VsbEJhcih7XG4gICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUgYXMgbnVtYmVyLFxuICAgICAgICAgICAgICAgICAgdmFsdWVSYW5nZSxcbiAgICAgICAgICAgICAgICAgIGFsaWduUG9zaXRpdmVOZWdhdGl2ZSxcbiAgICAgICAgICAgICAgICAgIGNvbG9yUG9zaXRpdmVOZWdhdGl2ZSxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHRleHRBbGlnbixcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IGNlbGxQcm9wcyA9IHtcbiAgICAgICAgICAgIC8vIHNob3cgcmF3IG51bWJlciBpbiB0aXRsZSBpbiBjYXNlIG9mIG51bWVyaWMgdmFsdWVzXG4gICAgICAgICAgICB0aXRsZTogdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyA/IFN0cmluZyh2YWx1ZSkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBvbkNsaWNrOiBlbWl0RmlsdGVyICYmICF2YWx1ZVJhbmdlID8gKCkgPT4gdG9nZ2xlRmlsdGVyKGtleSwgdmFsdWUpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBbXG4gICAgICAgICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgdmFsdWUgPT0gbnVsbCA/ICdkdC1pcy1udWxsJyA6ICcnLFxuICAgICAgICAgICAgICBpc0FjdGl2ZUZpbHRlclZhbHVlKGtleSwgdmFsdWUpID8gJyBkdC1pcy1hY3RpdmUtZmlsdGVyJyA6ICcnLFxuICAgICAgICAgICAgXS5qb2luKCcgJyksXG4gICAgICAgICAgICBzdHlsZSxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChodG1sKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tZGFuZ2VyXG4gICAgICAgICAgICByZXR1cm4gPHRkIHsuLi5jZWxsUHJvcHN9IGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXtodG1sfSAvPjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gSWYgY2VsbFByb3BzIHJlbmRlcmVzIHRleHRDb250ZW50IGFscmVhZHksIHRoZW4gd2UgZG9uJ3QgaGF2ZSB0b1xuICAgICAgICAgIC8vIHJlbmRlciBgQ2VsbGAuIFRoaXMgc2F2ZXMgc29tZSB0aW1lIGZvciBsYXJnZSB0YWJsZXMuXG4gICAgICAgICAgcmV0dXJuIDx0ZCB7Li4uY2VsbFByb3BzfT57dGV4dH08L3RkPjtcbiAgICAgICAgfSxcbiAgICAgICAgSGVhZGVyOiAoeyBjb2x1bW46IGNvbCwgb25DbGljaywgc3R5bGUgfSkgPT4gKFxuICAgICAgICAgIDx0aFxuICAgICAgICAgICAgdGl0bGU9XCJTaGlmdCArIENsaWNrIHRvIHNvcnQgYnkgbXVsdGlwbGUgY29sdW1uc1wiXG4gICAgICAgICAgICBjbGFzc05hbWU9e1tjbGFzc05hbWUsIGNvbC5pc1NvcnRlZCA/ICdpcy1zb3J0ZWQnIDogJyddLmpvaW4oJyAnKX1cbiAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgIC4uLnN0eWxlLFxuICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIG9uQ2xpY2s9e29uQ2xpY2t9XG4gICAgICAgICAgPlxuICAgICAgICAgICAgey8qIGNhbid0IHVzZSBgY29sdW1uV2lkdGggJiZgIGJlY2F1c2UgaXQgbWF5IGFsc28gYmUgemVybyAqL31cbiAgICAgICAgICAgIHtjb25maWcuY29sdW1uV2lkdGggPyAoXG4gICAgICAgICAgICAgIC8vIGNvbHVtbiB3aWR0aCBoaW50XG4gICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgd2lkdGg6IGNvbHVtbldpZHRoLFxuICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAwLjAxLFxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICApIDogbnVsbH1cbiAgICAgICAgICAgIHtsYWJlbH1cbiAgICAgICAgICAgIDxTb3J0SWNvbiBjb2x1bW49e2NvbH0gLz5cbiAgICAgICAgICA8L3RoPlxuICAgICAgICApLFxuICAgICAgICBzb3J0RGVzY0ZpcnN0OiBzb3J0RGVzYyxcbiAgICAgICAgc29ydFR5cGU6IGdldFNvcnRUeXBlQnlEYXRhVHlwZShkYXRhVHlwZSksXG4gICAgICB9O1xuICAgIH0sXG4gICAgW1xuICAgICAgZGVmYXVsdEFsaWduUE4sXG4gICAgICBkZWZhdWx0Q29sb3JQTixcbiAgICAgIGVtaXRGaWx0ZXIsXG4gICAgICBnZXRWYWx1ZVJhbmdlLFxuICAgICAgaXNBY3RpdmVGaWx0ZXJWYWx1ZSxcbiAgICAgIGlzUmF3UmVjb3JkcyxcbiAgICAgIHNob3dDZWxsQmFycyxcbiAgICAgIHNvcnREZXNjLFxuICAgICAgdG9nZ2xlRmlsdGVyLFxuICAgIF0sXG4gICk7XG5cbiAgY29uc3QgY29sdW1ucyA9IHVzZU1lbW8oKCkgPT4gY29sdW1uc01ldGEubWFwKGdldENvbHVtbkNvbmZpZ3MpLCBbY29sdW1uc01ldGEsIGdldENvbHVtbkNvbmZpZ3NdKTtcblxuICBjb25zdCBoYW5kbGVTZXJ2ZXJQYWdpbmF0aW9uQ2hhbmdlID0gKHBhZ2VOdW1iZXI6IG51bWJlciwgcGFnZVNpemU6IG51bWJlcikgPT4ge1xuICAgIHVwZGF0ZUV4dGVybmFsRm9ybURhdGEoc2V0RGF0YU1hc2ssIHBhZ2VOdW1iZXIsIHBhZ2VTaXplKTtcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxTdHlsZXM+XG4gICAgICA8RGF0YVRhYmxlPEQ+XG4gICAgICAgIGNvbHVtbnM9e2NvbHVtbnN9XG4gICAgICAgIGRhdGE9e2RhdGF9XG4gICAgICAgIHJvd0NvdW50PXtyb3dDb3VudH1cbiAgICAgICAgdGFibGVDbGFzc05hbWU9XCJ0YWJsZSB0YWJsZS1zdHJpcGVkIHRhYmxlLWNvbmRlbnNlZFwiXG4gICAgICAgIHBhZ2VTaXplPXtwYWdlU2l6ZX1cbiAgICAgICAgc2VydmVyUGFnaW5hdGlvbkRhdGE9e3NlcnZlclBhZ2luYXRpb25EYXRhfVxuICAgICAgICBwYWdlU2l6ZU9wdGlvbnM9e3BhZ2VTaXplT3B0aW9uc31cbiAgICAgICAgaGVpZ2h0PXtoZWlnaHR9XG4gICAgICAgIHNlcnZlclBhZ2luYXRpb249e3NlcnZlclBhZ2luYXRpb259XG4gICAgICAgIG9uU2VydmVyUGFnaW5hdGlvbkNoYW5nZT17aGFuZGxlU2VydmVyUGFnaW5hdGlvbkNoYW5nZX1cbiAgICAgICAgLy8gOSBwYWdlIGl0ZW1zIGluID4gMzQwcHggd29ya3Mgd2VsbCBldmVuIGZvciAxMDArIHBhZ2VzXG4gICAgICAgIG1heFBhZ2VJdGVtQ291bnQ9e3dpZHRoID4gMzQwID8gOSA6IDd9XG4gICAgICAgIG5vUmVzdWx0cz17KGZpbHRlcjogc3RyaW5nKSA9PiB0KGZpbHRlciA/ICdObyBtYXRjaGluZyByZWNvcmRzIGZvdW5kJyA6ICdObyByZWNvcmRzIGZvdW5kJyl9XG4gICAgICAgIHNlYXJjaElucHV0PXtpbmNsdWRlU2VhcmNoICYmIFNlYXJjaElucHV0fVxuICAgICAgICBzZWxlY3RQYWdlU2l6ZT17cGFnZVNpemUgIT09IG51bGwgJiYgU2VsZWN0UGFnZVNpemV9XG4gICAgICAgIC8vIG5vdCBpbiB1c2UgaW4gU3VwZXJzZXQsIGJ1dCBuZWVkZWQgZm9yIHVuaXQgdGVzdHNcbiAgICAgICAgc3RpY2t5PXtzdGlja3l9XG4gICAgICAvPlxuICAgIDwvU3R5bGVzPlxuICApO1xufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7QUNsREE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBO0FBQ0E7QUFFQTtBQWlCQTtBQUNBOztBQUVBO0FBQ0E7QUFRQTtBQUVBO0FBTUE7QUFDQTtBQUdBO0FBQ0E7QUFJQTtBQUVBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7Ozs7O0FDL0VBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTtBQUNBO0FBQ0E7QUFVQTtBQUNBOztBQUVBO0FBQ0E7QUFLQTtBQUNBO0FBR0E7QUFDQTtBQUtBO0FBQ0E7QUFFQTtBQUVBO0FBUUE7QUFDQTtBQUNBO0FBRUE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUZBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTtBQUNBO0FBV0E7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFPQTtBQU9BOzs7QUNqR0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBO0FBQ0E7O0FBRUE7QUFDQTtBQWFBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcENBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTtBQUNBO0FBWUE7QUFDQTtBQUNBO0FBcUJBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFrQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQU9BO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFNQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFTQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3pXQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFDQTtBQVFBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBeUJBO0FBQ0E7O0FBQUE7QUFzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBZ0JBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQVVBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFLQTtBQUdBO0FBU0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFXQTtBQUVBO0FBV0E7QUFDQTtBQVlBOzs7Ozs7QUN0VEE7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1DQTs7Ozs7O0FDNUVBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTtBQUNBO0FBSUE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3ZEQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFRQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBR0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFLQTtBQXNCQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7O0FBRUE7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFXQTtBQUNBO0FBSUE7QUFDQTtBQUlBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2497\n')}}]);