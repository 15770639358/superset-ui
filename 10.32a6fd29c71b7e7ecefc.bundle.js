(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{1920:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1912);\n\n\n/* harmony default export */ __webpack_exports__["a"] = ({\n  draw: function(context, size) {\n    var r = Math.sqrt(size / _math_js__WEBPACK_IMPORTED_MODULE_0__[/* pi */ "j"]);\n    context.moveTo(r, 0);\n    context.arc(0, 0, r, 0, _math_js__WEBPACK_IMPORTED_MODULE_0__[/* tau */ "m"]);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkyMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvY2lyY2xlLmpzPzlkYWMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtwaSwgdGF1fSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUpIHtcbiAgICB2YXIgciA9IE1hdGguc3FydChzaXplIC8gcGkpO1xuICAgIGNvbnRleHQubW92ZVRvKHIsIDApO1xuICAgIGNvbnRleHQuYXJjKDAsIDAsIHIsIDAsIHRhdSk7XG4gIH1cbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1920\n')},1921:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony default export */ __webpack_exports__["a"] = ({\n  draw: function(context, size) {\n    var r = Math.sqrt(size / 5) / 2;\n    context.moveTo(-3 * r, -r);\n    context.lineTo(-r, -r);\n    context.lineTo(-r, -3 * r);\n    context.lineTo(r, -3 * r);\n    context.lineTo(r, -r);\n    context.lineTo(3 * r, -r);\n    context.lineTo(3 * r, r);\n    context.lineTo(r, r);\n    context.lineTo(r, 3 * r);\n    context.lineTo(-r, 3 * r);\n    context.lineTo(-r, r);\n    context.lineTo(-3 * r, r);\n    context.closePath();\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkyMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvY3Jvc3MuanM/NmY4NSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCB7XG4gIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUpIHtcbiAgICB2YXIgciA9IE1hdGguc3FydChzaXplIC8gNSkgLyAyO1xuICAgIGNvbnRleHQubW92ZVRvKC0zICogciwgLXIpO1xuICAgIGNvbnRleHQubGluZVRvKC1yLCAtcik7XG4gICAgY29udGV4dC5saW5lVG8oLXIsIC0zICogcik7XG4gICAgY29udGV4dC5saW5lVG8ociwgLTMgKiByKTtcbiAgICBjb250ZXh0LmxpbmVUbyhyLCAtcik7XG4gICAgY29udGV4dC5saW5lVG8oMyAqIHIsIC1yKTtcbiAgICBjb250ZXh0LmxpbmVUbygzICogciwgcik7XG4gICAgY29udGV4dC5saW5lVG8ociwgcik7XG4gICAgY29udGV4dC5saW5lVG8ociwgMyAqIHIpO1xuICAgIGNvbnRleHQubGluZVRvKC1yLCAzICogcik7XG4gICAgY29udGV4dC5saW5lVG8oLXIsIHIpO1xuICAgIGNvbnRleHQubGluZVRvKC0zICogciwgcik7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1921\n')},1922:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('var tan30 = Math.sqrt(1 / 3),\n    tan30_2 = tan30 * 2;\n\n/* harmony default export */ __webpack_exports__["a"] = ({\n  draw: function(context, size) {\n    var y = Math.sqrt(size / tan30_2),\n        x = y * tan30;\n    context.moveTo(0, -y);\n    context.lineTo(x, 0);\n    context.lineTo(0, y);\n    context.lineTo(-x, 0);\n    context.closePath();\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkyMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvZGlhbW9uZC5qcz8wZjA0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciB0YW4zMCA9IE1hdGguc3FydCgxIC8gMyksXG4gICAgdGFuMzBfMiA9IHRhbjMwICogMjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplKSB7XG4gICAgdmFyIHkgPSBNYXRoLnNxcnQoc2l6ZSAvIHRhbjMwXzIpLFxuICAgICAgICB4ID0geSAqIHRhbjMwO1xuICAgIGNvbnRleHQubW92ZVRvKDAsIC15KTtcbiAgICBjb250ZXh0LmxpbmVUbyh4LCAwKTtcbiAgICBjb250ZXh0LmxpbmVUbygwLCB5KTtcbiAgICBjb250ZXh0LmxpbmVUbygteCwgMCk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1922\n')},1923:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony default export */ __webpack_exports__["a"] = ({\n  draw: function(context, size) {\n    var w = Math.sqrt(size),\n        x = -w / 2;\n    context.rect(x, x, w, w);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkyMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvc3F1YXJlLmpzP2E5OWQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQge1xuICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplKSB7XG4gICAgdmFyIHcgPSBNYXRoLnNxcnQoc2l6ZSksXG4gICAgICAgIHggPSAtdyAvIDI7XG4gICAgY29udGV4dC5yZWN0KHgsIHgsIHcsIHcpO1xuICB9XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1923\n')},1924:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1912);\n\n\nvar ka = 0.89081309152928522810,\n    kr = Math.sin(_math_js__WEBPACK_IMPORTED_MODULE_0__[/* pi */ "j"] / 10) / Math.sin(7 * _math_js__WEBPACK_IMPORTED_MODULE_0__[/* pi */ "j"] / 10),\n    kx = Math.sin(_math_js__WEBPACK_IMPORTED_MODULE_0__[/* tau */ "m"] / 10) * kr,\n    ky = -Math.cos(_math_js__WEBPACK_IMPORTED_MODULE_0__[/* tau */ "m"] / 10) * kr;\n\n/* harmony default export */ __webpack_exports__["a"] = ({\n  draw: function(context, size) {\n    var r = Math.sqrt(size * ka),\n        x = kx * r,\n        y = ky * r;\n    context.moveTo(0, -r);\n    context.lineTo(x, y);\n    for (var i = 1; i < 5; ++i) {\n      var a = _math_js__WEBPACK_IMPORTED_MODULE_0__[/* tau */ "m"] * i / 5,\n          c = Math.cos(a),\n          s = Math.sin(a);\n      context.lineTo(s * r, -c * r);\n      context.lineTo(c * x - s * y, s * x + c * y);\n    }\n    context.closePath();\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkyNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvc3Rhci5qcz9hNTA3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7cGksIHRhdX0gZnJvbSBcIi4uL21hdGguanNcIjtcblxudmFyIGthID0gMC44OTA4MTMwOTE1MjkyODUyMjgxMCxcbiAgICBrciA9IE1hdGguc2luKHBpIC8gMTApIC8gTWF0aC5zaW4oNyAqIHBpIC8gMTApLFxuICAgIGt4ID0gTWF0aC5zaW4odGF1IC8gMTApICoga3IsXG4gICAga3kgPSAtTWF0aC5jb3ModGF1IC8gMTApICoga3I7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSkge1xuICAgIHZhciByID0gTWF0aC5zcXJ0KHNpemUgKiBrYSksXG4gICAgICAgIHggPSBreCAqIHIsXG4gICAgICAgIHkgPSBreSAqIHI7XG4gICAgY29udGV4dC5tb3ZlVG8oMCwgLXIpO1xuICAgIGNvbnRleHQubGluZVRvKHgsIHkpO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgNTsgKytpKSB7XG4gICAgICB2YXIgYSA9IHRhdSAqIGkgLyA1LFxuICAgICAgICAgIGMgPSBNYXRoLmNvcyhhKSxcbiAgICAgICAgICBzID0gTWF0aC5zaW4oYSk7XG4gICAgICBjb250ZXh0LmxpbmVUbyhzICogciwgLWMgKiByKTtcbiAgICAgIGNvbnRleHQubGluZVRvKGMgKiB4IC0gcyAqIHksIHMgKiB4ICsgYyAqIHkpO1xuICAgIH1cbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1924\n')},1925:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('var sqrt3 = Math.sqrt(3);\n\n/* harmony default export */ __webpack_exports__["a"] = ({\n  draw: function(context, size) {\n    var y = -Math.sqrt(size / (sqrt3 * 3));\n    context.moveTo(0, y * 2);\n    context.lineTo(-sqrt3 * y, -y);\n    context.lineTo(sqrt3 * y, -y);\n    context.closePath();\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkyNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvdHJpYW5nbGUuanM/ZmM4MyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgc3FydDMgPSBNYXRoLnNxcnQoMyk7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSkge1xuICAgIHZhciB5ID0gLU1hdGguc3FydChzaXplIC8gKHNxcnQzICogMykpO1xuICAgIGNvbnRleHQubW92ZVRvKDAsIHkgKiAyKTtcbiAgICBjb250ZXh0LmxpbmVUbygtc3FydDMgKiB5LCAteSk7XG4gICAgY29udGV4dC5saW5lVG8oc3FydDMgKiB5LCAteSk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1925\n')},1926:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('var c = -0.5,\n    s = Math.sqrt(3) / 2,\n    k = 1 / Math.sqrt(12),\n    a = (k / 2 + 1) * 3;\n\n/* harmony default export */ __webpack_exports__["a"] = ({\n  draw: function(context, size) {\n    var r = Math.sqrt(size / a),\n        x0 = r / 2,\n        y0 = r * k,\n        x1 = x0,\n        y1 = r * k + r,\n        x2 = -x1,\n        y2 = y1;\n    context.moveTo(x0, y0);\n    context.lineTo(x1, y1);\n    context.lineTo(x2, y2);\n    context.lineTo(c * x0 - s * y0, s * x0 + c * y0);\n    context.lineTo(c * x1 - s * y1, s * x1 + c * y1);\n    context.lineTo(c * x2 - s * y2, s * x2 + c * y2);\n    context.lineTo(c * x0 + s * y0, c * y0 - s * x0);\n    context.lineTo(c * x1 + s * y1, c * y1 - s * x1);\n    context.lineTo(c * x2 + s * y2, c * y2 - s * x2);\n    context.closePath();\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkyNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvd3llLmpzPzIyNDciXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGMgPSAtMC41LFxuICAgIHMgPSBNYXRoLnNxcnQoMykgLyAyLFxuICAgIGsgPSAxIC8gTWF0aC5zcXJ0KDEyKSxcbiAgICBhID0gKGsgLyAyICsgMSkgKiAzO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUpIHtcbiAgICB2YXIgciA9IE1hdGguc3FydChzaXplIC8gYSksXG4gICAgICAgIHgwID0gciAvIDIsXG4gICAgICAgIHkwID0gciAqIGssXG4gICAgICAgIHgxID0geDAsXG4gICAgICAgIHkxID0gciAqIGsgKyByLFxuICAgICAgICB4MiA9IC14MSxcbiAgICAgICAgeTIgPSB5MTtcbiAgICBjb250ZXh0Lm1vdmVUbyh4MCwgeTApO1xuICAgIGNvbnRleHQubGluZVRvKHgxLCB5MSk7XG4gICAgY29udGV4dC5saW5lVG8oeDIsIHkyKTtcbiAgICBjb250ZXh0LmxpbmVUbyhjICogeDAgLSBzICogeTAsIHMgKiB4MCArIGMgKiB5MCk7XG4gICAgY29udGV4dC5saW5lVG8oYyAqIHgxIC0gcyAqIHkxLCBzICogeDEgKyBjICogeTEpO1xuICAgIGNvbnRleHQubGluZVRvKGMgKiB4MiAtIHMgKiB5MiwgcyAqIHgyICsgYyAqIHkyKTtcbiAgICBjb250ZXh0LmxpbmVUbyhjICogeDAgKyBzICogeTAsIGMgKiB5MCAtIHMgKiB4MCk7XG4gICAgY29udGV4dC5saW5lVG8oYyAqIHgxICsgcyAqIHkxLCBjICogeTEgLSBzICogeDEpO1xuICAgIGNvbnRleHQubGluZVRvKGMgKiB4MiArIHMgKiB5MiwgYyAqIHkyIC0gcyAqIHgyKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1926\n')},1949:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return symbols; });\n/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2483);\n/* harmony import */ var _symbol_circle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1920);\n/* harmony import */ var _symbol_cross_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1921);\n/* harmony import */ var _symbol_diamond_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1922);\n/* harmony import */ var _symbol_star_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1924);\n/* harmony import */ var _symbol_square_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(1923);\n/* harmony import */ var _symbol_triangle_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(1925);\n/* harmony import */ var _symbol_wye_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(1926);\n/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(1913);\n\n\n\n\n\n\n\n\n\n\nvar symbols = [\n  _symbol_circle_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"],\n  _symbol_cross_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"],\n  _symbol_diamond_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"],\n  _symbol_square_js__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"],\n  _symbol_star_js__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"],\n  _symbol_triangle_js__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"],\n  _symbol_wye_js__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"]\n];\n\n/* harmony default export */ __webpack_exports__["a"] = (function() {\n  var type = Object(_constant_js__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"])(_symbol_circle_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]),\n      size = Object(_constant_js__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"])(64),\n      context = null;\n\n  function symbol() {\n    var buffer;\n    if (!context) context = buffer = Object(d3_path__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])();\n    type.apply(this, arguments).draw(context, +size.apply(this, arguments));\n    if (buffer) return context = null, buffer + "" || null;\n  }\n\n  symbol.type = function(_) {\n    return arguments.length ? (type = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"])(_), symbol) : type;\n  };\n\n  symbol.size = function(_) {\n    return arguments.length ? (size = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"])(+_), symbol) : size;\n  };\n\n  symbol.context = function(_) {\n    return arguments.length ? (context = _ == null ? null : _, symbol) : context;\n  };\n\n  return symbol;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk0OS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wuanM/Y2E2MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3BhdGh9IGZyb20gXCJkMy1wYXRoXCI7XG5pbXBvcnQgY2lyY2xlIGZyb20gXCIuL3N5bWJvbC9jaXJjbGUuanNcIjtcbmltcG9ydCBjcm9zcyBmcm9tIFwiLi9zeW1ib2wvY3Jvc3MuanNcIjtcbmltcG9ydCBkaWFtb25kIGZyb20gXCIuL3N5bWJvbC9kaWFtb25kLmpzXCI7XG5pbXBvcnQgc3RhciBmcm9tIFwiLi9zeW1ib2wvc3Rhci5qc1wiO1xuaW1wb3J0IHNxdWFyZSBmcm9tIFwiLi9zeW1ib2wvc3F1YXJlLmpzXCI7XG5pbXBvcnQgdHJpYW5nbGUgZnJvbSBcIi4vc3ltYm9sL3RyaWFuZ2xlLmpzXCI7XG5pbXBvcnQgd3llIGZyb20gXCIuL3N5bWJvbC93eWUuanNcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuXG5leHBvcnQgdmFyIHN5bWJvbHMgPSBbXG4gIGNpcmNsZSxcbiAgY3Jvc3MsXG4gIGRpYW1vbmQsXG4gIHNxdWFyZSxcbiAgc3RhcixcbiAgdHJpYW5nbGUsXG4gIHd5ZVxuXTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciB0eXBlID0gY29uc3RhbnQoY2lyY2xlKSxcbiAgICAgIHNpemUgPSBjb25zdGFudCg2NCksXG4gICAgICBjb250ZXh0ID0gbnVsbDtcblxuICBmdW5jdGlvbiBzeW1ib2woKSB7XG4gICAgdmFyIGJ1ZmZlcjtcbiAgICBpZiAoIWNvbnRleHQpIGNvbnRleHQgPSBidWZmZXIgPSBwYXRoKCk7XG4gICAgdHlwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLmRyYXcoY29udGV4dCwgK3NpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgaWYgKGJ1ZmZlcikgcmV0dXJuIGNvbnRleHQgPSBudWxsLCBidWZmZXIgKyBcIlwiIHx8IG51bGw7XG4gIH1cblxuICBzeW1ib2wudHlwZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0eXBlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChfKSwgc3ltYm9sKSA6IHR5cGU7XG4gIH07XG5cbiAgc3ltYm9sLnNpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc2l6ZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBzeW1ib2wpIDogc2l6ZTtcbiAgfTtcblxuICBzeW1ib2wuY29udGV4dCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjb250ZXh0ID0gXyA9PSBudWxsID8gbnVsbCA6IF8sIHN5bWJvbCkgOiBjb250ZXh0O1xuICB9O1xuXG4gIHJldHVybiBzeW1ib2w7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1949\n')},1954:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DEFAULT_MARGIN; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return createMarginSelector; });\n/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(169);\n\nconst DEFAULT_MARGIN = { bottom: 16, left: 16, right: 16, top: 16 };\nfunction createMarginSelector(defaultMargin = DEFAULT_MARGIN) {\n    return Object(reselect__WEBPACK_IMPORTED_MODULE_0__["createSelector"])((margin) => margin.bottom, margin => margin.left, margin => margin.right, margin => margin.top, (bottom = defaultMargin.bottom, left = defaultMargin.left, right = defaultMargin.right, top = defaultMargin.top) => ({\n        bottom,\n        left,\n        right,\n        top,\n    }));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk1NC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wcmVzZXQtY2hhcnQteHkvc3JjL3V0aWxzL2NyZWF0ZU1hcmdpblNlbGVjdG9yLnRzeD83NTU1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yIH0gZnJvbSAncmVzZWxlY3QnO1xuaW1wb3J0IHsgTWFyZ2luIH0gZnJvbSAnQHN1cGVyc2V0LXVpL2NvcmUnO1xuXG5leHBvcnQgY29uc3QgREVGQVVMVF9NQVJHSU4gPSB7IGJvdHRvbTogMTYsIGxlZnQ6IDE2LCByaWdodDogMTYsIHRvcDogMTYgfTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlTWFyZ2luU2VsZWN0b3IoZGVmYXVsdE1hcmdpbjogTWFyZ2luID0gREVGQVVMVF9NQVJHSU4pIHtcbiAgcmV0dXJuIGNyZWF0ZVNlbGVjdG9yKFxuICAgIChtYXJnaW46IFBhcnRpYWw8TWFyZ2luPikgPT4gbWFyZ2luLmJvdHRvbSxcbiAgICBtYXJnaW4gPT4gbWFyZ2luLmxlZnQsXG4gICAgbWFyZ2luID0+IG1hcmdpbi5yaWdodCxcbiAgICBtYXJnaW4gPT4gbWFyZ2luLnRvcCxcbiAgICAoXG4gICAgICBib3R0b20gPSBkZWZhdWx0TWFyZ2luLmJvdHRvbSxcbiAgICAgIGxlZnQgPSBkZWZhdWx0TWFyZ2luLmxlZnQsXG4gICAgICByaWdodCA9IGRlZmF1bHRNYXJnaW4ucmlnaHQsXG4gICAgICB0b3AgPSBkZWZhdWx0TWFyZ2luLnRvcCxcbiAgICApID0+ICh7XG4gICAgICBib3R0b20sXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHQsXG4gICAgICB0b3AsXG4gICAgfSksXG4gICk7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFFQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1954\n')},1955:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Text; });\n/* unused harmony export getStringWidth */\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var reduce_css_calc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1940);\n/* harmony import */ var reduce_css_calc__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(reduce_css_calc__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\nvar commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction makeEmptyFunction(arg) {\n  return function () {\n    return arg;\n  };\n}\n\n/**\n * This function accepts and discards inputs; it has no side effects. This is\n * primarily useful idiomatically for overridable function endpoints which\n * always need to be callable, since JS lacks a null-call idiom ala Cocoa.\n */\nvar emptyFunction = function emptyFunction() {};\n\nemptyFunction.thatReturns = makeEmptyFunction;\nemptyFunction.thatReturnsFalse = makeEmptyFunction(false);\nemptyFunction.thatReturnsTrue = makeEmptyFunction(true);\nemptyFunction.thatReturnsNull = makeEmptyFunction(null);\nemptyFunction.thatReturnsThis = function () {\n  return this;\n};\nemptyFunction.thatReturnsArgument = function (arg) {\n  return arg;\n};\n\nvar emptyFunction_1 = emptyFunction;\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar validateFormat = function validateFormat(format) {};\n\nif (false) {}\n\nfunction invariant(condition, format, a, b, c, d, e, f) {\n  validateFormat(format);\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(format.replace(/%s/g, function () {\n        return args[argIndex++];\n      }));\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n}\n\nvar invariant_1 = invariant;\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar warning = emptyFunction_1;\n\nif (false) { var printWarning; }\n\nvar warning_1 = warning;\n\n/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nvar objectAssign = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nvar ReactPropTypesSecret_1 = ReactPropTypesSecret;\n\nif (false) { var loggedTypeFailures, ReactPropTypesSecret$1, warning$1, invariant$1; }\n\n/**\n * Assert that the values match with the type specs.\n * Error messages are memorized and will only be shown once.\n *\n * @param {object} typeSpecs Map of name to a ReactPropType\n * @param {object} values Runtime values that need to be type-checked\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @param {string} componentName Name of the component for error messages.\n * @param {?Function} getStack Returns the component stack.\n * @private\n */\nfunction checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n  if (false) { var stack, error, typeSpecName; }\n}\n\nvar checkPropTypes_1 = checkPropTypes;\n\nvar factoryWithTypeCheckers = function(isValidElement, throwOnDirectAccess) {\n  /* global Symbol */\n  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.\n\n  /**\n   * Returns the iterator method function contained on the iterable object.\n   *\n   * Be sure to invoke the function with the iterable as context:\n   *\n   *     var iteratorFn = getIteratorFn(myIterable);\n   *     if (iteratorFn) {\n   *       var iterator = iteratorFn.call(myIterable);\n   *       ...\n   *     }\n   *\n   * @param {?object} maybeIterable\n   * @return {?function}\n   */\n  function getIteratorFn(maybeIterable) {\n    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n\n  /**\n   * Collection of methods that allow declaration and validation of props that are\n   * supplied to React components. Example usage:\n   *\n   *   var Props = require('ReactPropTypes');\n   *   var MyArticle = React.createClass({\n   *     propTypes: {\n   *       // An optional string prop named \"description\".\n   *       description: Props.string,\n   *\n   *       // A required enum prop named \"category\".\n   *       category: Props.oneOf(['News','Photos']).isRequired,\n   *\n   *       // A prop named \"dialog\" that requires an instance of Dialog.\n   *       dialog: Props.instanceOf(Dialog).isRequired\n   *     },\n   *     render: function() { ... }\n   *   });\n   *\n   * A more formal specification of how these methods are used:\n   *\n   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\n   *   decl := ReactPropTypes.{type}(.isRequired)?\n   *\n   * Each and every declaration produces a function with the same signature. This\n   * allows the creation of custom validation functions. For example:\n   *\n   *  var MyLink = React.createClass({\n   *    propTypes: {\n   *      // An optional string or URI prop named \"href\".\n   *      href: function(props, propName, componentName) {\n   *        var propValue = props[propName];\n   *        if (propValue != null && typeof propValue !== 'string' &&\n   *            !(propValue instanceof URI)) {\n   *          return new Error(\n   *            'Expected a string or an URI for ' + propName + ' in ' +\n   *            componentName\n   *          );\n   *        }\n   *      }\n   *    },\n   *    render: function() {...}\n   *  });\n   *\n   * @internal\n   */\n\n  var ANONYMOUS = '<<anonymous>>';\n\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.\n  var ReactPropTypes = {\n    array: createPrimitiveTypeChecker('array'),\n    bool: createPrimitiveTypeChecker('boolean'),\n    func: createPrimitiveTypeChecker('function'),\n    number: createPrimitiveTypeChecker('number'),\n    object: createPrimitiveTypeChecker('object'),\n    string: createPrimitiveTypeChecker('string'),\n    symbol: createPrimitiveTypeChecker('symbol'),\n\n    any: createAnyTypeChecker(),\n    arrayOf: createArrayOfTypeChecker,\n    element: createElementTypeChecker(),\n    instanceOf: createInstanceTypeChecker,\n    node: createNodeChecker(),\n    objectOf: createObjectOfTypeChecker,\n    oneOf: createEnumTypeChecker,\n    oneOfType: createUnionTypeChecker,\n    shape: createShapeTypeChecker,\n    exact: createStrictShapeTypeChecker,\n  };\n\n  /**\n   * inlined Object.is polyfill to avoid requiring consumers ship their own\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n   */\n  /*eslint-disable no-self-compare*/\n  function is(x, y) {\n    // SameValue algorithm\n    if (x === y) {\n      // Steps 1-5, 7-10\n      // Steps 6.b-6.e: +0 != -0\n      return x !== 0 || 1 / x === 1 / y;\n    } else {\n      // Step 6.a: NaN == NaN\n      return x !== x && y !== y;\n    }\n  }\n  /*eslint-enable no-self-compare*/\n\n  /**\n   * We use an Error-like object for backward compatibility as people may call\n   * PropTypes directly and inspect their output. However, we don't use real\n   * Errors anymore. We don't inspect their stack anyway, and creating them\n   * is prohibitively expensive if they are created too often, such as what\n   * happens in oneOfType() for any type before the one that matched.\n   */\n  function PropTypeError(message) {\n    this.message = message;\n    this.stack = '';\n  }\n  // Make `instanceof Error` still work for returned errors.\n  PropTypeError.prototype = Error.prototype;\n\n  function createChainableTypeChecker(validate) {\n    if (false) { var manualPropTypeWarningCount, manualPropTypeCallCache; }\n    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\n      componentName = componentName || ANONYMOUS;\n      propFullName = propFullName || propName;\n\n      if (secret !== ReactPropTypesSecret_1) {\n        if (throwOnDirectAccess) {\n          // New behavior only for users of `prop-types` package\n          invariant_1(\n            false,\n            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n            'Use `PropTypes.checkPropTypes()` to call them. ' +\n            'Read more at http://fb.me/use-check-prop-types'\n          );\n        } else if (false) { var cacheKey; }\n      }\n      if (props[propName] == null) {\n        if (isRequired) {\n          if (props[propName] === null) {\n            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));\n          }\n          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));\n        }\n        return null;\n      } else {\n        return validate(props, propName, componentName, location, propFullName);\n      }\n    }\n\n    var chainedCheckType = checkType.bind(null, false);\n    chainedCheckType.isRequired = checkType.bind(null, true);\n\n    return chainedCheckType;\n  }\n\n  function createPrimitiveTypeChecker(expectedType) {\n    function validate(props, propName, componentName, location, propFullName, secret) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== expectedType) {\n        // `propValue` being instance of, say, date/regexp, pass the 'object'\n        // check, but we can offer a more precise error message here rather than\n        // 'of type `object`'.\n        var preciseType = getPreciseType(propValue);\n\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createAnyTypeChecker() {\n    return createChainableTypeChecker(emptyFunction_1.thatReturnsNull);\n  }\n\n  function createArrayOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');\n      }\n      var propValue = props[propName];\n      if (!Array.isArray(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));\n      }\n      for (var i = 0; i < propValue.length; i++) {\n        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret_1);\n        if (error instanceof Error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createElementTypeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      if (!isValidElement(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createInstanceTypeChecker(expectedClass) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!(props[propName] instanceof expectedClass)) {\n        var expectedClassName = expectedClass.name || ANONYMOUS;\n        var actualClassName = getClassName(props[propName]);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createEnumTypeChecker(expectedValues) {\n    if (!Array.isArray(expectedValues)) {\n       false ? undefined : void 0;\n      return emptyFunction_1.thatReturnsNull;\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      for (var i = 0; i < expectedValues.length; i++) {\n        if (is(propValue, expectedValues[i])) {\n          return null;\n        }\n      }\n\n      var valuesString = JSON.stringify(expectedValues);\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createObjectOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');\n      }\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));\n      }\n      for (var key in propValue) {\n        if (propValue.hasOwnProperty(key)) {\n          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);\n          if (error instanceof Error) {\n            return error;\n          }\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createUnionTypeChecker(arrayOfTypeCheckers) {\n    if (!Array.isArray(arrayOfTypeCheckers)) {\n       false ? undefined : void 0;\n      return emptyFunction_1.thatReturnsNull;\n    }\n\n    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n      var checker = arrayOfTypeCheckers[i];\n      if (typeof checker !== 'function') {\n        warning_1(\n          false,\n          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +\n          'received %s at index %s.',\n          getPostfixForTypeWarning(checker),\n          i\n        );\n        return emptyFunction_1.thatReturnsNull;\n      }\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n        var checker = arrayOfTypeCheckers[i];\n        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret_1) == null) {\n          return null;\n        }\n      }\n\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createNodeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!isNode(props[propName])) {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      for (var key in shapeTypes) {\n        var checker = shapeTypes[key];\n        if (!checker) {\n          continue;\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createStrictShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      // We need to check all keys in case some are required but missing from\n      // props.\n      var allKeys = objectAssign({}, props[propName], shapeTypes);\n      for (var key in allKeys) {\n        var checker = shapeTypes[key];\n        if (!checker) {\n          return new PropTypeError(\n            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +\n            '\\nBad object: ' + JSON.stringify(props[propName], null, '  ') +\n            '\\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')\n          );\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n\n    return createChainableTypeChecker(validate);\n  }\n\n  function isNode(propValue) {\n    switch (typeof propValue) {\n      case 'number':\n      case 'string':\n      case 'undefined':\n        return true;\n      case 'boolean':\n        return !propValue;\n      case 'object':\n        if (Array.isArray(propValue)) {\n          return propValue.every(isNode);\n        }\n        if (propValue === null || isValidElement(propValue)) {\n          return true;\n        }\n\n        var iteratorFn = getIteratorFn(propValue);\n        if (iteratorFn) {\n          var iterator = iteratorFn.call(propValue);\n          var step;\n          if (iteratorFn !== propValue.entries) {\n            while (!(step = iterator.next()).done) {\n              if (!isNode(step.value)) {\n                return false;\n              }\n            }\n          } else {\n            // Iterator will provide entry [k,v] tuples rather than values.\n            while (!(step = iterator.next()).done) {\n              var entry = step.value;\n              if (entry) {\n                if (!isNode(entry[1])) {\n                  return false;\n                }\n              }\n            }\n          }\n        } else {\n          return false;\n        }\n\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  function isSymbol(propType, propValue) {\n    // Native Symbol.\n    if (propType === 'symbol') {\n      return true;\n    }\n\n    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n    if (propValue['@@toStringTag'] === 'Symbol') {\n      return true;\n    }\n\n    // Fallback for non-spec compliant Symbols which are polyfilled.\n    if (typeof Symbol === 'function' && propValue instanceof Symbol) {\n      return true;\n    }\n\n    return false;\n  }\n\n  // Equivalent of `typeof` but with special handling for array and regexp.\n  function getPropType(propValue) {\n    var propType = typeof propValue;\n    if (Array.isArray(propValue)) {\n      return 'array';\n    }\n    if (propValue instanceof RegExp) {\n      // Old webkits (at least until Android 4.0) return 'function' rather than\n      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n      // passes PropTypes.object.\n      return 'object';\n    }\n    if (isSymbol(propType, propValue)) {\n      return 'symbol';\n    }\n    return propType;\n  }\n\n  // This handles more types than `getPropType`. Only used for error messages.\n  // See `createPrimitiveTypeChecker`.\n  function getPreciseType(propValue) {\n    if (typeof propValue === 'undefined' || propValue === null) {\n      return '' + propValue;\n    }\n    var propType = getPropType(propValue);\n    if (propType === 'object') {\n      if (propValue instanceof Date) {\n        return 'date';\n      } else if (propValue instanceof RegExp) {\n        return 'regexp';\n      }\n    }\n    return propType;\n  }\n\n  // Returns a string that is postfixed to a warning about an invalid type.\n  // For example, \"undefined\" or \"of type array\"\n  function getPostfixForTypeWarning(value) {\n    var type = getPreciseType(value);\n    switch (type) {\n      case 'array':\n      case 'object':\n        return 'an ' + type;\n      case 'boolean':\n      case 'date':\n      case 'regexp':\n        return 'a ' + type;\n      default:\n        return type;\n    }\n  }\n\n  // Returns class name of the object, if any.\n  function getClassName(propValue) {\n    if (!propValue.constructor || !propValue.constructor.name) {\n      return ANONYMOUS;\n    }\n    return propValue.constructor.name;\n  }\n\n  ReactPropTypes.checkPropTypes = checkPropTypes_1;\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n\nvar factoryWithThrowingShims = function() {\n  function shim(props, propName, componentName, location, propFullName, secret) {\n    if (secret === ReactPropTypesSecret_1) {\n      // It is still safe when called from React.\n      return;\n    }\n    invariant_1(\n      false,\n      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n      'Use PropTypes.checkPropTypes() to call them. ' +\n      'Read more at http://fb.me/use-check-prop-types'\n    );\n  }  shim.isRequired = shim;\n  function getShim() {\n    return shim;\n  }  // Important!\n  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.\n  var ReactPropTypes = {\n    array: shim,\n    bool: shim,\n    func: shim,\n    number: shim,\n    object: shim,\n    string: shim,\n    symbol: shim,\n\n    any: shim,\n    arrayOf: getShim,\n    element: shim,\n    instanceOf: getShim,\n    node: shim,\n    objectOf: getShim,\n    oneOf: getShim,\n    oneOfType: getShim,\n    shape: getShim,\n    exact: getShim\n  };\n\n  ReactPropTypes.checkPropTypes = emptyFunction_1;\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n\nvar propTypes = createCommonjsModule(function (module) {\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nif (false) { var throwOnDirectAccess, isValidElement, REACT_ELEMENT_TYPE; } else {\n  // By explicitly using `prop-types` you are opting into new production behavior.\n  // http://fb.me/prop-types-in-prod\n  module.exports = factoryWithThrowingShims();\n}\n});\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;\n\nvar _freeGlobal = freeGlobal;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = _freeGlobal || freeSelf || Function('return this')();\n\nvar _root = root;\n\n/** Built-in value references. */\nvar Symbol$1 = _root.Symbol;\n\nvar _Symbol = Symbol$1;\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$1 = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty$1.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nvar _getRawTag = getRawTag;\n\n/** Used for built-in method references. */\nvar objectProto$1 = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString$1 = objectProto$1.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString$1.call(value);\n}\n\nvar _objectToString = objectToString;\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag$1 && symToStringTag$1 in Object(value))\n    ? _getRawTag(value)\n    : _objectToString(value);\n}\n\nvar _baseGetTag = baseGetTag;\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nvar isObject_1 = isObject;\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject_1(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = _baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nvar isFunction_1 = isFunction;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = _root['__core-js_shared__'];\n\nvar _coreJsData = coreJsData;\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nvar _isMasked = isMasked;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nvar _toSource = toSource;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto$1 = Function.prototype,\n    objectProto$2 = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString$1 = funcProto$1.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$2 = objectProto$2.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString$1.call(hasOwnProperty$2).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject_1(value) || _isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(_toSource(value));\n}\n\nvar _baseIsNative = baseIsNative;\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nvar _getValue = getValue;\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = _getValue(object, key);\n  return _baseIsNative(value) ? value : undefined;\n}\n\nvar _getNative = getNative;\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = _getNative(Object, 'create');\n\nvar _nativeCreate = nativeCreate;\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = _nativeCreate ? _nativeCreate(null) : {};\n  this.size = 0;\n}\n\nvar _hashClear = hashClear;\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nvar _hashDelete = hashDelete;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto$3 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$3 = objectProto$3.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (_nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty$3.call(data, key) ? data[key] : undefined;\n}\n\nvar _hashGet = hashGet;\n\n/** Used for built-in method references. */\nvar objectProto$4 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$4 = objectProto$4.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return _nativeCreate ? (data[key] !== undefined) : hasOwnProperty$4.call(data, key);\n}\n\nvar _hashHas = hashHas;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED$1 = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (_nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;\n  return this;\n}\n\nvar _hashSet = hashSet;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = _hashClear;\nHash.prototype['delete'] = _hashDelete;\nHash.prototype.get = _hashGet;\nHash.prototype.has = _hashHas;\nHash.prototype.set = _hashSet;\n\nvar _Hash = Hash;\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nvar _listCacheClear = listCacheClear;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nvar eq_1 = eq;\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq_1(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nvar _assocIndexOf = assocIndexOf;\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = _assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nvar _listCacheDelete = listCacheDelete;\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = _assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nvar _listCacheGet = listCacheGet;\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return _assocIndexOf(this.__data__, key) > -1;\n}\n\nvar _listCacheHas = listCacheHas;\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = _assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nvar _listCacheSet = listCacheSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = _listCacheClear;\nListCache.prototype['delete'] = _listCacheDelete;\nListCache.prototype.get = _listCacheGet;\nListCache.prototype.has = _listCacheHas;\nListCache.prototype.set = _listCacheSet;\n\nvar _ListCache = ListCache;\n\n/* Built-in method references that are verified to be native. */\nvar Map = _getNative(_root, 'Map');\n\nvar _Map = Map;\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new _Hash,\n    'map': new (_Map || _ListCache),\n    'string': new _Hash\n  };\n}\n\nvar _mapCacheClear = mapCacheClear;\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nvar _isKeyable = isKeyable;\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return _isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nvar _getMapData = getMapData;\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = _getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nvar _mapCacheDelete = mapCacheDelete;\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return _getMapData(this, key).get(key);\n}\n\nvar _mapCacheGet = mapCacheGet;\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return _getMapData(this, key).has(key);\n}\n\nvar _mapCacheHas = mapCacheHas;\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = _getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nvar _mapCacheSet = mapCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = _mapCacheClear;\nMapCache.prototype['delete'] = _mapCacheDelete;\nMapCache.prototype.get = _mapCacheGet;\nMapCache.prototype.has = _mapCacheHas;\nMapCache.prototype.set = _mapCacheSet;\n\nvar _MapCache = MapCache;\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || _MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = _MapCache;\n\nvar memoize_1 = memoize;\n\nvar MEASUREMENT_ELEMENT_ID = '__react_svg_text_measurement_id';\n\nfunction getStringWidth(str, style) {\n  try {\n    // Calculate length of each word to be used to determine number of words per line\n    var textEl = document.getElementById(MEASUREMENT_ELEMENT_ID);\n    if (!textEl) {\n      var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n      svg.style.width = 0;\n      svg.style.height = 0;\n      svg.style.position = 'absolute';\n      svg.style.top = '-100%';\n      svg.style.left = '-100%';\n      textEl = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n      textEl.setAttribute('id', MEASUREMENT_ELEMENT_ID);\n      svg.appendChild(textEl);\n      document.body.appendChild(svg);\n    }\n\n    Object.assign(textEl.style, style);\n    textEl.textContent = str;\n    return textEl.getComputedTextLength();\n  } catch (e) {\n    return null;\n  }\n}\n\nvar getStringWidth$1 = memoize_1(getStringWidth, function (str, style) {\n  return str + '_' + JSON.stringify(style);\n});\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar Text = function (_Component) {\n  inherits(Text, _Component);\n\n  function Text(props) {\n    classCallCheck(this, Text);\n\n    var _this = possibleConstructorReturn(this, (Text.__proto__ || Object.getPrototypeOf(Text)).call(this, props));\n\n    _this.state = {\n      wordsByLines: []\n    };\n    return _this;\n  }\n\n  createClass(Text, [{\n    key: 'componentWillMount',\n    value: function componentWillMount() {\n      this.updateWordsByLines(this.props, true);\n    }\n  }, {\n    key: 'componentWillReceiveProps',\n    value: function componentWillReceiveProps(nextProps) {\n      var needCalculate = this.props.children !== nextProps.children || this.props.style !== nextProps.style;\n      this.updateWordsByLines(nextProps, needCalculate);\n    }\n  }, {\n    key: 'updateWordsByLines',\n    value: function updateWordsByLines(props, needCalculate) {\n      // Only perform calculations if using features that require them (multiline, scaleToFit)\n      if (props.width || props.scaleToFit) {\n        if (needCalculate) {\n          var words = props.children ? props.children.toString().split(/\\s+/) : [];\n\n          this.wordsWithComputedWidth = words.map(function (word) {\n            return {\n              word: word,\n              width: getStringWidth$1(word, props.style)\n            };\n          });\n          this.spaceWidth = getStringWidth$1('\\xA0', props.style);\n        }\n\n        var wordsByLines = this.calculateWordsByLines(this.wordsWithComputedWidth, this.spaceWidth, props.width);\n        this.setState({ wordsByLines: wordsByLines });\n      } else {\n        this.updateWordsWithoutCalculate(props);\n      }\n    }\n  }, {\n    key: 'updateWordsWithoutCalculate',\n    value: function updateWordsWithoutCalculate(props) {\n      var words = props.children ? props.children.toString().split(/\\s+/) : [];\n      this.setState({ wordsByLines: [{ words: words }] });\n    }\n  }, {\n    key: 'calculateWordsByLines',\n    value: function calculateWordsByLines(wordsWithComputedWidth, spaceWidth, lineWidth) {\n      var scaleToFit = this.props.scaleToFit;\n\n      return wordsWithComputedWidth.reduce(function (result, _ref) {\n        var word = _ref.word,\n            width = _ref.width;\n\n        var currentLine = result[result.length - 1];\n\n        if (currentLine && (lineWidth == null || scaleToFit || currentLine.width + width + spaceWidth < lineWidth)) {\n          // Word can be added to an existing line\n          currentLine.words.push(word);\n          currentLine.width += width + spaceWidth;\n        } else {\n          // Add first word to line or word is too long to scaleToFit on existing line\n          var newLine = { words: [word], width: width };\n          result.push(newLine);\n        }\n\n        return result;\n      }, []);\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props = this.props,\n          dx = _props.dx,\n          dy = _props.dy,\n          textAnchor = _props.textAnchor,\n          verticalAnchor = _props.verticalAnchor,\n          scaleToFit = _props.scaleToFit,\n          angle = _props.angle,\n          lineHeight = _props.lineHeight,\n          capHeight = _props.capHeight,\n          innerRef = _props.innerRef,\n          textProps = objectWithoutProperties(_props, ['dx', 'dy', 'textAnchor', 'verticalAnchor', 'scaleToFit', 'angle', 'lineHeight', 'capHeight', 'innerRef']);\n      var wordsByLines = this.state.wordsByLines;\n\n\n      var x = textProps.x;\n      var y = textProps.y;\n\n      var startDy = void 0;\n      switch (verticalAnchor) {\n        case 'start':\n          startDy = reduce_css_calc__WEBPACK_IMPORTED_MODULE_1___default()('calc(' + capHeight + ')');\n          break;\n        case 'middle':\n          startDy = reduce_css_calc__WEBPACK_IMPORTED_MODULE_1___default()('calc(' + (wordsByLines.length - 1) / 2 + ' * -' + lineHeight + ' + (' + capHeight + ' / 2))');\n          break;\n        default:\n          startDy = reduce_css_calc__WEBPACK_IMPORTED_MODULE_1___default()('calc(' + (wordsByLines.length - 1) + ' * -' + lineHeight + ')');\n          break;\n      }\n\n      var transforms = [];\n      if (scaleToFit && wordsByLines.length) {\n        var lineWidth = wordsByLines[0].width;\n        var sx = this.props.width / lineWidth;\n        var sy = sx;\n        var originX = x - sx * x;\n        var originY = y - sy * y;\n        transforms.push('matrix(' + sx + ', 0, 0, ' + sy + ', ' + originX + ', ' + originY + ')');\n      }\n      if (angle) {\n        transforms.push('rotate(' + angle + ', ' + x + ', ' + y + ')');\n      }\n      if (transforms.length) {\n        textProps.transform = transforms.join(' ');\n      }\n\n      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n        'svg',\n        {\n          ref: innerRef,\n          x: dx,\n          y: dy,\n          fontSize: textProps.fontSize,\n          style: { overflow: 'visible' }\n        },\n        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n          'text',\n          _extends({}, textProps, { textAnchor: textAnchor }),\n          wordsByLines.map(function (line, index) {\n            return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n              'tspan',\n              { x: x, dy: index === 0 ? startDy : lineHeight, key: index },\n              line.words.join(' ')\n            );\n          })\n        )\n      );\n    }\n  }]);\n  return Text;\n}(react__WEBPACK_IMPORTED_MODULE_0__[\"Component\"]);\n\nText.defaultProps = {\n  x: 0,\n  y: 0,\n  dx: 0,\n  dy: 0,\n  lineHeight: '1em',\n  capHeight: '0.71em', // Magic number from d3\n  scaleToFit: false,\n  textAnchor: 'start',\n  verticalAnchor: 'end' // default SVG behavior\n};\n\nText.propTypes = {\n  scaleToFit: propTypes.bool,\n  angle: propTypes.number,\n  textAnchor: propTypes.oneOf(['start', 'middle', 'end', 'inherit']),\n  verticalAnchor: propTypes.oneOf(['start', 'middle', 'end']),\n  style: propTypes.object,\n  innerRef: propTypes.func\n};\n\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(68)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk1NS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL3h5LWNoYXJ0L25vZGVfbW9kdWxlcy9AdngvYXhpcy9ub2RlX21vZHVsZXMvQHZ4L3RleHQvZGlzdC92eC10ZXh0LmVzLmpzPzkwZDciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCByZWR1Y2VDU1NDYWxjIGZyb20gJ3JlZHVjZS1jc3MtY2FsYyc7XG5cbnZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuLCBtb2R1bGUpIHtcblx0cmV0dXJuIG1vZHVsZSA9IHsgZXhwb3J0czoge30gfSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG5cbmZ1bmN0aW9uIG1ha2VFbXB0eUZ1bmN0aW9uKGFyZykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhcmc7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIGFuZCBkaXNjYXJkcyBpbnB1dHM7IGl0IGhhcyBubyBzaWRlIGVmZmVjdHMuIFRoaXMgaXNcbiAqIHByaW1hcmlseSB1c2VmdWwgaWRpb21hdGljYWxseSBmb3Igb3ZlcnJpZGFibGUgZnVuY3Rpb24gZW5kcG9pbnRzIHdoaWNoXG4gKiBhbHdheXMgbmVlZCB0byBiZSBjYWxsYWJsZSwgc2luY2UgSlMgbGFja3MgYSBudWxsLWNhbGwgaWRpb20gYWxhIENvY29hLlxuICovXG52YXIgZW1wdHlGdW5jdGlvbiA9IGZ1bmN0aW9uIGVtcHR5RnVuY3Rpb24oKSB7fTtcblxuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucyA9IG1ha2VFbXB0eUZ1bmN0aW9uO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlID0gbWFrZUVtcHR5RnVuY3Rpb24oZmFsc2UpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWUgPSBtYWtlRW1wdHlGdW5jdGlvbih0cnVlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsID0gbWFrZUVtcHR5RnVuY3Rpb24obnVsbCk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVGhpcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50ID0gZnVuY3Rpb24gKGFyZykge1xuICByZXR1cm4gYXJnO1xufTtcblxudmFyIGVtcHR5RnVuY3Rpb25fMSA9IGVtcHR5RnVuY3Rpb247XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbnZhciB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgdmFsaWRhdGVGb3JtYXQoZm9ybWF0KTtcblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKCdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICsgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSkpO1xuICAgICAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICB9XG5cbiAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxudmFyIGludmFyaWFudF8xID0gaW52YXJpYW50O1xuXG4vKipcbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgd2FybmluZyA9IGVtcHR5RnVuY3Rpb25fMTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIHByaW50V2FybmluZyhmb3JtYXQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xuXG4gIHdhcm5pbmcgPSBmdW5jdGlvbiB3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXQuaW5kZXhPZignRmFpbGVkIENvbXBvc2l0ZSBwcm9wVHlwZTogJykgPT09IDApIHtcbiAgICAgIHJldHVybjsgLy8gSWdub3JlIENvbXBvc2l0ZUNvbXBvbmVudCBwcm9wdHlwZSBjaGVjay5cbiAgICB9XG5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMl0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcuYXBwbHkodW5kZWZpbmVkLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIHdhcm5pbmdfMSA9IHdhcm5pbmc7XG5cbi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdH1cblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdH0pO1xuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0fSk7XG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxudmFyIG9iamVjdEFzc2lnbiA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0XzEgPSBSZWFjdFByb3BUeXBlc1NlY3JldDtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGludmFyaWFudCQxID0gaW52YXJpYW50XzE7XG4gIHZhciB3YXJuaW5nJDEgPSB3YXJuaW5nXzE7XG4gIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCQxID0gUmVhY3RQcm9wVHlwZXNTZWNyZXRfMTtcbiAgdmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xufVxuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cbiAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gez9GdW5jdGlvbn0gZ2V0U3RhY2sgUmV0dXJucyB0aGUgY29tcG9uZW50IHN0YWNrLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBnZXRTdGFjaykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmICh0eXBlU3BlY3MuaGFzT3duUHJvcGVydHkodHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpbnZhcmlhbnQkMSh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gPT09ICdmdW5jdGlvbicsICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tICcgKyAndGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCVzYC4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSk7XG4gICAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0JDEpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yID0gZXg7XG4gICAgICAgIH1cbiAgICAgICAgd2FybmluZyQxKCFlcnJvciB8fCBlcnJvciBpbnN0YW5jZW9mIEVycm9yLCAnJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBzdGFjayA9IGdldFN0YWNrID8gZ2V0U3RhY2soKSA6ICcnO1xuXG4gICAgICAgICAgd2FybmluZyQxKGZhbHNlLCAnRmFpbGVkICVzIHR5cGU6ICVzJXMnLCBsb2NhdGlvbiwgZXJyb3IubWVzc2FnZSwgc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBjaGVja1Byb3BUeXBlc18xID0gY2hlY2tQcm9wVHlwZXM7XG5cbnZhciBmYWN0b3J5V2l0aFR5cGVDaGVja2VycyA9IGZ1bmN0aW9uKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gIC8qIGdsb2JhbCBTeW1ib2wgKi9cbiAgdmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xuICB2YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICAgKlxuICAgKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcbiAgICpcbiAgICogICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihteUl0ZXJhYmxlKTtcbiAgICogICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAgICogICAgICAgLi4uXG4gICAqICAgICB9XG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbWF5YmVJdGVyYWJsZVxuICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG4gICAqL1xuICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXG4gICAqIHN1cHBsaWVkIHRvIFJlYWN0IGNvbXBvbmVudHMuIEV4YW1wbGUgdXNhZ2U6XG4gICAqXG4gICAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcbiAgICogICB2YXIgTXlBcnRpY2xlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFwiZGVzY3JpcHRpb25cIi5cbiAgICogICAgICAgZGVzY3JpcHRpb246IFByb3BzLnN0cmluZyxcbiAgICpcbiAgICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXCJjYXRlZ29yeVwiLlxuICAgKiAgICAgICBjYXRlZ29yeTogUHJvcHMub25lT2YoWydOZXdzJywnUGhvdG9zJ10pLmlzUmVxdWlyZWQsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcImRpYWxvZ1wiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxuICAgKiAgICAgICBkaWFsb2c6IFByb3BzLmluc3RhbmNlT2YoRGlhbG9nKS5pc1JlcXVpcmVkXG4gICAqICAgICB9LFxuICAgKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxuICAgKlxuICAgKiAgIHR5cGUgOj0gYXJyYXl8Ym9vbHxmdW5jfG9iamVjdHxudW1iZXJ8c3RyaW5nfG9uZU9mKFsuLi5dKXxpbnN0YW5jZU9mKC4uLilcbiAgICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XG4gICAqXG4gICAqIEVhY2ggYW5kIGV2ZXJ5IGRlY2xhcmF0aW9uIHByb2R1Y2VzIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBzaWduYXR1cmUuIFRoaXNcbiAgICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiAgdmFyIE15TGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIG9yIFVSSSBwcm9wIG5hbWVkIFwiaHJlZlwiLlxuICAgKiAgICAgIGhyZWY6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICogICAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICAgKiAgICAgICAgICAgICEocHJvcFZhbHVlIGluc3RhbmNlb2YgVVJJKSkge1xuICAgKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgKiAgICAgICAgICAgICdFeHBlY3RlZCBhIHN0cmluZyBvciBhbiBVUkkgZm9yICcgKyBwcm9wTmFtZSArICcgaW4gJyArXG4gICAqICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgKiAgICAgICAgICApO1xuICAgKiAgICAgICAgfVxuICAgKiAgICAgIH1cbiAgICogICAgfSxcbiAgICogICAgcmVuZGVyOiBmdW5jdGlvbigpIHsuLi59XG4gICAqICB9KTtcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG4gIHZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XG5cbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2FycmF5JyksXG4gICAgYm9vbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Jvb2xlYW4nKSxcbiAgICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcbiAgICBudW1iZXI6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdudW1iZXInKSxcbiAgICBvYmplY3Q6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdvYmplY3QnKSxcbiAgICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcbiAgICBzeW1ib2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzeW1ib2wnKSxcblxuICAgIGFueTogY3JlYXRlQW55VHlwZUNoZWNrZXIoKSxcbiAgICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXG4gICAgZWxlbWVudDogY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCksXG4gICAgaW5zdGFuY2VPZjogY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcixcbiAgICBub2RlOiBjcmVhdGVOb2RlQ2hlY2tlcigpLFxuICAgIG9iamVjdE9mOiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyLFxuICAgIG9uZU9mOiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIsXG4gICAgb25lT2ZUeXBlOiBjcmVhdGVVbmlvblR5cGVDaGVja2VyLFxuICAgIHNoYXBlOiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyLFxuICAgIGV4YWN0OiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyLFxuICB9O1xuXG4gIC8qKlxuICAgKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICAgKi9cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuICBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gICAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICAgIH1cbiAgfVxuICAvKmVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlKi9cblxuICAvKipcbiAgICogV2UgdXNlIGFuIEVycm9yLWxpa2Ugb2JqZWN0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGFzIHBlb3BsZSBtYXkgY2FsbFxuICAgKiBQcm9wVHlwZXMgZGlyZWN0bHkgYW5kIGluc3BlY3QgdGhlaXIgb3V0cHV0LiBIb3dldmVyLCB3ZSBkb24ndCB1c2UgcmVhbFxuICAgKiBFcnJvcnMgYW55bW9yZS4gV2UgZG9uJ3QgaW5zcGVjdCB0aGVpciBzdGFjayBhbnl3YXksIGFuZCBjcmVhdGluZyB0aGVtXG4gICAqIGlzIHByb2hpYml0aXZlbHkgZXhwZW5zaXZlIGlmIHRoZXkgYXJlIGNyZWF0ZWQgdG9vIG9mdGVuLCBzdWNoIGFzIHdoYXRcbiAgICogaGFwcGVucyBpbiBvbmVPZlR5cGUoKSBmb3IgYW55IHR5cGUgYmVmb3JlIHRoZSBvbmUgdGhhdCBtYXRjaGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gUHJvcFR5cGVFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLnN0YWNrID0gJyc7XG4gIH1cbiAgLy8gTWFrZSBgaW5zdGFuY2VvZiBFcnJvcmAgc3RpbGwgd29yayBmb3IgcmV0dXJuZWQgZXJyb3JzLlxuICBQcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuXG4gICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldF8xKSB7XG4gICAgICAgIGlmICh0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gICAgICAgICAgLy8gTmV3IGJlaGF2aW9yIG9ubHkgZm9yIHVzZXJzIG9mIGBwcm9wLXR5cGVzYCBwYWNrYWdlXG4gICAgICAgICAgaW52YXJpYW50XzEoXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICdVc2UgYFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpYCB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIE9sZCBiZWhhdmlvciBmb3IgcGVvcGxlIHVzaW5nIFJlYWN0LlByb3BUeXBlc1xuICAgICAgICAgIHZhciBjYWNoZUtleSA9IGNvbXBvbmVudE5hbWUgKyAnOicgKyBwcm9wTmFtZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldICYmXG4gICAgICAgICAgICAvLyBBdm9pZCBzcGFtbWluZyB0aGUgY29uc29sZSBiZWNhdXNlIHRoZXkgYXJlIG9mdGVuIG5vdCBhY3Rpb25hYmxlIGV4Y2VwdCBmb3IgbGliIGF1dGhvcnNcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50IDwgM1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgd2FybmluZ18xKFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgK1xuICAgICAgICAgICAgICAnZnVuY3Rpb24gZm9yIHRoZSBgJXNgIHByb3Agb24gYCVzYC4gVGhpcyBpcyBkZXByZWNhdGVkICcgK1xuICAgICAgICAgICAgICAnYW5kIHdpbGwgdGhyb3cgaW4gdGhlIHN0YW5kYWxvbmUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgICAnWW91IG1heSBiZSBzZWVpbmcgdGhpcyB3YXJuaW5nIGR1ZSB0byBhIHRoaXJkLXBhcnR5IFByb3BUeXBlcyAnICtcbiAgICAgICAgICAgICAgJ2xpYnJhcnkuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctZG9udC1jYWxsLXByb3B0eXBlcyAnICsgJ2ZvciBkZXRhaWxzLicsXG4gICAgICAgICAgICAgIHByb3BGdWxsTmFtZSxcbiAgICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uXzEudGhhdFJldHVybnNOdWxsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBhcnJheU9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScsIFJlYWN0UHJvcFR5cGVzU2VjcmV0XzEpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nXzEoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uXzEudGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzKHByb3BWYWx1ZSwgZXhwZWN0ZWRWYWx1ZXNbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KGV4cGVjdGVkVmFsdWVzKTtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdmFsdWUgYCcgKyBwcm9wVmFsdWUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgb25lIG9mICcgKyB2YWx1ZXNTdHJpbmcgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgICAgaWYgKHByb3BWYWx1ZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0XzEpO1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmdfMShmYWxzZSwgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uXzEudGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgaWYgKHR5cGVvZiBjaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5pbmdfMShcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUuIEV4cGVjdGVkIGFuIGFycmF5IG9mIGNoZWNrIGZ1bmN0aW9ucywgYnV0ICcgK1xuICAgICAgICAgICdyZWNlaXZlZCAlcyBhdCBpbmRleCAlcy4nLFxuICAgICAgICAgIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyhjaGVja2VyKSxcbiAgICAgICAgICBpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uXzEudGhhdFJldHVybnNOdWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgICAgaWYgKGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBSZWFjdFByb3BUeXBlc1NlY3JldF8xKSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVOb2RlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghaXNOb2RlKHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBSZWFjdE5vZGUuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc2hhcGVUeXBlcykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXRfMSk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGFsbCBrZXlzIGluIGNhc2Ugc29tZSBhcmUgcmVxdWlyZWQgYnV0IG1pc3NpbmcgZnJvbVxuICAgICAgLy8gcHJvcHMuXG4gICAgICB2YXIgYWxsS2V5cyA9IG9iamVjdEFzc2lnbih7fSwgcHJvcHNbcHJvcE5hbWVdLCBzaGFwZVR5cGVzKTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBhbGxLZXlzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAgICAgICAnSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Aga2V5IGAnICsga2V5ICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJyArXG4gICAgICAgICAgICAnXFxuQmFkIG9iamVjdDogJyArIEpTT04uc3RyaW5naWZ5KHByb3BzW3Byb3BOYW1lXSwgbnVsbCwgJyAgJykgK1xuICAgICAgICAgICAgJ1xcblZhbGlkIGtleXM6ICcgKyAgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMoc2hhcGVUeXBlcyksIG51bGwsICcgICcpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldF8xKTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XG4gICAgLy8gTmF0aXZlIFN5bWJvbC5cbiAgICBpZiAocHJvcFR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddID09PSAnU3ltYm9sJ1xuICAgIGlmIChwcm9wVmFsdWVbJ0BAdG9TdHJpbmdUYWcnXSA9PT0gJ1N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIGZvciBub24tc3BlYyBjb21wbGlhbnQgU3ltYm9scyB3aGljaCBhcmUgcG9seWZpbGxlZC5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wVmFsdWUgaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cbiAgZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gICAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ2FycmF5JztcbiAgICB9XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxuICAgICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG4gICAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICB9XG4gICAgaWYgKGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ3N5bWJvbCc7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFRoaXMgaGFuZGxlcyBtb3JlIHR5cGVzIHRoYW4gYGdldFByb3BUeXBlYC4gT25seSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cbiAgLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXG4gIGZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAndW5kZWZpbmVkJyB8fCBwcm9wVmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJyArIHByb3BWYWx1ZTtcbiAgICB9XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gJ2RhdGUnO1xuICAgICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgaXMgcG9zdGZpeGVkIHRvIGEgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIHR5cGUuXG4gIC8vIEZvciBleGFtcGxlLCBcInVuZGVmaW5lZFwiIG9yIFwib2YgdHlwZSBhcnJheVwiXG4gIGZ1bmN0aW9uIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgcmV0dXJuICdhbiAnICsgdHlwZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjYXNlICdyZWdleHAnOlxuICAgICAgICByZXR1cm4gJ2EgJyArIHR5cGU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuICBmdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XG4gICAgaWYgKCFwcm9wVmFsdWUuY29uc3RydWN0b3IgfHwgIXByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICByZXR1cm4gQU5PTllNT1VTO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGNoZWNrUHJvcFR5cGVzXzE7XG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG5cbnZhciBmYWN0b3J5V2l0aFRocm93aW5nU2hpbXMgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gc2hpbShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgIGlmIChzZWNyZXQgPT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0XzEpIHtcbiAgICAgIC8vIEl0IGlzIHN0aWxsIHNhZmUgd2hlbiBjYWxsZWQgZnJvbSBSZWFjdC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW52YXJpYW50XzEoXG4gICAgICBmYWxzZSxcbiAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICdVc2UgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCkgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICk7XG4gIH0gIHNoaW0uaXNSZXF1aXJlZCA9IHNoaW07XG4gIGZ1bmN0aW9uIGdldFNoaW0oKSB7XG4gICAgcmV0dXJuIHNoaW07XG4gIH0gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogc2hpbSxcbiAgICBib29sOiBzaGltLFxuICAgIGZ1bmM6IHNoaW0sXG4gICAgbnVtYmVyOiBzaGltLFxuICAgIG9iamVjdDogc2hpbSxcbiAgICBzdHJpbmc6IHNoaW0sXG4gICAgc3ltYm9sOiBzaGltLFxuXG4gICAgYW55OiBzaGltLFxuICAgIGFycmF5T2Y6IGdldFNoaW0sXG4gICAgZWxlbWVudDogc2hpbSxcbiAgICBpbnN0YW5jZU9mOiBnZXRTaGltLFxuICAgIG5vZGU6IHNoaW0sXG4gICAgb2JqZWN0T2Y6IGdldFNoaW0sXG4gICAgb25lT2Y6IGdldFNoaW0sXG4gICAgb25lT2ZUeXBlOiBnZXRTaGltLFxuICAgIHNoYXBlOiBnZXRTaGltLFxuICAgIGV4YWN0OiBnZXRTaGltXG4gIH07XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBlbXB0eUZ1bmN0aW9uXzE7XG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG5cbnZhciBwcm9wVHlwZXMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIFN5bWJvbC5mb3IgJiZcbiAgICBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykpIHx8XG4gICAgMHhlYWM3O1xuXG4gIHZhciBpc1ZhbGlkRWxlbWVudCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgb2JqZWN0ICE9PSBudWxsICYmXG4gICAgICBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfTtcblxuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBkZXZlbG9wbWVudCBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICB2YXIgdGhyb3dPbkRpcmVjdEFjY2VzcyA9IHRydWU7XG4gIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMoaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpO1xufSBlbHNlIHtcbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgcHJvZHVjdGlvbiBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcygpO1xufVxufSk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBjb21tb25qc0dsb2JhbCA9PSAnb2JqZWN0JyAmJiBjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBjb21tb25qc0dsb2JhbDtcblxudmFyIF9mcmVlR2xvYmFsID0gZnJlZUdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gX2ZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxudmFyIF9yb290ID0gcm9vdDtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sJDEgPSBfcm9vdC5TeW1ib2w7XG5cbnZhciBfU3ltYm9sID0gU3ltYm9sJDE7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5JDEgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gX1N5bWJvbCA/IF9TeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5JDEuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX2dldFJhd1RhZyA9IGdldFJhd1RhZztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvJDEgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmckMSA9IG9iamVjdFByb3RvJDEudG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmckMS5jYWxsKHZhbHVlKTtcbn1cblxudmFyIF9vYmplY3RUb1N0cmluZyA9IG9iamVjdFRvU3RyaW5nO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWckMSA9IF9TeW1ib2wgPyBfU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnJDEgJiYgc3ltVG9TdHJpbmdUYWckMSBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gX2dldFJhd1RhZyh2YWx1ZSlcbiAgICA6IF9vYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbnZhciBfYmFzZUdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG52YXIgaXNPYmplY3RfMSA9IGlzT2JqZWN0O1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RfMSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gX2Jhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG52YXIgaXNGdW5jdGlvbl8xID0gaXNGdW5jdGlvbjtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSBfcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbnZhciBfY29yZUpzRGF0YSA9IGNvcmVKc0RhdGE7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoX2NvcmVKc0RhdGEgJiYgX2NvcmVKc0RhdGEua2V5cyAmJiBfY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbnZhciBfaXNNYXNrZWQgPSBpc01hc2tlZDtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgX3RvU291cmNlID0gdG9Tb3VyY2U7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvJDEgPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8kMiA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmckMSA9IGZ1bmNQcm90byQxLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSQyID0gb2JqZWN0UHJvdG8kMi5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZyQxLmNhbGwoaGFzT3duUHJvcGVydHkkMikucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RfMSh2YWx1ZSkgfHwgX2lzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb25fMSh2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KF90b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG52YXIgX2Jhc2VJc05hdGl2ZSA9IGJhc2VJc05hdGl2ZTtcblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbnZhciBfZ2V0VmFsdWUgPSBnZXRWYWx1ZTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IF9nZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBfYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG52YXIgX2dldE5hdGl2ZSA9IGdldE5hdGl2ZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIG5hdGl2ZUNyZWF0ZSA9IF9nZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbnZhciBfbmF0aXZlQ3JlYXRlID0gbmF0aXZlQ3JlYXRlO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBfbmF0aXZlQ3JlYXRlID8gX25hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG52YXIgX2hhc2hDbGVhciA9IGhhc2hDbGVhcjtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9oYXNoRGVsZXRlID0gaGFzaERlbGV0ZTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8kMyA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5JDMgPSBvYmplY3RQcm90byQzLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoX25hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5JDMuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG52YXIgX2hhc2hHZXQgPSBoYXNoR2V0O1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8kNCA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5JDQgPSBvYmplY3RQcm90byQ0Lmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIF9uYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkkNC5jYWxsKGRhdGEsIGtleSk7XG59XG5cbnZhciBfaGFzaEhhcyA9IGhhc2hIYXM7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCQxID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAoX25hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEJDEgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBfaGFzaFNldCA9IGhhc2hTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBfaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gX2hhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBfaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IF9oYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gX2hhc2hTZXQ7XG5cbnZhciBfSGFzaCA9IEhhc2g7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxudmFyIF9saXN0Q2FjaGVDbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuXG4vKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxudmFyIGVxXzEgPSBlcTtcblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxXzEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG52YXIgX2Fzc29jSW5kZXhPZiA9IGFzc29jSW5kZXhPZjtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gX2Fzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIF9saXN0Q2FjaGVEZWxldGUgPSBsaXN0Q2FjaGVEZWxldGU7XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBfYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG52YXIgX2xpc3RDYWNoZUdldCA9IGxpc3RDYWNoZUdldDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIF9hc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG52YXIgX2xpc3RDYWNoZUhhcyA9IGxpc3RDYWNoZUhhcztcblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IF9hc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxudmFyIF9saXN0Q2FjaGVTZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gX2xpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBfbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBfbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBfbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBfbGlzdENhY2hlU2V0O1xuXG52YXIgX0xpc3RDYWNoZSA9IExpc3RDYWNoZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIE1hcCA9IF9nZXROYXRpdmUoX3Jvb3QsICdNYXAnKTtcblxudmFyIF9NYXAgPSBNYXA7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgX0hhc2gsXG4gICAgJ21hcCc6IG5ldyAoX01hcCB8fCBfTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IF9IYXNoXG4gIH07XG59XG5cbnZhciBfbWFwQ2FjaGVDbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxudmFyIF9pc0tleWFibGUgPSBpc0tleWFibGU7XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBfaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbnZhciBfZ2V0TWFwRGF0YSA9IGdldE1hcERhdGE7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IF9nZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9tYXBDYWNoZURlbGV0ZSA9IG1hcENhY2hlRGVsZXRlO1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBfZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG52YXIgX21hcENhY2hlR2V0ID0gbWFwQ2FjaGVHZXQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBfZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG52YXIgX21hcENhY2hlSGFzID0gbWFwQ2FjaGVIYXM7XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IF9nZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBfbWFwQ2FjaGVTZXQgPSBtYXBDYWNoZVNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IF9tYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IF9tYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBfbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gX21hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IF9tYXBDYWNoZVNldDtcblxudmFyIF9NYXBDYWNoZSA9IE1hcENhY2hlO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAqXG4gKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogdmFsdWVzKG90aGVyKTtcbiAqIC8vID0+IFszLCA0XVxuICpcbiAqIG9iamVjdC5hID0gMjtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBfTWFwQ2FjaGUpO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxubWVtb2l6ZS5DYWNoZSA9IF9NYXBDYWNoZTtcblxudmFyIG1lbW9pemVfMSA9IG1lbW9pemU7XG5cbnZhciBNRUFTVVJFTUVOVF9FTEVNRU5UX0lEID0gJ19fcmVhY3Rfc3ZnX3RleHRfbWVhc3VyZW1lbnRfaWQnO1xuXG5mdW5jdGlvbiBnZXRTdHJpbmdXaWR0aChzdHIsIHN0eWxlKSB7XG4gIHRyeSB7XG4gICAgLy8gQ2FsY3VsYXRlIGxlbmd0aCBvZiBlYWNoIHdvcmQgdG8gYmUgdXNlZCB0byBkZXRlcm1pbmUgbnVtYmVyIG9mIHdvcmRzIHBlciBsaW5lXG4gICAgdmFyIHRleHRFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKE1FQVNVUkVNRU5UX0VMRU1FTlRfSUQpO1xuICAgIGlmICghdGV4dEVsKSB7XG4gICAgICB2YXIgc3ZnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdzdmcnKTtcbiAgICAgIHN2Zy5zdHlsZS53aWR0aCA9IDA7XG4gICAgICBzdmcuc3R5bGUuaGVpZ2h0ID0gMDtcbiAgICAgIHN2Zy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICBzdmcuc3R5bGUudG9wID0gJy0xMDAlJztcbiAgICAgIHN2Zy5zdHlsZS5sZWZ0ID0gJy0xMDAlJztcbiAgICAgIHRleHRFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAndGV4dCcpO1xuICAgICAgdGV4dEVsLnNldEF0dHJpYnV0ZSgnaWQnLCBNRUFTVVJFTUVOVF9FTEVNRU5UX0lEKTtcbiAgICAgIHN2Zy5hcHBlbmRDaGlsZCh0ZXh0RWwpO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzdmcpO1xuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24odGV4dEVsLnN0eWxlLCBzdHlsZSk7XG4gICAgdGV4dEVsLnRleHRDb250ZW50ID0gc3RyO1xuICAgIHJldHVybiB0ZXh0RWwuZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG52YXIgZ2V0U3RyaW5nV2lkdGgkMSA9IG1lbW9pemVfMShnZXRTdHJpbmdXaWR0aCwgZnVuY3Rpb24gKHN0ciwgc3R5bGUpIHtcbiAgcmV0dXJuIHN0ciArICdfJyArIEpTT04uc3RyaW5naWZ5KHN0eWxlKTtcbn0pO1xuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxudmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxudmFyIGluaGVyaXRzID0gZnVuY3Rpb24gKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufTtcblxudmFyIG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG9iaiwga2V5cykge1xuICB2YXIgdGFyZ2V0ID0ge307XG5cbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlO1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlO1xuICAgIHRhcmdldFtpXSA9IG9ialtpXTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG52YXIgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiA9IGZ1bmN0aW9uIChzZWxmLCBjYWxsKSB7XG4gIGlmICghc2VsZikge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmO1xufTtcblxudmFyIFRleHQgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhUZXh0LCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBUZXh0KHByb3BzKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dCk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChUZXh0Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVGV4dCkpLmNhbGwodGhpcywgcHJvcHMpKTtcblxuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgd29yZHNCeUxpbmVzOiBbXVxuICAgIH07XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoVGV4dCwgW3tcbiAgICBrZXk6ICdjb21wb25lbnRXaWxsTW91bnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgICB0aGlzLnVwZGF0ZVdvcmRzQnlMaW5lcyh0aGlzLnByb3BzLCB0cnVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgIHZhciBuZWVkQ2FsY3VsYXRlID0gdGhpcy5wcm9wcy5jaGlsZHJlbiAhPT0gbmV4dFByb3BzLmNoaWxkcmVuIHx8IHRoaXMucHJvcHMuc3R5bGUgIT09IG5leHRQcm9wcy5zdHlsZTtcbiAgICAgIHRoaXMudXBkYXRlV29yZHNCeUxpbmVzKG5leHRQcm9wcywgbmVlZENhbGN1bGF0ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlV29yZHNCeUxpbmVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlV29yZHNCeUxpbmVzKHByb3BzLCBuZWVkQ2FsY3VsYXRlKSB7XG4gICAgICAvLyBPbmx5IHBlcmZvcm0gY2FsY3VsYXRpb25zIGlmIHVzaW5nIGZlYXR1cmVzIHRoYXQgcmVxdWlyZSB0aGVtIChtdWx0aWxpbmUsIHNjYWxlVG9GaXQpXG4gICAgICBpZiAocHJvcHMud2lkdGggfHwgcHJvcHMuc2NhbGVUb0ZpdCkge1xuICAgICAgICBpZiAobmVlZENhbGN1bGF0ZSkge1xuICAgICAgICAgIHZhciB3b3JkcyA9IHByb3BzLmNoaWxkcmVuID8gcHJvcHMuY2hpbGRyZW4udG9TdHJpbmcoKS5zcGxpdCgvXFxzKy8pIDogW107XG5cbiAgICAgICAgICB0aGlzLndvcmRzV2l0aENvbXB1dGVkV2lkdGggPSB3b3Jkcy5tYXAoZnVuY3Rpb24gKHdvcmQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHdvcmQ6IHdvcmQsXG4gICAgICAgICAgICAgIHdpZHRoOiBnZXRTdHJpbmdXaWR0aCQxKHdvcmQsIHByb3BzLnN0eWxlKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLnNwYWNlV2lkdGggPSBnZXRTdHJpbmdXaWR0aCQxKCdcXHhBMCcsIHByb3BzLnN0eWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB3b3Jkc0J5TGluZXMgPSB0aGlzLmNhbGN1bGF0ZVdvcmRzQnlMaW5lcyh0aGlzLndvcmRzV2l0aENvbXB1dGVkV2lkdGgsIHRoaXMuc3BhY2VXaWR0aCwgcHJvcHMud2lkdGgpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgd29yZHNCeUxpbmVzOiB3b3Jkc0J5TGluZXMgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnVwZGF0ZVdvcmRzV2l0aG91dENhbGN1bGF0ZShwcm9wcyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlV29yZHNXaXRob3V0Q2FsY3VsYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlV29yZHNXaXRob3V0Q2FsY3VsYXRlKHByb3BzKSB7XG4gICAgICB2YXIgd29yZHMgPSBwcm9wcy5jaGlsZHJlbiA/IHByb3BzLmNoaWxkcmVuLnRvU3RyaW5nKCkuc3BsaXQoL1xccysvKSA6IFtdO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IHdvcmRzQnlMaW5lczogW3sgd29yZHM6IHdvcmRzIH1dIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NhbGN1bGF0ZVdvcmRzQnlMaW5lcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZVdvcmRzQnlMaW5lcyh3b3Jkc1dpdGhDb21wdXRlZFdpZHRoLCBzcGFjZVdpZHRoLCBsaW5lV2lkdGgpIHtcbiAgICAgIHZhciBzY2FsZVRvRml0ID0gdGhpcy5wcm9wcy5zY2FsZVRvRml0O1xuXG4gICAgICByZXR1cm4gd29yZHNXaXRoQ29tcHV0ZWRXaWR0aC5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgX3JlZikge1xuICAgICAgICB2YXIgd29yZCA9IF9yZWYud29yZCxcbiAgICAgICAgICAgIHdpZHRoID0gX3JlZi53aWR0aDtcblxuICAgICAgICB2YXIgY3VycmVudExpbmUgPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGlmIChjdXJyZW50TGluZSAmJiAobGluZVdpZHRoID09IG51bGwgfHwgc2NhbGVUb0ZpdCB8fCBjdXJyZW50TGluZS53aWR0aCArIHdpZHRoICsgc3BhY2VXaWR0aCA8IGxpbmVXaWR0aCkpIHtcbiAgICAgICAgICAvLyBXb3JkIGNhbiBiZSBhZGRlZCB0byBhbiBleGlzdGluZyBsaW5lXG4gICAgICAgICAgY3VycmVudExpbmUud29yZHMucHVzaCh3b3JkKTtcbiAgICAgICAgICBjdXJyZW50TGluZS53aWR0aCArPSB3aWR0aCArIHNwYWNlV2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQWRkIGZpcnN0IHdvcmQgdG8gbGluZSBvciB3b3JkIGlzIHRvbyBsb25nIHRvIHNjYWxlVG9GaXQgb24gZXhpc3RpbmcgbGluZVxuICAgICAgICAgIHZhciBuZXdMaW5lID0geyB3b3JkczogW3dvcmRdLCB3aWR0aDogd2lkdGggfTtcbiAgICAgICAgICByZXN1bHQucHVzaChuZXdMaW5lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LCBbXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVuZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgZHggPSBfcHJvcHMuZHgsXG4gICAgICAgICAgZHkgPSBfcHJvcHMuZHksXG4gICAgICAgICAgdGV4dEFuY2hvciA9IF9wcm9wcy50ZXh0QW5jaG9yLFxuICAgICAgICAgIHZlcnRpY2FsQW5jaG9yID0gX3Byb3BzLnZlcnRpY2FsQW5jaG9yLFxuICAgICAgICAgIHNjYWxlVG9GaXQgPSBfcHJvcHMuc2NhbGVUb0ZpdCxcbiAgICAgICAgICBhbmdsZSA9IF9wcm9wcy5hbmdsZSxcbiAgICAgICAgICBsaW5lSGVpZ2h0ID0gX3Byb3BzLmxpbmVIZWlnaHQsXG4gICAgICAgICAgY2FwSGVpZ2h0ID0gX3Byb3BzLmNhcEhlaWdodCxcbiAgICAgICAgICBpbm5lclJlZiA9IF9wcm9wcy5pbm5lclJlZixcbiAgICAgICAgICB0ZXh0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcHJvcHMsIFsnZHgnLCAnZHknLCAndGV4dEFuY2hvcicsICd2ZXJ0aWNhbEFuY2hvcicsICdzY2FsZVRvRml0JywgJ2FuZ2xlJywgJ2xpbmVIZWlnaHQnLCAnY2FwSGVpZ2h0JywgJ2lubmVyUmVmJ10pO1xuICAgICAgdmFyIHdvcmRzQnlMaW5lcyA9IHRoaXMuc3RhdGUud29yZHNCeUxpbmVzO1xuXG5cbiAgICAgIHZhciB4ID0gdGV4dFByb3BzLng7XG4gICAgICB2YXIgeSA9IHRleHRQcm9wcy55O1xuXG4gICAgICB2YXIgc3RhcnREeSA9IHZvaWQgMDtcbiAgICAgIHN3aXRjaCAodmVydGljYWxBbmNob3IpIHtcbiAgICAgICAgY2FzZSAnc3RhcnQnOlxuICAgICAgICAgIHN0YXJ0RHkgPSByZWR1Y2VDU1NDYWxjKCdjYWxjKCcgKyBjYXBIZWlnaHQgKyAnKScpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICAgIHN0YXJ0RHkgPSByZWR1Y2VDU1NDYWxjKCdjYWxjKCcgKyAod29yZHNCeUxpbmVzLmxlbmd0aCAtIDEpIC8gMiArICcgKiAtJyArIGxpbmVIZWlnaHQgKyAnICsgKCcgKyBjYXBIZWlnaHQgKyAnIC8gMikpJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgc3RhcnREeSA9IHJlZHVjZUNTU0NhbGMoJ2NhbGMoJyArICh3b3Jkc0J5TGluZXMubGVuZ3RoIC0gMSkgKyAnICogLScgKyBsaW5lSGVpZ2h0ICsgJyknKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdmFyIHRyYW5zZm9ybXMgPSBbXTtcbiAgICAgIGlmIChzY2FsZVRvRml0ICYmIHdvcmRzQnlMaW5lcy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGxpbmVXaWR0aCA9IHdvcmRzQnlMaW5lc1swXS53aWR0aDtcbiAgICAgICAgdmFyIHN4ID0gdGhpcy5wcm9wcy53aWR0aCAvIGxpbmVXaWR0aDtcbiAgICAgICAgdmFyIHN5ID0gc3g7XG4gICAgICAgIHZhciBvcmlnaW5YID0geCAtIHN4ICogeDtcbiAgICAgICAgdmFyIG9yaWdpblkgPSB5IC0gc3kgKiB5O1xuICAgICAgICB0cmFuc2Zvcm1zLnB1c2goJ21hdHJpeCgnICsgc3ggKyAnLCAwLCAwLCAnICsgc3kgKyAnLCAnICsgb3JpZ2luWCArICcsICcgKyBvcmlnaW5ZICsgJyknKTtcbiAgICAgIH1cbiAgICAgIGlmIChhbmdsZSkge1xuICAgICAgICB0cmFuc2Zvcm1zLnB1c2goJ3JvdGF0ZSgnICsgYW5nbGUgKyAnLCAnICsgeCArICcsICcgKyB5ICsgJyknKTtcbiAgICAgIH1cbiAgICAgIGlmICh0cmFuc2Zvcm1zLmxlbmd0aCkge1xuICAgICAgICB0ZXh0UHJvcHMudHJhbnNmb3JtID0gdHJhbnNmb3Jtcy5qb2luKCcgJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnc3ZnJyxcbiAgICAgICAge1xuICAgICAgICAgIHJlZjogaW5uZXJSZWYsXG4gICAgICAgICAgeDogZHgsXG4gICAgICAgICAgeTogZHksXG4gICAgICAgICAgZm9udFNpemU6IHRleHRQcm9wcy5mb250U2l6ZSxcbiAgICAgICAgICBzdHlsZTogeyBvdmVyZmxvdzogJ3Zpc2libGUnIH1cbiAgICAgICAgfSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAndGV4dCcsXG4gICAgICAgICAgX2V4dGVuZHMoe30sIHRleHRQcm9wcywgeyB0ZXh0QW5jaG9yOiB0ZXh0QW5jaG9yIH0pLFxuICAgICAgICAgIHdvcmRzQnlMaW5lcy5tYXAoZnVuY3Rpb24gKGxpbmUsIGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgJ3RzcGFuJyxcbiAgICAgICAgICAgICAgeyB4OiB4LCBkeTogaW5kZXggPT09IDAgPyBzdGFydER5IDogbGluZUhlaWdodCwga2V5OiBpbmRleCB9LFxuICAgICAgICAgICAgICBsaW5lLndvcmRzLmpvaW4oJyAnKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVGV4dDtcbn0oQ29tcG9uZW50KTtcblxuVGV4dC5kZWZhdWx0UHJvcHMgPSB7XG4gIHg6IDAsXG4gIHk6IDAsXG4gIGR4OiAwLFxuICBkeTogMCxcbiAgbGluZUhlaWdodDogJzFlbScsXG4gIGNhcEhlaWdodDogJzAuNzFlbScsIC8vIE1hZ2ljIG51bWJlciBmcm9tIGQzXG4gIHNjYWxlVG9GaXQ6IGZhbHNlLFxuICB0ZXh0QW5jaG9yOiAnc3RhcnQnLFxuICB2ZXJ0aWNhbEFuY2hvcjogJ2VuZCcgLy8gZGVmYXVsdCBTVkcgYmVoYXZpb3Jcbn07XG5cblRleHQucHJvcFR5cGVzID0ge1xuICBzY2FsZVRvRml0OiBwcm9wVHlwZXMuYm9vbCxcbiAgYW5nbGU6IHByb3BUeXBlcy5udW1iZXIsXG4gIHRleHRBbmNob3I6IHByb3BUeXBlcy5vbmVPZihbJ3N0YXJ0JywgJ21pZGRsZScsICdlbmQnLCAnaW5oZXJpdCddKSxcbiAgdmVydGljYWxBbmNob3I6IHByb3BUeXBlcy5vbmVPZihbJ3N0YXJ0JywgJ21pZGRsZScsICdlbmQnXSksXG4gIHN0eWxlOiBwcm9wVHlwZXMub2JqZWN0LFxuICBpbm5lclJlZjogcHJvcFR5cGVzLmZ1bmNcbn07XG5cbmV4cG9ydCB7IFRleHQsIGdldFN0cmluZ1dpZHRoJDEgYXMgZ2V0U3RyaW5nV2lkdGggfTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREEyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1955\n")},1956:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return convertScaleToDataUIScale; });\nfunction isCompatibleDomainOrRange(array) {\n    return (typeof array !== 'undefined' &&\n        array.length > 0 &&\n        (typeof array[0] === 'string' || typeof array[0] === 'number'));\n}\n/**\n * Convert encodeable scale object into @data-ui's scale config\n * @param scale\n */\nfunction convertScaleToDataUIScale(scale) {\n    const { type, domain, range } = scale;\n    let outputType;\n    if (type === 'linear' || type === 'time' || type === 'band') {\n        outputType = type;\n    }\n    else if (type === 'utc') {\n        outputType = 'timeUtc';\n    }\n    else {\n        throw new Error(`Unsupported scale type: ${type}`);\n    }\n    const output = { type: outputType };\n    if (isCompatibleDomainOrRange(domain)) {\n        output.domain = domain;\n    }\n    if (isCompatibleDomainOrRange(range)) {\n        output.range = range;\n    }\n    if ('nice' in scale && typeof scale.nice === 'boolean') {\n        output.nice = scale.nice;\n    }\n    if ('paddingInner' in scale && typeof scale.paddingInner !== 'undefined') {\n        output.paddingInner = scale.paddingInner;\n    }\n    if ('paddingOuter' in scale && typeof scale.paddingOuter !== 'undefined') {\n        output.paddingOuter = scale.paddingOuter;\n    }\n    return output;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk1Ni5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wcmVzZXQtY2hhcnQteHkvc3JjL3V0aWxzL2NvbnZlcnRTY2FsZVRvRGF0YVVJU2NhbGVTaGFwZS50cz8wNDdmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFZhbHVlLCBTY2FsZUNvbmZpZyB9IGZyb20gJ2VuY29kYWJsZSc7XG5cbnR5cGUgRGF0YVVJU2NhbGVUeXBlID0gJ3RpbWUnIHwgJ3RpbWVVdGMnIHwgJ2xpbmVhcicgfCAnYmFuZCc7XG5cbmludGVyZmFjZSBEYXRhVUlTY2FsZSB7XG4gIHR5cGU6IERhdGFVSVNjYWxlVHlwZTtcbiAgZG9tYWluPzogbnVtYmVyW10gfCBzdHJpbmdbXTtcbiAgaW5jbHVkZVplcm8/OiBib29sZWFuO1xuICBuaWNlPzogYm9vbGVhbjtcbiAgcGFkZGluZ0lubmVyPzogbnVtYmVyO1xuICBwYWRkaW5nT3V0ZXI/OiBudW1iZXI7XG4gIHJhbmdlPzogbnVtYmVyW10gfCBzdHJpbmdbXTtcbiAgcmFuZ2VSb3VuZD86IG51bWJlcltdIHwgc3RyaW5nW107XG59XG5cbmZ1bmN0aW9uIGlzQ29tcGF0aWJsZURvbWFpbk9yUmFuZ2UoXG4gIGFycmF5OiBTY2FsZUNvbmZpZ1snZG9tYWluJ10gfCBTY2FsZUNvbmZpZ1sncmFuZ2UnXSxcbik6IGFycmF5IGlzIG51bWJlcltdIHwgc3RyaW5nW10ge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBhcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICBhcnJheS5sZW5ndGggPiAwICYmXG4gICAgKHR5cGVvZiBhcnJheVswXSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGFycmF5WzBdID09PSAnbnVtYmVyJylcbiAgKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGVuY29kZWFibGUgc2NhbGUgb2JqZWN0IGludG8gQGRhdGEtdWkncyBzY2FsZSBjb25maWdcbiAqIEBwYXJhbSBzY2FsZVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb252ZXJ0U2NhbGVUb0RhdGFVSVNjYWxlPE91dHB1dCBleHRlbmRzIFZhbHVlPihcbiAgc2NhbGU6IFNjYWxlQ29uZmlnPE91dHB1dD4sXG4pIHtcbiAgY29uc3QgeyB0eXBlLCBkb21haW4sIHJhbmdlIH0gPSBzY2FsZTtcblxuICBsZXQgb3V0cHV0VHlwZTogRGF0YVVJU2NhbGVUeXBlO1xuXG4gIGlmICh0eXBlID09PSAnbGluZWFyJyB8fCB0eXBlID09PSAndGltZScgfHwgdHlwZSA9PT0gJ2JhbmQnKSB7XG4gICAgb3V0cHV0VHlwZSA9IHR5cGU7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3V0YycpIHtcbiAgICBvdXRwdXRUeXBlID0gJ3RpbWVVdGMnO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgc2NhbGUgdHlwZTogJHt0eXBlfWApO1xuICB9XG5cbiAgY29uc3Qgb3V0cHV0OiBEYXRhVUlTY2FsZSA9IHsgdHlwZTogb3V0cHV0VHlwZSB9O1xuICBpZiAoaXNDb21wYXRpYmxlRG9tYWluT3JSYW5nZShkb21haW4pKSB7XG4gICAgb3V0cHV0LmRvbWFpbiA9IGRvbWFpbjtcbiAgfVxuICBpZiAoaXNDb21wYXRpYmxlRG9tYWluT3JSYW5nZShyYW5nZSkpIHtcbiAgICBvdXRwdXQucmFuZ2UgPSByYW5nZTtcbiAgfVxuICBpZiAoJ25pY2UnIGluIHNjYWxlICYmIHR5cGVvZiBzY2FsZS5uaWNlID09PSAnYm9vbGVhbicpIHtcbiAgICBvdXRwdXQubmljZSA9IHNjYWxlLm5pY2U7XG4gIH1cbiAgaWYgKCdwYWRkaW5nSW5uZXInIGluIHNjYWxlICYmIHR5cGVvZiBzY2FsZS5wYWRkaW5nSW5uZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgb3V0cHV0LnBhZGRpbmdJbm5lciA9IHNjYWxlLnBhZGRpbmdJbm5lcjtcbiAgfVxuICBpZiAoJ3BhZGRpbmdPdXRlcicgaW4gc2NhbGUgJiYgdHlwZW9mIHNjYWxlLnBhZGRpbmdPdXRlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBvdXRwdXQucGFkZGluZ091dGVyID0gc2NhbGUucGFkZGluZ091dGVyO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBZUE7QUFBQTtBQUdBO0FBRUE7QUFDQTtBQUVBO0FBRUE7OztBQUdBO0FBQ0E7QUFHQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1956\n")},1957:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"a\", function() { return /* binding */ createXYChartLayoutWithTheme; });\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react/index.js\nvar react = __webpack_require__(0);\nvar react_default = /*#__PURE__*/__webpack_require__.n(react);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/prop-types/index.js\nvar prop_types = __webpack_require__(56);\nvar prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/classnames/index.js\nvar classnames = __webpack_require__(74);\nvar classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-shape/src/arc.js\nvar arc = __webpack_require__(2167);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-shape/src/pie.js + 2 modules\nvar pie = __webpack_require__(2238);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-shape/src/line.js\nvar line = __webpack_require__(1960);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-shape/src/lineRadial.js\nvar lineRadial = __webpack_require__(1961);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-shape/src/area.js\nvar src_area = __webpack_require__(2125);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-shape/src/stack.js\nvar stack = __webpack_require__(2169);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-shape/src/order/ascending.js\nvar ascending = __webpack_require__(1962);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-shape/src/order/descending.js\nvar descending = __webpack_require__(2171);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-shape/src/order/insideOut.js\nvar insideOut = __webpack_require__(2172);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-shape/src/order/none.js\nvar none = __webpack_require__(1930);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-shape/src/order/reverse.js\nvar order_reverse = __webpack_require__(2173);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-shape/src/offset/expand.js\nvar expand = __webpack_require__(2174);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-shape/src/offset/diverging.js\nvar diverging = __webpack_require__(2175);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-shape/src/offset/none.js\nvar offset_none = __webpack_require__(1931);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-shape/src/offset/silhouette.js\nvar silhouette = __webpack_require__(2176);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-shape/src/offset/wiggle.js\nvar wiggle = __webpack_require__(2177);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-shape/src/link/index.js\nvar src_link = __webpack_require__(1963);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/node_modules/@vx/axis/node_modules/@vx/group/dist/vx-group.es.js\n\n\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nfunction Group(_ref) {\n  var _ref$top = _ref.top,\n      top = _ref$top === undefined ? 0 : _ref$top,\n      _ref$left = _ref.left,\n      left = _ref$left === undefined ? 0 : _ref$left,\n      transform = _ref.transform,\n      className = _ref.className,\n      children = _ref.children,\n      restProps = objectWithoutProperties(_ref, ['top', 'left', 'transform', 'className', 'children']);\n\n  return react_default.a.createElement(\n    'g',\n    _extends({\n      className: classnames_default()('vx-group', className),\n      transform: transform || 'translate(' + left + ', ' + top + ')'\n    }, restProps),\n    children\n  );\n}\n\n\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/point/dist/vx-point.es.js\nvar vx_point_es = __webpack_require__(1904);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-shape/src/curve/linear.js\nvar linear = __webpack_require__(1929);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-path/src/path.js\nvar path = __webpack_require__(2483);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/node_modules/@vx/axis/node_modules/@vx/shape/dist/vx-shape.es.js\n\n\n\n\n\n\n\n\n\nfunction callOrValue(maybeFn, data) {\n  if (typeof maybeFn === 'function') {\n    return maybeFn(data);\n  }\n  return maybeFn;\n}\n\nfunction additionalProps(restProps, data) {\n  return Object.keys(restProps).reduce(function (ret, cur) {\n    ret[cur] = callOrValue(restProps[cur], data);\n    return ret;\n  }, {});\n}\n\nvar vx_shape_es_extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar vx_shape_es_objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\nfunction Arc(_ref) {\n  var className = _ref.className,\n      data = _ref.data,\n      centroid = _ref.centroid,\n      innerRadius = _ref.innerRadius,\n      outerRadius = _ref.outerRadius,\n      cornerRadius = _ref.cornerRadius,\n      startAngle = _ref.startAngle,\n      endAngle = _ref.endAngle,\n      padAngle = _ref.padAngle,\n      padRadius = _ref.padRadius,\n      restProps = vx_shape_es_objectWithoutProperties(_ref, ['className', 'data', 'centroid', 'innerRadius', 'outerRadius', 'cornerRadius', 'startAngle', 'endAngle', 'padAngle', 'padRadius']);\n\n  var arc$$1 = Object(arc[\"a\" /* default */])();\n  if (centroid) arc$$1.centroid(centroid);\n  if (innerRadius) arc$$1.innerRadius(innerRadius);\n  if (outerRadius) arc$$1.outerRadius(outerRadius);\n  if (cornerRadius) arc$$1.cornerRadius(cornerRadius);\n  if (startAngle) arc$$1.startAngle(startAngle);\n  if (endAngle) arc$$1.endAngle(endAngle);\n  if (padAngle) arc$$1.padAngle(padAngle);\n  if (padRadius) arc$$1.padRadius(padRadius);\n  return react_default.a.createElement('path', vx_shape_es_extends({ className: classnames_default()('vx-arc', className), d: arc$$1(data) }, additionalProps(restProps, data)));\n}\n\nfunction Pie(_ref) {\n  var _ref$className = _ref.className,\n      className = _ref$className === undefined ? '' : _ref$className,\n      _ref$top = _ref.top,\n      top = _ref$top === undefined ? 0 : _ref$top,\n      _ref$left = _ref.left,\n      left = _ref$left === undefined ? 0 : _ref$left,\n      data = _ref.data,\n      centroid = _ref.centroid,\n      _ref$innerRadius = _ref.innerRadius,\n      innerRadius = _ref$innerRadius === undefined ? 0 : _ref$innerRadius,\n      outerRadius = _ref.outerRadius,\n      cornerRadius = _ref.cornerRadius,\n      _ref$startAngle = _ref.startAngle,\n      startAngle = _ref$startAngle === undefined ? 0 : _ref$startAngle,\n      endAngle = _ref.endAngle,\n      padAngle = _ref.padAngle,\n      padRadius = _ref.padRadius,\n      pieSort = _ref.pieSort,\n      pieSortValues = _ref.pieSortValues,\n      pieValue = _ref.pieValue,\n      children = _ref.children,\n      restProps = vx_shape_es_objectWithoutProperties(_ref, ['className', 'top', 'left', 'data', 'centroid', 'innerRadius', 'outerRadius', 'cornerRadius', 'startAngle', 'endAngle', 'padAngle', 'padRadius', 'pieSort', 'pieSortValues', 'pieValue', 'children']);\n\n  var path$$1 = Object(arc[\"a\" /* default */])();\n  path$$1.innerRadius(innerRadius);\n  if (outerRadius) path$$1.outerRadius(outerRadius);\n  if (cornerRadius) path$$1.cornerRadius(cornerRadius);\n  if (padRadius) path$$1.padRadius(padRadius);\n  var pie$$1 = Object(pie[\"a\" /* default */])();\n  if (pieSort !== undefined) pie$$1.sort(pieSort);\n  if (pieSortValues !== undefined) pie$$1.sortValues(pieSortValues);\n  if (pieValue) pie$$1.value(pieValue);\n  if (padAngle != null) pie$$1.padAngle(padAngle);\n  if (startAngle != null) pie$$1.startAngle(startAngle);\n  if (endAngle != null) pie$$1.endAngle(endAngle);\n  var arcs = pie$$1(data);\n  var renderFunctionArg = {\n    arcs: arcs,\n    generatePathProps: function generatePathProps(arc$$1, index) {\n      return vx_shape_es_extends({\n        className: classnames_default()('vx-pie-arc', className),\n        d: path$$1(arc$$1)\n      }, additionalProps(restProps, vx_shape_es_extends({}, arc$$1, {\n        index: index,\n        centroid: centroid ? path$$1.centroid(arc$$1) : undefined\n      })));\n    },\n    generateCentroid: function generateCentroid(arc$$1) {\n      return centroid && centroid(path$$1.centroid(arc$$1), arc$$1);\n    }\n  };\n  return react_default.a.createElement(\n    Group,\n    { className: 'vx-pie-arcs-group', top: top, left: left },\n    children ? children(renderFunctionArg) : arcs.map(function (arc$$1, i) {\n      var pathProps = renderFunctionArg.generatePathProps(arc$$1, i);\n      return react_default.a.createElement(\n        'g',\n        { key: 'pie-arc-' + i },\n        react_default.a.createElement('path', pathProps),\n        renderFunctionArg.generateCentroid(arc$$1)\n      );\n    })\n  );\n}\n\nLine.propTypes = {\n  innerRef: prop_types_default.a.func\n};\n\nfunction Line(_ref) {\n  var _ref$from = _ref.from,\n      from = _ref$from === undefined ? new vx_point_es[\"Point\"]({ x: 0, y: 0 }) : _ref$from,\n      _ref$to = _ref.to,\n      to = _ref$to === undefined ? new vx_point_es[\"Point\"]({ x: 1, y: 1 }) : _ref$to,\n      _ref$stroke = _ref.stroke,\n      stroke = _ref$stroke === undefined ? 'black' : _ref$stroke,\n      _ref$strokeWidth = _ref.strokeWidth,\n      strokeWidth = _ref$strokeWidth === undefined ? 1 : _ref$strokeWidth,\n      _ref$strokeDasharray = _ref.strokeDasharray,\n      strokeDasharray = _ref$strokeDasharray === undefined ? '' : _ref$strokeDasharray,\n      _ref$transform = _ref.transform,\n      transform = _ref$transform === undefined ? '' : _ref$transform,\n      _ref$className = _ref.className,\n      className = _ref$className === undefined ? '' : _ref$className,\n      data = _ref.data,\n      innerRef = _ref.innerRef,\n      restProps = vx_shape_es_objectWithoutProperties(_ref, ['from', 'to', 'stroke', 'strokeWidth', 'strokeDasharray', 'transform', 'className', 'data', 'innerRef']);\n\n  return react_default.a.createElement('line', vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-line', className),\n    x1: from.x,\n    y1: from.y,\n    x2: to.x,\n    y2: to.y,\n    stroke: stroke,\n    strokeWidth: strokeWidth,\n    strokeDasharray: strokeDasharray,\n    transform: transform\n  }, additionalProps(restProps, data)));\n}\n\nLinePath.propTypes = {\n  innerRef: prop_types_default.a.func,\n  xScale: prop_types_default.a.func,\n  yScale: prop_types_default.a.func,\n  data: prop_types_default.a.array,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  defined: prop_types_default.a.func,\n  stroke: prop_types_default.a.string,\n  strokeWidth: prop_types_default.a.number,\n  glyph: prop_types_default.a.func,\n  curve: prop_types_default.a.func\n};\n\nfunction LinePath(_ref) {\n  var children = _ref.children,\n      data = _ref.data,\n      xScale = _ref.xScale,\n      yScale = _ref.yScale,\n      x = _ref.x,\n      y = _ref.y,\n      _ref$defined = _ref.defined,\n      defined = _ref$defined === undefined ? function () {\n    return true;\n  } : _ref$defined,\n      className = _ref.className,\n      _ref$stroke = _ref.stroke,\n      stroke = _ref$stroke === undefined ? 'steelblue' : _ref$stroke,\n      _ref$strokeWidth = _ref.strokeWidth,\n      strokeWidth = _ref$strokeWidth === undefined ? 2 : _ref$strokeWidth,\n      _ref$strokeDasharray = _ref.strokeDasharray,\n      strokeDasharray = _ref$strokeDasharray === undefined ? '' : _ref$strokeDasharray,\n      _ref$strokeDashoffset = _ref.strokeDashoffset,\n      strokeDashoffset = _ref$strokeDashoffset === undefined ? 0 : _ref$strokeDashoffset,\n      _ref$fill = _ref.fill,\n      fill = _ref$fill === undefined ? 'none' : _ref$fill,\n      _ref$curve = _ref.curve,\n      curve = _ref$curve === undefined ? linear[\"a\" /* default */] : _ref$curve,\n      glyph = _ref.glyph,\n      innerRef = _ref.innerRef,\n      restProps = vx_shape_es_objectWithoutProperties(_ref, ['children', 'data', 'xScale', 'yScale', 'x', 'y', 'defined', 'className', 'stroke', 'strokeWidth', 'strokeDasharray', 'strokeDashoffset', 'fill', 'curve', 'glyph', 'innerRef']);\n\n  var path$$1 = Object(line[\"a\" /* default */])().x(function () {\n    return xScale(x.apply(undefined, arguments));\n  }).y(function () {\n    return yScale(y.apply(undefined, arguments));\n  }).defined(defined).curve(curve);\n  if (children) return children({ path: path$$1 });\n  return react_default.a.createElement(\n    'g',\n    null,\n    react_default.a.createElement('path', vx_shape_es_extends({\n      ref: innerRef,\n      className: classnames_default()('vx-linepath', className),\n      d: path$$1(data),\n      stroke: stroke,\n      strokeWidth: strokeWidth,\n      strokeDasharray: strokeDasharray,\n      strokeDashoffset: strokeDashoffset,\n      fill: fill\n    }, additionalProps(restProps, data))),\n    glyph && react_default.a.createElement(\n      'g',\n      { className: 'vx-linepath-glyphs' },\n      data.map(glyph)\n    )\n  );\n}\n\nLineRadial.propTypes = {\n  innerRef: prop_types_default.a.func\n};\n\nfunction LineRadial(_ref) {\n  var _ref$className = _ref.className,\n      className = _ref$className === undefined ? '' : _ref$className,\n      angle = _ref.angle,\n      radius = _ref.radius,\n      defined = _ref.defined,\n      curve = _ref.curve,\n      data = _ref.data,\n      innerRef = _ref.innerRef,\n      restProps = vx_shape_es_objectWithoutProperties(_ref, ['className', 'angle', 'radius', 'defined', 'curve', 'data', 'innerRef']);\n\n  var path$$1 = Object(lineRadial[\"a\" /* default */])();\n  if (angle) path$$1.angle(angle);\n  if (radius) path$$1.radius(radius);\n  if (defined) path$$1.defined(defined);\n  if (curve) path$$1.curve(curve);\n  return react_default.a.createElement(\n    'g',\n    null,\n    react_default.a.createElement('path', vx_shape_es_extends({\n      ref: innerRef,\n      className: classnames_default()('vx-line-radial', className),\n      d: path$$1(data)\n    }, additionalProps(restProps, data)))\n  );\n}\n\nArea.propTypes = {\n  x: prop_types_default.a.func,\n  x0: prop_types_default.a.func,\n  x1: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  y0: prop_types_default.a.func,\n  y1: prop_types_default.a.func,\n  xScale: prop_types_default.a.func,\n  yScale: prop_types_default.a.func,\n  data: prop_types_default.a.array,\n  defined: prop_types_default.a.func,\n  className: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.bool, prop_types_default.a.object, prop_types_default.a.array]),\n  innerRef: prop_types_default.a.func,\n  strokeDasharray: prop_types_default.a.string,\n  strokeWidth: prop_types_default.a.number,\n  stroke: prop_types_default.a.string,\n  fill: prop_types_default.a.string,\n  curve: prop_types_default.a.func\n};\n\nfunction Area(_ref) {\n  var children = _ref.children,\n      x = _ref.x,\n      x0 = _ref.x0,\n      x1 = _ref.x1,\n      y = _ref.y,\n      y0 = _ref.y0,\n      y1 = _ref.y1,\n      xScale = _ref.xScale,\n      yScale = _ref.yScale,\n      _ref$data = _ref.data,\n      data = _ref$data === undefined ? [] : _ref$data,\n      _ref$defined = _ref.defined,\n      defined = _ref$defined === undefined ? function () {\n    return true;\n  } : _ref$defined,\n      className = _ref.className,\n      strokeDasharray = _ref.strokeDasharray,\n      _ref$strokeWidth = _ref.strokeWidth,\n      strokeWidth = _ref$strokeWidth === undefined ? 2 : _ref$strokeWidth,\n      _ref$stroke = _ref.stroke,\n      stroke = _ref$stroke === undefined ? 'black' : _ref$stroke,\n      _ref$fill = _ref.fill,\n      fill = _ref$fill === undefined ? 'rgba(0,0,0,0.3)' : _ref$fill,\n      curve = _ref.curve,\n      innerRef = _ref.innerRef,\n      restProps = vx_shape_es_objectWithoutProperties(_ref, ['children', 'x', 'x0', 'x1', 'y', 'y0', 'y1', 'xScale', 'yScale', 'data', 'defined', 'className', 'strokeDasharray', 'strokeWidth', 'stroke', 'fill', 'curve', 'innerRef']);\n\n  var path$$1 = Object(src_area[\"a\" /* default */])();\n  if (x) path$$1.x(function () {\n    return xScale(x.apply(undefined, arguments));\n  });\n  if (x0) path$$1.x0(function () {\n    return xScale(x0.apply(undefined, arguments));\n  });\n  if (x1) path$$1.x1(function () {\n    return xScale(x1.apply(undefined, arguments));\n  });\n  if (y) path$$1.y(function () {\n    return yScale(y.apply(undefined, arguments));\n  });\n  if (y0) path$$1.y0(function () {\n    return yScale(y0.apply(undefined, arguments));\n  });\n  if (y1) path$$1.y1(function () {\n    return yScale(y1.apply(undefined, arguments));\n  });\n  if (defined) path$$1.defined(defined);\n  if (curve) path$$1.curve(curve);\n  if (children) return children({ path: path$$1 });\n  return react_default.a.createElement(\n    'g',\n    null,\n    react_default.a.createElement('path', vx_shape_es_extends({\n      ref: innerRef,\n      className: classnames_default()('vx-area', className),\n      d: path$$1(data),\n      stroke: stroke,\n      strokeWidth: strokeWidth,\n      strokeDasharray: strokeDasharray,\n      fill: fill\n    }, additionalProps(restProps, data)))\n  );\n}\n\nAreaClosed.propTypes = {\n  innerRef: prop_types_default.a.func\n};\n\nfunction AreaClosed(_ref) {\n  var x = _ref.x,\n      y = _ref.y,\n      y0 = _ref.y0,\n      xScale = _ref.xScale,\n      yScale = _ref.yScale,\n      data = _ref.data,\n      _ref$defined = _ref.defined,\n      defined = _ref$defined === undefined ? function () {\n    return true;\n  } : _ref$defined,\n      className = _ref.className,\n      strokeDasharray = _ref.strokeDasharray,\n      _ref$strokeWidth = _ref.strokeWidth,\n      strokeWidth = _ref$strokeWidth === undefined ? 2 : _ref$strokeWidth,\n      _ref$stroke = _ref.stroke,\n      stroke = _ref$stroke === undefined ? 'black' : _ref$stroke,\n      _ref$fill = _ref.fill,\n      fill = _ref$fill === undefined ? 'rgba(0,0,0,0.3)' : _ref$fill,\n      curve = _ref.curve,\n      innerRef = _ref.innerRef,\n      restProps = vx_shape_es_objectWithoutProperties(_ref, ['x', 'y', 'y0', 'xScale', 'yScale', 'data', 'defined', 'className', 'strokeDasharray', 'strokeWidth', 'stroke', 'fill', 'curve', 'innerRef']);\n\n  var path$$1 = Object(src_area[\"a\" /* default */])().x(function () {\n    return xScale(x.apply(undefined, arguments));\n  }).y0(y0 || yScale.range()[0]).y1(function () {\n    return yScale(y.apply(undefined, arguments));\n  }).defined(defined);\n  if (curve) path$$1.curve(curve);\n  return react_default.a.createElement(\n    'g',\n    null,\n    react_default.a.createElement('path', vx_shape_es_extends({\n      ref: innerRef,\n      className: classnames_default()('vx-area-closed', className),\n      d: path$$1(data),\n      stroke: stroke,\n      strokeWidth: strokeWidth,\n      strokeDasharray: strokeDasharray,\n      fill: fill\n    }, additionalProps(restProps, data)))\n  );\n}\n\nfunction AreaStack(_ref) {\n  var className = _ref.className,\n      _ref$top = _ref.top,\n      _ref$left = _ref.left,\n      keys = _ref.keys,\n      data = _ref.data,\n      curve = _ref.curve,\n      defined = _ref.defined,\n      x = _ref.x,\n      x0 = _ref.x0,\n      x1 = _ref.x1,\n      y0 = _ref.y0,\n      y1 = _ref.y1,\n      glyph = _ref.glyph,\n      _ref$reverse = _ref.reverse,\n      reverse = _ref$reverse === undefined ? false : _ref$reverse,\n      restProps = vx_shape_es_objectWithoutProperties(_ref, ['className', 'top', 'left', 'keys', 'data', 'curve', 'defined', 'x', 'x0', 'x1', 'y0', 'y1', 'glyph', 'reverse']);\n\n  var stack$$1 = Object(stack[\"a\" /* default */])();\n  if (keys) stack$$1.keys(keys);\n\n  var path$$1 = Object(src_area[\"a\" /* default */])();\n  if (x) path$$1.x(x);\n  if (x0) path$$1.x0(x0);\n  if (x1) path$$1.x1(x1);\n  if (y0) path$$1.y0(y0);\n  if (y1) path$$1.y1(y1);\n  if (curve) path$$1.curve(curve);\n  if (defined) path$$1.defined(defined);\n\n  var seriesData = stack$$1(data);\n  if (reverse) seriesData.reverse();\n\n  return react_default.a.createElement(\n    'g',\n    null,\n    seriesData.map(function (series, i) {\n      return react_default.a.createElement('path', vx_shape_es_extends({\n        className: classnames_default()('vx-area-stack', className),\n        key: 'area-stack-' + i + '-' + (series.key || ''),\n        d: path$$1(series)\n      }, additionalProps(restProps, {\n        datum: series[i],\n        index: i,\n        series: series\n      })));\n    }),\n    !!glyph && react_default.a.createElement(\n      'g',\n      { className: 'vx-area-stack-glyphs' },\n      data.map(glyph)\n    )\n  );\n}\n\nBar.propTypes = {\n  innerRef: prop_types_default.a.func\n};\n\nfunction Bar(_ref) {\n  var className = _ref.className,\n      innerRef = _ref.innerRef,\n      data = _ref.data,\n      _ref$x = _ref.x,\n      x = _ref$x === undefined ? 0 : _ref$x,\n      _ref$y = _ref.y,\n      y = _ref$y === undefined ? 0 : _ref$y,\n      width = _ref.width,\n      height = _ref.height,\n      rx = _ref.rx,\n      ry = _ref.ry,\n      _ref$fill = _ref.fill,\n      fill = _ref$fill === undefined ? 'steelblue' : _ref$fill,\n      fillOpacity = _ref.fillOpacity,\n      stroke = _ref.stroke,\n      strokeWidth = _ref.strokeWidth,\n      strokeDasharray = _ref.strokeDasharray,\n      strokeLinecap = _ref.strokeLinecap,\n      strokeLinejoin = _ref.strokeLinejoin,\n      strokeMiterlimit = _ref.strokeMiterlimit,\n      strokeOpacity = _ref.strokeOpacity,\n      restProps = vx_shape_es_objectWithoutProperties(_ref, ['className', 'innerRef', 'data', 'x', 'y', 'width', 'height', 'rx', 'ry', 'fill', 'fillOpacity', 'stroke', 'strokeWidth', 'strokeDasharray', 'strokeLinecap', 'strokeLinejoin', 'strokeMiterlimit', 'strokeOpacity']);\n\n  return react_default.a.createElement('rect', vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-bar', className),\n    x: x,\n    y: y,\n    width: width,\n    height: height,\n    rx: rx,\n    ry: ry,\n    fill: fill,\n    fillOpacity: fillOpacity,\n    stroke: stroke,\n    strokeWidth: strokeWidth,\n    strokeDasharray: strokeDasharray,\n    strokeLinecap: strokeLinecap,\n    strokeLinejoin: strokeLinejoin,\n    strokeMiterlimit: strokeMiterlimit,\n    strokeOpacity: strokeOpacity\n  }, additionalProps(restProps, data)));\n}\n\nfunction BarGroup(_ref) {\n  var data = _ref.data,\n      className = _ref.className,\n      top = _ref.top,\n      left = _ref.left,\n      x0 = _ref.x0,\n      x0Scale = _ref.x0Scale,\n      x1Scale = _ref.x1Scale,\n      yScale = _ref.yScale,\n      zScale = _ref.zScale,\n      keys = _ref.keys,\n      height = _ref.height,\n      restProps = vx_shape_es_objectWithoutProperties(_ref, ['data', 'className', 'top', 'left', 'x0', 'x0Scale', 'x1Scale', 'yScale', 'zScale', 'keys', 'height']);\n\n  var format = x0Scale.tickFormat ? x0Scale.tickFormat() : function (d) {\n    return d;\n  };\n  return react_default.a.createElement(\n    Group,\n    { className: classnames_default()('vx-bar-group', className), top: top, left: left },\n    data && data.map(function (d, i) {\n      return react_default.a.createElement(\n        Group,\n        { key: 'bar-group-' + i + '-' + x0(d), left: x0Scale(x0(d)) },\n        keys && keys.map(function (key, i) {\n          var value = d[key];\n          return react_default.a.createElement(Bar, vx_shape_es_extends({\n            key: 'bar-group-bar-' + i + '-' + value + '-' + key,\n            x: x1Scale(key),\n            y: yScale(value),\n            width: x1Scale.bandwidth(),\n            height: height - yScale(value),\n            fill: zScale(key),\n            data: {\n              key: key,\n              value: value,\n              x: format(x0(d)),\n              data: d\n            }\n          }, restProps));\n        })\n      );\n    })\n  );\n}\n\nBarGroup.propTypes = {\n  data: prop_types_default.a.array.isRequired,\n  x0: prop_types_default.a.func.isRequired,\n  x0Scale: prop_types_default.a.func.isRequired,\n  x1Scale: prop_types_default.a.func.isRequired,\n  yScale: prop_types_default.a.func.isRequired,\n  zScale: prop_types_default.a.func.isRequired,\n  keys: prop_types_default.a.array.isRequired,\n  height: prop_types_default.a.number.isRequired,\n  className: prop_types_default.a.string,\n  top: prop_types_default.a.number,\n  left: prop_types_default.a.number\n};\n\nfunction BarGroupHorizontal(_ref) {\n  var data = _ref.data,\n      className = _ref.className,\n      top = _ref.top,\n      left = _ref.left,\n      y0 = _ref.y0,\n      y0Scale = _ref.y0Scale,\n      y1Scale = _ref.y1Scale,\n      xScale = _ref.xScale,\n      zScale = _ref.zScale,\n      keys = _ref.keys,\n      width = _ref.width,\n      restProps = vx_shape_es_objectWithoutProperties(_ref, ['data', 'className', 'top', 'left', 'y0', 'y0Scale', 'y1Scale', 'xScale', 'zScale', 'keys', 'width']);\n\n  var format = y0Scale.tickFormat ? y0Scale.tickFormat() : function (d) {\n    return d;\n  };\n  return react_default.a.createElement(\n    Group,\n    { className: classnames_default()('vx-bar-group-horizontal', className), top: top, left: left },\n    data && data.map(function (d, i) {\n      return react_default.a.createElement(\n        Group,\n        { key: 'bar-group-' + i + '-' + y0(d), top: y0Scale(y0(d)) },\n        keys && keys.map(function (key, i) {\n          var value = d[key];\n          return react_default.a.createElement(Bar, vx_shape_es_extends({\n            key: 'bar-group-bar-' + i + '-' + value + '-' + key,\n            x: 0,\n            y: y1Scale(key),\n            width: width - xScale(value),\n            height: y1Scale.bandwidth(),\n            fill: zScale(key),\n            data: {\n              key: key,\n              value: value,\n              y: format(y0(d)),\n              data: d\n            }\n          }, restProps));\n        })\n      );\n    })\n  );\n}\n\nBarGroupHorizontal.propTypes = {\n  data: prop_types_default.a.array.isRequired,\n  y0: prop_types_default.a.func.isRequired,\n  y0Scale: prop_types_default.a.func.isRequired,\n  y1Scale: prop_types_default.a.func.isRequired,\n  xScale: prop_types_default.a.func.isRequired,\n  zScale: prop_types_default.a.func.isRequired,\n  keys: prop_types_default.a.array.isRequired,\n  width: prop_types_default.a.number.isRequired,\n  className: prop_types_default.a.string,\n  top: prop_types_default.a.number,\n  left: prop_types_default.a.number\n};\n\nfunction BarStack(_ref) {\n  var data = _ref.data,\n      className = _ref.className,\n      top = _ref.top,\n      left = _ref.left,\n      x = _ref.x,\n      xScale = _ref.xScale,\n      yScale = _ref.yScale,\n      zScale = _ref.zScale,\n      keys = _ref.keys,\n      height = _ref.height,\n      restProps = vx_shape_es_objectWithoutProperties(_ref, ['data', 'className', 'top', 'left', 'x', 'xScale', 'yScale', 'zScale', 'keys', 'height']);\n\n  var series = Object(stack[\"a\" /* default */])().keys(keys)(data);\n  var format = xScale.tickFormat ? xScale.tickFormat() : function (d) {\n    return d;\n  };\n  var bandwidth = xScale.bandwidth();\n  var step = xScale.step();\n  var paddingInner = xScale.paddingInner();\n  var paddingOuter = xScale.paddingOuter();\n  return react_default.a.createElement(\n    Group,\n    { className: classnames_default()('vx-bar-stack', className), top: top, left: left },\n    series && series.map(function (s, i) {\n      return react_default.a.createElement(\n        Group,\n        { key: 'vx-bar-stack-' + i },\n        s.map(function (d, ii) {\n          var barHeight = yScale(d[0]) - yScale(d[1]);\n          return react_default.a.createElement(Bar, vx_shape_es_extends({\n            key: 'bar-group-bar-' + i + '-' + ii + '-' + s.key,\n            x: xScale(x(d.data)),\n            y: yScale(d[1]),\n            width: bandwidth,\n            height: barHeight,\n            fill: zScale(s.key),\n            data: {\n              bandwidth: bandwidth,\n              paddingInner: paddingInner,\n              paddingOuter: paddingOuter,\n              step: step,\n              key: s.key,\n              value: d[1],\n              height: barHeight,\n              width: bandwidth,\n              x: x(d.data),\n              xFormatted: format(x(d.data)),\n              data: d.data\n            }\n          }, restProps));\n        })\n      );\n    })\n  );\n}\n\nBarStack.propTypes = {\n  data: prop_types_default.a.array.isRequired,\n  x: prop_types_default.a.func.isRequired,\n  xScale: prop_types_default.a.func.isRequired,\n  yScale: prop_types_default.a.func.isRequired,\n  zScale: prop_types_default.a.func.isRequired,\n  keys: prop_types_default.a.array.isRequired,\n  className: prop_types_default.a.string,\n  top: prop_types_default.a.number,\n  left: prop_types_default.a.number\n};\n\nfunction BarStackHorizontal(_ref) {\n  var data = _ref.data,\n      className = _ref.className,\n      top = _ref.top,\n      left = _ref.left,\n      y = _ref.y,\n      xScale = _ref.xScale,\n      yScale = _ref.yScale,\n      zScale = _ref.zScale,\n      keys = _ref.keys,\n      height = _ref.height,\n      restProps = vx_shape_es_objectWithoutProperties(_ref, ['data', 'className', 'top', 'left', 'y', 'xScale', 'yScale', 'zScale', 'keys', 'height']);\n\n  var series = Object(stack[\"a\" /* default */])().keys(keys)(data);\n  var format = yScale.tickFormat ? yScale.tickFormat() : function (d) {\n    return d;\n  };\n  var bandwidth = yScale.bandwidth();\n  var step = yScale.step();\n  var paddingInner = yScale.paddingInner();\n  var paddingOuter = yScale.paddingOuter();\n  return react_default.a.createElement(\n    Group,\n    { className: classnames_default()('vx-bar-stack-horizontal', className), top: top, left: left },\n    series && series.map(function (s, i) {\n      return react_default.a.createElement(\n        Group,\n        { key: 'vx-bar-stack-horizontal-' + i },\n        s.map(function (d, ii) {\n          var barWidth = xScale(d[1]) - xScale(d[0]);\n          return react_default.a.createElement(Bar, vx_shape_es_extends({\n            key: 'bar-group-bar-' + i + '-' + ii + '-' + s.key,\n            x: xScale(d[0]),\n            y: yScale(y(d.data)),\n            width: barWidth,\n            height: bandwidth,\n            fill: zScale(s.key),\n            data: {\n              bandwidth: bandwidth,\n              paddingInner: paddingInner,\n              paddingOuter: paddingOuter,\n              step: step,\n              key: s.key,\n              value: d[0],\n              height: bandwidth,\n              width: barWidth,\n              y: y(d.data),\n              yFormatted: format(y(d.data)),\n              data: d.data\n            }\n          }, restProps));\n        })\n      );\n    })\n  );\n}\n\nBarStackHorizontal.propTypes = {\n  data: prop_types_default.a.array.isRequired,\n  y: prop_types_default.a.func.isRequired,\n  xScale: prop_types_default.a.func.isRequired,\n  yScale: prop_types_default.a.func.isRequired,\n  zScale: prop_types_default.a.func.isRequired,\n  keys: prop_types_default.a.array.isRequired,\n  className: prop_types_default.a.string,\n  top: prop_types_default.a.number,\n  left: prop_types_default.a.number\n};\n\nvar STACK_ORDERS = {\n  ascending: ascending[\"a\" /* default */],\n  descending: descending[\"a\" /* default */],\n  insideout: insideOut[\"a\" /* default */],\n  none: none[\"a\" /* default */],\n  reverse: order_reverse[\"a\" /* default */]\n};\n\nvar STACK_ORDER_NAMES = Object.keys(STACK_ORDERS);\n\nfunction stackOrder(order) {\n  return STACK_ORDERS[order] || STACK_ORDERS.none;\n}\n\nvar STACK_OFFSETS = {\n  expand: expand[\"a\" /* default */],\n  diverging: diverging[\"a\" /* default */],\n  none: offset_none[\"a\" /* default */],\n  silhouette: silhouette[\"a\" /* default */],\n  wiggle: wiggle[\"a\" /* default */]\n};\n\nvar STACK_OFFSET_NAMES = Object.keys(STACK_OFFSETS);\n\nfunction stackOffset(offset) {\n  return STACK_OFFSETS[offset] || STACK_OFFSETS.none;\n}\n\nfunction Stack(_ref) {\n  var className = _ref.className,\n      _ref$top = _ref.top,\n      top = _ref$top === undefined ? 0 : _ref$top,\n      _ref$left = _ref.left,\n      left = _ref$left === undefined ? 0 : _ref$left,\n      keys = _ref.keys,\n      data = _ref.data,\n      curve = _ref.curve,\n      defined = _ref.defined,\n      x = _ref.x,\n      x0 = _ref.x0,\n      x1 = _ref.x1,\n      y0 = _ref.y0,\n      y1 = _ref.y1,\n      value = _ref.value,\n      order = _ref.order,\n      offset = _ref.offset,\n      render = _ref.render,\n      _ref$reverse = _ref.reverse,\n      reverse = _ref$reverse === undefined ? false : _ref$reverse,\n      restProps = vx_shape_es_objectWithoutProperties(_ref, ['className', 'top', 'left', 'keys', 'data', 'curve', 'defined', 'x', 'x0', 'x1', 'y0', 'y1', 'value', 'order', 'offset', 'render', 'reverse']);\n\n  var stack$$1 = Object(stack[\"a\" /* default */])();\n  if (keys) stack$$1.keys(keys);\n  if (value) stack$$1.value(value);\n  if (order) stack$$1.order(stackOrder(order));\n  if (offset) stack$$1.offset(stackOffset(offset));\n\n  var path$$1 = Object(src_area[\"a\" /* default */])();\n  if (x) path$$1.x(x);\n  if (x0) path$$1.x0(x0);\n  if (x1) path$$1.x1(x1);\n  if (y0) path$$1.y0(y0);\n  if (y1) path$$1.y1(y1);\n  if (curve) path$$1.curve(curve);\n  if (defined) path$$1.defined(defined);\n\n  var seriesData = stack$$1(data);\n  if (reverse) seriesData.reverse();\n\n  if (render) return react_default.a.createElement(\n    Group,\n    { top: top, left: left },\n    render({ seriesData: seriesData, path: path$$1 })\n  );\n\n  return react_default.a.createElement(\n    Group,\n    { top: top, left: left },\n    seriesData.map(function (series, i) {\n      return react_default.a.createElement('path', vx_shape_es_extends({\n        className: classnames_default()('vx-stack', className),\n        key: 'stack-' + i + '-' + (series.key || ''),\n        d: path$$1(series)\n      }, additionalProps(restProps, {\n        datum: series[i],\n        index: i,\n        series: series\n      })));\n    })\n  );\n}\n\nvar degreesToRadians = function degreesToRadians(degrees) {\n  return Math.PI / 180 * degrees;\n};\n\nfunction pathHorizontalDiagonal(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y;\n\n  return function (data) {\n    var link = Object(src_link[\"a\" /* linkHorizontal */])();\n    link.x(x);\n    link.y(y);\n    link.source(source);\n    link.target(target);\n    return link(data);\n  };\n}\n\nLinkHorizontal.propTypes = {\n  innerRef: prop_types_default.a.func,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func,\n  path: prop_types_default.a.func\n};\n\nfunction LinkHorizontal(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.y;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.x;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || pathHorizontalDiagonal({ source: source, target: target, x: x, y: y });\n  return react_default.a.createElement('path', vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link-horizontal', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathVerticalDiagonal(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y;\n\n  return function (data) {\n    var link = Object(src_link[\"c\" /* linkVertical */])();\n    link.x(x);\n    link.y(y);\n    link.source(source);\n    link.target(target);\n    return link(data);\n  };\n}\n\nLinkVertical.propTypes = {\n  innerRef: prop_types_default.a.func,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func,\n  path: prop_types_default.a.func\n};\n\nfunction LinkVertical(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.x;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.y;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || pathVerticalDiagonal({ source: source, target: target, x: x, y: y });\n  return react_default.a.createElement('path', vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link-vertical', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathRadialDiagonal(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      angle = _ref.angle,\n      radius = _ref.radius;\n\n  return function (data) {\n    var link = Object(src_link[\"b\" /* linkRadial */])();\n    link.angle(angle);\n    link.radius(radius);\n    link.source(source);\n    link.target(target);\n    return link(data);\n  };\n}\n\nLinkRadial.propTypes = {\n  innerRef: prop_types_default.a.func,\n  angle: prop_types_default.a.func,\n  radius: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func,\n  path: prop_types_default.a.func\n};\n\nfunction LinkRadial(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$angle = _ref2.angle,\n      angle = _ref2$angle === undefined ? function (d) {\n    return d.x;\n  } : _ref2$angle,\n      _ref2$radius = _ref2.radius,\n      radius = _ref2$radius === undefined ? function (d) {\n    return d.y;\n  } : _ref2$radius,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'angle', 'radius', 'source', 'target']);\n\n  path$$1 = path$$1 || pathRadialDiagonal({ source: source, target: target, angle: angle, radius: radius });\n  return react_default.a.createElement('path', vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link-radius', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathHorizontalCurve(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y,\n      percent = _ref.percent;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sx = x(sourceData);\n    var sy = y(sourceData);\n    var tx = x(targetData);\n    var ty = y(targetData);\n\n    var dx = tx - sx;\n    var dy = ty - sy;\n    var ix = percent * (dx + dy);\n    var iy = percent * (dy - dx);\n\n    var path$$1 = Object(path[\"a\" /* default */])();\n    path$$1.moveTo(sx, sy);\n    path$$1.bezierCurveTo(sx + ix, sy + iy, tx + iy, ty - ix, tx, ty);\n\n    return path$$1.toString();\n  };\n}\n\nLinkHorizontalCurve.propTypes = {\n  innerRef: prop_types_default.a.func,\n  percent: prop_types_default.a.number,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func,\n  path: prop_types_default.a.func\n};\n\nfunction LinkHorizontalCurve(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.y;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.x;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      _ref2$percent = _ref2.percent,\n      percent = _ref2$percent === undefined ? 0.2 : _ref2$percent,\n      restProps = vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target', 'percent']);\n\n  path$$1 = path$$1 || pathHorizontalCurve({ source: source, target: target, x: x, y: y, percent: percent });\n  return react_default.a.createElement('path', vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathVerticalCurve(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y,\n      percent = _ref.percent;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sx = x(sourceData);\n    var sy = y(sourceData);\n    var tx = x(targetData);\n    var ty = y(targetData);\n\n    var dx = tx - sx;\n    var dy = ty - sy;\n    var ix = percent * (dx + dy);\n    var iy = percent * (dy - dx);\n\n    var path$$1 = Object(path[\"a\" /* default */])();\n    path$$1.moveTo(sx, sy);\n    path$$1.bezierCurveTo(sx + ix, sy + iy, tx + iy, ty - ix, tx, ty);\n\n    return path$$1.toString();\n  };\n}\n\nLinkVerticalCurve.propTypes = {\n  innerRef: prop_types_default.a.func,\n  percent: prop_types_default.a.number,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func,\n  path: prop_types_default.a.func\n};\n\nfunction LinkVerticalCurve(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.x;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.y;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      _ref2$percent = _ref2.percent,\n      percent = _ref2$percent === undefined ? 0.2 : _ref2$percent,\n      restProps = vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target', 'percent']);\n\n  path$$1 = path$$1 || pathVerticalCurve({ source: source, target: target, x: x, y: y, percent: percent });\n  return react_default.a.createElement('path', vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathRadialCurve(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y,\n      percent = _ref.percent;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sa = x(sourceData) - Math.PI / 2;\n    var sr = y(sourceData);\n    var ta = x(targetData) - Math.PI / 2;\n    var tr = y(targetData);\n\n    var sc = Math.cos(sa);\n    var ss = Math.sin(sa);\n    var tc = Math.cos(ta);\n    var ts = Math.sin(ta);\n\n    var sx = sr * sc;\n    var sy = sr * ss;\n    var tx = tr * tc;\n    var ty = tr * ts;\n\n    var dx = tx - sx;\n    var dy = ty - sy;\n    var ix = percent * (dx + dy);\n    var iy = percent * (dy - dx);\n\n    var path$$1 = Object(path[\"a\" /* default */])();\n    path$$1.moveTo(sx, sy);\n    path$$1.bezierCurveTo(sx + ix, sy + iy, tx + iy, ty - ix, tx, ty);\n\n    return path$$1.toString();\n  };\n}\n\nLinkRadialCurve.propTypes = {\n  innerRef: prop_types_default.a.func,\n  percent: prop_types_default.a.number,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func,\n  path: prop_types_default.a.func\n};\n\nfunction LinkRadialCurve(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.x;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.y;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      _ref2$percent = _ref2.percent,\n      percent = _ref2$percent === undefined ? 0.2 : _ref2$percent,\n      restProps = vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target', 'percent']);\n\n  path$$1 = path$$1 || pathRadialCurve({ source: source, target: target, x: x, y: y, percent: percent });\n  return react_default.a.createElement('path', vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathHorizontalLine(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sx = x(sourceData);\n    var sy = y(sourceData);\n    var tx = x(targetData);\n    var ty = y(targetData);\n\n    var path$$1 = Object(path[\"a\" /* default */])();\n    path$$1.moveTo(sx, sy);\n    path$$1.lineTo(tx, ty);\n\n    return path$$1.toString();\n  };\n}\n\nLinkHorizontalLine.propTypes = {\n  innerRef: prop_types_default.a.func,\n  path: prop_types_default.a.func,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func\n};\n\nfunction LinkHorizontalLine(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.y;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.x;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || pathHorizontalLine({ source: source, target: target, x: x, y: y });\n  return react_default.a.createElement('path', vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathVerticalLine(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sx = x(sourceData);\n    var sy = y(sourceData);\n    var tx = x(targetData);\n    var ty = y(targetData);\n\n    var path$$1 = Object(path[\"a\" /* default */])();\n    path$$1.moveTo(sx, sy);\n    path$$1.lineTo(tx, ty);\n\n    return path$$1.toString();\n  };\n}\n\nLinkVerticalLine.propTypes = {\n  innerRef: prop_types_default.a.func,\n  path: prop_types_default.a.func,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func\n};\n\nfunction LinkVerticalLine(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.x;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.y;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || pathVerticalLine({ source: source, target: target, x: x, y: y });\n  return react_default.a.createElement('path', vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathRadialLine(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sa = x(sourceData) - Math.PI / 2;\n    var sr = y(sourceData);\n    var ta = x(targetData) - Math.PI / 2;\n    var tr = y(targetData);\n\n    var sc = Math.cos(sa);\n    var ss = Math.sin(sa);\n    var tc = Math.cos(ta);\n    var ts = Math.sin(ta);\n\n    var path$$1 = Object(path[\"a\" /* default */])();\n    path$$1.moveTo(sr * sc, sr * ss);\n    path$$1.lineTo(tr * tc, tr * ts);\n\n    return path$$1.toString();\n  };\n}\n\nLinkRadialStep.propTypes = {\n  innerRef: prop_types_default.a.func,\n  path: prop_types_default.a.func,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func\n};\n\nfunction LinkRadialStep(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.x;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.y;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || pathRadialLine({ source: source, target: target, x: x, y: y });\n  return react_default.a.createElement('path', vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathHorizontalStep(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y,\n      percent = _ref.percent;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sx = x(sourceData);\n    var sy = y(sourceData);\n    var tx = x(targetData);\n    var ty = y(targetData);\n\n    var path$$1 = Object(path[\"a\" /* default */])();\n    path$$1.moveTo(sx, sy);\n    path$$1.lineTo(sx + (tx - sx) * percent, sy);\n    path$$1.lineTo(sx + (tx - sx) * percent, ty);\n    path$$1.lineTo(tx, ty);\n\n    return path$$1.toString();\n  };\n}\n\nLinkHorizontalStep.propTypes = {\n  innerRef: prop_types_default.a.func,\n  percent: prop_types_default.a.number,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func,\n  path: prop_types_default.a.func\n};\n\nfunction LinkHorizontalStep(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$percent = _ref2.percent,\n      percent = _ref2$percent === undefined ? 0.5 : _ref2$percent,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.y;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.x;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'percent', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || pathHorizontalStep({ source: source, target: target, x: x, y: y, percent: percent });\n  return react_default.a.createElement('path', vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathVerticalStep(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y,\n      percent = _ref.percent;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sx = x(sourceData);\n    var sy = y(sourceData);\n    var tx = x(targetData);\n    var ty = y(targetData);\n\n    var path$$1 = Object(path[\"a\" /* default */])();\n    path$$1.moveTo(sx, sy);\n    path$$1.lineTo(sx, sy + (ty - sy) * percent);\n    path$$1.lineTo(tx, sy + (ty - sy) * percent);\n    path$$1.lineTo(tx, ty);\n\n    return path$$1.toString();\n  };\n}\n\nLinkVerticalStep.propTypes = {\n  innerRef: prop_types_default.a.func,\n  percent: prop_types_default.a.number,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func,\n  path: prop_types_default.a.func\n};\n\nfunction LinkVerticalStep(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$percent = _ref2.percent,\n      percent = _ref2$percent === undefined ? 0.5 : _ref2$percent,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.x;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.y;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'percent', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || pathVerticalStep({ source: source, target: target, x: x, y: y, percent: percent });\n  return react_default.a.createElement('path', vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathRadialStep(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sx = x(sourceData);\n    var sy = y(sourceData);\n    var tx = x(targetData);\n    var ty = y(targetData);\n\n    var sa = sx - Math.PI / 2;\n    var sr = sy;\n    var ta = tx - Math.PI / 2;\n    var tr = ty;\n\n    var sc = Math.cos(sa);\n    var ss = Math.sin(sa);\n    var tc = Math.cos(ta);\n    var ts = Math.sin(ta);\n    var sf = Math.abs(ta - sa) > Math.PI ? ta <= sa : ta > sa;\n\n    return '\\n      M' + sr * sc + ',' + sr * ss + '\\n      A' + sr + ',' + sr + ',0,0,' + (sf ? 1 : 0) + ',' + sr * tc + ',' + sr * ts + '\\n      L' + tr * tc + ',' + tr * ts + '\\n    ';\n  };\n}\n\nLinkRadialStep$1.propTypes = {\n  innerRef: prop_types_default.a.func,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func,\n  path: prop_types_default.a.func\n};\n\nfunction LinkRadialStep$1(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.x;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.y;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || pathRadialStep({ source: source, target: target, x: x, y: y });\n  return react_default.a.createElement('path', vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nPolygon.propTypes = {\n  sides: prop_types_default.a.number.isRequired,\n  size: prop_types_default.a.number.isRequired,\n  className: prop_types_default.a.string,\n  rotate: prop_types_default.a.number,\n  fill: prop_types_default.a.string,\n  strokeDasharray: prop_types_default.a.string,\n  strokeWidth: prop_types_default.a.number,\n  stroke: prop_types_default.a.string\n};\n\nvar vx_shape_es_getPoint = function getPoint(_ref) {\n  var sides = _ref.sides,\n      size = _ref.size,\n      center = _ref.center,\n      rotate = _ref.rotate,\n      side = _ref.side;\n\n  var degrees = 360 / sides * side - rotate;\n  var radians = degreesToRadians(degrees);\n\n  return new vx_point_es[\"Point\"]({\n    x: center.x + size * Math.cos(radians),\n    y: center.y + size * Math.sin(radians)\n  });\n};\n\nvar getPoints = function getPoints(_ref2) {\n  var sides = _ref2.sides,\n      size = _ref2.size,\n      center = _ref2.center,\n      rotate = _ref2.rotate;\n  return [].concat(toConsumableArray(Array(sides).keys())).map(function (side) {\n    return vx_shape_es_getPoint({\n      sides: sides,\n      size: size,\n      center: center,\n      rotate: rotate,\n      side: side\n    });\n  });\n};\n\nfunction Polygon(_ref3) {\n  var sides = _ref3.sides,\n      _ref3$size = _ref3.size,\n      size = _ref3$size === undefined ? 25 : _ref3$size,\n      _ref3$center = _ref3.center,\n      center = _ref3$center === undefined ? new vx_point_es[\"Point\"]({ x: 0, y: 0 }) : _ref3$center,\n      _ref3$rotate = _ref3.rotate,\n      rotate = _ref3$rotate === undefined ? 0 : _ref3$rotate,\n      className = _ref3.className,\n      clickHandler = _ref3.clickHandler,\n      fill = _ref3.fill,\n      strokeDasharray = _ref3.strokeDasharray,\n      _ref3$strokeWidth = _ref3.strokeWidth,\n      _ref3$stroke = _ref3.stroke,\n      restProps = vx_shape_es_objectWithoutProperties(_ref3, ['sides', 'size', 'center', 'rotate', 'className', 'clickHandler', 'fill', 'strokeDasharray', 'strokeWidth', 'stroke']);\n\n  var points = getPoints({\n    sides: sides,\n    size: size,\n    center: center,\n    rotate: rotate\n  }).map(function (p) {\n    return p.toArray();\n  }).join(' ');\n\n  return react_default.a.createElement('polygon', vx_shape_es_extends({ points: points, className: className, fill: fill }, restProps));\n}\n\n\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/node_modules/@vx/axis/node_modules/@vx/text/dist/vx-text.es.js\nvar vx_text_es = __webpack_require__(1955);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/node_modules/@vx/axis/dist/vx-axis.es.js\n\n\n\n\n\n\n\n\nfunction vx_axis_es_center(scale) {\n  var offset = scale.bandwidth() / 2;\n  if (scale.round()) offset = Math.round(offset);\n  return function (d) {\n    return scale(d) + offset;\n  };\n}\n\nfunction identity(x) {\n  return x;\n}\n\nvar ORIENT = {\n  top: 'top',\n  left: 'left',\n  right: 'right',\n  bottom: 'bottom'\n};\n\nfunction labelTransform(_ref) {\n  var labelOffset = _ref.labelOffset,\n      labelProps = _ref.labelProps,\n      orientation = _ref.orientation,\n      range = _ref.range,\n      tickLabelFontSize = _ref.tickLabelFontSize,\n      tickLength = _ref.tickLength;\n\n  var sign = orientation === ORIENT.left || orientation === ORIENT.top ? -1 : 1;\n\n  var x = void 0,\n      y = void 0,\n      transform = null;\n  if (orientation === ORIENT.top || orientation === ORIENT.bottom) {\n    x = (range[0] + range[range.length - 1]) / 2;\n    y = sign * (tickLength + labelOffset + tickLabelFontSize + (orientation === ORIENT.bottom ? labelProps.fontSize : 0));\n  } else {\n    x = sign * ((range[0] + range[range.length - 1]) / 2);\n    y = -(tickLength + labelOffset);\n    transform = 'rotate(' + sign * 90 + ')';\n  }\n\n  return { x: x, y: y, transform: transform };\n}\n\nvar vx_axis_es_extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar propTypes = {\n  axisClassName: prop_types_default.a.string,\n  axisLineClassName: prop_types_default.a.string,\n  hideAxisLine: prop_types_default.a.bool,\n  hideTicks: prop_types_default.a.bool,\n  hideZero: prop_types_default.a.bool,\n  label: prop_types_default.a.string,\n  labelClassName: prop_types_default.a.string,\n  labelOffset: prop_types_default.a.number,\n  labelProps: prop_types_default.a.object,\n  left: prop_types_default.a.number,\n  numTicks: prop_types_default.a.number,\n  orientation: prop_types_default.a.oneOf([ORIENT.top, ORIENT.right, ORIENT.bottom, ORIENT.left]),\n  rangePadding: prop_types_default.a.number,\n  scale: prop_types_default.a.func.isRequired,\n  stroke: prop_types_default.a.string,\n  strokeWidth: prop_types_default.a.number,\n  strokeDasharray: prop_types_default.a.string,\n  tickClassName: prop_types_default.a.string,\n  tickFormat: prop_types_default.a.func,\n  tickLabelProps: prop_types_default.a.func,\n  tickLength: prop_types_default.a.number,\n  tickStroke: prop_types_default.a.string,\n  tickTransform: prop_types_default.a.string,\n  tickValues: prop_types_default.a.array,\n  tickComponent: prop_types_default.a.func,\n  top: prop_types_default.a.number,\n  children: prop_types_default.a.func\n};\n\nfunction vx_axis_es_Axis(_ref) {\n  var children = _ref.children,\n      axisClassName = _ref.axisClassName,\n      axisLineClassName = _ref.axisLineClassName,\n      _ref$hideAxisLine = _ref.hideAxisLine,\n      hideAxisLine = _ref$hideAxisLine === undefined ? false : _ref$hideAxisLine,\n      _ref$hideTicks = _ref.hideTicks,\n      hideTicks = _ref$hideTicks === undefined ? false : _ref$hideTicks,\n      _ref$hideZero = _ref.hideZero,\n      hideZero = _ref$hideZero === undefined ? false : _ref$hideZero,\n      _ref$label = _ref.label,\n      label = _ref$label === undefined ? '' : _ref$label,\n      labelClassName = _ref.labelClassName,\n      _ref$labelOffset = _ref.labelOffset,\n      labelOffset = _ref$labelOffset === undefined ? 14 : _ref$labelOffset,\n      _ref$labelProps = _ref.labelProps,\n      labelProps = _ref$labelProps === undefined ? {\n    textAnchor: 'middle',\n    fontFamily: 'Arial',\n    fontSize: 10,\n    fill: 'black'\n  } : _ref$labelProps,\n      _ref$left = _ref.left,\n      left = _ref$left === undefined ? 0 : _ref$left,\n      _ref$numTicks = _ref.numTicks,\n      numTicks = _ref$numTicks === undefined ? 10 : _ref$numTicks,\n      _ref$orientation = _ref.orientation,\n      orientation = _ref$orientation === undefined ? ORIENT.bottom : _ref$orientation,\n      _ref$rangePadding = _ref.rangePadding,\n      rangePadding = _ref$rangePadding === undefined ? 0 : _ref$rangePadding,\n      scale = _ref.scale,\n      _ref$stroke = _ref.stroke,\n      stroke = _ref$stroke === undefined ? 'black' : _ref$stroke,\n      _ref$strokeWidth = _ref.strokeWidth,\n      strokeWidth = _ref$strokeWidth === undefined ? 1 : _ref$strokeWidth,\n      strokeDasharray = _ref.strokeDasharray,\n      tickClassName = _ref.tickClassName,\n      tickFormat = _ref.tickFormat,\n      _ref$tickLabelProps = _ref.tickLabelProps,\n      tickLabelProps = _ref$tickLabelProps === undefined ? function (tickValue, index) {\n    return {\n      textAnchor: 'middle',\n      fontFamily: 'Arial',\n      fontSize: 10,\n      fill: 'black'\n    };\n  } : _ref$tickLabelProps,\n      _ref$tickLength = _ref.tickLength,\n      tickLength = _ref$tickLength === undefined ? 8 : _ref$tickLength,\n      _ref$tickStroke = _ref.tickStroke,\n      tickStroke = _ref$tickStroke === undefined ? 'black' : _ref$tickStroke,\n      tickTransform = _ref.tickTransform,\n      tickValues = _ref.tickValues,\n      tickComponent = _ref.tickComponent,\n      _ref$top = _ref.top,\n      top = _ref$top === undefined ? 0 : _ref$top;\n\n  var values = scale.ticks ? scale.ticks(numTicks) : scale.domain();\n  if (tickValues) values = tickValues;\n  var format = scale.tickFormat ? scale.tickFormat() : identity;\n  if (tickFormat) format = tickFormat;\n\n  var range = scale.range();\n  var range0 = range[0] + 0.5 - rangePadding;\n  var range1 = range[range.length - 1] + 0.5 + rangePadding;\n\n  var horizontal = orientation !== ORIENT.left && orientation !== ORIENT.right;\n  var isLeft = orientation === ORIENT.left;\n  var isTop = orientation === ORIENT.top;\n  var tickSign = isLeft || isTop ? -1 : 1;\n\n  var position = (scale.bandwidth ? vx_axis_es_center : identity)(scale.copy());\n\n  var axisFromPoint = new vx_point_es[\"Point\"]({\n    x: horizontal ? range0 : 0,\n    y: horizontal ? 0 : range0\n  });\n  var axisToPoint = new vx_point_es[\"Point\"]({\n    x: horizontal ? range1 : 0,\n    y: horizontal ? 0 : range1\n  });\n\n  var tickLabelFontSize = 10; // track the max tick label size to compute label offset\n\n  if (!!children) {\n    return react_default.a.createElement(\n      Group,\n      { className: classnames_default()('vx-axis', axisClassName), top: top, left: left },\n      children({\n        axisFromPoint: axisFromPoint,\n        axisToPoint: axisToPoint,\n        horizontal: horizontal,\n        tickSign: tickSign,\n        numTicks: numTicks,\n        label: label,\n        rangePadding: rangePadding,\n        tickLength: tickLength,\n        tickFormat: format,\n        tickPosition: position,\n        ticks: values.map(function (value, index) {\n          var from = new vx_point_es[\"Point\"]({\n            x: horizontal ? position(value) : 0,\n            y: horizontal ? 0 : position(value)\n          });\n          var to = new vx_point_es[\"Point\"]({\n            x: horizontal ? position(value) : tickSign * tickLength,\n            y: horizontal ? tickLength * tickSign : position(value)\n          });\n          return {\n            value: value,\n            index: index,\n            from: from,\n            to: to,\n            formattedValue: format(value, index)\n          };\n        })\n      })\n    );\n  }\n\n  return react_default.a.createElement(\n    Group,\n    { className: classnames_default()('vx-axis', axisClassName), top: top, left: left },\n    values.map(function (val, index) {\n      if (hideZero && val === 0) return null;\n\n      var tickFromPoint = new vx_point_es[\"Point\"]({\n        x: horizontal ? position(val) : 0,\n        y: horizontal ? 0 : position(val)\n      });\n      var tickToPoint = new vx_point_es[\"Point\"]({\n        x: horizontal ? position(val) : tickSign * tickLength,\n        y: horizontal ? tickLength * tickSign : position(val)\n      });\n\n      var tickLabelPropsObj = tickLabelProps(val, index);\n      tickLabelFontSize = Math.max(tickLabelFontSize, tickLabelPropsObj.fontSize || 0);\n\n      return react_default.a.createElement(\n        Group,\n        {\n          key: 'vx-tick-' + val + '-' + index,\n          className: classnames_default()('vx-axis-tick', tickClassName),\n          transform: tickTransform\n        },\n        !hideTicks && react_default.a.createElement(Line, { from: tickFromPoint, to: tickToPoint, stroke: tickStroke }),\n        tickComponent ? tickComponent(vx_axis_es_extends({\n          x: tickToPoint.x,\n          y: tickToPoint.y + (horizontal && !isTop ? tickLabelFontSize : 0),\n          formattedValue: format(val, index)\n        }, tickLabelPropsObj)) : react_default.a.createElement(\n          vx_text_es[\"a\" /* Text */],\n          vx_axis_es_extends({\n            x: tickToPoint.x,\n            y: tickToPoint.y + (horizontal && !isTop ? tickLabelFontSize : 0)\n          }, tickLabelPropsObj),\n          format(val, index)\n        )\n      );\n    }),\n    !hideAxisLine && react_default.a.createElement(Line, {\n      className: classnames_default()('vx-axis-line', axisLineClassName),\n      from: axisFromPoint,\n      to: axisToPoint,\n      stroke: stroke,\n      strokeWidth: strokeWidth,\n      strokeDasharray: strokeDasharray\n    }),\n    label && react_default.a.createElement(\n      vx_text_es[\"a\" /* Text */],\n      vx_axis_es_extends({\n        className: classnames_default()('vx-axis-label', labelClassName)\n      }, labelTransform({\n        labelOffset: labelOffset,\n        labelProps: labelProps,\n        orientation: orientation,\n        range: range,\n        tickLabelFontSize: tickLabelFontSize,\n        tickLength: tickLength\n      }), labelProps),\n      label\n    )\n  );\n}\n\nvx_axis_es_Axis.propTypes = propTypes;\n\nvar propTypes$1 = {\n  axisClassName: prop_types_default.a.string,\n  axisLineClassName: prop_types_default.a.string,\n  hideAxisLine: prop_types_default.a.bool,\n  hideTicks: prop_types_default.a.bool,\n  hideZero: prop_types_default.a.bool,\n  label: prop_types_default.a.string,\n  labelClassName: prop_types_default.a.string,\n  labelOffset: prop_types_default.a.number,\n  labelProps: prop_types_default.a.object,\n  left: prop_types_default.a.number,\n  numTicks: prop_types_default.a.number,\n  rangePadding: prop_types_default.a.number,\n  scale: prop_types_default.a.func.isRequired,\n  stroke: prop_types_default.a.string,\n  strokeWidth: prop_types_default.a.number,\n  strokeDasharray: prop_types_default.a.string,\n  tickClassName: prop_types_default.a.string,\n  tickFormat: prop_types_default.a.func,\n  tickLabelProps: prop_types_default.a.func,\n  tickLength: prop_types_default.a.number,\n  tickStroke: prop_types_default.a.string,\n  tickTransform: prop_types_default.a.string,\n  tickValues: prop_types_default.a.array,\n  tickComponent: prop_types_default.a.func,\n  top: prop_types_default.a.number,\n  children: prop_types_default.a.func\n};\n\nfunction AxisLeft(_ref) {\n  var children = _ref.children,\n      axisClassName = _ref.axisClassName,\n      axisLineClassName = _ref.axisLineClassName,\n      hideAxisLine = _ref.hideAxisLine,\n      hideTicks = _ref.hideTicks,\n      hideZero = _ref.hideZero,\n      label = _ref.label,\n      labelClassName = _ref.labelClassName,\n      _ref$labelOffset = _ref.labelOffset,\n      labelOffset = _ref$labelOffset === undefined ? 36 : _ref$labelOffset,\n      labelProps = _ref.labelProps,\n      left = _ref.left,\n      numTicks = _ref.numTicks,\n      rangePadding = _ref.rangePadding,\n      scale = _ref.scale,\n      stroke = _ref.stroke,\n      strokeWidth = _ref.strokeWidth,\n      strokeDasharray = _ref.strokeDasharray,\n      tickClassName = _ref.tickClassName,\n      tickFormat = _ref.tickFormat,\n      _ref$tickLabelProps = _ref.tickLabelProps,\n      tickLabelProps = _ref$tickLabelProps === undefined ? function (_ref2) {\n    var tick = _ref2.tick,\n        index = _ref2.index;\n    return {\n      dx: '-0.25em',\n      dy: '0.25em',\n      fill: 'black',\n      fontFamily: 'Arial',\n      fontSize: 10,\n      textAnchor: 'end'\n    };\n  } : _ref$tickLabelProps,\n      _ref$tickLength = _ref.tickLength,\n      tickLength = _ref$tickLength === undefined ? 8 : _ref$tickLength,\n      tickStroke = _ref.tickStroke,\n      tickTransform = _ref.tickTransform,\n      tickValues = _ref.tickValues,\n      tickComponent = _ref.tickComponent,\n      top = _ref.top;\n\n  return react_default.a.createElement(vx_axis_es_Axis, {\n    axisClassName: classnames_default()('vx-axis-left', axisClassName),\n    axisLineClassName: axisLineClassName,\n    hideAxisLine: hideAxisLine,\n    hideTicks: hideTicks,\n    hideZero: hideZero,\n    label: label,\n    labelClassName: labelClassName,\n    labelOffset: labelOffset,\n    labelProps: labelProps,\n    left: left,\n    numTicks: numTicks,\n    orientation: ORIENT.left,\n    rangePadding: rangePadding,\n    scale: scale,\n    stroke: stroke,\n    strokeWidth: strokeWidth,\n    strokeDasharray: strokeDasharray,\n    tickClassName: tickClassName,\n    tickFormat: tickFormat,\n    tickLabelProps: tickLabelProps,\n    tickLength: tickLength,\n    tickStroke: tickStroke,\n    tickTransform: tickTransform,\n    tickValues: tickValues,\n    tickComponent: tickComponent,\n    top: top,\n    children: children\n  });\n}\n\nAxisLeft.propTypes = propTypes$1;\n\nvar propTypes$2 = {\n  axisClassName: prop_types_default.a.string,\n  axisLineClassName: prop_types_default.a.string,\n  hideAxisLine: prop_types_default.a.bool,\n  hideTicks: prop_types_default.a.bool,\n  hideZero: prop_types_default.a.bool,\n  label: prop_types_default.a.string,\n  labelClassName: prop_types_default.a.string,\n  labelOffset: prop_types_default.a.number,\n  labelProps: prop_types_default.a.object,\n  left: prop_types_default.a.number,\n  numTicks: prop_types_default.a.number,\n  rangePadding: prop_types_default.a.number,\n  scale: prop_types_default.a.func.isRequired,\n  stroke: prop_types_default.a.string,\n  strokeWidth: prop_types_default.a.number,\n  strokeDasharray: prop_types_default.a.string,\n  tickClassName: prop_types_default.a.string,\n  tickFormat: prop_types_default.a.func,\n  tickLabelProps: prop_types_default.a.func,\n  tickLength: prop_types_default.a.number,\n  tickStroke: prop_types_default.a.string,\n  tickTransform: prop_types_default.a.string,\n  tickValues: prop_types_default.a.array,\n  tickComponent: prop_types_default.a.func,\n  top: prop_types_default.a.number,\n  children: prop_types_default.a.func\n};\n\nfunction AxisRight(_ref) {\n  var children = _ref.children,\n      axisClassName = _ref.axisClassName,\n      axisLineClassName = _ref.axisLineClassName,\n      hideAxisLine = _ref.hideAxisLine,\n      hideTicks = _ref.hideTicks,\n      hideZero = _ref.hideZero,\n      label = _ref.label,\n      labelClassName = _ref.labelClassName,\n      _ref$labelOffset = _ref.labelOffset,\n      labelOffset = _ref$labelOffset === undefined ? 36 : _ref$labelOffset,\n      labelProps = _ref.labelProps,\n      left = _ref.left,\n      numTicks = _ref.numTicks,\n      rangePadding = _ref.rangePadding,\n      scale = _ref.scale,\n      stroke = _ref.stroke,\n      strokeWidth = _ref.strokeWidth,\n      strokeDasharray = _ref.strokeDasharray,\n      tickClassName = _ref.tickClassName,\n      tickFormat = _ref.tickFormat,\n      _ref$tickLabelProps = _ref.tickLabelProps,\n      tickLabelProps = _ref$tickLabelProps === undefined ? function (_ref2) {\n    var tick = _ref2.tick,\n        index = _ref2.index;\n    return {\n      dx: '0.25em',\n      dy: '0.25em',\n      fill: 'black',\n      fontFamily: 'Arial',\n      fontSize: 10,\n      textAnchor: 'start'\n    };\n  } : _ref$tickLabelProps,\n      _ref$tickLength = _ref.tickLength,\n      tickLength = _ref$tickLength === undefined ? 8 : _ref$tickLength,\n      tickStroke = _ref.tickStroke,\n      tickTransform = _ref.tickTransform,\n      tickValues = _ref.tickValues,\n      tickComponent = _ref.tickComponent,\n      top = _ref.top;\n\n  return react_default.a.createElement(vx_axis_es_Axis, {\n    axisClassName: classnames_default()('vx-axis-right', axisClassName),\n    axisLineClassName: axisLineClassName,\n    hideAxisLine: hideAxisLine,\n    hideTicks: hideTicks,\n    hideZero: hideZero,\n    label: label,\n    labelClassName: labelClassName,\n    labelOffset: labelOffset,\n    labelProps: labelProps,\n    left: left,\n    numTicks: numTicks,\n    orientation: ORIENT.right,\n    rangePadding: rangePadding,\n    scale: scale,\n    stroke: stroke,\n    strokeWidth: strokeWidth,\n    strokeDasharray: strokeDasharray,\n    tickClassName: tickClassName,\n    tickFormat: tickFormat,\n    tickLabelProps: tickLabelProps,\n    tickLength: tickLength,\n    tickStroke: tickStroke,\n    tickTransform: tickTransform,\n    tickValues: tickValues,\n    tickComponent: tickComponent,\n    top: top,\n    children: children\n  });\n}\n\nAxisRight.propTypes = propTypes$2;\n\nvar propTypes$3 = {\n  axisClassName: prop_types_default.a.string,\n  axisLineClassName: prop_types_default.a.string,\n  hideAxisLine: prop_types_default.a.bool,\n  hideTicks: prop_types_default.a.bool,\n  hideZero: prop_types_default.a.bool,\n  label: prop_types_default.a.string,\n  labelClassName: prop_types_default.a.string,\n  labelOffset: prop_types_default.a.number,\n  labelProps: prop_types_default.a.object,\n  left: prop_types_default.a.number,\n  numTicks: prop_types_default.a.number,\n  rangePadding: prop_types_default.a.number,\n  scale: prop_types_default.a.func.isRequired,\n  stroke: prop_types_default.a.string,\n  strokeWidth: prop_types_default.a.number,\n  strokeDasharray: prop_types_default.a.string,\n  tickClassName: prop_types_default.a.string,\n  tickFormat: prop_types_default.a.func,\n  tickLabelProps: prop_types_default.a.func,\n  tickLength: prop_types_default.a.number,\n  tickStroke: prop_types_default.a.string,\n  tickTransform: prop_types_default.a.string,\n  tickValues: prop_types_default.a.array,\n  tickComponent: prop_types_default.a.func,\n  top: prop_types_default.a.number,\n  children: prop_types_default.a.func\n};\n\nfunction AxisTop(_ref) {\n  var children = _ref.children,\n      axisClassName = _ref.axisClassName,\n      axisLineClassName = _ref.axisLineClassName,\n      hideAxisLine = _ref.hideAxisLine,\n      hideTicks = _ref.hideTicks,\n      hideZero = _ref.hideZero,\n      label = _ref.label,\n      labelClassName = _ref.labelClassName,\n      _ref$labelOffset = _ref.labelOffset,\n      labelOffset = _ref$labelOffset === undefined ? 8 : _ref$labelOffset,\n      labelProps = _ref.labelProps,\n      left = _ref.left,\n      numTicks = _ref.numTicks,\n      rangePadding = _ref.rangePadding,\n      scale = _ref.scale,\n      stroke = _ref.stroke,\n      strokeWidth = _ref.strokeWidth,\n      strokeDasharray = _ref.strokeDasharray,\n      tickClassName = _ref.tickClassName,\n      tickFormat = _ref.tickFormat,\n      _ref$tickLabelProps = _ref.tickLabelProps,\n      tickLabelProps = _ref$tickLabelProps === undefined ? function (_ref2) {\n    var tick = _ref2.tick,\n        index = _ref2.index;\n    return {\n      dy: '-0.25em',\n      fill: 'black',\n      fontFamily: 'Arial',\n      fontSize: 10,\n      textAnchor: 'middle'\n    };\n  } : _ref$tickLabelProps,\n      _ref$tickLength = _ref.tickLength,\n      tickLength = _ref$tickLength === undefined ? 8 : _ref$tickLength,\n      tickStroke = _ref.tickStroke,\n      tickTransform = _ref.tickTransform,\n      tickValues = _ref.tickValues,\n      tickComponent = _ref.tickComponent,\n      top = _ref.top;\n\n  return react_default.a.createElement(vx_axis_es_Axis, {\n    axisClassName: classnames_default()('vx-axis-top', axisClassName),\n    axisLineClassName: axisLineClassName,\n    hideAxisLine: hideAxisLine,\n    hideTicks: hideTicks,\n    hideZero: hideZero,\n    label: label,\n    labelClassName: labelClassName,\n    labelOffset: labelOffset,\n    labelProps: labelProps,\n    left: left,\n    numTicks: numTicks,\n    orientation: ORIENT.top,\n    rangePadding: rangePadding,\n    scale: scale,\n    stroke: stroke,\n    strokeWidth: strokeWidth,\n    strokeDasharray: strokeDasharray,\n    tickClassName: tickClassName,\n    tickFormat: tickFormat,\n    tickLabelProps: tickLabelProps,\n    tickLength: tickLength,\n    tickStroke: tickStroke,\n    tickTransform: tickTransform,\n    tickValues: tickValues,\n    tickComponent: tickComponent,\n    top: top,\n    children: children\n  });\n}\n\nAxisTop.propTypes = propTypes$3;\n\nvar propTypes$4 = {\n  axisClassName: prop_types_default.a.string,\n  axisLineClassName: prop_types_default.a.string,\n  hideAxisLine: prop_types_default.a.bool,\n  hideTicks: prop_types_default.a.bool,\n  hideZero: prop_types_default.a.bool,\n  label: prop_types_default.a.string,\n  labelClassName: prop_types_default.a.string,\n  labelOffset: prop_types_default.a.number,\n  labelProps: prop_types_default.a.object,\n  left: prop_types_default.a.number,\n  numTicks: prop_types_default.a.number,\n  rangePadding: prop_types_default.a.number,\n  scale: prop_types_default.a.func.isRequired,\n  stroke: prop_types_default.a.string,\n  strokeWidth: prop_types_default.a.number,\n  strokeDasharray: prop_types_default.a.string,\n  tickClassName: prop_types_default.a.string,\n  tickFormat: prop_types_default.a.func,\n  tickLabelProps: prop_types_default.a.func,\n  tickLength: prop_types_default.a.number,\n  tickStroke: prop_types_default.a.string,\n  tickTransform: prop_types_default.a.string,\n  tickValues: prop_types_default.a.array,\n  tickComponent: prop_types_default.a.func,\n  top: prop_types_default.a.number,\n  children: prop_types_default.a.func\n};\n\nfunction AxisBottom(_ref) {\n  var children = _ref.children,\n      axisClassName = _ref.axisClassName,\n      axisLineClassName = _ref.axisLineClassName,\n      hideAxisLine = _ref.hideAxisLine,\n      hideTicks = _ref.hideTicks,\n      hideZero = _ref.hideZero,\n      label = _ref.label,\n      labelClassName = _ref.labelClassName,\n      _ref$labelOffset = _ref.labelOffset,\n      labelOffset = _ref$labelOffset === undefined ? 8 : _ref$labelOffset,\n      labelProps = _ref.labelProps,\n      left = _ref.left,\n      numTicks = _ref.numTicks,\n      rangePadding = _ref.rangePadding,\n      scale = _ref.scale,\n      stroke = _ref.stroke,\n      strokeWidth = _ref.strokeWidth,\n      strokeDasharray = _ref.strokeDasharray,\n      tickClassName = _ref.tickClassName,\n      tickFormat = _ref.tickFormat,\n      _ref$tickLabelProps = _ref.tickLabelProps,\n      tickLabelProps = _ref$tickLabelProps === undefined ? function (_ref2) {\n    var tick = _ref2.tick,\n        index = _ref2.index;\n    return {\n      dy: '0.25em',\n      fill: 'black',\n      fontFamily: 'Arial',\n      fontSize: 10,\n      textAnchor: 'middle'\n    };\n  } : _ref$tickLabelProps,\n      _ref$tickLength = _ref.tickLength,\n      tickLength = _ref$tickLength === undefined ? 8 : _ref$tickLength,\n      tickStroke = _ref.tickStroke,\n      tickTransform = _ref.tickTransform,\n      tickValues = _ref.tickValues,\n      tickComponent = _ref.tickComponent,\n      top = _ref.top;\n\n  return react_default.a.createElement(vx_axis_es_Axis, {\n    axisClassName: classnames_default()('vx-axis-bottom', axisClassName),\n    axisLineClassName: axisLineClassName,\n    hideAxisLine: hideAxisLine,\n    hideTicks: hideTicks,\n    hideZero: hideZero,\n    label: label,\n    labelClassName: labelClassName,\n    labelOffset: labelOffset,\n    labelProps: labelProps,\n    left: left,\n    numTicks: numTicks,\n    orientation: ORIENT.bottom,\n    rangePadding: rangePadding,\n    scale: scale,\n    stroke: stroke,\n    strokeWidth: strokeWidth,\n    strokeDasharray: strokeDasharray,\n    tickClassName: tickClassName,\n    tickFormat: tickFormat,\n    tickLabelProps: tickLabelProps,\n    tickLength: tickLength,\n    tickStroke: tickStroke,\n    tickTransform: tickTransform,\n    tickValues: tickValues,\n    tickComponent: tickComponent,\n    top: top,\n    children: children\n  });\n}\n\nAxisBottom.propTypes = propTypes$4;\n\n\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/utils/propShapes.js\nvar propShapes = __webpack_require__(1905);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/axis/XAxis.js\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\n\n\n\n\nvar XAxis_propTypes = {\n  axisStyles: propShapes[\"b\" /* axisStylesShape */],\n  hideZero: prop_types_default.a.bool,\n  label: prop_types_default.a.string,\n  labelOffset: prop_types_default.a.number,\n  labelProps: prop_types_default.a.objectOf(prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string])),\n  numTicks: prop_types_default.a.number,\n  orientation: prop_types_default.a.oneOf(['bottom', 'top']),\n  rangePadding: prop_types_default.a.number,\n  tickStyles: propShapes[\"l\" /* tickStylesShape */],\n  tickComponent: prop_types_default.a.func,\n  tickLabelProps: prop_types_default.a.func,\n  tickFormat: prop_types_default.a.func,\n  tickValues: prop_types_default.a.arrayOf( // number or date/moment object\n  prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.object, prop_types_default.a.string])),\n  // probably injected by parent\n  innerHeight: prop_types_default.a.number,\n  scale: prop_types_default.a.func\n};\nvar defaultProps = {\n  axisStyles: {},\n  hideZero: false,\n  innerHeight: null,\n  label: null,\n  labelOffset: 14,\n  labelProps: null,\n  numTicks: null,\n  orientation: 'bottom',\n  rangePadding: null,\n  scale: null,\n  tickComponent: null,\n  tickFormat: null,\n  tickLabelProps: null,\n  tickStyles: {},\n  tickValues: undefined\n};\n\nvar XAxis_XAxis =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inheritsLoose(XAxis, _React$PureComponent);\n\n  function XAxis() {\n    return _React$PureComponent.apply(this, arguments) || this;\n  }\n\n  var _proto = XAxis.prototype;\n\n  _proto.render = function render() {\n    var _this$props = this.props,\n        axisStyles = _this$props.axisStyles,\n        innerHeight = _this$props.innerHeight,\n        hideZero = _this$props.hideZero,\n        label = _this$props.label,\n        labelOffset = _this$props.labelOffset,\n        labelProps = _this$props.labelProps,\n        numTicks = _this$props.numTicks,\n        orientation = _this$props.orientation,\n        rangePadding = _this$props.rangePadding,\n        scale = _this$props.scale,\n        tickComponent = _this$props.tickComponent,\n        tickFormat = _this$props.tickFormat,\n        passedTickLabelProps = _this$props.tickLabelProps,\n        tickStyles = _this$props.tickStyles,\n        tickValues = _this$props.tickValues;\n    if (!scale || !innerHeight) return null;\n    var Axis = orientation === 'bottom' ? AxisBottom : AxisTop;\n    var tickLabelProps = passedTickLabelProps;\n\n    if (!tickLabelProps) {\n      tickLabelProps = tickStyles.label && tickStyles.label[orientation] ? function () {\n        return tickStyles.label[orientation];\n      } : undefined;\n    }\n\n    return react_default.a.createElement(Axis, {\n      top: orientation === 'bottom' ? innerHeight : 0,\n      left: 0,\n      rangePadding: rangePadding,\n      hideTicks: numTicks === 0,\n      hideZero: hideZero,\n      label: label,\n      labelOffset: labelOffset,\n      labelProps: labelProps || (axisStyles.label || {})[orientation],\n      numTicks: numTicks,\n      scale: scale,\n      stroke: axisStyles.stroke,\n      strokeWidth: axisStyles.strokeWidth,\n      tickComponent: tickComponent,\n      tickFormat: tickFormat,\n      tickLabelProps: tickLabelProps,\n      tickLength: tickStyles.tickLength,\n      tickStroke: tickStyles.stroke,\n      tickValues: tickValues\n    });\n  };\n\n  return XAxis;\n}(react_default.a.PureComponent);\n\n\nXAxis_XAxis.propTypes = XAxis_propTypes;\nXAxis_XAxis.defaultProps = defaultProps;\nXAxis_XAxis.displayName = 'XAxis';\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/axis/YAxis.js\nfunction YAxis_extends() { YAxis_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return YAxis_extends.apply(this, arguments); }\n\nfunction YAxis_inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\n\n\n\n\nvar YAxis_propTypes = {\n  axisStyles: propShapes[\"b\" /* axisStylesShape */],\n  hideZero: prop_types_default.a.bool,\n  label: prop_types_default.a.string,\n  labelProps: prop_types_default.a.objectOf(prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string])),\n  labelOffset: prop_types_default.a.number,\n  numTicks: prop_types_default.a.number,\n  orientation: prop_types_default.a.oneOf(['left', 'right']),\n  rangePadding: prop_types_default.a.number,\n  tickComponent: prop_types_default.a.func,\n  tickStyles: propShapes[\"l\" /* tickStylesShape */],\n  tickLabelProps: prop_types_default.a.func,\n  tickFormat: prop_types_default.a.func,\n  tickValues: prop_types_default.a.arrayOf( // number or date/moment object\n  prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.object, prop_types_default.a.string])),\n  // probably injected by parent\n  innerWidth: prop_types_default.a.number,\n  height: prop_types_default.a.number,\n  scale: prop_types_default.a.func\n};\nvar YAxis_defaultProps = {\n  axisStyles: {},\n  hideZero: false,\n  innerWidth: null,\n  height: null,\n  label: null,\n  labelProps: null,\n  labelOffset: undefined,\n  numTicks: null,\n  orientation: 'right',\n  rangePadding: null,\n  scale: null,\n  tickComponent: null,\n  tickFormat: null,\n  tickLabelProps: null,\n  tickStyles: {},\n  tickValues: undefined\n};\n\nvar YAxis_YAxis =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  YAxis_inheritsLoose(YAxis, _React$PureComponent);\n\n  function YAxis() {\n    return _React$PureComponent.apply(this, arguments) || this;\n  }\n\n  var _proto = YAxis.prototype;\n\n  _proto.render = function render() {\n    var _this$props = this.props,\n        axisStyles = _this$props.axisStyles,\n        hideZero = _this$props.hideZero,\n        innerWidth = _this$props.innerWidth,\n        height = _this$props.height,\n        label = _this$props.label,\n        labelProps = _this$props.labelProps,\n        labelOffset = _this$props.labelOffset,\n        numTicks = _this$props.numTicks,\n        orientation = _this$props.orientation,\n        rangePadding = _this$props.rangePadding,\n        scale = _this$props.scale,\n        tickComponent = _this$props.tickComponent,\n        tickFormat = _this$props.tickFormat,\n        passedTickLabelProps = _this$props.tickLabelProps,\n        tickStyles = _this$props.tickStyles,\n        tickValues = _this$props.tickValues;\n    if (!scale || !innerWidth) return null;\n    var Axis = orientation === 'left' ? AxisLeft : AxisRight;\n    var tickLabelProps = passedTickLabelProps;\n\n    if (!tickLabelProps) {\n      tickLabelProps = tickStyles.label && tickStyles.label[orientation] ? function () {\n        return tickStyles.label[orientation];\n      } : undefined;\n    }\n\n    return react_default.a.createElement(Axis, {\n      top: 0,\n      left: orientation === 'right' ? innerWidth : 0,\n      rangePadding: rangePadding,\n      hideTicks: numTicks === 0,\n      hideZero: hideZero,\n      label: label,\n      labelProps: YAxis_extends({\n        verticalAnchor: 'start',\n        width: Math.max.apply(Math, scale.range().concat([height || 0]))\n      }, labelProps || (axisStyles.label || {})[orientation]),\n      labelOffset: labelOffset,\n      numTicks: numTicks,\n      scale: scale,\n      stroke: axisStyles.stroke,\n      strokeWidth: axisStyles.strokeWidth,\n      tickComponent: tickComponent,\n      tickFormat: tickFormat,\n      tickLabelProps: tickLabelProps,\n      tickLength: tickStyles.tickLength,\n      tickStroke: tickStyles.stroke,\n      tickValues: tickValues\n    });\n  };\n\n  return YAxis;\n}(react_default.a.PureComponent);\n\n\nYAxis_YAxis.propTypes = YAxis_propTypes;\nYAxis_YAxis.defaultProps = YAxis_defaultProps;\nYAxis_YAxis.displayName = 'YAxis';\n// EXTERNAL MODULE: ../superset-ui-core/src/dimension/mergeMargin.ts\nvar mergeMargin = __webpack_require__(1012);\n\n// EXTERNAL MODULE: ../superset-ui-core/src/chart-composition/ChartFrame.tsx\nvar ChartFrame = __webpack_require__(1015);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/utils/createTickComponent.tsx\nvar __rest = (undefined && undefined.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n\nfunction createTickComponent({ axisWidth, labelAngle, labelFlush, labelOverlap, orient, tickLabels, tickLabelDimensions, tickTextAnchor = 'middle', }) {\n    if (labelOverlap === 'rotate' && labelAngle !== 0) {\n        let xOffset = labelAngle > 0 ? -6 : 6;\n        if (orient === 'top') {\n            xOffset = 0;\n        }\n        const yOffset = orient === 'top' ? -3 : 0;\n        return (_a) => {\n            var { x, y, formattedValue = '' } = _a, textStyle = __rest(_a, [\"x\", \"y\", \"formattedValue\"]);\n            return (react_default.a.createElement(\"g\", { transform: `translate(${x + xOffset}, ${y + yOffset})` },\n                react_default.a.createElement(\"text\", Object.assign({ transform: `rotate(${labelAngle})` }, textStyle, { textAnchor: tickTextAnchor }), formattedValue)));\n        };\n    }\n    if (labelFlush === true || typeof labelFlush === 'number') {\n        const labelToDimensionMap = new Map();\n        tickLabels.forEach((label, i) => {\n            labelToDimensionMap.set(label, tickLabelDimensions[i]);\n        });\n        return (_a) => {\n            var { x, y, formattedValue = '' } = _a, textStyle = __rest(_a, [\"x\", \"y\", \"formattedValue\"]);\n            const dimension = labelToDimensionMap.get(formattedValue);\n            const labelWidth = typeof dimension === 'undefined' ? 0 : dimension.width;\n            let textAnchor = tickTextAnchor;\n            let xOffset = 0;\n            if (x - labelWidth / 2 < 0) {\n                textAnchor = 'start';\n                if (typeof labelFlush === 'number') {\n                    xOffset -= labelFlush;\n                }\n            }\n            else if (x + labelWidth / 2 > axisWidth) {\n                textAnchor = 'end';\n                if (typeof labelFlush === 'number') {\n                    xOffset += labelFlush;\n                }\n            }\n            return (react_default.a.createElement(\"text\", Object.assign({ x: x + xOffset, y: y }, textStyle, { textAnchor: textAnchor }), formattedValue));\n        };\n    }\n    // This will render the tick as horizontal string.\n    return null;\n}\n\n// EXTERNAL MODULE: ../superset-ui-core/src/dimension/getTextDimension.ts\nvar getTextDimension = __webpack_require__(424);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/utils/computeAxisLayout.ts\n\nfunction computeAxisLayout(axis, { axisTitleHeight = 20, axisWidth, gapBetweenAxisLabelAndBorder = 4, gapBetweenTickAndTickLabel = 4, defaultTickSize = 8, tickTextStyle = {}, }) {\n    const tickLabels = axis.getTickLabels();\n    const tickLabelDimensions = tickLabels.map((text) => Object(getTextDimension[\"a\" /* default */])({\n        style: tickTextStyle,\n        text,\n    }));\n    const { labelAngle, labelFlush, labelOverlap, labelPadding, orient, tickSize = defaultTickSize, } = axis.config;\n    const maxWidth = Math.max(...tickLabelDimensions.map(d => d.width), 0);\n    // cheap heuristic, can improve\n    const widthPerTick = axisWidth / tickLabels.length;\n    const isLabelOverlap = maxWidth > widthPerTick;\n    const labelAngleIfOverlap = labelOverlap.strategy === 'rotate' ? labelOverlap.labelAngle : 0;\n    const labelAngleAfterOverlapCheck = isLabelOverlap ? labelAngleIfOverlap : 0;\n    const finalLabelAngle = labelAngle === 0 ? labelAngleAfterOverlapCheck : labelAngle;\n    const spaceForAxisTitle = axis.hasTitle() ? labelPadding + axisTitleHeight : 0;\n    let tickTextAnchor = 'middle';\n    let labelOffset = 0;\n    let requiredMargin = tickSize + gapBetweenTickAndTickLabel + spaceForAxisTitle + gapBetweenAxisLabelAndBorder;\n    if (axis.channelEncoder.isX()) {\n        if (finalLabelAngle === 0) {\n            const labelHeight = tickLabelDimensions.length > 0 ? tickLabelDimensions[0].height : 0;\n            labelOffset = labelHeight + labelPadding;\n            requiredMargin += labelHeight;\n        }\n        else {\n            const labelHeight = Math.ceil(Math.abs(maxWidth * Math.sin((finalLabelAngle * Math.PI) / 180)));\n            labelOffset = labelHeight + labelPadding;\n            requiredMargin += labelHeight;\n            tickTextAnchor =\n                (orient === 'top' && finalLabelAngle > 0) || (orient === 'bottom' && finalLabelAngle < 0)\n                    ? 'end'\n                    : 'start';\n        }\n        requiredMargin += 8;\n    }\n    else {\n        labelOffset = maxWidth + spaceForAxisTitle;\n        requiredMargin += maxWidth;\n    }\n    return {\n        axisWidth,\n        labelAngle: finalLabelAngle,\n        labelFlush,\n        labelOffset,\n        labelOverlap: isLabelOverlap ? labelOverlap.strategy : 'flat',\n        minMargin: {\n            [orient]: Math.ceil(requiredMargin),\n        },\n        orient,\n        tickLabelDimensions,\n        tickLabels,\n        tickTextAnchor,\n    };\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/utils/XYChartLayout.tsx\n\n\n\n\n\nconst DEFAULT_LABEL_ANGLE = 40;\n// Additional margin to avoid content hidden behind scroll bar\nconst OVERFLOW_MARGIN = 8;\nclass XYChartLayout_XYChartLayout {\n    constructor(config) {\n        const { width, height, minContentWidth = 0, minContentHeight = 0, margin, xEncoder, xTickSize, xTickTextStyle, autoAdjustXMargin = true, yEncoder, yTickSize, yTickTextStyle, autoAdjustYMargin = true, } = config;\n        this.xEncoder = xEncoder;\n        this.yEncoder = yEncoder;\n        if (typeof yEncoder.axis !== 'undefined') {\n            this.yLayout = computeAxisLayout(yEncoder.axis, {\n                axisWidth: Math.max(height - margin.top - margin.bottom),\n                defaultTickSize: yTickSize,\n                tickTextStyle: yTickTextStyle,\n            });\n        }\n        const secondMargin = this.yLayout && autoAdjustYMargin ? Object(mergeMargin[\"a\" /* default */])(margin, this.yLayout.minMargin) : margin;\n        const innerWidth = Math.max(width - secondMargin.left - secondMargin.right, minContentWidth);\n        if (typeof xEncoder.axis !== 'undefined') {\n            this.xLayout = computeAxisLayout(xEncoder.axis, {\n                axisWidth: innerWidth,\n                defaultTickSize: xTickSize,\n                tickTextStyle: xTickTextStyle,\n            });\n        }\n        const finalMargin = this.xLayout && autoAdjustXMargin\n            ? Object(mergeMargin[\"a\" /* default */])(secondMargin, this.xLayout.minMargin)\n            : secondMargin;\n        const innerHeight = Math.max(height - finalMargin.top - finalMargin.bottom, minContentHeight);\n        const chartWidth = Math.round(innerWidth + finalMargin.left + finalMargin.right);\n        const chartHeight = Math.round(innerHeight + finalMargin.top + finalMargin.bottom);\n        const isOverFlowX = chartWidth > width;\n        const isOverFlowY = chartHeight > height;\n        if (isOverFlowX) {\n            finalMargin.bottom += OVERFLOW_MARGIN;\n        }\n        if (isOverFlowY) {\n            finalMargin.right += OVERFLOW_MARGIN;\n        }\n        this.chartWidth = isOverFlowX ? chartWidth + OVERFLOW_MARGIN : chartWidth;\n        this.chartHeight = isOverFlowY ? chartHeight + OVERFLOW_MARGIN : chartHeight;\n        this.containerWidth = width;\n        this.containerHeight = height;\n        this.margin = finalMargin;\n    }\n    renderChartWithFrame(renderChart) {\n        return (react_default.a.createElement(ChartFrame[\"a\" /* default */], { width: this.containerWidth, height: this.containerHeight, contentWidth: this.chartWidth, contentHeight: this.chartHeight, renderContent: renderChart }));\n    }\n    renderXAxis(props) {\n        const { axis } = this.xEncoder;\n        return axis && this.xLayout ? (react_default.a.createElement(XAxis_XAxis, Object.assign({ label: axis.getTitle(), labelOffset: this.xLayout.labelOffset, numTicks: axis.config.tickCount, orientation: axis.config.orient, tickComponent: createTickComponent(this.xLayout), tickFormat: axis.formatValue }, props))) : null;\n    }\n    renderYAxis(props) {\n        const { axis } = this.yEncoder;\n        return axis && this.yLayout ? (react_default.a.createElement(YAxis_YAxis, Object.assign({ label: axis.getTitle(), labelOffset: this.yLayout.labelOffset, numTicks: axis.config.tickCount, orientation: axis.config.orient, tickFormat: axis.formatValue }, props))) : null;\n    }\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/utils/createXYChartLayoutWithTheme.ts\nvar createXYChartLayoutWithTheme_rest = (undefined && undefined.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n\nfunction createXYChartLayoutWithTheme(config) {\n    const { theme } = config, rest = createXYChartLayoutWithTheme_rest(config, [\"theme\"]);\n    return new XYChartLayout_XYChartLayout(Object.assign(Object.assign({}, rest), { \n        // @ts-ignore\n        xTickSize: theme.xTickStyles.length || theme.xTickStyles.tickLength, xTickTextStyle: theme.xTickStyles.label.bottom || theme.xTickStyles.label.top, \n        // @ts-ignore\n        yTickSize: theme.yTickStyles.length || theme.yTickStyles.tickLength, yTickTextStyle: theme.yTickStyles.label.left || theme.yTickStyles.label.right }));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk1Ny5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL3h5LWNoYXJ0L25vZGVfbW9kdWxlcy9AdngvYXhpcy9ub2RlX21vZHVsZXMvQHZ4L2dyb3VwL2Rpc3QvdngtZ3JvdXAuZXMuanM/ZDYwNyIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS94eS1jaGFydC9ub2RlX21vZHVsZXMvQHZ4L2F4aXMvbm9kZV9tb2R1bGVzL0B2eC9zaGFwZS9kaXN0L3Z4LXNoYXBlLmVzLmpzPzhiNWUiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkveHktY2hhcnQvbm9kZV9tb2R1bGVzL0B2eC9heGlzL2Rpc3QvdngtYXhpcy5lcy5qcz8xZjFmIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL3h5LWNoYXJ0L2VzbS9heGlzL1hBeGlzLmpzP2M1NjAiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkveHktY2hhcnQvZXNtL2F4aXMvWUF4aXMuanM/NGVmNyIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvcHJlc2V0LWNoYXJ0LXh5L3NyYy91dGlscy9jcmVhdGVUaWNrQ29tcG9uZW50LnRzeD9lMTlkIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wcmVzZXQtY2hhcnQteHkvc3JjL3V0aWxzL2NvbXB1dGVBeGlzTGF5b3V0LnRzP2I5NmQiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9wbHVnaW5zL3ByZXNldC1jaGFydC14eS9zcmMvdXRpbHMvWFlDaGFydExheW91dC50c3g/N2M2ZiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvcHJlc2V0LWNoYXJ0LXh5L3NyYy91dGlscy9jcmVhdGVYWUNoYXJ0TGF5b3V0V2l0aFRoZW1lLnRzP2QyODkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjeCBmcm9tICdjbGFzc25hbWVzJztcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbnZhciBvYmplY3RXaXRob3V0UHJvcGVydGllcyA9IGZ1bmN0aW9uIChvYmosIGtleXMpIHtcbiAgdmFyIHRhcmdldCA9IHt9O1xuXG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTtcbiAgICB0YXJnZXRbaV0gPSBvYmpbaV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuZnVuY3Rpb24gR3JvdXAoX3JlZikge1xuICB2YXIgX3JlZiR0b3AgPSBfcmVmLnRvcCxcbiAgICAgIHRvcCA9IF9yZWYkdG9wID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiR0b3AsXG4gICAgICBfcmVmJGxlZnQgPSBfcmVmLmxlZnQsXG4gICAgICBsZWZ0ID0gX3JlZiRsZWZ0ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiRsZWZ0LFxuICAgICAgdHJhbnNmb3JtID0gX3JlZi50cmFuc2Zvcm0sXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsndG9wJywgJ2xlZnQnLCAndHJhbnNmb3JtJywgJ2NsYXNzTmFtZScsICdjaGlsZHJlbiddKTtcblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAnZycsXG4gICAgX2V4dGVuZHMoe1xuICAgICAgY2xhc3NOYW1lOiBjeCgndngtZ3JvdXAnLCBjbGFzc05hbWUpLFxuICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0gfHwgJ3RyYW5zbGF0ZSgnICsgbGVmdCArICcsICcgKyB0b3AgKyAnKSdcbiAgICB9LCByZXN0UHJvcHMpLFxuICAgIGNoaWxkcmVuXG4gICk7XG59XG5cbmV4cG9ydCB7IEdyb3VwIH07XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IGN4IGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IHsgYXJjLCBwaWUsIGxpbmUsIHJhZGlhbExpbmUsIGFyZWEsIHN0YWNrLCBzdGFja09yZGVyQXNjZW5kaW5nLCBzdGFja09yZGVyRGVzY2VuZGluZywgc3RhY2tPcmRlckluc2lkZU91dCwgc3RhY2tPcmRlck5vbmUsIHN0YWNrT3JkZXJSZXZlcnNlLCBzdGFja09mZnNldEV4cGFuZCwgc3RhY2tPZmZzZXREaXZlcmdpbmcsIHN0YWNrT2Zmc2V0Tm9uZSwgc3RhY2tPZmZzZXRTaWxob3VldHRlLCBzdGFja09mZnNldFdpZ2dsZSwgbGlua0hvcml6b250YWwsIGxpbmtWZXJ0aWNhbCwgbGlua1JhZGlhbCB9IGZyb20gJ2QzLXNoYXBlJztcbmltcG9ydCB7IEdyb3VwIH0gZnJvbSAnQHZ4L2dyb3VwJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJ0B2eC9wb2ludCc7XG5pbXBvcnQgeyBjdXJ2ZUxpbmVhciB9IGZyb20gJ0B2eC9jdXJ2ZSc7XG5pbXBvcnQgeyBwYXRoIH0gZnJvbSAnZDMtcGF0aCc7XG5cbmZ1bmN0aW9uIGNhbGxPclZhbHVlKG1heWJlRm4sIGRhdGEpIHtcbiAgaWYgKHR5cGVvZiBtYXliZUZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlRm4oZGF0YSk7XG4gIH1cbiAgcmV0dXJuIG1heWJlRm47XG59XG5cbmZ1bmN0aW9uIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHJlc3RQcm9wcykucmVkdWNlKGZ1bmN0aW9uIChyZXQsIGN1cikge1xuICAgIHJldFtjdXJdID0gY2FsbE9yVmFsdWUocmVzdFByb3BzW2N1cl0sIGRhdGEpO1xuICAgIHJldHVybiByZXQ7XG4gIH0sIHt9KTtcbn1cblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbnZhciBvYmplY3RXaXRob3V0UHJvcGVydGllcyA9IGZ1bmN0aW9uIChvYmosIGtleXMpIHtcbiAgdmFyIHRhcmdldCA9IHt9O1xuXG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTtcbiAgICB0YXJnZXRbaV0gPSBvYmpbaV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxudmFyIHRvQ29uc3VtYWJsZUFycmF5ID0gZnVuY3Rpb24gKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICAgIHJldHVybiBhcnIyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGFycik7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIEFyYyhfcmVmKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICBjZW50cm9pZCA9IF9yZWYuY2VudHJvaWQsXG4gICAgICBpbm5lclJhZGl1cyA9IF9yZWYuaW5uZXJSYWRpdXMsXG4gICAgICBvdXRlclJhZGl1cyA9IF9yZWYub3V0ZXJSYWRpdXMsXG4gICAgICBjb3JuZXJSYWRpdXMgPSBfcmVmLmNvcm5lclJhZGl1cyxcbiAgICAgIHN0YXJ0QW5nbGUgPSBfcmVmLnN0YXJ0QW5nbGUsXG4gICAgICBlbmRBbmdsZSA9IF9yZWYuZW5kQW5nbGUsXG4gICAgICBwYWRBbmdsZSA9IF9yZWYucGFkQW5nbGUsXG4gICAgICBwYWRSYWRpdXMgPSBfcmVmLnBhZFJhZGl1cyxcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnY2xhc3NOYW1lJywgJ2RhdGEnLCAnY2VudHJvaWQnLCAnaW5uZXJSYWRpdXMnLCAnb3V0ZXJSYWRpdXMnLCAnY29ybmVyUmFkaXVzJywgJ3N0YXJ0QW5nbGUnLCAnZW5kQW5nbGUnLCAncGFkQW5nbGUnLCAncGFkUmFkaXVzJ10pO1xuXG4gIHZhciBhcmMkJDEgPSBhcmMoKTtcbiAgaWYgKGNlbnRyb2lkKSBhcmMkJDEuY2VudHJvaWQoY2VudHJvaWQpO1xuICBpZiAoaW5uZXJSYWRpdXMpIGFyYyQkMS5pbm5lclJhZGl1cyhpbm5lclJhZGl1cyk7XG4gIGlmIChvdXRlclJhZGl1cykgYXJjJCQxLm91dGVyUmFkaXVzKG91dGVyUmFkaXVzKTtcbiAgaWYgKGNvcm5lclJhZGl1cykgYXJjJCQxLmNvcm5lclJhZGl1cyhjb3JuZXJSYWRpdXMpO1xuICBpZiAoc3RhcnRBbmdsZSkgYXJjJCQxLnN0YXJ0QW5nbGUoc3RhcnRBbmdsZSk7XG4gIGlmIChlbmRBbmdsZSkgYXJjJCQxLmVuZEFuZ2xlKGVuZEFuZ2xlKTtcbiAgaWYgKHBhZEFuZ2xlKSBhcmMkJDEucGFkQW5nbGUocGFkQW5nbGUpO1xuICBpZiAocGFkUmFkaXVzKSBhcmMkJDEucGFkUmFkaXVzKHBhZFJhZGl1cyk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoeyBjbGFzc05hbWU6IGN4KCd2eC1hcmMnLCBjbGFzc05hbWUpLCBkOiBhcmMkJDEoZGF0YSkgfSwgYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcywgZGF0YSkpKTtcbn1cblxuZnVuY3Rpb24gUGllKF9yZWYpIHtcbiAgdmFyIF9yZWYkY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBjbGFzc05hbWUgPSBfcmVmJGNsYXNzTmFtZSA9PT0gdW5kZWZpbmVkID8gJycgOiBfcmVmJGNsYXNzTmFtZSxcbiAgICAgIF9yZWYkdG9wID0gX3JlZi50b3AsXG4gICAgICB0b3AgPSBfcmVmJHRvcCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkdG9wLFxuICAgICAgX3JlZiRsZWZ0ID0gX3JlZi5sZWZ0LFxuICAgICAgbGVmdCA9IF9yZWYkbGVmdCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkbGVmdCxcbiAgICAgIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICBjZW50cm9pZCA9IF9yZWYuY2VudHJvaWQsXG4gICAgICBfcmVmJGlubmVyUmFkaXVzID0gX3JlZi5pbm5lclJhZGl1cyxcbiAgICAgIGlubmVyUmFkaXVzID0gX3JlZiRpbm5lclJhZGl1cyA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkaW5uZXJSYWRpdXMsXG4gICAgICBvdXRlclJhZGl1cyA9IF9yZWYub3V0ZXJSYWRpdXMsXG4gICAgICBjb3JuZXJSYWRpdXMgPSBfcmVmLmNvcm5lclJhZGl1cyxcbiAgICAgIF9yZWYkc3RhcnRBbmdsZSA9IF9yZWYuc3RhcnRBbmdsZSxcbiAgICAgIHN0YXJ0QW5nbGUgPSBfcmVmJHN0YXJ0QW5nbGUgPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmJHN0YXJ0QW5nbGUsXG4gICAgICBlbmRBbmdsZSA9IF9yZWYuZW5kQW5nbGUsXG4gICAgICBwYWRBbmdsZSA9IF9yZWYucGFkQW5nbGUsXG4gICAgICBwYWRSYWRpdXMgPSBfcmVmLnBhZFJhZGl1cyxcbiAgICAgIHBpZVNvcnQgPSBfcmVmLnBpZVNvcnQsXG4gICAgICBwaWVTb3J0VmFsdWVzID0gX3JlZi5waWVTb3J0VmFsdWVzLFxuICAgICAgcGllVmFsdWUgPSBfcmVmLnBpZVZhbHVlLFxuICAgICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgWydjbGFzc05hbWUnLCAndG9wJywgJ2xlZnQnLCAnZGF0YScsICdjZW50cm9pZCcsICdpbm5lclJhZGl1cycsICdvdXRlclJhZGl1cycsICdjb3JuZXJSYWRpdXMnLCAnc3RhcnRBbmdsZScsICdlbmRBbmdsZScsICdwYWRBbmdsZScsICdwYWRSYWRpdXMnLCAncGllU29ydCcsICdwaWVTb3J0VmFsdWVzJywgJ3BpZVZhbHVlJywgJ2NoaWxkcmVuJ10pO1xuXG4gIHZhciBwYXRoJCQxID0gYXJjKCk7XG4gIHBhdGgkJDEuaW5uZXJSYWRpdXMoaW5uZXJSYWRpdXMpO1xuICBpZiAob3V0ZXJSYWRpdXMpIHBhdGgkJDEub3V0ZXJSYWRpdXMob3V0ZXJSYWRpdXMpO1xuICBpZiAoY29ybmVyUmFkaXVzKSBwYXRoJCQxLmNvcm5lclJhZGl1cyhjb3JuZXJSYWRpdXMpO1xuICBpZiAocGFkUmFkaXVzKSBwYXRoJCQxLnBhZFJhZGl1cyhwYWRSYWRpdXMpO1xuICB2YXIgcGllJCQxID0gcGllKCk7XG4gIGlmIChwaWVTb3J0ICE9PSB1bmRlZmluZWQpIHBpZSQkMS5zb3J0KHBpZVNvcnQpO1xuICBpZiAocGllU29ydFZhbHVlcyAhPT0gdW5kZWZpbmVkKSBwaWUkJDEuc29ydFZhbHVlcyhwaWVTb3J0VmFsdWVzKTtcbiAgaWYgKHBpZVZhbHVlKSBwaWUkJDEudmFsdWUocGllVmFsdWUpO1xuICBpZiAocGFkQW5nbGUgIT0gbnVsbCkgcGllJCQxLnBhZEFuZ2xlKHBhZEFuZ2xlKTtcbiAgaWYgKHN0YXJ0QW5nbGUgIT0gbnVsbCkgcGllJCQxLnN0YXJ0QW5nbGUoc3RhcnRBbmdsZSk7XG4gIGlmIChlbmRBbmdsZSAhPSBudWxsKSBwaWUkJDEuZW5kQW5nbGUoZW5kQW5nbGUpO1xuICB2YXIgYXJjcyA9IHBpZSQkMShkYXRhKTtcbiAgdmFyIHJlbmRlckZ1bmN0aW9uQXJnID0ge1xuICAgIGFyY3M6IGFyY3MsXG4gICAgZ2VuZXJhdGVQYXRoUHJvcHM6IGZ1bmN0aW9uIGdlbmVyYXRlUGF0aFByb3BzKGFyYyQkMSwgaW5kZXgpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICAgIGNsYXNzTmFtZTogY3goJ3Z4LXBpZS1hcmMnLCBjbGFzc05hbWUpLFxuICAgICAgICBkOiBwYXRoJCQxKGFyYyQkMSlcbiAgICAgIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIF9leHRlbmRzKHt9LCBhcmMkJDEsIHtcbiAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICBjZW50cm9pZDogY2VudHJvaWQgPyBwYXRoJCQxLmNlbnRyb2lkKGFyYyQkMSkgOiB1bmRlZmluZWRcbiAgICAgIH0pKSk7XG4gICAgfSxcbiAgICBnZW5lcmF0ZUNlbnRyb2lkOiBmdW5jdGlvbiBnZW5lcmF0ZUNlbnRyb2lkKGFyYyQkMSkge1xuICAgICAgcmV0dXJuIGNlbnRyb2lkICYmIGNlbnRyb2lkKHBhdGgkJDEuY2VudHJvaWQoYXJjJCQxKSwgYXJjJCQxKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIEdyb3VwLFxuICAgIHsgY2xhc3NOYW1lOiAndngtcGllLWFyY3MtZ3JvdXAnLCB0b3A6IHRvcCwgbGVmdDogbGVmdCB9LFxuICAgIGNoaWxkcmVuID8gY2hpbGRyZW4ocmVuZGVyRnVuY3Rpb25BcmcpIDogYXJjcy5tYXAoZnVuY3Rpb24gKGFyYyQkMSwgaSkge1xuICAgICAgdmFyIHBhdGhQcm9wcyA9IHJlbmRlckZ1bmN0aW9uQXJnLmdlbmVyYXRlUGF0aFByb3BzKGFyYyQkMSwgaSk7XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ2cnLFxuICAgICAgICB7IGtleTogJ3BpZS1hcmMtJyArIGkgfSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgncGF0aCcsIHBhdGhQcm9wcyksXG4gICAgICAgIHJlbmRlckZ1bmN0aW9uQXJnLmdlbmVyYXRlQ2VudHJvaWQoYXJjJCQxKVxuICAgICAgKTtcbiAgICB9KVxuICApO1xufVxuXG5MaW5lLnByb3BUeXBlcyA9IHtcbiAgaW5uZXJSZWY6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5mdW5jdGlvbiBMaW5lKF9yZWYpIHtcbiAgdmFyIF9yZWYkZnJvbSA9IF9yZWYuZnJvbSxcbiAgICAgIGZyb20gPSBfcmVmJGZyb20gPT09IHVuZGVmaW5lZCA/IG5ldyBQb2ludCh7IHg6IDAsIHk6IDAgfSkgOiBfcmVmJGZyb20sXG4gICAgICBfcmVmJHRvID0gX3JlZi50byxcbiAgICAgIHRvID0gX3JlZiR0byA9PT0gdW5kZWZpbmVkID8gbmV3IFBvaW50KHsgeDogMSwgeTogMSB9KSA6IF9yZWYkdG8sXG4gICAgICBfcmVmJHN0cm9rZSA9IF9yZWYuc3Ryb2tlLFxuICAgICAgc3Ryb2tlID0gX3JlZiRzdHJva2UgPT09IHVuZGVmaW5lZCA/ICdibGFjaycgOiBfcmVmJHN0cm9rZSxcbiAgICAgIF9yZWYkc3Ryb2tlV2lkdGggPSBfcmVmLnN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlV2lkdGggPSBfcmVmJHN0cm9rZVdpZHRoID09PSB1bmRlZmluZWQgPyAxIDogX3JlZiRzdHJva2VXaWR0aCxcbiAgICAgIF9yZWYkc3Ryb2tlRGFzaGFycmF5ID0gX3JlZi5zdHJva2VEYXNoYXJyYXksXG4gICAgICBzdHJva2VEYXNoYXJyYXkgPSBfcmVmJHN0cm9rZURhc2hhcnJheSA9PT0gdW5kZWZpbmVkID8gJycgOiBfcmVmJHN0cm9rZURhc2hhcnJheSxcbiAgICAgIF9yZWYkdHJhbnNmb3JtID0gX3JlZi50cmFuc2Zvcm0sXG4gICAgICB0cmFuc2Zvcm0gPSBfcmVmJHRyYW5zZm9ybSA9PT0gdW5kZWZpbmVkID8gJycgOiBfcmVmJHRyYW5zZm9ybSxcbiAgICAgIF9yZWYkY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBjbGFzc05hbWUgPSBfcmVmJGNsYXNzTmFtZSA9PT0gdW5kZWZpbmVkID8gJycgOiBfcmVmJGNsYXNzTmFtZSxcbiAgICAgIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICBpbm5lclJlZiA9IF9yZWYuaW5uZXJSZWYsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2Zyb20nLCAndG8nLCAnc3Ryb2tlJywgJ3N0cm9rZVdpZHRoJywgJ3N0cm9rZURhc2hhcnJheScsICd0cmFuc2Zvcm0nLCAnY2xhc3NOYW1lJywgJ2RhdGEnLCAnaW5uZXJSZWYnXSk7XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2xpbmUnLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBpbm5lclJlZixcbiAgICBjbGFzc05hbWU6IGN4KCd2eC1saW5lJywgY2xhc3NOYW1lKSxcbiAgICB4MTogZnJvbS54LFxuICAgIHkxOiBmcm9tLnksXG4gICAgeDI6IHRvLngsXG4gICAgeTI6IHRvLnksXG4gICAgc3Ryb2tlOiBzdHJva2UsXG4gICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgIHN0cm9rZURhc2hhcnJheTogc3Ryb2tlRGFzaGFycmF5LFxuICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtXG4gIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSk7XG59XG5cbkxpbmVQYXRoLnByb3BUeXBlcyA9IHtcbiAgaW5uZXJSZWY6IFByb3BUeXBlcy5mdW5jLFxuICB4U2NhbGU6IFByb3BUeXBlcy5mdW5jLFxuICB5U2NhbGU6IFByb3BUeXBlcy5mdW5jLFxuICBkYXRhOiBQcm9wVHlwZXMuYXJyYXksXG4gIHg6IFByb3BUeXBlcy5mdW5jLFxuICB5OiBQcm9wVHlwZXMuZnVuYyxcbiAgZGVmaW5lZDogUHJvcFR5cGVzLmZ1bmMsXG4gIHN0cm9rZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgc3Ryb2tlV2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXG4gIGdseXBoOiBQcm9wVHlwZXMuZnVuYyxcbiAgY3VydmU6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5mdW5jdGlvbiBMaW5lUGF0aChfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgeFNjYWxlID0gX3JlZi54U2NhbGUsXG4gICAgICB5U2NhbGUgPSBfcmVmLnlTY2FsZSxcbiAgICAgIHggPSBfcmVmLngsXG4gICAgICB5ID0gX3JlZi55LFxuICAgICAgX3JlZiRkZWZpbmVkID0gX3JlZi5kZWZpbmVkLFxuICAgICAgZGVmaW5lZCA9IF9yZWYkZGVmaW5lZCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IDogX3JlZiRkZWZpbmVkLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBfcmVmJHN0cm9rZSA9IF9yZWYuc3Ryb2tlLFxuICAgICAgc3Ryb2tlID0gX3JlZiRzdHJva2UgPT09IHVuZGVmaW5lZCA/ICdzdGVlbGJsdWUnIDogX3JlZiRzdHJva2UsXG4gICAgICBfcmVmJHN0cm9rZVdpZHRoID0gX3JlZi5zdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZVdpZHRoID0gX3JlZiRzdHJva2VXaWR0aCA9PT0gdW5kZWZpbmVkID8gMiA6IF9yZWYkc3Ryb2tlV2lkdGgsXG4gICAgICBfcmVmJHN0cm9rZURhc2hhcnJheSA9IF9yZWYuc3Ryb2tlRGFzaGFycmF5LFxuICAgICAgc3Ryb2tlRGFzaGFycmF5ID0gX3JlZiRzdHJva2VEYXNoYXJyYXkgPT09IHVuZGVmaW5lZCA/ICcnIDogX3JlZiRzdHJva2VEYXNoYXJyYXksXG4gICAgICBfcmVmJHN0cm9rZURhc2hvZmZzZXQgPSBfcmVmLnN0cm9rZURhc2hvZmZzZXQsXG4gICAgICBzdHJva2VEYXNob2Zmc2V0ID0gX3JlZiRzdHJva2VEYXNob2Zmc2V0ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiRzdHJva2VEYXNob2Zmc2V0LFxuICAgICAgX3JlZiRmaWxsID0gX3JlZi5maWxsLFxuICAgICAgZmlsbCA9IF9yZWYkZmlsbCA9PT0gdW5kZWZpbmVkID8gJ25vbmUnIDogX3JlZiRmaWxsLFxuICAgICAgX3JlZiRjdXJ2ZSA9IF9yZWYuY3VydmUsXG4gICAgICBjdXJ2ZSA9IF9yZWYkY3VydmUgPT09IHVuZGVmaW5lZCA/IGN1cnZlTGluZWFyIDogX3JlZiRjdXJ2ZSxcbiAgICAgIGdseXBoID0gX3JlZi5nbHlwaCxcbiAgICAgIGlubmVyUmVmID0gX3JlZi5pbm5lclJlZixcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnY2hpbGRyZW4nLCAnZGF0YScsICd4U2NhbGUnLCAneVNjYWxlJywgJ3gnLCAneScsICdkZWZpbmVkJywgJ2NsYXNzTmFtZScsICdzdHJva2UnLCAnc3Ryb2tlV2lkdGgnLCAnc3Ryb2tlRGFzaGFycmF5JywgJ3N0cm9rZURhc2hvZmZzZXQnLCAnZmlsbCcsICdjdXJ2ZScsICdnbHlwaCcsICdpbm5lclJlZiddKTtcblxuICB2YXIgcGF0aCQkMSA9IGxpbmUoKS54KGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4geFNjYWxlKHguYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKTtcbiAgfSkueShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHlTY2FsZSh5LmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSk7XG4gIH0pLmRlZmluZWQoZGVmaW5lZCkuY3VydmUoY3VydmUpO1xuICBpZiAoY2hpbGRyZW4pIHJldHVybiBjaGlsZHJlbih7IHBhdGg6IHBhdGgkJDEgfSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICdnJyxcbiAgICBudWxsLFxuICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCBfZXh0ZW5kcyh7XG4gICAgICByZWY6IGlubmVyUmVmLFxuICAgICAgY2xhc3NOYW1lOiBjeCgndngtbGluZXBhdGgnLCBjbGFzc05hbWUpLFxuICAgICAgZDogcGF0aCQkMShkYXRhKSxcbiAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlRGFzaGFycmF5OiBzdHJva2VEYXNoYXJyYXksXG4gICAgICBzdHJva2VEYXNob2Zmc2V0OiBzdHJva2VEYXNob2Zmc2V0LFxuICAgICAgZmlsbDogZmlsbFxuICAgIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSksXG4gICAgZ2x5cGggJiYgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICdnJyxcbiAgICAgIHsgY2xhc3NOYW1lOiAndngtbGluZXBhdGgtZ2x5cGhzJyB9LFxuICAgICAgZGF0YS5tYXAoZ2x5cGgpXG4gICAgKVxuICApO1xufVxuXG5MaW5lUmFkaWFsLnByb3BUeXBlcyA9IHtcbiAgaW5uZXJSZWY6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5mdW5jdGlvbiBMaW5lUmFkaWFsKF9yZWYpIHtcbiAgdmFyIF9yZWYkY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBjbGFzc05hbWUgPSBfcmVmJGNsYXNzTmFtZSA9PT0gdW5kZWZpbmVkID8gJycgOiBfcmVmJGNsYXNzTmFtZSxcbiAgICAgIGFuZ2xlID0gX3JlZi5hbmdsZSxcbiAgICAgIHJhZGl1cyA9IF9yZWYucmFkaXVzLFxuICAgICAgZGVmaW5lZCA9IF9yZWYuZGVmaW5lZCxcbiAgICAgIGN1cnZlID0gX3JlZi5jdXJ2ZSxcbiAgICAgIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICBpbm5lclJlZiA9IF9yZWYuaW5uZXJSZWYsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2NsYXNzTmFtZScsICdhbmdsZScsICdyYWRpdXMnLCAnZGVmaW5lZCcsICdjdXJ2ZScsICdkYXRhJywgJ2lubmVyUmVmJ10pO1xuXG4gIHZhciBwYXRoJCQxID0gcmFkaWFsTGluZSgpO1xuICBpZiAoYW5nbGUpIHBhdGgkJDEuYW5nbGUoYW5nbGUpO1xuICBpZiAocmFkaXVzKSBwYXRoJCQxLnJhZGl1cyhyYWRpdXMpO1xuICBpZiAoZGVmaW5lZCkgcGF0aCQkMS5kZWZpbmVkKGRlZmluZWQpO1xuICBpZiAoY3VydmUpIHBhdGgkJDEuY3VydmUoY3VydmUpO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAnZycsXG4gICAgbnVsbCxcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgICAgcmVmOiBpbm5lclJlZixcbiAgICAgIGNsYXNzTmFtZTogY3goJ3Z4LWxpbmUtcmFkaWFsJywgY2xhc3NOYW1lKSxcbiAgICAgIGQ6IHBhdGgkJDEoZGF0YSlcbiAgICB9LCBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzLCBkYXRhKSkpXG4gICk7XG59XG5cbkFyZWEucHJvcFR5cGVzID0ge1xuICB4OiBQcm9wVHlwZXMuZnVuYyxcbiAgeDA6IFByb3BUeXBlcy5mdW5jLFxuICB4MTogUHJvcFR5cGVzLmZ1bmMsXG4gIHk6IFByb3BUeXBlcy5mdW5jLFxuICB5MDogUHJvcFR5cGVzLmZ1bmMsXG4gIHkxOiBQcm9wVHlwZXMuZnVuYyxcbiAgeFNjYWxlOiBQcm9wVHlwZXMuZnVuYyxcbiAgeVNjYWxlOiBQcm9wVHlwZXMuZnVuYyxcbiAgZGF0YTogUHJvcFR5cGVzLmFycmF5LFxuICBkZWZpbmVkOiBQcm9wVHlwZXMuZnVuYyxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuYm9vbCwgUHJvcFR5cGVzLm9iamVjdCwgUHJvcFR5cGVzLmFycmF5XSksXG4gIGlubmVyUmVmOiBQcm9wVHlwZXMuZnVuYyxcbiAgc3Ryb2tlRGFzaGFycmF5OiBQcm9wVHlwZXMuc3RyaW5nLFxuICBzdHJva2VXaWR0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgc3Ryb2tlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBmaWxsOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBjdXJ2ZTogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIEFyZWEoX3JlZikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgeCA9IF9yZWYueCxcbiAgICAgIHgwID0gX3JlZi54MCxcbiAgICAgIHgxID0gX3JlZi54MSxcbiAgICAgIHkgPSBfcmVmLnksXG4gICAgICB5MCA9IF9yZWYueTAsXG4gICAgICB5MSA9IF9yZWYueTEsXG4gICAgICB4U2NhbGUgPSBfcmVmLnhTY2FsZSxcbiAgICAgIHlTY2FsZSA9IF9yZWYueVNjYWxlLFxuICAgICAgX3JlZiRkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgZGF0YSA9IF9yZWYkZGF0YSA9PT0gdW5kZWZpbmVkID8gW10gOiBfcmVmJGRhdGEsXG4gICAgICBfcmVmJGRlZmluZWQgPSBfcmVmLmRlZmluZWQsXG4gICAgICBkZWZpbmVkID0gX3JlZiRkZWZpbmVkID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gOiBfcmVmJGRlZmluZWQsXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIHN0cm9rZURhc2hhcnJheSA9IF9yZWYuc3Ryb2tlRGFzaGFycmF5LFxuICAgICAgX3JlZiRzdHJva2VXaWR0aCA9IF9yZWYuc3Ryb2tlV2lkdGgsXG4gICAgICBzdHJva2VXaWR0aCA9IF9yZWYkc3Ryb2tlV2lkdGggPT09IHVuZGVmaW5lZCA/IDIgOiBfcmVmJHN0cm9rZVdpZHRoLFxuICAgICAgX3JlZiRzdHJva2UgPSBfcmVmLnN0cm9rZSxcbiAgICAgIHN0cm9rZSA9IF9yZWYkc3Ryb2tlID09PSB1bmRlZmluZWQgPyAnYmxhY2snIDogX3JlZiRzdHJva2UsXG4gICAgICBfcmVmJGZpbGwgPSBfcmVmLmZpbGwsXG4gICAgICBmaWxsID0gX3JlZiRmaWxsID09PSB1bmRlZmluZWQgPyAncmdiYSgwLDAsMCwwLjMpJyA6IF9yZWYkZmlsbCxcbiAgICAgIGN1cnZlID0gX3JlZi5jdXJ2ZSxcbiAgICAgIGlubmVyUmVmID0gX3JlZi5pbm5lclJlZixcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnY2hpbGRyZW4nLCAneCcsICd4MCcsICd4MScsICd5JywgJ3kwJywgJ3kxJywgJ3hTY2FsZScsICd5U2NhbGUnLCAnZGF0YScsICdkZWZpbmVkJywgJ2NsYXNzTmFtZScsICdzdHJva2VEYXNoYXJyYXknLCAnc3Ryb2tlV2lkdGgnLCAnc3Ryb2tlJywgJ2ZpbGwnLCAnY3VydmUnLCAnaW5uZXJSZWYnXSk7XG5cbiAgdmFyIHBhdGgkJDEgPSBhcmVhKCk7XG4gIGlmICh4KSBwYXRoJCQxLngoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB4U2NhbGUoeC5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykpO1xuICB9KTtcbiAgaWYgKHgwKSBwYXRoJCQxLngwKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4geFNjYWxlKHgwLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSk7XG4gIH0pO1xuICBpZiAoeDEpIHBhdGgkJDEueDEoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB4U2NhbGUoeDEuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKTtcbiAgfSk7XG4gIGlmICh5KSBwYXRoJCQxLnkoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB5U2NhbGUoeS5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykpO1xuICB9KTtcbiAgaWYgKHkwKSBwYXRoJCQxLnkwKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4geVNjYWxlKHkwLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSk7XG4gIH0pO1xuICBpZiAoeTEpIHBhdGgkJDEueTEoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB5U2NhbGUoeTEuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKTtcbiAgfSk7XG4gIGlmIChkZWZpbmVkKSBwYXRoJCQxLmRlZmluZWQoZGVmaW5lZCk7XG4gIGlmIChjdXJ2ZSkgcGF0aCQkMS5jdXJ2ZShjdXJ2ZSk7XG4gIGlmIChjaGlsZHJlbikgcmV0dXJuIGNoaWxkcmVuKHsgcGF0aDogcGF0aCQkMSB9KTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgJ2cnLFxuICAgIG51bGwsXG4gICAgUmVhY3QuY3JlYXRlRWxlbWVudCgncGF0aCcsIF9leHRlbmRzKHtcbiAgICAgIHJlZjogaW5uZXJSZWYsXG4gICAgICBjbGFzc05hbWU6IGN4KCd2eC1hcmVhJywgY2xhc3NOYW1lKSxcbiAgICAgIGQ6IHBhdGgkJDEoZGF0YSksXG4gICAgICBzdHJva2U6IHN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZURhc2hhcnJheTogc3Ryb2tlRGFzaGFycmF5LFxuICAgICAgZmlsbDogZmlsbFxuICAgIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSlcbiAgKTtcbn1cblxuQXJlYUNsb3NlZC5wcm9wVHlwZXMgPSB7XG4gIGlubmVyUmVmOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuZnVuY3Rpb24gQXJlYUNsb3NlZChfcmVmKSB7XG4gIHZhciB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueSxcbiAgICAgIHkwID0gX3JlZi55MCxcbiAgICAgIHhTY2FsZSA9IF9yZWYueFNjYWxlLFxuICAgICAgeVNjYWxlID0gX3JlZi55U2NhbGUsXG4gICAgICBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgX3JlZiRkZWZpbmVkID0gX3JlZi5kZWZpbmVkLFxuICAgICAgZGVmaW5lZCA9IF9yZWYkZGVmaW5lZCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IDogX3JlZiRkZWZpbmVkLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBzdHJva2VEYXNoYXJyYXkgPSBfcmVmLnN0cm9rZURhc2hhcnJheSxcbiAgICAgIF9yZWYkc3Ryb2tlV2lkdGggPSBfcmVmLnN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlV2lkdGggPSBfcmVmJHN0cm9rZVdpZHRoID09PSB1bmRlZmluZWQgPyAyIDogX3JlZiRzdHJva2VXaWR0aCxcbiAgICAgIF9yZWYkc3Ryb2tlID0gX3JlZi5zdHJva2UsXG4gICAgICBzdHJva2UgPSBfcmVmJHN0cm9rZSA9PT0gdW5kZWZpbmVkID8gJ2JsYWNrJyA6IF9yZWYkc3Ryb2tlLFxuICAgICAgX3JlZiRmaWxsID0gX3JlZi5maWxsLFxuICAgICAgZmlsbCA9IF9yZWYkZmlsbCA9PT0gdW5kZWZpbmVkID8gJ3JnYmEoMCwwLDAsMC4zKScgOiBfcmVmJGZpbGwsXG4gICAgICBjdXJ2ZSA9IF9yZWYuY3VydmUsXG4gICAgICBpbm5lclJlZiA9IF9yZWYuaW5uZXJSZWYsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ3gnLCAneScsICd5MCcsICd4U2NhbGUnLCAneVNjYWxlJywgJ2RhdGEnLCAnZGVmaW5lZCcsICdjbGFzc05hbWUnLCAnc3Ryb2tlRGFzaGFycmF5JywgJ3N0cm9rZVdpZHRoJywgJ3N0cm9rZScsICdmaWxsJywgJ2N1cnZlJywgJ2lubmVyUmVmJ10pO1xuXG4gIHZhciBwYXRoJCQxID0gYXJlYSgpLngoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB4U2NhbGUoeC5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykpO1xuICB9KS55MCh5MCB8fCB5U2NhbGUucmFuZ2UoKVswXSkueTEoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB5U2NhbGUoeS5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykpO1xuICB9KS5kZWZpbmVkKGRlZmluZWQpO1xuICBpZiAoY3VydmUpIHBhdGgkJDEuY3VydmUoY3VydmUpO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAnZycsXG4gICAgbnVsbCxcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgICAgcmVmOiBpbm5lclJlZixcbiAgICAgIGNsYXNzTmFtZTogY3goJ3Z4LWFyZWEtY2xvc2VkJywgY2xhc3NOYW1lKSxcbiAgICAgIGQ6IHBhdGgkJDEoZGF0YSksXG4gICAgICBzdHJva2U6IHN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZURhc2hhcnJheTogc3Ryb2tlRGFzaGFycmF5LFxuICAgICAgZmlsbDogZmlsbFxuICAgIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSlcbiAgKTtcbn1cblxuZnVuY3Rpb24gQXJlYVN0YWNrKF9yZWYpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgX3JlZiR0b3AgPSBfcmVmLnRvcCxcbiAgICAgIF9yZWYkbGVmdCA9IF9yZWYubGVmdCxcbiAgICAgIGtleXMgPSBfcmVmLmtleXMsXG4gICAgICBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgY3VydmUgPSBfcmVmLmN1cnZlLFxuICAgICAgZGVmaW5lZCA9IF9yZWYuZGVmaW5lZCxcbiAgICAgIHggPSBfcmVmLngsXG4gICAgICB4MCA9IF9yZWYueDAsXG4gICAgICB4MSA9IF9yZWYueDEsXG4gICAgICB5MCA9IF9yZWYueTAsXG4gICAgICB5MSA9IF9yZWYueTEsXG4gICAgICBnbHlwaCA9IF9yZWYuZ2x5cGgsXG4gICAgICBfcmVmJHJldmVyc2UgPSBfcmVmLnJldmVyc2UsXG4gICAgICByZXZlcnNlID0gX3JlZiRyZXZlcnNlID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkcmV2ZXJzZSxcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnY2xhc3NOYW1lJywgJ3RvcCcsICdsZWZ0JywgJ2tleXMnLCAnZGF0YScsICdjdXJ2ZScsICdkZWZpbmVkJywgJ3gnLCAneDAnLCAneDEnLCAneTAnLCAneTEnLCAnZ2x5cGgnLCAncmV2ZXJzZSddKTtcblxuICB2YXIgc3RhY2skJDEgPSBzdGFjaygpO1xuICBpZiAoa2V5cykgc3RhY2skJDEua2V5cyhrZXlzKTtcblxuICB2YXIgcGF0aCQkMSA9IGFyZWEoKTtcbiAgaWYgKHgpIHBhdGgkJDEueCh4KTtcbiAgaWYgKHgwKSBwYXRoJCQxLngwKHgwKTtcbiAgaWYgKHgxKSBwYXRoJCQxLngxKHgxKTtcbiAgaWYgKHkwKSBwYXRoJCQxLnkwKHkwKTtcbiAgaWYgKHkxKSBwYXRoJCQxLnkxKHkxKTtcbiAgaWYgKGN1cnZlKSBwYXRoJCQxLmN1cnZlKGN1cnZlKTtcbiAgaWYgKGRlZmluZWQpIHBhdGgkJDEuZGVmaW5lZChkZWZpbmVkKTtcblxuICB2YXIgc2VyaWVzRGF0YSA9IHN0YWNrJCQxKGRhdGEpO1xuICBpZiAocmV2ZXJzZSkgc2VyaWVzRGF0YS5yZXZlcnNlKCk7XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgJ2cnLFxuICAgIG51bGwsXG4gICAgc2VyaWVzRGF0YS5tYXAoZnVuY3Rpb24gKHNlcmllcywgaSkge1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCBfZXh0ZW5kcyh7XG4gICAgICAgIGNsYXNzTmFtZTogY3goJ3Z4LWFyZWEtc3RhY2snLCBjbGFzc05hbWUpLFxuICAgICAgICBrZXk6ICdhcmVhLXN0YWNrLScgKyBpICsgJy0nICsgKHNlcmllcy5rZXkgfHwgJycpLFxuICAgICAgICBkOiBwYXRoJCQxKHNlcmllcylcbiAgICAgIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIHtcbiAgICAgICAgZGF0dW06IHNlcmllc1tpXSxcbiAgICAgICAgaW5kZXg6IGksXG4gICAgICAgIHNlcmllczogc2VyaWVzXG4gICAgICB9KSkpO1xuICAgIH0pLFxuICAgICEhZ2x5cGggJiYgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICdnJyxcbiAgICAgIHsgY2xhc3NOYW1lOiAndngtYXJlYS1zdGFjay1nbHlwaHMnIH0sXG4gICAgICBkYXRhLm1hcChnbHlwaClcbiAgICApXG4gICk7XG59XG5cbkJhci5wcm9wVHlwZXMgPSB7XG4gIGlubmVyUmVmOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuZnVuY3Rpb24gQmFyKF9yZWYpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgaW5uZXJSZWYgPSBfcmVmLmlubmVyUmVmLFxuICAgICAgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgIF9yZWYkeCA9IF9yZWYueCxcbiAgICAgIHggPSBfcmVmJHggPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmJHgsXG4gICAgICBfcmVmJHkgPSBfcmVmLnksXG4gICAgICB5ID0gX3JlZiR5ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiR5LFxuICAgICAgd2lkdGggPSBfcmVmLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQsXG4gICAgICByeCA9IF9yZWYucngsXG4gICAgICByeSA9IF9yZWYucnksXG4gICAgICBfcmVmJGZpbGwgPSBfcmVmLmZpbGwsXG4gICAgICBmaWxsID0gX3JlZiRmaWxsID09PSB1bmRlZmluZWQgPyAnc3RlZWxibHVlJyA6IF9yZWYkZmlsbCxcbiAgICAgIGZpbGxPcGFjaXR5ID0gX3JlZi5maWxsT3BhY2l0eSxcbiAgICAgIHN0cm9rZSA9IF9yZWYuc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGggPSBfcmVmLnN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlRGFzaGFycmF5ID0gX3JlZi5zdHJva2VEYXNoYXJyYXksXG4gICAgICBzdHJva2VMaW5lY2FwID0gX3JlZi5zdHJva2VMaW5lY2FwLFxuICAgICAgc3Ryb2tlTGluZWpvaW4gPSBfcmVmLnN0cm9rZUxpbmVqb2luLFxuICAgICAgc3Ryb2tlTWl0ZXJsaW1pdCA9IF9yZWYuc3Ryb2tlTWl0ZXJsaW1pdCxcbiAgICAgIHN0cm9rZU9wYWNpdHkgPSBfcmVmLnN0cm9rZU9wYWNpdHksXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2NsYXNzTmFtZScsICdpbm5lclJlZicsICdkYXRhJywgJ3gnLCAneScsICd3aWR0aCcsICdoZWlnaHQnLCAncngnLCAncnknLCAnZmlsbCcsICdmaWxsT3BhY2l0eScsICdzdHJva2UnLCAnc3Ryb2tlV2lkdGgnLCAnc3Ryb2tlRGFzaGFycmF5JywgJ3N0cm9rZUxpbmVjYXAnLCAnc3Ryb2tlTGluZWpvaW4nLCAnc3Ryb2tlTWl0ZXJsaW1pdCcsICdzdHJva2VPcGFjaXR5J10pO1xuXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdyZWN0JywgX2V4dGVuZHMoe1xuICAgIHJlZjogaW5uZXJSZWYsXG4gICAgY2xhc3NOYW1lOiBjeCgndngtYmFyJywgY2xhc3NOYW1lKSxcbiAgICB4OiB4LFxuICAgIHk6IHksXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHJ4OiByeCxcbiAgICByeTogcnksXG4gICAgZmlsbDogZmlsbCxcbiAgICBmaWxsT3BhY2l0eTogZmlsbE9wYWNpdHksXG4gICAgc3Ryb2tlOiBzdHJva2UsXG4gICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgIHN0cm9rZURhc2hhcnJheTogc3Ryb2tlRGFzaGFycmF5LFxuICAgIHN0cm9rZUxpbmVjYXA6IHN0cm9rZUxpbmVjYXAsXG4gICAgc3Ryb2tlTGluZWpvaW46IHN0cm9rZUxpbmVqb2luLFxuICAgIHN0cm9rZU1pdGVybGltaXQ6IHN0cm9rZU1pdGVybGltaXQsXG4gICAgc3Ryb2tlT3BhY2l0eTogc3Ryb2tlT3BhY2l0eVxuICB9LCBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzLCBkYXRhKSkpO1xufVxuXG5mdW5jdGlvbiBCYXJHcm91cChfcmVmKSB7XG4gIHZhciBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICB0b3AgPSBfcmVmLnRvcCxcbiAgICAgIGxlZnQgPSBfcmVmLmxlZnQsXG4gICAgICB4MCA9IF9yZWYueDAsXG4gICAgICB4MFNjYWxlID0gX3JlZi54MFNjYWxlLFxuICAgICAgeDFTY2FsZSA9IF9yZWYueDFTY2FsZSxcbiAgICAgIHlTY2FsZSA9IF9yZWYueVNjYWxlLFxuICAgICAgelNjYWxlID0gX3JlZi56U2NhbGUsXG4gICAgICBrZXlzID0gX3JlZi5rZXlzLFxuICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2RhdGEnLCAnY2xhc3NOYW1lJywgJ3RvcCcsICdsZWZ0JywgJ3gwJywgJ3gwU2NhbGUnLCAneDFTY2FsZScsICd5U2NhbGUnLCAnelNjYWxlJywgJ2tleXMnLCAnaGVpZ2h0J10pO1xuXG4gIHZhciBmb3JtYXQgPSB4MFNjYWxlLnRpY2tGb3JtYXQgPyB4MFNjYWxlLnRpY2tGb3JtYXQoKSA6IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQ7XG4gIH07XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIEdyb3VwLFxuICAgIHsgY2xhc3NOYW1lOiBjeCgndngtYmFyLWdyb3VwJywgY2xhc3NOYW1lKSwgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfSxcbiAgICBkYXRhICYmIGRhdGEubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgR3JvdXAsXG4gICAgICAgIHsga2V5OiAnYmFyLWdyb3VwLScgKyBpICsgJy0nICsgeDAoZCksIGxlZnQ6IHgwU2NhbGUoeDAoZCkpIH0sXG4gICAgICAgIGtleXMgJiYga2V5cy5tYXAoZnVuY3Rpb24gKGtleSwgaSkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGRba2V5XTtcbiAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChCYXIsIF9leHRlbmRzKHtcbiAgICAgICAgICAgIGtleTogJ2Jhci1ncm91cC1iYXItJyArIGkgKyAnLScgKyB2YWx1ZSArICctJyArIGtleSxcbiAgICAgICAgICAgIHg6IHgxU2NhbGUoa2V5KSxcbiAgICAgICAgICAgIHk6IHlTY2FsZSh2YWx1ZSksXG4gICAgICAgICAgICB3aWR0aDogeDFTY2FsZS5iYW5kd2lkdGgoKSxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0IC0geVNjYWxlKHZhbHVlKSxcbiAgICAgICAgICAgIGZpbGw6IHpTY2FsZShrZXkpLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICB4OiBmb3JtYXQoeDAoZCkpLFxuICAgICAgICAgICAgICBkYXRhOiBkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVzdFByb3BzKSk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pXG4gICk7XG59XG5cbkJhckdyb3VwLnByb3BUeXBlcyA9IHtcbiAgZGF0YTogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsXG4gIHgwOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB4MFNjYWxlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB4MVNjYWxlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB5U2NhbGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHpTY2FsZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAga2V5czogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsXG4gIGhlaWdodDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRvcDogUHJvcFR5cGVzLm51bWJlcixcbiAgbGVmdDogUHJvcFR5cGVzLm51bWJlclxufTtcblxuZnVuY3Rpb24gQmFyR3JvdXBIb3Jpem9udGFsKF9yZWYpIHtcbiAgdmFyIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIHRvcCA9IF9yZWYudG9wLFxuICAgICAgbGVmdCA9IF9yZWYubGVmdCxcbiAgICAgIHkwID0gX3JlZi55MCxcbiAgICAgIHkwU2NhbGUgPSBfcmVmLnkwU2NhbGUsXG4gICAgICB5MVNjYWxlID0gX3JlZi55MVNjYWxlLFxuICAgICAgeFNjYWxlID0gX3JlZi54U2NhbGUsXG4gICAgICB6U2NhbGUgPSBfcmVmLnpTY2FsZSxcbiAgICAgIGtleXMgPSBfcmVmLmtleXMsXG4gICAgICB3aWR0aCA9IF9yZWYud2lkdGgsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2RhdGEnLCAnY2xhc3NOYW1lJywgJ3RvcCcsICdsZWZ0JywgJ3kwJywgJ3kwU2NhbGUnLCAneTFTY2FsZScsICd4U2NhbGUnLCAnelNjYWxlJywgJ2tleXMnLCAnd2lkdGgnXSk7XG5cbiAgdmFyIGZvcm1hdCA9IHkwU2NhbGUudGlja0Zvcm1hdCA/IHkwU2NhbGUudGlja0Zvcm1hdCgpIDogZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZDtcbiAgfTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgR3JvdXAsXG4gICAgeyBjbGFzc05hbWU6IGN4KCd2eC1iYXItZ3JvdXAtaG9yaXpvbnRhbCcsIGNsYXNzTmFtZSksIHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH0sXG4gICAgZGF0YSAmJiBkYXRhLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIEdyb3VwLFxuICAgICAgICB7IGtleTogJ2Jhci1ncm91cC0nICsgaSArICctJyArIHkwKGQpLCB0b3A6IHkwU2NhbGUoeTAoZCkpIH0sXG4gICAgICAgIGtleXMgJiYga2V5cy5tYXAoZnVuY3Rpb24gKGtleSwgaSkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGRba2V5XTtcbiAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChCYXIsIF9leHRlbmRzKHtcbiAgICAgICAgICAgIGtleTogJ2Jhci1ncm91cC1iYXItJyArIGkgKyAnLScgKyB2YWx1ZSArICctJyArIGtleSxcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiB5MVNjYWxlKGtleSksXG4gICAgICAgICAgICB3aWR0aDogd2lkdGggLSB4U2NhbGUodmFsdWUpLFxuICAgICAgICAgICAgaGVpZ2h0OiB5MVNjYWxlLmJhbmR3aWR0aCgpLFxuICAgICAgICAgICAgZmlsbDogelNjYWxlKGtleSksXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgIHk6IGZvcm1hdCh5MChkKSksXG4gICAgICAgICAgICAgIGRhdGE6IGRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCByZXN0UHJvcHMpKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSlcbiAgKTtcbn1cblxuQmFyR3JvdXBIb3Jpem9udGFsLnByb3BUeXBlcyA9IHtcbiAgZGF0YTogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsXG4gIHkwOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB5MFNjYWxlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB5MVNjYWxlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB4U2NhbGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHpTY2FsZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAga2V5czogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsXG4gIHdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdG9wOiBQcm9wVHlwZXMubnVtYmVyLFxuICBsZWZ0OiBQcm9wVHlwZXMubnVtYmVyXG59O1xuXG5mdW5jdGlvbiBCYXJTdGFjayhfcmVmKSB7XG4gIHZhciBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICB0b3AgPSBfcmVmLnRvcCxcbiAgICAgIGxlZnQgPSBfcmVmLmxlZnQsXG4gICAgICB4ID0gX3JlZi54LFxuICAgICAgeFNjYWxlID0gX3JlZi54U2NhbGUsXG4gICAgICB5U2NhbGUgPSBfcmVmLnlTY2FsZSxcbiAgICAgIHpTY2FsZSA9IF9yZWYuelNjYWxlLFxuICAgICAga2V5cyA9IF9yZWYua2V5cyxcbiAgICAgIGhlaWdodCA9IF9yZWYuaGVpZ2h0LFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgWydkYXRhJywgJ2NsYXNzTmFtZScsICd0b3AnLCAnbGVmdCcsICd4JywgJ3hTY2FsZScsICd5U2NhbGUnLCAnelNjYWxlJywgJ2tleXMnLCAnaGVpZ2h0J10pO1xuXG4gIHZhciBzZXJpZXMgPSBzdGFjaygpLmtleXMoa2V5cykoZGF0YSk7XG4gIHZhciBmb3JtYXQgPSB4U2NhbGUudGlja0Zvcm1hdCA/IHhTY2FsZS50aWNrRm9ybWF0KCkgOiBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkO1xuICB9O1xuICB2YXIgYmFuZHdpZHRoID0geFNjYWxlLmJhbmR3aWR0aCgpO1xuICB2YXIgc3RlcCA9IHhTY2FsZS5zdGVwKCk7XG4gIHZhciBwYWRkaW5nSW5uZXIgPSB4U2NhbGUucGFkZGluZ0lubmVyKCk7XG4gIHZhciBwYWRkaW5nT3V0ZXIgPSB4U2NhbGUucGFkZGluZ091dGVyKCk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIEdyb3VwLFxuICAgIHsgY2xhc3NOYW1lOiBjeCgndngtYmFyLXN0YWNrJywgY2xhc3NOYW1lKSwgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfSxcbiAgICBzZXJpZXMgJiYgc2VyaWVzLm1hcChmdW5jdGlvbiAocywgaSkge1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIEdyb3VwLFxuICAgICAgICB7IGtleTogJ3Z4LWJhci1zdGFjay0nICsgaSB9LFxuICAgICAgICBzLm1hcChmdW5jdGlvbiAoZCwgaWkpIHtcbiAgICAgICAgICB2YXIgYmFySGVpZ2h0ID0geVNjYWxlKGRbMF0pIC0geVNjYWxlKGRbMV0pO1xuICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEJhciwgX2V4dGVuZHMoe1xuICAgICAgICAgICAga2V5OiAnYmFyLWdyb3VwLWJhci0nICsgaSArICctJyArIGlpICsgJy0nICsgcy5rZXksXG4gICAgICAgICAgICB4OiB4U2NhbGUoeChkLmRhdGEpKSxcbiAgICAgICAgICAgIHk6IHlTY2FsZShkWzFdKSxcbiAgICAgICAgICAgIHdpZHRoOiBiYW5kd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGJhckhlaWdodCxcbiAgICAgICAgICAgIGZpbGw6IHpTY2FsZShzLmtleSksXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIGJhbmR3aWR0aDogYmFuZHdpZHRoLFxuICAgICAgICAgICAgICBwYWRkaW5nSW5uZXI6IHBhZGRpbmdJbm5lcixcbiAgICAgICAgICAgICAgcGFkZGluZ091dGVyOiBwYWRkaW5nT3V0ZXIsXG4gICAgICAgICAgICAgIHN0ZXA6IHN0ZXAsXG4gICAgICAgICAgICAgIGtleTogcy5rZXksXG4gICAgICAgICAgICAgIHZhbHVlOiBkWzFdLFxuICAgICAgICAgICAgICBoZWlnaHQ6IGJhckhlaWdodCxcbiAgICAgICAgICAgICAgd2lkdGg6IGJhbmR3aWR0aCxcbiAgICAgICAgICAgICAgeDogeChkLmRhdGEpLFxuICAgICAgICAgICAgICB4Rm9ybWF0dGVkOiBmb3JtYXQoeChkLmRhdGEpKSxcbiAgICAgICAgICAgICAgZGF0YTogZC5kYXRhXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVzdFByb3BzKSk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pXG4gICk7XG59XG5cbkJhclN0YWNrLnByb3BUeXBlcyA9IHtcbiAgZGF0YTogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsXG4gIHg6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHhTY2FsZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgeVNjYWxlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB6U2NhbGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIGtleXM6IFByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLFxuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRvcDogUHJvcFR5cGVzLm51bWJlcixcbiAgbGVmdDogUHJvcFR5cGVzLm51bWJlclxufTtcblxuZnVuY3Rpb24gQmFyU3RhY2tIb3Jpem9udGFsKF9yZWYpIHtcbiAgdmFyIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIHRvcCA9IF9yZWYudG9wLFxuICAgICAgbGVmdCA9IF9yZWYubGVmdCxcbiAgICAgIHkgPSBfcmVmLnksXG4gICAgICB4U2NhbGUgPSBfcmVmLnhTY2FsZSxcbiAgICAgIHlTY2FsZSA9IF9yZWYueVNjYWxlLFxuICAgICAgelNjYWxlID0gX3JlZi56U2NhbGUsXG4gICAgICBrZXlzID0gX3JlZi5rZXlzLFxuICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2RhdGEnLCAnY2xhc3NOYW1lJywgJ3RvcCcsICdsZWZ0JywgJ3knLCAneFNjYWxlJywgJ3lTY2FsZScsICd6U2NhbGUnLCAna2V5cycsICdoZWlnaHQnXSk7XG5cbiAgdmFyIHNlcmllcyA9IHN0YWNrKCkua2V5cyhrZXlzKShkYXRhKTtcbiAgdmFyIGZvcm1hdCA9IHlTY2FsZS50aWNrRm9ybWF0ID8geVNjYWxlLnRpY2tGb3JtYXQoKSA6IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQ7XG4gIH07XG4gIHZhciBiYW5kd2lkdGggPSB5U2NhbGUuYmFuZHdpZHRoKCk7XG4gIHZhciBzdGVwID0geVNjYWxlLnN0ZXAoKTtcbiAgdmFyIHBhZGRpbmdJbm5lciA9IHlTY2FsZS5wYWRkaW5nSW5uZXIoKTtcbiAgdmFyIHBhZGRpbmdPdXRlciA9IHlTY2FsZS5wYWRkaW5nT3V0ZXIoKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgR3JvdXAsXG4gICAgeyBjbGFzc05hbWU6IGN4KCd2eC1iYXItc3RhY2staG9yaXpvbnRhbCcsIGNsYXNzTmFtZSksIHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH0sXG4gICAgc2VyaWVzICYmIHNlcmllcy5tYXAoZnVuY3Rpb24gKHMsIGkpIHtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICBHcm91cCxcbiAgICAgICAgeyBrZXk6ICd2eC1iYXItc3RhY2staG9yaXpvbnRhbC0nICsgaSB9LFxuICAgICAgICBzLm1hcChmdW5jdGlvbiAoZCwgaWkpIHtcbiAgICAgICAgICB2YXIgYmFyV2lkdGggPSB4U2NhbGUoZFsxXSkgLSB4U2NhbGUoZFswXSk7XG4gICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQmFyLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgICBrZXk6ICdiYXItZ3JvdXAtYmFyLScgKyBpICsgJy0nICsgaWkgKyAnLScgKyBzLmtleSxcbiAgICAgICAgICAgIHg6IHhTY2FsZShkWzBdKSxcbiAgICAgICAgICAgIHk6IHlTY2FsZSh5KGQuZGF0YSkpLFxuICAgICAgICAgICAgd2lkdGg6IGJhcldpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBiYW5kd2lkdGgsXG4gICAgICAgICAgICBmaWxsOiB6U2NhbGUocy5rZXkpLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBiYW5kd2lkdGg6IGJhbmR3aWR0aCxcbiAgICAgICAgICAgICAgcGFkZGluZ0lubmVyOiBwYWRkaW5nSW5uZXIsXG4gICAgICAgICAgICAgIHBhZGRpbmdPdXRlcjogcGFkZGluZ091dGVyLFxuICAgICAgICAgICAgICBzdGVwOiBzdGVwLFxuICAgICAgICAgICAgICBrZXk6IHMua2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogZFswXSxcbiAgICAgICAgICAgICAgaGVpZ2h0OiBiYW5kd2lkdGgsXG4gICAgICAgICAgICAgIHdpZHRoOiBiYXJXaWR0aCxcbiAgICAgICAgICAgICAgeTogeShkLmRhdGEpLFxuICAgICAgICAgICAgICB5Rm9ybWF0dGVkOiBmb3JtYXQoeShkLmRhdGEpKSxcbiAgICAgICAgICAgICAgZGF0YTogZC5kYXRhXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVzdFByb3BzKSk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pXG4gICk7XG59XG5cbkJhclN0YWNrSG9yaXpvbnRhbC5wcm9wVHlwZXMgPSB7XG4gIGRhdGE6IFByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLFxuICB5OiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB4U2NhbGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHlTY2FsZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgelNjYWxlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBrZXlzOiBQcm9wVHlwZXMuYXJyYXkuaXNSZXF1aXJlZCxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICB0b3A6IFByb3BUeXBlcy5udW1iZXIsXG4gIGxlZnQ6IFByb3BUeXBlcy5udW1iZXJcbn07XG5cbnZhciBTVEFDS19PUkRFUlMgPSB7XG4gIGFzY2VuZGluZzogc3RhY2tPcmRlckFzY2VuZGluZyxcbiAgZGVzY2VuZGluZzogc3RhY2tPcmRlckRlc2NlbmRpbmcsXG4gIGluc2lkZW91dDogc3RhY2tPcmRlckluc2lkZU91dCxcbiAgbm9uZTogc3RhY2tPcmRlck5vbmUsXG4gIHJldmVyc2U6IHN0YWNrT3JkZXJSZXZlcnNlXG59O1xuXG52YXIgU1RBQ0tfT1JERVJfTkFNRVMgPSBPYmplY3Qua2V5cyhTVEFDS19PUkRFUlMpO1xuXG5mdW5jdGlvbiBzdGFja09yZGVyKG9yZGVyKSB7XG4gIHJldHVybiBTVEFDS19PUkRFUlNbb3JkZXJdIHx8IFNUQUNLX09SREVSUy5ub25lO1xufVxuXG52YXIgU1RBQ0tfT0ZGU0VUUyA9IHtcbiAgZXhwYW5kOiBzdGFja09mZnNldEV4cGFuZCxcbiAgZGl2ZXJnaW5nOiBzdGFja09mZnNldERpdmVyZ2luZyxcbiAgbm9uZTogc3RhY2tPZmZzZXROb25lLFxuICBzaWxob3VldHRlOiBzdGFja09mZnNldFNpbGhvdWV0dGUsXG4gIHdpZ2dsZTogc3RhY2tPZmZzZXRXaWdnbGVcbn07XG5cbnZhciBTVEFDS19PRkZTRVRfTkFNRVMgPSBPYmplY3Qua2V5cyhTVEFDS19PRkZTRVRTKTtcblxuZnVuY3Rpb24gc3RhY2tPZmZzZXQob2Zmc2V0KSB7XG4gIHJldHVybiBTVEFDS19PRkZTRVRTW29mZnNldF0gfHwgU1RBQ0tfT0ZGU0VUUy5ub25lO1xufVxuXG5mdW5jdGlvbiBTdGFjayhfcmVmKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIF9yZWYkdG9wID0gX3JlZi50b3AsXG4gICAgICB0b3AgPSBfcmVmJHRvcCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkdG9wLFxuICAgICAgX3JlZiRsZWZ0ID0gX3JlZi5sZWZ0LFxuICAgICAgbGVmdCA9IF9yZWYkbGVmdCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkbGVmdCxcbiAgICAgIGtleXMgPSBfcmVmLmtleXMsXG4gICAgICBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgY3VydmUgPSBfcmVmLmN1cnZlLFxuICAgICAgZGVmaW5lZCA9IF9yZWYuZGVmaW5lZCxcbiAgICAgIHggPSBfcmVmLngsXG4gICAgICB4MCA9IF9yZWYueDAsXG4gICAgICB4MSA9IF9yZWYueDEsXG4gICAgICB5MCA9IF9yZWYueTAsXG4gICAgICB5MSA9IF9yZWYueTEsXG4gICAgICB2YWx1ZSA9IF9yZWYudmFsdWUsXG4gICAgICBvcmRlciA9IF9yZWYub3JkZXIsXG4gICAgICBvZmZzZXQgPSBfcmVmLm9mZnNldCxcbiAgICAgIHJlbmRlciA9IF9yZWYucmVuZGVyLFxuICAgICAgX3JlZiRyZXZlcnNlID0gX3JlZi5yZXZlcnNlLFxuICAgICAgcmV2ZXJzZSA9IF9yZWYkcmV2ZXJzZSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJHJldmVyc2UsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2NsYXNzTmFtZScsICd0b3AnLCAnbGVmdCcsICdrZXlzJywgJ2RhdGEnLCAnY3VydmUnLCAnZGVmaW5lZCcsICd4JywgJ3gwJywgJ3gxJywgJ3kwJywgJ3kxJywgJ3ZhbHVlJywgJ29yZGVyJywgJ29mZnNldCcsICdyZW5kZXInLCAncmV2ZXJzZSddKTtcblxuICB2YXIgc3RhY2skJDEgPSBzdGFjaygpO1xuICBpZiAoa2V5cykgc3RhY2skJDEua2V5cyhrZXlzKTtcbiAgaWYgKHZhbHVlKSBzdGFjayQkMS52YWx1ZSh2YWx1ZSk7XG4gIGlmIChvcmRlcikgc3RhY2skJDEub3JkZXIoc3RhY2tPcmRlcihvcmRlcikpO1xuICBpZiAob2Zmc2V0KSBzdGFjayQkMS5vZmZzZXQoc3RhY2tPZmZzZXQob2Zmc2V0KSk7XG5cbiAgdmFyIHBhdGgkJDEgPSBhcmVhKCk7XG4gIGlmICh4KSBwYXRoJCQxLngoeCk7XG4gIGlmICh4MCkgcGF0aCQkMS54MCh4MCk7XG4gIGlmICh4MSkgcGF0aCQkMS54MSh4MSk7XG4gIGlmICh5MCkgcGF0aCQkMS55MCh5MCk7XG4gIGlmICh5MSkgcGF0aCQkMS55MSh5MSk7XG4gIGlmIChjdXJ2ZSkgcGF0aCQkMS5jdXJ2ZShjdXJ2ZSk7XG4gIGlmIChkZWZpbmVkKSBwYXRoJCQxLmRlZmluZWQoZGVmaW5lZCk7XG5cbiAgdmFyIHNlcmllc0RhdGEgPSBzdGFjayQkMShkYXRhKTtcbiAgaWYgKHJldmVyc2UpIHNlcmllc0RhdGEucmV2ZXJzZSgpO1xuXG4gIGlmIChyZW5kZXIpIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIEdyb3VwLFxuICAgIHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfSxcbiAgICByZW5kZXIoeyBzZXJpZXNEYXRhOiBzZXJpZXNEYXRhLCBwYXRoOiBwYXRoJCQxIH0pXG4gICk7XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgR3JvdXAsXG4gICAgeyB0b3A6IHRvcCwgbGVmdDogbGVmdCB9LFxuICAgIHNlcmllc0RhdGEubWFwKGZ1bmN0aW9uIChzZXJpZXMsIGkpIHtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgICAgICBjbGFzc05hbWU6IGN4KCd2eC1zdGFjaycsIGNsYXNzTmFtZSksXG4gICAgICAgIGtleTogJ3N0YWNrLScgKyBpICsgJy0nICsgKHNlcmllcy5rZXkgfHwgJycpLFxuICAgICAgICBkOiBwYXRoJCQxKHNlcmllcylcbiAgICAgIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIHtcbiAgICAgICAgZGF0dW06IHNlcmllc1tpXSxcbiAgICAgICAgaW5kZXg6IGksXG4gICAgICAgIHNlcmllczogc2VyaWVzXG4gICAgICB9KSkpO1xuICAgIH0pXG4gICk7XG59XG5cbnZhciBkZWdyZWVzVG9SYWRpYW5zID0gZnVuY3Rpb24gZGVncmVlc1RvUmFkaWFucyhkZWdyZWVzKSB7XG4gIHJldHVybiBNYXRoLlBJIC8gMTgwICogZGVncmVlcztcbn07XG5cbmZ1bmN0aW9uIHBhdGhIb3Jpem9udGFsRGlhZ29uYWwoX3JlZikge1xuICB2YXIgc291cmNlID0gX3JlZi5zb3VyY2UsXG4gICAgICB0YXJnZXQgPSBfcmVmLnRhcmdldCxcbiAgICAgIHggPSBfcmVmLngsXG4gICAgICB5ID0gX3JlZi55O1xuXG4gIHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBsaW5rID0gbGlua0hvcml6b250YWwoKTtcbiAgICBsaW5rLngoeCk7XG4gICAgbGluay55KHkpO1xuICAgIGxpbmsuc291cmNlKHNvdXJjZSk7XG4gICAgbGluay50YXJnZXQodGFyZ2V0KTtcbiAgICByZXR1cm4gbGluayhkYXRhKTtcbiAgfTtcbn1cblxuTGlua0hvcml6b250YWwucHJvcFR5cGVzID0ge1xuICBpbm5lclJlZjogUHJvcFR5cGVzLmZ1bmMsXG4gIHg6IFByb3BUeXBlcy5mdW5jLFxuICB5OiBQcm9wVHlwZXMuZnVuYyxcbiAgc291cmNlOiBQcm9wVHlwZXMuZnVuYyxcbiAgdGFyZ2V0OiBQcm9wVHlwZXMuZnVuYyxcbiAgcGF0aDogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIExpbmtIb3Jpem9udGFsKF9yZWYyKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmMi5jbGFzc05hbWUsXG4gICAgICBpbm5lclJlZiA9IF9yZWYyLmlubmVyUmVmLFxuICAgICAgZGF0YSA9IF9yZWYyLmRhdGEsXG4gICAgICBwYXRoJCQxID0gX3JlZjIucGF0aCxcbiAgICAgIF9yZWYyJHggPSBfcmVmMi54LFxuICAgICAgeCA9IF9yZWYyJHggPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueTtcbiAgfSA6IF9yZWYyJHgsXG4gICAgICBfcmVmMiR5ID0gX3JlZjIueSxcbiAgICAgIHkgPSBfcmVmMiR5ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLng7XG4gIH0gOiBfcmVmMiR5LFxuICAgICAgX3JlZjIkc291cmNlID0gX3JlZjIuc291cmNlLFxuICAgICAgc291cmNlID0gX3JlZjIkc291cmNlID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnNvdXJjZTtcbiAgfSA6IF9yZWYyJHNvdXJjZSxcbiAgICAgIF9yZWYyJHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgIHRhcmdldCA9IF9yZWYyJHRhcmdldCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC50YXJnZXQ7XG4gIH0gOiBfcmVmMiR0YXJnZXQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgWydjbGFzc05hbWUnLCAnaW5uZXJSZWYnLCAnZGF0YScsICdwYXRoJywgJ3gnLCAneScsICdzb3VyY2UnLCAndGFyZ2V0J10pO1xuXG4gIHBhdGgkJDEgPSBwYXRoJCQxIHx8IHBhdGhIb3Jpem9udGFsRGlhZ29uYWwoeyBzb3VyY2U6IHNvdXJjZSwgdGFyZ2V0OiB0YXJnZXQsIHg6IHgsIHk6IHkgfSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgIHJlZjogaW5uZXJSZWYsXG4gICAgY2xhc3NOYW1lOiBjeCgndngtbGluay1ob3Jpem9udGFsJywgY2xhc3NOYW1lKSxcbiAgICBkOiBwYXRoJCQxKGRhdGEpXG4gIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSk7XG59XG5cbmZ1bmN0aW9uIHBhdGhWZXJ0aWNhbERpYWdvbmFsKF9yZWYpIHtcbiAgdmFyIHNvdXJjZSA9IF9yZWYuc291cmNlLFxuICAgICAgdGFyZ2V0ID0gX3JlZi50YXJnZXQsXG4gICAgICB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueTtcblxuICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgbGluayA9IGxpbmtWZXJ0aWNhbCgpO1xuICAgIGxpbmsueCh4KTtcbiAgICBsaW5rLnkoeSk7XG4gICAgbGluay5zb3VyY2Uoc291cmNlKTtcbiAgICBsaW5rLnRhcmdldCh0YXJnZXQpO1xuICAgIHJldHVybiBsaW5rKGRhdGEpO1xuICB9O1xufVxuXG5MaW5rVmVydGljYWwucHJvcFR5cGVzID0ge1xuICBpbm5lclJlZjogUHJvcFR5cGVzLmZ1bmMsXG4gIHg6IFByb3BUeXBlcy5mdW5jLFxuICB5OiBQcm9wVHlwZXMuZnVuYyxcbiAgc291cmNlOiBQcm9wVHlwZXMuZnVuYyxcbiAgdGFyZ2V0OiBQcm9wVHlwZXMuZnVuYyxcbiAgcGF0aDogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIExpbmtWZXJ0aWNhbChfcmVmMikge1xuICB2YXIgY2xhc3NOYW1lID0gX3JlZjIuY2xhc3NOYW1lLFxuICAgICAgaW5uZXJSZWYgPSBfcmVmMi5pbm5lclJlZixcbiAgICAgIGRhdGEgPSBfcmVmMi5kYXRhLFxuICAgICAgcGF0aCQkMSA9IF9yZWYyLnBhdGgsXG4gICAgICBfcmVmMiR4ID0gX3JlZjIueCxcbiAgICAgIHggPSBfcmVmMiR4ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLng7XG4gIH0gOiBfcmVmMiR4LFxuICAgICAgX3JlZjIkeSA9IF9yZWYyLnksXG4gICAgICB5ID0gX3JlZjIkeSA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC55O1xuICB9IDogX3JlZjIkeSxcbiAgICAgIF9yZWYyJHNvdXJjZSA9IF9yZWYyLnNvdXJjZSxcbiAgICAgIHNvdXJjZSA9IF9yZWYyJHNvdXJjZSA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC5zb3VyY2U7XG4gIH0gOiBfcmVmMiRzb3VyY2UsXG4gICAgICBfcmVmMiR0YXJnZXQgPSBfcmVmMi50YXJnZXQsXG4gICAgICB0YXJnZXQgPSBfcmVmMiR0YXJnZXQgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQudGFyZ2V0O1xuICB9IDogX3JlZjIkdGFyZ2V0LFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjIsIFsnY2xhc3NOYW1lJywgJ2lubmVyUmVmJywgJ2RhdGEnLCAncGF0aCcsICd4JywgJ3knLCAnc291cmNlJywgJ3RhcmdldCddKTtcblxuICBwYXRoJCQxID0gcGF0aCQkMSB8fCBwYXRoVmVydGljYWxEaWFnb25hbCh7IHNvdXJjZTogc291cmNlLCB0YXJnZXQ6IHRhcmdldCwgeDogeCwgeTogeSB9KTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBpbm5lclJlZixcbiAgICBjbGFzc05hbWU6IGN4KCd2eC1saW5rLXZlcnRpY2FsJywgY2xhc3NOYW1lKSxcbiAgICBkOiBwYXRoJCQxKGRhdGEpXG4gIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSk7XG59XG5cbmZ1bmN0aW9uIHBhdGhSYWRpYWxEaWFnb25hbChfcmVmKSB7XG4gIHZhciBzb3VyY2UgPSBfcmVmLnNvdXJjZSxcbiAgICAgIHRhcmdldCA9IF9yZWYudGFyZ2V0LFxuICAgICAgYW5nbGUgPSBfcmVmLmFuZ2xlLFxuICAgICAgcmFkaXVzID0gX3JlZi5yYWRpdXM7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIGxpbmsgPSBsaW5rUmFkaWFsKCk7XG4gICAgbGluay5hbmdsZShhbmdsZSk7XG4gICAgbGluay5yYWRpdXMocmFkaXVzKTtcbiAgICBsaW5rLnNvdXJjZShzb3VyY2UpO1xuICAgIGxpbmsudGFyZ2V0KHRhcmdldCk7XG4gICAgcmV0dXJuIGxpbmsoZGF0YSk7XG4gIH07XG59XG5cbkxpbmtSYWRpYWwucHJvcFR5cGVzID0ge1xuICBpbm5lclJlZjogUHJvcFR5cGVzLmZ1bmMsXG4gIGFuZ2xlOiBQcm9wVHlwZXMuZnVuYyxcbiAgcmFkaXVzOiBQcm9wVHlwZXMuZnVuYyxcbiAgc291cmNlOiBQcm9wVHlwZXMuZnVuYyxcbiAgdGFyZ2V0OiBQcm9wVHlwZXMuZnVuYyxcbiAgcGF0aDogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIExpbmtSYWRpYWwoX3JlZjIpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYyLmNsYXNzTmFtZSxcbiAgICAgIGlubmVyUmVmID0gX3JlZjIuaW5uZXJSZWYsXG4gICAgICBkYXRhID0gX3JlZjIuZGF0YSxcbiAgICAgIHBhdGgkJDEgPSBfcmVmMi5wYXRoLFxuICAgICAgX3JlZjIkYW5nbGUgPSBfcmVmMi5hbmdsZSxcbiAgICAgIGFuZ2xlID0gX3JlZjIkYW5nbGUgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueDtcbiAgfSA6IF9yZWYyJGFuZ2xlLFxuICAgICAgX3JlZjIkcmFkaXVzID0gX3JlZjIucmFkaXVzLFxuICAgICAgcmFkaXVzID0gX3JlZjIkcmFkaXVzID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnk7XG4gIH0gOiBfcmVmMiRyYWRpdXMsXG4gICAgICBfcmVmMiRzb3VyY2UgPSBfcmVmMi5zb3VyY2UsXG4gICAgICBzb3VyY2UgPSBfcmVmMiRzb3VyY2UgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQuc291cmNlO1xuICB9IDogX3JlZjIkc291cmNlLFxuICAgICAgX3JlZjIkdGFyZ2V0ID0gX3JlZjIudGFyZ2V0LFxuICAgICAgdGFyZ2V0ID0gX3JlZjIkdGFyZ2V0ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnRhcmdldDtcbiAgfSA6IF9yZWYyJHRhcmdldCxcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYyLCBbJ2NsYXNzTmFtZScsICdpbm5lclJlZicsICdkYXRhJywgJ3BhdGgnLCAnYW5nbGUnLCAncmFkaXVzJywgJ3NvdXJjZScsICd0YXJnZXQnXSk7XG5cbiAgcGF0aCQkMSA9IHBhdGgkJDEgfHwgcGF0aFJhZGlhbERpYWdvbmFsKHsgc291cmNlOiBzb3VyY2UsIHRhcmdldDogdGFyZ2V0LCBhbmdsZTogYW5nbGUsIHJhZGl1czogcmFkaXVzIH0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgncGF0aCcsIF9leHRlbmRzKHtcbiAgICByZWY6IGlubmVyUmVmLFxuICAgIGNsYXNzTmFtZTogY3goJ3Z4LWxpbmstcmFkaXVzJywgY2xhc3NOYW1lKSxcbiAgICBkOiBwYXRoJCQxKGRhdGEpXG4gIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSk7XG59XG5cbmZ1bmN0aW9uIHBhdGhIb3Jpem9udGFsQ3VydmUoX3JlZikge1xuICB2YXIgc291cmNlID0gX3JlZi5zb3VyY2UsXG4gICAgICB0YXJnZXQgPSBfcmVmLnRhcmdldCxcbiAgICAgIHggPSBfcmVmLngsXG4gICAgICB5ID0gX3JlZi55LFxuICAgICAgcGVyY2VudCA9IF9yZWYucGVyY2VudDtcblxuICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgc291cmNlRGF0YSA9IHNvdXJjZShkYXRhKTtcbiAgICB2YXIgdGFyZ2V0RGF0YSA9IHRhcmdldChkYXRhKTtcblxuICAgIHZhciBzeCA9IHgoc291cmNlRGF0YSk7XG4gICAgdmFyIHN5ID0geShzb3VyY2VEYXRhKTtcbiAgICB2YXIgdHggPSB4KHRhcmdldERhdGEpO1xuICAgIHZhciB0eSA9IHkodGFyZ2V0RGF0YSk7XG5cbiAgICB2YXIgZHggPSB0eCAtIHN4O1xuICAgIHZhciBkeSA9IHR5IC0gc3k7XG4gICAgdmFyIGl4ID0gcGVyY2VudCAqIChkeCArIGR5KTtcbiAgICB2YXIgaXkgPSBwZXJjZW50ICogKGR5IC0gZHgpO1xuXG4gICAgdmFyIHBhdGgkJDEgPSBwYXRoKCk7XG4gICAgcGF0aCQkMS5tb3ZlVG8oc3gsIHN5KTtcbiAgICBwYXRoJCQxLmJlemllckN1cnZlVG8oc3ggKyBpeCwgc3kgKyBpeSwgdHggKyBpeSwgdHkgLSBpeCwgdHgsIHR5KTtcblxuICAgIHJldHVybiBwYXRoJCQxLnRvU3RyaW5nKCk7XG4gIH07XG59XG5cbkxpbmtIb3Jpem9udGFsQ3VydmUucHJvcFR5cGVzID0ge1xuICBpbm5lclJlZjogUHJvcFR5cGVzLmZ1bmMsXG4gIHBlcmNlbnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIHg6IFByb3BUeXBlcy5mdW5jLFxuICB5OiBQcm9wVHlwZXMuZnVuYyxcbiAgc291cmNlOiBQcm9wVHlwZXMuZnVuYyxcbiAgdGFyZ2V0OiBQcm9wVHlwZXMuZnVuYyxcbiAgcGF0aDogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIExpbmtIb3Jpem9udGFsQ3VydmUoX3JlZjIpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYyLmNsYXNzTmFtZSxcbiAgICAgIGlubmVyUmVmID0gX3JlZjIuaW5uZXJSZWYsXG4gICAgICBkYXRhID0gX3JlZjIuZGF0YSxcbiAgICAgIHBhdGgkJDEgPSBfcmVmMi5wYXRoLFxuICAgICAgX3JlZjIkeCA9IF9yZWYyLngsXG4gICAgICB4ID0gX3JlZjIkeCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC55O1xuICB9IDogX3JlZjIkeCxcbiAgICAgIF9yZWYyJHkgPSBfcmVmMi55LFxuICAgICAgeSA9IF9yZWYyJHkgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueDtcbiAgfSA6IF9yZWYyJHksXG4gICAgICBfcmVmMiRzb3VyY2UgPSBfcmVmMi5zb3VyY2UsXG4gICAgICBzb3VyY2UgPSBfcmVmMiRzb3VyY2UgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQuc291cmNlO1xuICB9IDogX3JlZjIkc291cmNlLFxuICAgICAgX3JlZjIkdGFyZ2V0ID0gX3JlZjIudGFyZ2V0LFxuICAgICAgdGFyZ2V0ID0gX3JlZjIkdGFyZ2V0ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnRhcmdldDtcbiAgfSA6IF9yZWYyJHRhcmdldCxcbiAgICAgIF9yZWYyJHBlcmNlbnQgPSBfcmVmMi5wZXJjZW50LFxuICAgICAgcGVyY2VudCA9IF9yZWYyJHBlcmNlbnQgPT09IHVuZGVmaW5lZCA/IDAuMiA6IF9yZWYyJHBlcmNlbnQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgWydjbGFzc05hbWUnLCAnaW5uZXJSZWYnLCAnZGF0YScsICdwYXRoJywgJ3gnLCAneScsICdzb3VyY2UnLCAndGFyZ2V0JywgJ3BlcmNlbnQnXSk7XG5cbiAgcGF0aCQkMSA9IHBhdGgkJDEgfHwgcGF0aEhvcml6b250YWxDdXJ2ZSh7IHNvdXJjZTogc291cmNlLCB0YXJnZXQ6IHRhcmdldCwgeDogeCwgeTogeSwgcGVyY2VudDogcGVyY2VudCB9KTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBpbm5lclJlZixcbiAgICBjbGFzc05hbWU6IGN4KCd2eC1saW5rJywgY2xhc3NOYW1lKSxcbiAgICBkOiBwYXRoJCQxKGRhdGEpXG4gIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSk7XG59XG5cbmZ1bmN0aW9uIHBhdGhWZXJ0aWNhbEN1cnZlKF9yZWYpIHtcbiAgdmFyIHNvdXJjZSA9IF9yZWYuc291cmNlLFxuICAgICAgdGFyZ2V0ID0gX3JlZi50YXJnZXQsXG4gICAgICB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueSxcbiAgICAgIHBlcmNlbnQgPSBfcmVmLnBlcmNlbnQ7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIHNvdXJjZURhdGEgPSBzb3VyY2UoZGF0YSk7XG4gICAgdmFyIHRhcmdldERhdGEgPSB0YXJnZXQoZGF0YSk7XG5cbiAgICB2YXIgc3ggPSB4KHNvdXJjZURhdGEpO1xuICAgIHZhciBzeSA9IHkoc291cmNlRGF0YSk7XG4gICAgdmFyIHR4ID0geCh0YXJnZXREYXRhKTtcbiAgICB2YXIgdHkgPSB5KHRhcmdldERhdGEpO1xuXG4gICAgdmFyIGR4ID0gdHggLSBzeDtcbiAgICB2YXIgZHkgPSB0eSAtIHN5O1xuICAgIHZhciBpeCA9IHBlcmNlbnQgKiAoZHggKyBkeSk7XG4gICAgdmFyIGl5ID0gcGVyY2VudCAqIChkeSAtIGR4KTtcblxuICAgIHZhciBwYXRoJCQxID0gcGF0aCgpO1xuICAgIHBhdGgkJDEubW92ZVRvKHN4LCBzeSk7XG4gICAgcGF0aCQkMS5iZXppZXJDdXJ2ZVRvKHN4ICsgaXgsIHN5ICsgaXksIHR4ICsgaXksIHR5IC0gaXgsIHR4LCB0eSk7XG5cbiAgICByZXR1cm4gcGF0aCQkMS50b1N0cmluZygpO1xuICB9O1xufVxuXG5MaW5rVmVydGljYWxDdXJ2ZS5wcm9wVHlwZXMgPSB7XG4gIGlubmVyUmVmOiBQcm9wVHlwZXMuZnVuYyxcbiAgcGVyY2VudDogUHJvcFR5cGVzLm51bWJlcixcbiAgeDogUHJvcFR5cGVzLmZ1bmMsXG4gIHk6IFByb3BUeXBlcy5mdW5jLFxuICBzb3VyY2U6IFByb3BUeXBlcy5mdW5jLFxuICB0YXJnZXQ6IFByb3BUeXBlcy5mdW5jLFxuICBwYXRoOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuZnVuY3Rpb24gTGlua1ZlcnRpY2FsQ3VydmUoX3JlZjIpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYyLmNsYXNzTmFtZSxcbiAgICAgIGlubmVyUmVmID0gX3JlZjIuaW5uZXJSZWYsXG4gICAgICBkYXRhID0gX3JlZjIuZGF0YSxcbiAgICAgIHBhdGgkJDEgPSBfcmVmMi5wYXRoLFxuICAgICAgX3JlZjIkeCA9IF9yZWYyLngsXG4gICAgICB4ID0gX3JlZjIkeCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC54O1xuICB9IDogX3JlZjIkeCxcbiAgICAgIF9yZWYyJHkgPSBfcmVmMi55LFxuICAgICAgeSA9IF9yZWYyJHkgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueTtcbiAgfSA6IF9yZWYyJHksXG4gICAgICBfcmVmMiRzb3VyY2UgPSBfcmVmMi5zb3VyY2UsXG4gICAgICBzb3VyY2UgPSBfcmVmMiRzb3VyY2UgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQuc291cmNlO1xuICB9IDogX3JlZjIkc291cmNlLFxuICAgICAgX3JlZjIkdGFyZ2V0ID0gX3JlZjIudGFyZ2V0LFxuICAgICAgdGFyZ2V0ID0gX3JlZjIkdGFyZ2V0ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnRhcmdldDtcbiAgfSA6IF9yZWYyJHRhcmdldCxcbiAgICAgIF9yZWYyJHBlcmNlbnQgPSBfcmVmMi5wZXJjZW50LFxuICAgICAgcGVyY2VudCA9IF9yZWYyJHBlcmNlbnQgPT09IHVuZGVmaW5lZCA/IDAuMiA6IF9yZWYyJHBlcmNlbnQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgWydjbGFzc05hbWUnLCAnaW5uZXJSZWYnLCAnZGF0YScsICdwYXRoJywgJ3gnLCAneScsICdzb3VyY2UnLCAndGFyZ2V0JywgJ3BlcmNlbnQnXSk7XG5cbiAgcGF0aCQkMSA9IHBhdGgkJDEgfHwgcGF0aFZlcnRpY2FsQ3VydmUoeyBzb3VyY2U6IHNvdXJjZSwgdGFyZ2V0OiB0YXJnZXQsIHg6IHgsIHk6IHksIHBlcmNlbnQ6IHBlcmNlbnQgfSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgIHJlZjogaW5uZXJSZWYsXG4gICAgY2xhc3NOYW1lOiBjeCgndngtbGluaycsIGNsYXNzTmFtZSksXG4gICAgZDogcGF0aCQkMShkYXRhKVxuICB9LCBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzLCBkYXRhKSkpO1xufVxuXG5mdW5jdGlvbiBwYXRoUmFkaWFsQ3VydmUoX3JlZikge1xuICB2YXIgc291cmNlID0gX3JlZi5zb3VyY2UsXG4gICAgICB0YXJnZXQgPSBfcmVmLnRhcmdldCxcbiAgICAgIHggPSBfcmVmLngsXG4gICAgICB5ID0gX3JlZi55LFxuICAgICAgcGVyY2VudCA9IF9yZWYucGVyY2VudDtcblxuICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgc291cmNlRGF0YSA9IHNvdXJjZShkYXRhKTtcbiAgICB2YXIgdGFyZ2V0RGF0YSA9IHRhcmdldChkYXRhKTtcblxuICAgIHZhciBzYSA9IHgoc291cmNlRGF0YSkgLSBNYXRoLlBJIC8gMjtcbiAgICB2YXIgc3IgPSB5KHNvdXJjZURhdGEpO1xuICAgIHZhciB0YSA9IHgodGFyZ2V0RGF0YSkgLSBNYXRoLlBJIC8gMjtcbiAgICB2YXIgdHIgPSB5KHRhcmdldERhdGEpO1xuXG4gICAgdmFyIHNjID0gTWF0aC5jb3Moc2EpO1xuICAgIHZhciBzcyA9IE1hdGguc2luKHNhKTtcbiAgICB2YXIgdGMgPSBNYXRoLmNvcyh0YSk7XG4gICAgdmFyIHRzID0gTWF0aC5zaW4odGEpO1xuXG4gICAgdmFyIHN4ID0gc3IgKiBzYztcbiAgICB2YXIgc3kgPSBzciAqIHNzO1xuICAgIHZhciB0eCA9IHRyICogdGM7XG4gICAgdmFyIHR5ID0gdHIgKiB0cztcblxuICAgIHZhciBkeCA9IHR4IC0gc3g7XG4gICAgdmFyIGR5ID0gdHkgLSBzeTtcbiAgICB2YXIgaXggPSBwZXJjZW50ICogKGR4ICsgZHkpO1xuICAgIHZhciBpeSA9IHBlcmNlbnQgKiAoZHkgLSBkeCk7XG5cbiAgICB2YXIgcGF0aCQkMSA9IHBhdGgoKTtcbiAgICBwYXRoJCQxLm1vdmVUbyhzeCwgc3kpO1xuICAgIHBhdGgkJDEuYmV6aWVyQ3VydmVUbyhzeCArIGl4LCBzeSArIGl5LCB0eCArIGl5LCB0eSAtIGl4LCB0eCwgdHkpO1xuXG4gICAgcmV0dXJuIHBhdGgkJDEudG9TdHJpbmcoKTtcbiAgfTtcbn1cblxuTGlua1JhZGlhbEN1cnZlLnByb3BUeXBlcyA9IHtcbiAgaW5uZXJSZWY6IFByb3BUeXBlcy5mdW5jLFxuICBwZXJjZW50OiBQcm9wVHlwZXMubnVtYmVyLFxuICB4OiBQcm9wVHlwZXMuZnVuYyxcbiAgeTogUHJvcFR5cGVzLmZ1bmMsXG4gIHNvdXJjZTogUHJvcFR5cGVzLmZ1bmMsXG4gIHRhcmdldDogUHJvcFR5cGVzLmZ1bmMsXG4gIHBhdGg6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5mdW5jdGlvbiBMaW5rUmFkaWFsQ3VydmUoX3JlZjIpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYyLmNsYXNzTmFtZSxcbiAgICAgIGlubmVyUmVmID0gX3JlZjIuaW5uZXJSZWYsXG4gICAgICBkYXRhID0gX3JlZjIuZGF0YSxcbiAgICAgIHBhdGgkJDEgPSBfcmVmMi5wYXRoLFxuICAgICAgX3JlZjIkeCA9IF9yZWYyLngsXG4gICAgICB4ID0gX3JlZjIkeCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC54O1xuICB9IDogX3JlZjIkeCxcbiAgICAgIF9yZWYyJHkgPSBfcmVmMi55LFxuICAgICAgeSA9IF9yZWYyJHkgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueTtcbiAgfSA6IF9yZWYyJHksXG4gICAgICBfcmVmMiRzb3VyY2UgPSBfcmVmMi5zb3VyY2UsXG4gICAgICBzb3VyY2UgPSBfcmVmMiRzb3VyY2UgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQuc291cmNlO1xuICB9IDogX3JlZjIkc291cmNlLFxuICAgICAgX3JlZjIkdGFyZ2V0ID0gX3JlZjIudGFyZ2V0LFxuICAgICAgdGFyZ2V0ID0gX3JlZjIkdGFyZ2V0ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnRhcmdldDtcbiAgfSA6IF9yZWYyJHRhcmdldCxcbiAgICAgIF9yZWYyJHBlcmNlbnQgPSBfcmVmMi5wZXJjZW50LFxuICAgICAgcGVyY2VudCA9IF9yZWYyJHBlcmNlbnQgPT09IHVuZGVmaW5lZCA/IDAuMiA6IF9yZWYyJHBlcmNlbnQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgWydjbGFzc05hbWUnLCAnaW5uZXJSZWYnLCAnZGF0YScsICdwYXRoJywgJ3gnLCAneScsICdzb3VyY2UnLCAndGFyZ2V0JywgJ3BlcmNlbnQnXSk7XG5cbiAgcGF0aCQkMSA9IHBhdGgkJDEgfHwgcGF0aFJhZGlhbEN1cnZlKHsgc291cmNlOiBzb3VyY2UsIHRhcmdldDogdGFyZ2V0LCB4OiB4LCB5OiB5LCBwZXJjZW50OiBwZXJjZW50IH0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgncGF0aCcsIF9leHRlbmRzKHtcbiAgICByZWY6IGlubmVyUmVmLFxuICAgIGNsYXNzTmFtZTogY3goJ3Z4LWxpbmsnLCBjbGFzc05hbWUpLFxuICAgIGQ6IHBhdGgkJDEoZGF0YSlcbiAgfSwgYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcywgZGF0YSkpKTtcbn1cblxuZnVuY3Rpb24gcGF0aEhvcml6b250YWxMaW5lKF9yZWYpIHtcbiAgdmFyIHNvdXJjZSA9IF9yZWYuc291cmNlLFxuICAgICAgdGFyZ2V0ID0gX3JlZi50YXJnZXQsXG4gICAgICB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueTtcblxuICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgc291cmNlRGF0YSA9IHNvdXJjZShkYXRhKTtcbiAgICB2YXIgdGFyZ2V0RGF0YSA9IHRhcmdldChkYXRhKTtcblxuICAgIHZhciBzeCA9IHgoc291cmNlRGF0YSk7XG4gICAgdmFyIHN5ID0geShzb3VyY2VEYXRhKTtcbiAgICB2YXIgdHggPSB4KHRhcmdldERhdGEpO1xuICAgIHZhciB0eSA9IHkodGFyZ2V0RGF0YSk7XG5cbiAgICB2YXIgcGF0aCQkMSA9IHBhdGgoKTtcbiAgICBwYXRoJCQxLm1vdmVUbyhzeCwgc3kpO1xuICAgIHBhdGgkJDEubGluZVRvKHR4LCB0eSk7XG5cbiAgICByZXR1cm4gcGF0aCQkMS50b1N0cmluZygpO1xuICB9O1xufVxuXG5MaW5rSG9yaXpvbnRhbExpbmUucHJvcFR5cGVzID0ge1xuICBpbm5lclJlZjogUHJvcFR5cGVzLmZ1bmMsXG4gIHBhdGg6IFByb3BUeXBlcy5mdW5jLFxuICB4OiBQcm9wVHlwZXMuZnVuYyxcbiAgeTogUHJvcFR5cGVzLmZ1bmMsXG4gIHNvdXJjZTogUHJvcFR5cGVzLmZ1bmMsXG4gIHRhcmdldDogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIExpbmtIb3Jpem9udGFsTGluZShfcmVmMikge1xuICB2YXIgY2xhc3NOYW1lID0gX3JlZjIuY2xhc3NOYW1lLFxuICAgICAgaW5uZXJSZWYgPSBfcmVmMi5pbm5lclJlZixcbiAgICAgIGRhdGEgPSBfcmVmMi5kYXRhLFxuICAgICAgcGF0aCQkMSA9IF9yZWYyLnBhdGgsXG4gICAgICBfcmVmMiR4ID0gX3JlZjIueCxcbiAgICAgIHggPSBfcmVmMiR4ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnk7XG4gIH0gOiBfcmVmMiR4LFxuICAgICAgX3JlZjIkeSA9IF9yZWYyLnksXG4gICAgICB5ID0gX3JlZjIkeSA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC54O1xuICB9IDogX3JlZjIkeSxcbiAgICAgIF9yZWYyJHNvdXJjZSA9IF9yZWYyLnNvdXJjZSxcbiAgICAgIHNvdXJjZSA9IF9yZWYyJHNvdXJjZSA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC5zb3VyY2U7XG4gIH0gOiBfcmVmMiRzb3VyY2UsXG4gICAgICBfcmVmMiR0YXJnZXQgPSBfcmVmMi50YXJnZXQsXG4gICAgICB0YXJnZXQgPSBfcmVmMiR0YXJnZXQgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQudGFyZ2V0O1xuICB9IDogX3JlZjIkdGFyZ2V0LFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjIsIFsnY2xhc3NOYW1lJywgJ2lubmVyUmVmJywgJ2RhdGEnLCAncGF0aCcsICd4JywgJ3knLCAnc291cmNlJywgJ3RhcmdldCddKTtcblxuICBwYXRoJCQxID0gcGF0aCQkMSB8fCBwYXRoSG9yaXpvbnRhbExpbmUoeyBzb3VyY2U6IHNvdXJjZSwgdGFyZ2V0OiB0YXJnZXQsIHg6IHgsIHk6IHkgfSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgIHJlZjogaW5uZXJSZWYsXG4gICAgY2xhc3NOYW1lOiBjeCgndngtbGluaycsIGNsYXNzTmFtZSksXG4gICAgZDogcGF0aCQkMShkYXRhKVxuICB9LCBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzLCBkYXRhKSkpO1xufVxuXG5mdW5jdGlvbiBwYXRoVmVydGljYWxMaW5lKF9yZWYpIHtcbiAgdmFyIHNvdXJjZSA9IF9yZWYuc291cmNlLFxuICAgICAgdGFyZ2V0ID0gX3JlZi50YXJnZXQsXG4gICAgICB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueTtcblxuICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgc291cmNlRGF0YSA9IHNvdXJjZShkYXRhKTtcbiAgICB2YXIgdGFyZ2V0RGF0YSA9IHRhcmdldChkYXRhKTtcblxuICAgIHZhciBzeCA9IHgoc291cmNlRGF0YSk7XG4gICAgdmFyIHN5ID0geShzb3VyY2VEYXRhKTtcbiAgICB2YXIgdHggPSB4KHRhcmdldERhdGEpO1xuICAgIHZhciB0eSA9IHkodGFyZ2V0RGF0YSk7XG5cbiAgICB2YXIgcGF0aCQkMSA9IHBhdGgoKTtcbiAgICBwYXRoJCQxLm1vdmVUbyhzeCwgc3kpO1xuICAgIHBhdGgkJDEubGluZVRvKHR4LCB0eSk7XG5cbiAgICByZXR1cm4gcGF0aCQkMS50b1N0cmluZygpO1xuICB9O1xufVxuXG5MaW5rVmVydGljYWxMaW5lLnByb3BUeXBlcyA9IHtcbiAgaW5uZXJSZWY6IFByb3BUeXBlcy5mdW5jLFxuICBwYXRoOiBQcm9wVHlwZXMuZnVuYyxcbiAgeDogUHJvcFR5cGVzLmZ1bmMsXG4gIHk6IFByb3BUeXBlcy5mdW5jLFxuICBzb3VyY2U6IFByb3BUeXBlcy5mdW5jLFxuICB0YXJnZXQ6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5mdW5jdGlvbiBMaW5rVmVydGljYWxMaW5lKF9yZWYyKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmMi5jbGFzc05hbWUsXG4gICAgICBpbm5lclJlZiA9IF9yZWYyLmlubmVyUmVmLFxuICAgICAgZGF0YSA9IF9yZWYyLmRhdGEsXG4gICAgICBwYXRoJCQxID0gX3JlZjIucGF0aCxcbiAgICAgIF9yZWYyJHggPSBfcmVmMi54LFxuICAgICAgeCA9IF9yZWYyJHggPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueDtcbiAgfSA6IF9yZWYyJHgsXG4gICAgICBfcmVmMiR5ID0gX3JlZjIueSxcbiAgICAgIHkgPSBfcmVmMiR5ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnk7XG4gIH0gOiBfcmVmMiR5LFxuICAgICAgX3JlZjIkc291cmNlID0gX3JlZjIuc291cmNlLFxuICAgICAgc291cmNlID0gX3JlZjIkc291cmNlID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnNvdXJjZTtcbiAgfSA6IF9yZWYyJHNvdXJjZSxcbiAgICAgIF9yZWYyJHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgIHRhcmdldCA9IF9yZWYyJHRhcmdldCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC50YXJnZXQ7XG4gIH0gOiBfcmVmMiR0YXJnZXQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgWydjbGFzc05hbWUnLCAnaW5uZXJSZWYnLCAnZGF0YScsICdwYXRoJywgJ3gnLCAneScsICdzb3VyY2UnLCAndGFyZ2V0J10pO1xuXG4gIHBhdGgkJDEgPSBwYXRoJCQxIHx8IHBhdGhWZXJ0aWNhbExpbmUoeyBzb3VyY2U6IHNvdXJjZSwgdGFyZ2V0OiB0YXJnZXQsIHg6IHgsIHk6IHkgfSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgIHJlZjogaW5uZXJSZWYsXG4gICAgY2xhc3NOYW1lOiBjeCgndngtbGluaycsIGNsYXNzTmFtZSksXG4gICAgZDogcGF0aCQkMShkYXRhKVxuICB9LCBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzLCBkYXRhKSkpO1xufVxuXG5mdW5jdGlvbiBwYXRoUmFkaWFsTGluZShfcmVmKSB7XG4gIHZhciBzb3VyY2UgPSBfcmVmLnNvdXJjZSxcbiAgICAgIHRhcmdldCA9IF9yZWYudGFyZ2V0LFxuICAgICAgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIHNvdXJjZURhdGEgPSBzb3VyY2UoZGF0YSk7XG4gICAgdmFyIHRhcmdldERhdGEgPSB0YXJnZXQoZGF0YSk7XG5cbiAgICB2YXIgc2EgPSB4KHNvdXJjZURhdGEpIC0gTWF0aC5QSSAvIDI7XG4gICAgdmFyIHNyID0geShzb3VyY2VEYXRhKTtcbiAgICB2YXIgdGEgPSB4KHRhcmdldERhdGEpIC0gTWF0aC5QSSAvIDI7XG4gICAgdmFyIHRyID0geSh0YXJnZXREYXRhKTtcblxuICAgIHZhciBzYyA9IE1hdGguY29zKHNhKTtcbiAgICB2YXIgc3MgPSBNYXRoLnNpbihzYSk7XG4gICAgdmFyIHRjID0gTWF0aC5jb3ModGEpO1xuICAgIHZhciB0cyA9IE1hdGguc2luKHRhKTtcblxuICAgIHZhciBwYXRoJCQxID0gcGF0aCgpO1xuICAgIHBhdGgkJDEubW92ZVRvKHNyICogc2MsIHNyICogc3MpO1xuICAgIHBhdGgkJDEubGluZVRvKHRyICogdGMsIHRyICogdHMpO1xuXG4gICAgcmV0dXJuIHBhdGgkJDEudG9TdHJpbmcoKTtcbiAgfTtcbn1cblxuTGlua1JhZGlhbFN0ZXAucHJvcFR5cGVzID0ge1xuICBpbm5lclJlZjogUHJvcFR5cGVzLmZ1bmMsXG4gIHBhdGg6IFByb3BUeXBlcy5mdW5jLFxuICB4OiBQcm9wVHlwZXMuZnVuYyxcbiAgeTogUHJvcFR5cGVzLmZ1bmMsXG4gIHNvdXJjZTogUHJvcFR5cGVzLmZ1bmMsXG4gIHRhcmdldDogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIExpbmtSYWRpYWxTdGVwKF9yZWYyKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmMi5jbGFzc05hbWUsXG4gICAgICBpbm5lclJlZiA9IF9yZWYyLmlubmVyUmVmLFxuICAgICAgZGF0YSA9IF9yZWYyLmRhdGEsXG4gICAgICBwYXRoJCQxID0gX3JlZjIucGF0aCxcbiAgICAgIF9yZWYyJHggPSBfcmVmMi54LFxuICAgICAgeCA9IF9yZWYyJHggPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueDtcbiAgfSA6IF9yZWYyJHgsXG4gICAgICBfcmVmMiR5ID0gX3JlZjIueSxcbiAgICAgIHkgPSBfcmVmMiR5ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnk7XG4gIH0gOiBfcmVmMiR5LFxuICAgICAgX3JlZjIkc291cmNlID0gX3JlZjIuc291cmNlLFxuICAgICAgc291cmNlID0gX3JlZjIkc291cmNlID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnNvdXJjZTtcbiAgfSA6IF9yZWYyJHNvdXJjZSxcbiAgICAgIF9yZWYyJHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgIHRhcmdldCA9IF9yZWYyJHRhcmdldCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC50YXJnZXQ7XG4gIH0gOiBfcmVmMiR0YXJnZXQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgWydjbGFzc05hbWUnLCAnaW5uZXJSZWYnLCAnZGF0YScsICdwYXRoJywgJ3gnLCAneScsICdzb3VyY2UnLCAndGFyZ2V0J10pO1xuXG4gIHBhdGgkJDEgPSBwYXRoJCQxIHx8IHBhdGhSYWRpYWxMaW5lKHsgc291cmNlOiBzb3VyY2UsIHRhcmdldDogdGFyZ2V0LCB4OiB4LCB5OiB5IH0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgncGF0aCcsIF9leHRlbmRzKHtcbiAgICByZWY6IGlubmVyUmVmLFxuICAgIGNsYXNzTmFtZTogY3goJ3Z4LWxpbmsnLCBjbGFzc05hbWUpLFxuICAgIGQ6IHBhdGgkJDEoZGF0YSlcbiAgfSwgYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcywgZGF0YSkpKTtcbn1cblxuZnVuY3Rpb24gcGF0aEhvcml6b250YWxTdGVwKF9yZWYpIHtcbiAgdmFyIHNvdXJjZSA9IF9yZWYuc291cmNlLFxuICAgICAgdGFyZ2V0ID0gX3JlZi50YXJnZXQsXG4gICAgICB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueSxcbiAgICAgIHBlcmNlbnQgPSBfcmVmLnBlcmNlbnQ7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIHNvdXJjZURhdGEgPSBzb3VyY2UoZGF0YSk7XG4gICAgdmFyIHRhcmdldERhdGEgPSB0YXJnZXQoZGF0YSk7XG5cbiAgICB2YXIgc3ggPSB4KHNvdXJjZURhdGEpO1xuICAgIHZhciBzeSA9IHkoc291cmNlRGF0YSk7XG4gICAgdmFyIHR4ID0geCh0YXJnZXREYXRhKTtcbiAgICB2YXIgdHkgPSB5KHRhcmdldERhdGEpO1xuXG4gICAgdmFyIHBhdGgkJDEgPSBwYXRoKCk7XG4gICAgcGF0aCQkMS5tb3ZlVG8oc3gsIHN5KTtcbiAgICBwYXRoJCQxLmxpbmVUbyhzeCArICh0eCAtIHN4KSAqIHBlcmNlbnQsIHN5KTtcbiAgICBwYXRoJCQxLmxpbmVUbyhzeCArICh0eCAtIHN4KSAqIHBlcmNlbnQsIHR5KTtcbiAgICBwYXRoJCQxLmxpbmVUbyh0eCwgdHkpO1xuXG4gICAgcmV0dXJuIHBhdGgkJDEudG9TdHJpbmcoKTtcbiAgfTtcbn1cblxuTGlua0hvcml6b250YWxTdGVwLnByb3BUeXBlcyA9IHtcbiAgaW5uZXJSZWY6IFByb3BUeXBlcy5mdW5jLFxuICBwZXJjZW50OiBQcm9wVHlwZXMubnVtYmVyLFxuICB4OiBQcm9wVHlwZXMuZnVuYyxcbiAgeTogUHJvcFR5cGVzLmZ1bmMsXG4gIHNvdXJjZTogUHJvcFR5cGVzLmZ1bmMsXG4gIHRhcmdldDogUHJvcFR5cGVzLmZ1bmMsXG4gIHBhdGg6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5mdW5jdGlvbiBMaW5rSG9yaXpvbnRhbFN0ZXAoX3JlZjIpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYyLmNsYXNzTmFtZSxcbiAgICAgIGlubmVyUmVmID0gX3JlZjIuaW5uZXJSZWYsXG4gICAgICBkYXRhID0gX3JlZjIuZGF0YSxcbiAgICAgIHBhdGgkJDEgPSBfcmVmMi5wYXRoLFxuICAgICAgX3JlZjIkcGVyY2VudCA9IF9yZWYyLnBlcmNlbnQsXG4gICAgICBwZXJjZW50ID0gX3JlZjIkcGVyY2VudCA9PT0gdW5kZWZpbmVkID8gMC41IDogX3JlZjIkcGVyY2VudCxcbiAgICAgIF9yZWYyJHggPSBfcmVmMi54LFxuICAgICAgeCA9IF9yZWYyJHggPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueTtcbiAgfSA6IF9yZWYyJHgsXG4gICAgICBfcmVmMiR5ID0gX3JlZjIueSxcbiAgICAgIHkgPSBfcmVmMiR5ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLng7XG4gIH0gOiBfcmVmMiR5LFxuICAgICAgX3JlZjIkc291cmNlID0gX3JlZjIuc291cmNlLFxuICAgICAgc291cmNlID0gX3JlZjIkc291cmNlID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnNvdXJjZTtcbiAgfSA6IF9yZWYyJHNvdXJjZSxcbiAgICAgIF9yZWYyJHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgIHRhcmdldCA9IF9yZWYyJHRhcmdldCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC50YXJnZXQ7XG4gIH0gOiBfcmVmMiR0YXJnZXQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgWydjbGFzc05hbWUnLCAnaW5uZXJSZWYnLCAnZGF0YScsICdwYXRoJywgJ3BlcmNlbnQnLCAneCcsICd5JywgJ3NvdXJjZScsICd0YXJnZXQnXSk7XG5cbiAgcGF0aCQkMSA9IHBhdGgkJDEgfHwgcGF0aEhvcml6b250YWxTdGVwKHsgc291cmNlOiBzb3VyY2UsIHRhcmdldDogdGFyZ2V0LCB4OiB4LCB5OiB5LCBwZXJjZW50OiBwZXJjZW50IH0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgncGF0aCcsIF9leHRlbmRzKHtcbiAgICByZWY6IGlubmVyUmVmLFxuICAgIGNsYXNzTmFtZTogY3goJ3Z4LWxpbmsnLCBjbGFzc05hbWUpLFxuICAgIGQ6IHBhdGgkJDEoZGF0YSlcbiAgfSwgYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcywgZGF0YSkpKTtcbn1cblxuZnVuY3Rpb24gcGF0aFZlcnRpY2FsU3RlcChfcmVmKSB7XG4gIHZhciBzb3VyY2UgPSBfcmVmLnNvdXJjZSxcbiAgICAgIHRhcmdldCA9IF9yZWYudGFyZ2V0LFxuICAgICAgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnksXG4gICAgICBwZXJjZW50ID0gX3JlZi5wZXJjZW50O1xuXG4gIHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBzb3VyY2VEYXRhID0gc291cmNlKGRhdGEpO1xuICAgIHZhciB0YXJnZXREYXRhID0gdGFyZ2V0KGRhdGEpO1xuXG4gICAgdmFyIHN4ID0geChzb3VyY2VEYXRhKTtcbiAgICB2YXIgc3kgPSB5KHNvdXJjZURhdGEpO1xuICAgIHZhciB0eCA9IHgodGFyZ2V0RGF0YSk7XG4gICAgdmFyIHR5ID0geSh0YXJnZXREYXRhKTtcblxuICAgIHZhciBwYXRoJCQxID0gcGF0aCgpO1xuICAgIHBhdGgkJDEubW92ZVRvKHN4LCBzeSk7XG4gICAgcGF0aCQkMS5saW5lVG8oc3gsIHN5ICsgKHR5IC0gc3kpICogcGVyY2VudCk7XG4gICAgcGF0aCQkMS5saW5lVG8odHgsIHN5ICsgKHR5IC0gc3kpICogcGVyY2VudCk7XG4gICAgcGF0aCQkMS5saW5lVG8odHgsIHR5KTtcblxuICAgIHJldHVybiBwYXRoJCQxLnRvU3RyaW5nKCk7XG4gIH07XG59XG5cbkxpbmtWZXJ0aWNhbFN0ZXAucHJvcFR5cGVzID0ge1xuICBpbm5lclJlZjogUHJvcFR5cGVzLmZ1bmMsXG4gIHBlcmNlbnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIHg6IFByb3BUeXBlcy5mdW5jLFxuICB5OiBQcm9wVHlwZXMuZnVuYyxcbiAgc291cmNlOiBQcm9wVHlwZXMuZnVuYyxcbiAgdGFyZ2V0OiBQcm9wVHlwZXMuZnVuYyxcbiAgcGF0aDogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIExpbmtWZXJ0aWNhbFN0ZXAoX3JlZjIpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYyLmNsYXNzTmFtZSxcbiAgICAgIGlubmVyUmVmID0gX3JlZjIuaW5uZXJSZWYsXG4gICAgICBkYXRhID0gX3JlZjIuZGF0YSxcbiAgICAgIHBhdGgkJDEgPSBfcmVmMi5wYXRoLFxuICAgICAgX3JlZjIkcGVyY2VudCA9IF9yZWYyLnBlcmNlbnQsXG4gICAgICBwZXJjZW50ID0gX3JlZjIkcGVyY2VudCA9PT0gdW5kZWZpbmVkID8gMC41IDogX3JlZjIkcGVyY2VudCxcbiAgICAgIF9yZWYyJHggPSBfcmVmMi54LFxuICAgICAgeCA9IF9yZWYyJHggPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueDtcbiAgfSA6IF9yZWYyJHgsXG4gICAgICBfcmVmMiR5ID0gX3JlZjIueSxcbiAgICAgIHkgPSBfcmVmMiR5ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnk7XG4gIH0gOiBfcmVmMiR5LFxuICAgICAgX3JlZjIkc291cmNlID0gX3JlZjIuc291cmNlLFxuICAgICAgc291cmNlID0gX3JlZjIkc291cmNlID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnNvdXJjZTtcbiAgfSA6IF9yZWYyJHNvdXJjZSxcbiAgICAgIF9yZWYyJHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgIHRhcmdldCA9IF9yZWYyJHRhcmdldCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC50YXJnZXQ7XG4gIH0gOiBfcmVmMiR0YXJnZXQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgWydjbGFzc05hbWUnLCAnaW5uZXJSZWYnLCAnZGF0YScsICdwYXRoJywgJ3BlcmNlbnQnLCAneCcsICd5JywgJ3NvdXJjZScsICd0YXJnZXQnXSk7XG5cbiAgcGF0aCQkMSA9IHBhdGgkJDEgfHwgcGF0aFZlcnRpY2FsU3RlcCh7IHNvdXJjZTogc291cmNlLCB0YXJnZXQ6IHRhcmdldCwgeDogeCwgeTogeSwgcGVyY2VudDogcGVyY2VudCB9KTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBpbm5lclJlZixcbiAgICBjbGFzc05hbWU6IGN4KCd2eC1saW5rJywgY2xhc3NOYW1lKSxcbiAgICBkOiBwYXRoJCQxKGRhdGEpXG4gIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSk7XG59XG5cbmZ1bmN0aW9uIHBhdGhSYWRpYWxTdGVwKF9yZWYpIHtcbiAgdmFyIHNvdXJjZSA9IF9yZWYuc291cmNlLFxuICAgICAgdGFyZ2V0ID0gX3JlZi50YXJnZXQsXG4gICAgICB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueTtcblxuICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgc291cmNlRGF0YSA9IHNvdXJjZShkYXRhKTtcbiAgICB2YXIgdGFyZ2V0RGF0YSA9IHRhcmdldChkYXRhKTtcblxuICAgIHZhciBzeCA9IHgoc291cmNlRGF0YSk7XG4gICAgdmFyIHN5ID0geShzb3VyY2VEYXRhKTtcbiAgICB2YXIgdHggPSB4KHRhcmdldERhdGEpO1xuICAgIHZhciB0eSA9IHkodGFyZ2V0RGF0YSk7XG5cbiAgICB2YXIgc2EgPSBzeCAtIE1hdGguUEkgLyAyO1xuICAgIHZhciBzciA9IHN5O1xuICAgIHZhciB0YSA9IHR4IC0gTWF0aC5QSSAvIDI7XG4gICAgdmFyIHRyID0gdHk7XG5cbiAgICB2YXIgc2MgPSBNYXRoLmNvcyhzYSk7XG4gICAgdmFyIHNzID0gTWF0aC5zaW4oc2EpO1xuICAgIHZhciB0YyA9IE1hdGguY29zKHRhKTtcbiAgICB2YXIgdHMgPSBNYXRoLnNpbih0YSk7XG4gICAgdmFyIHNmID0gTWF0aC5hYnModGEgLSBzYSkgPiBNYXRoLlBJID8gdGEgPD0gc2EgOiB0YSA+IHNhO1xuXG4gICAgcmV0dXJuICdcXG4gICAgICBNJyArIHNyICogc2MgKyAnLCcgKyBzciAqIHNzICsgJ1xcbiAgICAgIEEnICsgc3IgKyAnLCcgKyBzciArICcsMCwwLCcgKyAoc2YgPyAxIDogMCkgKyAnLCcgKyBzciAqIHRjICsgJywnICsgc3IgKiB0cyArICdcXG4gICAgICBMJyArIHRyICogdGMgKyAnLCcgKyB0ciAqIHRzICsgJ1xcbiAgICAnO1xuICB9O1xufVxuXG5MaW5rUmFkaWFsU3RlcCQxLnByb3BUeXBlcyA9IHtcbiAgaW5uZXJSZWY6IFByb3BUeXBlcy5mdW5jLFxuICB4OiBQcm9wVHlwZXMuZnVuYyxcbiAgeTogUHJvcFR5cGVzLmZ1bmMsXG4gIHNvdXJjZTogUHJvcFR5cGVzLmZ1bmMsXG4gIHRhcmdldDogUHJvcFR5cGVzLmZ1bmMsXG4gIHBhdGg6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5mdW5jdGlvbiBMaW5rUmFkaWFsU3RlcCQxKF9yZWYyKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmMi5jbGFzc05hbWUsXG4gICAgICBpbm5lclJlZiA9IF9yZWYyLmlubmVyUmVmLFxuICAgICAgZGF0YSA9IF9yZWYyLmRhdGEsXG4gICAgICBwYXRoJCQxID0gX3JlZjIucGF0aCxcbiAgICAgIF9yZWYyJHggPSBfcmVmMi54LFxuICAgICAgeCA9IF9yZWYyJHggPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueDtcbiAgfSA6IF9yZWYyJHgsXG4gICAgICBfcmVmMiR5ID0gX3JlZjIueSxcbiAgICAgIHkgPSBfcmVmMiR5ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnk7XG4gIH0gOiBfcmVmMiR5LFxuICAgICAgX3JlZjIkc291cmNlID0gX3JlZjIuc291cmNlLFxuICAgICAgc291cmNlID0gX3JlZjIkc291cmNlID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnNvdXJjZTtcbiAgfSA6IF9yZWYyJHNvdXJjZSxcbiAgICAgIF9yZWYyJHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgIHRhcmdldCA9IF9yZWYyJHRhcmdldCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC50YXJnZXQ7XG4gIH0gOiBfcmVmMiR0YXJnZXQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgWydjbGFzc05hbWUnLCAnaW5uZXJSZWYnLCAnZGF0YScsICdwYXRoJywgJ3gnLCAneScsICdzb3VyY2UnLCAndGFyZ2V0J10pO1xuXG4gIHBhdGgkJDEgPSBwYXRoJCQxIHx8IHBhdGhSYWRpYWxTdGVwKHsgc291cmNlOiBzb3VyY2UsIHRhcmdldDogdGFyZ2V0LCB4OiB4LCB5OiB5IH0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgncGF0aCcsIF9leHRlbmRzKHtcbiAgICByZWY6IGlubmVyUmVmLFxuICAgIGNsYXNzTmFtZTogY3goJ3Z4LWxpbmsnLCBjbGFzc05hbWUpLFxuICAgIGQ6IHBhdGgkJDEoZGF0YSlcbiAgfSwgYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcywgZGF0YSkpKTtcbn1cblxuUG9seWdvbi5wcm9wVHlwZXMgPSB7XG4gIHNpZGVzOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIHNpemU6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICByb3RhdGU6IFByb3BUeXBlcy5udW1iZXIsXG4gIGZpbGw6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHN0cm9rZURhc2hhcnJheTogUHJvcFR5cGVzLnN0cmluZyxcbiAgc3Ryb2tlV2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXG4gIHN0cm9rZTogUHJvcFR5cGVzLnN0cmluZ1xufTtcblxudmFyIGdldFBvaW50ID0gZnVuY3Rpb24gZ2V0UG9pbnQoX3JlZikge1xuICB2YXIgc2lkZXMgPSBfcmVmLnNpZGVzLFxuICAgICAgc2l6ZSA9IF9yZWYuc2l6ZSxcbiAgICAgIGNlbnRlciA9IF9yZWYuY2VudGVyLFxuICAgICAgcm90YXRlID0gX3JlZi5yb3RhdGUsXG4gICAgICBzaWRlID0gX3JlZi5zaWRlO1xuXG4gIHZhciBkZWdyZWVzID0gMzYwIC8gc2lkZXMgKiBzaWRlIC0gcm90YXRlO1xuICB2YXIgcmFkaWFucyA9IGRlZ3JlZXNUb1JhZGlhbnMoZGVncmVlcyk7XG5cbiAgcmV0dXJuIG5ldyBQb2ludCh7XG4gICAgeDogY2VudGVyLnggKyBzaXplICogTWF0aC5jb3MocmFkaWFucyksXG4gICAgeTogY2VudGVyLnkgKyBzaXplICogTWF0aC5zaW4ocmFkaWFucylcbiAgfSk7XG59O1xuXG52YXIgZ2V0UG9pbnRzID0gZnVuY3Rpb24gZ2V0UG9pbnRzKF9yZWYyKSB7XG4gIHZhciBzaWRlcyA9IF9yZWYyLnNpZGVzLFxuICAgICAgc2l6ZSA9IF9yZWYyLnNpemUsXG4gICAgICBjZW50ZXIgPSBfcmVmMi5jZW50ZXIsXG4gICAgICByb3RhdGUgPSBfcmVmMi5yb3RhdGU7XG4gIHJldHVybiBbXS5jb25jYXQodG9Db25zdW1hYmxlQXJyYXkoQXJyYXkoc2lkZXMpLmtleXMoKSkpLm1hcChmdW5jdGlvbiAoc2lkZSkge1xuICAgIHJldHVybiBnZXRQb2ludCh7XG4gICAgICBzaWRlczogc2lkZXMsXG4gICAgICBzaXplOiBzaXplLFxuICAgICAgY2VudGVyOiBjZW50ZXIsXG4gICAgICByb3RhdGU6IHJvdGF0ZSxcbiAgICAgIHNpZGU6IHNpZGVcbiAgICB9KTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBQb2x5Z29uKF9yZWYzKSB7XG4gIHZhciBzaWRlcyA9IF9yZWYzLnNpZGVzLFxuICAgICAgX3JlZjMkc2l6ZSA9IF9yZWYzLnNpemUsXG4gICAgICBzaXplID0gX3JlZjMkc2l6ZSA9PT0gdW5kZWZpbmVkID8gMjUgOiBfcmVmMyRzaXplLFxuICAgICAgX3JlZjMkY2VudGVyID0gX3JlZjMuY2VudGVyLFxuICAgICAgY2VudGVyID0gX3JlZjMkY2VudGVyID09PSB1bmRlZmluZWQgPyBuZXcgUG9pbnQoeyB4OiAwLCB5OiAwIH0pIDogX3JlZjMkY2VudGVyLFxuICAgICAgX3JlZjMkcm90YXRlID0gX3JlZjMucm90YXRlLFxuICAgICAgcm90YXRlID0gX3JlZjMkcm90YXRlID09PSB1bmRlZmluZWQgPyAwIDogX3JlZjMkcm90YXRlLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZjMuY2xhc3NOYW1lLFxuICAgICAgY2xpY2tIYW5kbGVyID0gX3JlZjMuY2xpY2tIYW5kbGVyLFxuICAgICAgZmlsbCA9IF9yZWYzLmZpbGwsXG4gICAgICBzdHJva2VEYXNoYXJyYXkgPSBfcmVmMy5zdHJva2VEYXNoYXJyYXksXG4gICAgICBfcmVmMyRzdHJva2VXaWR0aCA9IF9yZWYzLnN0cm9rZVdpZHRoLFxuICAgICAgX3JlZjMkc3Ryb2tlID0gX3JlZjMuc3Ryb2tlLFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjMsIFsnc2lkZXMnLCAnc2l6ZScsICdjZW50ZXInLCAncm90YXRlJywgJ2NsYXNzTmFtZScsICdjbGlja0hhbmRsZXInLCAnZmlsbCcsICdzdHJva2VEYXNoYXJyYXknLCAnc3Ryb2tlV2lkdGgnLCAnc3Ryb2tlJ10pO1xuXG4gIHZhciBwb2ludHMgPSBnZXRQb2ludHMoe1xuICAgIHNpZGVzOiBzaWRlcyxcbiAgICBzaXplOiBzaXplLFxuICAgIGNlbnRlcjogY2VudGVyLFxuICAgIHJvdGF0ZTogcm90YXRlXG4gIH0pLm1hcChmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBwLnRvQXJyYXkoKTtcbiAgfSkuam9pbignICcpO1xuXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdwb2x5Z29uJywgX2V4dGVuZHMoeyBwb2ludHM6IHBvaW50cywgY2xhc3NOYW1lOiBjbGFzc05hbWUsIGZpbGw6IGZpbGwgfSwgcmVzdFByb3BzKSk7XG59XG5cbmV4cG9ydCB7IEFyYywgUGllLCBMaW5lLCBMaW5lUGF0aCwgTGluZVJhZGlhbCwgQXJlYSwgQXJlYUNsb3NlZCwgQXJlYVN0YWNrLCBCYXIsIEJhckdyb3VwLCBCYXJHcm91cEhvcml6b250YWwsIEJhclN0YWNrLCBCYXJTdGFja0hvcml6b250YWwsIFN0YWNrLCBjYWxsT3JWYWx1ZSwgc3RhY2tPZmZzZXQsIFNUQUNLX09GRlNFVFMsIFNUQUNLX09GRlNFVF9OQU1FUywgc3RhY2tPcmRlciwgU1RBQ0tfT1JERVJTLCBTVEFDS19PUkRFUl9OQU1FUywgZGVncmVlc1RvUmFkaWFucywgTGlua0hvcml6b250YWwsIHBhdGhIb3Jpem9udGFsRGlhZ29uYWwsIExpbmtWZXJ0aWNhbCwgcGF0aFZlcnRpY2FsRGlhZ29uYWwsIExpbmtSYWRpYWwsIHBhdGhSYWRpYWxEaWFnb25hbCwgTGlua0hvcml6b250YWxDdXJ2ZSwgcGF0aEhvcml6b250YWxDdXJ2ZSwgTGlua1ZlcnRpY2FsQ3VydmUsIHBhdGhWZXJ0aWNhbEN1cnZlLCBMaW5rUmFkaWFsQ3VydmUsIHBhdGhSYWRpYWxDdXJ2ZSwgTGlua0hvcml6b250YWxMaW5lLCBwYXRoSG9yaXpvbnRhbExpbmUsIExpbmtWZXJ0aWNhbExpbmUsIHBhdGhWZXJ0aWNhbExpbmUsIExpbmtSYWRpYWxTdGVwIGFzIExpbmtSYWRpYWxMaW5lLCBwYXRoUmFkaWFsTGluZSwgTGlua0hvcml6b250YWxTdGVwLCBwYXRoSG9yaXpvbnRhbFN0ZXAsIExpbmtWZXJ0aWNhbFN0ZXAsIHBhdGhWZXJ0aWNhbFN0ZXAsIExpbmtSYWRpYWxTdGVwJDEgYXMgTGlua1JhZGlhbFN0ZXAsIHBhdGhSYWRpYWxTdGVwLCBQb2x5Z29uLCBnZXRQb2ludHMsIGdldFBvaW50IH07XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjeCBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCB7IExpbmUgfSBmcm9tICdAdngvc2hhcGUnO1xuaW1wb3J0IHsgUG9pbnQgfSBmcm9tICdAdngvcG9pbnQnO1xuaW1wb3J0IHsgR3JvdXAgfSBmcm9tICdAdngvZ3JvdXAnO1xuaW1wb3J0IHsgVGV4dCB9IGZyb20gJ0B2eC90ZXh0JztcblxuZnVuY3Rpb24gY2VudGVyKHNjYWxlKSB7XG4gIHZhciBvZmZzZXQgPSBzY2FsZS5iYW5kd2lkdGgoKSAvIDI7XG4gIGlmIChzY2FsZS5yb3VuZCgpKSBvZmZzZXQgPSBNYXRoLnJvdW5kKG9mZnNldCk7XG4gIHJldHVybiBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBzY2FsZShkKSArIG9mZnNldDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaWRlbnRpdHkoeCkge1xuICByZXR1cm4geDtcbn1cblxudmFyIE9SSUVOVCA9IHtcbiAgdG9wOiAndG9wJyxcbiAgbGVmdDogJ2xlZnQnLFxuICByaWdodDogJ3JpZ2h0JyxcbiAgYm90dG9tOiAnYm90dG9tJ1xufTtcblxuZnVuY3Rpb24gbGFiZWxUcmFuc2Zvcm0oX3JlZikge1xuICB2YXIgbGFiZWxPZmZzZXQgPSBfcmVmLmxhYmVsT2Zmc2V0LFxuICAgICAgbGFiZWxQcm9wcyA9IF9yZWYubGFiZWxQcm9wcyxcbiAgICAgIG9yaWVudGF0aW9uID0gX3JlZi5vcmllbnRhdGlvbixcbiAgICAgIHJhbmdlID0gX3JlZi5yYW5nZSxcbiAgICAgIHRpY2tMYWJlbEZvbnRTaXplID0gX3JlZi50aWNrTGFiZWxGb250U2l6ZSxcbiAgICAgIHRpY2tMZW5ndGggPSBfcmVmLnRpY2tMZW5ndGg7XG5cbiAgdmFyIHNpZ24gPSBvcmllbnRhdGlvbiA9PT0gT1JJRU5ULmxlZnQgfHwgb3JpZW50YXRpb24gPT09IE9SSUVOVC50b3AgPyAtMSA6IDE7XG5cbiAgdmFyIHggPSB2b2lkIDAsXG4gICAgICB5ID0gdm9pZCAwLFxuICAgICAgdHJhbnNmb3JtID0gbnVsbDtcbiAgaWYgKG9yaWVudGF0aW9uID09PSBPUklFTlQudG9wIHx8IG9yaWVudGF0aW9uID09PSBPUklFTlQuYm90dG9tKSB7XG4gICAgeCA9IChyYW5nZVswXSArIHJhbmdlW3JhbmdlLmxlbmd0aCAtIDFdKSAvIDI7XG4gICAgeSA9IHNpZ24gKiAodGlja0xlbmd0aCArIGxhYmVsT2Zmc2V0ICsgdGlja0xhYmVsRm9udFNpemUgKyAob3JpZW50YXRpb24gPT09IE9SSUVOVC5ib3R0b20gPyBsYWJlbFByb3BzLmZvbnRTaXplIDogMCkpO1xuICB9IGVsc2Uge1xuICAgIHggPSBzaWduICogKChyYW5nZVswXSArIHJhbmdlW3JhbmdlLmxlbmd0aCAtIDFdKSAvIDIpO1xuICAgIHkgPSAtKHRpY2tMZW5ndGggKyBsYWJlbE9mZnNldCk7XG4gICAgdHJhbnNmb3JtID0gJ3JvdGF0ZSgnICsgc2lnbiAqIDkwICsgJyknO1xuICB9XG5cbiAgcmV0dXJuIHsgeDogeCwgeTogeSwgdHJhbnNmb3JtOiB0cmFuc2Zvcm0gfTtcbn1cblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbnZhciBwcm9wVHlwZXMgPSB7XG4gIGF4aXNDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGF4aXNMaW5lQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBoaWRlQXhpc0xpbmU6IFByb3BUeXBlcy5ib29sLFxuICBoaWRlVGlja3M6IFByb3BUeXBlcy5ib29sLFxuICBoaWRlWmVybzogUHJvcFR5cGVzLmJvb2wsXG4gIGxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBsYWJlbENsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgbGFiZWxPZmZzZXQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIGxhYmVsUHJvcHM6IFByb3BUeXBlcy5vYmplY3QsXG4gIGxlZnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIG51bVRpY2tzOiBQcm9wVHlwZXMubnVtYmVyLFxuICBvcmllbnRhdGlvbjogUHJvcFR5cGVzLm9uZU9mKFtPUklFTlQudG9wLCBPUklFTlQucmlnaHQsIE9SSUVOVC5ib3R0b20sIE9SSUVOVC5sZWZ0XSksXG4gIHJhbmdlUGFkZGluZzogUHJvcFR5cGVzLm51bWJlcixcbiAgc2NhbGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHN0cm9rZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgc3Ryb2tlV2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXG4gIHN0cm9rZURhc2hhcnJheTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdGlja0NsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdGlja0Zvcm1hdDogUHJvcFR5cGVzLmZ1bmMsXG4gIHRpY2tMYWJlbFByb3BzOiBQcm9wVHlwZXMuZnVuYyxcbiAgdGlja0xlbmd0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgdGlja1N0cm9rZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdGlja1RyYW5zZm9ybTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdGlja1ZhbHVlczogUHJvcFR5cGVzLmFycmF5LFxuICB0aWNrQ29tcG9uZW50OiBQcm9wVHlwZXMuZnVuYyxcbiAgdG9wOiBQcm9wVHlwZXMubnVtYmVyLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIEF4aXMoX3JlZikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgYXhpc0NsYXNzTmFtZSA9IF9yZWYuYXhpc0NsYXNzTmFtZSxcbiAgICAgIGF4aXNMaW5lQ2xhc3NOYW1lID0gX3JlZi5heGlzTGluZUNsYXNzTmFtZSxcbiAgICAgIF9yZWYkaGlkZUF4aXNMaW5lID0gX3JlZi5oaWRlQXhpc0xpbmUsXG4gICAgICBoaWRlQXhpc0xpbmUgPSBfcmVmJGhpZGVBeGlzTGluZSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJGhpZGVBeGlzTGluZSxcbiAgICAgIF9yZWYkaGlkZVRpY2tzID0gX3JlZi5oaWRlVGlja3MsXG4gICAgICBoaWRlVGlja3MgPSBfcmVmJGhpZGVUaWNrcyA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJGhpZGVUaWNrcyxcbiAgICAgIF9yZWYkaGlkZVplcm8gPSBfcmVmLmhpZGVaZXJvLFxuICAgICAgaGlkZVplcm8gPSBfcmVmJGhpZGVaZXJvID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkaGlkZVplcm8sXG4gICAgICBfcmVmJGxhYmVsID0gX3JlZi5sYWJlbCxcbiAgICAgIGxhYmVsID0gX3JlZiRsYWJlbCA9PT0gdW5kZWZpbmVkID8gJycgOiBfcmVmJGxhYmVsLFxuICAgICAgbGFiZWxDbGFzc05hbWUgPSBfcmVmLmxhYmVsQ2xhc3NOYW1lLFxuICAgICAgX3JlZiRsYWJlbE9mZnNldCA9IF9yZWYubGFiZWxPZmZzZXQsXG4gICAgICBsYWJlbE9mZnNldCA9IF9yZWYkbGFiZWxPZmZzZXQgPT09IHVuZGVmaW5lZCA/IDE0IDogX3JlZiRsYWJlbE9mZnNldCxcbiAgICAgIF9yZWYkbGFiZWxQcm9wcyA9IF9yZWYubGFiZWxQcm9wcyxcbiAgICAgIGxhYmVsUHJvcHMgPSBfcmVmJGxhYmVsUHJvcHMgPT09IHVuZGVmaW5lZCA/IHtcbiAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJyxcbiAgICBmb250RmFtaWx5OiAnQXJpYWwnLFxuICAgIGZvbnRTaXplOiAxMCxcbiAgICBmaWxsOiAnYmxhY2snXG4gIH0gOiBfcmVmJGxhYmVsUHJvcHMsXG4gICAgICBfcmVmJGxlZnQgPSBfcmVmLmxlZnQsXG4gICAgICBsZWZ0ID0gX3JlZiRsZWZ0ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiRsZWZ0LFxuICAgICAgX3JlZiRudW1UaWNrcyA9IF9yZWYubnVtVGlja3MsXG4gICAgICBudW1UaWNrcyA9IF9yZWYkbnVtVGlja3MgPT09IHVuZGVmaW5lZCA/IDEwIDogX3JlZiRudW1UaWNrcyxcbiAgICAgIF9yZWYkb3JpZW50YXRpb24gPSBfcmVmLm9yaWVudGF0aW9uLFxuICAgICAgb3JpZW50YXRpb24gPSBfcmVmJG9yaWVudGF0aW9uID09PSB1bmRlZmluZWQgPyBPUklFTlQuYm90dG9tIDogX3JlZiRvcmllbnRhdGlvbixcbiAgICAgIF9yZWYkcmFuZ2VQYWRkaW5nID0gX3JlZi5yYW5nZVBhZGRpbmcsXG4gICAgICByYW5nZVBhZGRpbmcgPSBfcmVmJHJhbmdlUGFkZGluZyA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkcmFuZ2VQYWRkaW5nLFxuICAgICAgc2NhbGUgPSBfcmVmLnNjYWxlLFxuICAgICAgX3JlZiRzdHJva2UgPSBfcmVmLnN0cm9rZSxcbiAgICAgIHN0cm9rZSA9IF9yZWYkc3Ryb2tlID09PSB1bmRlZmluZWQgPyAnYmxhY2snIDogX3JlZiRzdHJva2UsXG4gICAgICBfcmVmJHN0cm9rZVdpZHRoID0gX3JlZi5zdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZVdpZHRoID0gX3JlZiRzdHJva2VXaWR0aCA9PT0gdW5kZWZpbmVkID8gMSA6IF9yZWYkc3Ryb2tlV2lkdGgsXG4gICAgICBzdHJva2VEYXNoYXJyYXkgPSBfcmVmLnN0cm9rZURhc2hhcnJheSxcbiAgICAgIHRpY2tDbGFzc05hbWUgPSBfcmVmLnRpY2tDbGFzc05hbWUsXG4gICAgICB0aWNrRm9ybWF0ID0gX3JlZi50aWNrRm9ybWF0LFxuICAgICAgX3JlZiR0aWNrTGFiZWxQcm9wcyA9IF9yZWYudGlja0xhYmVsUHJvcHMsXG4gICAgICB0aWNrTGFiZWxQcm9wcyA9IF9yZWYkdGlja0xhYmVsUHJvcHMgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uICh0aWNrVmFsdWUsIGluZGV4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHRBbmNob3I6ICdtaWRkbGUnLFxuICAgICAgZm9udEZhbWlseTogJ0FyaWFsJyxcbiAgICAgIGZvbnRTaXplOiAxMCxcbiAgICAgIGZpbGw6ICdibGFjaydcbiAgICB9O1xuICB9IDogX3JlZiR0aWNrTGFiZWxQcm9wcyxcbiAgICAgIF9yZWYkdGlja0xlbmd0aCA9IF9yZWYudGlja0xlbmd0aCxcbiAgICAgIHRpY2tMZW5ndGggPSBfcmVmJHRpY2tMZW5ndGggPT09IHVuZGVmaW5lZCA/IDggOiBfcmVmJHRpY2tMZW5ndGgsXG4gICAgICBfcmVmJHRpY2tTdHJva2UgPSBfcmVmLnRpY2tTdHJva2UsXG4gICAgICB0aWNrU3Ryb2tlID0gX3JlZiR0aWNrU3Ryb2tlID09PSB1bmRlZmluZWQgPyAnYmxhY2snIDogX3JlZiR0aWNrU3Ryb2tlLFxuICAgICAgdGlja1RyYW5zZm9ybSA9IF9yZWYudGlja1RyYW5zZm9ybSxcbiAgICAgIHRpY2tWYWx1ZXMgPSBfcmVmLnRpY2tWYWx1ZXMsXG4gICAgICB0aWNrQ29tcG9uZW50ID0gX3JlZi50aWNrQ29tcG9uZW50LFxuICAgICAgX3JlZiR0b3AgPSBfcmVmLnRvcCxcbiAgICAgIHRvcCA9IF9yZWYkdG9wID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiR0b3A7XG5cbiAgdmFyIHZhbHVlcyA9IHNjYWxlLnRpY2tzID8gc2NhbGUudGlja3MobnVtVGlja3MpIDogc2NhbGUuZG9tYWluKCk7XG4gIGlmICh0aWNrVmFsdWVzKSB2YWx1ZXMgPSB0aWNrVmFsdWVzO1xuICB2YXIgZm9ybWF0ID0gc2NhbGUudGlja0Zvcm1hdCA/IHNjYWxlLnRpY2tGb3JtYXQoKSA6IGlkZW50aXR5O1xuICBpZiAodGlja0Zvcm1hdCkgZm9ybWF0ID0gdGlja0Zvcm1hdDtcblxuICB2YXIgcmFuZ2UgPSBzY2FsZS5yYW5nZSgpO1xuICB2YXIgcmFuZ2UwID0gcmFuZ2VbMF0gKyAwLjUgLSByYW5nZVBhZGRpbmc7XG4gIHZhciByYW5nZTEgPSByYW5nZVtyYW5nZS5sZW5ndGggLSAxXSArIDAuNSArIHJhbmdlUGFkZGluZztcblxuICB2YXIgaG9yaXpvbnRhbCA9IG9yaWVudGF0aW9uICE9PSBPUklFTlQubGVmdCAmJiBvcmllbnRhdGlvbiAhPT0gT1JJRU5ULnJpZ2h0O1xuICB2YXIgaXNMZWZ0ID0gb3JpZW50YXRpb24gPT09IE9SSUVOVC5sZWZ0O1xuICB2YXIgaXNUb3AgPSBvcmllbnRhdGlvbiA9PT0gT1JJRU5ULnRvcDtcbiAgdmFyIHRpY2tTaWduID0gaXNMZWZ0IHx8IGlzVG9wID8gLTEgOiAxO1xuXG4gIHZhciBwb3NpdGlvbiA9IChzY2FsZS5iYW5kd2lkdGggPyBjZW50ZXIgOiBpZGVudGl0eSkoc2NhbGUuY29weSgpKTtcblxuICB2YXIgYXhpc0Zyb21Qb2ludCA9IG5ldyBQb2ludCh7XG4gICAgeDogaG9yaXpvbnRhbCA/IHJhbmdlMCA6IDAsXG4gICAgeTogaG9yaXpvbnRhbCA/IDAgOiByYW5nZTBcbiAgfSk7XG4gIHZhciBheGlzVG9Qb2ludCA9IG5ldyBQb2ludCh7XG4gICAgeDogaG9yaXpvbnRhbCA/IHJhbmdlMSA6IDAsXG4gICAgeTogaG9yaXpvbnRhbCA/IDAgOiByYW5nZTFcbiAgfSk7XG5cbiAgdmFyIHRpY2tMYWJlbEZvbnRTaXplID0gMTA7IC8vIHRyYWNrIHRoZSBtYXggdGljayBsYWJlbCBzaXplIHRvIGNvbXB1dGUgbGFiZWwgb2Zmc2V0XG5cbiAgaWYgKCEhY2hpbGRyZW4pIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgIEdyb3VwLFxuICAgICAgeyBjbGFzc05hbWU6IGN4KCd2eC1heGlzJywgYXhpc0NsYXNzTmFtZSksIHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH0sXG4gICAgICBjaGlsZHJlbih7XG4gICAgICAgIGF4aXNGcm9tUG9pbnQ6IGF4aXNGcm9tUG9pbnQsXG4gICAgICAgIGF4aXNUb1BvaW50OiBheGlzVG9Qb2ludCxcbiAgICAgICAgaG9yaXpvbnRhbDogaG9yaXpvbnRhbCxcbiAgICAgICAgdGlja1NpZ246IHRpY2tTaWduLFxuICAgICAgICBudW1UaWNrczogbnVtVGlja3MsXG4gICAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgICAgcmFuZ2VQYWRkaW5nOiByYW5nZVBhZGRpbmcsXG4gICAgICAgIHRpY2tMZW5ndGg6IHRpY2tMZW5ndGgsXG4gICAgICAgIHRpY2tGb3JtYXQ6IGZvcm1hdCxcbiAgICAgICAgdGlja1Bvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgICAgdGlja3M6IHZhbHVlcy5tYXAoZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgICAgIHZhciBmcm9tID0gbmV3IFBvaW50KHtcbiAgICAgICAgICAgIHg6IGhvcml6b250YWwgPyBwb3NpdGlvbih2YWx1ZSkgOiAwLFxuICAgICAgICAgICAgeTogaG9yaXpvbnRhbCA/IDAgOiBwb3NpdGlvbih2YWx1ZSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgdG8gPSBuZXcgUG9pbnQoe1xuICAgICAgICAgICAgeDogaG9yaXpvbnRhbCA/IHBvc2l0aW9uKHZhbHVlKSA6IHRpY2tTaWduICogdGlja0xlbmd0aCxcbiAgICAgICAgICAgIHk6IGhvcml6b250YWwgPyB0aWNrTGVuZ3RoICogdGlja1NpZ24gOiBwb3NpdGlvbih2YWx1ZSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgZnJvbTogZnJvbSxcbiAgICAgICAgICAgIHRvOiB0byxcbiAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlOiBmb3JtYXQodmFsdWUsIGluZGV4KVxuICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICBHcm91cCxcbiAgICB7IGNsYXNzTmFtZTogY3goJ3Z4LWF4aXMnLCBheGlzQ2xhc3NOYW1lKSwgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfSxcbiAgICB2YWx1ZXMubWFwKGZ1bmN0aW9uICh2YWwsIGluZGV4KSB7XG4gICAgICBpZiAoaGlkZVplcm8gJiYgdmFsID09PSAwKSByZXR1cm4gbnVsbDtcblxuICAgICAgdmFyIHRpY2tGcm9tUG9pbnQgPSBuZXcgUG9pbnQoe1xuICAgICAgICB4OiBob3Jpem9udGFsID8gcG9zaXRpb24odmFsKSA6IDAsXG4gICAgICAgIHk6IGhvcml6b250YWwgPyAwIDogcG9zaXRpb24odmFsKVxuICAgICAgfSk7XG4gICAgICB2YXIgdGlja1RvUG9pbnQgPSBuZXcgUG9pbnQoe1xuICAgICAgICB4OiBob3Jpem9udGFsID8gcG9zaXRpb24odmFsKSA6IHRpY2tTaWduICogdGlja0xlbmd0aCxcbiAgICAgICAgeTogaG9yaXpvbnRhbCA/IHRpY2tMZW5ndGggKiB0aWNrU2lnbiA6IHBvc2l0aW9uKHZhbClcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgdGlja0xhYmVsUHJvcHNPYmogPSB0aWNrTGFiZWxQcm9wcyh2YWwsIGluZGV4KTtcbiAgICAgIHRpY2tMYWJlbEZvbnRTaXplID0gTWF0aC5tYXgodGlja0xhYmVsRm9udFNpemUsIHRpY2tMYWJlbFByb3BzT2JqLmZvbnRTaXplIHx8IDApO1xuXG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgR3JvdXAsXG4gICAgICAgIHtcbiAgICAgICAgICBrZXk6ICd2eC10aWNrLScgKyB2YWwgKyAnLScgKyBpbmRleCxcbiAgICAgICAgICBjbGFzc05hbWU6IGN4KCd2eC1heGlzLXRpY2snLCB0aWNrQ2xhc3NOYW1lKSxcbiAgICAgICAgICB0cmFuc2Zvcm06IHRpY2tUcmFuc2Zvcm1cbiAgICAgICAgfSxcbiAgICAgICAgIWhpZGVUaWNrcyAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KExpbmUsIHsgZnJvbTogdGlja0Zyb21Qb2ludCwgdG86IHRpY2tUb1BvaW50LCBzdHJva2U6IHRpY2tTdHJva2UgfSksXG4gICAgICAgIHRpY2tDb21wb25lbnQgPyB0aWNrQ29tcG9uZW50KF9leHRlbmRzKHtcbiAgICAgICAgICB4OiB0aWNrVG9Qb2ludC54LFxuICAgICAgICAgIHk6IHRpY2tUb1BvaW50LnkgKyAoaG9yaXpvbnRhbCAmJiAhaXNUb3AgPyB0aWNrTGFiZWxGb250U2l6ZSA6IDApLFxuICAgICAgICAgIGZvcm1hdHRlZFZhbHVlOiBmb3JtYXQodmFsLCBpbmRleClcbiAgICAgICAgfSwgdGlja0xhYmVsUHJvcHNPYmopKSA6IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgVGV4dCxcbiAgICAgICAgICBfZXh0ZW5kcyh7XG4gICAgICAgICAgICB4OiB0aWNrVG9Qb2ludC54LFxuICAgICAgICAgICAgeTogdGlja1RvUG9pbnQueSArIChob3Jpem9udGFsICYmICFpc1RvcCA/IHRpY2tMYWJlbEZvbnRTaXplIDogMClcbiAgICAgICAgICB9LCB0aWNrTGFiZWxQcm9wc09iaiksXG4gICAgICAgICAgZm9ybWF0KHZhbCwgaW5kZXgpXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSksXG4gICAgIWhpZGVBeGlzTGluZSAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KExpbmUsIHtcbiAgICAgIGNsYXNzTmFtZTogY3goJ3Z4LWF4aXMtbGluZScsIGF4aXNMaW5lQ2xhc3NOYW1lKSxcbiAgICAgIGZyb206IGF4aXNGcm9tUG9pbnQsXG4gICAgICB0bzogYXhpc1RvUG9pbnQsXG4gICAgICBzdHJva2U6IHN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZURhc2hhcnJheTogc3Ryb2tlRGFzaGFycmF5XG4gICAgfSksXG4gICAgbGFiZWwgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgIFRleHQsXG4gICAgICBfZXh0ZW5kcyh7XG4gICAgICAgIGNsYXNzTmFtZTogY3goJ3Z4LWF4aXMtbGFiZWwnLCBsYWJlbENsYXNzTmFtZSlcbiAgICAgIH0sIGxhYmVsVHJhbnNmb3JtKHtcbiAgICAgICAgbGFiZWxPZmZzZXQ6IGxhYmVsT2Zmc2V0LFxuICAgICAgICBsYWJlbFByb3BzOiBsYWJlbFByb3BzLFxuICAgICAgICBvcmllbnRhdGlvbjogb3JpZW50YXRpb24sXG4gICAgICAgIHJhbmdlOiByYW5nZSxcbiAgICAgICAgdGlja0xhYmVsRm9udFNpemU6IHRpY2tMYWJlbEZvbnRTaXplLFxuICAgICAgICB0aWNrTGVuZ3RoOiB0aWNrTGVuZ3RoXG4gICAgICB9KSwgbGFiZWxQcm9wcyksXG4gICAgICBsYWJlbFxuICAgIClcbiAgKTtcbn1cblxuQXhpcy5wcm9wVHlwZXMgPSBwcm9wVHlwZXM7XG5cbnZhciBwcm9wVHlwZXMkMSA9IHtcbiAgYXhpc0NsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgYXhpc0xpbmVDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGhpZGVBeGlzTGluZTogUHJvcFR5cGVzLmJvb2wsXG4gIGhpZGVUaWNrczogUHJvcFR5cGVzLmJvb2wsXG4gIGhpZGVaZXJvOiBQcm9wVHlwZXMuYm9vbCxcbiAgbGFiZWw6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGxhYmVsQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBsYWJlbE9mZnNldDogUHJvcFR5cGVzLm51bWJlcixcbiAgbGFiZWxQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcbiAgbGVmdDogUHJvcFR5cGVzLm51bWJlcixcbiAgbnVtVGlja3M6IFByb3BUeXBlcy5udW1iZXIsXG4gIHJhbmdlUGFkZGluZzogUHJvcFR5cGVzLm51bWJlcixcbiAgc2NhbGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHN0cm9rZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgc3Ryb2tlV2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXG4gIHN0cm9rZURhc2hhcnJheTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdGlja0NsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdGlja0Zvcm1hdDogUHJvcFR5cGVzLmZ1bmMsXG4gIHRpY2tMYWJlbFByb3BzOiBQcm9wVHlwZXMuZnVuYyxcbiAgdGlja0xlbmd0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgdGlja1N0cm9rZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdGlja1RyYW5zZm9ybTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdGlja1ZhbHVlczogUHJvcFR5cGVzLmFycmF5LFxuICB0aWNrQ29tcG9uZW50OiBQcm9wVHlwZXMuZnVuYyxcbiAgdG9wOiBQcm9wVHlwZXMubnVtYmVyLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIEF4aXNMZWZ0KF9yZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIGF4aXNDbGFzc05hbWUgPSBfcmVmLmF4aXNDbGFzc05hbWUsXG4gICAgICBheGlzTGluZUNsYXNzTmFtZSA9IF9yZWYuYXhpc0xpbmVDbGFzc05hbWUsXG4gICAgICBoaWRlQXhpc0xpbmUgPSBfcmVmLmhpZGVBeGlzTGluZSxcbiAgICAgIGhpZGVUaWNrcyA9IF9yZWYuaGlkZVRpY2tzLFxuICAgICAgaGlkZVplcm8gPSBfcmVmLmhpZGVaZXJvLFxuICAgICAgbGFiZWwgPSBfcmVmLmxhYmVsLFxuICAgICAgbGFiZWxDbGFzc05hbWUgPSBfcmVmLmxhYmVsQ2xhc3NOYW1lLFxuICAgICAgX3JlZiRsYWJlbE9mZnNldCA9IF9yZWYubGFiZWxPZmZzZXQsXG4gICAgICBsYWJlbE9mZnNldCA9IF9yZWYkbGFiZWxPZmZzZXQgPT09IHVuZGVmaW5lZCA/IDM2IDogX3JlZiRsYWJlbE9mZnNldCxcbiAgICAgIGxhYmVsUHJvcHMgPSBfcmVmLmxhYmVsUHJvcHMsXG4gICAgICBsZWZ0ID0gX3JlZi5sZWZ0LFxuICAgICAgbnVtVGlja3MgPSBfcmVmLm51bVRpY2tzLFxuICAgICAgcmFuZ2VQYWRkaW5nID0gX3JlZi5yYW5nZVBhZGRpbmcsXG4gICAgICBzY2FsZSA9IF9yZWYuc2NhbGUsXG4gICAgICBzdHJva2UgPSBfcmVmLnN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoID0gX3JlZi5zdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZURhc2hhcnJheSA9IF9yZWYuc3Ryb2tlRGFzaGFycmF5LFxuICAgICAgdGlja0NsYXNzTmFtZSA9IF9yZWYudGlja0NsYXNzTmFtZSxcbiAgICAgIHRpY2tGb3JtYXQgPSBfcmVmLnRpY2tGb3JtYXQsXG4gICAgICBfcmVmJHRpY2tMYWJlbFByb3BzID0gX3JlZi50aWNrTGFiZWxQcm9wcyxcbiAgICAgIHRpY2tMYWJlbFByb3BzID0gX3JlZiR0aWNrTGFiZWxQcm9wcyA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgdmFyIHRpY2sgPSBfcmVmMi50aWNrLFxuICAgICAgICBpbmRleCA9IF9yZWYyLmluZGV4O1xuICAgIHJldHVybiB7XG4gICAgICBkeDogJy0wLjI1ZW0nLFxuICAgICAgZHk6ICcwLjI1ZW0nLFxuICAgICAgZmlsbDogJ2JsYWNrJyxcbiAgICAgIGZvbnRGYW1pbHk6ICdBcmlhbCcsXG4gICAgICBmb250U2l6ZTogMTAsXG4gICAgICB0ZXh0QW5jaG9yOiAnZW5kJ1xuICAgIH07XG4gIH0gOiBfcmVmJHRpY2tMYWJlbFByb3BzLFxuICAgICAgX3JlZiR0aWNrTGVuZ3RoID0gX3JlZi50aWNrTGVuZ3RoLFxuICAgICAgdGlja0xlbmd0aCA9IF9yZWYkdGlja0xlbmd0aCA9PT0gdW5kZWZpbmVkID8gOCA6IF9yZWYkdGlja0xlbmd0aCxcbiAgICAgIHRpY2tTdHJva2UgPSBfcmVmLnRpY2tTdHJva2UsXG4gICAgICB0aWNrVHJhbnNmb3JtID0gX3JlZi50aWNrVHJhbnNmb3JtLFxuICAgICAgdGlja1ZhbHVlcyA9IF9yZWYudGlja1ZhbHVlcyxcbiAgICAgIHRpY2tDb21wb25lbnQgPSBfcmVmLnRpY2tDb21wb25lbnQsXG4gICAgICB0b3AgPSBfcmVmLnRvcDtcblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChBeGlzLCB7XG4gICAgYXhpc0NsYXNzTmFtZTogY3goJ3Z4LWF4aXMtbGVmdCcsIGF4aXNDbGFzc05hbWUpLFxuICAgIGF4aXNMaW5lQ2xhc3NOYW1lOiBheGlzTGluZUNsYXNzTmFtZSxcbiAgICBoaWRlQXhpc0xpbmU6IGhpZGVBeGlzTGluZSxcbiAgICBoaWRlVGlja3M6IGhpZGVUaWNrcyxcbiAgICBoaWRlWmVybzogaGlkZVplcm8sXG4gICAgbGFiZWw6IGxhYmVsLFxuICAgIGxhYmVsQ2xhc3NOYW1lOiBsYWJlbENsYXNzTmFtZSxcbiAgICBsYWJlbE9mZnNldDogbGFiZWxPZmZzZXQsXG4gICAgbGFiZWxQcm9wczogbGFiZWxQcm9wcyxcbiAgICBsZWZ0OiBsZWZ0LFxuICAgIG51bVRpY2tzOiBudW1UaWNrcyxcbiAgICBvcmllbnRhdGlvbjogT1JJRU5ULmxlZnQsXG4gICAgcmFuZ2VQYWRkaW5nOiByYW5nZVBhZGRpbmcsXG4gICAgc2NhbGU6IHNjYWxlLFxuICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICBzdHJva2VEYXNoYXJyYXk6IHN0cm9rZURhc2hhcnJheSxcbiAgICB0aWNrQ2xhc3NOYW1lOiB0aWNrQ2xhc3NOYW1lLFxuICAgIHRpY2tGb3JtYXQ6IHRpY2tGb3JtYXQsXG4gICAgdGlja0xhYmVsUHJvcHM6IHRpY2tMYWJlbFByb3BzLFxuICAgIHRpY2tMZW5ndGg6IHRpY2tMZW5ndGgsXG4gICAgdGlja1N0cm9rZTogdGlja1N0cm9rZSxcbiAgICB0aWNrVHJhbnNmb3JtOiB0aWNrVHJhbnNmb3JtLFxuICAgIHRpY2tWYWx1ZXM6IHRpY2tWYWx1ZXMsXG4gICAgdGlja0NvbXBvbmVudDogdGlja0NvbXBvbmVudCxcbiAgICB0b3A6IHRvcCxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgfSk7XG59XG5cbkF4aXNMZWZ0LnByb3BUeXBlcyA9IHByb3BUeXBlcyQxO1xuXG52YXIgcHJvcFR5cGVzJDIgPSB7XG4gIGF4aXNDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGF4aXNMaW5lQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBoaWRlQXhpc0xpbmU6IFByb3BUeXBlcy5ib29sLFxuICBoaWRlVGlja3M6IFByb3BUeXBlcy5ib29sLFxuICBoaWRlWmVybzogUHJvcFR5cGVzLmJvb2wsXG4gIGxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBsYWJlbENsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgbGFiZWxPZmZzZXQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIGxhYmVsUHJvcHM6IFByb3BUeXBlcy5vYmplY3QsXG4gIGxlZnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIG51bVRpY2tzOiBQcm9wVHlwZXMubnVtYmVyLFxuICByYW5nZVBhZGRpbmc6IFByb3BUeXBlcy5udW1iZXIsXG4gIHNjYWxlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBzdHJva2U6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHN0cm9rZVdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLFxuICBzdHJva2VEYXNoYXJyYXk6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRpY2tDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRpY2tGb3JtYXQ6IFByb3BUeXBlcy5mdW5jLFxuICB0aWNrTGFiZWxQcm9wczogUHJvcFR5cGVzLmZ1bmMsXG4gIHRpY2tMZW5ndGg6IFByb3BUeXBlcy5udW1iZXIsXG4gIHRpY2tTdHJva2U6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRpY2tUcmFuc2Zvcm06IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRpY2tWYWx1ZXM6IFByb3BUeXBlcy5hcnJheSxcbiAgdGlja0NvbXBvbmVudDogUHJvcFR5cGVzLmZ1bmMsXG4gIHRvcDogUHJvcFR5cGVzLm51bWJlcixcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5mdW5jXG59O1xuXG5mdW5jdGlvbiBBeGlzUmlnaHQoX3JlZikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgYXhpc0NsYXNzTmFtZSA9IF9yZWYuYXhpc0NsYXNzTmFtZSxcbiAgICAgIGF4aXNMaW5lQ2xhc3NOYW1lID0gX3JlZi5heGlzTGluZUNsYXNzTmFtZSxcbiAgICAgIGhpZGVBeGlzTGluZSA9IF9yZWYuaGlkZUF4aXNMaW5lLFxuICAgICAgaGlkZVRpY2tzID0gX3JlZi5oaWRlVGlja3MsXG4gICAgICBoaWRlWmVybyA9IF9yZWYuaGlkZVplcm8sXG4gICAgICBsYWJlbCA9IF9yZWYubGFiZWwsXG4gICAgICBsYWJlbENsYXNzTmFtZSA9IF9yZWYubGFiZWxDbGFzc05hbWUsXG4gICAgICBfcmVmJGxhYmVsT2Zmc2V0ID0gX3JlZi5sYWJlbE9mZnNldCxcbiAgICAgIGxhYmVsT2Zmc2V0ID0gX3JlZiRsYWJlbE9mZnNldCA9PT0gdW5kZWZpbmVkID8gMzYgOiBfcmVmJGxhYmVsT2Zmc2V0LFxuICAgICAgbGFiZWxQcm9wcyA9IF9yZWYubGFiZWxQcm9wcyxcbiAgICAgIGxlZnQgPSBfcmVmLmxlZnQsXG4gICAgICBudW1UaWNrcyA9IF9yZWYubnVtVGlja3MsXG4gICAgICByYW5nZVBhZGRpbmcgPSBfcmVmLnJhbmdlUGFkZGluZyxcbiAgICAgIHNjYWxlID0gX3JlZi5zY2FsZSxcbiAgICAgIHN0cm9rZSA9IF9yZWYuc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGggPSBfcmVmLnN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlRGFzaGFycmF5ID0gX3JlZi5zdHJva2VEYXNoYXJyYXksXG4gICAgICB0aWNrQ2xhc3NOYW1lID0gX3JlZi50aWNrQ2xhc3NOYW1lLFxuICAgICAgdGlja0Zvcm1hdCA9IF9yZWYudGlja0Zvcm1hdCxcbiAgICAgIF9yZWYkdGlja0xhYmVsUHJvcHMgPSBfcmVmLnRpY2tMYWJlbFByb3BzLFxuICAgICAgdGlja0xhYmVsUHJvcHMgPSBfcmVmJHRpY2tMYWJlbFByb3BzID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICB2YXIgdGljayA9IF9yZWYyLnRpY2ssXG4gICAgICAgIGluZGV4ID0gX3JlZjIuaW5kZXg7XG4gICAgcmV0dXJuIHtcbiAgICAgIGR4OiAnMC4yNWVtJyxcbiAgICAgIGR5OiAnMC4yNWVtJyxcbiAgICAgIGZpbGw6ICdibGFjaycsXG4gICAgICBmb250RmFtaWx5OiAnQXJpYWwnLFxuICAgICAgZm9udFNpemU6IDEwLFxuICAgICAgdGV4dEFuY2hvcjogJ3N0YXJ0J1xuICAgIH07XG4gIH0gOiBfcmVmJHRpY2tMYWJlbFByb3BzLFxuICAgICAgX3JlZiR0aWNrTGVuZ3RoID0gX3JlZi50aWNrTGVuZ3RoLFxuICAgICAgdGlja0xlbmd0aCA9IF9yZWYkdGlja0xlbmd0aCA9PT0gdW5kZWZpbmVkID8gOCA6IF9yZWYkdGlja0xlbmd0aCxcbiAgICAgIHRpY2tTdHJva2UgPSBfcmVmLnRpY2tTdHJva2UsXG4gICAgICB0aWNrVHJhbnNmb3JtID0gX3JlZi50aWNrVHJhbnNmb3JtLFxuICAgICAgdGlja1ZhbHVlcyA9IF9yZWYudGlja1ZhbHVlcyxcbiAgICAgIHRpY2tDb21wb25lbnQgPSBfcmVmLnRpY2tDb21wb25lbnQsXG4gICAgICB0b3AgPSBfcmVmLnRvcDtcblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChBeGlzLCB7XG4gICAgYXhpc0NsYXNzTmFtZTogY3goJ3Z4LWF4aXMtcmlnaHQnLCBheGlzQ2xhc3NOYW1lKSxcbiAgICBheGlzTGluZUNsYXNzTmFtZTogYXhpc0xpbmVDbGFzc05hbWUsXG4gICAgaGlkZUF4aXNMaW5lOiBoaWRlQXhpc0xpbmUsXG4gICAgaGlkZVRpY2tzOiBoaWRlVGlja3MsXG4gICAgaGlkZVplcm86IGhpZGVaZXJvLFxuICAgIGxhYmVsOiBsYWJlbCxcbiAgICBsYWJlbENsYXNzTmFtZTogbGFiZWxDbGFzc05hbWUsXG4gICAgbGFiZWxPZmZzZXQ6IGxhYmVsT2Zmc2V0LFxuICAgIGxhYmVsUHJvcHM6IGxhYmVsUHJvcHMsXG4gICAgbGVmdDogbGVmdCxcbiAgICBudW1UaWNrczogbnVtVGlja3MsXG4gICAgb3JpZW50YXRpb246IE9SSUVOVC5yaWdodCxcbiAgICByYW5nZVBhZGRpbmc6IHJhbmdlUGFkZGluZyxcbiAgICBzY2FsZTogc2NhbGUsXG4gICAgc3Ryb2tlOiBzdHJva2UsXG4gICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgIHN0cm9rZURhc2hhcnJheTogc3Ryb2tlRGFzaGFycmF5LFxuICAgIHRpY2tDbGFzc05hbWU6IHRpY2tDbGFzc05hbWUsXG4gICAgdGlja0Zvcm1hdDogdGlja0Zvcm1hdCxcbiAgICB0aWNrTGFiZWxQcm9wczogdGlja0xhYmVsUHJvcHMsXG4gICAgdGlja0xlbmd0aDogdGlja0xlbmd0aCxcbiAgICB0aWNrU3Ryb2tlOiB0aWNrU3Ryb2tlLFxuICAgIHRpY2tUcmFuc2Zvcm06IHRpY2tUcmFuc2Zvcm0sXG4gICAgdGlja1ZhbHVlczogdGlja1ZhbHVlcyxcbiAgICB0aWNrQ29tcG9uZW50OiB0aWNrQ29tcG9uZW50LFxuICAgIHRvcDogdG9wLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICB9KTtcbn1cblxuQXhpc1JpZ2h0LnByb3BUeXBlcyA9IHByb3BUeXBlcyQyO1xuXG52YXIgcHJvcFR5cGVzJDMgPSB7XG4gIGF4aXNDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGF4aXNMaW5lQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBoaWRlQXhpc0xpbmU6IFByb3BUeXBlcy5ib29sLFxuICBoaWRlVGlja3M6IFByb3BUeXBlcy5ib29sLFxuICBoaWRlWmVybzogUHJvcFR5cGVzLmJvb2wsXG4gIGxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBsYWJlbENsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgbGFiZWxPZmZzZXQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIGxhYmVsUHJvcHM6IFByb3BUeXBlcy5vYmplY3QsXG4gIGxlZnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIG51bVRpY2tzOiBQcm9wVHlwZXMubnVtYmVyLFxuICByYW5nZVBhZGRpbmc6IFByb3BUeXBlcy5udW1iZXIsXG4gIHNjYWxlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBzdHJva2U6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHN0cm9rZVdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLFxuICBzdHJva2VEYXNoYXJyYXk6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRpY2tDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRpY2tGb3JtYXQ6IFByb3BUeXBlcy5mdW5jLFxuICB0aWNrTGFiZWxQcm9wczogUHJvcFR5cGVzLmZ1bmMsXG4gIHRpY2tMZW5ndGg6IFByb3BUeXBlcy5udW1iZXIsXG4gIHRpY2tTdHJva2U6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRpY2tUcmFuc2Zvcm06IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRpY2tWYWx1ZXM6IFByb3BUeXBlcy5hcnJheSxcbiAgdGlja0NvbXBvbmVudDogUHJvcFR5cGVzLmZ1bmMsXG4gIHRvcDogUHJvcFR5cGVzLm51bWJlcixcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5mdW5jXG59O1xuXG5mdW5jdGlvbiBBeGlzVG9wKF9yZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIGF4aXNDbGFzc05hbWUgPSBfcmVmLmF4aXNDbGFzc05hbWUsXG4gICAgICBheGlzTGluZUNsYXNzTmFtZSA9IF9yZWYuYXhpc0xpbmVDbGFzc05hbWUsXG4gICAgICBoaWRlQXhpc0xpbmUgPSBfcmVmLmhpZGVBeGlzTGluZSxcbiAgICAgIGhpZGVUaWNrcyA9IF9yZWYuaGlkZVRpY2tzLFxuICAgICAgaGlkZVplcm8gPSBfcmVmLmhpZGVaZXJvLFxuICAgICAgbGFiZWwgPSBfcmVmLmxhYmVsLFxuICAgICAgbGFiZWxDbGFzc05hbWUgPSBfcmVmLmxhYmVsQ2xhc3NOYW1lLFxuICAgICAgX3JlZiRsYWJlbE9mZnNldCA9IF9yZWYubGFiZWxPZmZzZXQsXG4gICAgICBsYWJlbE9mZnNldCA9IF9yZWYkbGFiZWxPZmZzZXQgPT09IHVuZGVmaW5lZCA/IDggOiBfcmVmJGxhYmVsT2Zmc2V0LFxuICAgICAgbGFiZWxQcm9wcyA9IF9yZWYubGFiZWxQcm9wcyxcbiAgICAgIGxlZnQgPSBfcmVmLmxlZnQsXG4gICAgICBudW1UaWNrcyA9IF9yZWYubnVtVGlja3MsXG4gICAgICByYW5nZVBhZGRpbmcgPSBfcmVmLnJhbmdlUGFkZGluZyxcbiAgICAgIHNjYWxlID0gX3JlZi5zY2FsZSxcbiAgICAgIHN0cm9rZSA9IF9yZWYuc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGggPSBfcmVmLnN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlRGFzaGFycmF5ID0gX3JlZi5zdHJva2VEYXNoYXJyYXksXG4gICAgICB0aWNrQ2xhc3NOYW1lID0gX3JlZi50aWNrQ2xhc3NOYW1lLFxuICAgICAgdGlja0Zvcm1hdCA9IF9yZWYudGlja0Zvcm1hdCxcbiAgICAgIF9yZWYkdGlja0xhYmVsUHJvcHMgPSBfcmVmLnRpY2tMYWJlbFByb3BzLFxuICAgICAgdGlja0xhYmVsUHJvcHMgPSBfcmVmJHRpY2tMYWJlbFByb3BzID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICB2YXIgdGljayA9IF9yZWYyLnRpY2ssXG4gICAgICAgIGluZGV4ID0gX3JlZjIuaW5kZXg7XG4gICAgcmV0dXJuIHtcbiAgICAgIGR5OiAnLTAuMjVlbScsXG4gICAgICBmaWxsOiAnYmxhY2snLFxuICAgICAgZm9udEZhbWlseTogJ0FyaWFsJyxcbiAgICAgIGZvbnRTaXplOiAxMCxcbiAgICAgIHRleHRBbmNob3I6ICdtaWRkbGUnXG4gICAgfTtcbiAgfSA6IF9yZWYkdGlja0xhYmVsUHJvcHMsXG4gICAgICBfcmVmJHRpY2tMZW5ndGggPSBfcmVmLnRpY2tMZW5ndGgsXG4gICAgICB0aWNrTGVuZ3RoID0gX3JlZiR0aWNrTGVuZ3RoID09PSB1bmRlZmluZWQgPyA4IDogX3JlZiR0aWNrTGVuZ3RoLFxuICAgICAgdGlja1N0cm9rZSA9IF9yZWYudGlja1N0cm9rZSxcbiAgICAgIHRpY2tUcmFuc2Zvcm0gPSBfcmVmLnRpY2tUcmFuc2Zvcm0sXG4gICAgICB0aWNrVmFsdWVzID0gX3JlZi50aWNrVmFsdWVzLFxuICAgICAgdGlja0NvbXBvbmVudCA9IF9yZWYudGlja0NvbXBvbmVudCxcbiAgICAgIHRvcCA9IF9yZWYudG9wO1xuXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEF4aXMsIHtcbiAgICBheGlzQ2xhc3NOYW1lOiBjeCgndngtYXhpcy10b3AnLCBheGlzQ2xhc3NOYW1lKSxcbiAgICBheGlzTGluZUNsYXNzTmFtZTogYXhpc0xpbmVDbGFzc05hbWUsXG4gICAgaGlkZUF4aXNMaW5lOiBoaWRlQXhpc0xpbmUsXG4gICAgaGlkZVRpY2tzOiBoaWRlVGlja3MsXG4gICAgaGlkZVplcm86IGhpZGVaZXJvLFxuICAgIGxhYmVsOiBsYWJlbCxcbiAgICBsYWJlbENsYXNzTmFtZTogbGFiZWxDbGFzc05hbWUsXG4gICAgbGFiZWxPZmZzZXQ6IGxhYmVsT2Zmc2V0LFxuICAgIGxhYmVsUHJvcHM6IGxhYmVsUHJvcHMsXG4gICAgbGVmdDogbGVmdCxcbiAgICBudW1UaWNrczogbnVtVGlja3MsXG4gICAgb3JpZW50YXRpb246IE9SSUVOVC50b3AsXG4gICAgcmFuZ2VQYWRkaW5nOiByYW5nZVBhZGRpbmcsXG4gICAgc2NhbGU6IHNjYWxlLFxuICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICBzdHJva2VEYXNoYXJyYXk6IHN0cm9rZURhc2hhcnJheSxcbiAgICB0aWNrQ2xhc3NOYW1lOiB0aWNrQ2xhc3NOYW1lLFxuICAgIHRpY2tGb3JtYXQ6IHRpY2tGb3JtYXQsXG4gICAgdGlja0xhYmVsUHJvcHM6IHRpY2tMYWJlbFByb3BzLFxuICAgIHRpY2tMZW5ndGg6IHRpY2tMZW5ndGgsXG4gICAgdGlja1N0cm9rZTogdGlja1N0cm9rZSxcbiAgICB0aWNrVHJhbnNmb3JtOiB0aWNrVHJhbnNmb3JtLFxuICAgIHRpY2tWYWx1ZXM6IHRpY2tWYWx1ZXMsXG4gICAgdGlja0NvbXBvbmVudDogdGlja0NvbXBvbmVudCxcbiAgICB0b3A6IHRvcCxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgfSk7XG59XG5cbkF4aXNUb3AucHJvcFR5cGVzID0gcHJvcFR5cGVzJDM7XG5cbnZhciBwcm9wVHlwZXMkNCA9IHtcbiAgYXhpc0NsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgYXhpc0xpbmVDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGhpZGVBeGlzTGluZTogUHJvcFR5cGVzLmJvb2wsXG4gIGhpZGVUaWNrczogUHJvcFR5cGVzLmJvb2wsXG4gIGhpZGVaZXJvOiBQcm9wVHlwZXMuYm9vbCxcbiAgbGFiZWw6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGxhYmVsQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBsYWJlbE9mZnNldDogUHJvcFR5cGVzLm51bWJlcixcbiAgbGFiZWxQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcbiAgbGVmdDogUHJvcFR5cGVzLm51bWJlcixcbiAgbnVtVGlja3M6IFByb3BUeXBlcy5udW1iZXIsXG4gIHJhbmdlUGFkZGluZzogUHJvcFR5cGVzLm51bWJlcixcbiAgc2NhbGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHN0cm9rZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgc3Ryb2tlV2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXG4gIHN0cm9rZURhc2hhcnJheTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdGlja0NsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdGlja0Zvcm1hdDogUHJvcFR5cGVzLmZ1bmMsXG4gIHRpY2tMYWJlbFByb3BzOiBQcm9wVHlwZXMuZnVuYyxcbiAgdGlja0xlbmd0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgdGlja1N0cm9rZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdGlja1RyYW5zZm9ybTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdGlja1ZhbHVlczogUHJvcFR5cGVzLmFycmF5LFxuICB0aWNrQ29tcG9uZW50OiBQcm9wVHlwZXMuZnVuYyxcbiAgdG9wOiBQcm9wVHlwZXMubnVtYmVyLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIEF4aXNCb3R0b20oX3JlZikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgYXhpc0NsYXNzTmFtZSA9IF9yZWYuYXhpc0NsYXNzTmFtZSxcbiAgICAgIGF4aXNMaW5lQ2xhc3NOYW1lID0gX3JlZi5heGlzTGluZUNsYXNzTmFtZSxcbiAgICAgIGhpZGVBeGlzTGluZSA9IF9yZWYuaGlkZUF4aXNMaW5lLFxuICAgICAgaGlkZVRpY2tzID0gX3JlZi5oaWRlVGlja3MsXG4gICAgICBoaWRlWmVybyA9IF9yZWYuaGlkZVplcm8sXG4gICAgICBsYWJlbCA9IF9yZWYubGFiZWwsXG4gICAgICBsYWJlbENsYXNzTmFtZSA9IF9yZWYubGFiZWxDbGFzc05hbWUsXG4gICAgICBfcmVmJGxhYmVsT2Zmc2V0ID0gX3JlZi5sYWJlbE9mZnNldCxcbiAgICAgIGxhYmVsT2Zmc2V0ID0gX3JlZiRsYWJlbE9mZnNldCA9PT0gdW5kZWZpbmVkID8gOCA6IF9yZWYkbGFiZWxPZmZzZXQsXG4gICAgICBsYWJlbFByb3BzID0gX3JlZi5sYWJlbFByb3BzLFxuICAgICAgbGVmdCA9IF9yZWYubGVmdCxcbiAgICAgIG51bVRpY2tzID0gX3JlZi5udW1UaWNrcyxcbiAgICAgIHJhbmdlUGFkZGluZyA9IF9yZWYucmFuZ2VQYWRkaW5nLFxuICAgICAgc2NhbGUgPSBfcmVmLnNjYWxlLFxuICAgICAgc3Ryb2tlID0gX3JlZi5zdHJva2UsXG4gICAgICBzdHJva2VXaWR0aCA9IF9yZWYuc3Ryb2tlV2lkdGgsXG4gICAgICBzdHJva2VEYXNoYXJyYXkgPSBfcmVmLnN0cm9rZURhc2hhcnJheSxcbiAgICAgIHRpY2tDbGFzc05hbWUgPSBfcmVmLnRpY2tDbGFzc05hbWUsXG4gICAgICB0aWNrRm9ybWF0ID0gX3JlZi50aWNrRm9ybWF0LFxuICAgICAgX3JlZiR0aWNrTGFiZWxQcm9wcyA9IF9yZWYudGlja0xhYmVsUHJvcHMsXG4gICAgICB0aWNrTGFiZWxQcm9wcyA9IF9yZWYkdGlja0xhYmVsUHJvcHMgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChfcmVmMikge1xuICAgIHZhciB0aWNrID0gX3JlZjIudGljayxcbiAgICAgICAgaW5kZXggPSBfcmVmMi5pbmRleDtcbiAgICByZXR1cm4ge1xuICAgICAgZHk6ICcwLjI1ZW0nLFxuICAgICAgZmlsbDogJ2JsYWNrJyxcbiAgICAgIGZvbnRGYW1pbHk6ICdBcmlhbCcsXG4gICAgICBmb250U2l6ZTogMTAsXG4gICAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJ1xuICAgIH07XG4gIH0gOiBfcmVmJHRpY2tMYWJlbFByb3BzLFxuICAgICAgX3JlZiR0aWNrTGVuZ3RoID0gX3JlZi50aWNrTGVuZ3RoLFxuICAgICAgdGlja0xlbmd0aCA9IF9yZWYkdGlja0xlbmd0aCA9PT0gdW5kZWZpbmVkID8gOCA6IF9yZWYkdGlja0xlbmd0aCxcbiAgICAgIHRpY2tTdHJva2UgPSBfcmVmLnRpY2tTdHJva2UsXG4gICAgICB0aWNrVHJhbnNmb3JtID0gX3JlZi50aWNrVHJhbnNmb3JtLFxuICAgICAgdGlja1ZhbHVlcyA9IF9yZWYudGlja1ZhbHVlcyxcbiAgICAgIHRpY2tDb21wb25lbnQgPSBfcmVmLnRpY2tDb21wb25lbnQsXG4gICAgICB0b3AgPSBfcmVmLnRvcDtcblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChBeGlzLCB7XG4gICAgYXhpc0NsYXNzTmFtZTogY3goJ3Z4LWF4aXMtYm90dG9tJywgYXhpc0NsYXNzTmFtZSksXG4gICAgYXhpc0xpbmVDbGFzc05hbWU6IGF4aXNMaW5lQ2xhc3NOYW1lLFxuICAgIGhpZGVBeGlzTGluZTogaGlkZUF4aXNMaW5lLFxuICAgIGhpZGVUaWNrczogaGlkZVRpY2tzLFxuICAgIGhpZGVaZXJvOiBoaWRlWmVybyxcbiAgICBsYWJlbDogbGFiZWwsXG4gICAgbGFiZWxDbGFzc05hbWU6IGxhYmVsQ2xhc3NOYW1lLFxuICAgIGxhYmVsT2Zmc2V0OiBsYWJlbE9mZnNldCxcbiAgICBsYWJlbFByb3BzOiBsYWJlbFByb3BzLFxuICAgIGxlZnQ6IGxlZnQsXG4gICAgbnVtVGlja3M6IG51bVRpY2tzLFxuICAgIG9yaWVudGF0aW9uOiBPUklFTlQuYm90dG9tLFxuICAgIHJhbmdlUGFkZGluZzogcmFuZ2VQYWRkaW5nLFxuICAgIHNjYWxlOiBzY2FsZSxcbiAgICBzdHJva2U6IHN0cm9rZSxcbiAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgc3Ryb2tlRGFzaGFycmF5OiBzdHJva2VEYXNoYXJyYXksXG4gICAgdGlja0NsYXNzTmFtZTogdGlja0NsYXNzTmFtZSxcbiAgICB0aWNrRm9ybWF0OiB0aWNrRm9ybWF0LFxuICAgIHRpY2tMYWJlbFByb3BzOiB0aWNrTGFiZWxQcm9wcyxcbiAgICB0aWNrTGVuZ3RoOiB0aWNrTGVuZ3RoLFxuICAgIHRpY2tTdHJva2U6IHRpY2tTdHJva2UsXG4gICAgdGlja1RyYW5zZm9ybTogdGlja1RyYW5zZm9ybSxcbiAgICB0aWNrVmFsdWVzOiB0aWNrVmFsdWVzLFxuICAgIHRpY2tDb21wb25lbnQ6IHRpY2tDb21wb25lbnQsXG4gICAgdG9wOiB0b3AsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gIH0pO1xufVxuXG5BeGlzQm90dG9tLnByb3BUeXBlcyA9IHByb3BUeXBlcyQ0O1xuXG5leHBvcnQgeyBBeGlzLCBBeGlzTGVmdCwgQXhpc1JpZ2h0LCBBeGlzVG9wLCBBeGlzQm90dG9tLCBPUklFTlQgYXMgT3JpZW50YXRpb24gfTtcbiIsImZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IEF4aXNCb3R0b20sIEF4aXNUb3AgfSBmcm9tICdAdngvYXhpcyc7XG5pbXBvcnQgeyBheGlzU3R5bGVzU2hhcGUsIHRpY2tTdHlsZXNTaGFwZSB9IGZyb20gJy4uL3V0aWxzL3Byb3BTaGFwZXMnO1xudmFyIHByb3BUeXBlcyA9IHtcbiAgYXhpc1N0eWxlczogYXhpc1N0eWxlc1NoYXBlLFxuICBoaWRlWmVybzogUHJvcFR5cGVzLmJvb2wsXG4gIGxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBsYWJlbE9mZnNldDogUHJvcFR5cGVzLm51bWJlcixcbiAgbGFiZWxQcm9wczogUHJvcFR5cGVzLm9iamVjdE9mKFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSksXG4gIG51bVRpY2tzOiBQcm9wVHlwZXMubnVtYmVyLFxuICBvcmllbnRhdGlvbjogUHJvcFR5cGVzLm9uZU9mKFsnYm90dG9tJywgJ3RvcCddKSxcbiAgcmFuZ2VQYWRkaW5nOiBQcm9wVHlwZXMubnVtYmVyLFxuICB0aWNrU3R5bGVzOiB0aWNrU3R5bGVzU2hhcGUsXG4gIHRpY2tDb21wb25lbnQ6IFByb3BUeXBlcy5mdW5jLFxuICB0aWNrTGFiZWxQcm9wczogUHJvcFR5cGVzLmZ1bmMsXG4gIHRpY2tGb3JtYXQ6IFByb3BUeXBlcy5mdW5jLFxuICB0aWNrVmFsdWVzOiBQcm9wVHlwZXMuYXJyYXlPZiggLy8gbnVtYmVyIG9yIGRhdGUvbW9tZW50IG9iamVjdFxuICBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMub2JqZWN0LCBQcm9wVHlwZXMuc3RyaW5nXSkpLFxuICAvLyBwcm9iYWJseSBpbmplY3RlZCBieSBwYXJlbnRcbiAgaW5uZXJIZWlnaHQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIHNjYWxlOiBQcm9wVHlwZXMuZnVuY1xufTtcbnZhciBkZWZhdWx0UHJvcHMgPSB7XG4gIGF4aXNTdHlsZXM6IHt9LFxuICBoaWRlWmVybzogZmFsc2UsXG4gIGlubmVySGVpZ2h0OiBudWxsLFxuICBsYWJlbDogbnVsbCxcbiAgbGFiZWxPZmZzZXQ6IDE0LFxuICBsYWJlbFByb3BzOiBudWxsLFxuICBudW1UaWNrczogbnVsbCxcbiAgb3JpZW50YXRpb246ICdib3R0b20nLFxuICByYW5nZVBhZGRpbmc6IG51bGwsXG4gIHNjYWxlOiBudWxsLFxuICB0aWNrQ29tcG9uZW50OiBudWxsLFxuICB0aWNrRm9ybWF0OiBudWxsLFxuICB0aWNrTGFiZWxQcm9wczogbnVsbCxcbiAgdGlja1N0eWxlczoge30sXG4gIHRpY2tWYWx1ZXM6IHVuZGVmaW5lZFxufTtcblxudmFyIFhBeGlzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUmVhY3QkUHVyZUNvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShYQXhpcywgX1JlYWN0JFB1cmVDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFhBeGlzKCkge1xuICAgIHJldHVybiBfUmVhY3QkUHVyZUNvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gWEF4aXMucHJvdG90eXBlO1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgYXhpc1N0eWxlcyA9IF90aGlzJHByb3BzLmF4aXNTdHlsZXMsXG4gICAgICAgIGlubmVySGVpZ2h0ID0gX3RoaXMkcHJvcHMuaW5uZXJIZWlnaHQsXG4gICAgICAgIGhpZGVaZXJvID0gX3RoaXMkcHJvcHMuaGlkZVplcm8sXG4gICAgICAgIGxhYmVsID0gX3RoaXMkcHJvcHMubGFiZWwsXG4gICAgICAgIGxhYmVsT2Zmc2V0ID0gX3RoaXMkcHJvcHMubGFiZWxPZmZzZXQsXG4gICAgICAgIGxhYmVsUHJvcHMgPSBfdGhpcyRwcm9wcy5sYWJlbFByb3BzLFxuICAgICAgICBudW1UaWNrcyA9IF90aGlzJHByb3BzLm51bVRpY2tzLFxuICAgICAgICBvcmllbnRhdGlvbiA9IF90aGlzJHByb3BzLm9yaWVudGF0aW9uLFxuICAgICAgICByYW5nZVBhZGRpbmcgPSBfdGhpcyRwcm9wcy5yYW5nZVBhZGRpbmcsXG4gICAgICAgIHNjYWxlID0gX3RoaXMkcHJvcHMuc2NhbGUsXG4gICAgICAgIHRpY2tDb21wb25lbnQgPSBfdGhpcyRwcm9wcy50aWNrQ29tcG9uZW50LFxuICAgICAgICB0aWNrRm9ybWF0ID0gX3RoaXMkcHJvcHMudGlja0Zvcm1hdCxcbiAgICAgICAgcGFzc2VkVGlja0xhYmVsUHJvcHMgPSBfdGhpcyRwcm9wcy50aWNrTGFiZWxQcm9wcyxcbiAgICAgICAgdGlja1N0eWxlcyA9IF90aGlzJHByb3BzLnRpY2tTdHlsZXMsXG4gICAgICAgIHRpY2tWYWx1ZXMgPSBfdGhpcyRwcm9wcy50aWNrVmFsdWVzO1xuICAgIGlmICghc2NhbGUgfHwgIWlubmVySGVpZ2h0KSByZXR1cm4gbnVsbDtcbiAgICB2YXIgQXhpcyA9IG9yaWVudGF0aW9uID09PSAnYm90dG9tJyA/IEF4aXNCb3R0b20gOiBBeGlzVG9wO1xuICAgIHZhciB0aWNrTGFiZWxQcm9wcyA9IHBhc3NlZFRpY2tMYWJlbFByb3BzO1xuXG4gICAgaWYgKCF0aWNrTGFiZWxQcm9wcykge1xuICAgICAgdGlja0xhYmVsUHJvcHMgPSB0aWNrU3R5bGVzLmxhYmVsICYmIHRpY2tTdHlsZXMubGFiZWxbb3JpZW50YXRpb25dID8gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGlja1N0eWxlcy5sYWJlbFtvcmllbnRhdGlvbl07XG4gICAgICB9IDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEF4aXMsIHtcbiAgICAgIHRvcDogb3JpZW50YXRpb24gPT09ICdib3R0b20nID8gaW5uZXJIZWlnaHQgOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHJhbmdlUGFkZGluZzogcmFuZ2VQYWRkaW5nLFxuICAgICAgaGlkZVRpY2tzOiBudW1UaWNrcyA9PT0gMCxcbiAgICAgIGhpZGVaZXJvOiBoaWRlWmVybyxcbiAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgIGxhYmVsT2Zmc2V0OiBsYWJlbE9mZnNldCxcbiAgICAgIGxhYmVsUHJvcHM6IGxhYmVsUHJvcHMgfHwgKGF4aXNTdHlsZXMubGFiZWwgfHwge30pW29yaWVudGF0aW9uXSxcbiAgICAgIG51bVRpY2tzOiBudW1UaWNrcyxcbiAgICAgIHNjYWxlOiBzY2FsZSxcbiAgICAgIHN0cm9rZTogYXhpc1N0eWxlcy5zdHJva2UsXG4gICAgICBzdHJva2VXaWR0aDogYXhpc1N0eWxlcy5zdHJva2VXaWR0aCxcbiAgICAgIHRpY2tDb21wb25lbnQ6IHRpY2tDb21wb25lbnQsXG4gICAgICB0aWNrRm9ybWF0OiB0aWNrRm9ybWF0LFxuICAgICAgdGlja0xhYmVsUHJvcHM6IHRpY2tMYWJlbFByb3BzLFxuICAgICAgdGlja0xlbmd0aDogdGlja1N0eWxlcy50aWNrTGVuZ3RoLFxuICAgICAgdGlja1N0cm9rZTogdGlja1N0eWxlcy5zdHJva2UsXG4gICAgICB0aWNrVmFsdWVzOiB0aWNrVmFsdWVzXG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFhBeGlzO1xufShSZWFjdC5QdXJlQ29tcG9uZW50KTtcblxuZXhwb3J0IHsgWEF4aXMgYXMgZGVmYXVsdCB9O1xuWEF4aXMucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xuWEF4aXMuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuWEF4aXMuZGlzcGxheU5hbWUgPSAnWEF4aXMnOyIsImZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IEF4aXNMZWZ0LCBBeGlzUmlnaHQgfSBmcm9tICdAdngvYXhpcyc7XG5pbXBvcnQgeyBheGlzU3R5bGVzU2hhcGUsIHRpY2tTdHlsZXNTaGFwZSB9IGZyb20gJy4uL3V0aWxzL3Byb3BTaGFwZXMnO1xudmFyIHByb3BUeXBlcyA9IHtcbiAgYXhpc1N0eWxlczogYXhpc1N0eWxlc1NoYXBlLFxuICBoaWRlWmVybzogUHJvcFR5cGVzLmJvb2wsXG4gIGxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBsYWJlbFByb3BzOiBQcm9wVHlwZXMub2JqZWN0T2YoUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pKSxcbiAgbGFiZWxPZmZzZXQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIG51bVRpY2tzOiBQcm9wVHlwZXMubnVtYmVyLFxuICBvcmllbnRhdGlvbjogUHJvcFR5cGVzLm9uZU9mKFsnbGVmdCcsICdyaWdodCddKSxcbiAgcmFuZ2VQYWRkaW5nOiBQcm9wVHlwZXMubnVtYmVyLFxuICB0aWNrQ29tcG9uZW50OiBQcm9wVHlwZXMuZnVuYyxcbiAgdGlja1N0eWxlczogdGlja1N0eWxlc1NoYXBlLFxuICB0aWNrTGFiZWxQcm9wczogUHJvcFR5cGVzLmZ1bmMsXG4gIHRpY2tGb3JtYXQ6IFByb3BUeXBlcy5mdW5jLFxuICB0aWNrVmFsdWVzOiBQcm9wVHlwZXMuYXJyYXlPZiggLy8gbnVtYmVyIG9yIGRhdGUvbW9tZW50IG9iamVjdFxuICBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMub2JqZWN0LCBQcm9wVHlwZXMuc3RyaW5nXSkpLFxuICAvLyBwcm9iYWJseSBpbmplY3RlZCBieSBwYXJlbnRcbiAgaW5uZXJXaWR0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgaGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLFxuICBzY2FsZTogUHJvcFR5cGVzLmZ1bmNcbn07XG52YXIgZGVmYXVsdFByb3BzID0ge1xuICBheGlzU3R5bGVzOiB7fSxcbiAgaGlkZVplcm86IGZhbHNlLFxuICBpbm5lcldpZHRoOiBudWxsLFxuICBoZWlnaHQ6IG51bGwsXG4gIGxhYmVsOiBudWxsLFxuICBsYWJlbFByb3BzOiBudWxsLFxuICBsYWJlbE9mZnNldDogdW5kZWZpbmVkLFxuICBudW1UaWNrczogbnVsbCxcbiAgb3JpZW50YXRpb246ICdyaWdodCcsXG4gIHJhbmdlUGFkZGluZzogbnVsbCxcbiAgc2NhbGU6IG51bGwsXG4gIHRpY2tDb21wb25lbnQ6IG51bGwsXG4gIHRpY2tGb3JtYXQ6IG51bGwsXG4gIHRpY2tMYWJlbFByb3BzOiBudWxsLFxuICB0aWNrU3R5bGVzOiB7fSxcbiAgdGlja1ZhbHVlczogdW5kZWZpbmVkXG59O1xuXG52YXIgWUF4aXMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9SZWFjdCRQdXJlQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKFlBeGlzLCBfUmVhY3QkUHVyZUNvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gWUF4aXMoKSB7XG4gICAgcmV0dXJuIF9SZWFjdCRQdXJlQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBZQXhpcy5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBheGlzU3R5bGVzID0gX3RoaXMkcHJvcHMuYXhpc1N0eWxlcyxcbiAgICAgICAgaGlkZVplcm8gPSBfdGhpcyRwcm9wcy5oaWRlWmVybyxcbiAgICAgICAgaW5uZXJXaWR0aCA9IF90aGlzJHByb3BzLmlubmVyV2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF90aGlzJHByb3BzLmhlaWdodCxcbiAgICAgICAgbGFiZWwgPSBfdGhpcyRwcm9wcy5sYWJlbCxcbiAgICAgICAgbGFiZWxQcm9wcyA9IF90aGlzJHByb3BzLmxhYmVsUHJvcHMsXG4gICAgICAgIGxhYmVsT2Zmc2V0ID0gX3RoaXMkcHJvcHMubGFiZWxPZmZzZXQsXG4gICAgICAgIG51bVRpY2tzID0gX3RoaXMkcHJvcHMubnVtVGlja3MsXG4gICAgICAgIG9yaWVudGF0aW9uID0gX3RoaXMkcHJvcHMub3JpZW50YXRpb24sXG4gICAgICAgIHJhbmdlUGFkZGluZyA9IF90aGlzJHByb3BzLnJhbmdlUGFkZGluZyxcbiAgICAgICAgc2NhbGUgPSBfdGhpcyRwcm9wcy5zY2FsZSxcbiAgICAgICAgdGlja0NvbXBvbmVudCA9IF90aGlzJHByb3BzLnRpY2tDb21wb25lbnQsXG4gICAgICAgIHRpY2tGb3JtYXQgPSBfdGhpcyRwcm9wcy50aWNrRm9ybWF0LFxuICAgICAgICBwYXNzZWRUaWNrTGFiZWxQcm9wcyA9IF90aGlzJHByb3BzLnRpY2tMYWJlbFByb3BzLFxuICAgICAgICB0aWNrU3R5bGVzID0gX3RoaXMkcHJvcHMudGlja1N0eWxlcyxcbiAgICAgICAgdGlja1ZhbHVlcyA9IF90aGlzJHByb3BzLnRpY2tWYWx1ZXM7XG4gICAgaWYgKCFzY2FsZSB8fCAhaW5uZXJXaWR0aCkgcmV0dXJuIG51bGw7XG4gICAgdmFyIEF4aXMgPSBvcmllbnRhdGlvbiA9PT0gJ2xlZnQnID8gQXhpc0xlZnQgOiBBeGlzUmlnaHQ7XG4gICAgdmFyIHRpY2tMYWJlbFByb3BzID0gcGFzc2VkVGlja0xhYmVsUHJvcHM7XG5cbiAgICBpZiAoIXRpY2tMYWJlbFByb3BzKSB7XG4gICAgICB0aWNrTGFiZWxQcm9wcyA9IHRpY2tTdHlsZXMubGFiZWwgJiYgdGlja1N0eWxlcy5sYWJlbFtvcmllbnRhdGlvbl0gPyBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aWNrU3R5bGVzLmxhYmVsW29yaWVudGF0aW9uXTtcbiAgICAgIH0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQXhpcywge1xuICAgICAgdG9wOiAwLFxuICAgICAgbGVmdDogb3JpZW50YXRpb24gPT09ICdyaWdodCcgPyBpbm5lcldpZHRoIDogMCxcbiAgICAgIHJhbmdlUGFkZGluZzogcmFuZ2VQYWRkaW5nLFxuICAgICAgaGlkZVRpY2tzOiBudW1UaWNrcyA9PT0gMCxcbiAgICAgIGhpZGVaZXJvOiBoaWRlWmVybyxcbiAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgIGxhYmVsUHJvcHM6IF9leHRlbmRzKHtcbiAgICAgICAgdmVydGljYWxBbmNob3I6ICdzdGFydCcsXG4gICAgICAgIHdpZHRoOiBNYXRoLm1heC5hcHBseShNYXRoLCBzY2FsZS5yYW5nZSgpLmNvbmNhdChbaGVpZ2h0IHx8IDBdKSlcbiAgICAgIH0sIGxhYmVsUHJvcHMgfHwgKGF4aXNTdHlsZXMubGFiZWwgfHwge30pW29yaWVudGF0aW9uXSksXG4gICAgICBsYWJlbE9mZnNldDogbGFiZWxPZmZzZXQsXG4gICAgICBudW1UaWNrczogbnVtVGlja3MsXG4gICAgICBzY2FsZTogc2NhbGUsXG4gICAgICBzdHJva2U6IGF4aXNTdHlsZXMuc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGg6IGF4aXNTdHlsZXMuc3Ryb2tlV2lkdGgsXG4gICAgICB0aWNrQ29tcG9uZW50OiB0aWNrQ29tcG9uZW50LFxuICAgICAgdGlja0Zvcm1hdDogdGlja0Zvcm1hdCxcbiAgICAgIHRpY2tMYWJlbFByb3BzOiB0aWNrTGFiZWxQcm9wcyxcbiAgICAgIHRpY2tMZW5ndGg6IHRpY2tTdHlsZXMudGlja0xlbmd0aCxcbiAgICAgIHRpY2tTdHJva2U6IHRpY2tTdHlsZXMuc3Ryb2tlLFxuICAgICAgdGlja1ZhbHVlczogdGlja1ZhbHVlc1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBZQXhpcztcbn0oUmVhY3QuUHVyZUNvbXBvbmVudCk7XG5cbmV4cG9ydCB7IFlBeGlzIGFzIGRlZmF1bHQgfTtcbllBeGlzLnByb3BUeXBlcyA9IHByb3BUeXBlcztcbllBeGlzLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbllBeGlzLmRpc3BsYXlOYW1lID0gJ1lBeGlzJzsiLCJpbXBvcnQgUmVhY3QsIHsgQ1NTUHJvcGVydGllcyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IERpbWVuc2lvbiB9IGZyb20gJ0BzdXBlcnNldC11aS9jb3JlJztcbmltcG9ydCB7IEF4aXNMYXlvdXQgfSBmcm9tICcuL2NvbXB1dGVBeGlzTGF5b3V0JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlVGlja0NvbXBvbmVudCh7XG4gIGF4aXNXaWR0aCxcbiAgbGFiZWxBbmdsZSxcbiAgbGFiZWxGbHVzaCxcbiAgbGFiZWxPdmVybGFwLFxuICBvcmllbnQsXG4gIHRpY2tMYWJlbHMsXG4gIHRpY2tMYWJlbERpbWVuc2lvbnMsXG4gIHRpY2tUZXh0QW5jaG9yID0gJ21pZGRsZScsXG59OiBBeGlzTGF5b3V0KSB7XG4gIGlmIChsYWJlbE92ZXJsYXAgPT09ICdyb3RhdGUnICYmIGxhYmVsQW5nbGUgIT09IDApIHtcbiAgICBsZXQgeE9mZnNldCA9IGxhYmVsQW5nbGUgPiAwID8gLTYgOiA2O1xuICAgIGlmIChvcmllbnQgPT09ICd0b3AnKSB7XG4gICAgICB4T2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgY29uc3QgeU9mZnNldCA9IG9yaWVudCA9PT0gJ3RvcCcgPyAtMyA6IDA7XG5cbiAgICByZXR1cm4gKHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgZm9ybWF0dGVkVmFsdWUgPSAnJyxcbiAgICAgIC4uLnRleHRTdHlsZVxuICAgIH06IHtcbiAgICAgIHg6IG51bWJlcjtcbiAgICAgIHk6IG51bWJlcjtcbiAgICAgIGR5PzogbnVtYmVyO1xuICAgICAgZm9ybWF0dGVkVmFsdWU6IHN0cmluZztcbiAgICAgIHRleHRTdHlsZTogQ1NTUHJvcGVydGllcztcbiAgICB9KSA9PiAoXG4gICAgICA8ZyB0cmFuc2Zvcm09e2B0cmFuc2xhdGUoJHt4ICsgeE9mZnNldH0sICR7eSArIHlPZmZzZXR9KWB9PlxuICAgICAgICA8dGV4dCB0cmFuc2Zvcm09e2Byb3RhdGUoJHtsYWJlbEFuZ2xlfSlgfSB7Li4udGV4dFN0eWxlfSB0ZXh0QW5jaG9yPXt0aWNrVGV4dEFuY2hvcn0+XG4gICAgICAgICAge2Zvcm1hdHRlZFZhbHVlfVxuICAgICAgICA8L3RleHQ+XG4gICAgICA8L2c+XG4gICAgKTtcbiAgfVxuXG4gIGlmIChsYWJlbEZsdXNoID09PSB0cnVlIHx8IHR5cGVvZiBsYWJlbEZsdXNoID09PSAnbnVtYmVyJykge1xuICAgIGNvbnN0IGxhYmVsVG9EaW1lbnNpb25NYXAgPSBuZXcgTWFwPHN0cmluZywgRGltZW5zaW9uPigpO1xuICAgIHRpY2tMYWJlbHMuZm9yRWFjaCgobGFiZWwsIGkpID0+IHtcbiAgICAgIGxhYmVsVG9EaW1lbnNpb25NYXAuc2V0KGxhYmVsLCB0aWNrTGFiZWxEaW1lbnNpb25zW2ldKTtcbiAgICB9KTtcblxuICAgIHJldHVybiAoe1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBmb3JtYXR0ZWRWYWx1ZSA9ICcnLFxuICAgICAgLi4udGV4dFN0eWxlXG4gICAgfToge1xuICAgICAgeDogbnVtYmVyO1xuICAgICAgeTogbnVtYmVyO1xuICAgICAgZHk/OiBudW1iZXI7XG4gICAgICBmb3JtYXR0ZWRWYWx1ZTogc3RyaW5nO1xuICAgICAgdGV4dFN0eWxlOiBDU1NQcm9wZXJ0aWVzO1xuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IGxhYmVsVG9EaW1lbnNpb25NYXAuZ2V0KGZvcm1hdHRlZFZhbHVlKTtcbiAgICAgIGNvbnN0IGxhYmVsV2lkdGggPSB0eXBlb2YgZGltZW5zaW9uID09PSAndW5kZWZpbmVkJyA/IDAgOiBkaW1lbnNpb24ud2lkdGg7XG4gICAgICBsZXQgdGV4dEFuY2hvciA9IHRpY2tUZXh0QW5jaG9yO1xuICAgICAgbGV0IHhPZmZzZXQgPSAwO1xuXG4gICAgICBpZiAoeCAtIGxhYmVsV2lkdGggLyAyIDwgMCkge1xuICAgICAgICB0ZXh0QW5jaG9yID0gJ3N0YXJ0JztcbiAgICAgICAgaWYgKHR5cGVvZiBsYWJlbEZsdXNoID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHhPZmZzZXQgLT0gbGFiZWxGbHVzaDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh4ICsgbGFiZWxXaWR0aCAvIDIgPiBheGlzV2lkdGgpIHtcbiAgICAgICAgdGV4dEFuY2hvciA9ICdlbmQnO1xuICAgICAgICBpZiAodHlwZW9mIGxhYmVsRmx1c2ggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgeE9mZnNldCArPSBsYWJlbEZsdXNoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgIDx0ZXh0IHg9e3ggKyB4T2Zmc2V0fSB5PXt5fSB7Li4udGV4dFN0eWxlfSB0ZXh0QW5jaG9yPXt0ZXh0QW5jaG9yfT5cbiAgICAgICAgICB7Zm9ybWF0dGVkVmFsdWV9XG4gICAgICAgIDwvdGV4dD5cbiAgICAgICk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIFRoaXMgd2lsbCByZW5kZXIgdGhlIHRpY2sgYXMgaG9yaXpvbnRhbCBzdHJpbmcuXG4gIHJldHVybiBudWxsO1xufVxuIiwiaW1wb3J0IHsgQ1NTUHJvcGVydGllcyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGdldFRleHREaW1lbnNpb24sIE1hcmdpbiwgRGltZW5zaW9uIH0gZnJvbSAnQHN1cGVyc2V0LXVpL2NvcmUnO1xuaW1wb3J0IHsgQXhpc09yaWVudCwgQ2hhbm5lbERlZiwgVmFsdWUgfSBmcm9tICdlbmNvZGFibGUnO1xuXG5pbXBvcnQgQ2hhbm5lbEVuY29kZXJBeGlzIGZyb20gJ2VuY29kYWJsZS9saWIvZW5jb2RlcnMvQ2hhbm5lbEVuY29kZXJBeGlzJztcblxuZXhwb3J0IGludGVyZmFjZSBBeGlzTGF5b3V0IHtcbiAgYXhpc1dpZHRoOiBudW1iZXI7XG4gIGxhYmVsQW5nbGU6IG51bWJlcjtcbiAgbGFiZWxGbHVzaDogbnVtYmVyIHwgYm9vbGVhbjtcbiAgbGFiZWxPZmZzZXQ6IG51bWJlcjtcbiAgbGFiZWxPdmVybGFwOiAnZmxhdCcgfCAncm90YXRlJztcbiAgbWluTWFyZ2luOiBQYXJ0aWFsPE1hcmdpbj47XG4gIG9yaWVudDogQXhpc09yaWVudDtcbiAgdGlja0xhYmVsRGltZW5zaW9uczogRGltZW5zaW9uW107XG4gIHRpY2tMYWJlbHM6IHN0cmluZ1tdO1xuICB0aWNrVGV4dEFuY2hvcj86IHN0cmluZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcHV0ZUF4aXNMYXlvdXQ8RGVmIGV4dGVuZHMgQ2hhbm5lbERlZjxPdXRwdXQ+LCBPdXRwdXQgZXh0ZW5kcyBWYWx1ZT4oXG4gIGF4aXM6IENoYW5uZWxFbmNvZGVyQXhpczxEZWYsIE91dHB1dD4sXG4gIHtcbiAgICBheGlzVGl0bGVIZWlnaHQgPSAyMCxcbiAgICBheGlzV2lkdGgsXG4gICAgZ2FwQmV0d2VlbkF4aXNMYWJlbEFuZEJvcmRlciA9IDQsXG4gICAgZ2FwQmV0d2VlblRpY2tBbmRUaWNrTGFiZWwgPSA0LFxuICAgIGRlZmF1bHRUaWNrU2l6ZSA9IDgsXG4gICAgdGlja1RleHRTdHlsZSA9IHt9LFxuICB9OiB7XG4gICAgYXhpc1RpdGxlSGVpZ2h0PzogbnVtYmVyO1xuICAgIGF4aXNXaWR0aDogbnVtYmVyO1xuICAgIGdhcEJldHdlZW5BeGlzTGFiZWxBbmRCb3JkZXI/OiBudW1iZXI7XG4gICAgZ2FwQmV0d2VlblRpY2tBbmRUaWNrTGFiZWw/OiBudW1iZXI7XG4gICAgZGVmYXVsdFRpY2tTaXplPzogbnVtYmVyO1xuICAgIHRpY2tUZXh0U3R5bGU/OiBDU1NQcm9wZXJ0aWVzO1xuICB9LFxuKTogQXhpc0xheW91dCB7XG4gIGNvbnN0IHRpY2tMYWJlbHMgPSBheGlzLmdldFRpY2tMYWJlbHMoKTtcbiAgY29uc3QgdGlja0xhYmVsRGltZW5zaW9ucyA9IHRpY2tMYWJlbHMubWFwKCh0ZXh0OiBzdHJpbmcpID0+XG4gICAgZ2V0VGV4dERpbWVuc2lvbih7XG4gICAgICBzdHlsZTogdGlja1RleHRTdHlsZSxcbiAgICAgIHRleHQsXG4gICAgfSksXG4gICk7XG5cbiAgY29uc3Qge1xuICAgIGxhYmVsQW5nbGUsXG4gICAgbGFiZWxGbHVzaCxcbiAgICBsYWJlbE92ZXJsYXAsXG4gICAgbGFiZWxQYWRkaW5nLFxuICAgIG9yaWVudCxcbiAgICB0aWNrU2l6ZSA9IGRlZmF1bHRUaWNrU2l6ZSxcbiAgfSA9IGF4aXMuY29uZmlnO1xuXG4gIGNvbnN0IG1heFdpZHRoID0gTWF0aC5tYXgoLi4udGlja0xhYmVsRGltZW5zaW9ucy5tYXAoZCA9PiBkLndpZHRoKSwgMCk7XG5cbiAgLy8gY2hlYXAgaGV1cmlzdGljLCBjYW4gaW1wcm92ZVxuICBjb25zdCB3aWR0aFBlclRpY2sgPSBheGlzV2lkdGggLyB0aWNrTGFiZWxzLmxlbmd0aDtcbiAgY29uc3QgaXNMYWJlbE92ZXJsYXAgPSBtYXhXaWR0aCA+IHdpZHRoUGVyVGljaztcbiAgY29uc3QgbGFiZWxBbmdsZUlmT3ZlcmxhcCA9IGxhYmVsT3ZlcmxhcC5zdHJhdGVneSA9PT0gJ3JvdGF0ZScgPyBsYWJlbE92ZXJsYXAubGFiZWxBbmdsZSA6IDA7XG4gIGNvbnN0IGxhYmVsQW5nbGVBZnRlck92ZXJsYXBDaGVjayA9IGlzTGFiZWxPdmVybGFwID8gbGFiZWxBbmdsZUlmT3ZlcmxhcCA6IDA7XG4gIGNvbnN0IGZpbmFsTGFiZWxBbmdsZSA9IGxhYmVsQW5nbGUgPT09IDAgPyBsYWJlbEFuZ2xlQWZ0ZXJPdmVybGFwQ2hlY2sgOiBsYWJlbEFuZ2xlO1xuXG4gIGNvbnN0IHNwYWNlRm9yQXhpc1RpdGxlID0gYXhpcy5oYXNUaXRsZSgpID8gbGFiZWxQYWRkaW5nICsgYXhpc1RpdGxlSGVpZ2h0IDogMDtcbiAgbGV0IHRpY2tUZXh0QW5jaG9yID0gJ21pZGRsZSc7XG4gIGxldCBsYWJlbE9mZnNldCA9IDA7XG4gIGxldCByZXF1aXJlZE1hcmdpbiA9XG4gICAgdGlja1NpemUgKyBnYXBCZXR3ZWVuVGlja0FuZFRpY2tMYWJlbCArIHNwYWNlRm9yQXhpc1RpdGxlICsgZ2FwQmV0d2VlbkF4aXNMYWJlbEFuZEJvcmRlcjtcblxuICBpZiAoYXhpcy5jaGFubmVsRW5jb2Rlci5pc1goKSkge1xuICAgIGlmIChmaW5hbExhYmVsQW5nbGUgPT09IDApIHtcbiAgICAgIGNvbnN0IGxhYmVsSGVpZ2h0ID0gdGlja0xhYmVsRGltZW5zaW9ucy5sZW5ndGggPiAwID8gdGlja0xhYmVsRGltZW5zaW9uc1swXS5oZWlnaHQgOiAwO1xuICAgICAgbGFiZWxPZmZzZXQgPSBsYWJlbEhlaWdodCArIGxhYmVsUGFkZGluZztcbiAgICAgIHJlcXVpcmVkTWFyZ2luICs9IGxhYmVsSGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsYWJlbEhlaWdodCA9IE1hdGguY2VpbChcbiAgICAgICAgTWF0aC5hYnMobWF4V2lkdGggKiBNYXRoLnNpbigoZmluYWxMYWJlbEFuZ2xlICogTWF0aC5QSSkgLyAxODApKSxcbiAgICAgICk7XG4gICAgICBsYWJlbE9mZnNldCA9IGxhYmVsSGVpZ2h0ICsgbGFiZWxQYWRkaW5nO1xuICAgICAgcmVxdWlyZWRNYXJnaW4gKz0gbGFiZWxIZWlnaHQ7XG4gICAgICB0aWNrVGV4dEFuY2hvciA9XG4gICAgICAgIChvcmllbnQgPT09ICd0b3AnICYmIGZpbmFsTGFiZWxBbmdsZSA+IDApIHx8IChvcmllbnQgPT09ICdib3R0b20nICYmIGZpbmFsTGFiZWxBbmdsZSA8IDApXG4gICAgICAgICAgPyAnZW5kJ1xuICAgICAgICAgIDogJ3N0YXJ0JztcbiAgICB9XG4gICAgcmVxdWlyZWRNYXJnaW4gKz0gODtcbiAgfSBlbHNlIHtcbiAgICBsYWJlbE9mZnNldCA9IG1heFdpZHRoICsgc3BhY2VGb3JBeGlzVGl0bGU7XG4gICAgcmVxdWlyZWRNYXJnaW4gKz0gbWF4V2lkdGg7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGF4aXNXaWR0aCxcbiAgICBsYWJlbEFuZ2xlOiBmaW5hbExhYmVsQW5nbGUsXG4gICAgbGFiZWxGbHVzaCxcbiAgICBsYWJlbE9mZnNldCxcbiAgICBsYWJlbE92ZXJsYXA6IGlzTGFiZWxPdmVybGFwID8gbGFiZWxPdmVybGFwLnN0cmF0ZWd5IDogJ2ZsYXQnLFxuICAgIG1pbk1hcmdpbjoge1xuICAgICAgW29yaWVudF06IE1hdGguY2VpbChyZXF1aXJlZE1hcmdpbiksXG4gICAgfSxcbiAgICBvcmllbnQsXG4gICAgdGlja0xhYmVsRGltZW5zaW9ucyxcbiAgICB0aWNrTGFiZWxzLFxuICAgIHRpY2tUZXh0QW5jaG9yLFxuICB9O1xufVxuIiwiaW1wb3J0IFJlYWN0LCB7IFJlYWN0Tm9kZSwgQ1NTUHJvcGVydGllcyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFhBeGlzLCBZQXhpcyB9IGZyb20gJ0BkYXRhLXVpL3h5LWNoYXJ0JztcbmltcG9ydCB7IENoYXJ0RnJhbWUsIE1hcmdpbiwgbWVyZ2VNYXJnaW4sIERpbWVuc2lvbiB9IGZyb20gJ0BzdXBlcnNldC11aS9jb3JlJztcbmltcG9ydCB7IENoYW5uZWxFbmNvZGVyLCBQbGFpbk9iamVjdCwgVmFsdWUsIFhGaWVsZERlZiwgWUZpZWxkRGVmIH0gZnJvbSAnZW5jb2RhYmxlJztcbmltcG9ydCBjcmVhdGVUaWNrQ29tcG9uZW50IGZyb20gJy4vY3JlYXRlVGlja0NvbXBvbmVudCc7XG5pbXBvcnQgY29tcHV0ZUF4aXNMYXlvdXQsIHsgQXhpc0xheW91dCB9IGZyb20gJy4vY29tcHV0ZUF4aXNMYXlvdXQnO1xuXG5leHBvcnQgY29uc3QgREVGQVVMVF9MQUJFTF9BTkdMRSA9IDQwO1xuXG4vLyBBZGRpdGlvbmFsIG1hcmdpbiB0byBhdm9pZCBjb250ZW50IGhpZGRlbiBiZWhpbmQgc2Nyb2xsIGJhclxuY29uc3QgT1ZFUkZMT1dfTUFSR0lOID0gODtcblxuZXhwb3J0IGludGVyZmFjZSBYWUNoYXJ0TGF5b3V0Q29uZmlnPFhPdXRwdXQgZXh0ZW5kcyBWYWx1ZSwgWU91dHB1dCBleHRlbmRzIFZhbHVlPiB7XG4gIHdpZHRoOiBudW1iZXI7XG4gIGhlaWdodDogbnVtYmVyO1xuICBtaW5Db250ZW50V2lkdGg/OiBudW1iZXI7XG4gIG1pbkNvbnRlbnRIZWlnaHQ/OiBudW1iZXI7XG4gIG1hcmdpbjogTWFyZ2luO1xuICB4RW5jb2RlcjogQ2hhbm5lbEVuY29kZXI8WEZpZWxkRGVmPFhPdXRwdXQ+LCBYT3V0cHV0PjtcbiAgeFRpY2tTaXplPzogbnVtYmVyO1xuICB4VGlja1RleHRTdHlsZT86IENTU1Byb3BlcnRpZXM7XG4gIGF1dG9BZGp1c3RYTWFyZ2luPzogYm9vbGVhbjtcbiAgeUVuY29kZXI6IENoYW5uZWxFbmNvZGVyPFlGaWVsZERlZjxZT3V0cHV0PiwgWU91dHB1dD47XG4gIHlUaWNrU2l6ZT86IG51bWJlcjtcbiAgeVRpY2tUZXh0U3R5bGU/OiBDU1NQcm9wZXJ0aWVzO1xuICBhdXRvQWRqdXN0WU1hcmdpbj86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFhZQ2hhcnRMYXlvdXQ8WE91dHB1dCBleHRlbmRzIFZhbHVlLCBZT3V0cHV0IGV4dGVuZHMgVmFsdWU+IHtcbiAgY2hhcnRXaWR0aDogbnVtYmVyO1xuXG4gIGNoYXJ0SGVpZ2h0OiBudW1iZXI7XG5cbiAgY29udGFpbmVyV2lkdGg6IG51bWJlcjtcblxuICBjb250YWluZXJIZWlnaHQ6IG51bWJlcjtcblxuICBtYXJnaW46IE1hcmdpbjtcblxuICB4RW5jb2RlcjogQ2hhbm5lbEVuY29kZXI8WEZpZWxkRGVmPFhPdXRwdXQ+LCBYT3V0cHV0PjtcblxuICB4TGF5b3V0PzogQXhpc0xheW91dDtcblxuICB5RW5jb2RlcjogQ2hhbm5lbEVuY29kZXI8WUZpZWxkRGVmPFlPdXRwdXQ+LCBZT3V0cHV0PjtcblxuICB5TGF5b3V0PzogQXhpc0xheW91dDtcblxuICBjb25zdHJ1Y3Rvcihjb25maWc6IFhZQ2hhcnRMYXlvdXRDb25maWc8WE91dHB1dCwgWU91dHB1dD4pIHtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIG1pbkNvbnRlbnRXaWR0aCA9IDAsXG4gICAgICBtaW5Db250ZW50SGVpZ2h0ID0gMCxcbiAgICAgIG1hcmdpbixcbiAgICAgIHhFbmNvZGVyLFxuICAgICAgeFRpY2tTaXplLFxuICAgICAgeFRpY2tUZXh0U3R5bGUsXG4gICAgICBhdXRvQWRqdXN0WE1hcmdpbiA9IHRydWUsXG4gICAgICB5RW5jb2RlcixcbiAgICAgIHlUaWNrU2l6ZSxcbiAgICAgIHlUaWNrVGV4dFN0eWxlLFxuICAgICAgYXV0b0FkanVzdFlNYXJnaW4gPSB0cnVlLFxuICAgIH0gPSBjb25maWc7XG5cbiAgICB0aGlzLnhFbmNvZGVyID0geEVuY29kZXI7XG4gICAgdGhpcy55RW5jb2RlciA9IHlFbmNvZGVyO1xuXG4gICAgaWYgKHR5cGVvZiB5RW5jb2Rlci5heGlzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy55TGF5b3V0ID0gY29tcHV0ZUF4aXNMYXlvdXQoeUVuY29kZXIuYXhpcywge1xuICAgICAgICBheGlzV2lkdGg6IE1hdGgubWF4KGhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tKSxcbiAgICAgICAgZGVmYXVsdFRpY2tTaXplOiB5VGlja1NpemUsXG4gICAgICAgIHRpY2tUZXh0U3R5bGU6IHlUaWNrVGV4dFN0eWxlLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2Vjb25kTWFyZ2luID1cbiAgICAgIHRoaXMueUxheW91dCAmJiBhdXRvQWRqdXN0WU1hcmdpbiA/IG1lcmdlTWFyZ2luKG1hcmdpbiwgdGhpcy55TGF5b3V0Lm1pbk1hcmdpbikgOiBtYXJnaW47XG4gICAgY29uc3QgaW5uZXJXaWR0aCA9IE1hdGgubWF4KHdpZHRoIC0gc2Vjb25kTWFyZ2luLmxlZnQgLSBzZWNvbmRNYXJnaW4ucmlnaHQsIG1pbkNvbnRlbnRXaWR0aCk7XG5cbiAgICBpZiAodHlwZW9mIHhFbmNvZGVyLmF4aXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLnhMYXlvdXQgPSBjb21wdXRlQXhpc0xheW91dCh4RW5jb2Rlci5heGlzLCB7XG4gICAgICAgIGF4aXNXaWR0aDogaW5uZXJXaWR0aCxcbiAgICAgICAgZGVmYXVsdFRpY2tTaXplOiB4VGlja1NpemUsXG4gICAgICAgIHRpY2tUZXh0U3R5bGU6IHhUaWNrVGV4dFN0eWxlLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgZmluYWxNYXJnaW4gPVxuICAgICAgdGhpcy54TGF5b3V0ICYmIGF1dG9BZGp1c3RYTWFyZ2luXG4gICAgICAgID8gbWVyZ2VNYXJnaW4oc2Vjb25kTWFyZ2luLCB0aGlzLnhMYXlvdXQubWluTWFyZ2luKVxuICAgICAgICA6IHNlY29uZE1hcmdpbjtcblxuICAgIGNvbnN0IGlubmVySGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0IC0gZmluYWxNYXJnaW4udG9wIC0gZmluYWxNYXJnaW4uYm90dG9tLCBtaW5Db250ZW50SGVpZ2h0KTtcblxuICAgIGNvbnN0IGNoYXJ0V2lkdGggPSBNYXRoLnJvdW5kKGlubmVyV2lkdGggKyBmaW5hbE1hcmdpbi5sZWZ0ICsgZmluYWxNYXJnaW4ucmlnaHQpO1xuICAgIGNvbnN0IGNoYXJ0SGVpZ2h0ID0gTWF0aC5yb3VuZChpbm5lckhlaWdodCArIGZpbmFsTWFyZ2luLnRvcCArIGZpbmFsTWFyZ2luLmJvdHRvbSk7XG5cbiAgICBjb25zdCBpc092ZXJGbG93WCA9IGNoYXJ0V2lkdGggPiB3aWR0aDtcbiAgICBjb25zdCBpc092ZXJGbG93WSA9IGNoYXJ0SGVpZ2h0ID4gaGVpZ2h0O1xuICAgIGlmIChpc092ZXJGbG93WCkge1xuICAgICAgZmluYWxNYXJnaW4uYm90dG9tICs9IE9WRVJGTE9XX01BUkdJTjtcbiAgICB9XG4gICAgaWYgKGlzT3ZlckZsb3dZKSB7XG4gICAgICBmaW5hbE1hcmdpbi5yaWdodCArPSBPVkVSRkxPV19NQVJHSU47XG4gICAgfVxuICAgIHRoaXMuY2hhcnRXaWR0aCA9IGlzT3ZlckZsb3dYID8gY2hhcnRXaWR0aCArIE9WRVJGTE9XX01BUkdJTiA6IGNoYXJ0V2lkdGg7XG4gICAgdGhpcy5jaGFydEhlaWdodCA9IGlzT3ZlckZsb3dZID8gY2hhcnRIZWlnaHQgKyBPVkVSRkxPV19NQVJHSU4gOiBjaGFydEhlaWdodDtcbiAgICB0aGlzLmNvbnRhaW5lcldpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5jb250YWluZXJIZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5tYXJnaW4gPSBmaW5hbE1hcmdpbjtcbiAgfVxuXG4gIHJlbmRlckNoYXJ0V2l0aEZyYW1lKHJlbmRlckNoYXJ0OiAoaW5wdXQ6IERpbWVuc2lvbikgPT4gUmVhY3ROb2RlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxDaGFydEZyYW1lXG4gICAgICAgIHdpZHRoPXt0aGlzLmNvbnRhaW5lcldpZHRofVxuICAgICAgICBoZWlnaHQ9e3RoaXMuY29udGFpbmVySGVpZ2h0fVxuICAgICAgICBjb250ZW50V2lkdGg9e3RoaXMuY2hhcnRXaWR0aH1cbiAgICAgICAgY29udGVudEhlaWdodD17dGhpcy5jaGFydEhlaWdodH1cbiAgICAgICAgcmVuZGVyQ29udGVudD17cmVuZGVyQ2hhcnR9XG4gICAgICAvPlxuICAgICk7XG4gIH1cblxuICByZW5kZXJYQXhpcyhwcm9wcz86IFBsYWluT2JqZWN0KSB7XG4gICAgY29uc3QgeyBheGlzIH0gPSB0aGlzLnhFbmNvZGVyO1xuXG4gICAgcmV0dXJuIGF4aXMgJiYgdGhpcy54TGF5b3V0ID8gKFxuICAgICAgPFhBeGlzXG4gICAgICAgIGxhYmVsPXtheGlzLmdldFRpdGxlKCl9XG4gICAgICAgIGxhYmVsT2Zmc2V0PXt0aGlzLnhMYXlvdXQubGFiZWxPZmZzZXR9XG4gICAgICAgIG51bVRpY2tzPXtheGlzLmNvbmZpZy50aWNrQ291bnR9XG4gICAgICAgIG9yaWVudGF0aW9uPXtheGlzLmNvbmZpZy5vcmllbnR9XG4gICAgICAgIHRpY2tDb21wb25lbnQ9e2NyZWF0ZVRpY2tDb21wb25lbnQodGhpcy54TGF5b3V0KX1cbiAgICAgICAgdGlja0Zvcm1hdD17YXhpcy5mb3JtYXRWYWx1ZX1cbiAgICAgICAgey4uLnByb3BzfVxuICAgICAgLz5cbiAgICApIDogbnVsbDtcbiAgfVxuXG4gIHJlbmRlcllBeGlzKHByb3BzPzogUGxhaW5PYmplY3QpIHtcbiAgICBjb25zdCB7IGF4aXMgfSA9IHRoaXMueUVuY29kZXI7XG5cbiAgICByZXR1cm4gYXhpcyAmJiB0aGlzLnlMYXlvdXQgPyAoXG4gICAgICA8WUF4aXNcbiAgICAgICAgbGFiZWw9e2F4aXMuZ2V0VGl0bGUoKX1cbiAgICAgICAgbGFiZWxPZmZzZXQ9e3RoaXMueUxheW91dC5sYWJlbE9mZnNldH1cbiAgICAgICAgbnVtVGlja3M9e2F4aXMuY29uZmlnLnRpY2tDb3VudH1cbiAgICAgICAgb3JpZW50YXRpb249e2F4aXMuY29uZmlnLm9yaWVudH1cbiAgICAgICAgdGlja0Zvcm1hdD17YXhpcy5mb3JtYXRWYWx1ZX1cbiAgICAgICAgey4uLnByb3BzfVxuICAgICAgLz5cbiAgICApIDogbnVsbDtcbiAgfVxufVxuIiwiaW1wb3J0IHsgQ2hhcnRUaGVtZSB9IGZyb20gJ0BkYXRhLXVpL3RoZW1lJztcbmltcG9ydCB7IFZhbHVlIH0gZnJvbSAnZW5jb2RhYmxlJztcbmltcG9ydCBYWUNoYXJ0TGF5b3V0LCB7IFhZQ2hhcnRMYXlvdXRDb25maWcgfSBmcm9tICcuL1hZQ2hhcnRMYXlvdXQnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVYWUNoYXJ0TGF5b3V0V2l0aFRoZW1lPFhPdXRwdXQgZXh0ZW5kcyBWYWx1ZSwgWU91dHB1dCBleHRlbmRzIFZhbHVlPihcbiAgY29uZmlnOiBYWUNoYXJ0TGF5b3V0Q29uZmlnPFhPdXRwdXQsIFlPdXRwdXQ+ICYge1xuICAgIHRoZW1lOiBDaGFydFRoZW1lO1xuICB9LFxuKSB7XG4gIGNvbnN0IHsgdGhlbWUsIC4uLnJlc3QgfSA9IGNvbmZpZztcblxuICByZXR1cm4gbmV3IFhZQ2hhcnRMYXlvdXQ8WE91dHB1dCwgWU91dHB1dD4oe1xuICAgIC4uLnJlc3QsXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHhUaWNrU2l6ZTogdGhlbWUueFRpY2tTdHlsZXMubGVuZ3RoIHx8IHRoZW1lLnhUaWNrU3R5bGVzLnRpY2tMZW5ndGgsXG4gICAgeFRpY2tUZXh0U3R5bGU6IHRoZW1lLnhUaWNrU3R5bGVzLmxhYmVsLmJvdHRvbSB8fCB0aGVtZS54VGlja1N0eWxlcy5sYWJlbC50b3AsXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHlUaWNrU2l6ZTogdGhlbWUueVRpY2tTdHlsZXMubGVuZ3RoIHx8IHRoZW1lLnlUaWNrU3R5bGVzLnRpY2tMZW5ndGgsXG4gICAgeVRpY2tUZXh0U3R5bGU6IHRoZW1lLnlUaWNrU3R5bGVzLmxhYmVsLmxlZnQgfHwgdGhlbWUueVRpY2tTdHlsZXMubGFiZWwucmlnaHQsXG4gIH0pO1xufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDbHREQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUN6ckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDckhBO0FBSUE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBV0E7QUFFQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7Ozs7QUNyRkE7QUFrQkE7QUFrQkE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBU0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFrQkE7QUFtQkE7QUFDQTtBQWdCQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQVNBO0FBRUE7QUFDQTtBQUVBO0FBV0E7QUFFQTtBQUNBO0FBRUE7QUFVQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3hKQTtBQUVBO0FBS0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1957\n")},1958:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"a\", function() { return /* binding */ createRenderLegend; });\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react/index.js\nvar react = __webpack_require__(0);\nvar react_default = /*#__PURE__*/__webpack_require__.n(react);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/legend/esm/legends/Legend/LegendItem.js\nvar LegendItem = __webpack_require__(2298);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/legend/esm/legends/Legend/LegendLabel.js\nvar LegendLabel = __webpack_require__(2299);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/components/legend/DefaultLegendItem.tsx\n\n\nconst MARK_SIZE = 8;\nconst MARK_STYLE = { display: 'inline-block' };\nfunction DefaultLegendItem({ group, item, MarkRenderer, LabelRenderer, }) {\n    var _a, _b, _c, _d;\n    return (react_default.a.createElement(LegendItem[\"a\" /* default */], { key: `legend-item-${group.field}-${item.input}`, margin: \"0 5px\" },\n        typeof MarkRenderer === 'undefined' ? (react_default.a.createElement(\"svg\", { width: MARK_SIZE, height: MARK_SIZE, style: MARK_STYLE },\n            react_default.a.createElement(\"circle\", { fill: \n                // @ts-ignore\n                ((_c = (_b = (_a = item.output.color) !== null && _a !== void 0 ? _a : \n                // @ts-ignore\n                item.output.fill) !== null && _b !== void 0 ? _b : \n                // @ts-ignore\n                item.output.stroke) !== null && _c !== void 0 ? _c : '#ccc'), stroke: \n                // @ts-ignore\n                ((_d = item.output.stroke) !== null && _d !== void 0 ? _d : 'none'), r: MARK_SIZE / 2, cx: MARK_SIZE / 2, cy: MARK_SIZE / 2 }))) : (react_default.a.createElement(MarkRenderer, { group: group, item: item })),\n        typeof LabelRenderer === 'undefined' ? (react_default.a.createElement(LegendLabel[\"a\" /* default */], { align: \"left\", margin: \"0 0 0 4px\" }, item.input)) : (react_default.a.createElement(LabelRenderer, { group: group, item: item }))));\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/components/legend/DefaultLegendGroup.tsx\n\n\nconst LEGEND_GROUP_STYLE = {\n    display: 'flex',\n    flexBasis: 'auto',\n    flexDirection: 'row',\n    flexGrow: 1,\n    flexShrink: 1,\n    flexWrap: 'wrap',\n    fontSize: '0.8em',\n    justifyContent: 'flex-end',\n    padding: 8,\n};\nfunction DefaultLegendGroupRenderer({ group, ItemRenderer = DefaultLegendItem, ItemMarkRenderer, ItemLabelRenderer, style, }) {\n    const combinedStyle = typeof style === 'undefined' ? LEGEND_GROUP_STYLE : Object.assign(Object.assign({}, LEGEND_GROUP_STYLE), style);\n    return (react_default.a.createElement(\"div\", { style: combinedStyle }, 'items' in group &&\n        group.items.map(item => (react_default.a.createElement(ItemRenderer, { key: `legend-item-${group.field}-${item.input}`, group: group, item: item, MarkRenderer: ItemMarkRenderer, LabelRenderer: ItemLabelRenderer })))));\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/components/legend/DefaultLegend.tsx\n\n\nconst LEGEND_CONTAINER_STYLE = {\n    display: 'flex',\n    flexBasis: 'auto',\n    flexGrow: 1,\n    flexShrink: 1,\n    maxHeight: 100,\n    overflowY: 'auto',\n    position: 'relative',\n};\nclass DefaultLegend_DefaultLegend extends react[\"PureComponent\"] {\n    render() {\n        const { groups, LegendGroupRenderer = DefaultLegendGroupRenderer, LegendItemRenderer, LegendItemMarkRenderer, LegendItemLabelRenderer, style, } = this.props;\n        const combinedStyle = typeof style === 'undefined'\n            ? LEGEND_CONTAINER_STYLE\n            : Object.assign(Object.assign({}, LEGEND_CONTAINER_STYLE), style);\n        return (react_default.a.createElement(\"div\", { style: combinedStyle }, groups\n            .filter(group => 'items' in group && group.items.length > 0)\n            .map(group => (react_default.a.createElement(LegendGroupRenderer, { key: group.field, group: group, ItemRenderer: LegendItemRenderer, ItemMarkRenderer: LegendItemMarkRenderer, ItemLabelRenderer: LegendItemLabelRenderer })))));\n    }\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/components/legend/createRenderLegend.tsx\n\n\nfunction createRenderLegend(encoder, data, props) {\n    if (encoder.hasLegend()) {\n        const { LegendRenderer = DefaultLegend_DefaultLegend, LegendGroupRenderer, LegendItemRenderer, LegendItemLabelRenderer, LegendItemMarkRenderer, } = props;\n        return () => (react_default.a.createElement(LegendRenderer, { groups: encoder.getLegendInformation(data), LegendGroupRenderer: LegendGroupRenderer, LegendItemRenderer: LegendItemRenderer, LegendItemMarkRenderer: LegendItemMarkRenderer, LegendItemLabelRenderer: LegendItemLabelRenderer }));\n    }\n    return undefined;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk1OC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wcmVzZXQtY2hhcnQteHkvc3JjL2NvbXBvbmVudHMvbGVnZW5kL0RlZmF1bHRMZWdlbmRJdGVtLnRzeD9hMTZmIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wcmVzZXQtY2hhcnQteHkvc3JjL2NvbXBvbmVudHMvbGVnZW5kL0RlZmF1bHRMZWdlbmRHcm91cC50c3g/NWM4MSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvcHJlc2V0LWNoYXJ0LXh5L3NyYy9jb21wb25lbnRzL2xlZ2VuZC9EZWZhdWx0TGVnZW5kLnRzeD9jMzA1Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wcmVzZXQtY2hhcnQteHkvc3JjL2NvbXBvbmVudHMvbGVnZW5kL2NyZWF0ZVJlbmRlckxlZ2VuZC50c3g/YTk1NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgQ1NTUHJvcGVydGllcyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IExlZ2VuZEl0ZW0sIExlZ2VuZExhYmVsIH0gZnJvbSAnQHZ4L2xlZ2VuZCc7XG5pbXBvcnQgeyBFbmNvZGluZ0NvbmZpZyB9IGZyb20gJ2VuY29kYWJsZSc7XG5pbXBvcnQgeyBMZWdlbmRJdGVtUmVuZGVyZXJQcm9wcyB9IGZyb20gJy4vdHlwZXMnO1xuXG5jb25zdCBNQVJLX1NJWkUgPSA4O1xuXG5jb25zdCBNQVJLX1NUWUxFOiBDU1NQcm9wZXJ0aWVzID0geyBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyB9O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEZWZhdWx0TGVnZW5kSXRlbTxDb25maWcgZXh0ZW5kcyBFbmNvZGluZ0NvbmZpZz4oe1xuICBncm91cCxcbiAgaXRlbSxcbiAgTWFya1JlbmRlcmVyLFxuICBMYWJlbFJlbmRlcmVyLFxufTogTGVnZW5kSXRlbVJlbmRlcmVyUHJvcHM8Q29uZmlnPikge1xuICByZXR1cm4gKFxuICAgIDxMZWdlbmRJdGVtIGtleT17YGxlZ2VuZC1pdGVtLSR7Z3JvdXAuZmllbGR9LSR7aXRlbS5pbnB1dH1gfSBtYXJnaW49XCIwIDVweFwiPlxuICAgICAge3R5cGVvZiBNYXJrUmVuZGVyZXIgPT09ICd1bmRlZmluZWQnID8gKFxuICAgICAgICA8c3ZnIHdpZHRoPXtNQVJLX1NJWkV9IGhlaWdodD17TUFSS19TSVpFfSBzdHlsZT17TUFSS19TVFlMRX0+XG4gICAgICAgICAgPGNpcmNsZVxuICAgICAgICAgICAgZmlsbD17XG4gICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgKGl0ZW0ub3V0cHV0LmNvbG9yID8/XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGl0ZW0ub3V0cHV0LmZpbGwgPz9cbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgaXRlbS5vdXRwdXQuc3Ryb2tlID8/XG4gICAgICAgICAgICAgICAgJyNjY2MnKSBhcyBzdHJpbmdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cm9rZT17XG4gICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgKGl0ZW0ub3V0cHV0LnN0cm9rZSA/PyAnbm9uZScpIGFzIHN0cmluZ1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcj17TUFSS19TSVpFIC8gMn1cbiAgICAgICAgICAgIGN4PXtNQVJLX1NJWkUgLyAyfVxuICAgICAgICAgICAgY3k9e01BUktfU0laRSAvIDJ9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9zdmc+XG4gICAgICApIDogKFxuICAgICAgICA8TWFya1JlbmRlcmVyIGdyb3VwPXtncm91cH0gaXRlbT17aXRlbX0gLz5cbiAgICAgICl9XG4gICAgICB7dHlwZW9mIExhYmVsUmVuZGVyZXIgPT09ICd1bmRlZmluZWQnID8gKFxuICAgICAgICA8TGVnZW5kTGFiZWwgYWxpZ249XCJsZWZ0XCIgbWFyZ2luPVwiMCAwIDAgNHB4XCI+XG4gICAgICAgICAge2l0ZW0uaW5wdXR9XG4gICAgICAgIDwvTGVnZW5kTGFiZWw+XG4gICAgICApIDogKFxuICAgICAgICA8TGFiZWxSZW5kZXJlciBncm91cD17Z3JvdXB9IGl0ZW09e2l0ZW19IC8+XG4gICAgICApfVxuICAgIDwvTGVnZW5kSXRlbT5cbiAgKTtcbn1cbiIsImltcG9ydCBSZWFjdCwgeyBDU1NQcm9wZXJ0aWVzIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgRW5jb2RpbmdDb25maWcgfSBmcm9tICdlbmNvZGFibGUnO1xuaW1wb3J0IHsgTGVnZW5kR3JvdXBSZW5kZXJlclByb3BzIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgRGVmYXVsdExlZ2VuZEl0ZW0gZnJvbSAnLi9EZWZhdWx0TGVnZW5kSXRlbSc7XG5cbmNvbnN0IExFR0VORF9HUk9VUF9TVFlMRTogQ1NTUHJvcGVydGllcyA9IHtcbiAgZGlzcGxheTogJ2ZsZXgnLFxuICBmbGV4QmFzaXM6ICdhdXRvJyxcbiAgZmxleERpcmVjdGlvbjogJ3JvdycsXG4gIGZsZXhHcm93OiAxLFxuICBmbGV4U2hyaW5rOiAxLFxuICBmbGV4V3JhcDogJ3dyYXAnLFxuICBmb250U2l6ZTogJzAuOGVtJyxcbiAganVzdGlmeUNvbnRlbnQ6ICdmbGV4LWVuZCcsXG4gIHBhZGRpbmc6IDgsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEZWZhdWx0TGVnZW5kR3JvdXBSZW5kZXJlcjxDb25maWcgZXh0ZW5kcyBFbmNvZGluZ0NvbmZpZz4oe1xuICBncm91cCxcbiAgSXRlbVJlbmRlcmVyID0gRGVmYXVsdExlZ2VuZEl0ZW0sXG4gIEl0ZW1NYXJrUmVuZGVyZXIsXG4gIEl0ZW1MYWJlbFJlbmRlcmVyLFxuICBzdHlsZSxcbn06IExlZ2VuZEdyb3VwUmVuZGVyZXJQcm9wczxDb25maWc+KSB7XG4gIGNvbnN0IGNvbWJpbmVkU3R5bGUgPVxuICAgIHR5cGVvZiBzdHlsZSA9PT0gJ3VuZGVmaW5lZCcgPyBMRUdFTkRfR1JPVVBfU1RZTEUgOiB7IC4uLkxFR0VORF9HUk9VUF9TVFlMRSwgLi4uc3R5bGUgfTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgc3R5bGU9e2NvbWJpbmVkU3R5bGV9PlxuICAgICAgeydpdGVtcycgaW4gZ3JvdXAgJiZcbiAgICAgICAgZ3JvdXAuaXRlbXMubWFwKGl0ZW0gPT4gKFxuICAgICAgICAgIDxJdGVtUmVuZGVyZXJcbiAgICAgICAgICAgIGtleT17YGxlZ2VuZC1pdGVtLSR7Z3JvdXAuZmllbGR9LSR7aXRlbS5pbnB1dH1gfVxuICAgICAgICAgICAgZ3JvdXA9e2dyb3VwfVxuICAgICAgICAgICAgaXRlbT17aXRlbX1cbiAgICAgICAgICAgIE1hcmtSZW5kZXJlcj17SXRlbU1hcmtSZW5kZXJlcn1cbiAgICAgICAgICAgIExhYmVsUmVuZGVyZXI9e0l0ZW1MYWJlbFJlbmRlcmVyfVxuICAgICAgICAgIC8+XG4gICAgICAgICkpfVxuICAgIDwvZGl2PlxuICApO1xufVxuIiwiaW1wb3J0IFJlYWN0LCB7IENTU1Byb3BlcnRpZXMsIFB1cmVDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBFbmNvZGluZ0NvbmZpZyB9IGZyb20gJ2VuY29kYWJsZSc7XG5pbXBvcnQgeyBMZWdlbmRSZW5kZXJlclByb3BzIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgRGVmYXVsdExlZ2VuZEdyb3VwIGZyb20gJy4vRGVmYXVsdExlZ2VuZEdyb3VwJztcblxuY29uc3QgTEVHRU5EX0NPTlRBSU5FUl9TVFlMRTogQ1NTUHJvcGVydGllcyA9IHtcbiAgZGlzcGxheTogJ2ZsZXgnLFxuICBmbGV4QmFzaXM6ICdhdXRvJyxcbiAgZmxleEdyb3c6IDEsXG4gIGZsZXhTaHJpbms6IDEsXG4gIG1heEhlaWdodDogMTAwLFxuICBvdmVyZmxvd1k6ICdhdXRvJyxcbiAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG59O1xuXG5leHBvcnQgdHlwZSBQcm9wczxDb25maWcgZXh0ZW5kcyBFbmNvZGluZ0NvbmZpZz4gPSBMZWdlbmRSZW5kZXJlclByb3BzPENvbmZpZz47XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlZmF1bHRMZWdlbmQ8Q29uZmlnIGV4dGVuZHMgRW5jb2RpbmdDb25maWc+IGV4dGVuZHMgUHVyZUNvbXBvbmVudDxcbiAgUHJvcHM8Q29uZmlnPlxuPiB7XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBncm91cHMsXG4gICAgICBMZWdlbmRHcm91cFJlbmRlcmVyID0gRGVmYXVsdExlZ2VuZEdyb3VwLFxuICAgICAgTGVnZW5kSXRlbVJlbmRlcmVyLFxuICAgICAgTGVnZW5kSXRlbU1hcmtSZW5kZXJlcixcbiAgICAgIExlZ2VuZEl0ZW1MYWJlbFJlbmRlcmVyLFxuICAgICAgc3R5bGUsXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCBjb21iaW5lZFN0eWxlID1cbiAgICAgIHR5cGVvZiBzdHlsZSA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyBMRUdFTkRfQ09OVEFJTkVSX1NUWUxFXG4gICAgICAgIDogeyAuLi5MRUdFTkRfQ09OVEFJTkVSX1NUWUxFLCAuLi5zdHlsZSB9O1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgc3R5bGU9e2NvbWJpbmVkU3R5bGV9PlxuICAgICAgICB7Z3JvdXBzXG4gICAgICAgICAgLmZpbHRlcihncm91cCA9PiAnaXRlbXMnIGluIGdyb3VwICYmIGdyb3VwLml0ZW1zLmxlbmd0aCA+IDApXG4gICAgICAgICAgLm1hcChncm91cCA9PiAoXG4gICAgICAgICAgICA8TGVnZW5kR3JvdXBSZW5kZXJlclxuICAgICAgICAgICAgICBrZXk9e2dyb3VwLmZpZWxkfVxuICAgICAgICAgICAgICBncm91cD17Z3JvdXB9XG4gICAgICAgICAgICAgIEl0ZW1SZW5kZXJlcj17TGVnZW5kSXRlbVJlbmRlcmVyfVxuICAgICAgICAgICAgICBJdGVtTWFya1JlbmRlcmVyPXtMZWdlbmRJdGVtTWFya1JlbmRlcmVyfVxuICAgICAgICAgICAgICBJdGVtTGFiZWxSZW5kZXJlcj17TGVnZW5kSXRlbUxhYmVsUmVuZGVyZXJ9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICkpfVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEVuY29kZXIsIEVuY29kaW5nQ29uZmlnLCBEYXRhc2V0IH0gZnJvbSAnZW5jb2RhYmxlJztcbmltcG9ydCB7IExlZ2VuZEhvb2tzIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgRGVmYXVsdExlZ2VuZCBmcm9tICcuL0RlZmF1bHRMZWdlbmQnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVSZW5kZXJMZWdlbmQ8Q29uZmlnIGV4dGVuZHMgRW5jb2RpbmdDb25maWc+KFxuICBlbmNvZGVyOiBFbmNvZGVyPENvbmZpZz4sXG4gIGRhdGE6IERhdGFzZXQsXG4gIHByb3BzOiBMZWdlbmRIb29rczxDb25maWc+LFxuKSB7XG4gIGlmIChlbmNvZGVyLmhhc0xlZ2VuZCgpKSB7XG4gICAgY29uc3Qge1xuICAgICAgTGVnZW5kUmVuZGVyZXIgPSBEZWZhdWx0TGVnZW5kLFxuICAgICAgTGVnZW5kR3JvdXBSZW5kZXJlcixcbiAgICAgIExlZ2VuZEl0ZW1SZW5kZXJlcixcbiAgICAgIExlZ2VuZEl0ZW1MYWJlbFJlbmRlcmVyLFxuICAgICAgTGVnZW5kSXRlbU1hcmtSZW5kZXJlcixcbiAgICB9ID0gcHJvcHM7XG5cbiAgICByZXR1cm4gKCkgPT4gKFxuICAgICAgPExlZ2VuZFJlbmRlcmVyXG4gICAgICAgIGdyb3Vwcz17ZW5jb2Rlci5nZXRMZWdlbmRJbmZvcm1hdGlvbihkYXRhKX1cbiAgICAgICAgTGVnZW5kR3JvdXBSZW5kZXJlcj17TGVnZW5kR3JvdXBSZW5kZXJlcn1cbiAgICAgICAgTGVnZW5kSXRlbVJlbmRlcmVyPXtMZWdlbmRJdGVtUmVuZGVyZXJ9XG4gICAgICAgIExlZ2VuZEl0ZW1NYXJrUmVuZGVyZXI9e0xlZ2VuZEl0ZW1NYXJrUmVuZGVyZXJ9XG4gICAgICAgIExlZ2VuZEl0ZW1MYWJlbFJlbmRlcmVyPXtMZWdlbmRJdGVtTGFiZWxSZW5kZXJlcn1cbiAgICAgIC8+XG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFJQTtBQUVBO0FBRUE7O0FBTUE7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQVVBO0FBU0E7OztBQ2xEQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBT0E7QUFHQTtBQUdBO0FBV0E7OztBQ3pDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFHQTtBQUNBO0FBU0E7QUFFQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBV0E7QUFDQTs7O0FDbkRBO0FBR0E7QUFFQTtBQUtBO0FBQ0E7QUFRQTtBQVNBO0FBRUE7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1958\n")},2158:function(module,exports,__webpack_require__){"use strict";eval('exports.__esModule=!0,exports.default=exports.propTypes=exports.withTooltipPropTypes=exports.Tooltip=void 0;var _react=_interopRequireDefault(__webpack_require__(0)),_propTypes=_interopRequireDefault(__webpack_require__(56)),_localPoint=_interopRequireDefault(__webpack_require__(2128)),_withTooltip=_interopRequireDefault(__webpack_require__(2179)),_TooltipWithBounds=_interopRequireWildcard(__webpack_require__(2178)),_Tooltip=_interopRequireDefault(__webpack_require__(1964));exports.Tooltip=_Tooltip.default;function _interopRequireWildcard(a){if(a&&a.__esModule)return a;var b={};if(null!=a)for(var c in a)if(Object.prototype.hasOwnProperty.call(a,c)){var d=Object.defineProperty&&Object.getOwnPropertyDescriptor?Object.getOwnPropertyDescriptor(a,c):{};d.get||d.set?Object.defineProperty(b,c,d):b[c]=a[c]}return b.default=a,b}function _interopRequireDefault(a){return a&&a.__esModule?a:{default:a}}function _objectWithoutPropertiesLoose(a,b){if(null==a)return{};var c,d,e={},f=Object.keys(a);for(d=0;d<f.length;d++)c=f[d],0<=b.indexOf(c)||(e[c]=a[c]);return e}function _inheritsLoose(a,b){a.prototype=Object.create(b.prototype),a.prototype.constructor=a,a.__proto__=b}function _assertThisInitialized(a){if(void 0===a)throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called");return a}function _extends(){return _extends=Object.assign||function(a){for(var b,c=1;c<arguments.length;c++)for(var d in b=arguments[c],b)Object.prototype.hasOwnProperty.call(b,d)&&(a[d]=b[d]);return a},_extends.apply(this,arguments)}var withTooltipPropTypes={onMouseMove:_propTypes.default.func,// expects to be called like func({ event, datum })\nonMouseLeave:_propTypes.default.func,// expects to be called like func({ event, datum })\ntooltipData:_propTypes.default.any};exports.withTooltipPropTypes=withTooltipPropTypes;var propTypes=_extends({},_TooltipWithBounds.withTooltipPropTypes,{children:_propTypes.default.oneOfType([_propTypes.default.object,_propTypes.default.func]).isRequired,className:_propTypes.default.string,HoverStyles:_propTypes.default.oneOfType([_propTypes.default.object,_propTypes.default.func]),renderTooltip:_propTypes.default.func,styles:_propTypes.default.objectOf(_propTypes.default.oneOfType([_propTypes.default.string,_propTypes.default.number])),TooltipComponent:_propTypes.default.oneOfType([_propTypes.default.object,_propTypes.default.func]),tooltipProps:_propTypes.default.object,// eslint-disable-line react/forbid-prop-types\ntooltipTimeout:_propTypes.default.number});exports.propTypes=propTypes;var defaultProps={className:null,HoverStyles:function a(){return _react.default.createElement("style",{type:"text/css"},"\\n      .vx-arc:hover,\\n      .vx-bar:hover,\\n      .vx-glyph-dot:hover {\\n        opacity: 0.7;\\n      }\\n    ")},renderTooltip:null,styles:{display:"inline-block",position:"relative"},TooltipComponent:_TooltipWithBounds.default,tooltipProps:null,tooltipTimeout:200},WithTooltip=/*#__PURE__*/function(a){function b(b){var c;return c=a.call(this,b)||this,c.handleMouseMove=c.handleMouseMove.bind(_assertThisInitialized(_assertThisInitialized(c))),c.handleMouseLeave=c.handleMouseLeave.bind(_assertThisInitialized(_assertThisInitialized(c))),c.tooltipTimeout=null,c}_inheritsLoose(b,a);var c=b.prototype;return c.componentWillUnmount=function a(){this.tooltipTimeout&&clearTimeout(this.tooltipTimeout)},c.handleMouseMove=function h(a){var b=a.event,c=a.datum,d=a.coords,e=_objectWithoutPropertiesLoose(a,["event","datum","coords"]),f=this.props.showTooltip;this.tooltipTimeout&&clearTimeout(this.tooltipTimeout);var g={x:0,y:0};b&&b.target&&"focus"!==b.type&&b.target.ownerSVGElement&&(g=(0,_localPoint.default)(b.target.ownerSVGElement,b)),g=_extends({},g,d),f({tooltipLeft:g.x,tooltipTop:g.y,tooltipData:_extends({event:b,datum:c},e)})},c.handleMouseLeave=function d(){var a=this.props,b=a.tooltipTimeout,c=a.hideTooltip;this.tooltipTimeout=setTimeout(function(){c()},b)},c.render=function o(){var a=this.props,b=a.children,c=a.className,d=a.HoverStyles,e=a.tooltipData,f=a.tooltipOpen,g=a.tooltipLeft,h=a.tooltipTop,i=a.tooltipProps,j=a.renderTooltip,k=a.styles,l=a.TooltipComponent,m={onMouseMove:this.handleMouseMove,onMouseLeave:this.handleMouseLeave,tooltipData:e},n=j&&f&&l&&j(e);return _react.default.createElement("div",{style:k,className:c},"function"==typeof b?b(m):_react.default.cloneElement(_react.default.Children.only(b),m),!!n&&_react.default.createElement(l,_extends({key:Math.random(),top:h,left:g},i),n),d&&_react.default.createElement(d,null))},b}(_react.default.PureComponent);WithTooltip.propTypes=propTypes,WithTooltip.defaultProps=defaultProps;var _default=(0,_withTooltip.default)(WithTooltip);exports.default=_default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjE1OC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL3NoYXJlZC9saWIvZW5oYW5jZXIvV2l0aFRvb2x0aXAuanM/YzQ0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtleHBvcnRzLl9fZXNNb2R1bGU9ITAsZXhwb3J0cy5kZWZhdWx0PWV4cG9ydHMucHJvcFR5cGVzPWV4cG9ydHMud2l0aFRvb2x0aXBQcm9wVHlwZXM9ZXhwb3J0cy5Ub29sdGlwPXZvaWQgMDt2YXIgX3JlYWN0PV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKSxfcHJvcFR5cGVzPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInByb3AtdHlwZXNcIikpLF9sb2NhbFBvaW50PV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkB2eC9ldmVudC9idWlsZC9sb2NhbFBvaW50XCIpKSxfd2l0aFRvb2x0aXA9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQHZ4L3Rvb2x0aXAvYnVpbGQvZW5oYW5jZXJzL3dpdGhUb29sdGlwXCIpKSxfVG9vbHRpcFdpdGhCb3VuZHM9X2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIkB2eC90b29sdGlwL2J1aWxkL3Rvb2x0aXBzL1Rvb2x0aXBXaXRoQm91bmRzXCIpKSxfVG9vbHRpcD1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAdngvdG9vbHRpcC9idWlsZC90b29sdGlwcy9Ub29sdGlwXCIpKTtleHBvcnRzLlRvb2x0aXA9X1Rvb2x0aXAuZGVmYXVsdDtmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChhKXtpZihhJiZhLl9fZXNNb2R1bGUpcmV0dXJuIGE7dmFyIGI9e307aWYobnVsbCE9YSlmb3IodmFyIGMgaW4gYSlpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSxjKSl7dmFyIGQ9T2JqZWN0LmRlZmluZVByb3BlcnR5JiZPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yP09iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYSxjKTp7fTtkLmdldHx8ZC5zZXQ/T2JqZWN0LmRlZmluZVByb3BlcnR5KGIsYyxkKTpiW2NdPWFbY119cmV0dXJuIGIuZGVmYXVsdD1hLGJ9ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChhKXtyZXR1cm4gYSYmYS5fX2VzTW9kdWxlP2E6e2RlZmF1bHQ6YX19ZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoYSxiKXtpZihudWxsPT1hKXJldHVybnt9O3ZhciBjLGQsZT17fSxmPU9iamVjdC5rZXlzKGEpO2ZvcihkPTA7ZDxmLmxlbmd0aDtkKyspYz1mW2RdLDA8PWIuaW5kZXhPZihjKXx8KGVbY109YVtjXSk7cmV0dXJuIGV9ZnVuY3Rpb24gX2luaGVyaXRzTG9vc2UoYSxiKXthLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGIucHJvdG90eXBlKSxhLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1hLGEuX19wcm90b19fPWJ9ZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChhKXtpZih2b2lkIDA9PT1hKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4gYX1mdW5jdGlvbiBfZXh0ZW5kcygpe3JldHVybiBfZXh0ZW5kcz1PYmplY3QuYXNzaWdufHxmdW5jdGlvbihhKXtmb3IodmFyIGIsYz0xO2M8YXJndW1lbnRzLmxlbmd0aDtjKyspZm9yKHZhciBkIGluIGI9YXJndW1lbnRzW2NdLGIpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsZCkmJihhW2RdPWJbZF0pO3JldHVybiBhfSxfZXh0ZW5kcy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9dmFyIHdpdGhUb29sdGlwUHJvcFR5cGVzPXtvbk1vdXNlTW92ZTpfcHJvcFR5cGVzLmRlZmF1bHQuZnVuYywvLyBleHBlY3RzIHRvIGJlIGNhbGxlZCBsaWtlIGZ1bmMoeyBldmVudCwgZGF0dW0gfSlcbm9uTW91c2VMZWF2ZTpfcHJvcFR5cGVzLmRlZmF1bHQuZnVuYywvLyBleHBlY3RzIHRvIGJlIGNhbGxlZCBsaWtlIGZ1bmMoeyBldmVudCwgZGF0dW0gfSlcbnRvb2x0aXBEYXRhOl9wcm9wVHlwZXMuZGVmYXVsdC5hbnl9O2V4cG9ydHMud2l0aFRvb2x0aXBQcm9wVHlwZXM9d2l0aFRvb2x0aXBQcm9wVHlwZXM7dmFyIHByb3BUeXBlcz1fZXh0ZW5kcyh7fSxfVG9vbHRpcFdpdGhCb3VuZHMud2l0aFRvb2x0aXBQcm9wVHlwZXMse2NoaWxkcmVuOl9wcm9wVHlwZXMuZGVmYXVsdC5vbmVPZlR5cGUoW19wcm9wVHlwZXMuZGVmYXVsdC5vYmplY3QsX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmNdKS5pc1JlcXVpcmVkLGNsYXNzTmFtZTpfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nLEhvdmVyU3R5bGVzOl9wcm9wVHlwZXMuZGVmYXVsdC5vbmVPZlR5cGUoW19wcm9wVHlwZXMuZGVmYXVsdC5vYmplY3QsX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmNdKSxyZW5kZXJUb29sdGlwOl9wcm9wVHlwZXMuZGVmYXVsdC5mdW5jLHN0eWxlczpfcHJvcFR5cGVzLmRlZmF1bHQub2JqZWN0T2YoX3Byb3BUeXBlcy5kZWZhdWx0Lm9uZU9mVHlwZShbX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZyxfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyXSkpLFRvb2x0aXBDb21wb25lbnQ6X3Byb3BUeXBlcy5kZWZhdWx0Lm9uZU9mVHlwZShbX3Byb3BUeXBlcy5kZWZhdWx0Lm9iamVjdCxfcHJvcFR5cGVzLmRlZmF1bHQuZnVuY10pLHRvb2x0aXBQcm9wczpfcHJvcFR5cGVzLmRlZmF1bHQub2JqZWN0LC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVhY3QvZm9yYmlkLXByb3AtdHlwZXNcbnRvb2x0aXBUaW1lb3V0Ol9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXJ9KTtleHBvcnRzLnByb3BUeXBlcz1wcm9wVHlwZXM7dmFyIGRlZmF1bHRQcm9wcz17Y2xhc3NOYW1lOm51bGwsSG92ZXJTdHlsZXM6ZnVuY3Rpb24gYSgpe3JldHVybiBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIix7dHlwZTpcInRleHQvY3NzXCJ9LFwiXFxuICAgICAgLnZ4LWFyYzpob3ZlcixcXG4gICAgICAudngtYmFyOmhvdmVyLFxcbiAgICAgIC52eC1nbHlwaC1kb3Q6aG92ZXIge1xcbiAgICAgICAgb3BhY2l0eTogMC43O1xcbiAgICAgIH1cXG4gICAgXCIpfSxyZW5kZXJUb29sdGlwOm51bGwsc3R5bGVzOntkaXNwbGF5OlwiaW5saW5lLWJsb2NrXCIscG9zaXRpb246XCJyZWxhdGl2ZVwifSxUb29sdGlwQ29tcG9uZW50Ol9Ub29sdGlwV2l0aEJvdW5kcy5kZWZhdWx0LHRvb2x0aXBQcm9wczpudWxsLHRvb2x0aXBUaW1lb3V0OjIwMH0sV2l0aFRvb2x0aXA9LyojX19QVVJFX18qL2Z1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoYil7dmFyIGM7cmV0dXJuIGM9YS5jYWxsKHRoaXMsYil8fHRoaXMsYy5oYW5kbGVNb3VzZU1vdmU9Yy5oYW5kbGVNb3VzZU1vdmUuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoYykpKSxjLmhhbmRsZU1vdXNlTGVhdmU9Yy5oYW5kbGVNb3VzZUxlYXZlLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKGMpKSksYy50b29sdGlwVGltZW91dD1udWxsLGN9X2luaGVyaXRzTG9vc2UoYixhKTt2YXIgYz1iLnByb3RvdHlwZTtyZXR1cm4gYy5jb21wb25lbnRXaWxsVW5tb3VudD1mdW5jdGlvbiBhKCl7dGhpcy50b29sdGlwVGltZW91dCYmY2xlYXJUaW1lb3V0KHRoaXMudG9vbHRpcFRpbWVvdXQpfSxjLmhhbmRsZU1vdXNlTW92ZT1mdW5jdGlvbiBoKGEpe3ZhciBiPWEuZXZlbnQsYz1hLmRhdHVtLGQ9YS5jb29yZHMsZT1fb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShhLFtcImV2ZW50XCIsXCJkYXR1bVwiLFwiY29vcmRzXCJdKSxmPXRoaXMucHJvcHMuc2hvd1Rvb2x0aXA7dGhpcy50b29sdGlwVGltZW91dCYmY2xlYXJUaW1lb3V0KHRoaXMudG9vbHRpcFRpbWVvdXQpO3ZhciBnPXt4OjAseTowfTtiJiZiLnRhcmdldCYmXCJmb2N1c1wiIT09Yi50eXBlJiZiLnRhcmdldC5vd25lclNWR0VsZW1lbnQmJihnPSgwLF9sb2NhbFBvaW50LmRlZmF1bHQpKGIudGFyZ2V0Lm93bmVyU1ZHRWxlbWVudCxiKSksZz1fZXh0ZW5kcyh7fSxnLGQpLGYoe3Rvb2x0aXBMZWZ0OmcueCx0b29sdGlwVG9wOmcueSx0b29sdGlwRGF0YTpfZXh0ZW5kcyh7ZXZlbnQ6YixkYXR1bTpjfSxlKX0pfSxjLmhhbmRsZU1vdXNlTGVhdmU9ZnVuY3Rpb24gZCgpe3ZhciBhPXRoaXMucHJvcHMsYj1hLnRvb2x0aXBUaW1lb3V0LGM9YS5oaWRlVG9vbHRpcDt0aGlzLnRvb2x0aXBUaW1lb3V0PXNldFRpbWVvdXQoZnVuY3Rpb24oKXtjKCl9LGIpfSxjLnJlbmRlcj1mdW5jdGlvbiBvKCl7dmFyIGE9dGhpcy5wcm9wcyxiPWEuY2hpbGRyZW4sYz1hLmNsYXNzTmFtZSxkPWEuSG92ZXJTdHlsZXMsZT1hLnRvb2x0aXBEYXRhLGY9YS50b29sdGlwT3BlbixnPWEudG9vbHRpcExlZnQsaD1hLnRvb2x0aXBUb3AsaT1hLnRvb2x0aXBQcm9wcyxqPWEucmVuZGVyVG9vbHRpcCxrPWEuc3R5bGVzLGw9YS5Ub29sdGlwQ29tcG9uZW50LG09e29uTW91c2VNb3ZlOnRoaXMuaGFuZGxlTW91c2VNb3ZlLG9uTW91c2VMZWF2ZTp0aGlzLmhhbmRsZU1vdXNlTGVhdmUsdG9vbHRpcERhdGE6ZX0sbj1qJiZmJiZsJiZqKGUpO3JldHVybiBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIse3N0eWxlOmssY2xhc3NOYW1lOmN9LFwiZnVuY3Rpb25cIj09dHlwZW9mIGI/YihtKTpfcmVhY3QuZGVmYXVsdC5jbG9uZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuQ2hpbGRyZW4ub25seShiKSxtKSwhIW4mJl9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQobCxfZXh0ZW5kcyh7a2V5Ok1hdGgucmFuZG9tKCksdG9wOmgsbGVmdDpnfSxpKSxuKSxkJiZfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KGQsbnVsbCkpfSxifShfcmVhY3QuZGVmYXVsdC5QdXJlQ29tcG9uZW50KTtXaXRoVG9vbHRpcC5wcm9wVHlwZXM9cHJvcFR5cGVzLFdpdGhUb29sdGlwLmRlZmF1bHRQcm9wcz1kZWZhdWx0UHJvcHM7dmFyIF9kZWZhdWx0PSgwLF93aXRoVG9vbHRpcC5kZWZhdWx0KShXaXRoVG9vbHRpcCk7ZXhwb3J0cy5kZWZhdWx0PV9kZWZhdWx0OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2158\n')},2159:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* unused harmony export Glyph */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return GlyphDot; });\n/* unused harmony export GlyphCross */\n/* unused harmony export GlyphDiamond */\n/* unused harmony export GlyphStar */\n/* unused harmony export GlyphTriangle */\n/* unused harmony export GlyphWye */\n/* unused harmony export GlyphSquare */\n/* unused harmony export GlyphCircle */\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _vx_group__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1914);\n/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(74);\n/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1949);\n/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1921);\n/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(1922);\n/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(1924);\n/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(1925);\n/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(1926);\n/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(1923);\n/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(1920);\n\n\n\n\n\nfunction Glyph(_ref) {\n  var _ref$top = _ref.top,\n      top = _ref$top === undefined ? 0 : _ref$top,\n      _ref$left = _ref.left,\n      left = _ref$left === undefined ? 0 : _ref$left,\n      className = _ref.className,\n      children = _ref.children;\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n    _vx_group__WEBPACK_IMPORTED_MODULE_1__[/* Group */ \"a\"],\n    { className: classnames__WEBPACK_IMPORTED_MODULE_2___default()('vx-glyph', className), top: top, left: left },\n    children\n  );\n}\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nfunction GlyphDot(_ref) {\n  var _ref$top = _ref.top,\n      top = _ref$top === undefined ? 0 : _ref$top,\n      _ref$left = _ref.left,\n      left = _ref$left === undefined ? 0 : _ref$left,\n      className = _ref.className,\n      children = _ref.children,\n      cx$$1 = _ref.cx,\n      cy = _ref.cy,\n      r = _ref.r,\n      fill = _ref.fill,\n      stroke = _ref.stroke,\n      strokeWidth = _ref.strokeWidth,\n      strokeDasharray = _ref.strokeDasharray,\n      restProps = objectWithoutProperties(_ref, ['top', 'left', 'className', 'children', 'cx', 'cy', 'r', 'fill', 'stroke', 'strokeWidth', 'strokeDasharray']);\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n    Glyph,\n    { top: top, left: left },\n    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('circle', _extends({\n      className: classnames__WEBPACK_IMPORTED_MODULE_2___default()('vx-glyph-dot', className),\n      cx: cx$$1,\n      cy: cy,\n      r: r,\n      fill: fill,\n      stroke: stroke,\n      strokeWidth: strokeWidth,\n      strokeDasharray: strokeDasharray\n    }, restProps)),\n    children\n  );\n}\n\nfunction callOrValue(maybeFn, data) {\n  if (typeof maybeFn === 'function') {\n    return maybeFn(data);\n  }\n  return maybeFn;\n}\n\nfunction additionalProps(restProps, data) {\n  return Object.keys(restProps).reduce(function (ret, cur) {\n    ret[cur] = callOrValue(restProps[cur], data);\n    return ret;\n  }, {});\n}\n\nfunction GlyphCross(_ref) {\n  var children = _ref.children,\n      className = _ref.className,\n      top = _ref.top,\n      left = _ref.left,\n      size = _ref.size,\n      restProps = objectWithoutProperties(_ref, ['children', 'className', 'top', 'left', 'size']);\n\n  var path = Object(d3_shape__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])();\n  path.type(d3_shape__WEBPACK_IMPORTED_MODULE_4__[/* default */ \"a\"]);\n  if (size) path.size(size);\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n    Glyph,\n    { top: top, left: left },\n    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('path', _extends({\n      className: classnames__WEBPACK_IMPORTED_MODULE_2___default()('vx-glyph-cross', className),\n      d: path()\n    }, additionalProps(restProps))),\n    children\n  );\n}\n\nfunction GlyphDiamond(_ref) {\n  var children = _ref.children,\n      className = _ref.className,\n      top = _ref.top,\n      left = _ref.left,\n      size = _ref.size,\n      restProps = objectWithoutProperties(_ref, ['children', 'className', 'top', 'left', 'size']);\n\n  var path = Object(d3_shape__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])();\n  path.type(d3_shape__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"]);\n  if (size) path.size(size);\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n    Glyph,\n    { top: top, left: left },\n    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('path', _extends({\n      className: classnames__WEBPACK_IMPORTED_MODULE_2___default()('vx-glyph-diamond', className),\n      d: path()\n    }, additionalProps(restProps))),\n    children\n  );\n}\n\nfunction GlyphStar(_ref) {\n  var children = _ref.children,\n      className = _ref.className,\n      top = _ref.top,\n      left = _ref.left,\n      size = _ref.size,\n      restProps = objectWithoutProperties(_ref, ['children', 'className', 'top', 'left', 'size']);\n\n  var path = Object(d3_shape__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])();\n  path.type(d3_shape__WEBPACK_IMPORTED_MODULE_6__[/* default */ \"a\"]);\n  if (size) path.size(size);\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n    Glyph,\n    { top: top, left: left },\n    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('path', _extends({ className: classnames__WEBPACK_IMPORTED_MODULE_2___default()('vx-glyph-star', className), d: path() }, additionalProps(restProps))),\n    children\n  );\n}\n\nfunction GlyphTriangle(_ref) {\n  var children = _ref.children,\n      className = _ref.className,\n      top = _ref.top,\n      left = _ref.left,\n      size = _ref.size,\n      restProps = objectWithoutProperties(_ref, ['children', 'className', 'top', 'left', 'size']);\n\n  var path = Object(d3_shape__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])();\n  path.type(d3_shape__WEBPACK_IMPORTED_MODULE_7__[/* default */ \"a\"]);\n  if (size) path.size(size);\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n    Glyph,\n    { top: top, left: left },\n    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('path', _extends({\n      className: classnames__WEBPACK_IMPORTED_MODULE_2___default()('vx-glyph-triangle', className),\n      d: path()\n    }, additionalProps(restProps))),\n    children\n  );\n}\n\nfunction GlyphWye(_ref) {\n  var children = _ref.children,\n      className = _ref.className,\n      top = _ref.top,\n      left = _ref.left,\n      size = _ref.size,\n      restProps = objectWithoutProperties(_ref, ['children', 'className', 'top', 'left', 'size']);\n\n  var path = Object(d3_shape__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])();\n  path.type(d3_shape__WEBPACK_IMPORTED_MODULE_8__[/* default */ \"a\"]);\n  if (size) path.size(size);\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n    Glyph,\n    { top: top, left: left },\n    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('path', _extends({ className: classnames__WEBPACK_IMPORTED_MODULE_2___default()('vx-glyph-wye', className), d: path() }, additionalProps(restProps))),\n    children\n  );\n}\n\nfunction GlyphSquare(_ref) {\n  var children = _ref.children,\n      className = _ref.className,\n      top = _ref.top,\n      left = _ref.left,\n      size = _ref.size,\n      restProps = objectWithoutProperties(_ref, ['children', 'className', 'top', 'left', 'size']);\n\n  var path = Object(d3_shape__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])();\n  path.type(d3_shape__WEBPACK_IMPORTED_MODULE_9__[/* default */ \"a\"]);\n  if (size) path.size(size);\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n    Glyph,\n    { top: top, left: left },\n    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('path', _extends({\n      className: classnames__WEBPACK_IMPORTED_MODULE_2___default()('vx-glyph-square', className),\n      d: path()\n    }, additionalProps(restProps))),\n    children\n  );\n}\n\nfunction GlyphCircle(_ref) {\n  var children = _ref.children,\n      className = _ref.className,\n      top = _ref.top,\n      left = _ref.left,\n      size = _ref.size,\n      restProps = objectWithoutProperties(_ref, ['children', 'className', 'top', 'left', 'size']);\n\n  var path = Object(d3_shape__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])();\n  path.type(d3_shape__WEBPACK_IMPORTED_MODULE_10__[/* default */ \"a\"]);\n  if (size) path.size(size);\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n    Glyph,\n    { top: top, left: left },\n    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('path', _extends({\n      className: classnames__WEBPACK_IMPORTED_MODULE_2___default()('vx-glyph-circle', className),\n      d: path()\n    }, additionalProps(restProps))),\n    children\n  );\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjE1OS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL3h5LWNoYXJ0L25vZGVfbW9kdWxlcy9AdngvZ2x5cGgvZGlzdC92eC1nbHlwaC5lcy5qcz8yNTQ4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBHcm91cCB9IGZyb20gJ0B2eC9ncm91cCc7XG5pbXBvcnQgY3ggZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgeyBzeW1ib2wsIHN5bWJvbENyb3NzLCBzeW1ib2xEaWFtb25kLCBzeW1ib2xTdGFyLCBzeW1ib2xUcmlhbmdsZSwgc3ltYm9sV3llLCBzeW1ib2xTcXVhcmUsIHN5bWJvbENpcmNsZSB9IGZyb20gJ2QzLXNoYXBlJztcblxuZnVuY3Rpb24gR2x5cGgoX3JlZikge1xuICB2YXIgX3JlZiR0b3AgPSBfcmVmLnRvcCxcbiAgICAgIHRvcCA9IF9yZWYkdG9wID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiR0b3AsXG4gICAgICBfcmVmJGxlZnQgPSBfcmVmLmxlZnQsXG4gICAgICBsZWZ0ID0gX3JlZiRsZWZ0ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiRsZWZ0LFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW47XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgR3JvdXAsXG4gICAgeyBjbGFzc05hbWU6IGN4KCd2eC1nbHlwaCcsIGNsYXNzTmFtZSksIHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH0sXG4gICAgY2hpbGRyZW5cbiAgKTtcbn1cblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbnZhciBvYmplY3RXaXRob3V0UHJvcGVydGllcyA9IGZ1bmN0aW9uIChvYmosIGtleXMpIHtcbiAgdmFyIHRhcmdldCA9IHt9O1xuXG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTtcbiAgICB0YXJnZXRbaV0gPSBvYmpbaV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuZnVuY3Rpb24gR2x5cGhEb3QoX3JlZikge1xuICB2YXIgX3JlZiR0b3AgPSBfcmVmLnRvcCxcbiAgICAgIHRvcCA9IF9yZWYkdG9wID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiR0b3AsXG4gICAgICBfcmVmJGxlZnQgPSBfcmVmLmxlZnQsXG4gICAgICBsZWZ0ID0gX3JlZiRsZWZ0ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiRsZWZ0LFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBjeCQkMSA9IF9yZWYuY3gsXG4gICAgICBjeSA9IF9yZWYuY3ksXG4gICAgICByID0gX3JlZi5yLFxuICAgICAgZmlsbCA9IF9yZWYuZmlsbCxcbiAgICAgIHN0cm9rZSA9IF9yZWYuc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGggPSBfcmVmLnN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlRGFzaGFycmF5ID0gX3JlZi5zdHJva2VEYXNoYXJyYXksXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ3RvcCcsICdsZWZ0JywgJ2NsYXNzTmFtZScsICdjaGlsZHJlbicsICdjeCcsICdjeScsICdyJywgJ2ZpbGwnLCAnc3Ryb2tlJywgJ3N0cm9rZVdpZHRoJywgJ3N0cm9rZURhc2hhcnJheSddKTtcblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICBHbHlwaCxcbiAgICB7IHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH0sXG4gICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnY2lyY2xlJywgX2V4dGVuZHMoe1xuICAgICAgY2xhc3NOYW1lOiBjeCgndngtZ2x5cGgtZG90JywgY2xhc3NOYW1lKSxcbiAgICAgIGN4OiBjeCQkMSxcbiAgICAgIGN5OiBjeSxcbiAgICAgIHI6IHIsXG4gICAgICBmaWxsOiBmaWxsLFxuICAgICAgc3Ryb2tlOiBzdHJva2UsXG4gICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgICBzdHJva2VEYXNoYXJyYXk6IHN0cm9rZURhc2hhcnJheVxuICAgIH0sIHJlc3RQcm9wcykpLFxuICAgIGNoaWxkcmVuXG4gICk7XG59XG5cbmZ1bmN0aW9uIGNhbGxPclZhbHVlKG1heWJlRm4sIGRhdGEpIHtcbiAgaWYgKHR5cGVvZiBtYXliZUZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlRm4oZGF0YSk7XG4gIH1cbiAgcmV0dXJuIG1heWJlRm47XG59XG5cbmZ1bmN0aW9uIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHJlc3RQcm9wcykucmVkdWNlKGZ1bmN0aW9uIChyZXQsIGN1cikge1xuICAgIHJldFtjdXJdID0gY2FsbE9yVmFsdWUocmVzdFByb3BzW2N1cl0sIGRhdGEpO1xuICAgIHJldHVybiByZXQ7XG4gIH0sIHt9KTtcbn1cblxuZnVuY3Rpb24gR2x5cGhDcm9zcyhfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIHRvcCA9IF9yZWYudG9wLFxuICAgICAgbGVmdCA9IF9yZWYubGVmdCxcbiAgICAgIHNpemUgPSBfcmVmLnNpemUsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2NoaWxkcmVuJywgJ2NsYXNzTmFtZScsICd0b3AnLCAnbGVmdCcsICdzaXplJ10pO1xuXG4gIHZhciBwYXRoID0gc3ltYm9sKCk7XG4gIHBhdGgudHlwZShzeW1ib2xDcm9zcyk7XG4gIGlmIChzaXplKSBwYXRoLnNpemUoc2l6ZSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIEdseXBoLFxuICAgIHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfSxcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgICAgY2xhc3NOYW1lOiBjeCgndngtZ2x5cGgtY3Jvc3MnLCBjbGFzc05hbWUpLFxuICAgICAgZDogcGF0aCgpXG4gICAgfSwgYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcykpKSxcbiAgICBjaGlsZHJlblxuICApO1xufVxuXG5mdW5jdGlvbiBHbHlwaERpYW1vbmQoX3JlZikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICB0b3AgPSBfcmVmLnRvcCxcbiAgICAgIGxlZnQgPSBfcmVmLmxlZnQsXG4gICAgICBzaXplID0gX3JlZi5zaXplLFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgWydjaGlsZHJlbicsICdjbGFzc05hbWUnLCAndG9wJywgJ2xlZnQnLCAnc2l6ZSddKTtcblxuICB2YXIgcGF0aCA9IHN5bWJvbCgpO1xuICBwYXRoLnR5cGUoc3ltYm9sRGlhbW9uZCk7XG4gIGlmIChzaXplKSBwYXRoLnNpemUoc2l6ZSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIEdseXBoLFxuICAgIHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfSxcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgICAgY2xhc3NOYW1lOiBjeCgndngtZ2x5cGgtZGlhbW9uZCcsIGNsYXNzTmFtZSksXG4gICAgICBkOiBwYXRoKClcbiAgICB9LCBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzKSkpLFxuICAgIGNoaWxkcmVuXG4gICk7XG59XG5cbmZ1bmN0aW9uIEdseXBoU3RhcihfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIHRvcCA9IF9yZWYudG9wLFxuICAgICAgbGVmdCA9IF9yZWYubGVmdCxcbiAgICAgIHNpemUgPSBfcmVmLnNpemUsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2NoaWxkcmVuJywgJ2NsYXNzTmFtZScsICd0b3AnLCAnbGVmdCcsICdzaXplJ10pO1xuXG4gIHZhciBwYXRoID0gc3ltYm9sKCk7XG4gIHBhdGgudHlwZShzeW1ib2xTdGFyKTtcbiAgaWYgKHNpemUpIHBhdGguc2l6ZShzaXplKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgR2x5cGgsXG4gICAgeyB0b3A6IHRvcCwgbGVmdDogbGVmdCB9LFxuICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCBfZXh0ZW5kcyh7IGNsYXNzTmFtZTogY3goJ3Z4LWdseXBoLXN0YXInLCBjbGFzc05hbWUpLCBkOiBwYXRoKCkgfSwgYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcykpKSxcbiAgICBjaGlsZHJlblxuICApO1xufVxuXG5mdW5jdGlvbiBHbHlwaFRyaWFuZ2xlKF9yZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgdG9wID0gX3JlZi50b3AsXG4gICAgICBsZWZ0ID0gX3JlZi5sZWZ0LFxuICAgICAgc2l6ZSA9IF9yZWYuc2l6ZSxcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnY2hpbGRyZW4nLCAnY2xhc3NOYW1lJywgJ3RvcCcsICdsZWZ0JywgJ3NpemUnXSk7XG5cbiAgdmFyIHBhdGggPSBzeW1ib2woKTtcbiAgcGF0aC50eXBlKHN5bWJvbFRyaWFuZ2xlKTtcbiAgaWYgKHNpemUpIHBhdGguc2l6ZShzaXplKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgR2x5cGgsXG4gICAgeyB0b3A6IHRvcCwgbGVmdDogbGVmdCB9LFxuICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCBfZXh0ZW5kcyh7XG4gICAgICBjbGFzc05hbWU6IGN4KCd2eC1nbHlwaC10cmlhbmdsZScsIGNsYXNzTmFtZSksXG4gICAgICBkOiBwYXRoKClcbiAgICB9LCBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzKSkpLFxuICAgIGNoaWxkcmVuXG4gICk7XG59XG5cbmZ1bmN0aW9uIEdseXBoV3llKF9yZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgdG9wID0gX3JlZi50b3AsXG4gICAgICBsZWZ0ID0gX3JlZi5sZWZ0LFxuICAgICAgc2l6ZSA9IF9yZWYuc2l6ZSxcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnY2hpbGRyZW4nLCAnY2xhc3NOYW1lJywgJ3RvcCcsICdsZWZ0JywgJ3NpemUnXSk7XG5cbiAgdmFyIHBhdGggPSBzeW1ib2woKTtcbiAgcGF0aC50eXBlKHN5bWJvbFd5ZSk7XG4gIGlmIChzaXplKSBwYXRoLnNpemUoc2l6ZSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIEdseXBoLFxuICAgIHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfSxcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoeyBjbGFzc05hbWU6IGN4KCd2eC1nbHlwaC13eWUnLCBjbGFzc05hbWUpLCBkOiBwYXRoKCkgfSwgYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcykpKSxcbiAgICBjaGlsZHJlblxuICApO1xufVxuXG5mdW5jdGlvbiBHbHlwaFNxdWFyZShfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIHRvcCA9IF9yZWYudG9wLFxuICAgICAgbGVmdCA9IF9yZWYubGVmdCxcbiAgICAgIHNpemUgPSBfcmVmLnNpemUsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2NoaWxkcmVuJywgJ2NsYXNzTmFtZScsICd0b3AnLCAnbGVmdCcsICdzaXplJ10pO1xuXG4gIHZhciBwYXRoID0gc3ltYm9sKCk7XG4gIHBhdGgudHlwZShzeW1ib2xTcXVhcmUpO1xuICBpZiAoc2l6ZSkgcGF0aC5zaXplKHNpemUpO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICBHbHlwaCxcbiAgICB7IHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH0sXG4gICAgUmVhY3QuY3JlYXRlRWxlbWVudCgncGF0aCcsIF9leHRlbmRzKHtcbiAgICAgIGNsYXNzTmFtZTogY3goJ3Z4LWdseXBoLXNxdWFyZScsIGNsYXNzTmFtZSksXG4gICAgICBkOiBwYXRoKClcbiAgICB9LCBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzKSkpLFxuICAgIGNoaWxkcmVuXG4gICk7XG59XG5cbmZ1bmN0aW9uIEdseXBoQ2lyY2xlKF9yZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgdG9wID0gX3JlZi50b3AsXG4gICAgICBsZWZ0ID0gX3JlZi5sZWZ0LFxuICAgICAgc2l6ZSA9IF9yZWYuc2l6ZSxcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnY2hpbGRyZW4nLCAnY2xhc3NOYW1lJywgJ3RvcCcsICdsZWZ0JywgJ3NpemUnXSk7XG5cbiAgdmFyIHBhdGggPSBzeW1ib2woKTtcbiAgcGF0aC50eXBlKHN5bWJvbENpcmNsZSk7XG4gIGlmIChzaXplKSBwYXRoLnNpemUoc2l6ZSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIEdseXBoLFxuICAgIHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfSxcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgICAgY2xhc3NOYW1lOiBjeCgndngtZ2x5cGgtY2lyY2xlJywgY2xhc3NOYW1lKSxcbiAgICAgIGQ6IHBhdGgoKVxuICAgIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMpKSksXG4gICAgY2hpbGRyZW5cbiAgKTtcbn1cblxuZXhwb3J0IHsgR2x5cGgsIEdseXBoRG90LCBHbHlwaENyb3NzLCBHbHlwaERpYW1vbmQsIEdseXBoU3RhciwgR2x5cGhUcmlhbmdsZSwgR2x5cGhXeWUsIEdseXBoU3F1YXJlLCBHbHlwaENpcmNsZSB9O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2159\n")},2515:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, "default", function() { return /* binding */ Line_LineChart; });\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react/index.js\nvar react = __webpack_require__(0);\nvar react_default = /*#__PURE__*/__webpack_require__.n(react);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/lodash/lodash.js\nvar lodash = __webpack_require__(107);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/shared/lib/enhancer/WithTooltip.js\nvar WithTooltip = __webpack_require__(2158);\nvar WithTooltip_default = /*#__PURE__*/__webpack_require__.n(WithTooltip);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/composer/WithTooltip.js\n\n\n/* harmony default export */ var composer_WithTooltip = (WithTooltip_default.a);\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/chart/XYChart.js + 51 modules\nvar XYChart = __webpack_require__(2504);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/chart/CrossHair.js\nvar CrossHair = __webpack_require__(2495);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/aesthetic/LinearGradient.js\nvar LinearGradient = __webpack_require__(2492);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/series/AreaSeries.js\nvar AreaSeries = __webpack_require__(2493);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/theme/esm/color.js\nvar color = __webpack_require__(1965);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/shared/esm/components/FocusBlurHandler.js\nvar FocusBlurHandler = __webpack_require__(2494);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/node_modules/@vx/glyph/dist/vx-glyph.es.js\nvar vx_glyph_es = __webpack_require__(2159);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/node_modules/@vx/shape/dist/vx-shape.es.js\nvar vx_shape_es = __webpack_require__(2155);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/prop-types/index.js\nvar prop_types = __webpack_require__(56);\nvar prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/utils/chartUtils.js\nvar chartUtils = __webpack_require__(1910);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/utils/findClosestDatum.js\nvar findClosestDatum = __webpack_require__(2154);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/utils/interpolatorLookup.js\nvar interpolatorLookup = __webpack_require__(2118);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/utils/propShapes.js\nvar propShapes = __webpack_require__(1905);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/utils/sharedSeriesProps.js\nvar sharedSeriesProps = __webpack_require__(1951);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/series/LineSeries.js\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar propTypes = _extends({}, sharedSeriesProps["a" /* default */], {\n  data: propShapes["e" /* lineSeriesDataShape */].isRequired,\n  interpolation: propShapes["d" /* interpolationShape */],\n  showPoints: prop_types_default.a.bool,\n  stroke: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.string]),\n  strokeDasharray: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.string]),\n  strokeWidth: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  strokeOpacity: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  strokeLinecap: prop_types_default.a.oneOf([\'butt\', \'square\', \'round\', \'inherit\'])\n});\n\nvar defaultProps = {\n  interpolation: \'monotoneX\',\n  showPoints: false,\n  stroke: color["a" /* default */].default,\n  strokeDasharray: null,\n  strokeWidth: 3,\n  strokeOpacity: 1,\n  strokeLinecap: \'round\'\n};\n\nvar x = function x(d) {\n  return d.x;\n};\n\nvar y = function y(d) {\n  return d.y;\n};\n\nvar LineSeries_defined = function defined(d) {\n  return Object(chartUtils["j" /* isDefined */])(y(d));\n};\n\nvar noEventsStyles = {\n  pointerEvents: \'none\'\n};\n\nvar LineSeries_LineSeries =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inheritsLoose(LineSeries, _React$PureComponent);\n\n  function LineSeries() {\n    return _React$PureComponent.apply(this, arguments) || this;\n  }\n\n  var _proto = LineSeries.prototype;\n\n  _proto.render = function render() {\n    var _this$props = this.props,\n        data = _this$props.data,\n        disableMouseEvents = _this$props.disableMouseEvents,\n        interpolation = _this$props.interpolation,\n        showPoints = _this$props.showPoints,\n        stroke = _this$props.stroke,\n        strokeDasharray = _this$props.strokeDasharray,\n        strokeWidth = _this$props.strokeWidth,\n        strokeLinecap = _this$props.strokeLinecap,\n        strokeOpacity = _this$props.strokeOpacity,\n        xScale = _this$props.xScale,\n        yScale = _this$props.yScale,\n        margin = _this$props.margin,\n        onClick = _this$props.onClick,\n        onMouseMove = _this$props.onMouseMove,\n        onMouseLeave = _this$props.onMouseLeave;\n    if (!xScale || !yScale) return null;\n    var strokeValue = Object(chartUtils["b" /* callOrValue */])(stroke);\n    var strokeOpacityValue = Object(chartUtils["b" /* callOrValue */])(strokeOpacity);\n    var curve = interpolatorLookup["a" /* default */][interpolation] || interpolatorLookup["a" /* default */].monotoneX;\n    return react_default.a.createElement(vx_shape_es["c" /* LinePath */], {\n      style: disableMouseEvents ? noEventsStyles : null,\n      data: data,\n      xScale: xScale,\n      yScale: yScale,\n      x: x,\n      y: y,\n      stroke: strokeValue,\n      strokeWidth: Object(chartUtils["b" /* callOrValue */])(strokeWidth),\n      strokeDasharray: Object(chartUtils["b" /* callOrValue */])(strokeDasharray),\n      strokeLinecap: strokeLinecap,\n      strokeOpacity: strokeOpacityValue,\n      curve: curve,\n      defined: LineSeries_defined,\n      onClick: disableMouseEvents ? null : onClick && function () {\n        return function (event) {\n          var d = Object(findClosestDatum["a" /* default */])({\n            data: data,\n            getX: x,\n            event: event,\n            xScale: xScale,\n            marginLeft: margin.left\n          });\n          onClick({\n            event: event,\n            data: data,\n            datum: d,\n            color: strokeValue\n          });\n        };\n      },\n      onMouseMove: disableMouseEvents ? null : onMouseMove && function () {\n        return function (event) {\n          var d = Object(findClosestDatum["a" /* default */])({\n            data: data,\n            getX: x,\n            event: event,\n            xScale: xScale,\n            marginLeft: margin.left\n          });\n          onMouseMove({\n            event: event,\n            data: data,\n            datum: d,\n            color: strokeValue\n          });\n        };\n      },\n      onMouseLeave: disableMouseEvents ? null : onMouseLeave && function () {\n        return onMouseLeave;\n      },\n      glyph: function glyph(d, i) {\n        return (// <a /> wrapper is needed for focusing with SVG 1.2 regardless of whether we show a point\n          Object(chartUtils["j" /* isDefined */])(x(d)) && Object(chartUtils["j" /* isDefined */])(y(d)) && react_default.a.createElement(FocusBlurHandler["a" /* default */], {\n            key: "linepoint-" + i,\n            onBlur: disableMouseEvents ? null : onMouseLeave,\n            onFocus: disableMouseEvents ? null : function (event) {\n              onMouseMove({\n                event: event,\n                data: data,\n                datum: d,\n                color: d.stroke || Object(chartUtils["b" /* callOrValue */])(stroke, d, i),\n                index: i\n              });\n            }\n          }, showPoints && react_default.a.createElement(vx_glyph_es["a" /* GlyphDot */], {\n            key: i + "-" + x(d),\n            cx: xScale(x(d)),\n            cy: yScale(y(d)),\n            r: 4,\n            fill: d.stroke || Object(chartUtils["b" /* callOrValue */])(stroke, d, i),\n            stroke: "#FFFFFF",\n            strokeWidth: 1,\n            style: {\n              pointerEvents: \'none\'\n            }\n          }, d.label && react_default.a.createElement("text", {\n            x: xScale(x(d)),\n            y: yScale(y(d)),\n            dx: 10,\n            fill: d.stroke || Object(chartUtils["b" /* callOrValue */])(stroke, d, i),\n            stroke: "#fff",\n            strokeWidth: 1,\n            fontSize: 12\n          }, d.label)))\n        );\n      }\n    });\n  };\n\n  return LineSeries;\n}(react_default.a.PureComponent);\n\n\nLineSeries_LineSeries.propTypes = propTypes;\nLineSeries_LineSeries.defaultProps = defaultProps;\nLineSeries_LineSeries.displayName = \'LineSeries\';\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/theme/esm/chartTheme.js + 2 modules\nvar chartTheme = __webpack_require__(2527);\n\n// EXTERNAL MODULE: ../superset-ui-core/src/chart-composition/legend/WithLegend.tsx\nvar WithLegend = __webpack_require__(1016);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/reselect/es/index.js\nvar es = __webpack_require__(169);\n\n// EXTERNAL MODULE: ../superset-ui-core/src/chart-composition/tooltip/TooltipFrame.tsx\nvar TooltipFrame = __webpack_require__(1017);\n\n// EXTERNAL MODULE: ../superset-ui-core/src/chart-composition/tooltip/TooltipTable.tsx\nvar TooltipTable = __webpack_require__(1018);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/components/Line/DefaultTooltipRenderer.tsx\n\n\n\nconst MARK_STYLE = { marginRight: 4 };\nfunction DefaultTooltipRenderer({ allSeries, datum, encoder, series = {}, theme = chartTheme["a" /* default */], }) {\n    return (react_default.a.createElement(TooltipFrame["a" /* default */], null,\n        react_default.a.createElement(react_default.a.Fragment, null,\n            react_default.a.createElement("div", { style: { fontFamily: theme.labelStyles.fontFamily } },\n                react_default.a.createElement("strong", null, encoder.channels.x.formatValue(datum.x))),\n            react_default.a.createElement("br", null),\n            series && (react_default.a.createElement(TooltipTable["a" /* default */], { data: allSeries\n                    .filter(({ key }) => series[key])\n                    .concat()\n                    .sort((a, b) => series[b.key].y - series[a.key].y)\n                    .map(({ key, stroke, strokeDasharray, strokeWidth }) => ({\n                    key,\n                    keyColumn: (react_default.a.createElement(react_default.a.Fragment, null,\n                        react_default.a.createElement("svg", { width: "12", height: "8", style: MARK_STYLE },\n                            react_default.a.createElement("line", { x2: "12", y1: "3", y2: "3", stroke: stroke, strokeWidth: strokeWidth, strokeDasharray: strokeDasharray })),\n                        series[key] === datum ? react_default.a.createElement("b", null, key) : key)),\n                    valueColumn: encoder.channels.y.formatValue(series[key].y),\n                })) })))));\n}\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/utils/createMarginSelector.tsx\nvar createMarginSelector = __webpack_require__(1954);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/utils/convertScaleToDataUIScaleShape.ts\nvar convertScaleToDataUIScaleShape = __webpack_require__(1956);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/utils/createXYChartLayoutWithTheme.ts + 8 modules\nvar createXYChartLayoutWithTheme = __webpack_require__(1957);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/components/legend/createRenderLegend.tsx + 3 modules\nvar createRenderLegend = __webpack_require__(1958);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/components/Line/Encoder.ts\nvar Encoder = __webpack_require__(1049);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/components/Line/DefaultLegendItemMarkRenderer.tsx\n\nconst MARK_WIDTH = 12;\nconst MARK_HEIGHT = 8;\nconst DefaultLegendItemMarkRenderer_MARK_STYLE = { display: \'inline-block\' };\nfunction DefaultLegendItemMarkRenderer({ item, }) {\n    var _a, _b, _c;\n    return (react_default.a.createElement("svg", { width: MARK_WIDTH, height: MARK_HEIGHT, style: DefaultLegendItemMarkRenderer_MARK_STYLE },\n        react_default.a.createElement("line", { stroke: (_a = item.output.stroke) !== null && _a !== void 0 ? _a : \'none\', strokeWidth: (_b = item.output.strokeWidth) !== null && _b !== void 0 ? _b : 2, strokeDasharray: (_c = item.output.strokeDasharray) !== null && _c !== void 0 ? _c : \'none\', x1: 0, x2: MARK_WIDTH, y1: MARK_HEIGHT / 2, y2: MARK_HEIGHT / 2 })));\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/components/Line/Line.tsx\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst Line_defaultProps = {\n    className: \'\',\n    encoding: {},\n    LegendItemMarkRenderer: DefaultLegendItemMarkRenderer,\n    margin: createMarginSelector["a" /* DEFAULT_MARGIN */],\n    theme: chartTheme["a" /* default */],\n    TooltipRenderer: DefaultTooltipRenderer,\n};\nconst CIRCLE_STYLE = { strokeWidth: 1.5 };\nclass Line_LineChart extends react["PureComponent"] {\n    constructor() {\n        super(...arguments);\n        this.createEncoder = Encoder["a" /* lineEncoderFactory */].createSelector();\n        this.createAllSeries = Object(es["createSelector"])((input) => input.encoder, input => input.data, (encoder, data) => {\n            const { channels } = encoder;\n            const fieldNames = encoder.getGroupBys();\n            const groups = Object(lodash["groupBy"])(data, row => fieldNames.map(f => `${f}=${row[f]}`).join(\',\'));\n            const allSeries = Object(lodash["values"])(groups).map(seriesData => {\n                const firstDatum = seriesData[0];\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                const key = fieldNames.map(f => firstDatum[f]).join(\',\');\n                const series = {\n                    key: key.length === 0 ? channels.y.getTitle() : key,\n                    fill: channels.fill.encodeDatum(firstDatum, false),\n                    stroke: channels.stroke.encodeDatum(firstDatum, \'#222\'),\n                    strokeDasharray: channels.strokeDasharray.encodeDatum(firstDatum, \'\'),\n                    strokeWidth: channels.strokeWidth.encodeDatum(firstDatum, 1),\n                    values: [],\n                };\n                series.values = seriesData\n                    .map(v => ({\n                    x: channels.x.getValueFromDatum(v),\n                    y: channels.y.getValueFromDatum(v),\n                    data: v,\n                    parent: series,\n                }))\n                    .sort((a, b) => {\n                    const aTime = a.x instanceof Date ? a.x.getTime() : a.x;\n                    const bTime = b.x instanceof Date ? b.x.getTime() : b.x;\n                    return aTime - bTime;\n                });\n                return series;\n            });\n            return allSeries;\n        });\n        this.createMargin = Object(createMarginSelector["b" /* default */])();\n        this.renderChart = (dim) => {\n            const { width, height } = dim;\n            const { data, margin, theme, TooltipRenderer, encoding } = this.props;\n            const encoder = this.createEncoder(encoding);\n            const { channels } = encoder;\n            encoder.setDomainFromDataset(data);\n            const allSeries = this.createAllSeries({ encoder, data });\n            const layout = Object(createXYChartLayoutWithTheme["a" /* default */])({\n                width,\n                height,\n                margin: this.createMargin(margin),\n                theme,\n                xEncoder: channels.x,\n                yEncoder: channels.y,\n            });\n            return layout.renderChartWithFrame((chartDim) => (react_default.a.createElement(composer_WithTooltip, { renderTooltip: ({ datum, series, }) => (react_default.a.createElement(TooltipRenderer, { encoder: encoder, allSeries: allSeries, datum: datum, series: series, theme: theme })) }, ({ onMouseLeave, onMouseMove, tooltipData, }) => (react_default.a.createElement(XYChart["a" /* default */], { showYGrid: true, snapTooltipToDataX: true, width: chartDim.width, height: chartDim.height, ariaLabel: "LineChart", eventTrigger: "container", margin: layout.margin, renderTooltip: null, theme: theme, tooltipData: tooltipData, \n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                xScale: Object(convertScaleToDataUIScaleShape["a" /* default */])(channels.x.definition.scale), \n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                yScale: Object(convertScaleToDataUIScaleShape["a" /* default */])(channels.y.definition.scale), onMouseMove: onMouseMove, onMouseLeave: onMouseLeave },\n                layout.renderXAxis(),\n                layout.renderYAxis(),\n                this.renderSeries(allSeries),\n                react_default.a.createElement(CrossHair["a" /* default */], { fullHeight: true, showCircle: true, showMultipleCircles: true, strokeDasharray: "", showHorizontalLine: false, circleFill: (d) => d.y === tooltipData.datum.y ? d.parent.stroke : \'#fff\', circleSize: (d) => (d.y === tooltipData.datum.y ? 6 : 4), circleStroke: (d) => d.y === tooltipData.datum.y ? \'#fff\' : d.parent.stroke, circleStyles: CIRCLE_STYLE, stroke: "#ccc" }))))));\n        };\n    }\n    // eslint-disable-next-line class-methods-use-this\n    renderSeries(allSeries) {\n        const filledSeries = Object(lodash["flatMap"])(allSeries\n            .filter(({ fill }) => fill)\n            .map(series => {\n            const gradientId = Object(lodash["uniqueId"])(Object(lodash["kebabCase"])(`gradient-${series.key}`));\n            return [\n                react_default.a.createElement(LinearGradient["a" /* default */], { key: `${series.key}-gradient`, id: gradientId, from: series.stroke, to: "#fff" }),\n                react_default.a.createElement(AreaSeries["a" /* default */], { key: `${series.key}-fill`, seriesKey: series.key, data: series.values, interpolation: "linear", fill: `url(#${gradientId})`, stroke: series.stroke, strokeWidth: series.strokeWidth }),\n            ];\n        }));\n        const unfilledSeries = allSeries\n            .filter(({ fill }) => !fill)\n            .map(series => (react_default.a.createElement(LineSeries_LineSeries, { key: series.key, seriesKey: series.key, interpolation: "linear", data: series.values, stroke: series.stroke, strokeDasharray: series.strokeDasharray, strokeWidth: series.strokeWidth })));\n        return filledSeries.concat(unfilledSeries);\n    }\n    render() {\n        const { className, data, width, height, encoding } = this.props;\n        return (react_default.a.createElement(WithLegend["a" /* default */], { className: `superset-chart-line ${className}`, width: width, height: height, position: "top", renderLegend: Object(createRenderLegend["a" /* default */])(this.createEncoder(encoding), data, this.props), renderChart: this.renderChart }));\n    }\n}\nLine_LineChart.defaultProps = Line_defaultProps;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUxNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL3h5LWNoYXJ0L2VzbS9jb21wb3Nlci9XaXRoVG9vbHRpcC5qcz9jMWQ0Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL3h5LWNoYXJ0L2VzbS9zZXJpZXMvTGluZVNlcmllcy5qcz9kNWFjIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wcmVzZXQtY2hhcnQteHkvc3JjL2NvbXBvbmVudHMvTGluZS9EZWZhdWx0VG9vbHRpcFJlbmRlcmVyLnRzeD9mZjJlIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wcmVzZXQtY2hhcnQteHkvc3JjL2NvbXBvbmVudHMvTGluZS9EZWZhdWx0TGVnZW5kSXRlbU1hcmtSZW5kZXJlci50c3g/MjU2MSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvcHJlc2V0LWNoYXJ0LXh5L3NyYy9jb21wb25lbnRzL0xpbmUvTGluZS50c3g/MzM3NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgV2l0aFRvb2x0aXAgZnJvbSAnQGRhdGEtdWkvc2hhcmVkL2xpYi9lbmhhbmNlci9XaXRoVG9vbHRpcCc7XG5leHBvcnQgeyB3aXRoVG9vbHRpcFByb3BUeXBlcyB9IGZyb20gJ0BkYXRhLXVpL3NoYXJlZC9saWIvZW5oYW5jZXIvV2l0aFRvb2x0aXAnO1xuZXhwb3J0IGRlZmF1bHQgV2l0aFRvb2x0aXA7IiwiZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmltcG9ydCB7IGNvbG9yIH0gZnJvbSAnQGRhdGEtdWkvdGhlbWUnO1xuaW1wb3J0IHsgRm9jdXNCbHVySGFuZGxlciB9IGZyb20gJ0BkYXRhLXVpL3NoYXJlZCc7XG5pbXBvcnQgeyBHbHlwaERvdCB9IGZyb20gJ0B2eC9nbHlwaCc7XG5pbXBvcnQgeyBMaW5lUGF0aCB9IGZyb20gJ0B2eC9zaGFwZSc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNhbGxPclZhbHVlLCBpc0RlZmluZWQgfSBmcm9tICcuLi91dGlscy9jaGFydFV0aWxzJztcbmltcG9ydCBmaW5kQ2xvc2VzdERhdHVtIGZyb20gJy4uL3V0aWxzL2ZpbmRDbG9zZXN0RGF0dW0nO1xuaW1wb3J0IGludGVycG9sYXRvckxvb2t1cCBmcm9tICcuLi91dGlscy9pbnRlcnBvbGF0b3JMb29rdXAnO1xuaW1wb3J0IHsgaW50ZXJwb2xhdGlvblNoYXBlLCBsaW5lU2VyaWVzRGF0YVNoYXBlIH0gZnJvbSAnLi4vdXRpbHMvcHJvcFNoYXBlcyc7XG5pbXBvcnQgc2hhcmVkU2VyaWVzUHJvcHMgZnJvbSAnLi4vdXRpbHMvc2hhcmVkU2VyaWVzUHJvcHMnO1xuXG52YXIgcHJvcFR5cGVzID0gX2V4dGVuZHMoe30sIHNoYXJlZFNlcmllc1Byb3BzLCB7XG4gIGRhdGE6IGxpbmVTZXJpZXNEYXRhU2hhcGUuaXNSZXF1aXJlZCxcbiAgaW50ZXJwb2xhdGlvbjogaW50ZXJwb2xhdGlvblNoYXBlLFxuICBzaG93UG9pbnRzOiBQcm9wVHlwZXMuYm9vbCxcbiAgc3Ryb2tlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLnN0cmluZ10pLFxuICBzdHJva2VEYXNoYXJyYXk6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMuc3RyaW5nXSksXG4gIHN0cm9rZVdpZHRoOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm51bWJlcl0pLFxuICBzdHJva2VPcGFjaXR5OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm51bWJlcl0pLFxuICBzdHJva2VMaW5lY2FwOiBQcm9wVHlwZXMub25lT2YoWydidXR0JywgJ3NxdWFyZScsICdyb3VuZCcsICdpbmhlcml0J10pXG59KTtcblxudmFyIGRlZmF1bHRQcm9wcyA9IHtcbiAgaW50ZXJwb2xhdGlvbjogJ21vbm90b25lWCcsXG4gIHNob3dQb2ludHM6IGZhbHNlLFxuICBzdHJva2U6IGNvbG9yLmRlZmF1bHQsXG4gIHN0cm9rZURhc2hhcnJheTogbnVsbCxcbiAgc3Ryb2tlV2lkdGg6IDMsXG4gIHN0cm9rZU9wYWNpdHk6IDEsXG4gIHN0cm9rZUxpbmVjYXA6ICdyb3VuZCdcbn07XG5cbnZhciB4ID0gZnVuY3Rpb24geChkKSB7XG4gIHJldHVybiBkLng7XG59O1xuXG52YXIgeSA9IGZ1bmN0aW9uIHkoZCkge1xuICByZXR1cm4gZC55O1xufTtcblxudmFyIGRlZmluZWQgPSBmdW5jdGlvbiBkZWZpbmVkKGQpIHtcbiAgcmV0dXJuIGlzRGVmaW5lZCh5KGQpKTtcbn07XG5cbnZhciBub0V2ZW50c1N0eWxlcyA9IHtcbiAgcG9pbnRlckV2ZW50czogJ25vbmUnXG59O1xuXG52YXIgTGluZVNlcmllcyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1JlYWN0JFB1cmVDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoTGluZVNlcmllcywgX1JlYWN0JFB1cmVDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIExpbmVTZXJpZXMoKSB7XG4gICAgcmV0dXJuIF9SZWFjdCRQdXJlQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBMaW5lU2VyaWVzLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIGRhdGEgPSBfdGhpcyRwcm9wcy5kYXRhLFxuICAgICAgICBkaXNhYmxlTW91c2VFdmVudHMgPSBfdGhpcyRwcm9wcy5kaXNhYmxlTW91c2VFdmVudHMsXG4gICAgICAgIGludGVycG9sYXRpb24gPSBfdGhpcyRwcm9wcy5pbnRlcnBvbGF0aW9uLFxuICAgICAgICBzaG93UG9pbnRzID0gX3RoaXMkcHJvcHMuc2hvd1BvaW50cyxcbiAgICAgICAgc3Ryb2tlID0gX3RoaXMkcHJvcHMuc3Ryb2tlLFxuICAgICAgICBzdHJva2VEYXNoYXJyYXkgPSBfdGhpcyRwcm9wcy5zdHJva2VEYXNoYXJyYXksXG4gICAgICAgIHN0cm9rZVdpZHRoID0gX3RoaXMkcHJvcHMuc3Ryb2tlV2lkdGgsXG4gICAgICAgIHN0cm9rZUxpbmVjYXAgPSBfdGhpcyRwcm9wcy5zdHJva2VMaW5lY2FwLFxuICAgICAgICBzdHJva2VPcGFjaXR5ID0gX3RoaXMkcHJvcHMuc3Ryb2tlT3BhY2l0eSxcbiAgICAgICAgeFNjYWxlID0gX3RoaXMkcHJvcHMueFNjYWxlLFxuICAgICAgICB5U2NhbGUgPSBfdGhpcyRwcm9wcy55U2NhbGUsXG4gICAgICAgIG1hcmdpbiA9IF90aGlzJHByb3BzLm1hcmdpbixcbiAgICAgICAgb25DbGljayA9IF90aGlzJHByb3BzLm9uQ2xpY2ssXG4gICAgICAgIG9uTW91c2VNb3ZlID0gX3RoaXMkcHJvcHMub25Nb3VzZU1vdmUsXG4gICAgICAgIG9uTW91c2VMZWF2ZSA9IF90aGlzJHByb3BzLm9uTW91c2VMZWF2ZTtcbiAgICBpZiAoIXhTY2FsZSB8fCAheVNjYWxlKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgc3Ryb2tlVmFsdWUgPSBjYWxsT3JWYWx1ZShzdHJva2UpO1xuICAgIHZhciBzdHJva2VPcGFjaXR5VmFsdWUgPSBjYWxsT3JWYWx1ZShzdHJva2VPcGFjaXR5KTtcbiAgICB2YXIgY3VydmUgPSBpbnRlcnBvbGF0b3JMb29rdXBbaW50ZXJwb2xhdGlvbl0gfHwgaW50ZXJwb2xhdG9yTG9va3VwLm1vbm90b25lWDtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChMaW5lUGF0aCwge1xuICAgICAgc3R5bGU6IGRpc2FibGVNb3VzZUV2ZW50cyA/IG5vRXZlbnRzU3R5bGVzIDogbnVsbCxcbiAgICAgIGRhdGE6IGRhdGEsXG4gICAgICB4U2NhbGU6IHhTY2FsZSxcbiAgICAgIHlTY2FsZTogeVNjYWxlLFxuICAgICAgeDogeCxcbiAgICAgIHk6IHksXG4gICAgICBzdHJva2U6IHN0cm9rZVZhbHVlLFxuICAgICAgc3Ryb2tlV2lkdGg6IGNhbGxPclZhbHVlKHN0cm9rZVdpZHRoKSxcbiAgICAgIHN0cm9rZURhc2hhcnJheTogY2FsbE9yVmFsdWUoc3Ryb2tlRGFzaGFycmF5KSxcbiAgICAgIHN0cm9rZUxpbmVjYXA6IHN0cm9rZUxpbmVjYXAsXG4gICAgICBzdHJva2VPcGFjaXR5OiBzdHJva2VPcGFjaXR5VmFsdWUsXG4gICAgICBjdXJ2ZTogY3VydmUsXG4gICAgICBkZWZpbmVkOiBkZWZpbmVkLFxuICAgICAgb25DbGljazogZGlzYWJsZU1vdXNlRXZlbnRzID8gbnVsbCA6IG9uQ2xpY2sgJiYgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgdmFyIGQgPSBmaW5kQ2xvc2VzdERhdHVtKHtcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICBnZXRYOiB4LFxuICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgeFNjYWxlOiB4U2NhbGUsXG4gICAgICAgICAgICBtYXJnaW5MZWZ0OiBtYXJnaW4ubGVmdFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG9uQ2xpY2soe1xuICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIGRhdHVtOiBkLFxuICAgICAgICAgICAgY29sb3I6IHN0cm9rZVZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgb25Nb3VzZU1vdmU6IGRpc2FibGVNb3VzZUV2ZW50cyA/IG51bGwgOiBvbk1vdXNlTW92ZSAmJiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICB2YXIgZCA9IGZpbmRDbG9zZXN0RGF0dW0oe1xuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIGdldFg6IHgsXG4gICAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgICB4U2NhbGU6IHhTY2FsZSxcbiAgICAgICAgICAgIG1hcmdpbkxlZnQ6IG1hcmdpbi5sZWZ0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgb25Nb3VzZU1vdmUoe1xuICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIGRhdHVtOiBkLFxuICAgICAgICAgICAgY29sb3I6IHN0cm9rZVZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgb25Nb3VzZUxlYXZlOiBkaXNhYmxlTW91c2VFdmVudHMgPyBudWxsIDogb25Nb3VzZUxlYXZlICYmIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG9uTW91c2VMZWF2ZTtcbiAgICAgIH0sXG4gICAgICBnbHlwaDogZnVuY3Rpb24gZ2x5cGgoZCwgaSkge1xuICAgICAgICByZXR1cm4gKC8vIDxhIC8+IHdyYXBwZXIgaXMgbmVlZGVkIGZvciBmb2N1c2luZyB3aXRoIFNWRyAxLjIgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHdlIHNob3cgYSBwb2ludFxuICAgICAgICAgIGlzRGVmaW5lZCh4KGQpKSAmJiBpc0RlZmluZWQoeShkKSkgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChGb2N1c0JsdXJIYW5kbGVyLCB7XG4gICAgICAgICAgICBrZXk6IFwibGluZXBvaW50LVwiICsgaSxcbiAgICAgICAgICAgIG9uQmx1cjogZGlzYWJsZU1vdXNlRXZlbnRzID8gbnVsbCA6IG9uTW91c2VMZWF2ZSxcbiAgICAgICAgICAgIG9uRm9jdXM6IGRpc2FibGVNb3VzZUV2ZW50cyA/IG51bGwgOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgb25Nb3VzZU1vdmUoe1xuICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgIGRhdHVtOiBkLFxuICAgICAgICAgICAgICAgIGNvbG9yOiBkLnN0cm9rZSB8fCBjYWxsT3JWYWx1ZShzdHJva2UsIGQsIGkpLFxuICAgICAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHNob3dQb2ludHMgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChHbHlwaERvdCwge1xuICAgICAgICAgICAga2V5OiBpICsgXCItXCIgKyB4KGQpLFxuICAgICAgICAgICAgY3g6IHhTY2FsZSh4KGQpKSxcbiAgICAgICAgICAgIGN5OiB5U2NhbGUoeShkKSksXG4gICAgICAgICAgICByOiA0LFxuICAgICAgICAgICAgZmlsbDogZC5zdHJva2UgfHwgY2FsbE9yVmFsdWUoc3Ryb2tlLCBkLCBpKSxcbiAgICAgICAgICAgIHN0cm9rZTogXCIjRkZGRkZGXCIsXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIGQubGFiZWwgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChcInRleHRcIiwge1xuICAgICAgICAgICAgeDogeFNjYWxlKHgoZCkpLFxuICAgICAgICAgICAgeTogeVNjYWxlKHkoZCkpLFxuICAgICAgICAgICAgZHg6IDEwLFxuICAgICAgICAgICAgZmlsbDogZC5zdHJva2UgfHwgY2FsbE9yVmFsdWUoc3Ryb2tlLCBkLCBpKSxcbiAgICAgICAgICAgIHN0cm9rZTogXCIjZmZmXCIsXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgICAgIGZvbnRTaXplOiAxMlxuICAgICAgICAgIH0sIGQubGFiZWwpKSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gTGluZVNlcmllcztcbn0oUmVhY3QuUHVyZUNvbXBvbmVudCk7XG5cbmV4cG9ydCB7IExpbmVTZXJpZXMgYXMgZGVmYXVsdCB9O1xuTGluZVNlcmllcy5wcm9wVHlwZXMgPSBwcm9wVHlwZXM7XG5MaW5lU2VyaWVzLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbkxpbmVTZXJpZXMuZGlzcGxheU5hbWUgPSAnTGluZVNlcmllcyc7IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFRvb2x0aXBGcmFtZSwgVG9vbHRpcFRhYmxlIH0gZnJvbSAnQHN1cGVyc2V0LXVpL2NvcmUnO1xuaW1wb3J0IHsgY2hhcnRUaGVtZSB9IGZyb20gJ0BkYXRhLXVpL3RoZW1lJztcbmltcG9ydCB7IFRvb2x0aXBQcm9wcyB9IGZyb20gJy4vTGluZSc7XG5cbmNvbnN0IE1BUktfU1RZTEUgPSB7IG1hcmdpblJpZ2h0OiA0IH07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERlZmF1bHRUb29sdGlwUmVuZGVyZXIoe1xuICBhbGxTZXJpZXMsXG4gIGRhdHVtLFxuICBlbmNvZGVyLFxuICBzZXJpZXMgPSB7fSxcbiAgdGhlbWUgPSBjaGFydFRoZW1lLFxufTogVG9vbHRpcFByb3BzKSB7XG4gIHJldHVybiAoXG4gICAgPFRvb2x0aXBGcmFtZT5cbiAgICAgIDw+XG4gICAgICAgIDxkaXYgc3R5bGU9e3sgZm9udEZhbWlseTogdGhlbWUubGFiZWxTdHlsZXMuZm9udEZhbWlseSB9fT5cbiAgICAgICAgICA8c3Ryb25nPntlbmNvZGVyLmNoYW5uZWxzLnguZm9ybWF0VmFsdWUoZGF0dW0ueCl9PC9zdHJvbmc+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8YnIgLz5cbiAgICAgICAge3NlcmllcyAmJiAoXG4gICAgICAgICAgPFRvb2x0aXBUYWJsZVxuICAgICAgICAgICAgZGF0YT17YWxsU2VyaWVzXG4gICAgICAgICAgICAgIC5maWx0ZXIoKHsga2V5IH0pID0+IHNlcmllc1trZXldKVxuICAgICAgICAgICAgICAuY29uY2F0KClcbiAgICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IHNlcmllc1tiLmtleV0ueSAtIHNlcmllc1thLmtleV0ueSlcbiAgICAgICAgICAgICAgLm1hcCgoeyBrZXksIHN0cm9rZSwgc3Ryb2tlRGFzaGFycmF5LCBzdHJva2VXaWR0aCB9KSA9PiAoe1xuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICBrZXlDb2x1bW46IChcbiAgICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxzdmcgd2lkdGg9XCIxMlwiIGhlaWdodD1cIjhcIiBzdHlsZT17TUFSS19TVFlMRX0+XG4gICAgICAgICAgICAgICAgICAgICAgPGxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIHgyPVwiMTJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgeTE9XCIzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkyPVwiM1wiXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U9e3N0cm9rZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoPXtzdHJva2VXaWR0aH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZURhc2hhcnJheT17c3Ryb2tlRGFzaGFycmF5fVxuICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgICAgICAgICAgICB7c2VyaWVzW2tleV0gPT09IGRhdHVtID8gPGI+e2tleX08L2I+IDoga2V5fVxuICAgICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICB2YWx1ZUNvbHVtbjogZW5jb2Rlci5jaGFubmVscy55LmZvcm1hdFZhbHVlKHNlcmllc1trZXldLnkpLFxuICAgICAgICAgICAgICB9KSl9XG4gICAgICAgICAgLz5cbiAgICAgICAgKX1cbiAgICAgIDwvPlxuICAgIDwvVG9vbHRpcEZyYW1lPlxuICApO1xufVxuIiwiaW1wb3J0IFJlYWN0LCB7IENTU1Byb3BlcnRpZXMgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBMZWdlbmRJdGVtTWFya1JlbmRlcmVyUHJvcHMgfSBmcm9tICcuLi9sZWdlbmQvdHlwZXMnO1xuaW1wb3J0IHsgTGluZUVuY29kaW5nQ29uZmlnIH0gZnJvbSAnLi9FbmNvZGVyJztcblxuY29uc3QgTUFSS19XSURUSCA9IDEyO1xuY29uc3QgTUFSS19IRUlHSFQgPSA4O1xuXG5jb25zdCBNQVJLX1NUWUxFOiBDU1NQcm9wZXJ0aWVzID0geyBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyB9O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEZWZhdWx0TGVnZW5kSXRlbU1hcmtSZW5kZXJlcih7XG4gIGl0ZW0sXG59OiBMZWdlbmRJdGVtTWFya1JlbmRlcmVyUHJvcHM8TGluZUVuY29kaW5nQ29uZmlnPikge1xuICByZXR1cm4gKFxuICAgIDxzdmcgd2lkdGg9e01BUktfV0lEVEh9IGhlaWdodD17TUFSS19IRUlHSFR9IHN0eWxlPXtNQVJLX1NUWUxFfT5cbiAgICAgIDxsaW5lXG4gICAgICAgIHN0cm9rZT17aXRlbS5vdXRwdXQuc3Ryb2tlID8/ICdub25lJ31cbiAgICAgICAgc3Ryb2tlV2lkdGg9e2l0ZW0ub3V0cHV0LnN0cm9rZVdpZHRoID8/IDJ9XG4gICAgICAgIHN0cm9rZURhc2hhcnJheT17aXRlbS5vdXRwdXQuc3Ryb2tlRGFzaGFycmF5ID8/ICdub25lJ31cbiAgICAgICAgeDE9ezB9XG4gICAgICAgIHgyPXtNQVJLX1dJRFRIfVxuICAgICAgICB5MT17TUFSS19IRUlHSFQgLyAyfVxuICAgICAgICB5Mj17TUFSS19IRUlHSFQgLyAyfVxuICAgICAgLz5cbiAgICA8L3N2Zz5cbiAgKTtcbn1cbiIsImltcG9ydCBSZWFjdCwgeyBQdXJlQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsga2ViYWJDYXNlLCBncm91cEJ5LCBmbGF0TWFwLCB1bmlxdWVJZCwgdmFsdWVzIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7XG4gIEFyZWFTZXJpZXMsXG4gIExpbmVhckdyYWRpZW50LFxuICBMaW5lU2VyaWVzLFxuICBYWUNoYXJ0LFxuICBDcm9zc0hhaXIsXG4gIFdpdGhUb29sdGlwLFxufSBmcm9tICdAZGF0YS11aS94eS1jaGFydCc7XG5pbXBvcnQgeyBjaGFydFRoZW1lIH0gZnJvbSAnQGRhdGEtdWkvdGhlbWUnO1xuaW1wb3J0IHsgV2l0aExlZ2VuZCwgTWFyZ2luLCBEaW1lbnNpb24gfSBmcm9tICdAc3VwZXJzZXQtdWkvY29yZSc7XG5pbXBvcnQgeyBjcmVhdGVTZWxlY3RvciB9IGZyb20gJ3Jlc2VsZWN0JztcbmltcG9ydCB7IERhdGFzZXQsIFBsYWluT2JqZWN0IH0gZnJvbSAnZW5jb2RhYmxlJztcbmltcG9ydCBEZWZhdWx0VG9vbHRpcFJlbmRlcmVyIGZyb20gJy4vRGVmYXVsdFRvb2x0aXBSZW5kZXJlcic7XG5pbXBvcnQgY3JlYXRlTWFyZ2luU2VsZWN0b3IsIHsgREVGQVVMVF9NQVJHSU4gfSBmcm9tICcuLi8uLi91dGlscy9jcmVhdGVNYXJnaW5TZWxlY3Rvcic7XG5pbXBvcnQgY29udmVydFNjYWxlVG9EYXRhVUlTY2FsZSBmcm9tICcuLi8uLi91dGlscy9jb252ZXJ0U2NhbGVUb0RhdGFVSVNjYWxlU2hhcGUnO1xuaW1wb3J0IGNyZWF0ZVhZQ2hhcnRMYXlvdXRXaXRoVGhlbWUgZnJvbSAnLi4vLi4vdXRpbHMvY3JlYXRlWFlDaGFydExheW91dFdpdGhUaGVtZSc7XG5pbXBvcnQgY3JlYXRlUmVuZGVyTGVnZW5kIGZyb20gJy4uL2xlZ2VuZC9jcmVhdGVSZW5kZXJMZWdlbmQnO1xuaW1wb3J0IHsgTGVnZW5kSG9va3MgfSBmcm9tICcuLi9sZWdlbmQvdHlwZXMnO1xuaW1wb3J0IHtcbiAgbGluZUVuY29kZXJGYWN0b3J5LFxuICBMaW5lRW5jb2RlcixcbiAgTGluZUVuY29kaW5nLFxuICBMaW5lRW5jb2RpbmdDb25maWcsXG4gIExpbmVDaGFubmVsT3V0cHV0cyxcbn0gZnJvbSAnLi9FbmNvZGVyJztcbmltcG9ydCBEZWZhdWx0TGVnZW5kSXRlbU1hcmtSZW5kZXJlciBmcm9tICcuL0RlZmF1bHRMZWdlbmRJdGVtTWFya1JlbmRlcmVyJztcblxuZXhwb3J0IGludGVyZmFjZSBUb29sdGlwUHJvcHMge1xuICBlbmNvZGVyOiBMaW5lRW5jb2RlcjtcbiAgYWxsU2VyaWVzOiBTZXJpZXNbXTtcbiAgZGF0dW06IFNlcmllc1ZhbHVlO1xuICBzZXJpZXM6IHtcbiAgICBba2V5OiBzdHJpbmddOiBTZXJpZXNWYWx1ZTtcbiAgfTtcbiAgdGhlbWU6IHR5cGVvZiBjaGFydFRoZW1lO1xufVxuXG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gIGNsYXNzTmFtZTogJycsXG4gIGVuY29kaW5nOiB7fSxcbiAgTGVnZW5kSXRlbU1hcmtSZW5kZXJlcjogRGVmYXVsdExlZ2VuZEl0ZW1NYXJrUmVuZGVyZXIsXG4gIG1hcmdpbjogREVGQVVMVF9NQVJHSU4sXG4gIHRoZW1lOiBjaGFydFRoZW1lLFxuICBUb29sdGlwUmVuZGVyZXI6IERlZmF1bHRUb29sdGlwUmVuZGVyZXIsXG59O1xuXG4vKiogUGFydCBvZiBmb3JtRGF0YSB0aGF0IGlzIG5lZWRlZCBmb3IgcmVuZGVyaW5nIGxvZ2ljIGluIHRoaXMgZmlsZSAqL1xuZXhwb3J0IHR5cGUgRm9ybURhdGFQcm9wcyA9IHtcbiAgbWFyZ2luPzogTWFyZ2luO1xuICB0aGVtZT86IHR5cGVvZiBjaGFydFRoZW1lO1xuICBlbmNvZGluZz86IFBhcnRpYWw8TGluZUVuY29kaW5nPjtcbn07XG5cbmV4cG9ydCB0eXBlIEhvb2tQcm9wcyA9IHtcbiAgVG9vbHRpcFJlbmRlcmVyPzogUmVhY3QuQ29tcG9uZW50VHlwZTxUb29sdGlwUHJvcHM+O1xufSAmIExlZ2VuZEhvb2tzPExpbmVFbmNvZGluZ0NvbmZpZz47XG5cbnR5cGUgUHJvcHMgPSB7XG4gIGNsYXNzTmFtZT86IHN0cmluZztcbiAgd2lkdGg6IHN0cmluZyB8IG51bWJlcjtcbiAgaGVpZ2h0OiBzdHJpbmcgfCBudW1iZXI7XG4gIGRhdGE6IERhdGFzZXQ7XG59ICYgSG9va1Byb3BzICZcbiAgRm9ybURhdGFQcm9wcyAmXG4gIFJlYWRvbmx5PHR5cGVvZiBkZWZhdWx0UHJvcHM+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFNlcmllcyB7XG4gIGtleTogc3RyaW5nO1xuICBmaWxsOiBMaW5lQ2hhbm5lbE91dHB1dHNbJ2ZpbGwnXTtcbiAgc3Ryb2tlOiBMaW5lQ2hhbm5lbE91dHB1dHNbJ3N0cm9rZSddO1xuICBzdHJva2VEYXNoYXJyYXk6IExpbmVDaGFubmVsT3V0cHV0c1snc3Ryb2tlRGFzaGFycmF5J107XG4gIHN0cm9rZVdpZHRoOiBMaW5lQ2hhbm5lbE91dHB1dHNbJ3N0cm9rZVdpZHRoJ107XG4gIHZhbHVlczogU2VyaWVzVmFsdWVbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZXJpZXNWYWx1ZSB7XG4gIHg6IG51bWJlciB8IERhdGU7XG4gIHk6IG51bWJlcjtcbiAgZGF0YTogUGxhaW5PYmplY3Q7XG4gIHBhcmVudDogU2VyaWVzO1xufVxuXG5jb25zdCBDSVJDTEVfU1RZTEUgPSB7IHN0cm9rZVdpZHRoOiAxLjUgfTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGluZUNoYXJ0IGV4dGVuZHMgUHVyZUNvbXBvbmVudDxQcm9wcz4ge1xuICBwcml2YXRlIGNyZWF0ZUVuY29kZXIgPSBsaW5lRW5jb2RlckZhY3RvcnkuY3JlYXRlU2VsZWN0b3IoKTtcblxuICBwcml2YXRlIGNyZWF0ZUFsbFNlcmllcyA9IGNyZWF0ZVNlbGVjdG9yKFxuICAgIChpbnB1dDogeyBlbmNvZGVyOiBMaW5lRW5jb2RlcjsgZGF0YTogRGF0YXNldCB9KSA9PiBpbnB1dC5lbmNvZGVyLFxuICAgIGlucHV0ID0+IGlucHV0LmRhdGEsXG4gICAgKGVuY29kZXIsIGRhdGEpID0+IHtcbiAgICAgIGNvbnN0IHsgY2hhbm5lbHMgfSA9IGVuY29kZXI7XG4gICAgICBjb25zdCBmaWVsZE5hbWVzID0gZW5jb2Rlci5nZXRHcm91cEJ5cygpO1xuXG4gICAgICBjb25zdCBncm91cHMgPSBncm91cEJ5KGRhdGEsIHJvdyA9PiBmaWVsZE5hbWVzLm1hcChmID0+IGAke2Z9PSR7cm93W2ZdfWApLmpvaW4oJywnKSk7XG5cbiAgICAgIGNvbnN0IGFsbFNlcmllcyA9IHZhbHVlcyhncm91cHMpLm1hcChzZXJpZXNEYXRhID0+IHtcbiAgICAgICAgY29uc3QgZmlyc3REYXR1bSA9IHNlcmllc0RhdGFbMF07XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxuICAgICAgICBjb25zdCBrZXkgPSBmaWVsZE5hbWVzLm1hcChmID0+IGZpcnN0RGF0dW1bZl0pLmpvaW4oJywnKTtcbiAgICAgICAgY29uc3Qgc2VyaWVzOiBTZXJpZXMgPSB7XG4gICAgICAgICAga2V5OiBrZXkubGVuZ3RoID09PSAwID8gY2hhbm5lbHMueS5nZXRUaXRsZSgpIDoga2V5LFxuICAgICAgICAgIGZpbGw6IGNoYW5uZWxzLmZpbGwuZW5jb2RlRGF0dW0oZmlyc3REYXR1bSwgZmFsc2UpLFxuICAgICAgICAgIHN0cm9rZTogY2hhbm5lbHMuc3Ryb2tlLmVuY29kZURhdHVtKGZpcnN0RGF0dW0sICcjMjIyJyksXG4gICAgICAgICAgc3Ryb2tlRGFzaGFycmF5OiBjaGFubmVscy5zdHJva2VEYXNoYXJyYXkuZW5jb2RlRGF0dW0oZmlyc3REYXR1bSwgJycpLFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiBjaGFubmVscy5zdHJva2VXaWR0aC5lbmNvZGVEYXR1bShmaXJzdERhdHVtLCAxKSxcbiAgICAgICAgICB2YWx1ZXM6IFtdLFxuICAgICAgICB9O1xuXG4gICAgICAgIHNlcmllcy52YWx1ZXMgPSBzZXJpZXNEYXRhXG4gICAgICAgICAgLm1hcCh2ID0+ICh7XG4gICAgICAgICAgICB4OiBjaGFubmVscy54LmdldFZhbHVlRnJvbURhdHVtPERhdGUgfCBudW1iZXI+KHYpLFxuICAgICAgICAgICAgeTogY2hhbm5lbHMueS5nZXRWYWx1ZUZyb21EYXR1bTxudW1iZXI+KHYpLFxuICAgICAgICAgICAgZGF0YTogdixcbiAgICAgICAgICAgIHBhcmVudDogc2VyaWVzLFxuICAgICAgICAgIH0pKVxuICAgICAgICAgIC5zb3J0KChhOiBTZXJpZXNWYWx1ZSwgYjogU2VyaWVzVmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFUaW1lID0gYS54IGluc3RhbmNlb2YgRGF0ZSA/IGEueC5nZXRUaW1lKCkgOiBhLng7XG4gICAgICAgICAgICBjb25zdCBiVGltZSA9IGIueCBpbnN0YW5jZW9mIERhdGUgPyBiLnguZ2V0VGltZSgpIDogYi54O1xuXG4gICAgICAgICAgICByZXR1cm4gYVRpbWUgLSBiVGltZTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gc2VyaWVzO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBhbGxTZXJpZXM7XG4gICAgfSxcbiAgKTtcblxuICBwcml2YXRlIGNyZWF0ZU1hcmdpbiA9IGNyZWF0ZU1hcmdpblNlbGVjdG9yKCk7XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuICByZW5kZXJTZXJpZXMoYWxsU2VyaWVzOiBTZXJpZXNbXSkge1xuICAgIGNvbnN0IGZpbGxlZFNlcmllcyA9IGZsYXRNYXAoXG4gICAgICBhbGxTZXJpZXNcbiAgICAgICAgLmZpbHRlcigoeyBmaWxsIH0pID0+IGZpbGwpXG4gICAgICAgIC5tYXAoc2VyaWVzID0+IHtcbiAgICAgICAgICBjb25zdCBncmFkaWVudElkID0gdW5pcXVlSWQoa2ViYWJDYXNlKGBncmFkaWVudC0ke3Nlcmllcy5rZXl9YCkpO1xuXG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIDxMaW5lYXJHcmFkaWVudFxuICAgICAgICAgICAgICBrZXk9e2Ake3Nlcmllcy5rZXl9LWdyYWRpZW50YH1cbiAgICAgICAgICAgICAgaWQ9e2dyYWRpZW50SWR9XG4gICAgICAgICAgICAgIGZyb209e3Nlcmllcy5zdHJva2V9XG4gICAgICAgICAgICAgIHRvPVwiI2ZmZlwiXG4gICAgICAgICAgICAvPixcbiAgICAgICAgICAgIDxBcmVhU2VyaWVzXG4gICAgICAgICAgICAgIGtleT17YCR7c2VyaWVzLmtleX0tZmlsbGB9XG4gICAgICAgICAgICAgIHNlcmllc0tleT17c2VyaWVzLmtleX1cbiAgICAgICAgICAgICAgZGF0YT17c2VyaWVzLnZhbHVlc31cbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGlvbj1cImxpbmVhclwiXG4gICAgICAgICAgICAgIGZpbGw9e2B1cmwoIyR7Z3JhZGllbnRJZH0pYH1cbiAgICAgICAgICAgICAgc3Ryb2tlPXtzZXJpZXMuc3Ryb2tlfVxuICAgICAgICAgICAgICBzdHJva2VXaWR0aD17c2VyaWVzLnN0cm9rZVdpZHRofVxuICAgICAgICAgICAgLz4sXG4gICAgICAgICAgXTtcbiAgICAgICAgfSksXG4gICAgKTtcblxuICAgIGNvbnN0IHVuZmlsbGVkU2VyaWVzID0gYWxsU2VyaWVzXG4gICAgICAuZmlsdGVyKCh7IGZpbGwgfSkgPT4gIWZpbGwpXG4gICAgICAubWFwKHNlcmllcyA9PiAoXG4gICAgICAgIDxMaW5lU2VyaWVzXG4gICAgICAgICAga2V5PXtzZXJpZXMua2V5fVxuICAgICAgICAgIHNlcmllc0tleT17c2VyaWVzLmtleX1cbiAgICAgICAgICBpbnRlcnBvbGF0aW9uPVwibGluZWFyXCJcbiAgICAgICAgICBkYXRhPXtzZXJpZXMudmFsdWVzfVxuICAgICAgICAgIHN0cm9rZT17c2VyaWVzLnN0cm9rZX1cbiAgICAgICAgICBzdHJva2VEYXNoYXJyYXk9e3Nlcmllcy5zdHJva2VEYXNoYXJyYXl9XG4gICAgICAgICAgc3Ryb2tlV2lkdGg9e3Nlcmllcy5zdHJva2VXaWR0aH1cbiAgICAgICAgLz5cbiAgICAgICkpO1xuXG4gICAgcmV0dXJuIGZpbGxlZFNlcmllcy5jb25jYXQodW5maWxsZWRTZXJpZXMpO1xuICB9XG5cbiAgcmVuZGVyQ2hhcnQgPSAoZGltOiBEaW1lbnNpb24pID0+IHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGRpbTtcbiAgICBjb25zdCB7IGRhdGEsIG1hcmdpbiwgdGhlbWUsIFRvb2x0aXBSZW5kZXJlciwgZW5jb2RpbmcgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCBlbmNvZGVyID0gdGhpcy5jcmVhdGVFbmNvZGVyKGVuY29kaW5nKTtcbiAgICBjb25zdCB7IGNoYW5uZWxzIH0gPSBlbmNvZGVyO1xuXG4gICAgZW5jb2Rlci5zZXREb21haW5Gcm9tRGF0YXNldChkYXRhKTtcblxuICAgIGNvbnN0IGFsbFNlcmllcyA9IHRoaXMuY3JlYXRlQWxsU2VyaWVzKHsgZW5jb2RlciwgZGF0YSB9KTtcblxuICAgIGNvbnN0IGxheW91dCA9IGNyZWF0ZVhZQ2hhcnRMYXlvdXRXaXRoVGhlbWUoe1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBtYXJnaW46IHRoaXMuY3JlYXRlTWFyZ2luKG1hcmdpbiksXG4gICAgICB0aGVtZSxcbiAgICAgIHhFbmNvZGVyOiBjaGFubmVscy54LFxuICAgICAgeUVuY29kZXI6IGNoYW5uZWxzLnksXG4gICAgfSk7XG5cbiAgICByZXR1cm4gbGF5b3V0LnJlbmRlckNoYXJ0V2l0aEZyYW1lKChjaGFydERpbTogRGltZW5zaW9uKSA9PiAoXG4gICAgICA8V2l0aFRvb2x0aXBcbiAgICAgICAgcmVuZGVyVG9vbHRpcD17KHtcbiAgICAgICAgICBkYXR1bSxcbiAgICAgICAgICBzZXJpZXMsXG4gICAgICAgIH06IHtcbiAgICAgICAgICBkYXR1bTogU2VyaWVzVmFsdWU7XG4gICAgICAgICAgc2VyaWVzOiB7XG4gICAgICAgICAgICBba2V5OiBzdHJpbmddOiBTZXJpZXNWYWx1ZTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KSA9PiAoXG4gICAgICAgICAgPFRvb2x0aXBSZW5kZXJlclxuICAgICAgICAgICAgZW5jb2Rlcj17ZW5jb2Rlcn1cbiAgICAgICAgICAgIGFsbFNlcmllcz17YWxsU2VyaWVzfVxuICAgICAgICAgICAgZGF0dW09e2RhdHVtfVxuICAgICAgICAgICAgc2VyaWVzPXtzZXJpZXN9XG4gICAgICAgICAgICB0aGVtZT17dGhlbWV9XG4gICAgICAgICAgLz5cbiAgICAgICAgKX1cbiAgICAgID5cbiAgICAgICAgeyh7XG4gICAgICAgICAgb25Nb3VzZUxlYXZlLFxuICAgICAgICAgIG9uTW91c2VNb3ZlLFxuICAgICAgICAgIHRvb2x0aXBEYXRhLFxuICAgICAgICB9OiB7XG4gICAgICAgICAgb25Nb3VzZUxlYXZlOiAoLi4uYXJnczogdW5rbm93bltdKSA9PiB2b2lkO1xuICAgICAgICAgIG9uTW91c2VNb3ZlOiAoLi4uYXJnczogdW5rbm93bltdKSA9PiB2b2lkO1xuICAgICAgICAgIHRvb2x0aXBEYXRhOiB7IGRhdHVtOiB7IHk/OiBudW1iZXIgfSB9O1xuICAgICAgICB9KSA9PiAoXG4gICAgICAgICAgPFhZQ2hhcnRcbiAgICAgICAgICAgIHNob3dZR3JpZFxuICAgICAgICAgICAgc25hcFRvb2x0aXBUb0RhdGFYXG4gICAgICAgICAgICB3aWR0aD17Y2hhcnREaW0ud2lkdGh9XG4gICAgICAgICAgICBoZWlnaHQ9e2NoYXJ0RGltLmhlaWdodH1cbiAgICAgICAgICAgIGFyaWFMYWJlbD1cIkxpbmVDaGFydFwiXG4gICAgICAgICAgICBldmVudFRyaWdnZXI9XCJjb250YWluZXJcIlxuICAgICAgICAgICAgbWFyZ2luPXtsYXlvdXQubWFyZ2lufVxuICAgICAgICAgICAgcmVuZGVyVG9vbHRpcD17bnVsbH1cbiAgICAgICAgICAgIHRoZW1lPXt0aGVtZX1cbiAgICAgICAgICAgIHRvb2x0aXBEYXRhPXt0b29sdGlwRGF0YX1cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICB4U2NhbGU9e2NvbnZlcnRTY2FsZVRvRGF0YVVJU2NhbGUoY2hhbm5lbHMueC5kZWZpbml0aW9uLnNjYWxlIGFzIGFueSl9XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgeVNjYWxlPXtjb252ZXJ0U2NhbGVUb0RhdGFVSVNjYWxlKGNoYW5uZWxzLnkuZGVmaW5pdGlvbi5zY2FsZSBhcyBhbnkpfVxuICAgICAgICAgICAgb25Nb3VzZU1vdmU9e29uTW91c2VNb3ZlfVxuICAgICAgICAgICAgb25Nb3VzZUxlYXZlPXtvbk1vdXNlTGVhdmV9XG4gICAgICAgICAgPlxuICAgICAgICAgICAge2xheW91dC5yZW5kZXJYQXhpcygpfVxuICAgICAgICAgICAge2xheW91dC5yZW5kZXJZQXhpcygpfVxuICAgICAgICAgICAge3RoaXMucmVuZGVyU2VyaWVzKGFsbFNlcmllcyl9XG4gICAgICAgICAgICA8Q3Jvc3NIYWlyXG4gICAgICAgICAgICAgIGZ1bGxIZWlnaHRcbiAgICAgICAgICAgICAgc2hvd0NpcmNsZVxuICAgICAgICAgICAgICBzaG93TXVsdGlwbGVDaXJjbGVzXG4gICAgICAgICAgICAgIHN0cm9rZURhc2hhcnJheT1cIlwiXG4gICAgICAgICAgICAgIHNob3dIb3Jpem9udGFsTGluZT17ZmFsc2V9XG4gICAgICAgICAgICAgIGNpcmNsZUZpbGw9eyhkOiBTZXJpZXNWYWx1ZSkgPT5cbiAgICAgICAgICAgICAgICBkLnkgPT09IHRvb2x0aXBEYXRhLmRhdHVtLnkgPyBkLnBhcmVudC5zdHJva2UgOiAnI2ZmZidcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjaXJjbGVTaXplPXsoZDogU2VyaWVzVmFsdWUpID0+IChkLnkgPT09IHRvb2x0aXBEYXRhLmRhdHVtLnkgPyA2IDogNCl9XG4gICAgICAgICAgICAgIGNpcmNsZVN0cm9rZT17KGQ6IFNlcmllc1ZhbHVlKSA9PlxuICAgICAgICAgICAgICAgIGQueSA9PT0gdG9vbHRpcERhdGEuZGF0dW0ueSA/ICcjZmZmJyA6IGQucGFyZW50LnN0cm9rZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNpcmNsZVN0eWxlcz17Q0lSQ0xFX1NUWUxFfVxuICAgICAgICAgICAgICBzdHJva2U9XCIjY2NjXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgPC9YWUNoYXJ0PlxuICAgICAgICApfVxuICAgICAgPC9XaXRoVG9vbHRpcD5cbiAgICApKTtcbiAgfTtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBjbGFzc05hbWUsIGRhdGEsIHdpZHRoLCBoZWlnaHQsIGVuY29kaW5nIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxXaXRoTGVnZW5kXG4gICAgICAgIGNsYXNzTmFtZT17YHN1cGVyc2V0LWNoYXJ0LWxpbmUgJHtjbGFzc05hbWV9YH1cbiAgICAgICAgd2lkdGg9e3dpZHRofVxuICAgICAgICBoZWlnaHQ9e2hlaWdodH1cbiAgICAgICAgcG9zaXRpb249XCJ0b3BcIlxuICAgICAgICByZW5kZXJMZWdlbmQ9e2NyZWF0ZVJlbmRlckxlZ2VuZCh0aGlzLmNyZWF0ZUVuY29kZXIoZW5jb2RpbmcpLCBkYXRhLCB0aGlzLnByb3BzKX1cbiAgICAgICAgcmVuZGVyQ2hhcnQ9e3RoaXMucmVuZGVyQ2hhcnR9XG4gICAgICAvPlxuICAgICk7XG4gIH1cbn1cbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3JMQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBT0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQVNBO0FBR0E7QUFDQTtBQU1BOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuREE7QUFJQTtBQUNBO0FBRUE7QUFFQTs7QUFHQTtBQUVBO0FBV0E7OztBQ3pCQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFPQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFzQ0E7QUFFQTtBQUFBOztBQUNBO0FBRUE7QUFJQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBaURBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBd0NBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFvQkE7QUFnQkE7QUF2SkE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQU1BO0FBU0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQVlBO0FBQ0E7QUE4RkE7QUFDQTtBQUVBO0FBVUE7O0FBeEpBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2515\n')}}]);