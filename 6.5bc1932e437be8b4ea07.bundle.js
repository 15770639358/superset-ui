(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{1928:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return isValueDef; });\n/* unused harmony export isNonValueDef */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return isFieldDef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return isTypedFieldDef; });\n/* unused harmony export isScaleFieldDef */\n/* unused harmony export isPositionFieldDef */\nfunction isValueDef(channelDef) {\n  return channelDef && 'value' in channelDef;\n}\nfunction isNonValueDef(channelDef) {\n  return channelDef && !('value' in channelDef);\n}\nfunction isFieldDef(channelDef) {\n  return channelDef && 'field' in channelDef && !!channelDef.field;\n}\nfunction isTypedFieldDef(channelDef) {\n  return isFieldDef(channelDef) && 'type' in channelDef && !!channelDef.type;\n}\nfunction isScaleFieldDef(channelDef) {\n  return isTypedFieldDef(channelDef) && 'scale' in channelDef;\n}\nfunction isPositionFieldDef(channelDef) {\n  return isTypedFieldDef(channelDef) && 'axis' in channelDef;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkyOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vdHlwZUd1YXJkcy9DaGFubmVsRGVmLmpzPzg2NmQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGlzVmFsdWVEZWYoY2hhbm5lbERlZikge1xuICByZXR1cm4gY2hhbm5lbERlZiAmJiAndmFsdWUnIGluIGNoYW5uZWxEZWY7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNOb25WYWx1ZURlZihjaGFubmVsRGVmKSB7XG4gIHJldHVybiBjaGFubmVsRGVmICYmICEoJ3ZhbHVlJyBpbiBjaGFubmVsRGVmKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0ZpZWxkRGVmKGNoYW5uZWxEZWYpIHtcbiAgcmV0dXJuIGNoYW5uZWxEZWYgJiYgJ2ZpZWxkJyBpbiBjaGFubmVsRGVmICYmICEhY2hhbm5lbERlZi5maWVsZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1R5cGVkRmllbGREZWYoY2hhbm5lbERlZikge1xuICByZXR1cm4gaXNGaWVsZERlZihjaGFubmVsRGVmKSAmJiAndHlwZScgaW4gY2hhbm5lbERlZiAmJiAhIWNoYW5uZWxEZWYudHlwZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1NjYWxlRmllbGREZWYoY2hhbm5lbERlZikge1xuICByZXR1cm4gaXNUeXBlZEZpZWxkRGVmKGNoYW5uZWxEZWYpICYmICdzY2FsZScgaW4gY2hhbm5lbERlZjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1Bvc2l0aW9uRmllbGREZWYoY2hhbm5lbERlZikge1xuICByZXR1cm4gaXNUeXBlZEZpZWxkRGVmKGNoYW5uZWxEZWYpICYmICdheGlzJyBpbiBjaGFubmVsRGVmO1xufSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1928\n")},2404:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return isCompleteValueDef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return isCompleteFieldDef; });\nfunction isCompleteValueDef(def) {\n  return 'value' in def;\n}\nfunction isCompleteFieldDef(def) {\n  return 'field' in def;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQwNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vdHlwZUd1YXJkcy9Db21wbGV0ZUNoYW5uZWxEZWYuanM/MmJkOCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gaXNDb21wbGV0ZVZhbHVlRGVmKGRlZikge1xuICByZXR1cm4gJ3ZhbHVlJyBpbiBkZWY7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNDb21wbGV0ZUZpZWxkRGVmKGRlZikge1xuICByZXR1cm4gJ2ZpZWxkJyBpbiBkZWY7XG59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2404\n")},2465:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"a\", function() { return /* binding */ createEncoderFactory; });\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/reselect/es/index.js\nvar es = __webpack_require__(181);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/typeGuards/ChannelDef.js\nvar ChannelDef = __webpack_require__(1928);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/typeGuards/Base.js\nfunction isArray(maybeArray) {\n  return Array.isArray(maybeArray);\n}\nfunction isNotArray(maybeArray) {\n  return !Array.isArray(maybeArray);\n}\nfunction isDefined(value) {\n  return typeof value !== 'undefined' && value !== null;\n}\nfunction isEveryElementDefined(array) {\n  return array.every(isDefined);\n}\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-array/src/extent.js\nvar src_extent = __webpack_require__(279);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/types/scale/ScaleType.js\n// Modified from vega-lite\n// because vega-lite uses namespace which has issues with babel and typescript\nconst ScaleType = {\n  // Continuous - Quantitative\n  LINEAR: 'linear',\n  LOG: 'log',\n  POW: 'pow',\n  SQRT: 'sqrt',\n  SYMLOG: 'symlog',\n  // Continuous - Time\n  TIME: 'time',\n  UTC: 'utc',\n  // Discretizing scales\n  QUANTILE: 'quantile',\n  QUANTIZE: 'quantize',\n  THRESHOLD: 'threshold',\n  BIN_ORDINAL: 'bin-ordinal',\n  // Discrete scales\n  ORDINAL: 'ordinal',\n  POINT: 'point',\n  BAND: 'band'\n};\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/typeGuards/Channel.js\nfunction isX(channelType) {\n  return channelType === 'X' || channelType === 'XBand';\n}\nfunction isY(channelType) {\n  return channelType === 'Y' || channelType === 'YBand';\n}\nfunction isXOrY(channelType) {\n  return isX(channelType) || isY(channelType);\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/utils/keys.js\n/**\n * This is a stricter version of Object.keys but with better types.\n * See https://github.com/Microsoft/TypeScript/pull/12253#issuecomment-263132208\n */\nconst keys = Object.keys;\n/* harmony default export */ var utils_keys = (keys);\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/dateTimeToTimestamp.js\n// Modified from vega-lite version\n// and remove unnecessary dependency\n\n/* eslint-disable no-param-reassign */\n\n/* eslint-disable no-negated-condition */\n\n/**\n * Internal Object for defining datetime expressions.\n * This is an expression version of DateTime.\n * If both month and quarter are provided, month has higher precedence.\n * `day` cannot be combined with other date.\n */\n\nfunction invalidTimeUnit(unitName, value) {\n  return \"Invalid \" + unitName + \": \" + String(value) + \".\";\n}\n/*\n * A designated year that starts on Sunday.\n */\n\n\nconst SUNDAY_YEAR = 2006;\nconst MONTHS = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december'];\nconst SHORT_MONTHS = MONTHS.map(m => m.slice(0, 3));\nconst DAYS = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];\nconst SHORT_DAYS = DAYS.map(d => d.slice(0, 3));\n\nfunction isNumber(x) {\n  return typeof x === 'number';\n}\n/**\n * Returns whether the passed in value is a valid number.\n */\n\n\nfunction isNumeric(value) {\n  if (isNumber(value)) {\n    return true;\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  return !isNaN(value) && !isNaN(parseFloat(value));\n}\n\nfunction normalizeQuarter(q) {\n  if (isNumeric(q)) {\n    q = Number(q);\n  }\n\n  if (isNumber(q)) {\n    if (q > 4) {\n      // eslint-disable-next-line no-console\n      console.warn(invalidTimeUnit('quarter', q));\n    } // We accept 1-based quarter, so need to readjust to 0-based quarter\n\n\n    return q - 1;\n  } // Invalid quarter\n\n\n  throw new Error(invalidTimeUnit('quarter', q));\n}\nfunction normalizeMonth(m) {\n  if (isNumeric(m)) {\n    m = Number(m);\n  }\n\n  if (isNumber(m)) {\n    // We accept 1-based month, so need to readjust to 0-based month\n    return m - 1;\n  }\n\n  const lowerM = m.toLowerCase();\n  const monthIndex = MONTHS.indexOf(lowerM);\n\n  if (monthIndex !== -1) {\n    return monthIndex; // 0 for january, ...\n  }\n\n  const shortM = lowerM.slice(0, 3);\n  const shortMonthIndex = SHORT_MONTHS.indexOf(shortM);\n\n  if (shortMonthIndex !== -1) {\n    return shortMonthIndex;\n  } // Invalid month\n\n\n  throw new Error(invalidTimeUnit('month', m));\n}\nfunction normalizeDay(d) {\n  if (isNumeric(d)) {\n    d = Number(d);\n  }\n\n  if (isNumber(d)) {\n    // mod so that this can be both 0-based where 0 = sunday\n    // and 1-based where 7=sunday\n    return d % 7;\n  }\n\n  const lowerD = d.toLowerCase();\n  const dayIndex = DAYS.indexOf(lowerD);\n\n  if (dayIndex !== -1) {\n    return dayIndex; // 0 for january, ...\n  }\n\n  const shortD = lowerD.slice(0, 3);\n  const shortDayIndex = SHORT_DAYS.indexOf(shortD);\n\n  if (shortDayIndex !== -1) {\n    return shortDayIndex;\n  } // Invalid day\n\n\n  throw new Error(invalidTimeUnit('day', d));\n}\n/**\n * @param d the date.\n * @param normalize whether to normalize quarter, month, day. This should probably be true if d is a DateTime.\n * @returns array of date time parts [year, month, day, hours, minutes, seconds, milliseconds]\n */\n\nfunction dateTimeParts(d, normalize) {\n  const parts = [];\n\n  if (normalize && d.day !== undefined) {\n    if (utils_keys(d).length > 1) {\n      d = { ...d\n      };\n      delete d.day;\n    }\n  }\n\n  if (d.year !== undefined) {\n    parts.push(d.year);\n  } else if (d.day !== undefined) {\n    // Set year to 2006 for working with day since January 1 2006 is a Sunday\n    parts.push(SUNDAY_YEAR);\n  } else {\n    parts.push(0);\n  }\n\n  if (d.month !== undefined) {\n    const month = normalize ? normalizeMonth(d.month) : d.month;\n    parts.push(month);\n  } else if (d.quarter !== undefined) {\n    const quarter = normalize ? normalizeQuarter(d.quarter) : d.quarter;\n    parts.push(isNumber(quarter) ? quarter * 3 : quarter + \"*3\");\n  } else {\n    parts.push(0); // months start at zero in JS\n  }\n\n  if (d.date !== undefined) {\n    parts.push(d.date);\n  } else if (d.day !== undefined) {\n    // HACK: Day only works as a standalone unit\n    // This is only correct because we always set year to 2006 for day\n    const day = normalize ? normalizeDay(d.day) : d.day;\n    parts.push(isNumber(day) ? day + 1 : day + \"+1\");\n  } else {\n    parts.push(1); // Date starts at 1 in JS\n  }\n\n  ['hours', 'minutes', 'seconds', 'milliseconds'].forEach(timeUnit => {\n    const unit = d[timeUnit];\n    parts.push(typeof unit === 'undefined' ? 0 : unit);\n  });\n  return parts;\n}\n/**\n * @param d the date time.\n * @returns the timestamp.\n */\n\nfunction dateTimeToTimestamp(d) {\n  const parts = dateTimeParts(d, true);\n\n  if (d.utc) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return Number(new Date(Date.UTC(...parts)));\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  return Number(new Date(...parts));\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/parseDateTime.js\n\nfunction parseDateTime(dateTime) {\n  if (typeof dateTime === 'number' || typeof dateTime === 'string') {\n    return new Date(dateTime);\n  }\n\n  return new Date(dateTimeToTimestamp(dateTime));\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/utils/inferElementTypeFromUnionOfArrayTypes.js\n/**\n * Type workaround for https://github.com/Microsoft/TypeScript/issues/7294#issuecomment-465794460\n * to avoid error \"Cannot invoke an expression whose type lacks a call signature\"\n * when using array.map\n */\nfunction inferElementTypeFromUnionOfArrayTypes(array) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return array;\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/typeGuards/DateTime.js\n// eslint-disable-next-line import/prefer-default-export\nfunction isDateTime(o) {\n  return !!o && !(o instanceof Date) && typeof o !== 'string' && typeof o !== 'boolean' && typeof o !== 'number' && ('year' in o && o.year != null || 'quarter' in o && o.quarter != null || 'month' in o && o.month != null || 'date' in o && o.date != null || 'day' in o && o.day != null || 'hours' in o && o.hours != null || 'minutes' in o && o.minutes != null || 'seconds' in o && o.seconds != null || 'milliseconds' in o && o.milliseconds != null);\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/format/fallbackFormatter.js\nfunction fallbackFormatter(v) {\n  return \"\" + v;\n}\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/options/Encodable.js\nvar Encodable = __webpack_require__(1170);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/format/createFormatter.js\n\n\nfunction createFormatter({\n  formatType,\n  format,\n  formatInLocalTime\n}) {\n  if (formatType === 'time') {\n    const formatter = Encodable[\"a\" /* default */].resolveTimeFormat({\n      format,\n      formatInLocalTime\n    });\n    return value => formatter(value);\n  }\n\n  if (formatType === 'number' || typeof format !== 'undefined' && format.length > 0) {\n    const formatter = Encodable[\"a\" /* default */].resolveNumberFormat(format);\n    return value => formatter(value);\n  }\n\n  return fallbackFormatter;\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/encoders/ChannelEncoderAxis.js\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\nclass ChannelEncoderAxis_ChannelEncoderAxis {\n  constructor(channelEncoder) {\n    _defineProperty(this, \"channelEncoder\", void 0);\n\n    _defineProperty(this, \"config\", void 0);\n\n    _defineProperty(this, \"formatValue\", void 0);\n\n    this.channelEncoder = channelEncoder;\n    this.config = channelEncoder.definition.axis;\n    this.formatValue = createFormatter(this.config);\n  }\n\n  getTitle() {\n    return this.config.title;\n  }\n\n  hasTitle() {\n    const {\n      title\n    } = this.config;\n    return title !== null && typeof title !== 'undefined' && title !== '';\n  }\n\n  getTickLabels() {\n    const {\n      tickCount,\n      values\n    } = this.config;\n\n    if (typeof values !== 'undefined') {\n      return inferElementTypeFromUnionOfArrayTypes(values).map(v => this.formatValue(isDateTime(v) ? parseDateTime(v) : v));\n    }\n\n    const {\n      scale\n    } = this.channelEncoder;\n\n    if (scale && 'domain' in scale) {\n      const ticks = 'ticks' in scale ? scale.ticks(tickCount) : scale.domain();\n      return ticks.map(this.formatValue);\n    }\n\n    return [];\n  }\n\n}\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/lodash.get/index.js\nvar lodash_get = __webpack_require__(1172);\nvar lodash_get_default = /*#__PURE__*/__webpack_require__.n(lodash_get);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/createGetterFromChannelDef.js\n\n\nfunction createGetterFromChannelDef(definition) {\n  if (Object(ChannelDef[\"c\" /* isValueDef */])(definition)) {\n    return () => definition.value;\n  }\n\n  if (typeof definition.field !== 'undefined') {\n    return x => lodash_get_default()(x, definition.field);\n  }\n\n  return () => undefined;\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/utils/isDisabled.js\nfunction isDisabled(config) {\n  return config === false || config === null;\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/utils/isEnabled.js\n\nfunction isEnabled(config) {\n  return !isDisabled(config);\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/fillers/expandLabelOverlapStrategy.js\n\nconst STRATEGY_FLAT = {\n  strategy: 'flat'\n};\nconst STRATEGY_ROTATE = {\n  labelAngle: 40,\n  strategy: 'rotate'\n};\nfunction expandLabelOverlapStrategy(channelType, labelOverlap = 'auto') {\n  let output;\n\n  switch (labelOverlap) {\n    case 'flat':\n      output = STRATEGY_FLAT;\n      break;\n\n    case 'rotate':\n      output = STRATEGY_ROTATE;\n      break;\n\n    case 'auto':\n      output = isX(channelType) ? STRATEGY_ROTATE : STRATEGY_FLAT;\n      break;\n\n    default:\n      output = labelOverlap;\n      break;\n  }\n\n  return { ...output\n  };\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/scaleCategories.js\n // Grouped by domain and range\n\nconst continuousToContinuousScaleTypes = [ScaleType.LINEAR, ScaleType.POW, ScaleType.SQRT, ScaleType.SYMLOG, ScaleType.LOG, ScaleType.TIME, ScaleType.UTC];\nconst continuousToContinuousScaleTypesSet = new Set(continuousToContinuousScaleTypes);\nconst continuousToDiscreteScaleTypes = [ScaleType.QUANTILE, ScaleType.QUANTIZE, ScaleType.THRESHOLD];\nconst continuousToDiscreteScaleTypesSet = new Set(continuousToDiscreteScaleTypes); // Grouped by Domain\n\nconst continuousDomainScaleTypes = continuousToContinuousScaleTypes.concat(continuousToDiscreteScaleTypes);\nconst continuousDomainScaleTypesSet = new Set(continuousDomainScaleTypes);\nconst discreteDomainScaleTypes = [ScaleType.ORDINAL, ScaleType.BIN_ORDINAL, ScaleType.POINT, ScaleType.BAND];\nconst discreteDomainScaleTypesSet = new Set(discreteDomainScaleTypes); // Three broad categories\n\nconst continuousScaleTypes = continuousToContinuousScaleTypes;\nconst continuousScaleTypesSet = continuousToContinuousScaleTypesSet;\nconst discreteScaleTypes = [ScaleType.BAND, ScaleType.POINT, ScaleType.ORDINAL];\nconst discreteScaleTypesSet = new Set(discreteScaleTypes);\nconst discretizingScaleTypes = [ScaleType.BIN_ORDINAL, ScaleType.QUANTILE, ScaleType.QUANTIZE, ScaleType.THRESHOLD];\nconst discretizingScaleTypesSet = new Set(discretizingScaleTypes); // Others\n\nconst timeScaleTypes = [ScaleType.TIME, ScaleType.UTC];\nconst timeScaleTypesSet = new Set(timeScaleTypes);\nconst allScaleTypes = [ScaleType.LINEAR, ScaleType.LOG, ScaleType.POW, ScaleType.SQRT, ScaleType.SYMLOG, ScaleType.TIME, ScaleType.UTC, ScaleType.QUANTILE, ScaleType.QUANTIZE, ScaleType.THRESHOLD, ScaleType.BIN_ORDINAL, ScaleType.ORDINAL, ScaleType.POINT, ScaleType.BAND];\nconst allScaleTypesSet = new Set(allScaleTypes);\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/fillers/completeAxisConfig.js\n\n\n\n\n\n\nfunction isChannelDefWithAxisSupport(channelType, channelDef) {\n  return Object(ChannelDef[\"b\" /* isTypedFieldDef */])(channelDef) && isXOrY(channelType);\n}\n\nfunction completeAxisConfig(channelType, channelDef) {\n  if (isChannelDefWithAxisSupport(channelType, channelDef) && isEnabled(channelDef.axis)) {\n    const axis = channelDef.axis === true || typeof channelDef.axis === 'undefined' ? {} : channelDef.axis;\n    const isXChannel = isX(channelType);\n    const {\n      format = channelDef.format,\n      formatType = channelDef.formatType,\n      formatInLocalTime = channelDef.formatInLocalTime,\n      labelAngle = 0,\n      labelFlush,\n      labelOverlap,\n      labelPadding = 4,\n      orient = isXChannel ? 'bottom' : 'left',\n      tickCount = 5,\n      ticks = true,\n      title = channelDef.title,\n      titlePadding = 4\n    } = axis;\n    const output = { ...axis,\n      format,\n      formatType,\n      labelAngle,\n      labelFlush: typeof labelFlush === 'undefined' ? channelDef.scale && typeof channelDef.scale.type !== 'undefined' && continuousToContinuousScaleTypesSet.has(channelDef.scale.type) : labelFlush,\n      labelOverlap: expandLabelOverlapStrategy(channelType, labelOverlap),\n      labelPadding,\n      orient,\n      tickCount,\n      ticks,\n      title,\n      titlePadding\n    };\n\n    if (typeof formatInLocalTime !== 'undefined') {\n      output.formatInLocalTime = formatInLocalTime;\n    }\n\n    return output;\n  }\n\n  return false;\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/fillers/completeFormatConfig.js\nfunction completeFormatConfig(config) {\n  const {\n    formatType,\n    formatInLocalTime,\n    format,\n    type,\n    scaleType\n  } = config;\n  let resolvedFormatType;\n\n  if (typeof formatType !== 'undefined') {\n    resolvedFormatType = formatType;\n  } else if (type === 'quantitative') {\n    resolvedFormatType = 'number';\n  } else if (type === 'temporal' || scaleType === 'time' || scaleType === 'utc') {\n    resolvedFormatType = 'time';\n  } else if (typeof format !== 'undefined' && format.length > 0) {\n    resolvedFormatType = 'number';\n  }\n\n  if (resolvedFormatType === 'time') {\n    return {\n      formatType: 'time',\n      formatInLocalTime: formatInLocalTime || typeof formatInLocalTime === 'undefined' && scaleType === 'time',\n      format\n    };\n  }\n\n  return {\n    formatType: resolvedFormatType,\n    format\n  };\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/fillers/completeLegendConfig.js\n\nfunction completeLegendConfig(channelType, channelDef) {\n  if ('legend' in channelDef && channelDef.legend !== undefined) {\n    return channelDef.legend;\n  }\n\n  return isXOrY(channelType) || channelType === 'Text' ? false : {};\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/fillers/inferScaleType.js\n\n/**\n * Sometimes scale type is not specified but can be inferred\n * from other fields.\n * See https://vega.github.io/vega-lite/docs/scale.html\n * @param channelType type of the channel\n * @param fieldType type of the field\n * @param bin is value binned\n */\n\nfunction inferScaleType(channelType, fieldType, bin = false) {\n  if (fieldType === 'nominal' || fieldType === 'ordinal') {\n    switch (channelType) {\n      // For positional (x and y) ordinal and ordinal fields,\n      // \"point\" is the default scale type for all marks\n      // except bar and rect marks, which use \"band\" scales.\n      // https://vega.github.io/vega-lite/docs/scale.html\n      case 'XBand':\n      case 'YBand':\n        return ScaleType.BAND;\n\n      case 'X':\n      case 'Y':\n      case 'Numeric':\n        return ScaleType.POINT;\n\n      case 'Color':\n      case 'Category':\n        return ScaleType.ORDINAL;\n\n      default:\n    }\n  } else if (fieldType === 'quantitative') {\n    switch (channelType) {\n      case 'XBand':\n      case 'YBand':\n      case 'X':\n      case 'Y':\n      case 'Numeric':\n        return ScaleType.LINEAR;\n\n      case 'Color':\n        return bin ? ScaleType.BIN_ORDINAL : ScaleType.LINEAR;\n\n      default:\n    }\n  } else if (fieldType === 'temporal') {\n    switch (channelType) {\n      case 'XBand':\n      case 'YBand':\n      case 'X':\n      case 'Y':\n      case 'Numeric':\n        return ScaleType.UTC;\n\n      case 'Color':\n        return ScaleType.LINEAR;\n\n      default:\n    }\n  }\n\n  return undefined;\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/isPropertySupportedByScaleType.js\n\n\nconst pointOrBand = [ScaleType.POINT, ScaleType.BAND];\nconst pointOrBandSet = new Set(pointOrBand);\nconst exceptPointOrBand = allScaleTypes.filter(type => !pointOrBandSet.has(type));\nconst exceptPointOrBandSet = new Set(exceptPointOrBand);\nconst continuousOrPointOrBandSet = new Set(continuousScaleTypes.concat(pointOrBand));\nconst zeroSet = new Set(continuousDomainScaleTypes); // log scale cannot have zero value\n\nzeroSet.delete(ScaleType.LOG); // zero is not meaningful for time\n\nzeroSet.delete(ScaleType.TIME);\nzeroSet.delete(ScaleType.UTC); // threshold requires custom domain so zero does not matter\n\nzeroSet.delete(ScaleType.THRESHOLD); // quantile depends on distribution so zero does not matter\n\nzeroSet.delete(ScaleType.QUANTILE);\nconst supportedScaleTypes = {\n  align: pointOrBandSet,\n  base: new Set([ScaleType.LOG]),\n  clamp: continuousScaleTypesSet,\n  constant: new Set([ScaleType.SYMLOG]),\n  domain: allScaleTypesSet,\n  exponent: new Set([ScaleType.POW]),\n  interpolate: exceptPointOrBandSet,\n  nice: new Set(continuousScaleTypes.concat([ScaleType.QUANTIZE, ScaleType.THRESHOLD])),\n  padding: continuousOrPointOrBandSet,\n  paddingInner: new Set([ScaleType.BAND]),\n  paddingOuter: pointOrBandSet,\n  range: allScaleTypesSet,\n  reverse: allScaleTypesSet,\n  round: continuousOrPointOrBandSet,\n  scheme: exceptPointOrBandSet,\n  type: allScaleTypesSet,\n  unknown: new Set([ScaleType.ORDINAL]),\n  zero: zeroSet\n};\nfunction isPropertySupportedByScaleType(property, scaleType) {\n  return supportedScaleTypes[property].has(scaleType);\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/typeGuards/ScaleConfig.js\n\n\nfunction isContinuousScaleConfig(config) {\n  return continuousScaleTypesSet.has(config.type);\n}\nfunction isDiscretizingScaleConfig(config) {\n  return discretizingScaleTypesSet.has(config.type);\n}\nfunction isDiscreteScaleConfig(config) {\n  return discreteScaleTypesSet.has(config.type);\n}\nfunction isScaleConfigWithZero(config) {\n  return isPropertySupportedByScaleType('zero', config.type);\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/fillers/completeScaleConfig.js\n\n\n\n\n\nfunction completeScaleConfig(channelType, channelDef) {\n  if (Object(ChannelDef[\"b\" /* isTypedFieldDef */])(channelDef) && isEnabled(channelDef.scale)) {\n    const {\n      scale = {},\n      type,\n      bin\n    } = channelDef;\n    const {\n      type: scaleType = inferScaleType(channelType, type, bin)\n    } = scale;\n\n    if (typeof scaleType === 'undefined') {\n      return false;\n    } // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n\n\n    const filledScale = { ...scale,\n      type: scaleType\n    };\n\n    if (isContinuousScaleConfig(filledScale)) {\n      if (typeof filledScale.nice === 'undefined') {\n        filledScale.nice = !timeScaleTypesSet.has(scaleType);\n      }\n\n      if (typeof filledScale.clamp === 'undefined') {\n        filledScale.clamp = true;\n      }\n    }\n\n    if (isScaleConfigWithZero(filledScale) && typeof filledScale.zero === 'undefined') {\n      filledScale.zero = true;\n    }\n\n    return filledScale;\n  }\n\n  return false;\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/fillers/inferFieldType.js\n\nconst temporalFieldNames = new Set(['time', 'date', 'datetime', 'timestamp']);\nfunction inferFieldType(channelType, field = '') {\n  if (isXOrY(channelType) || channelType === 'Numeric') {\n    return temporalFieldNames.has(field.toLowerCase()) ? 'temporal' : 'quantitative';\n  }\n\n  return 'nominal';\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/fillers/completeChannelDef.js\n\n\n\n\n\n\nfunction completeChannelDef(channelType, channelDef) {\n  var _channelDef$title;\n\n  if (Object(ChannelDef[\"c\" /* isValueDef */])(channelDef)) {\n    return { ...channelDef,\n      axis: false,\n      legend: false,\n      scale: false,\n      title: ''\n    };\n  } // Fill top-level properties\n\n\n  const copy = { ...channelDef,\n    title: Object(ChannelDef[\"a\" /* isFieldDef */])(channelDef) ? (_channelDef$title = channelDef.title) != null ? _channelDef$title : channelDef.field : '',\n    type: Object(ChannelDef[\"b\" /* isTypedFieldDef */])(channelDef) ? channelDef.type : inferFieldType(channelType, channelDef.field)\n  }; // Scale needs the top-level properties to be filled.\n\n  const scale = completeScaleConfig(channelType, copy); // Format needs scale.\n\n  const format = completeFormatConfig({ ...channelDef,\n    scaleType: scale ? scale.type : undefined\n  });\n  const copy2 = { ...copy,\n    ...format,\n    scale\n  }; // These need scale and format\n\n  const axis = completeAxisConfig(channelType, copy2);\n  const legend = completeLegendConfig(channelType, copy2);\n  return { ...copy2,\n    axis,\n    legend\n  };\n}\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-scale/src/linear.js\nvar linear = __webpack_require__(70);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-scale/src/log.js\nvar log = __webpack_require__(262);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-scale/src/pow.js\nvar pow = __webpack_require__(214);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-scale/src/time.js + 3 modules\nvar time = __webpack_require__(438);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-scale/src/utcTime.js + 3 modules\nvar utcTime = __webpack_require__(1074);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-scale/src/quantile.js\nvar quantile = __webpack_require__(981);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-scale/src/quantize.js\nvar quantize = __webpack_require__(982);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-scale/src/threshold.js\nvar threshold = __webpack_require__(983);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-scale/src/ordinal.js\nvar ordinal = __webpack_require__(329);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-scale/src/band.js + 1 modules\nvar band = __webpack_require__(590);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-scale/src/symlog.js\nvar symlog = __webpack_require__(263);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/createScaleFromScaleType.js\n\n\nfunction createScaleFromScaleType(type) {\n  switch (type) {\n    case ScaleType.LINEAR:\n      return Object(linear[\"a\" /* default */])();\n\n    case ScaleType.LOG:\n      return Object(log[\"a\" /* default */])();\n\n    case ScaleType.POW:\n      return Object(pow[\"a\" /* default */])();\n\n    case ScaleType.SQRT:\n      return Object(pow[\"c\" /* sqrt */])();\n\n    case ScaleType.TIME:\n      return Object(time[\"b\" /* default */])();\n\n    case ScaleType.UTC:\n      return Object(utcTime[\"a\" /* default */])();\n\n    case ScaleType.QUANTILE:\n      return Object(quantile[\"a\" /* default */])();\n\n    case ScaleType.QUANTIZE:\n      return Object(quantize[\"a\" /* default */])();\n\n    case ScaleType.THRESHOLD:\n      return Object(threshold[\"a\" /* default */])();\n\n    case ScaleType.ORDINAL:\n      return Object(ordinal[\"a\" /* default */])();\n\n    case ScaleType.POINT:\n      return Object(band[\"b\" /* point */])();\n\n    case ScaleType.BAND:\n      return Object(band[\"a\" /* default */])();\n\n    case ScaleType.SYMLOG:\n      return Object(symlog[\"a\" /* default */])();\n\n    case ScaleType.BIN_ORDINAL:\n      // TODO: Pending scale.bins implementation\n      throw new Error(\"\\\"type = \" + type + \"\\\" is not supported yet.\");\n\n    default:\n      return Object(linear[\"a\" /* default */])();\n  }\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/applyAlign.js\nfunction applyAlign(config, scale) {\n  if ('align' in config && typeof config.align !== 'undefined' && 'align' in scale) {\n    scale.align(config.align);\n  }\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/applyBase.js\nfunction applyBase(config, scale) {\n  if ('base' in config && typeof config.base !== 'undefined' && 'base' in scale) {\n    scale.base(config.base);\n  }\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/applyClamp.js\nfunction applyClamp(config, scale) {\n  if ('clamp' in config && config.clamp === true && 'clamp' in scale) {\n    scale.clamp(config.clamp);\n  }\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/applyExponent.js\nfunction applyExponent(config, scale) {\n  if ('exponent' in config && typeof config.exponent !== 'undefined' && 'exponent' in scale) {\n    scale.exponent(config.exponent);\n  }\n}\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-time/src/day.js\nvar day = __webpack_require__(574);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-time/src/hour.js\nvar hour = __webpack_require__(573);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-time/src/minute.js\nvar minute = __webpack_require__(572);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-time/src/month.js\nvar month = __webpack_require__(575);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-time/src/second.js\nvar second = __webpack_require__(327);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-time/src/week.js\nvar week = __webpack_require__(78);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-time/src/year.js\nvar year = __webpack_require__(576);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-time/src/utcDay.js\nvar utcDay = __webpack_require__(579);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-time/src/utcHour.js\nvar utcHour = __webpack_require__(578);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-time/src/utcMinute.js\nvar utcMinute = __webpack_require__(577);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-time/src/utcMonth.js\nvar utcMonth = __webpack_require__(580);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-time/src/utcWeek.js\nvar utcWeek = __webpack_require__(79);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-time/src/utcYear.js\nvar utcYear = __webpack_require__(581);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/applyNice.js\n\n\nconst localTimeIntervals = {\n  day: day[\"b\" /* default */],\n  hour: hour[\"a\" /* default */],\n  minute: minute[\"a\" /* default */],\n  month: month[\"a\" /* default */],\n  second: second[\"a\" /* default */],\n  week: week[\"g\" /* sunday */],\n  year: year[\"a\" /* default */]\n};\nconst utcIntervals = {\n  day: utcDay[\"a\" /* default */],\n  hour: utcHour[\"a\" /* default */],\n  minute: utcMinute[\"a\" /* default */],\n  month: utcMonth[\"a\" /* default */],\n  second: second[\"a\" /* default */],\n  week: utcWeek[\"g\" /* utcSunday */],\n  year: utcYear[\"a\" /* default */]\n};\nfunction applyNice(config, scale) {\n  if ('nice' in config && typeof config.nice !== 'undefined' && 'nice' in scale) {\n    const {\n      nice\n    } = config;\n\n    if (typeof nice === 'boolean') {\n      if (nice) {\n        scale.nice();\n      }\n    } else if (typeof nice === 'number') {\n      scale.nice(nice);\n    } else {\n      const timeScale = scale;\n      const {\n        type\n      } = config;\n\n      if (typeof nice === 'string') {\n        timeScale.nice(type === ScaleType.UTC ? utcIntervals[nice] : localTimeIntervals[nice]);\n      } else {\n        const {\n          interval,\n          step\n        } = nice;\n        const parsedInterval = (type === ScaleType.UTC ? utcIntervals[interval] : localTimeIntervals[interval]).every(step);\n\n        if (parsedInterval !== null) {\n          timeScale.nice(parsedInterval);\n        }\n      }\n    }\n  }\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/typeGuards/Scale.js\n\nfunction isContinuousScale(scale, scaleType) {\n  return scale && continuousScaleTypesSet.has(scaleType);\n}\nfunction isDiscretizingScale(scale, scaleType) {\n  return scale && discretizingScaleTypesSet.has(scaleType);\n}\nfunction isDiscreteScale(scale, scaleType) {\n  return scale && discreteScaleTypesSet.has(scaleType);\n}\nfunction isTimeScale(scale, scaleType) {\n  return scale && timeScaleTypesSet.has(scaleType);\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/applyZero.js\n\nfunction applyZero(config, scale) {\n  if ('zero' in config && config.zero === true && isContinuousScale(scale, config.type)) {\n    const domain = scale.domain();\n    const [a, b] = domain;\n    const isDescending = b < a;\n    const [min, max] = isDescending ? [b, a] : [a, b];\n    const domainWithZero = [Math.min(0, min), Math.max(0, max)];\n    scale.domain(isDescending ? domainWithZero.reverse() : domainWithZero);\n  }\n}\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-interpolate/src/lab.js\nvar lab = __webpack_require__(1071);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-interpolate/src/hcl.js\nvar hcl = __webpack_require__(583);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-interpolate/src/hsl.js\nvar hsl = __webpack_require__(582);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-interpolate/src/cubehelix.js + 1 modules\nvar cubehelix = __webpack_require__(591);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-interpolate/src/rgb.js\nvar rgb = __webpack_require__(217);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/createColorInterpolator.js\n\nconst interpolatorMap = {\n  lab: lab[\"a\" /* default */],\n  hcl: hcl[\"a\" /* default */],\n  'hcl-long': hcl[\"b\" /* hclLong */],\n  hsl: hsl[\"a\" /* default */],\n  'hsl-long': hsl[\"b\" /* hslLong */],\n  cubehelix: cubehelix[\"b\" /* default */],\n  'cubehelix-long': cubehelix[\"a\" /* cubehelixLong */],\n  rgb: rgb[\"a\" /* default */]\n};\nfunction createColorInterpolator(interpolate) {\n  switch (interpolate) {\n    case 'lab':\n    case 'hcl':\n    case 'hcl-long':\n    case 'hsl':\n    case 'hsl-long':\n    case 'cubehelix':\n    case 'cubehelix-long':\n    case 'rgb':\n      return interpolatorMap[interpolate];\n\n    default:\n  }\n\n  const {\n    type,\n    gamma\n  } = interpolate;\n  const interpolator = interpolatorMap[type];\n  return typeof gamma === 'undefined' ? interpolator : interpolator.gamma(gamma);\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/applyInterpolate.js\n\nfunction applyInterpolate(config, scale) {\n  if ('interpolate' in config && typeof config.interpolate !== 'undefined' && 'interpolate' in scale) {\n    scale.interpolate(createColorInterpolator(config.interpolate));\n  }\n}\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-interpolate/src/round.js\nvar round = __webpack_require__(1070);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/applyRound.js\n\nfunction applyRound(config, scale) {\n  if ('round' in config && config.round === true) {\n    const roundableScale = scale;\n\n    if ('round' in roundableScale) {\n      roundableScale.round(config.round);\n    } else {\n      roundableScale.interpolate(round[\"a\" /* default */]);\n    }\n  }\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/domain/parseContinuousDomain.js\n\n/**\n * Convert each element in the array into\n * - Date (for time scales)\n * - number (for other continuous scales)\n * @param domain\n * @param scaleType\n */\n\nfunction parseContinuousDomain(domain, scaleType) {\n  if (timeScaleTypesSet.has(scaleType)) {\n    return domain.filter(d => typeof d !== 'boolean').map(d => typeof d === 'string' || typeof d === 'number' ? new Date(d) : d);\n  }\n\n  return domain.map(d => typeof d === 'string' || typeof d === 'boolean' ? Number(d) : d);\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/domain/parseDiscreteDomain.js\n/**\n * Discrete domains are converted into string[]\n * when using D3 scales\n * @param domain\n */\nfunction parseDiscreteDomain(domain) {\n  return domain.map(d => \"\" + d);\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/utils/combineCategories.js\n/**\n * Combine two arrays into a unique list\n * by keeping the order the fixedCategories\n * and append new categories at the end.\n * @param fixedCategories\n * @param inputCategories\n */\nfunction combineCategories(fixedCategories, inputCategories = []) {\n  if (fixedCategories.length === 0) {\n    return inputCategories;\n  }\n\n  const fixedSet = new Set(fixedCategories);\n  return fixedCategories.concat(inputCategories.filter(d => !fixedSet.has(d)));\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/utils/combineContinuousDomains.js\n\n/**\n * Combine two continuous domain and ensure that the output\n * does not go beyond fixedDomain\n * @param bounds\n * @param dataDomain\n */\n\nfunction combineContinuousDomains(bounds, dataDomain) {\n  if (bounds.length > 0 && isEveryElementDefined(bounds)) {\n    return bounds;\n  }\n\n  if (bounds.length === 2 && dataDomain.length === 2 && bounds.filter(isDefined).length > 0) {\n    const [boundMin, boundMax] = bounds;\n    const [dataMin, dataMax] = dataDomain;\n    let min = dataMin;\n\n    if (isDefined(boundMin)) {\n      min = boundMin.valueOf() > dataMin.valueOf() ? boundMin : dataMin;\n    }\n\n    let max = dataMax;\n\n    if (isDefined(boundMax)) {\n      max = boundMax.valueOf() < dataMax.valueOf() ? boundMax : dataMax;\n    }\n\n    return [min, max];\n  }\n\n  return dataDomain;\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/utils/removeUndefinedAndNull.js\nfunction removeUndefinedAndNull(array) {\n  return array.filter(x => typeof x !== 'undefined' && x !== null);\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/parseDateTimeIn.js\n\n\n/**\n * Only parse elements that are DateTime to Date.\n * Leave the rest alone.\n * @param array\n */\n\nfunction parseDateTimeIn(array) {\n  return array.map(d => !(d instanceof Date) && isDateTime(d) ? parseDateTime(d) : d);\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/applyDomain.js\n\n\n\n\n\n\n\n\n\nfunction createOrderFunction(reverse) {\n  return reverse ? array => array.concat().reverse() : array => array;\n}\n\nfunction isCompleteDomain(domain) {\n  return domain.length !== 2 || domain[0] != null && domain[1] != null;\n}\n\nfunction applyDomain(config, scale,\n/** domain from dataset */\ndataDomain) {\n  const {\n    reverse,\n    type\n  } = config;\n  const order = createOrderFunction(reverse);\n\n  if (isContinuousScale(scale, type) && isContinuousScaleConfig(config) || isDiscretizingScale(scale, type) && isDiscretizingScaleConfig(config)) {\n    // For continuous and discretizing scales\n    if (config.domain) {\n      // If config.domain is specified\n      if (isCompleteDomain(config.domain)) {\n        // If the config.domain is completed\n        // ignores the dataDomain\n        scale.domain(order(parseDateTimeIn(config.domain)));\n      } else if (dataDomain) {\n        // If it is incompleted, then try to combine\n        // with the dataDomain\n        scale.domain(order(combineContinuousDomains(parseContinuousDomain(parseDateTimeIn(config.domain), type), parseContinuousDomain(removeUndefinedAndNull(dataDomain), type))));\n      }\n    } else if (dataDomain) {\n      // If no config.domain then just use the dataDomain if any\n      scale.domain(order(parseContinuousDomain(removeUndefinedAndNull(dataDomain), type)));\n    }\n  } else if (isDiscreteScale(scale, type) && isDiscreteScaleConfig(config)) {\n    // For discrete scales\n    if (config.domain) {\n      const fixedDomain = parseDiscreteDomain(parseDateTimeIn(config.domain));\n      scale.domain(order(dataDomain ? combineCategories(fixedDomain, parseDiscreteDomain(dataDomain)) : fixedDomain));\n    } else if (dataDomain) {\n      // If no config.domain then just use the dataDomain if any\n      scale.domain(order(parseDiscreteDomain(dataDomain)));\n    }\n  }\n}\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@encodable/color/esm/scheme/wrappers/wrapColorScheme.js + 21 modules\nvar wrapColorScheme = __webpack_require__(435);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/typeGuards/SchemeParams.js\n// eslint-disable-next-line import/prefer-default-export\nfunction isSchemeParams(scheme) {\n  return Object.prototype.toString.call(scheme) !== '[object String]';\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/applyRange.js\n\n\n\n\nfunction applyRange(config, scale) {\n  const {\n    range,\n    domain\n  } = config;\n\n  if (typeof range === 'undefined') {\n    if ('scheme' in config && typeof config.scheme !== 'undefined') {\n      const {\n        scheme\n      } = config;\n      let name;\n      let count;\n\n      if (isContinuousScaleConfig(config) && domain) {\n        count = domain.length;\n      }\n\n      let extent;\n\n      if (isSchemeParams(scheme)) {\n        name = scheme.name;\n\n        if (scheme.count) {\n          count = scheme.count;\n        }\n\n        extent = scheme.extent;\n      } else {\n        name = scheme;\n      }\n\n      const schemeObject = Encodable[\"a\" /* default */].resolveColorScheme({\n        name,\n        type: 'sequential'\n      });\n\n      if (typeof schemeObject !== 'undefined' && schemeObject.type === 'sequential') {\n        const wrappedScheme = Object(wrapColorScheme[\"a\" /* default */])(schemeObject);\n        scale.range(wrappedScheme.getColors(count, extent));\n      }\n    }\n  } else {\n    // TODO: add type guard should fix this problem\n    // @ts-ignore\n    scale.range(range);\n  }\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/applyPadding.js\nfunction applyPadding(config, scale) {\n  if ('padding' in config && typeof config.padding !== 'undefined' && 'padding' in scale) {\n    scale.padding(config.padding);\n  }\n\n  if ('paddingInner' in config && typeof config.paddingInner !== 'undefined' && 'paddingInner' in scale) {\n    scale.paddingInner(config.paddingInner);\n  }\n\n  if ('paddingOuter' in config && typeof config.paddingOuter !== 'undefined' && 'paddingOuter' in scale) {\n    scale.paddingOuter(config.paddingOuter);\n  }\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/updateScale.js\n\n\n\n\n\n\n\n\n\n\n\nfunction updateScale(scale, config) {\n  // domain and range apply to all scales\n  applyDomain(config, scale);\n  applyRange(config, scale); // Sort other properties alphabetically.\n\n  applyAlign(config, scale);\n  applyBase(config, scale);\n  applyClamp(config, scale);\n  applyExponent(config, scale);\n  applyInterpolate(config, scale); // Nice depends on domain.\n\n  applyNice(config, scale);\n  applyPadding(config, scale);\n  applyRound(config, scale); // Zero depends on domain and nice.\n\n  applyZero(config, scale);\n  return scale;\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/createScale.js\n\n\n\n\n\n\n\nfunction createScale(config) {\n  const {\n    range\n  } = config; // Handle categorical color scales\n  // An ordinal scale without specified range\n  // is assumed to be a color scale.\n\n  if (config.type === ScaleType.ORDINAL && typeof range === 'undefined') {\n    const scheme = 'scheme' in config ? config.scheme : undefined;\n    const resolve = Encodable[\"a\" /* default */].getCategoricalColorScaleResolver();\n    let colorScale;\n\n    if (typeof scheme === 'undefined') {\n      colorScale = resolve({});\n    } else if (isSchemeParams(scheme)) {\n      colorScale = resolve(scheme);\n    } else {\n      colorScale = resolve({\n        name: scheme\n      });\n    }\n\n    const castedColorScale = colorScale;\n    applyDomain(config, castedColorScale);\n    return castedColorScale;\n  }\n\n  const scale = createScaleFromScaleType(config.type);\n  return updateScale(scale, config);\n}\n\n/* harmony default export */ var scale_createScale = (createScale);\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/utils/identity.js\nfunction identity(x) {\n  return x;\n}\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/typeGuards/CompleteChannelDef.js\nvar CompleteChannelDef = __webpack_require__(2404);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/encoders/ChannelEncoder.js\nfunction ChannelEncoder_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass ChannelEncoder_ChannelEncoder {\n  constructor({\n    name,\n    channelType,\n    definition: originalDefinition\n  }) {\n    ChannelEncoder_defineProperty(this, \"name\", void 0);\n\n    ChannelEncoder_defineProperty(this, \"channelType\", void 0);\n\n    ChannelEncoder_defineProperty(this, \"originalDefinition\", void 0);\n\n    ChannelEncoder_defineProperty(this, \"definition\", void 0);\n\n    ChannelEncoder_defineProperty(this, \"scale\", void 0);\n\n    ChannelEncoder_defineProperty(this, \"axis\", void 0);\n\n    ChannelEncoder_defineProperty(this, \"getValue\", void 0);\n\n    ChannelEncoder_defineProperty(this, \"encodeFunc\", void 0);\n\n    ChannelEncoder_defineProperty(this, \"formatValue\", void 0);\n\n    ChannelEncoder_defineProperty(this, \"encodeValue\", (value, otherwise) => {\n      if (typeof otherwise !== 'undefined' && (value === null || typeof value === 'undefined')) {\n        return otherwise;\n      } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n      return this.encodeFunc(value);\n    });\n\n    ChannelEncoder_defineProperty(this, \"encodeDatum\", (datum, otherwise) => typeof otherwise === 'undefined' ? this.encodeValue(this.getValueFromDatum(datum)) : this.encodeValue(this.getValueFromDatum(datum), otherwise));\n\n    ChannelEncoder_defineProperty(this, \"formatDatum\", datum => this.formatValue(this.getValueFromDatum(datum)));\n\n    ChannelEncoder_defineProperty(this, \"getValueFromDatum\", (datum, otherwise) => {\n      const value = this.getValue(datum);\n      return otherwise !== undefined && (value === null || value === undefined) ? otherwise : value;\n    });\n\n    ChannelEncoder_defineProperty(this, \"getDomainFromDataset\", data => {\n      if (Object(ChannelDef[\"c\" /* isValueDef */])(this.definition)) {\n        const {\n          value\n        } = this.definition;\n        return [value];\n      }\n\n      const {\n        type\n      } = this.definition;\n\n      if (type === 'nominal' || type === 'ordinal') {\n        return Array.from(new Set(data.map(d => this.getValueFromDatum(d))));\n      }\n\n      if (type === 'quantitative') {\n        // Quantile scale needs all items\n        // because it treats domain as a discrete set of sample values\n        // for computing the quantiles\n        if (this.definition.scale && this.definition.scale.type === 'quantile') {\n          return data.map(d => this.getValueFromDatum(d));\n        }\n\n        const extent = Object(src_extent[\"a\" /* default */])(data, d => this.getValueFromDatum(d));\n        return typeof extent[0] === 'undefined' ? [0, 1] : extent;\n      }\n\n      if (type === 'temporal') {\n        const extent = Object(src_extent[\"a\" /* default */])(data, d => this.getValueFromDatum(d));\n        return typeof extent[0] === 'undefined' ? [0, 1] : extent;\n      }\n\n      return [];\n    });\n\n    this.name = name;\n    this.channelType = channelType;\n    this.originalDefinition = originalDefinition;\n    this.definition = completeChannelDef(this.channelType, originalDefinition);\n    this.getValue = createGetterFromChannelDef(this.definition);\n    this.formatValue = Object(ChannelDef[\"a\" /* isFieldDef */])(this.definition) ? createFormatter(this.definition) : fallbackFormatter;\n\n    if (this.definition.scale) {\n      const scale = scale_createScale(this.definition.scale); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n      this.encodeFunc = value => scale(value);\n\n      this.scale = scale;\n    } else {\n      const {\n        definition\n      } = this;\n      this.encodeFunc = Object(CompleteChannelDef[\"b\" /* isCompleteValueDef */])(definition) ? () => definition.value : identity;\n    }\n\n    if (this.definition.axis) {\n      this.axis = new ChannelEncoderAxis_ChannelEncoderAxis(this);\n    }\n  }\n\n  getDomain() {\n    if (this.scale && 'domain' in this.scale) {\n      return this.scale.domain();\n    }\n\n    return [];\n  }\n\n  setDomain(domain) {\n    if (this.definition.scale !== false && this.scale && !this.hasCategoricalColorScale() && 'domain' in this.scale) {\n      const config = this.definition.scale;\n      applyDomain(config, this.scale, domain);\n      applyRange(config, this.scale);\n      applyZero(config, this.scale);\n      applyNice(config, this.scale);\n    }\n\n    return this;\n  }\n\n  setDomainFromDataset(data) {\n    return this.scale && 'domain' in this.scale ? this.setDomain(this.getDomainFromDataset(data)) : this;\n  }\n\n  getTitle() {\n    return this.definition.title;\n  }\n\n  isGroupBy() {\n    if (Object(ChannelDef[\"b\" /* isTypedFieldDef */])(this.definition)) {\n      const {\n        type\n      } = this.definition;\n      return this.channelType === 'Category' || this.channelType === 'Text' || this.channelType === 'Color' && (type === 'nominal' || type === 'ordinal') || isXOrY(this.channelType) && (type === 'nominal' || type === 'ordinal');\n    }\n\n    return false;\n  }\n\n  isX() {\n    return isX(this.channelType);\n  }\n\n  isXOrY() {\n    return isXOrY(this.channelType);\n  }\n\n  isY() {\n    return isY(this.channelType);\n  }\n\n  hasCategoricalColorScale() {\n    const config = this.definition.scale; // Scale type is ordinal with not given range\n    // (may have optional scheme)\n    // will become a categorical scale\n    // of named color scheme.\n    // A color scale from named color scheme may be shared among multiple components\n    // in the same namespace by default, so changing its domain affect all components.\n    // (Sounds like a bad idea.)\n    // This function is currently only being used to check\n    // whether to apply domain from dataset or not.\n    // An ordinal scale with user-specified color scheme as range array\n    // will return false from this function and be excluded from it.\n\n    return this.scale && config && config.type === ScaleType.ORDINAL && typeof config.range === 'undefined';\n  }\n\n  hasLegend() {\n    return this.definition.legend !== false;\n  }\n\n  hasValueDefinition() {\n    return Object(CompleteChannelDef[\"b\" /* isCompleteValueDef */])(this.definition);\n  }\n\n  hasFieldDefinition() {\n    return Object(CompleteChannelDef[\"a\" /* isCompleteFieldDef */])(this.definition);\n  }\n\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/encoders/Encoder.js\nfunction Encoder_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\nclass Encoder_Encoder {\n  constructor({\n    channelTypes,\n    encoding\n  }) {\n    Encoder_defineProperty(this, \"encoding\", void 0);\n\n    Encoder_defineProperty(this, \"channelTypes\", void 0);\n\n    Encoder_defineProperty(this, \"channels\", void 0);\n\n    Encoder_defineProperty(this, \"legends\", void 0);\n\n    this.channelTypes = channelTypes;\n    this.encoding = encoding;\n    const channelNames = this.getChannelNames(); // Create channel encoders\n\n    const channels = {};\n    channelNames.forEach(name => {\n      const channelEncoding = encoding[name];\n\n      if (Array.isArray(channelEncoding)) {\n        const definitions = channelEncoding;\n        channels[name] = definitions.map((definition, i) => new ChannelEncoder_ChannelEncoder({\n          channelType: channelTypes[name],\n          definition,\n          name: name + \"[\" + i + \"]\"\n        }));\n      } else {\n        const definition = channelEncoding;\n        channels[name] = new ChannelEncoder_ChannelEncoder({\n          channelType: channelTypes[name],\n          definition,\n          name: name\n        });\n      }\n    });\n    this.channels = channels; // Group the channels that use the same field together\n    // so they can share the same legend.\n\n    this.legends = {};\n    channelNames.map(name => this.channels[name]).forEach(c => {\n      if (isNotArray(c) && c.hasLegend() && Object(ChannelDef[\"b\" /* isTypedFieldDef */])(c.definition)) {\n        const {\n          field\n        } = c.definition;\n        const channelEncoder = c;\n\n        if (this.legends[field]) {\n          this.legends[field].push(channelEncoder);\n        } else {\n          this.legends[field] = [channelEncoder];\n        }\n      }\n    });\n  }\n\n  getChannelNames() {\n    return Object.keys(this.channelTypes);\n  }\n\n  getChannelEncoders() {\n    return this.getChannelNames().flatMap(name => this.channels[name]);\n  }\n\n  getGroupBys() {\n    const fields = this.getChannelEncoders().filter(c => c.isGroupBy()).map(c => c.definition.field);\n    return Array.from(new Set(fields));\n  }\n\n  createLegendItemsFactory(field) {\n    const channelEncoders = this.getChannelEncoders().filter(e => isNotArray(e) && Object(ChannelDef[\"c\" /* isValueDef */])(e.definition)).flat().concat(this.legends[field]);\n    return domain => domain.map(input => ({\n      input,\n      output: channelEncoders.reduce((prev, curr) => {\n        const map = prev;\n        map[curr.name] = curr.encodeValue(input);\n        return map;\n      }, {})\n    }));\n  }\n\n  getLegendInformation(data = []) {\n    return Object.keys(this.legends) // for each field that was encoded\n    .map(field => {\n      // get all the channels that use this field\n      const channelEncoders = this.legends[field];\n      const firstEncoder = channelEncoders[0];\n      const definition = firstEncoder.definition;\n      const createLegendItems = this.createLegendItemsFactory(field);\n\n      if (definition.type === 'nominal') {\n        return {\n          channelEncoders,\n          createLegendItems,\n          field,\n          items: createLegendItems(firstEncoder.getDomainFromDataset(data)),\n          type: definition.type\n        };\n      }\n\n      return {\n        channelEncoders,\n        createLegendItems,\n        field,\n        type: definition.type\n      };\n    });\n  }\n\n  setDomainFromDataset(data) {\n    this.getChannelEncoders().forEach(channelEncoder => {\n      channelEncoder.setDomainFromDataset(data);\n    });\n    return this;\n  }\n\n  hasLegend() {\n    return Object.keys(this.legends).length > 0;\n  }\n\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/utils/mergeEncoding.js\nfunction mergeEncoding(defaultEncoding, encoding) {\n  return { ...defaultEncoding,\n    ...encoding\n  };\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/encoders/createEncoderFactory.js\n\n\n\nfunction createEncoderFactory(params) {\n  const {\n    channelTypes\n  } = params;\n  const completeEncoding = 'defaultEncoding' in params ? encoding => mergeEncoding(params.defaultEncoding, encoding) : params.completeEncoding;\n\n  const create = (encoding = {}) => new Encoder_Encoder({\n    channelTypes,\n    encoding: completeEncoding(encoding)\n  });\n\n  return {\n    channelTypes,\n    create,\n    createSelector: () => Object(es[\"createSelector\"])(encoding => encoding, create),\n    DEFAULT_ENCODING: completeEncoding({})\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQ2NS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vdHlwZUd1YXJkcy9CYXNlLmpzP2RmNzUiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS90eXBlcy9zY2FsZS9TY2FsZVR5cGUuanM/OTliMiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL3R5cGVHdWFyZHMvQ2hhbm5lbC5qcz9lODZiIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vdXRpbHMva2V5cy5qcz85YjY4Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vcGFyc2Vycy9kYXRlVGltZVRvVGltZXN0YW1wLmpzP2M3YWUiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS9wYXJzZXJzL3BhcnNlRGF0ZVRpbWUuanM/NmQyNyIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL3V0aWxzL2luZmVyRWxlbWVudFR5cGVGcm9tVW5pb25PZkFycmF5VHlwZXMuanM/MzhhMCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL3R5cGVHdWFyZHMvRGF0ZVRpbWUuanM/NDM0YiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL3BhcnNlcnMvZm9ybWF0L2ZhbGxiYWNrRm9ybWF0dGVyLmpzPzgzMDEiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS9wYXJzZXJzL2Zvcm1hdC9jcmVhdGVGb3JtYXR0ZXIuanM/NDIyNSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL2VuY29kZXJzL0NoYW5uZWxFbmNvZGVyQXhpcy5qcz8zZjA4Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vcGFyc2Vycy9jcmVhdGVHZXR0ZXJGcm9tQ2hhbm5lbERlZi5qcz8zM2JmIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vdXRpbHMvaXNEaXNhYmxlZC5qcz8yMGQzIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vdXRpbHMvaXNFbmFibGVkLmpzPzk0ZTgiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS9maWxsZXJzL2V4cGFuZExhYmVsT3ZlcmxhcFN0cmF0ZWd5LmpzP2Y1ODEiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS9wYXJzZXJzL3NjYWxlL3NjYWxlQ2F0ZWdvcmllcy5qcz82YWY5Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vZmlsbGVycy9jb21wbGV0ZUF4aXNDb25maWcuanM/ODU0ZiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL2ZpbGxlcnMvY29tcGxldGVGb3JtYXRDb25maWcuanM/NDQ3NyIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL2ZpbGxlcnMvY29tcGxldGVMZWdlbmRDb25maWcuanM/MWY2OCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL2ZpbGxlcnMvaW5mZXJTY2FsZVR5cGUuanM/NzY1MCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL3BhcnNlcnMvc2NhbGUvaXNQcm9wZXJ0eVN1cHBvcnRlZEJ5U2NhbGVUeXBlLmpzP2VhZTIiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS90eXBlR3VhcmRzL1NjYWxlQ29uZmlnLmpzP2U1MmUiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS9maWxsZXJzL2NvbXBsZXRlU2NhbGVDb25maWcuanM/NWI0MCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL2ZpbGxlcnMvaW5mZXJGaWVsZFR5cGUuanM/Nzg2OCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL2ZpbGxlcnMvY29tcGxldGVDaGFubmVsRGVmLmpzPzA5YzUiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS9wYXJzZXJzL3NjYWxlL2NyZWF0ZVNjYWxlRnJvbVNjYWxlVHlwZS5qcz9mNmNmIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vcGFyc2Vycy9zY2FsZS9hcHBseUFsaWduLmpzP2EwODEiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS9wYXJzZXJzL3NjYWxlL2FwcGx5QmFzZS5qcz9lMTgxIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vcGFyc2Vycy9zY2FsZS9hcHBseUNsYW1wLmpzPzQyYWIiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS9wYXJzZXJzL3NjYWxlL2FwcGx5RXhwb25lbnQuanM/MDQwYSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL3BhcnNlcnMvc2NhbGUvYXBwbHlOaWNlLmpzPzUxMDEiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS90eXBlR3VhcmRzL1NjYWxlLmpzP2FlYmMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS9wYXJzZXJzL3NjYWxlL2FwcGx5WmVyby5qcz8xN2I1Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vcGFyc2Vycy9zY2FsZS9jcmVhdGVDb2xvckludGVycG9sYXRvci5qcz83OGY4Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vcGFyc2Vycy9zY2FsZS9hcHBseUludGVycG9sYXRlLmpzPzQ1MzUiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS9wYXJzZXJzL3NjYWxlL2FwcGx5Um91bmQuanM/NDAxZCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL3BhcnNlcnMvZG9tYWluL3BhcnNlQ29udGludW91c0RvbWFpbi5qcz9mOWFhIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vcGFyc2Vycy9kb21haW4vcGFyc2VEaXNjcmV0ZURvbWFpbi5qcz82NDc3Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vdXRpbHMvY29tYmluZUNhdGVnb3JpZXMuanM/NGUxZSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL3V0aWxzL2NvbWJpbmVDb250aW51b3VzRG9tYWlucy5qcz9kYWU3Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vdXRpbHMvcmVtb3ZlVW5kZWZpbmVkQW5kTnVsbC5qcz80OTRmIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vcGFyc2Vycy9wYXJzZURhdGVUaW1lSW4uanM/ODA2YSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL3BhcnNlcnMvc2NhbGUvYXBwbHlEb21haW4uanM/NDMwZSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL3R5cGVHdWFyZHMvU2NoZW1lUGFyYW1zLmpzPzM5ZmYiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS9wYXJzZXJzL3NjYWxlL2FwcGx5UmFuZ2UuanM/MGNmNCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL3BhcnNlcnMvc2NhbGUvYXBwbHlQYWRkaW5nLmpzP2IyNmMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS9wYXJzZXJzL3NjYWxlL3VwZGF0ZVNjYWxlLmpzPzk4NjAiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS9wYXJzZXJzL3NjYWxlL2NyZWF0ZVNjYWxlLmpzP2Y0OGUiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS91dGlscy9pZGVudGl0eS5qcz9kM2FmIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vZW5jb2RlcnMvQ2hhbm5lbEVuY29kZXIuanM/NWQyMCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL2VuY29kZXJzL0VuY29kZXIuanM/NzVmZSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL3V0aWxzL21lcmdlRW5jb2RpbmcuanM/YTY5ZiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL2VuY29kZXJzL2NyZWF0ZUVuY29kZXJGYWN0b3J5LmpzPzBmNGQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXkobWF5YmVBcnJheSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShtYXliZUFycmF5KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc05vdEFycmF5KG1heWJlQXJyYXkpIHtcbiAgcmV0dXJuICFBcnJheS5pc0FycmF5KG1heWJlQXJyYXkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzRGVmaW5lZCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0V2ZXJ5RWxlbWVudERlZmluZWQoYXJyYXkpIHtcbiAgcmV0dXJuIGFycmF5LmV2ZXJ5KGlzRGVmaW5lZCk7XG59IiwiLy8gTW9kaWZpZWQgZnJvbSB2ZWdhLWxpdGVcbi8vIGJlY2F1c2UgdmVnYS1saXRlIHVzZXMgbmFtZXNwYWNlIHdoaWNoIGhhcyBpc3N1ZXMgd2l0aCBiYWJlbCBhbmQgdHlwZXNjcmlwdFxuZXhwb3J0IGNvbnN0IFNjYWxlVHlwZSA9IHtcbiAgLy8gQ29udGludW91cyAtIFF1YW50aXRhdGl2ZVxuICBMSU5FQVI6ICdsaW5lYXInLFxuICBMT0c6ICdsb2cnLFxuICBQT1c6ICdwb3cnLFxuICBTUVJUOiAnc3FydCcsXG4gIFNZTUxPRzogJ3N5bWxvZycsXG4gIC8vIENvbnRpbnVvdXMgLSBUaW1lXG4gIFRJTUU6ICd0aW1lJyxcbiAgVVRDOiAndXRjJyxcbiAgLy8gRGlzY3JldGl6aW5nIHNjYWxlc1xuICBRVUFOVElMRTogJ3F1YW50aWxlJyxcbiAgUVVBTlRJWkU6ICdxdWFudGl6ZScsXG4gIFRIUkVTSE9MRDogJ3RocmVzaG9sZCcsXG4gIEJJTl9PUkRJTkFMOiAnYmluLW9yZGluYWwnLFxuICAvLyBEaXNjcmV0ZSBzY2FsZXNcbiAgT1JESU5BTDogJ29yZGluYWwnLFxuICBQT0lOVDogJ3BvaW50JyxcbiAgQkFORDogJ2JhbmQnXG59OyIsImV4cG9ydCBmdW5jdGlvbiBpc1goY2hhbm5lbFR5cGUpIHtcbiAgcmV0dXJuIGNoYW5uZWxUeXBlID09PSAnWCcgfHwgY2hhbm5lbFR5cGUgPT09ICdYQmFuZCc7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNZKGNoYW5uZWxUeXBlKSB7XG4gIHJldHVybiBjaGFubmVsVHlwZSA9PT0gJ1knIHx8IGNoYW5uZWxUeXBlID09PSAnWUJhbmQnO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzWE9yWShjaGFubmVsVHlwZSkge1xuICByZXR1cm4gaXNYKGNoYW5uZWxUeXBlKSB8fCBpc1koY2hhbm5lbFR5cGUpO1xufSIsIi8qKlxuICogVGhpcyBpcyBhIHN0cmljdGVyIHZlcnNpb24gb2YgT2JqZWN0LmtleXMgYnV0IHdpdGggYmV0dGVyIHR5cGVzLlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC9wdWxsLzEyMjUzI2lzc3VlY29tbWVudC0yNjMxMzIyMDhcbiAqL1xuY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzO1xuZXhwb3J0IGRlZmF1bHQga2V5czsiLCIvLyBNb2RpZmllZCBmcm9tIHZlZ2EtbGl0ZSB2ZXJzaW9uXG4vLyBhbmQgcmVtb3ZlIHVubmVjZXNzYXJ5IGRlcGVuZGVuY3lcblxuLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cblxuLyogZXNsaW50LWRpc2FibGUgbm8tbmVnYXRlZC1jb25kaXRpb24gKi9cbmltcG9ydCBrZXlzIGZyb20gJy4uL3V0aWxzL2tleXMnO1xuLyoqXG4gKiBJbnRlcm5hbCBPYmplY3QgZm9yIGRlZmluaW5nIGRhdGV0aW1lIGV4cHJlc3Npb25zLlxuICogVGhpcyBpcyBhbiBleHByZXNzaW9uIHZlcnNpb24gb2YgRGF0ZVRpbWUuXG4gKiBJZiBib3RoIG1vbnRoIGFuZCBxdWFydGVyIGFyZSBwcm92aWRlZCwgbW9udGggaGFzIGhpZ2hlciBwcmVjZWRlbmNlLlxuICogYGRheWAgY2Fubm90IGJlIGNvbWJpbmVkIHdpdGggb3RoZXIgZGF0ZS5cbiAqL1xuXG5mdW5jdGlvbiBpbnZhbGlkVGltZVVuaXQodW5pdE5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBcIkludmFsaWQgXCIgKyB1bml0TmFtZSArIFwiOiBcIiArIFN0cmluZyh2YWx1ZSkgKyBcIi5cIjtcbn1cbi8qXG4gKiBBIGRlc2lnbmF0ZWQgeWVhciB0aGF0IHN0YXJ0cyBvbiBTdW5kYXkuXG4gKi9cblxuXG5jb25zdCBTVU5EQVlfWUVBUiA9IDIwMDY7XG5jb25zdCBNT05USFMgPSBbJ2phbnVhcnknLCAnZmVicnVhcnknLCAnbWFyY2gnLCAnYXByaWwnLCAnbWF5JywgJ2p1bmUnLCAnanVseScsICdhdWd1c3QnLCAnc2VwdGVtYmVyJywgJ29jdG9iZXInLCAnbm92ZW1iZXInLCAnZGVjZW1iZXInXTtcbmNvbnN0IFNIT1JUX01PTlRIUyA9IE1PTlRIUy5tYXAobSA9PiBtLnNsaWNlKDAsIDMpKTtcbmNvbnN0IERBWVMgPSBbJ3N1bmRheScsICdtb25kYXknLCAndHVlc2RheScsICd3ZWRuZXNkYXknLCAndGh1cnNkYXknLCAnZnJpZGF5JywgJ3NhdHVyZGF5J107XG5jb25zdCBTSE9SVF9EQVlTID0gREFZUy5tYXAoZCA9PiBkLnNsaWNlKDAsIDMpKTtcblxuZnVuY3Rpb24gaXNOdW1iZXIoeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09ICdudW1iZXInO1xufVxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHBhc3NlZCBpbiB2YWx1ZSBpcyBhIHZhbGlkIG51bWJlci5cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzTnVtZXJpYyh2YWx1ZSkge1xuICBpZiAoaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuXG4gIHJldHVybiAhaXNOYU4odmFsdWUpICYmICFpc05hTihwYXJzZUZsb2F0KHZhbHVlKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVRdWFydGVyKHEpIHtcbiAgaWYgKGlzTnVtZXJpYyhxKSkge1xuICAgIHEgPSBOdW1iZXIocSk7XG4gIH1cblxuICBpZiAoaXNOdW1iZXIocSkpIHtcbiAgICBpZiAocSA+IDQpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLndhcm4oaW52YWxpZFRpbWVVbml0KCdxdWFydGVyJywgcSkpO1xuICAgIH0gLy8gV2UgYWNjZXB0IDEtYmFzZWQgcXVhcnRlciwgc28gbmVlZCB0byByZWFkanVzdCB0byAwLWJhc2VkIHF1YXJ0ZXJcblxuXG4gICAgcmV0dXJuIHEgLSAxO1xuICB9IC8vIEludmFsaWQgcXVhcnRlclxuXG5cbiAgdGhyb3cgbmV3IEVycm9yKGludmFsaWRUaW1lVW5pdCgncXVhcnRlcicsIHEpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVNb250aChtKSB7XG4gIGlmIChpc051bWVyaWMobSkpIHtcbiAgICBtID0gTnVtYmVyKG0pO1xuICB9XG5cbiAgaWYgKGlzTnVtYmVyKG0pKSB7XG4gICAgLy8gV2UgYWNjZXB0IDEtYmFzZWQgbW9udGgsIHNvIG5lZWQgdG8gcmVhZGp1c3QgdG8gMC1iYXNlZCBtb250aFxuICAgIHJldHVybiBtIC0gMTtcbiAgfVxuXG4gIGNvbnN0IGxvd2VyTSA9IG0udG9Mb3dlckNhc2UoKTtcbiAgY29uc3QgbW9udGhJbmRleCA9IE1PTlRIUy5pbmRleE9mKGxvd2VyTSk7XG5cbiAgaWYgKG1vbnRoSW5kZXggIT09IC0xKSB7XG4gICAgcmV0dXJuIG1vbnRoSW5kZXg7IC8vIDAgZm9yIGphbnVhcnksIC4uLlxuICB9XG5cbiAgY29uc3Qgc2hvcnRNID0gbG93ZXJNLnNsaWNlKDAsIDMpO1xuICBjb25zdCBzaG9ydE1vbnRoSW5kZXggPSBTSE9SVF9NT05USFMuaW5kZXhPZihzaG9ydE0pO1xuXG4gIGlmIChzaG9ydE1vbnRoSW5kZXggIT09IC0xKSB7XG4gICAgcmV0dXJuIHNob3J0TW9udGhJbmRleDtcbiAgfSAvLyBJbnZhbGlkIG1vbnRoXG5cblxuICB0aHJvdyBuZXcgRXJyb3IoaW52YWxpZFRpbWVVbml0KCdtb250aCcsIG0pKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVEYXkoZCkge1xuICBpZiAoaXNOdW1lcmljKGQpKSB7XG4gICAgZCA9IE51bWJlcihkKTtcbiAgfVxuXG4gIGlmIChpc051bWJlcihkKSkge1xuICAgIC8vIG1vZCBzbyB0aGF0IHRoaXMgY2FuIGJlIGJvdGggMC1iYXNlZCB3aGVyZSAwID0gc3VuZGF5XG4gICAgLy8gYW5kIDEtYmFzZWQgd2hlcmUgNz1zdW5kYXlcbiAgICByZXR1cm4gZCAlIDc7XG4gIH1cblxuICBjb25zdCBsb3dlckQgPSBkLnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IGRheUluZGV4ID0gREFZUy5pbmRleE9mKGxvd2VyRCk7XG5cbiAgaWYgKGRheUluZGV4ICE9PSAtMSkge1xuICAgIHJldHVybiBkYXlJbmRleDsgLy8gMCBmb3IgamFudWFyeSwgLi4uXG4gIH1cblxuICBjb25zdCBzaG9ydEQgPSBsb3dlckQuc2xpY2UoMCwgMyk7XG4gIGNvbnN0IHNob3J0RGF5SW5kZXggPSBTSE9SVF9EQVlTLmluZGV4T2Yoc2hvcnREKTtcblxuICBpZiAoc2hvcnREYXlJbmRleCAhPT0gLTEpIHtcbiAgICByZXR1cm4gc2hvcnREYXlJbmRleDtcbiAgfSAvLyBJbnZhbGlkIGRheVxuXG5cbiAgdGhyb3cgbmV3IEVycm9yKGludmFsaWRUaW1lVW5pdCgnZGF5JywgZCkpO1xufVxuLyoqXG4gKiBAcGFyYW0gZCB0aGUgZGF0ZS5cbiAqIEBwYXJhbSBub3JtYWxpemUgd2hldGhlciB0byBub3JtYWxpemUgcXVhcnRlciwgbW9udGgsIGRheS4gVGhpcyBzaG91bGQgcHJvYmFibHkgYmUgdHJ1ZSBpZiBkIGlzIGEgRGF0ZVRpbWUuXG4gKiBAcmV0dXJucyBhcnJheSBvZiBkYXRlIHRpbWUgcGFydHMgW3llYXIsIG1vbnRoLCBkYXksIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHNdXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRhdGVUaW1lUGFydHMoZCwgbm9ybWFsaXplKSB7XG4gIGNvbnN0IHBhcnRzID0gW107XG5cbiAgaWYgKG5vcm1hbGl6ZSAmJiBkLmRheSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGtleXMoZCkubGVuZ3RoID4gMSkge1xuICAgICAgZCA9IHsgLi4uZFxuICAgICAgfTtcbiAgICAgIGRlbGV0ZSBkLmRheTtcbiAgICB9XG4gIH1cblxuICBpZiAoZC55ZWFyICE9PSB1bmRlZmluZWQpIHtcbiAgICBwYXJ0cy5wdXNoKGQueWVhcik7XG4gIH0gZWxzZSBpZiAoZC5kYXkgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIFNldCB5ZWFyIHRvIDIwMDYgZm9yIHdvcmtpbmcgd2l0aCBkYXkgc2luY2UgSmFudWFyeSAxIDIwMDYgaXMgYSBTdW5kYXlcbiAgICBwYXJ0cy5wdXNoKFNVTkRBWV9ZRUFSKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJ0cy5wdXNoKDApO1xuICB9XG5cbiAgaWYgKGQubW9udGggIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IG1vbnRoID0gbm9ybWFsaXplID8gbm9ybWFsaXplTW9udGgoZC5tb250aCkgOiBkLm1vbnRoO1xuICAgIHBhcnRzLnB1c2gobW9udGgpO1xuICB9IGVsc2UgaWYgKGQucXVhcnRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgcXVhcnRlciA9IG5vcm1hbGl6ZSA/IG5vcm1hbGl6ZVF1YXJ0ZXIoZC5xdWFydGVyKSA6IGQucXVhcnRlcjtcbiAgICBwYXJ0cy5wdXNoKGlzTnVtYmVyKHF1YXJ0ZXIpID8gcXVhcnRlciAqIDMgOiBxdWFydGVyICsgXCIqM1wiKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJ0cy5wdXNoKDApOyAvLyBtb250aHMgc3RhcnQgYXQgemVybyBpbiBKU1xuICB9XG5cbiAgaWYgKGQuZGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcGFydHMucHVzaChkLmRhdGUpO1xuICB9IGVsc2UgaWYgKGQuZGF5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBIQUNLOiBEYXkgb25seSB3b3JrcyBhcyBhIHN0YW5kYWxvbmUgdW5pdFxuICAgIC8vIFRoaXMgaXMgb25seSBjb3JyZWN0IGJlY2F1c2Ugd2UgYWx3YXlzIHNldCB5ZWFyIHRvIDIwMDYgZm9yIGRheVxuICAgIGNvbnN0IGRheSA9IG5vcm1hbGl6ZSA/IG5vcm1hbGl6ZURheShkLmRheSkgOiBkLmRheTtcbiAgICBwYXJ0cy5wdXNoKGlzTnVtYmVyKGRheSkgPyBkYXkgKyAxIDogZGF5ICsgXCIrMVwiKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJ0cy5wdXNoKDEpOyAvLyBEYXRlIHN0YXJ0cyBhdCAxIGluIEpTXG4gIH1cblxuICBbJ2hvdXJzJywgJ21pbnV0ZXMnLCAnc2Vjb25kcycsICdtaWxsaXNlY29uZHMnXS5mb3JFYWNoKHRpbWVVbml0ID0+IHtcbiAgICBjb25zdCB1bml0ID0gZFt0aW1lVW5pdF07XG4gICAgcGFydHMucHVzaCh0eXBlb2YgdW5pdCA9PT0gJ3VuZGVmaW5lZCcgPyAwIDogdW5pdCk7XG4gIH0pO1xuICByZXR1cm4gcGFydHM7XG59XG4vKipcbiAqIEBwYXJhbSBkIHRoZSBkYXRlIHRpbWUuXG4gKiBAcmV0dXJucyB0aGUgdGltZXN0YW1wLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRhdGVUaW1lVG9UaW1lc3RhbXAoZCkge1xuICBjb25zdCBwYXJ0cyA9IGRhdGVUaW1lUGFydHMoZCwgdHJ1ZSk7XG5cbiAgaWYgKGQudXRjKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICByZXR1cm4gTnVtYmVyKG5ldyBEYXRlKERhdGUuVVRDKC4uLnBhcnRzKSkpO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cblxuICByZXR1cm4gTnVtYmVyKG5ldyBEYXRlKC4uLnBhcnRzKSk7XG59IiwiaW1wb3J0IGRhdGVUaW1lVG9UaW1lc3RhbXAgZnJvbSAnLi9kYXRlVGltZVRvVGltZXN0YW1wJztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHBhcnNlRGF0ZVRpbWUoZGF0ZVRpbWUpIHtcbiAgaWYgKHR5cGVvZiBkYXRlVGltZSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGRhdGVUaW1lID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBuZXcgRGF0ZShkYXRlVGltZSk7XG4gIH1cblxuICByZXR1cm4gbmV3IERhdGUoZGF0ZVRpbWVUb1RpbWVzdGFtcChkYXRlVGltZSkpO1xufSIsIi8qKlxuICogVHlwZSB3b3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzcyOTQjaXNzdWVjb21tZW50LTQ2NTc5NDQ2MFxuICogdG8gYXZvaWQgZXJyb3IgXCJDYW5ub3QgaW52b2tlIGFuIGV4cHJlc3Npb24gd2hvc2UgdHlwZSBsYWNrcyBhIGNhbGwgc2lnbmF0dXJlXCJcbiAqIHdoZW4gdXNpbmcgYXJyYXkubWFwXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGluZmVyRWxlbWVudFR5cGVGcm9tVW5pb25PZkFycmF5VHlwZXMoYXJyYXkpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgcmV0dXJuIGFycmF5O1xufSIsIi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvcHJlZmVyLWRlZmF1bHQtZXhwb3J0XG5leHBvcnQgZnVuY3Rpb24gaXNEYXRlVGltZShvKSB7XG4gIHJldHVybiAhIW8gJiYgIShvIGluc3RhbmNlb2YgRGF0ZSkgJiYgdHlwZW9mIG8gIT09ICdzdHJpbmcnICYmIHR5cGVvZiBvICE9PSAnYm9vbGVhbicgJiYgdHlwZW9mIG8gIT09ICdudW1iZXInICYmICgneWVhcicgaW4gbyAmJiBvLnllYXIgIT0gbnVsbCB8fCAncXVhcnRlcicgaW4gbyAmJiBvLnF1YXJ0ZXIgIT0gbnVsbCB8fCAnbW9udGgnIGluIG8gJiYgby5tb250aCAhPSBudWxsIHx8ICdkYXRlJyBpbiBvICYmIG8uZGF0ZSAhPSBudWxsIHx8ICdkYXknIGluIG8gJiYgby5kYXkgIT0gbnVsbCB8fCAnaG91cnMnIGluIG8gJiYgby5ob3VycyAhPSBudWxsIHx8ICdtaW51dGVzJyBpbiBvICYmIG8ubWludXRlcyAhPSBudWxsIHx8ICdzZWNvbmRzJyBpbiBvICYmIG8uc2Vjb25kcyAhPSBudWxsIHx8ICdtaWxsaXNlY29uZHMnIGluIG8gJiYgby5taWxsaXNlY29uZHMgIT0gbnVsbCk7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZmFsbGJhY2tGb3JtYXR0ZXIodikge1xuICByZXR1cm4gXCJcIiArIHY7XG59IiwiaW1wb3J0IGZhbGxiYWNrRm9ybWF0dGVyIGZyb20gJy4vZmFsbGJhY2tGb3JtYXR0ZXInO1xuaW1wb3J0IEVuY29kYWJsZSBmcm9tICcuLi8uLi9vcHRpb25zL0VuY29kYWJsZSc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVGb3JtYXR0ZXIoe1xuICBmb3JtYXRUeXBlLFxuICBmb3JtYXQsXG4gIGZvcm1hdEluTG9jYWxUaW1lXG59KSB7XG4gIGlmIChmb3JtYXRUeXBlID09PSAndGltZScpIHtcbiAgICBjb25zdCBmb3JtYXR0ZXIgPSBFbmNvZGFibGUucmVzb2x2ZVRpbWVGb3JtYXQoe1xuICAgICAgZm9ybWF0LFxuICAgICAgZm9ybWF0SW5Mb2NhbFRpbWVcbiAgICB9KTtcbiAgICByZXR1cm4gdmFsdWUgPT4gZm9ybWF0dGVyKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChmb3JtYXRUeXBlID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgZm9ybWF0ICE9PSAndW5kZWZpbmVkJyAmJiBmb3JtYXQubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGZvcm1hdHRlciA9IEVuY29kYWJsZS5yZXNvbHZlTnVtYmVyRm9ybWF0KGZvcm1hdCk7XG4gICAgcmV0dXJuIHZhbHVlID0+IGZvcm1hdHRlcih2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gZmFsbGJhY2tGb3JtYXR0ZXI7XG59IiwiZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuaW1wb3J0IHBhcnNlRGF0ZVRpbWUgZnJvbSAnLi4vcGFyc2Vycy9wYXJzZURhdGVUaW1lJztcbmltcG9ydCBpbmZlckVsZW1lbnRUeXBlRnJvbVVuaW9uT2ZBcnJheVR5cGVzIGZyb20gJy4uL3V0aWxzL2luZmVyRWxlbWVudFR5cGVGcm9tVW5pb25PZkFycmF5VHlwZXMnO1xuaW1wb3J0IHsgaXNEYXRlVGltZSB9IGZyb20gJy4uL3R5cGVHdWFyZHMvRGF0ZVRpbWUnO1xuaW1wb3J0IGNyZWF0ZUZvcm1hdHRlciBmcm9tICcuLi9wYXJzZXJzL2Zvcm1hdC9jcmVhdGVGb3JtYXR0ZXInO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2hhbm5lbEVuY29kZXJBeGlzIHtcbiAgY29uc3RydWN0b3IoY2hhbm5lbEVuY29kZXIpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjaGFubmVsRW5jb2RlclwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29uZmlnXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJmb3JtYXRWYWx1ZVwiLCB2b2lkIDApO1xuXG4gICAgdGhpcy5jaGFubmVsRW5jb2RlciA9IGNoYW5uZWxFbmNvZGVyO1xuICAgIHRoaXMuY29uZmlnID0gY2hhbm5lbEVuY29kZXIuZGVmaW5pdGlvbi5heGlzO1xuICAgIHRoaXMuZm9ybWF0VmFsdWUgPSBjcmVhdGVGb3JtYXR0ZXIodGhpcy5jb25maWcpO1xuICB9XG5cbiAgZ2V0VGl0bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLnRpdGxlO1xuICB9XG5cbiAgaGFzVGl0bGUoKSB7XG4gICAgY29uc3Qge1xuICAgICAgdGl0bGVcbiAgICB9ID0gdGhpcy5jb25maWc7XG4gICAgcmV0dXJuIHRpdGxlICE9PSBudWxsICYmIHR5cGVvZiB0aXRsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdGl0bGUgIT09ICcnO1xuICB9XG5cbiAgZ2V0VGlja0xhYmVscygpIHtcbiAgICBjb25zdCB7XG4gICAgICB0aWNrQ291bnQsXG4gICAgICB2YWx1ZXNcbiAgICB9ID0gdGhpcy5jb25maWc7XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBpbmZlckVsZW1lbnRUeXBlRnJvbVVuaW9uT2ZBcnJheVR5cGVzKHZhbHVlcykubWFwKHYgPT4gdGhpcy5mb3JtYXRWYWx1ZShpc0RhdGVUaW1lKHYpID8gcGFyc2VEYXRlVGltZSh2KSA6IHYpKTtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICBzY2FsZVxuICAgIH0gPSB0aGlzLmNoYW5uZWxFbmNvZGVyO1xuXG4gICAgaWYgKHNjYWxlICYmICdkb21haW4nIGluIHNjYWxlKSB7XG4gICAgICBjb25zdCB0aWNrcyA9ICd0aWNrcycgaW4gc2NhbGUgPyBzY2FsZS50aWNrcyh0aWNrQ291bnQpIDogc2NhbGUuZG9tYWluKCk7XG4gICAgICByZXR1cm4gdGlja3MubWFwKHRoaXMuZm9ybWF0VmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiBbXTtcbiAgfVxuXG59IiwiaW1wb3J0IGdldCBmcm9tICdsb2Rhc2guZ2V0JztcbmltcG9ydCB7IGlzVmFsdWVEZWYgfSBmcm9tICcuLi90eXBlR3VhcmRzL0NoYW5uZWxEZWYnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlR2V0dGVyRnJvbUNoYW5uZWxEZWYoZGVmaW5pdGlvbikge1xuICBpZiAoaXNWYWx1ZURlZihkZWZpbml0aW9uKSkge1xuICAgIHJldHVybiAoKSA9PiBkZWZpbml0aW9uLnZhbHVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBkZWZpbml0aW9uLmZpZWxkICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB4ID0+IGdldCh4LCBkZWZpbml0aW9uLmZpZWxkKTtcbiAgfVxuXG4gIHJldHVybiAoKSA9PiB1bmRlZmluZWQ7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNEaXNhYmxlZChjb25maWcpIHtcbiAgcmV0dXJuIGNvbmZpZyA9PT0gZmFsc2UgfHwgY29uZmlnID09PSBudWxsO1xufSIsImltcG9ydCBpc0Rpc2FibGVkIGZyb20gJy4vaXNEaXNhYmxlZCc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc0VuYWJsZWQoY29uZmlnKSB7XG4gIHJldHVybiAhaXNEaXNhYmxlZChjb25maWcpO1xufSIsImltcG9ydCB7IGlzWCB9IGZyb20gJy4uL3R5cGVHdWFyZHMvQ2hhbm5lbCc7XG5leHBvcnQgY29uc3QgU1RSQVRFR1lfRkxBVCA9IHtcbiAgc3RyYXRlZ3k6ICdmbGF0J1xufTtcbmNvbnN0IFNUUkFURUdZX1JPVEFURSA9IHtcbiAgbGFiZWxBbmdsZTogNDAsXG4gIHN0cmF0ZWd5OiAncm90YXRlJ1xufTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGV4cGFuZExhYmVsT3ZlcmxhcFN0cmF0ZWd5KGNoYW5uZWxUeXBlLCBsYWJlbE92ZXJsYXAgPSAnYXV0bycpIHtcbiAgbGV0IG91dHB1dDtcblxuICBzd2l0Y2ggKGxhYmVsT3ZlcmxhcCkge1xuICAgIGNhc2UgJ2ZsYXQnOlxuICAgICAgb3V0cHV0ID0gU1RSQVRFR1lfRkxBVDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncm90YXRlJzpcbiAgICAgIG91dHB1dCA9IFNUUkFURUdZX1JPVEFURTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYXV0byc6XG4gICAgICBvdXRwdXQgPSBpc1goY2hhbm5lbFR5cGUpID8gU1RSQVRFR1lfUk9UQVRFIDogU1RSQVRFR1lfRkxBVDtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIG91dHB1dCA9IGxhYmVsT3ZlcmxhcDtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHsgLi4ub3V0cHV0XG4gIH07XG59IiwiaW1wb3J0IHsgU2NhbGVUeXBlIH0gZnJvbSAnLi4vLi4vdHlwZXMnOyAvLyBHcm91cGVkIGJ5IGRvbWFpbiBhbmQgcmFuZ2VcblxuZXhwb3J0IGNvbnN0IGNvbnRpbnVvdXNUb0NvbnRpbnVvdXNTY2FsZVR5cGVzID0gW1NjYWxlVHlwZS5MSU5FQVIsIFNjYWxlVHlwZS5QT1csIFNjYWxlVHlwZS5TUVJULCBTY2FsZVR5cGUuU1lNTE9HLCBTY2FsZVR5cGUuTE9HLCBTY2FsZVR5cGUuVElNRSwgU2NhbGVUeXBlLlVUQ107XG5leHBvcnQgY29uc3QgY29udGludW91c1RvQ29udGludW91c1NjYWxlVHlwZXNTZXQgPSBuZXcgU2V0KGNvbnRpbnVvdXNUb0NvbnRpbnVvdXNTY2FsZVR5cGVzKTtcbmV4cG9ydCBjb25zdCBjb250aW51b3VzVG9EaXNjcmV0ZVNjYWxlVHlwZXMgPSBbU2NhbGVUeXBlLlFVQU5USUxFLCBTY2FsZVR5cGUuUVVBTlRJWkUsIFNjYWxlVHlwZS5USFJFU0hPTERdO1xuZXhwb3J0IGNvbnN0IGNvbnRpbnVvdXNUb0Rpc2NyZXRlU2NhbGVUeXBlc1NldCA9IG5ldyBTZXQoY29udGludW91c1RvRGlzY3JldGVTY2FsZVR5cGVzKTsgLy8gR3JvdXBlZCBieSBEb21haW5cblxuZXhwb3J0IGNvbnN0IGNvbnRpbnVvdXNEb21haW5TY2FsZVR5cGVzID0gY29udGludW91c1RvQ29udGludW91c1NjYWxlVHlwZXMuY29uY2F0KGNvbnRpbnVvdXNUb0Rpc2NyZXRlU2NhbGVUeXBlcyk7XG5leHBvcnQgY29uc3QgY29udGludW91c0RvbWFpblNjYWxlVHlwZXNTZXQgPSBuZXcgU2V0KGNvbnRpbnVvdXNEb21haW5TY2FsZVR5cGVzKTtcbmV4cG9ydCBjb25zdCBkaXNjcmV0ZURvbWFpblNjYWxlVHlwZXMgPSBbU2NhbGVUeXBlLk9SRElOQUwsIFNjYWxlVHlwZS5CSU5fT1JESU5BTCwgU2NhbGVUeXBlLlBPSU5ULCBTY2FsZVR5cGUuQkFORF07XG5leHBvcnQgY29uc3QgZGlzY3JldGVEb21haW5TY2FsZVR5cGVzU2V0ID0gbmV3IFNldChkaXNjcmV0ZURvbWFpblNjYWxlVHlwZXMpOyAvLyBUaHJlZSBicm9hZCBjYXRlZ29yaWVzXG5cbmV4cG9ydCBjb25zdCBjb250aW51b3VzU2NhbGVUeXBlcyA9IGNvbnRpbnVvdXNUb0NvbnRpbnVvdXNTY2FsZVR5cGVzO1xuZXhwb3J0IGNvbnN0IGNvbnRpbnVvdXNTY2FsZVR5cGVzU2V0ID0gY29udGludW91c1RvQ29udGludW91c1NjYWxlVHlwZXNTZXQ7XG5leHBvcnQgY29uc3QgZGlzY3JldGVTY2FsZVR5cGVzID0gW1NjYWxlVHlwZS5CQU5ELCBTY2FsZVR5cGUuUE9JTlQsIFNjYWxlVHlwZS5PUkRJTkFMXTtcbmV4cG9ydCBjb25zdCBkaXNjcmV0ZVNjYWxlVHlwZXNTZXQgPSBuZXcgU2V0KGRpc2NyZXRlU2NhbGVUeXBlcyk7XG5leHBvcnQgY29uc3QgZGlzY3JldGl6aW5nU2NhbGVUeXBlcyA9IFtTY2FsZVR5cGUuQklOX09SRElOQUwsIFNjYWxlVHlwZS5RVUFOVElMRSwgU2NhbGVUeXBlLlFVQU5USVpFLCBTY2FsZVR5cGUuVEhSRVNIT0xEXTtcbmV4cG9ydCBjb25zdCBkaXNjcmV0aXppbmdTY2FsZVR5cGVzU2V0ID0gbmV3IFNldChkaXNjcmV0aXppbmdTY2FsZVR5cGVzKTsgLy8gT3RoZXJzXG5cbmV4cG9ydCBjb25zdCB0aW1lU2NhbGVUeXBlcyA9IFtTY2FsZVR5cGUuVElNRSwgU2NhbGVUeXBlLlVUQ107XG5leHBvcnQgY29uc3QgdGltZVNjYWxlVHlwZXNTZXQgPSBuZXcgU2V0KHRpbWVTY2FsZVR5cGVzKTtcbmV4cG9ydCBjb25zdCBhbGxTY2FsZVR5cGVzID0gW1NjYWxlVHlwZS5MSU5FQVIsIFNjYWxlVHlwZS5MT0csIFNjYWxlVHlwZS5QT1csIFNjYWxlVHlwZS5TUVJULCBTY2FsZVR5cGUuU1lNTE9HLCBTY2FsZVR5cGUuVElNRSwgU2NhbGVUeXBlLlVUQywgU2NhbGVUeXBlLlFVQU5USUxFLCBTY2FsZVR5cGUuUVVBTlRJWkUsIFNjYWxlVHlwZS5USFJFU0hPTEQsIFNjYWxlVHlwZS5CSU5fT1JESU5BTCwgU2NhbGVUeXBlLk9SRElOQUwsIFNjYWxlVHlwZS5QT0lOVCwgU2NhbGVUeXBlLkJBTkRdO1xuZXhwb3J0IGNvbnN0IGFsbFNjYWxlVHlwZXNTZXQgPSBuZXcgU2V0KGFsbFNjYWxlVHlwZXMpOyIsImltcG9ydCBpc0VuYWJsZWQgZnJvbSAnLi4vdXRpbHMvaXNFbmFibGVkJztcbmltcG9ydCB7IGlzWE9yWSwgaXNYIH0gZnJvbSAnLi4vdHlwZUd1YXJkcy9DaGFubmVsJztcbmltcG9ydCB7IGlzVHlwZWRGaWVsZERlZiB9IGZyb20gJy4uL3R5cGVHdWFyZHMvQ2hhbm5lbERlZic7XG5pbXBvcnQgZXhwYW5kTGFiZWxPdmVybGFwU3RyYXRlZ3kgZnJvbSAnLi9leHBhbmRMYWJlbE92ZXJsYXBTdHJhdGVneSc7XG5pbXBvcnQgeyBjb250aW51b3VzVG9Db250aW51b3VzU2NhbGVUeXBlc1NldCB9IGZyb20gJy4uL3BhcnNlcnMvc2NhbGUvc2NhbGVDYXRlZ29yaWVzJztcblxuZnVuY3Rpb24gaXNDaGFubmVsRGVmV2l0aEF4aXNTdXBwb3J0KGNoYW5uZWxUeXBlLCBjaGFubmVsRGVmKSB7XG4gIHJldHVybiBpc1R5cGVkRmllbGREZWYoY2hhbm5lbERlZikgJiYgaXNYT3JZKGNoYW5uZWxUeXBlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcGxldGVBeGlzQ29uZmlnKGNoYW5uZWxUeXBlLCBjaGFubmVsRGVmKSB7XG4gIGlmIChpc0NoYW5uZWxEZWZXaXRoQXhpc1N1cHBvcnQoY2hhbm5lbFR5cGUsIGNoYW5uZWxEZWYpICYmIGlzRW5hYmxlZChjaGFubmVsRGVmLmF4aXMpKSB7XG4gICAgY29uc3QgYXhpcyA9IGNoYW5uZWxEZWYuYXhpcyA9PT0gdHJ1ZSB8fCB0eXBlb2YgY2hhbm5lbERlZi5heGlzID09PSAndW5kZWZpbmVkJyA/IHt9IDogY2hhbm5lbERlZi5heGlzO1xuICAgIGNvbnN0IGlzWENoYW5uZWwgPSBpc1goY2hhbm5lbFR5cGUpO1xuICAgIGNvbnN0IHtcbiAgICAgIGZvcm1hdCA9IGNoYW5uZWxEZWYuZm9ybWF0LFxuICAgICAgZm9ybWF0VHlwZSA9IGNoYW5uZWxEZWYuZm9ybWF0VHlwZSxcbiAgICAgIGZvcm1hdEluTG9jYWxUaW1lID0gY2hhbm5lbERlZi5mb3JtYXRJbkxvY2FsVGltZSxcbiAgICAgIGxhYmVsQW5nbGUgPSAwLFxuICAgICAgbGFiZWxGbHVzaCxcbiAgICAgIGxhYmVsT3ZlcmxhcCxcbiAgICAgIGxhYmVsUGFkZGluZyA9IDQsXG4gICAgICBvcmllbnQgPSBpc1hDaGFubmVsID8gJ2JvdHRvbScgOiAnbGVmdCcsXG4gICAgICB0aWNrQ291bnQgPSA1LFxuICAgICAgdGlja3MgPSB0cnVlLFxuICAgICAgdGl0bGUgPSBjaGFubmVsRGVmLnRpdGxlLFxuICAgICAgdGl0bGVQYWRkaW5nID0gNFxuICAgIH0gPSBheGlzO1xuICAgIGNvbnN0IG91dHB1dCA9IHsgLi4uYXhpcyxcbiAgICAgIGZvcm1hdCxcbiAgICAgIGZvcm1hdFR5cGUsXG4gICAgICBsYWJlbEFuZ2xlLFxuICAgICAgbGFiZWxGbHVzaDogdHlwZW9mIGxhYmVsRmx1c2ggPT09ICd1bmRlZmluZWQnID8gY2hhbm5lbERlZi5zY2FsZSAmJiB0eXBlb2YgY2hhbm5lbERlZi5zY2FsZS50eXBlICE9PSAndW5kZWZpbmVkJyAmJiBjb250aW51b3VzVG9Db250aW51b3VzU2NhbGVUeXBlc1NldC5oYXMoY2hhbm5lbERlZi5zY2FsZS50eXBlKSA6IGxhYmVsRmx1c2gsXG4gICAgICBsYWJlbE92ZXJsYXA6IGV4cGFuZExhYmVsT3ZlcmxhcFN0cmF0ZWd5KGNoYW5uZWxUeXBlLCBsYWJlbE92ZXJsYXApLFxuICAgICAgbGFiZWxQYWRkaW5nLFxuICAgICAgb3JpZW50LFxuICAgICAgdGlja0NvdW50LFxuICAgICAgdGlja3MsXG4gICAgICB0aXRsZSxcbiAgICAgIHRpdGxlUGFkZGluZ1xuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIGZvcm1hdEluTG9jYWxUaW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgb3V0cHV0LmZvcm1hdEluTG9jYWxUaW1lID0gZm9ybWF0SW5Mb2NhbFRpbWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wbGV0ZUZvcm1hdENvbmZpZyhjb25maWcpIHtcbiAgY29uc3Qge1xuICAgIGZvcm1hdFR5cGUsXG4gICAgZm9ybWF0SW5Mb2NhbFRpbWUsXG4gICAgZm9ybWF0LFxuICAgIHR5cGUsXG4gICAgc2NhbGVUeXBlXG4gIH0gPSBjb25maWc7XG4gIGxldCByZXNvbHZlZEZvcm1hdFR5cGU7XG5cbiAgaWYgKHR5cGVvZiBmb3JtYXRUeXBlICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJlc29sdmVkRm9ybWF0VHlwZSA9IGZvcm1hdFR5cGU7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3F1YW50aXRhdGl2ZScpIHtcbiAgICByZXNvbHZlZEZvcm1hdFR5cGUgPSAnbnVtYmVyJztcbiAgfSBlbHNlIGlmICh0eXBlID09PSAndGVtcG9yYWwnIHx8IHNjYWxlVHlwZSA9PT0gJ3RpbWUnIHx8IHNjYWxlVHlwZSA9PT0gJ3V0YycpIHtcbiAgICByZXNvbHZlZEZvcm1hdFR5cGUgPSAndGltZSc7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGZvcm1hdCAhPT0gJ3VuZGVmaW5lZCcgJiYgZm9ybWF0Lmxlbmd0aCA+IDApIHtcbiAgICByZXNvbHZlZEZvcm1hdFR5cGUgPSAnbnVtYmVyJztcbiAgfVxuXG4gIGlmIChyZXNvbHZlZEZvcm1hdFR5cGUgPT09ICd0aW1lJykge1xuICAgIHJldHVybiB7XG4gICAgICBmb3JtYXRUeXBlOiAndGltZScsXG4gICAgICBmb3JtYXRJbkxvY2FsVGltZTogZm9ybWF0SW5Mb2NhbFRpbWUgfHwgdHlwZW9mIGZvcm1hdEluTG9jYWxUaW1lID09PSAndW5kZWZpbmVkJyAmJiBzY2FsZVR5cGUgPT09ICd0aW1lJyxcbiAgICAgIGZvcm1hdFxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGZvcm1hdFR5cGU6IHJlc29sdmVkRm9ybWF0VHlwZSxcbiAgICBmb3JtYXRcbiAgfTtcbn0iLCJpbXBvcnQgeyBpc1hPclkgfSBmcm9tICcuLi90eXBlR3VhcmRzL0NoYW5uZWwnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcGxldGVMZWdlbmRDb25maWcoY2hhbm5lbFR5cGUsIGNoYW5uZWxEZWYpIHtcbiAgaWYgKCdsZWdlbmQnIGluIGNoYW5uZWxEZWYgJiYgY2hhbm5lbERlZi5sZWdlbmQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBjaGFubmVsRGVmLmxlZ2VuZDtcbiAgfVxuXG4gIHJldHVybiBpc1hPclkoY2hhbm5lbFR5cGUpIHx8IGNoYW5uZWxUeXBlID09PSAnVGV4dCcgPyBmYWxzZSA6IHt9O1xufSIsImltcG9ydCB7IFNjYWxlVHlwZSB9IGZyb20gJy4uL3R5cGVzJztcbi8qKlxuICogU29tZXRpbWVzIHNjYWxlIHR5cGUgaXMgbm90IHNwZWNpZmllZCBidXQgY2FuIGJlIGluZmVycmVkXG4gKiBmcm9tIG90aGVyIGZpZWxkcy5cbiAqIFNlZSBodHRwczovL3ZlZ2EuZ2l0aHViLmlvL3ZlZ2EtbGl0ZS9kb2NzL3NjYWxlLmh0bWxcbiAqIEBwYXJhbSBjaGFubmVsVHlwZSB0eXBlIG9mIHRoZSBjaGFubmVsXG4gKiBAcGFyYW0gZmllbGRUeXBlIHR5cGUgb2YgdGhlIGZpZWxkXG4gKiBAcGFyYW0gYmluIGlzIHZhbHVlIGJpbm5lZFxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGluZmVyU2NhbGVUeXBlKGNoYW5uZWxUeXBlLCBmaWVsZFR5cGUsIGJpbiA9IGZhbHNlKSB7XG4gIGlmIChmaWVsZFR5cGUgPT09ICdub21pbmFsJyB8fCBmaWVsZFR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgIHN3aXRjaCAoY2hhbm5lbFR5cGUpIHtcbiAgICAgIC8vIEZvciBwb3NpdGlvbmFsICh4IGFuZCB5KSBvcmRpbmFsIGFuZCBvcmRpbmFsIGZpZWxkcyxcbiAgICAgIC8vIFwicG9pbnRcIiBpcyB0aGUgZGVmYXVsdCBzY2FsZSB0eXBlIGZvciBhbGwgbWFya3NcbiAgICAgIC8vIGV4Y2VwdCBiYXIgYW5kIHJlY3QgbWFya3MsIHdoaWNoIHVzZSBcImJhbmRcIiBzY2FsZXMuXG4gICAgICAvLyBodHRwczovL3ZlZ2EuZ2l0aHViLmlvL3ZlZ2EtbGl0ZS9kb2NzL3NjYWxlLmh0bWxcbiAgICAgIGNhc2UgJ1hCYW5kJzpcbiAgICAgIGNhc2UgJ1lCYW5kJzpcbiAgICAgICAgcmV0dXJuIFNjYWxlVHlwZS5CQU5EO1xuXG4gICAgICBjYXNlICdYJzpcbiAgICAgIGNhc2UgJ1knOlxuICAgICAgY2FzZSAnTnVtZXJpYyc6XG4gICAgICAgIHJldHVybiBTY2FsZVR5cGUuUE9JTlQ7XG5cbiAgICAgIGNhc2UgJ0NvbG9yJzpcbiAgICAgIGNhc2UgJ0NhdGVnb3J5JzpcbiAgICAgICAgcmV0dXJuIFNjYWxlVHlwZS5PUkRJTkFMO1xuXG4gICAgICBkZWZhdWx0OlxuICAgIH1cbiAgfSBlbHNlIGlmIChmaWVsZFR5cGUgPT09ICdxdWFudGl0YXRpdmUnKSB7XG4gICAgc3dpdGNoIChjaGFubmVsVHlwZSkge1xuICAgICAgY2FzZSAnWEJhbmQnOlxuICAgICAgY2FzZSAnWUJhbmQnOlxuICAgICAgY2FzZSAnWCc6XG4gICAgICBjYXNlICdZJzpcbiAgICAgIGNhc2UgJ051bWVyaWMnOlxuICAgICAgICByZXR1cm4gU2NhbGVUeXBlLkxJTkVBUjtcblxuICAgICAgY2FzZSAnQ29sb3InOlxuICAgICAgICByZXR1cm4gYmluID8gU2NhbGVUeXBlLkJJTl9PUkRJTkFMIDogU2NhbGVUeXBlLkxJTkVBUjtcblxuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gIH0gZWxzZSBpZiAoZmllbGRUeXBlID09PSAndGVtcG9yYWwnKSB7XG4gICAgc3dpdGNoIChjaGFubmVsVHlwZSkge1xuICAgICAgY2FzZSAnWEJhbmQnOlxuICAgICAgY2FzZSAnWUJhbmQnOlxuICAgICAgY2FzZSAnWCc6XG4gICAgICBjYXNlICdZJzpcbiAgICAgIGNhc2UgJ051bWVyaWMnOlxuICAgICAgICByZXR1cm4gU2NhbGVUeXBlLlVUQztcblxuICAgICAgY2FzZSAnQ29sb3InOlxuICAgICAgICByZXR1cm4gU2NhbGVUeXBlLkxJTkVBUjtcblxuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufSIsImltcG9ydCB7IFNjYWxlVHlwZSB9IGZyb20gJy4uLy4uL3R5cGVzJztcbmltcG9ydCB7IGFsbFNjYWxlVHlwZXNTZXQsIGFsbFNjYWxlVHlwZXMsIGNvbnRpbnVvdXNEb21haW5TY2FsZVR5cGVzLCBjb250aW51b3VzU2NhbGVUeXBlcywgY29udGludW91c1NjYWxlVHlwZXNTZXQgfSBmcm9tICcuL3NjYWxlQ2F0ZWdvcmllcyc7XG5jb25zdCBwb2ludE9yQmFuZCA9IFtTY2FsZVR5cGUuUE9JTlQsIFNjYWxlVHlwZS5CQU5EXTtcbmNvbnN0IHBvaW50T3JCYW5kU2V0ID0gbmV3IFNldChwb2ludE9yQmFuZCk7XG5jb25zdCBleGNlcHRQb2ludE9yQmFuZCA9IGFsbFNjYWxlVHlwZXMuZmlsdGVyKHR5cGUgPT4gIXBvaW50T3JCYW5kU2V0Lmhhcyh0eXBlKSk7XG5jb25zdCBleGNlcHRQb2ludE9yQmFuZFNldCA9IG5ldyBTZXQoZXhjZXB0UG9pbnRPckJhbmQpO1xuY29uc3QgY29udGludW91c09yUG9pbnRPckJhbmRTZXQgPSBuZXcgU2V0KGNvbnRpbnVvdXNTY2FsZVR5cGVzLmNvbmNhdChwb2ludE9yQmFuZCkpO1xuY29uc3QgemVyb1NldCA9IG5ldyBTZXQoY29udGludW91c0RvbWFpblNjYWxlVHlwZXMpOyAvLyBsb2cgc2NhbGUgY2Fubm90IGhhdmUgemVybyB2YWx1ZVxuXG56ZXJvU2V0LmRlbGV0ZShTY2FsZVR5cGUuTE9HKTsgLy8gemVybyBpcyBub3QgbWVhbmluZ2Z1bCBmb3IgdGltZVxuXG56ZXJvU2V0LmRlbGV0ZShTY2FsZVR5cGUuVElNRSk7XG56ZXJvU2V0LmRlbGV0ZShTY2FsZVR5cGUuVVRDKTsgLy8gdGhyZXNob2xkIHJlcXVpcmVzIGN1c3RvbSBkb21haW4gc28gemVybyBkb2VzIG5vdCBtYXR0ZXJcblxuemVyb1NldC5kZWxldGUoU2NhbGVUeXBlLlRIUkVTSE9MRCk7IC8vIHF1YW50aWxlIGRlcGVuZHMgb24gZGlzdHJpYnV0aW9uIHNvIHplcm8gZG9lcyBub3QgbWF0dGVyXG5cbnplcm9TZXQuZGVsZXRlKFNjYWxlVHlwZS5RVUFOVElMRSk7XG5jb25zdCBzdXBwb3J0ZWRTY2FsZVR5cGVzID0ge1xuICBhbGlnbjogcG9pbnRPckJhbmRTZXQsXG4gIGJhc2U6IG5ldyBTZXQoW1NjYWxlVHlwZS5MT0ddKSxcbiAgY2xhbXA6IGNvbnRpbnVvdXNTY2FsZVR5cGVzU2V0LFxuICBjb25zdGFudDogbmV3IFNldChbU2NhbGVUeXBlLlNZTUxPR10pLFxuICBkb21haW46IGFsbFNjYWxlVHlwZXNTZXQsXG4gIGV4cG9uZW50OiBuZXcgU2V0KFtTY2FsZVR5cGUuUE9XXSksXG4gIGludGVycG9sYXRlOiBleGNlcHRQb2ludE9yQmFuZFNldCxcbiAgbmljZTogbmV3IFNldChjb250aW51b3VzU2NhbGVUeXBlcy5jb25jYXQoW1NjYWxlVHlwZS5RVUFOVElaRSwgU2NhbGVUeXBlLlRIUkVTSE9MRF0pKSxcbiAgcGFkZGluZzogY29udGludW91c09yUG9pbnRPckJhbmRTZXQsXG4gIHBhZGRpbmdJbm5lcjogbmV3IFNldChbU2NhbGVUeXBlLkJBTkRdKSxcbiAgcGFkZGluZ091dGVyOiBwb2ludE9yQmFuZFNldCxcbiAgcmFuZ2U6IGFsbFNjYWxlVHlwZXNTZXQsXG4gIHJldmVyc2U6IGFsbFNjYWxlVHlwZXNTZXQsXG4gIHJvdW5kOiBjb250aW51b3VzT3JQb2ludE9yQmFuZFNldCxcbiAgc2NoZW1lOiBleGNlcHRQb2ludE9yQmFuZFNldCxcbiAgdHlwZTogYWxsU2NhbGVUeXBlc1NldCxcbiAgdW5rbm93bjogbmV3IFNldChbU2NhbGVUeXBlLk9SRElOQUxdKSxcbiAgemVybzogemVyb1NldFxufTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzUHJvcGVydHlTdXBwb3J0ZWRCeVNjYWxlVHlwZShwcm9wZXJ0eSwgc2NhbGVUeXBlKSB7XG4gIHJldHVybiBzdXBwb3J0ZWRTY2FsZVR5cGVzW3Byb3BlcnR5XS5oYXMoc2NhbGVUeXBlKTtcbn0iLCJpbXBvcnQgaXNQcm9wZXJ0eVN1cHBvcnRlZEJ5U2NhbGVUeXBlIGZyb20gJy4uL3BhcnNlcnMvc2NhbGUvaXNQcm9wZXJ0eVN1cHBvcnRlZEJ5U2NhbGVUeXBlJztcbmltcG9ydCB7IGNvbnRpbnVvdXNTY2FsZVR5cGVzU2V0LCBkaXNjcmV0aXppbmdTY2FsZVR5cGVzU2V0LCBkaXNjcmV0ZVNjYWxlVHlwZXNTZXQgfSBmcm9tICcuLi9wYXJzZXJzL3NjYWxlL3NjYWxlQ2F0ZWdvcmllcyc7XG5leHBvcnQgZnVuY3Rpb24gaXNDb250aW51b3VzU2NhbGVDb25maWcoY29uZmlnKSB7XG4gIHJldHVybiBjb250aW51b3VzU2NhbGVUeXBlc1NldC5oYXMoY29uZmlnLnR5cGUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzRGlzY3JldGl6aW5nU2NhbGVDb25maWcoY29uZmlnKSB7XG4gIHJldHVybiBkaXNjcmV0aXppbmdTY2FsZVR5cGVzU2V0Lmhhcyhjb25maWcudHlwZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNEaXNjcmV0ZVNjYWxlQ29uZmlnKGNvbmZpZykge1xuICByZXR1cm4gZGlzY3JldGVTY2FsZVR5cGVzU2V0Lmhhcyhjb25maWcudHlwZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNTY2FsZUNvbmZpZ1dpdGhaZXJvKGNvbmZpZykge1xuICByZXR1cm4gaXNQcm9wZXJ0eVN1cHBvcnRlZEJ5U2NhbGVUeXBlKCd6ZXJvJywgY29uZmlnLnR5cGUpO1xufSIsImltcG9ydCBpbmZlclNjYWxlVHlwZSBmcm9tICcuL2luZmVyU2NhbGVUeXBlJztcbmltcG9ydCB7IGlzVHlwZWRGaWVsZERlZiB9IGZyb20gJy4uL3R5cGVHdWFyZHMvQ2hhbm5lbERlZic7XG5pbXBvcnQgeyBpc0NvbnRpbnVvdXNTY2FsZUNvbmZpZywgaXNTY2FsZUNvbmZpZ1dpdGhaZXJvIH0gZnJvbSAnLi4vdHlwZUd1YXJkcy9TY2FsZUNvbmZpZyc7XG5pbXBvcnQgaXNFbmFibGVkIGZyb20gJy4uL3V0aWxzL2lzRW5hYmxlZCc7XG5pbXBvcnQgeyB0aW1lU2NhbGVUeXBlc1NldCB9IGZyb20gJy4uL3BhcnNlcnMvc2NhbGUvc2NhbGVDYXRlZ29yaWVzJztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXBsZXRlU2NhbGVDb25maWcoY2hhbm5lbFR5cGUsIGNoYW5uZWxEZWYpIHtcbiAgaWYgKGlzVHlwZWRGaWVsZERlZihjaGFubmVsRGVmKSAmJiBpc0VuYWJsZWQoY2hhbm5lbERlZi5zY2FsZSkpIHtcbiAgICBjb25zdCB7XG4gICAgICBzY2FsZSA9IHt9LFxuICAgICAgdHlwZSxcbiAgICAgIGJpblxuICAgIH0gPSBjaGFubmVsRGVmO1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGU6IHNjYWxlVHlwZSA9IGluZmVyU2NhbGVUeXBlKGNoYW5uZWxUeXBlLCB0eXBlLCBiaW4pXG4gICAgfSA9IHNjYWxlO1xuXG4gICAgaWYgKHR5cGVvZiBzY2FsZVR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2NvbnNpc3RlbnQtdHlwZS1hc3NlcnRpb25zXG5cblxuICAgIGNvbnN0IGZpbGxlZFNjYWxlID0geyAuLi5zY2FsZSxcbiAgICAgIHR5cGU6IHNjYWxlVHlwZVxuICAgIH07XG5cbiAgICBpZiAoaXNDb250aW51b3VzU2NhbGVDb25maWcoZmlsbGVkU2NhbGUpKSB7XG4gICAgICBpZiAodHlwZW9mIGZpbGxlZFNjYWxlLm5pY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGZpbGxlZFNjYWxlLm5pY2UgPSAhdGltZVNjYWxlVHlwZXNTZXQuaGFzKHNjYWxlVHlwZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgZmlsbGVkU2NhbGUuY2xhbXAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGZpbGxlZFNjYWxlLmNsYW1wID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNTY2FsZUNvbmZpZ1dpdGhaZXJvKGZpbGxlZFNjYWxlKSAmJiB0eXBlb2YgZmlsbGVkU2NhbGUuemVybyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGZpbGxlZFNjYWxlLnplcm8gPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmaWxsZWRTY2FsZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn0iLCJpbXBvcnQgeyBpc1hPclkgfSBmcm9tICcuLi90eXBlR3VhcmRzL0NoYW5uZWwnO1xuY29uc3QgdGVtcG9yYWxGaWVsZE5hbWVzID0gbmV3IFNldChbJ3RpbWUnLCAnZGF0ZScsICdkYXRldGltZScsICd0aW1lc3RhbXAnXSk7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbmZlckZpZWxkVHlwZShjaGFubmVsVHlwZSwgZmllbGQgPSAnJykge1xuICBpZiAoaXNYT3JZKGNoYW5uZWxUeXBlKSB8fCBjaGFubmVsVHlwZSA9PT0gJ051bWVyaWMnKSB7XG4gICAgcmV0dXJuIHRlbXBvcmFsRmllbGROYW1lcy5oYXMoZmllbGQudG9Mb3dlckNhc2UoKSkgPyAndGVtcG9yYWwnIDogJ3F1YW50aXRhdGl2ZSc7XG4gIH1cblxuICByZXR1cm4gJ25vbWluYWwnO1xufSIsImltcG9ydCB7IGlzRmllbGREZWYsIGlzVmFsdWVEZWYsIGlzVHlwZWRGaWVsZERlZiB9IGZyb20gJy4uL3R5cGVHdWFyZHMvQ2hhbm5lbERlZic7XG5pbXBvcnQgY29tcGxldGVBeGlzQ29uZmlnIGZyb20gJy4vY29tcGxldGVBeGlzQ29uZmlnJztcbmltcG9ydCBjb21wbGV0ZUZvcm1hdENvbmZpZyBmcm9tICcuL2NvbXBsZXRlRm9ybWF0Q29uZmlnJztcbmltcG9ydCBjb21wbGV0ZUxlZ2VuZENvbmZpZyBmcm9tICcuL2NvbXBsZXRlTGVnZW5kQ29uZmlnJztcbmltcG9ydCBjb21wbGV0ZVNjYWxlQ29uZmlnIGZyb20gJy4vY29tcGxldGVTY2FsZUNvbmZpZyc7XG5pbXBvcnQgaW5mZXJGaWVsZFR5cGUgZnJvbSAnLi9pbmZlckZpZWxkVHlwZSc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wbGV0ZUNoYW5uZWxEZWYoY2hhbm5lbFR5cGUsIGNoYW5uZWxEZWYpIHtcbiAgdmFyIF9jaGFubmVsRGVmJHRpdGxlO1xuXG4gIGlmIChpc1ZhbHVlRGVmKGNoYW5uZWxEZWYpKSB7XG4gICAgcmV0dXJuIHsgLi4uY2hhbm5lbERlZixcbiAgICAgIGF4aXM6IGZhbHNlLFxuICAgICAgbGVnZW5kOiBmYWxzZSxcbiAgICAgIHNjYWxlOiBmYWxzZSxcbiAgICAgIHRpdGxlOiAnJ1xuICAgIH07XG4gIH0gLy8gRmlsbCB0b3AtbGV2ZWwgcHJvcGVydGllc1xuXG5cbiAgY29uc3QgY29weSA9IHsgLi4uY2hhbm5lbERlZixcbiAgICB0aXRsZTogaXNGaWVsZERlZihjaGFubmVsRGVmKSA/IChfY2hhbm5lbERlZiR0aXRsZSA9IGNoYW5uZWxEZWYudGl0bGUpICE9IG51bGwgPyBfY2hhbm5lbERlZiR0aXRsZSA6IGNoYW5uZWxEZWYuZmllbGQgOiAnJyxcbiAgICB0eXBlOiBpc1R5cGVkRmllbGREZWYoY2hhbm5lbERlZikgPyBjaGFubmVsRGVmLnR5cGUgOiBpbmZlckZpZWxkVHlwZShjaGFubmVsVHlwZSwgY2hhbm5lbERlZi5maWVsZClcbiAgfTsgLy8gU2NhbGUgbmVlZHMgdGhlIHRvcC1sZXZlbCBwcm9wZXJ0aWVzIHRvIGJlIGZpbGxlZC5cblxuICBjb25zdCBzY2FsZSA9IGNvbXBsZXRlU2NhbGVDb25maWcoY2hhbm5lbFR5cGUsIGNvcHkpOyAvLyBGb3JtYXQgbmVlZHMgc2NhbGUuXG5cbiAgY29uc3QgZm9ybWF0ID0gY29tcGxldGVGb3JtYXRDb25maWcoeyAuLi5jaGFubmVsRGVmLFxuICAgIHNjYWxlVHlwZTogc2NhbGUgPyBzY2FsZS50eXBlIDogdW5kZWZpbmVkXG4gIH0pO1xuICBjb25zdCBjb3B5MiA9IHsgLi4uY29weSxcbiAgICAuLi5mb3JtYXQsXG4gICAgc2NhbGVcbiAgfTsgLy8gVGhlc2UgbmVlZCBzY2FsZSBhbmQgZm9ybWF0XG5cbiAgY29uc3QgYXhpcyA9IGNvbXBsZXRlQXhpc0NvbmZpZyhjaGFubmVsVHlwZSwgY29weTIpO1xuICBjb25zdCBsZWdlbmQgPSBjb21wbGV0ZUxlZ2VuZENvbmZpZyhjaGFubmVsVHlwZSwgY29weTIpO1xuICByZXR1cm4geyAuLi5jb3B5MixcbiAgICBheGlzLFxuICAgIGxlZ2VuZFxuICB9O1xufSIsImltcG9ydCB7IHNjYWxlTGluZWFyLCBzY2FsZUxvZywgc2NhbGVQb3csIHNjYWxlU3FydCwgc2NhbGVUaW1lLCBzY2FsZVV0Yywgc2NhbGVRdWFudGlsZSwgc2NhbGVRdWFudGl6ZSwgc2NhbGVUaHJlc2hvbGQsIHNjYWxlT3JkaW5hbCwgc2NhbGVQb2ludCwgc2NhbGVCYW5kLCBzY2FsZVN5bWxvZyB9IGZyb20gJ2QzLXNjYWxlJztcbmltcG9ydCB7IFNjYWxlVHlwZSB9IGZyb20gJy4uLy4uL3R5cGVzJztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZVNjYWxlRnJvbVNjYWxlVHlwZSh0eXBlKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgU2NhbGVUeXBlLkxJTkVBUjpcbiAgICAgIHJldHVybiBzY2FsZUxpbmVhcigpO1xuXG4gICAgY2FzZSBTY2FsZVR5cGUuTE9HOlxuICAgICAgcmV0dXJuIHNjYWxlTG9nKCk7XG5cbiAgICBjYXNlIFNjYWxlVHlwZS5QT1c6XG4gICAgICByZXR1cm4gc2NhbGVQb3coKTtcblxuICAgIGNhc2UgU2NhbGVUeXBlLlNRUlQ6XG4gICAgICByZXR1cm4gc2NhbGVTcXJ0KCk7XG5cbiAgICBjYXNlIFNjYWxlVHlwZS5USU1FOlxuICAgICAgcmV0dXJuIHNjYWxlVGltZSgpO1xuXG4gICAgY2FzZSBTY2FsZVR5cGUuVVRDOlxuICAgICAgcmV0dXJuIHNjYWxlVXRjKCk7XG5cbiAgICBjYXNlIFNjYWxlVHlwZS5RVUFOVElMRTpcbiAgICAgIHJldHVybiBzY2FsZVF1YW50aWxlKCk7XG5cbiAgICBjYXNlIFNjYWxlVHlwZS5RVUFOVElaRTpcbiAgICAgIHJldHVybiBzY2FsZVF1YW50aXplKCk7XG5cbiAgICBjYXNlIFNjYWxlVHlwZS5USFJFU0hPTEQ6XG4gICAgICByZXR1cm4gc2NhbGVUaHJlc2hvbGQoKTtcblxuICAgIGNhc2UgU2NhbGVUeXBlLk9SRElOQUw6XG4gICAgICByZXR1cm4gc2NhbGVPcmRpbmFsKCk7XG5cbiAgICBjYXNlIFNjYWxlVHlwZS5QT0lOVDpcbiAgICAgIHJldHVybiBzY2FsZVBvaW50KCk7XG5cbiAgICBjYXNlIFNjYWxlVHlwZS5CQU5EOlxuICAgICAgcmV0dXJuIHNjYWxlQmFuZCgpO1xuXG4gICAgY2FzZSBTY2FsZVR5cGUuU1lNTE9HOlxuICAgICAgcmV0dXJuIHNjYWxlU3ltbG9nKCk7XG5cbiAgICBjYXNlIFNjYWxlVHlwZS5CSU5fT1JESU5BTDpcbiAgICAgIC8vIFRPRE86IFBlbmRpbmcgc2NhbGUuYmlucyBpbXBsZW1lbnRhdGlvblxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXFxcInR5cGUgPSBcIiArIHR5cGUgKyBcIlxcXCIgaXMgbm90IHN1cHBvcnRlZCB5ZXQuXCIpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzY2FsZUxpbmVhcigpO1xuICB9XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXBwbHlBbGlnbihjb25maWcsIHNjYWxlKSB7XG4gIGlmICgnYWxpZ24nIGluIGNvbmZpZyAmJiB0eXBlb2YgY29uZmlnLmFsaWduICE9PSAndW5kZWZpbmVkJyAmJiAnYWxpZ24nIGluIHNjYWxlKSB7XG4gICAgc2NhbGUuYWxpZ24oY29uZmlnLmFsaWduKTtcbiAgfVxufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFwcGx5QmFzZShjb25maWcsIHNjYWxlKSB7XG4gIGlmICgnYmFzZScgaW4gY29uZmlnICYmIHR5cGVvZiBjb25maWcuYmFzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2Jhc2UnIGluIHNjYWxlKSB7XG4gICAgc2NhbGUuYmFzZShjb25maWcuYmFzZSk7XG4gIH1cbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhcHBseUNsYW1wKGNvbmZpZywgc2NhbGUpIHtcbiAgaWYgKCdjbGFtcCcgaW4gY29uZmlnICYmIGNvbmZpZy5jbGFtcCA9PT0gdHJ1ZSAmJiAnY2xhbXAnIGluIHNjYWxlKSB7XG4gICAgc2NhbGUuY2xhbXAoY29uZmlnLmNsYW1wKTtcbiAgfVxufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFwcGx5RXhwb25lbnQoY29uZmlnLCBzY2FsZSkge1xuICBpZiAoJ2V4cG9uZW50JyBpbiBjb25maWcgJiYgdHlwZW9mIGNvbmZpZy5leHBvbmVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2V4cG9uZW50JyBpbiBzY2FsZSkge1xuICAgIHNjYWxlLmV4cG9uZW50KGNvbmZpZy5leHBvbmVudCk7XG4gIH1cbn0iLCJpbXBvcnQgeyB0aW1lU2Vjb25kLCB0aW1lTWludXRlLCB0aW1lSG91ciwgdGltZURheSwgdGltZVllYXIsIHRpbWVNb250aCwgdGltZVdlZWssIHV0Y1NlY29uZCwgdXRjTWludXRlLCB1dGNIb3VyLCB1dGNEYXksIHV0Y1dlZWssIHV0Y01vbnRoLCB1dGNZZWFyIH0gZnJvbSAnZDMtdGltZSc7XG5pbXBvcnQgeyBTY2FsZVR5cGUgfSBmcm9tICcuLi8uLi90eXBlcyc7XG5jb25zdCBsb2NhbFRpbWVJbnRlcnZhbHMgPSB7XG4gIGRheTogdGltZURheSxcbiAgaG91cjogdGltZUhvdXIsXG4gIG1pbnV0ZTogdGltZU1pbnV0ZSxcbiAgbW9udGg6IHRpbWVNb250aCxcbiAgc2Vjb25kOiB0aW1lU2Vjb25kLFxuICB3ZWVrOiB0aW1lV2VlayxcbiAgeWVhcjogdGltZVllYXJcbn07XG5jb25zdCB1dGNJbnRlcnZhbHMgPSB7XG4gIGRheTogdXRjRGF5LFxuICBob3VyOiB1dGNIb3VyLFxuICBtaW51dGU6IHV0Y01pbnV0ZSxcbiAgbW9udGg6IHV0Y01vbnRoLFxuICBzZWNvbmQ6IHV0Y1NlY29uZCxcbiAgd2VlazogdXRjV2VlayxcbiAgeWVhcjogdXRjWWVhclxufTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFwcGx5TmljZShjb25maWcsIHNjYWxlKSB7XG4gIGlmICgnbmljZScgaW4gY29uZmlnICYmIHR5cGVvZiBjb25maWcubmljZSAhPT0gJ3VuZGVmaW5lZCcgJiYgJ25pY2UnIGluIHNjYWxlKSB7XG4gICAgY29uc3Qge1xuICAgICAgbmljZVxuICAgIH0gPSBjb25maWc7XG5cbiAgICBpZiAodHlwZW9mIG5pY2UgPT09ICdib29sZWFuJykge1xuICAgICAgaWYgKG5pY2UpIHtcbiAgICAgICAgc2NhbGUubmljZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG5pY2UgPT09ICdudW1iZXInKSB7XG4gICAgICBzY2FsZS5uaWNlKG5pY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0aW1lU2NhbGUgPSBzY2FsZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdHlwZVxuICAgICAgfSA9IGNvbmZpZztcblxuICAgICAgaWYgKHR5cGVvZiBuaWNlID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aW1lU2NhbGUubmljZSh0eXBlID09PSBTY2FsZVR5cGUuVVRDID8gdXRjSW50ZXJ2YWxzW25pY2VdIDogbG9jYWxUaW1lSW50ZXJ2YWxzW25pY2VdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBpbnRlcnZhbCxcbiAgICAgICAgICBzdGVwXG4gICAgICAgIH0gPSBuaWNlO1xuICAgICAgICBjb25zdCBwYXJzZWRJbnRlcnZhbCA9ICh0eXBlID09PSBTY2FsZVR5cGUuVVRDID8gdXRjSW50ZXJ2YWxzW2ludGVydmFsXSA6IGxvY2FsVGltZUludGVydmFsc1tpbnRlcnZhbF0pLmV2ZXJ5KHN0ZXApO1xuXG4gICAgICAgIGlmIChwYXJzZWRJbnRlcnZhbCAhPT0gbnVsbCkge1xuICAgICAgICAgIHRpbWVTY2FsZS5uaWNlKHBhcnNlZEludGVydmFsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSIsImltcG9ydCB7IHRpbWVTY2FsZVR5cGVzU2V0LCBjb250aW51b3VzU2NhbGVUeXBlc1NldCwgZGlzY3JldGl6aW5nU2NhbGVUeXBlc1NldCwgZGlzY3JldGVTY2FsZVR5cGVzU2V0IH0gZnJvbSAnLi4vcGFyc2Vycy9zY2FsZS9zY2FsZUNhdGVnb3JpZXMnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ29udGludW91c1NjYWxlKHNjYWxlLCBzY2FsZVR5cGUpIHtcbiAgcmV0dXJuIHNjYWxlICYmIGNvbnRpbnVvdXNTY2FsZVR5cGVzU2V0LmhhcyhzY2FsZVR5cGUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzRGlzY3JldGl6aW5nU2NhbGUoc2NhbGUsIHNjYWxlVHlwZSkge1xuICByZXR1cm4gc2NhbGUgJiYgZGlzY3JldGl6aW5nU2NhbGVUeXBlc1NldC5oYXMoc2NhbGVUeXBlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0Rpc2NyZXRlU2NhbGUoc2NhbGUsIHNjYWxlVHlwZSkge1xuICByZXR1cm4gc2NhbGUgJiYgZGlzY3JldGVTY2FsZVR5cGVzU2V0LmhhcyhzY2FsZVR5cGUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzVGltZVNjYWxlKHNjYWxlLCBzY2FsZVR5cGUpIHtcbiAgcmV0dXJuIHNjYWxlICYmIHRpbWVTY2FsZVR5cGVzU2V0LmhhcyhzY2FsZVR5cGUpO1xufSIsImltcG9ydCB7IGlzQ29udGludW91c1NjYWxlIH0gZnJvbSAnLi4vLi4vdHlwZUd1YXJkcy9TY2FsZSc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhcHBseVplcm8oY29uZmlnLCBzY2FsZSkge1xuICBpZiAoJ3plcm8nIGluIGNvbmZpZyAmJiBjb25maWcuemVybyA9PT0gdHJ1ZSAmJiBpc0NvbnRpbnVvdXNTY2FsZShzY2FsZSwgY29uZmlnLnR5cGUpKSB7XG4gICAgY29uc3QgZG9tYWluID0gc2NhbGUuZG9tYWluKCk7XG4gICAgY29uc3QgW2EsIGJdID0gZG9tYWluO1xuICAgIGNvbnN0IGlzRGVzY2VuZGluZyA9IGIgPCBhO1xuICAgIGNvbnN0IFttaW4sIG1heF0gPSBpc0Rlc2NlbmRpbmcgPyBbYiwgYV0gOiBbYSwgYl07XG4gICAgY29uc3QgZG9tYWluV2l0aFplcm8gPSBbTWF0aC5taW4oMCwgbWluKSwgTWF0aC5tYXgoMCwgbWF4KV07XG4gICAgc2NhbGUuZG9tYWluKGlzRGVzY2VuZGluZyA/IGRvbWFpbldpdGhaZXJvLnJldmVyc2UoKSA6IGRvbWFpbldpdGhaZXJvKTtcbiAgfVxufSIsImltcG9ydCB7IGludGVycG9sYXRlUmdiLCBpbnRlcnBvbGF0ZUxhYiwgaW50ZXJwb2xhdGVIY2wsIGludGVycG9sYXRlSGNsTG9uZywgaW50ZXJwb2xhdGVIc2wsIGludGVycG9sYXRlSHNsTG9uZywgaW50ZXJwb2xhdGVDdWJlaGVsaXgsIGludGVycG9sYXRlQ3ViZWhlbGl4TG9uZyB9IGZyb20gJ2QzLWludGVycG9sYXRlJztcbmNvbnN0IGludGVycG9sYXRvck1hcCA9IHtcbiAgbGFiOiBpbnRlcnBvbGF0ZUxhYixcbiAgaGNsOiBpbnRlcnBvbGF0ZUhjbCxcbiAgJ2hjbC1sb25nJzogaW50ZXJwb2xhdGVIY2xMb25nLFxuICBoc2w6IGludGVycG9sYXRlSHNsLFxuICAnaHNsLWxvbmcnOiBpbnRlcnBvbGF0ZUhzbExvbmcsXG4gIGN1YmVoZWxpeDogaW50ZXJwb2xhdGVDdWJlaGVsaXgsXG4gICdjdWJlaGVsaXgtbG9uZyc6IGludGVycG9sYXRlQ3ViZWhlbGl4TG9uZyxcbiAgcmdiOiBpbnRlcnBvbGF0ZVJnYlxufTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZUNvbG9ySW50ZXJwb2xhdG9yKGludGVycG9sYXRlKSB7XG4gIHN3aXRjaCAoaW50ZXJwb2xhdGUpIHtcbiAgICBjYXNlICdsYWInOlxuICAgIGNhc2UgJ2hjbCc6XG4gICAgY2FzZSAnaGNsLWxvbmcnOlxuICAgIGNhc2UgJ2hzbCc6XG4gICAgY2FzZSAnaHNsLWxvbmcnOlxuICAgIGNhc2UgJ2N1YmVoZWxpeCc6XG4gICAgY2FzZSAnY3ViZWhlbGl4LWxvbmcnOlxuICAgIGNhc2UgJ3JnYic6XG4gICAgICByZXR1cm4gaW50ZXJwb2xhdG9yTWFwW2ludGVycG9sYXRlXTtcblxuICAgIGRlZmF1bHQ6XG4gIH1cblxuICBjb25zdCB7XG4gICAgdHlwZSxcbiAgICBnYW1tYVxuICB9ID0gaW50ZXJwb2xhdGU7XG4gIGNvbnN0IGludGVycG9sYXRvciA9IGludGVycG9sYXRvck1hcFt0eXBlXTtcbiAgcmV0dXJuIHR5cGVvZiBnYW1tYSA9PT0gJ3VuZGVmaW5lZCcgPyBpbnRlcnBvbGF0b3IgOiBpbnRlcnBvbGF0b3IuZ2FtbWEoZ2FtbWEpO1xufSIsImltcG9ydCBjcmVhdGVDb2xvckludGVycG9sYXRvciBmcm9tICcuL2NyZWF0ZUNvbG9ySW50ZXJwb2xhdG9yJztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFwcGx5SW50ZXJwb2xhdGUoY29uZmlnLCBzY2FsZSkge1xuICBpZiAoJ2ludGVycG9sYXRlJyBpbiBjb25maWcgJiYgdHlwZW9mIGNvbmZpZy5pbnRlcnBvbGF0ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2ludGVycG9sYXRlJyBpbiBzY2FsZSkge1xuICAgIHNjYWxlLmludGVycG9sYXRlKGNyZWF0ZUNvbG9ySW50ZXJwb2xhdG9yKGNvbmZpZy5pbnRlcnBvbGF0ZSkpO1xuICB9XG59IiwiaW1wb3J0IHsgaW50ZXJwb2xhdGVSb3VuZCB9IGZyb20gJ2QzLWludGVycG9sYXRlJztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFwcGx5Um91bmQoY29uZmlnLCBzY2FsZSkge1xuICBpZiAoJ3JvdW5kJyBpbiBjb25maWcgJiYgY29uZmlnLnJvdW5kID09PSB0cnVlKSB7XG4gICAgY29uc3Qgcm91bmRhYmxlU2NhbGUgPSBzY2FsZTtcblxuICAgIGlmICgncm91bmQnIGluIHJvdW5kYWJsZVNjYWxlKSB7XG4gICAgICByb3VuZGFibGVTY2FsZS5yb3VuZChjb25maWcucm91bmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByb3VuZGFibGVTY2FsZS5pbnRlcnBvbGF0ZShpbnRlcnBvbGF0ZVJvdW5kKTtcbiAgICB9XG4gIH1cbn0iLCJpbXBvcnQgeyB0aW1lU2NhbGVUeXBlc1NldCB9IGZyb20gJy4uL3NjYWxlL3NjYWxlQ2F0ZWdvcmllcyc7XG4vKipcbiAqIENvbnZlcnQgZWFjaCBlbGVtZW50IGluIHRoZSBhcnJheSBpbnRvXG4gKiAtIERhdGUgKGZvciB0aW1lIHNjYWxlcylcbiAqIC0gbnVtYmVyIChmb3Igb3RoZXIgY29udGludW91cyBzY2FsZXMpXG4gKiBAcGFyYW0gZG9tYWluXG4gKiBAcGFyYW0gc2NhbGVUeXBlXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGFyc2VDb250aW51b3VzRG9tYWluKGRvbWFpbiwgc2NhbGVUeXBlKSB7XG4gIGlmICh0aW1lU2NhbGVUeXBlc1NldC5oYXMoc2NhbGVUeXBlKSkge1xuICAgIHJldHVybiBkb21haW4uZmlsdGVyKGQgPT4gdHlwZW9mIGQgIT09ICdib29sZWFuJykubWFwKGQgPT4gdHlwZW9mIGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBkID09PSAnbnVtYmVyJyA/IG5ldyBEYXRlKGQpIDogZCk7XG4gIH1cblxuICByZXR1cm4gZG9tYWluLm1hcChkID0+IHR5cGVvZiBkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgZCA9PT0gJ2Jvb2xlYW4nID8gTnVtYmVyKGQpIDogZCk7XG59IiwiLyoqXG4gKiBEaXNjcmV0ZSBkb21haW5zIGFyZSBjb252ZXJ0ZWQgaW50byBzdHJpbmdbXVxuICogd2hlbiB1c2luZyBEMyBzY2FsZXNcbiAqIEBwYXJhbSBkb21haW5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGFyc2VEaXNjcmV0ZURvbWFpbihkb21haW4pIHtcbiAgcmV0dXJuIGRvbWFpbi5tYXAoZCA9PiBcIlwiICsgZCk7XG59IiwiLyoqXG4gKiBDb21iaW5lIHR3byBhcnJheXMgaW50byBhIHVuaXF1ZSBsaXN0XG4gKiBieSBrZWVwaW5nIHRoZSBvcmRlciB0aGUgZml4ZWRDYXRlZ29yaWVzXG4gKiBhbmQgYXBwZW5kIG5ldyBjYXRlZ29yaWVzIGF0IHRoZSBlbmQuXG4gKiBAcGFyYW0gZml4ZWRDYXRlZ29yaWVzXG4gKiBAcGFyYW0gaW5wdXRDYXRlZ29yaWVzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbWJpbmVDYXRlZ29yaWVzKGZpeGVkQ2F0ZWdvcmllcywgaW5wdXRDYXRlZ29yaWVzID0gW10pIHtcbiAgaWYgKGZpeGVkQ2F0ZWdvcmllcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gaW5wdXRDYXRlZ29yaWVzO1xuICB9XG5cbiAgY29uc3QgZml4ZWRTZXQgPSBuZXcgU2V0KGZpeGVkQ2F0ZWdvcmllcyk7XG4gIHJldHVybiBmaXhlZENhdGVnb3JpZXMuY29uY2F0KGlucHV0Q2F0ZWdvcmllcy5maWx0ZXIoZCA9PiAhZml4ZWRTZXQuaGFzKGQpKSk7XG59IiwiaW1wb3J0IHsgaXNFdmVyeUVsZW1lbnREZWZpbmVkLCBpc0RlZmluZWQgfSBmcm9tICcuLi90eXBlR3VhcmRzL0Jhc2UnO1xuLyoqXG4gKiBDb21iaW5lIHR3byBjb250aW51b3VzIGRvbWFpbiBhbmQgZW5zdXJlIHRoYXQgdGhlIG91dHB1dFxuICogZG9lcyBub3QgZ28gYmV5b25kIGZpeGVkRG9tYWluXG4gKiBAcGFyYW0gYm91bmRzXG4gKiBAcGFyYW0gZGF0YURvbWFpblxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbWJpbmVDb250aW51b3VzRG9tYWlucyhib3VuZHMsIGRhdGFEb21haW4pIHtcbiAgaWYgKGJvdW5kcy5sZW5ndGggPiAwICYmIGlzRXZlcnlFbGVtZW50RGVmaW5lZChib3VuZHMpKSB7XG4gICAgcmV0dXJuIGJvdW5kcztcbiAgfVxuXG4gIGlmIChib3VuZHMubGVuZ3RoID09PSAyICYmIGRhdGFEb21haW4ubGVuZ3RoID09PSAyICYmIGJvdW5kcy5maWx0ZXIoaXNEZWZpbmVkKS5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgW2JvdW5kTWluLCBib3VuZE1heF0gPSBib3VuZHM7XG4gICAgY29uc3QgW2RhdGFNaW4sIGRhdGFNYXhdID0gZGF0YURvbWFpbjtcbiAgICBsZXQgbWluID0gZGF0YU1pbjtcblxuICAgIGlmIChpc0RlZmluZWQoYm91bmRNaW4pKSB7XG4gICAgICBtaW4gPSBib3VuZE1pbi52YWx1ZU9mKCkgPiBkYXRhTWluLnZhbHVlT2YoKSA/IGJvdW5kTWluIDogZGF0YU1pbjtcbiAgICB9XG5cbiAgICBsZXQgbWF4ID0gZGF0YU1heDtcblxuICAgIGlmIChpc0RlZmluZWQoYm91bmRNYXgpKSB7XG4gICAgICBtYXggPSBib3VuZE1heC52YWx1ZU9mKCkgPCBkYXRhTWF4LnZhbHVlT2YoKSA/IGJvdW5kTWF4IDogZGF0YU1heDtcbiAgICB9XG5cbiAgICByZXR1cm4gW21pbiwgbWF4XTtcbiAgfVxuXG4gIHJldHVybiBkYXRhRG9tYWluO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlbW92ZVVuZGVmaW5lZEFuZE51bGwoYXJyYXkpIHtcbiAgcmV0dXJuIGFycmF5LmZpbHRlcih4ID0+IHR5cGVvZiB4ICE9PSAndW5kZWZpbmVkJyAmJiB4ICE9PSBudWxsKTtcbn0iLCJpbXBvcnQgeyBpc0RhdGVUaW1lIH0gZnJvbSAnLi4vdHlwZUd1YXJkcy9EYXRlVGltZSc7XG5pbXBvcnQgcGFyc2VEYXRlVGltZSBmcm9tICcuL3BhcnNlRGF0ZVRpbWUnO1xuLyoqXG4gKiBPbmx5IHBhcnNlIGVsZW1lbnRzIHRoYXQgYXJlIERhdGVUaW1lIHRvIERhdGUuXG4gKiBMZWF2ZSB0aGUgcmVzdCBhbG9uZS5cbiAqIEBwYXJhbSBhcnJheVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHBhcnNlRGF0ZVRpbWVJbihhcnJheSkge1xuICByZXR1cm4gYXJyYXkubWFwKGQgPT4gIShkIGluc3RhbmNlb2YgRGF0ZSkgJiYgaXNEYXRlVGltZShkKSA/IHBhcnNlRGF0ZVRpbWUoZCkgOiBkKTtcbn0iLCJpbXBvcnQgeyBpc0NvbnRpbnVvdXNTY2FsZSwgaXNEaXNjcmV0aXppbmdTY2FsZSwgaXNEaXNjcmV0ZVNjYWxlIH0gZnJvbSAnLi4vLi4vdHlwZUd1YXJkcy9TY2FsZSc7XG5pbXBvcnQgeyBpc0NvbnRpbnVvdXNTY2FsZUNvbmZpZywgaXNEaXNjcmV0aXppbmdTY2FsZUNvbmZpZywgaXNEaXNjcmV0ZVNjYWxlQ29uZmlnIH0gZnJvbSAnLi4vLi4vdHlwZUd1YXJkcy9TY2FsZUNvbmZpZyc7XG5pbXBvcnQgcGFyc2VDb250aW51b3VzRG9tYWluIGZyb20gJy4uL2RvbWFpbi9wYXJzZUNvbnRpbnVvdXNEb21haW4nO1xuaW1wb3J0IHBhcnNlRGlzY3JldGVEb21haW4gZnJvbSAnLi4vZG9tYWluL3BhcnNlRGlzY3JldGVEb21haW4nO1xuaW1wb3J0IGNvbWJpbmVDYXRlZ29yaWVzIGZyb20gJy4uLy4uL3V0aWxzL2NvbWJpbmVDYXRlZ29yaWVzJztcbmltcG9ydCBjb21iaW5lQ29udGludW91c0RvbWFpbnMgZnJvbSAnLi4vLi4vdXRpbHMvY29tYmluZUNvbnRpbnVvdXNEb21haW5zJztcbmltcG9ydCByZW1vdmVVbmRlZmluZWRBbmROdWxsIGZyb20gJy4uLy4uL3V0aWxzL3JlbW92ZVVuZGVmaW5lZEFuZE51bGwnO1xuaW1wb3J0IHBhcnNlRGF0ZVRpbWVJbiBmcm9tICcuLi9wYXJzZURhdGVUaW1lSW4nO1xuXG5mdW5jdGlvbiBjcmVhdGVPcmRlckZ1bmN0aW9uKHJldmVyc2UpIHtcbiAgcmV0dXJuIHJldmVyc2UgPyBhcnJheSA9PiBhcnJheS5jb25jYXQoKS5yZXZlcnNlKCkgOiBhcnJheSA9PiBhcnJheTtcbn1cblxuZnVuY3Rpb24gaXNDb21wbGV0ZURvbWFpbihkb21haW4pIHtcbiAgcmV0dXJuIGRvbWFpbi5sZW5ndGggIT09IDIgfHwgZG9tYWluWzBdICE9IG51bGwgJiYgZG9tYWluWzFdICE9IG51bGw7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFwcGx5RG9tYWluKGNvbmZpZywgc2NhbGUsXG4vKiogZG9tYWluIGZyb20gZGF0YXNldCAqL1xuZGF0YURvbWFpbikge1xuICBjb25zdCB7XG4gICAgcmV2ZXJzZSxcbiAgICB0eXBlXG4gIH0gPSBjb25maWc7XG4gIGNvbnN0IG9yZGVyID0gY3JlYXRlT3JkZXJGdW5jdGlvbihyZXZlcnNlKTtcblxuICBpZiAoaXNDb250aW51b3VzU2NhbGUoc2NhbGUsIHR5cGUpICYmIGlzQ29udGludW91c1NjYWxlQ29uZmlnKGNvbmZpZykgfHwgaXNEaXNjcmV0aXppbmdTY2FsZShzY2FsZSwgdHlwZSkgJiYgaXNEaXNjcmV0aXppbmdTY2FsZUNvbmZpZyhjb25maWcpKSB7XG4gICAgLy8gRm9yIGNvbnRpbnVvdXMgYW5kIGRpc2NyZXRpemluZyBzY2FsZXNcbiAgICBpZiAoY29uZmlnLmRvbWFpbikge1xuICAgICAgLy8gSWYgY29uZmlnLmRvbWFpbiBpcyBzcGVjaWZpZWRcbiAgICAgIGlmIChpc0NvbXBsZXRlRG9tYWluKGNvbmZpZy5kb21haW4pKSB7XG4gICAgICAgIC8vIElmIHRoZSBjb25maWcuZG9tYWluIGlzIGNvbXBsZXRlZFxuICAgICAgICAvLyBpZ25vcmVzIHRoZSBkYXRhRG9tYWluXG4gICAgICAgIHNjYWxlLmRvbWFpbihvcmRlcihwYXJzZURhdGVUaW1lSW4oY29uZmlnLmRvbWFpbikpKTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YURvbWFpbikge1xuICAgICAgICAvLyBJZiBpdCBpcyBpbmNvbXBsZXRlZCwgdGhlbiB0cnkgdG8gY29tYmluZVxuICAgICAgICAvLyB3aXRoIHRoZSBkYXRhRG9tYWluXG4gICAgICAgIHNjYWxlLmRvbWFpbihvcmRlcihjb21iaW5lQ29udGludW91c0RvbWFpbnMocGFyc2VDb250aW51b3VzRG9tYWluKHBhcnNlRGF0ZVRpbWVJbihjb25maWcuZG9tYWluKSwgdHlwZSksIHBhcnNlQ29udGludW91c0RvbWFpbihyZW1vdmVVbmRlZmluZWRBbmROdWxsKGRhdGFEb21haW4pLCB0eXBlKSkpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRhdGFEb21haW4pIHtcbiAgICAgIC8vIElmIG5vIGNvbmZpZy5kb21haW4gdGhlbiBqdXN0IHVzZSB0aGUgZGF0YURvbWFpbiBpZiBhbnlcbiAgICAgIHNjYWxlLmRvbWFpbihvcmRlcihwYXJzZUNvbnRpbnVvdXNEb21haW4ocmVtb3ZlVW5kZWZpbmVkQW5kTnVsbChkYXRhRG9tYWluKSwgdHlwZSkpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNEaXNjcmV0ZVNjYWxlKHNjYWxlLCB0eXBlKSAmJiBpc0Rpc2NyZXRlU2NhbGVDb25maWcoY29uZmlnKSkge1xuICAgIC8vIEZvciBkaXNjcmV0ZSBzY2FsZXNcbiAgICBpZiAoY29uZmlnLmRvbWFpbikge1xuICAgICAgY29uc3QgZml4ZWREb21haW4gPSBwYXJzZURpc2NyZXRlRG9tYWluKHBhcnNlRGF0ZVRpbWVJbihjb25maWcuZG9tYWluKSk7XG4gICAgICBzY2FsZS5kb21haW4ob3JkZXIoZGF0YURvbWFpbiA/IGNvbWJpbmVDYXRlZ29yaWVzKGZpeGVkRG9tYWluLCBwYXJzZURpc2NyZXRlRG9tYWluKGRhdGFEb21haW4pKSA6IGZpeGVkRG9tYWluKSk7XG4gICAgfSBlbHNlIGlmIChkYXRhRG9tYWluKSB7XG4gICAgICAvLyBJZiBubyBjb25maWcuZG9tYWluIHRoZW4ganVzdCB1c2UgdGhlIGRhdGFEb21haW4gaWYgYW55XG4gICAgICBzY2FsZS5kb21haW4ob3JkZXIocGFyc2VEaXNjcmV0ZURvbWFpbihkYXRhRG9tYWluKSkpO1xuICAgIH1cbiAgfVxufSIsIi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvcHJlZmVyLWRlZmF1bHQtZXhwb3J0XG5leHBvcnQgZnVuY3Rpb24gaXNTY2hlbWVQYXJhbXMoc2NoZW1lKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc2NoZW1lKSAhPT0gJ1tvYmplY3QgU3RyaW5nXSc7XG59IiwiaW1wb3J0IHsgd3JhcENvbG9yU2NoZW1lIH0gZnJvbSAnQGVuY29kYWJsZS9jb2xvcic7XG5pbXBvcnQgRW5jb2RhYmxlIGZyb20gJy4uLy4uL29wdGlvbnMvRW5jb2RhYmxlJztcbmltcG9ydCB7IGlzQ29udGludW91c1NjYWxlQ29uZmlnIH0gZnJvbSAnLi4vLi4vdHlwZUd1YXJkcy9TY2FsZUNvbmZpZyc7XG5pbXBvcnQgeyBpc1NjaGVtZVBhcmFtcyB9IGZyb20gJy4uLy4uL3R5cGVHdWFyZHMvU2NoZW1lUGFyYW1zJztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFwcGx5UmFuZ2UoY29uZmlnLCBzY2FsZSkge1xuICBjb25zdCB7XG4gICAgcmFuZ2UsXG4gICAgZG9tYWluXG4gIH0gPSBjb25maWc7XG5cbiAgaWYgKHR5cGVvZiByYW5nZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoJ3NjaGVtZScgaW4gY29uZmlnICYmIHR5cGVvZiBjb25maWcuc2NoZW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzY2hlbWVcbiAgICAgIH0gPSBjb25maWc7XG4gICAgICBsZXQgbmFtZTtcbiAgICAgIGxldCBjb3VudDtcblxuICAgICAgaWYgKGlzQ29udGludW91c1NjYWxlQ29uZmlnKGNvbmZpZykgJiYgZG9tYWluKSB7XG4gICAgICAgIGNvdW50ID0gZG9tYWluLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgbGV0IGV4dGVudDtcblxuICAgICAgaWYgKGlzU2NoZW1lUGFyYW1zKHNjaGVtZSkpIHtcbiAgICAgICAgbmFtZSA9IHNjaGVtZS5uYW1lO1xuXG4gICAgICAgIGlmIChzY2hlbWUuY291bnQpIHtcbiAgICAgICAgICBjb3VudCA9IHNjaGVtZS5jb3VudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGV4dGVudCA9IHNjaGVtZS5leHRlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuYW1lID0gc2NoZW1lO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzY2hlbWVPYmplY3QgPSBFbmNvZGFibGUucmVzb2x2ZUNvbG9yU2NoZW1lKHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgdHlwZTogJ3NlcXVlbnRpYWwnXG4gICAgICB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBzY2hlbWVPYmplY3QgIT09ICd1bmRlZmluZWQnICYmIHNjaGVtZU9iamVjdC50eXBlID09PSAnc2VxdWVudGlhbCcpIHtcbiAgICAgICAgY29uc3Qgd3JhcHBlZFNjaGVtZSA9IHdyYXBDb2xvclNjaGVtZShzY2hlbWVPYmplY3QpO1xuICAgICAgICBzY2FsZS5yYW5nZSh3cmFwcGVkU2NoZW1lLmdldENvbG9ycyhjb3VudCwgZXh0ZW50KSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFRPRE86IGFkZCB0eXBlIGd1YXJkIHNob3VsZCBmaXggdGhpcyBwcm9ibGVtXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHNjYWxlLnJhbmdlKHJhbmdlKTtcbiAgfVxufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFwcGx5UGFkZGluZyhjb25maWcsIHNjYWxlKSB7XG4gIGlmICgncGFkZGluZycgaW4gY29uZmlnICYmIHR5cGVvZiBjb25maWcucGFkZGluZyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ3BhZGRpbmcnIGluIHNjYWxlKSB7XG4gICAgc2NhbGUucGFkZGluZyhjb25maWcucGFkZGluZyk7XG4gIH1cblxuICBpZiAoJ3BhZGRpbmdJbm5lcicgaW4gY29uZmlnICYmIHR5cGVvZiBjb25maWcucGFkZGluZ0lubmVyICE9PSAndW5kZWZpbmVkJyAmJiAncGFkZGluZ0lubmVyJyBpbiBzY2FsZSkge1xuICAgIHNjYWxlLnBhZGRpbmdJbm5lcihjb25maWcucGFkZGluZ0lubmVyKTtcbiAgfVxuXG4gIGlmICgncGFkZGluZ091dGVyJyBpbiBjb25maWcgJiYgdHlwZW9mIGNvbmZpZy5wYWRkaW5nT3V0ZXIgIT09ICd1bmRlZmluZWQnICYmICdwYWRkaW5nT3V0ZXInIGluIHNjYWxlKSB7XG4gICAgc2NhbGUucGFkZGluZ091dGVyKGNvbmZpZy5wYWRkaW5nT3V0ZXIpO1xuICB9XG59IiwiaW1wb3J0IGFwcGx5QWxpZ24gZnJvbSAnLi9hcHBseUFsaWduJztcbmltcG9ydCBhcHBseUJhc2UgZnJvbSAnLi9hcHBseUJhc2UnO1xuaW1wb3J0IGFwcGx5Q2xhbXAgZnJvbSAnLi9hcHBseUNsYW1wJztcbmltcG9ydCBhcHBseUV4cG9uZW50IGZyb20gJy4vYXBwbHlFeHBvbmVudCc7XG5pbXBvcnQgYXBwbHlOaWNlIGZyb20gJy4vYXBwbHlOaWNlJztcbmltcG9ydCBhcHBseVplcm8gZnJvbSAnLi9hcHBseVplcm8nO1xuaW1wb3J0IGFwcGx5SW50ZXJwb2xhdGUgZnJvbSAnLi9hcHBseUludGVycG9sYXRlJztcbmltcG9ydCBhcHBseVJvdW5kIGZyb20gJy4vYXBwbHlSb3VuZCc7XG5pbXBvcnQgYXBwbHlEb21haW4gZnJvbSAnLi9hcHBseURvbWFpbic7XG5pbXBvcnQgYXBwbHlSYW5nZSBmcm9tICcuL2FwcGx5UmFuZ2UnO1xuaW1wb3J0IGFwcGx5UGFkZGluZyBmcm9tICcuL2FwcGx5UGFkZGluZyc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1cGRhdGVTY2FsZShzY2FsZSwgY29uZmlnKSB7XG4gIC8vIGRvbWFpbiBhbmQgcmFuZ2UgYXBwbHkgdG8gYWxsIHNjYWxlc1xuICBhcHBseURvbWFpbihjb25maWcsIHNjYWxlKTtcbiAgYXBwbHlSYW5nZShjb25maWcsIHNjYWxlKTsgLy8gU29ydCBvdGhlciBwcm9wZXJ0aWVzIGFscGhhYmV0aWNhbGx5LlxuXG4gIGFwcGx5QWxpZ24oY29uZmlnLCBzY2FsZSk7XG4gIGFwcGx5QmFzZShjb25maWcsIHNjYWxlKTtcbiAgYXBwbHlDbGFtcChjb25maWcsIHNjYWxlKTtcbiAgYXBwbHlFeHBvbmVudChjb25maWcsIHNjYWxlKTtcbiAgYXBwbHlJbnRlcnBvbGF0ZShjb25maWcsIHNjYWxlKTsgLy8gTmljZSBkZXBlbmRzIG9uIGRvbWFpbi5cblxuICBhcHBseU5pY2UoY29uZmlnLCBzY2FsZSk7XG4gIGFwcGx5UGFkZGluZyhjb25maWcsIHNjYWxlKTtcbiAgYXBwbHlSb3VuZChjb25maWcsIHNjYWxlKTsgLy8gWmVybyBkZXBlbmRzIG9uIGRvbWFpbiBhbmQgbmljZS5cblxuICBhcHBseVplcm8oY29uZmlnLCBzY2FsZSk7XG4gIHJldHVybiBzY2FsZTtcbn0iLCJpbXBvcnQgeyBTY2FsZVR5cGUgfSBmcm9tICcuLi8uLi90eXBlcyc7XG5pbXBvcnQgY3JlYXRlU2NhbGVGcm9tU2NhbGVUeXBlIGZyb20gJy4vY3JlYXRlU2NhbGVGcm9tU2NhbGVUeXBlJztcbmltcG9ydCB1cGRhdGVTY2FsZSBmcm9tICcuL3VwZGF0ZVNjYWxlJztcbmltcG9ydCBFbmNvZGFibGUgZnJvbSAnLi4vLi4vb3B0aW9ucy9FbmNvZGFibGUnO1xuaW1wb3J0IHsgaXNTY2hlbWVQYXJhbXMgfSBmcm9tICcuLi8uLi90eXBlR3VhcmRzL1NjaGVtZVBhcmFtcyc7XG5pbXBvcnQgYXBwbHlEb21haW4gZnJvbSAnLi9hcHBseURvbWFpbic7XG5cbmZ1bmN0aW9uIGNyZWF0ZVNjYWxlKGNvbmZpZykge1xuICBjb25zdCB7XG4gICAgcmFuZ2VcbiAgfSA9IGNvbmZpZzsgLy8gSGFuZGxlIGNhdGVnb3JpY2FsIGNvbG9yIHNjYWxlc1xuICAvLyBBbiBvcmRpbmFsIHNjYWxlIHdpdGhvdXQgc3BlY2lmaWVkIHJhbmdlXG4gIC8vIGlzIGFzc3VtZWQgdG8gYmUgYSBjb2xvciBzY2FsZS5cblxuICBpZiAoY29uZmlnLnR5cGUgPT09IFNjYWxlVHlwZS5PUkRJTkFMICYmIHR5cGVvZiByYW5nZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zdCBzY2hlbWUgPSAnc2NoZW1lJyBpbiBjb25maWcgPyBjb25maWcuc2NoZW1lIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHJlc29sdmUgPSBFbmNvZGFibGUuZ2V0Q2F0ZWdvcmljYWxDb2xvclNjYWxlUmVzb2x2ZXIoKTtcbiAgICBsZXQgY29sb3JTY2FsZTtcblxuICAgIGlmICh0eXBlb2Ygc2NoZW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgY29sb3JTY2FsZSA9IHJlc29sdmUoe30pO1xuICAgIH0gZWxzZSBpZiAoaXNTY2hlbWVQYXJhbXMoc2NoZW1lKSkge1xuICAgICAgY29sb3JTY2FsZSA9IHJlc29sdmUoc2NoZW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29sb3JTY2FsZSA9IHJlc29sdmUoe1xuICAgICAgICBuYW1lOiBzY2hlbWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGNhc3RlZENvbG9yU2NhbGUgPSBjb2xvclNjYWxlO1xuICAgIGFwcGx5RG9tYWluKGNvbmZpZywgY2FzdGVkQ29sb3JTY2FsZSk7XG4gICAgcmV0dXJuIGNhc3RlZENvbG9yU2NhbGU7XG4gIH1cblxuICBjb25zdCBzY2FsZSA9IGNyZWF0ZVNjYWxlRnJvbVNjYWxlVHlwZShjb25maWcudHlwZSk7XG4gIHJldHVybiB1cGRhdGVTY2FsZShzY2FsZSwgY29uZmlnKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlU2NhbGU7IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaWRlbnRpdHkoeCkge1xuICByZXR1cm4geDtcbn0iLCJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5pbXBvcnQgeyBleHRlbnQgYXMgZDNFeHRlbnQgfSBmcm9tICdkMy1hcnJheSc7XG5pbXBvcnQgeyBTY2FsZVR5cGUgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBpc1R5cGVkRmllbGREZWYsIGlzVmFsdWVEZWYsIGlzRmllbGREZWYgfSBmcm9tICcuLi90eXBlR3VhcmRzL0NoYW5uZWxEZWYnO1xuaW1wb3J0IHsgaXNYLCBpc1ksIGlzWE9yWSB9IGZyb20gJy4uL3R5cGVHdWFyZHMvQ2hhbm5lbCc7XG5pbXBvcnQgQ2hhbm5lbEVuY29kZXJBeGlzIGZyb20gJy4vQ2hhbm5lbEVuY29kZXJBeGlzJztcbmltcG9ydCBjcmVhdGVHZXR0ZXJGcm9tQ2hhbm5lbERlZiBmcm9tICcuLi9wYXJzZXJzL2NyZWF0ZUdldHRlckZyb21DaGFubmVsRGVmJztcbmltcG9ydCBjb21wbGV0ZUNoYW5uZWxEZWYgZnJvbSAnLi4vZmlsbGVycy9jb21wbGV0ZUNoYW5uZWxEZWYnO1xuaW1wb3J0IGNyZWF0ZVNjYWxlIGZyb20gJy4uL3BhcnNlcnMvc2NhbGUvY3JlYXRlU2NhbGUnO1xuaW1wb3J0IGlkZW50aXR5IGZyb20gJy4uL3V0aWxzL2lkZW50aXR5JztcbmltcG9ydCBhcHBseURvbWFpbiBmcm9tICcuLi9wYXJzZXJzL3NjYWxlL2FwcGx5RG9tYWluJztcbmltcG9ydCBhcHBseVJhbmdlIGZyb20gJy4uL3BhcnNlcnMvc2NhbGUvYXBwbHlSYW5nZSc7XG5pbXBvcnQgYXBwbHlaZXJvIGZyb20gJy4uL3BhcnNlcnMvc2NhbGUvYXBwbHlaZXJvJztcbmltcG9ydCBhcHBseU5pY2UgZnJvbSAnLi4vcGFyc2Vycy9zY2FsZS9hcHBseU5pY2UnO1xuaW1wb3J0IHsgaXNDb21wbGV0ZVZhbHVlRGVmLCBpc0NvbXBsZXRlRmllbGREZWYgfSBmcm9tICcuLi90eXBlR3VhcmRzL0NvbXBsZXRlQ2hhbm5lbERlZic7XG5pbXBvcnQgZmFsbGJhY2tGb3JtYXR0ZXIgZnJvbSAnLi4vcGFyc2Vycy9mb3JtYXQvZmFsbGJhY2tGb3JtYXR0ZXInO1xuaW1wb3J0IGNyZWF0ZUZvcm1hdHRlciBmcm9tICcuLi9wYXJzZXJzL2Zvcm1hdC9jcmVhdGVGb3JtYXR0ZXInO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2hhbm5lbEVuY29kZXIge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbmFtZSxcbiAgICBjaGFubmVsVHlwZSxcbiAgICBkZWZpbml0aW9uOiBvcmlnaW5hbERlZmluaXRpb25cbiAgfSkge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNoYW5uZWxUeXBlXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvcmlnaW5hbERlZmluaXRpb25cIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRlZmluaXRpb25cIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNjYWxlXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJheGlzXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJnZXRWYWx1ZVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZW5jb2RlRnVuY1wiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZm9ybWF0VmFsdWVcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVuY29kZVZhbHVlXCIsICh2YWx1ZSwgb3RoZXJ3aXNlKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIG90aGVyd2lzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgKHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgICAgIHJldHVybiBvdGhlcndpc2U7XG4gICAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cblxuICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlRnVuYyh2YWx1ZSk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJlbmNvZGVEYXR1bVwiLCAoZGF0dW0sIG90aGVyd2lzZSkgPT4gdHlwZW9mIG90aGVyd2lzZSA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLmVuY29kZVZhbHVlKHRoaXMuZ2V0VmFsdWVGcm9tRGF0dW0oZGF0dW0pKSA6IHRoaXMuZW5jb2RlVmFsdWUodGhpcy5nZXRWYWx1ZUZyb21EYXR1bShkYXR1bSksIG90aGVyd2lzZSkpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZm9ybWF0RGF0dW1cIiwgZGF0dW0gPT4gdGhpcy5mb3JtYXRWYWx1ZSh0aGlzLmdldFZhbHVlRnJvbURhdHVtKGRhdHVtKSkpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2V0VmFsdWVGcm9tRGF0dW1cIiwgKGRhdHVtLCBvdGhlcndpc2UpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXRWYWx1ZShkYXR1bSk7XG4gICAgICByZXR1cm4gb3RoZXJ3aXNlICE9PSB1bmRlZmluZWQgJiYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpID8gb3RoZXJ3aXNlIDogdmFsdWU7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJnZXREb21haW5Gcm9tRGF0YXNldFwiLCBkYXRhID0+IHtcbiAgICAgIGlmIChpc1ZhbHVlRGVmKHRoaXMuZGVmaW5pdGlvbikpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0gPSB0aGlzLmRlZmluaXRpb247XG4gICAgICAgIHJldHVybiBbdmFsdWVdO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7XG4gICAgICAgIHR5cGVcbiAgICAgIH0gPSB0aGlzLmRlZmluaXRpb247XG5cbiAgICAgIGlmICh0eXBlID09PSAnbm9taW5hbCcgfHwgdHlwZSA9PT0gJ29yZGluYWwnKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQoZGF0YS5tYXAoZCA9PiB0aGlzLmdldFZhbHVlRnJvbURhdHVtKGQpKSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZSA9PT0gJ3F1YW50aXRhdGl2ZScpIHtcbiAgICAgICAgLy8gUXVhbnRpbGUgc2NhbGUgbmVlZHMgYWxsIGl0ZW1zXG4gICAgICAgIC8vIGJlY2F1c2UgaXQgdHJlYXRzIGRvbWFpbiBhcyBhIGRpc2NyZXRlIHNldCBvZiBzYW1wbGUgdmFsdWVzXG4gICAgICAgIC8vIGZvciBjb21wdXRpbmcgdGhlIHF1YW50aWxlc1xuICAgICAgICBpZiAodGhpcy5kZWZpbml0aW9uLnNjYWxlICYmIHRoaXMuZGVmaW5pdGlvbi5zY2FsZS50eXBlID09PSAncXVhbnRpbGUnKSB7XG4gICAgICAgICAgcmV0dXJuIGRhdGEubWFwKGQgPT4gdGhpcy5nZXRWYWx1ZUZyb21EYXR1bShkKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBleHRlbnQgPSBkM0V4dGVudChkYXRhLCBkID0+IHRoaXMuZ2V0VmFsdWVGcm9tRGF0dW0oZCkpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIGV4dGVudFswXSA9PT0gJ3VuZGVmaW5lZCcgPyBbMCwgMV0gOiBleHRlbnQ7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlID09PSAndGVtcG9yYWwnKSB7XG4gICAgICAgIGNvbnN0IGV4dGVudCA9IGQzRXh0ZW50KGRhdGEsIGQgPT4gdGhpcy5nZXRWYWx1ZUZyb21EYXR1bShkKSk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZXh0ZW50WzBdID09PSAndW5kZWZpbmVkJyA/IFswLCAxXSA6IGV4dGVudDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtdO1xuICAgIH0pO1xuXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmNoYW5uZWxUeXBlID0gY2hhbm5lbFR5cGU7XG4gICAgdGhpcy5vcmlnaW5hbERlZmluaXRpb24gPSBvcmlnaW5hbERlZmluaXRpb247XG4gICAgdGhpcy5kZWZpbml0aW9uID0gY29tcGxldGVDaGFubmVsRGVmKHRoaXMuY2hhbm5lbFR5cGUsIG9yaWdpbmFsRGVmaW5pdGlvbik7XG4gICAgdGhpcy5nZXRWYWx1ZSA9IGNyZWF0ZUdldHRlckZyb21DaGFubmVsRGVmKHRoaXMuZGVmaW5pdGlvbik7XG4gICAgdGhpcy5mb3JtYXRWYWx1ZSA9IGlzRmllbGREZWYodGhpcy5kZWZpbml0aW9uKSA/IGNyZWF0ZUZvcm1hdHRlcih0aGlzLmRlZmluaXRpb24pIDogZmFsbGJhY2tGb3JtYXR0ZXI7XG5cbiAgICBpZiAodGhpcy5kZWZpbml0aW9uLnNjYWxlKSB7XG4gICAgICBjb25zdCBzY2FsZSA9IGNyZWF0ZVNjYWxlKHRoaXMuZGVmaW5pdGlvbi5zY2FsZSk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cbiAgICAgIHRoaXMuZW5jb2RlRnVuYyA9IHZhbHVlID0+IHNjYWxlKHZhbHVlKTtcblxuICAgICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRlZmluaXRpb25cbiAgICAgIH0gPSB0aGlzO1xuICAgICAgdGhpcy5lbmNvZGVGdW5jID0gaXNDb21wbGV0ZVZhbHVlRGVmKGRlZmluaXRpb24pID8gKCkgPT4gZGVmaW5pdGlvbi52YWx1ZSA6IGlkZW50aXR5O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmRlZmluaXRpb24uYXhpcykge1xuICAgICAgdGhpcy5heGlzID0gbmV3IENoYW5uZWxFbmNvZGVyQXhpcyh0aGlzKTtcbiAgICB9XG4gIH1cblxuICBnZXREb21haW4oKSB7XG4gICAgaWYgKHRoaXMuc2NhbGUgJiYgJ2RvbWFpbicgaW4gdGhpcy5zY2FsZSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2NhbGUuZG9tYWluKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgc2V0RG9tYWluKGRvbWFpbikge1xuICAgIGlmICh0aGlzLmRlZmluaXRpb24uc2NhbGUgIT09IGZhbHNlICYmIHRoaXMuc2NhbGUgJiYgIXRoaXMuaGFzQ2F0ZWdvcmljYWxDb2xvclNjYWxlKCkgJiYgJ2RvbWFpbicgaW4gdGhpcy5zY2FsZSkge1xuICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5kZWZpbml0aW9uLnNjYWxlO1xuICAgICAgYXBwbHlEb21haW4oY29uZmlnLCB0aGlzLnNjYWxlLCBkb21haW4pO1xuICAgICAgYXBwbHlSYW5nZShjb25maWcsIHRoaXMuc2NhbGUpO1xuICAgICAgYXBwbHlaZXJvKGNvbmZpZywgdGhpcy5zY2FsZSk7XG4gICAgICBhcHBseU5pY2UoY29uZmlnLCB0aGlzLnNjYWxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldERvbWFpbkZyb21EYXRhc2V0KGRhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5zY2FsZSAmJiAnZG9tYWluJyBpbiB0aGlzLnNjYWxlID8gdGhpcy5zZXREb21haW4odGhpcy5nZXREb21haW5Gcm9tRGF0YXNldChkYXRhKSkgOiB0aGlzO1xuICB9XG5cbiAgZ2V0VGl0bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmaW5pdGlvbi50aXRsZTtcbiAgfVxuXG4gIGlzR3JvdXBCeSgpIHtcbiAgICBpZiAoaXNUeXBlZEZpZWxkRGVmKHRoaXMuZGVmaW5pdGlvbikpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdHlwZVxuICAgICAgfSA9IHRoaXMuZGVmaW5pdGlvbjtcbiAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxUeXBlID09PSAnQ2F0ZWdvcnknIHx8IHRoaXMuY2hhbm5lbFR5cGUgPT09ICdUZXh0JyB8fCB0aGlzLmNoYW5uZWxUeXBlID09PSAnQ29sb3InICYmICh0eXBlID09PSAnbm9taW5hbCcgfHwgdHlwZSA9PT0gJ29yZGluYWwnKSB8fCBpc1hPclkodGhpcy5jaGFubmVsVHlwZSkgJiYgKHR5cGUgPT09ICdub21pbmFsJyB8fCB0eXBlID09PSAnb3JkaW5hbCcpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlzWCgpIHtcbiAgICByZXR1cm4gaXNYKHRoaXMuY2hhbm5lbFR5cGUpO1xuICB9XG5cbiAgaXNYT3JZKCkge1xuICAgIHJldHVybiBpc1hPclkodGhpcy5jaGFubmVsVHlwZSk7XG4gIH1cblxuICBpc1koKSB7XG4gICAgcmV0dXJuIGlzWSh0aGlzLmNoYW5uZWxUeXBlKTtcbiAgfVxuXG4gIGhhc0NhdGVnb3JpY2FsQ29sb3JTY2FsZSgpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmRlZmluaXRpb24uc2NhbGU7IC8vIFNjYWxlIHR5cGUgaXMgb3JkaW5hbCB3aXRoIG5vdCBnaXZlbiByYW5nZVxuICAgIC8vIChtYXkgaGF2ZSBvcHRpb25hbCBzY2hlbWUpXG4gICAgLy8gd2lsbCBiZWNvbWUgYSBjYXRlZ29yaWNhbCBzY2FsZVxuICAgIC8vIG9mIG5hbWVkIGNvbG9yIHNjaGVtZS5cbiAgICAvLyBBIGNvbG9yIHNjYWxlIGZyb20gbmFtZWQgY29sb3Igc2NoZW1lIG1heSBiZSBzaGFyZWQgYW1vbmcgbXVsdGlwbGUgY29tcG9uZW50c1xuICAgIC8vIGluIHRoZSBzYW1lIG5hbWVzcGFjZSBieSBkZWZhdWx0LCBzbyBjaGFuZ2luZyBpdHMgZG9tYWluIGFmZmVjdCBhbGwgY29tcG9uZW50cy5cbiAgICAvLyAoU291bmRzIGxpa2UgYSBiYWQgaWRlYS4pXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBjdXJyZW50bHkgb25seSBiZWluZyB1c2VkIHRvIGNoZWNrXG4gICAgLy8gd2hldGhlciB0byBhcHBseSBkb21haW4gZnJvbSBkYXRhc2V0IG9yIG5vdC5cbiAgICAvLyBBbiBvcmRpbmFsIHNjYWxlIHdpdGggdXNlci1zcGVjaWZpZWQgY29sb3Igc2NoZW1lIGFzIHJhbmdlIGFycmF5XG4gICAgLy8gd2lsbCByZXR1cm4gZmFsc2UgZnJvbSB0aGlzIGZ1bmN0aW9uIGFuZCBiZSBleGNsdWRlZCBmcm9tIGl0LlxuXG4gICAgcmV0dXJuIHRoaXMuc2NhbGUgJiYgY29uZmlnICYmIGNvbmZpZy50eXBlID09PSBTY2FsZVR5cGUuT1JESU5BTCAmJiB0eXBlb2YgY29uZmlnLnJhbmdlID09PSAndW5kZWZpbmVkJztcbiAgfVxuXG4gIGhhc0xlZ2VuZCgpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZpbml0aW9uLmxlZ2VuZCAhPT0gZmFsc2U7XG4gIH1cblxuICBoYXNWYWx1ZURlZmluaXRpb24oKSB7XG4gICAgcmV0dXJuIGlzQ29tcGxldGVWYWx1ZURlZih0aGlzLmRlZmluaXRpb24pO1xuICB9XG5cbiAgaGFzRmllbGREZWZpbml0aW9uKCkge1xuICAgIHJldHVybiBpc0NvbXBsZXRlRmllbGREZWYodGhpcy5kZWZpbml0aW9uKTtcbiAgfVxuXG59IiwiZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuaW1wb3J0IHsgaXNUeXBlZEZpZWxkRGVmLCBpc1ZhbHVlRGVmIH0gZnJvbSAnLi4vdHlwZUd1YXJkcy9DaGFubmVsRGVmJztcbmltcG9ydCB7IGlzTm90QXJyYXkgfSBmcm9tICcuLi90eXBlR3VhcmRzL0Jhc2UnO1xuaW1wb3J0IENoYW5uZWxFbmNvZGVyIGZyb20gJy4vQ2hhbm5lbEVuY29kZXInO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW5jb2RlciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjaGFubmVsVHlwZXMsXG4gICAgZW5jb2RpbmdcbiAgfSkge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVuY29kaW5nXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjaGFubmVsVHlwZXNcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNoYW5uZWxzXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJsZWdlbmRzXCIsIHZvaWQgMCk7XG5cbiAgICB0aGlzLmNoYW5uZWxUeXBlcyA9IGNoYW5uZWxUeXBlcztcbiAgICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gICAgY29uc3QgY2hhbm5lbE5hbWVzID0gdGhpcy5nZXRDaGFubmVsTmFtZXMoKTsgLy8gQ3JlYXRlIGNoYW5uZWwgZW5jb2RlcnNcblxuICAgIGNvbnN0IGNoYW5uZWxzID0ge307XG4gICAgY2hhbm5lbE5hbWVzLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICBjb25zdCBjaGFubmVsRW5jb2RpbmcgPSBlbmNvZGluZ1tuYW1lXTtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hhbm5lbEVuY29kaW5nKSkge1xuICAgICAgICBjb25zdCBkZWZpbml0aW9ucyA9IGNoYW5uZWxFbmNvZGluZztcbiAgICAgICAgY2hhbm5lbHNbbmFtZV0gPSBkZWZpbml0aW9ucy5tYXAoKGRlZmluaXRpb24sIGkpID0+IG5ldyBDaGFubmVsRW5jb2Rlcih7XG4gICAgICAgICAgY2hhbm5lbFR5cGU6IGNoYW5uZWxUeXBlc1tuYW1lXSxcbiAgICAgICAgICBkZWZpbml0aW9uLFxuICAgICAgICAgIG5hbWU6IG5hbWUgKyBcIltcIiArIGkgKyBcIl1cIlxuICAgICAgICB9KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gY2hhbm5lbEVuY29kaW5nO1xuICAgICAgICBjaGFubmVsc1tuYW1lXSA9IG5ldyBDaGFubmVsRW5jb2Rlcih7XG4gICAgICAgICAgY2hhbm5lbFR5cGU6IGNoYW5uZWxUeXBlc1tuYW1lXSxcbiAgICAgICAgICBkZWZpbml0aW9uLFxuICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5jaGFubmVscyA9IGNoYW5uZWxzOyAvLyBHcm91cCB0aGUgY2hhbm5lbHMgdGhhdCB1c2UgdGhlIHNhbWUgZmllbGQgdG9nZXRoZXJcbiAgICAvLyBzbyB0aGV5IGNhbiBzaGFyZSB0aGUgc2FtZSBsZWdlbmQuXG5cbiAgICB0aGlzLmxlZ2VuZHMgPSB7fTtcbiAgICBjaGFubmVsTmFtZXMubWFwKG5hbWUgPT4gdGhpcy5jaGFubmVsc1tuYW1lXSkuZm9yRWFjaChjID0+IHtcbiAgICAgIGlmIChpc05vdEFycmF5KGMpICYmIGMuaGFzTGVnZW5kKCkgJiYgaXNUeXBlZEZpZWxkRGVmKGMuZGVmaW5pdGlvbikpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGZpZWxkXG4gICAgICAgIH0gPSBjLmRlZmluaXRpb247XG4gICAgICAgIGNvbnN0IGNoYW5uZWxFbmNvZGVyID0gYztcblxuICAgICAgICBpZiAodGhpcy5sZWdlbmRzW2ZpZWxkXSkge1xuICAgICAgICAgIHRoaXMubGVnZW5kc1tmaWVsZF0ucHVzaChjaGFubmVsRW5jb2Rlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5sZWdlbmRzW2ZpZWxkXSA9IFtjaGFubmVsRW5jb2Rlcl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGdldENoYW5uZWxOYW1lcygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5jaGFubmVsVHlwZXMpO1xuICB9XG5cbiAgZ2V0Q2hhbm5lbEVuY29kZXJzKCkge1xuICAgIHJldHVybiB0aGlzLmdldENoYW5uZWxOYW1lcygpLmZsYXRNYXAobmFtZSA9PiB0aGlzLmNoYW5uZWxzW25hbWVdKTtcbiAgfVxuXG4gIGdldEdyb3VwQnlzKCkge1xuICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMuZ2V0Q2hhbm5lbEVuY29kZXJzKCkuZmlsdGVyKGMgPT4gYy5pc0dyb3VwQnkoKSkubWFwKGMgPT4gYy5kZWZpbml0aW9uLmZpZWxkKTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KGZpZWxkcykpO1xuICB9XG5cbiAgY3JlYXRlTGVnZW5kSXRlbXNGYWN0b3J5KGZpZWxkKSB7XG4gICAgY29uc3QgY2hhbm5lbEVuY29kZXJzID0gdGhpcy5nZXRDaGFubmVsRW5jb2RlcnMoKS5maWx0ZXIoZSA9PiBpc05vdEFycmF5KGUpICYmIGlzVmFsdWVEZWYoZS5kZWZpbml0aW9uKSkuZmxhdCgpLmNvbmNhdCh0aGlzLmxlZ2VuZHNbZmllbGRdKTtcbiAgICByZXR1cm4gZG9tYWluID0+IGRvbWFpbi5tYXAoaW5wdXQgPT4gKHtcbiAgICAgIGlucHV0LFxuICAgICAgb3V0cHV0OiBjaGFubmVsRW5jb2RlcnMucmVkdWNlKChwcmV2LCBjdXJyKSA9PiB7XG4gICAgICAgIGNvbnN0IG1hcCA9IHByZXY7XG4gICAgICAgIG1hcFtjdXJyLm5hbWVdID0gY3Vyci5lbmNvZGVWYWx1ZShpbnB1dCk7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgICB9LCB7fSlcbiAgICB9KSk7XG4gIH1cblxuICBnZXRMZWdlbmRJbmZvcm1hdGlvbihkYXRhID0gW10pIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5sZWdlbmRzKSAvLyBmb3IgZWFjaCBmaWVsZCB0aGF0IHdhcyBlbmNvZGVkXG4gICAgLm1hcChmaWVsZCA9PiB7XG4gICAgICAvLyBnZXQgYWxsIHRoZSBjaGFubmVscyB0aGF0IHVzZSB0aGlzIGZpZWxkXG4gICAgICBjb25zdCBjaGFubmVsRW5jb2RlcnMgPSB0aGlzLmxlZ2VuZHNbZmllbGRdO1xuICAgICAgY29uc3QgZmlyc3RFbmNvZGVyID0gY2hhbm5lbEVuY29kZXJzWzBdO1xuICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IGZpcnN0RW5jb2Rlci5kZWZpbml0aW9uO1xuICAgICAgY29uc3QgY3JlYXRlTGVnZW5kSXRlbXMgPSB0aGlzLmNyZWF0ZUxlZ2VuZEl0ZW1zRmFjdG9yeShmaWVsZCk7XG5cbiAgICAgIGlmIChkZWZpbml0aW9uLnR5cGUgPT09ICdub21pbmFsJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNoYW5uZWxFbmNvZGVycyxcbiAgICAgICAgICBjcmVhdGVMZWdlbmRJdGVtcyxcbiAgICAgICAgICBmaWVsZCxcbiAgICAgICAgICBpdGVtczogY3JlYXRlTGVnZW5kSXRlbXMoZmlyc3RFbmNvZGVyLmdldERvbWFpbkZyb21EYXRhc2V0KGRhdGEpKSxcbiAgICAgICAgICB0eXBlOiBkZWZpbml0aW9uLnR5cGVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2hhbm5lbEVuY29kZXJzLFxuICAgICAgICBjcmVhdGVMZWdlbmRJdGVtcyxcbiAgICAgICAgZmllbGQsXG4gICAgICAgIHR5cGU6IGRlZmluaXRpb24udHlwZVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHNldERvbWFpbkZyb21EYXRhc2V0KGRhdGEpIHtcbiAgICB0aGlzLmdldENoYW5uZWxFbmNvZGVycygpLmZvckVhY2goY2hhbm5lbEVuY29kZXIgPT4ge1xuICAgICAgY2hhbm5lbEVuY29kZXIuc2V0RG9tYWluRnJvbURhdGFzZXQoZGF0YSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBoYXNMZWdlbmQoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMubGVnZW5kcykubGVuZ3RoID4gMDtcbiAgfVxuXG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWVyZ2VFbmNvZGluZyhkZWZhdWx0RW5jb2RpbmcsIGVuY29kaW5nKSB7XG4gIHJldHVybiB7IC4uLmRlZmF1bHRFbmNvZGluZyxcbiAgICAuLi5lbmNvZGluZ1xuICB9O1xufSIsImltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yIH0gZnJvbSAncmVzZWxlY3QnO1xuaW1wb3J0IEVuY29kZXIgZnJvbSAnLi9FbmNvZGVyJztcbmltcG9ydCBtZXJnZUVuY29kaW5nIGZyb20gJy4uL3V0aWxzL21lcmdlRW5jb2RpbmcnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlRW5jb2RlckZhY3RvcnkocGFyYW1zKSB7XG4gIGNvbnN0IHtcbiAgICBjaGFubmVsVHlwZXNcbiAgfSA9IHBhcmFtcztcbiAgY29uc3QgY29tcGxldGVFbmNvZGluZyA9ICdkZWZhdWx0RW5jb2RpbmcnIGluIHBhcmFtcyA/IGVuY29kaW5nID0+IG1lcmdlRW5jb2RpbmcocGFyYW1zLmRlZmF1bHRFbmNvZGluZywgZW5jb2RpbmcpIDogcGFyYW1zLmNvbXBsZXRlRW5jb2Rpbmc7XG5cbiAgY29uc3QgY3JlYXRlID0gKGVuY29kaW5nID0ge30pID0+IG5ldyBFbmNvZGVyKHtcbiAgICBjaGFubmVsVHlwZXMsXG4gICAgZW5jb2Rpbmc6IGNvbXBsZXRlRW5jb2RpbmcoZW5jb2RpbmcpXG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgY2hhbm5lbFR5cGVzLFxuICAgIGNyZWF0ZSxcbiAgICBjcmVhdGVTZWxlY3RvcjogKCkgPT4gY3JlYXRlU2VsZWN0b3IoZW5jb2RpbmcgPT4gZW5jb2RpbmcsIGNyZWF0ZSksXG4gICAgREVGQVVMVF9FTkNPRElORzogY29tcGxldGVFbmNvZGluZyh7fSlcbiAgfTtcbn0iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBOzs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2465\n")}}]);