(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{1943:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DEFAULT_MARGIN; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return createMarginSelector; });\n/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(171);\n\nconst DEFAULT_MARGIN = { bottom: 16, left: 16, right: 16, top: 16 };\nfunction createMarginSelector(defaultMargin = DEFAULT_MARGIN) {\n    return Object(reselect__WEBPACK_IMPORTED_MODULE_0__["createSelector"])((margin) => margin.bottom, margin => margin.left, margin => margin.right, margin => margin.top, (bottom = defaultMargin.bottom, left = defaultMargin.left, right = defaultMargin.right, top = defaultMargin.top) => ({\n        bottom,\n        left,\n        right,\n        top,\n    }));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk0My5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wcmVzZXQtY2hhcnQteHkvc3JjL3V0aWxzL2NyZWF0ZU1hcmdpblNlbGVjdG9yLnRzeD83NTU1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yIH0gZnJvbSAncmVzZWxlY3QnO1xuaW1wb3J0IHsgTWFyZ2luIH0gZnJvbSAnQHN1cGVyc2V0LXVpL2NvcmUnO1xuXG5leHBvcnQgY29uc3QgREVGQVVMVF9NQVJHSU4gPSB7IGJvdHRvbTogMTYsIGxlZnQ6IDE2LCByaWdodDogMTYsIHRvcDogMTYgfTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlTWFyZ2luU2VsZWN0b3IoZGVmYXVsdE1hcmdpbjogTWFyZ2luID0gREVGQVVMVF9NQVJHSU4pIHtcbiAgcmV0dXJuIGNyZWF0ZVNlbGVjdG9yKFxuICAgIChtYXJnaW46IFBhcnRpYWw8TWFyZ2luPikgPT4gbWFyZ2luLmJvdHRvbSxcbiAgICBtYXJnaW4gPT4gbWFyZ2luLmxlZnQsXG4gICAgbWFyZ2luID0+IG1hcmdpbi5yaWdodCxcbiAgICBtYXJnaW4gPT4gbWFyZ2luLnRvcCxcbiAgICAoXG4gICAgICBib3R0b20gPSBkZWZhdWx0TWFyZ2luLmJvdHRvbSxcbiAgICAgIGxlZnQgPSBkZWZhdWx0TWFyZ2luLmxlZnQsXG4gICAgICByaWdodCA9IGRlZmF1bHRNYXJnaW4ucmlnaHQsXG4gICAgICB0b3AgPSBkZWZhdWx0TWFyZ2luLnRvcCxcbiAgICApID0+ICh7XG4gICAgICBib3R0b20sXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHQsXG4gICAgICB0b3AsXG4gICAgfSksXG4gICk7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFFQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1943\n')},1944:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Text; });\n/* unused harmony export getStringWidth */\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var reduce_css_calc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1929);\n/* harmony import */ var reduce_css_calc__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(reduce_css_calc__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\nvar commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction makeEmptyFunction(arg) {\n  return function () {\n    return arg;\n  };\n}\n\n/**\n * This function accepts and discards inputs; it has no side effects. This is\n * primarily useful idiomatically for overridable function endpoints which\n * always need to be callable, since JS lacks a null-call idiom ala Cocoa.\n */\nvar emptyFunction = function emptyFunction() {};\n\nemptyFunction.thatReturns = makeEmptyFunction;\nemptyFunction.thatReturnsFalse = makeEmptyFunction(false);\nemptyFunction.thatReturnsTrue = makeEmptyFunction(true);\nemptyFunction.thatReturnsNull = makeEmptyFunction(null);\nemptyFunction.thatReturnsThis = function () {\n  return this;\n};\nemptyFunction.thatReturnsArgument = function (arg) {\n  return arg;\n};\n\nvar emptyFunction_1 = emptyFunction;\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar validateFormat = function validateFormat(format) {};\n\nif (false) {}\n\nfunction invariant(condition, format, a, b, c, d, e, f) {\n  validateFormat(format);\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(format.replace(/%s/g, function () {\n        return args[argIndex++];\n      }));\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n}\n\nvar invariant_1 = invariant;\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar warning = emptyFunction_1;\n\nif (false) { var printWarning; }\n\nvar warning_1 = warning;\n\n/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nvar objectAssign = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nvar ReactPropTypesSecret_1 = ReactPropTypesSecret;\n\nif (false) { var loggedTypeFailures, ReactPropTypesSecret$1, warning$1, invariant$1; }\n\n/**\n * Assert that the values match with the type specs.\n * Error messages are memorized and will only be shown once.\n *\n * @param {object} typeSpecs Map of name to a ReactPropType\n * @param {object} values Runtime values that need to be type-checked\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @param {string} componentName Name of the component for error messages.\n * @param {?Function} getStack Returns the component stack.\n * @private\n */\nfunction checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n  if (false) { var stack, error, typeSpecName; }\n}\n\nvar checkPropTypes_1 = checkPropTypes;\n\nvar factoryWithTypeCheckers = function(isValidElement, throwOnDirectAccess) {\n  /* global Symbol */\n  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.\n\n  /**\n   * Returns the iterator method function contained on the iterable object.\n   *\n   * Be sure to invoke the function with the iterable as context:\n   *\n   *     var iteratorFn = getIteratorFn(myIterable);\n   *     if (iteratorFn) {\n   *       var iterator = iteratorFn.call(myIterable);\n   *       ...\n   *     }\n   *\n   * @param {?object} maybeIterable\n   * @return {?function}\n   */\n  function getIteratorFn(maybeIterable) {\n    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n\n  /**\n   * Collection of methods that allow declaration and validation of props that are\n   * supplied to React components. Example usage:\n   *\n   *   var Props = require('ReactPropTypes');\n   *   var MyArticle = React.createClass({\n   *     propTypes: {\n   *       // An optional string prop named \"description\".\n   *       description: Props.string,\n   *\n   *       // A required enum prop named \"category\".\n   *       category: Props.oneOf(['News','Photos']).isRequired,\n   *\n   *       // A prop named \"dialog\" that requires an instance of Dialog.\n   *       dialog: Props.instanceOf(Dialog).isRequired\n   *     },\n   *     render: function() { ... }\n   *   });\n   *\n   * A more formal specification of how these methods are used:\n   *\n   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\n   *   decl := ReactPropTypes.{type}(.isRequired)?\n   *\n   * Each and every declaration produces a function with the same signature. This\n   * allows the creation of custom validation functions. For example:\n   *\n   *  var MyLink = React.createClass({\n   *    propTypes: {\n   *      // An optional string or URI prop named \"href\".\n   *      href: function(props, propName, componentName) {\n   *        var propValue = props[propName];\n   *        if (propValue != null && typeof propValue !== 'string' &&\n   *            !(propValue instanceof URI)) {\n   *          return new Error(\n   *            'Expected a string or an URI for ' + propName + ' in ' +\n   *            componentName\n   *          );\n   *        }\n   *      }\n   *    },\n   *    render: function() {...}\n   *  });\n   *\n   * @internal\n   */\n\n  var ANONYMOUS = '<<anonymous>>';\n\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.\n  var ReactPropTypes = {\n    array: createPrimitiveTypeChecker('array'),\n    bool: createPrimitiveTypeChecker('boolean'),\n    func: createPrimitiveTypeChecker('function'),\n    number: createPrimitiveTypeChecker('number'),\n    object: createPrimitiveTypeChecker('object'),\n    string: createPrimitiveTypeChecker('string'),\n    symbol: createPrimitiveTypeChecker('symbol'),\n\n    any: createAnyTypeChecker(),\n    arrayOf: createArrayOfTypeChecker,\n    element: createElementTypeChecker(),\n    instanceOf: createInstanceTypeChecker,\n    node: createNodeChecker(),\n    objectOf: createObjectOfTypeChecker,\n    oneOf: createEnumTypeChecker,\n    oneOfType: createUnionTypeChecker,\n    shape: createShapeTypeChecker,\n    exact: createStrictShapeTypeChecker,\n  };\n\n  /**\n   * inlined Object.is polyfill to avoid requiring consumers ship their own\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n   */\n  /*eslint-disable no-self-compare*/\n  function is(x, y) {\n    // SameValue algorithm\n    if (x === y) {\n      // Steps 1-5, 7-10\n      // Steps 6.b-6.e: +0 != -0\n      return x !== 0 || 1 / x === 1 / y;\n    } else {\n      // Step 6.a: NaN == NaN\n      return x !== x && y !== y;\n    }\n  }\n  /*eslint-enable no-self-compare*/\n\n  /**\n   * We use an Error-like object for backward compatibility as people may call\n   * PropTypes directly and inspect their output. However, we don't use real\n   * Errors anymore. We don't inspect their stack anyway, and creating them\n   * is prohibitively expensive if they are created too often, such as what\n   * happens in oneOfType() for any type before the one that matched.\n   */\n  function PropTypeError(message) {\n    this.message = message;\n    this.stack = '';\n  }\n  // Make `instanceof Error` still work for returned errors.\n  PropTypeError.prototype = Error.prototype;\n\n  function createChainableTypeChecker(validate) {\n    if (false) { var manualPropTypeWarningCount, manualPropTypeCallCache; }\n    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\n      componentName = componentName || ANONYMOUS;\n      propFullName = propFullName || propName;\n\n      if (secret !== ReactPropTypesSecret_1) {\n        if (throwOnDirectAccess) {\n          // New behavior only for users of `prop-types` package\n          invariant_1(\n            false,\n            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n            'Use `PropTypes.checkPropTypes()` to call them. ' +\n            'Read more at http://fb.me/use-check-prop-types'\n          );\n        } else if (false) { var cacheKey; }\n      }\n      if (props[propName] == null) {\n        if (isRequired) {\n          if (props[propName] === null) {\n            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));\n          }\n          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));\n        }\n        return null;\n      } else {\n        return validate(props, propName, componentName, location, propFullName);\n      }\n    }\n\n    var chainedCheckType = checkType.bind(null, false);\n    chainedCheckType.isRequired = checkType.bind(null, true);\n\n    return chainedCheckType;\n  }\n\n  function createPrimitiveTypeChecker(expectedType) {\n    function validate(props, propName, componentName, location, propFullName, secret) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== expectedType) {\n        // `propValue` being instance of, say, date/regexp, pass the 'object'\n        // check, but we can offer a more precise error message here rather than\n        // 'of type `object`'.\n        var preciseType = getPreciseType(propValue);\n\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createAnyTypeChecker() {\n    return createChainableTypeChecker(emptyFunction_1.thatReturnsNull);\n  }\n\n  function createArrayOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');\n      }\n      var propValue = props[propName];\n      if (!Array.isArray(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));\n      }\n      for (var i = 0; i < propValue.length; i++) {\n        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret_1);\n        if (error instanceof Error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createElementTypeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      if (!isValidElement(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createInstanceTypeChecker(expectedClass) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!(props[propName] instanceof expectedClass)) {\n        var expectedClassName = expectedClass.name || ANONYMOUS;\n        var actualClassName = getClassName(props[propName]);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createEnumTypeChecker(expectedValues) {\n    if (!Array.isArray(expectedValues)) {\n       false ? undefined : void 0;\n      return emptyFunction_1.thatReturnsNull;\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      for (var i = 0; i < expectedValues.length; i++) {\n        if (is(propValue, expectedValues[i])) {\n          return null;\n        }\n      }\n\n      var valuesString = JSON.stringify(expectedValues);\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createObjectOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');\n      }\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));\n      }\n      for (var key in propValue) {\n        if (propValue.hasOwnProperty(key)) {\n          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);\n          if (error instanceof Error) {\n            return error;\n          }\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createUnionTypeChecker(arrayOfTypeCheckers) {\n    if (!Array.isArray(arrayOfTypeCheckers)) {\n       false ? undefined : void 0;\n      return emptyFunction_1.thatReturnsNull;\n    }\n\n    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n      var checker = arrayOfTypeCheckers[i];\n      if (typeof checker !== 'function') {\n        warning_1(\n          false,\n          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +\n          'received %s at index %s.',\n          getPostfixForTypeWarning(checker),\n          i\n        );\n        return emptyFunction_1.thatReturnsNull;\n      }\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n        var checker = arrayOfTypeCheckers[i];\n        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret_1) == null) {\n          return null;\n        }\n      }\n\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createNodeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!isNode(props[propName])) {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      for (var key in shapeTypes) {\n        var checker = shapeTypes[key];\n        if (!checker) {\n          continue;\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createStrictShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      // We need to check all keys in case some are required but missing from\n      // props.\n      var allKeys = objectAssign({}, props[propName], shapeTypes);\n      for (var key in allKeys) {\n        var checker = shapeTypes[key];\n        if (!checker) {\n          return new PropTypeError(\n            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +\n            '\\nBad object: ' + JSON.stringify(props[propName], null, '  ') +\n            '\\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')\n          );\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n\n    return createChainableTypeChecker(validate);\n  }\n\n  function isNode(propValue) {\n    switch (typeof propValue) {\n      case 'number':\n      case 'string':\n      case 'undefined':\n        return true;\n      case 'boolean':\n        return !propValue;\n      case 'object':\n        if (Array.isArray(propValue)) {\n          return propValue.every(isNode);\n        }\n        if (propValue === null || isValidElement(propValue)) {\n          return true;\n        }\n\n        var iteratorFn = getIteratorFn(propValue);\n        if (iteratorFn) {\n          var iterator = iteratorFn.call(propValue);\n          var step;\n          if (iteratorFn !== propValue.entries) {\n            while (!(step = iterator.next()).done) {\n              if (!isNode(step.value)) {\n                return false;\n              }\n            }\n          } else {\n            // Iterator will provide entry [k,v] tuples rather than values.\n            while (!(step = iterator.next()).done) {\n              var entry = step.value;\n              if (entry) {\n                if (!isNode(entry[1])) {\n                  return false;\n                }\n              }\n            }\n          }\n        } else {\n          return false;\n        }\n\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  function isSymbol(propType, propValue) {\n    // Native Symbol.\n    if (propType === 'symbol') {\n      return true;\n    }\n\n    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n    if (propValue['@@toStringTag'] === 'Symbol') {\n      return true;\n    }\n\n    // Fallback for non-spec compliant Symbols which are polyfilled.\n    if (typeof Symbol === 'function' && propValue instanceof Symbol) {\n      return true;\n    }\n\n    return false;\n  }\n\n  // Equivalent of `typeof` but with special handling for array and regexp.\n  function getPropType(propValue) {\n    var propType = typeof propValue;\n    if (Array.isArray(propValue)) {\n      return 'array';\n    }\n    if (propValue instanceof RegExp) {\n      // Old webkits (at least until Android 4.0) return 'function' rather than\n      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n      // passes PropTypes.object.\n      return 'object';\n    }\n    if (isSymbol(propType, propValue)) {\n      return 'symbol';\n    }\n    return propType;\n  }\n\n  // This handles more types than `getPropType`. Only used for error messages.\n  // See `createPrimitiveTypeChecker`.\n  function getPreciseType(propValue) {\n    if (typeof propValue === 'undefined' || propValue === null) {\n      return '' + propValue;\n    }\n    var propType = getPropType(propValue);\n    if (propType === 'object') {\n      if (propValue instanceof Date) {\n        return 'date';\n      } else if (propValue instanceof RegExp) {\n        return 'regexp';\n      }\n    }\n    return propType;\n  }\n\n  // Returns a string that is postfixed to a warning about an invalid type.\n  // For example, \"undefined\" or \"of type array\"\n  function getPostfixForTypeWarning(value) {\n    var type = getPreciseType(value);\n    switch (type) {\n      case 'array':\n      case 'object':\n        return 'an ' + type;\n      case 'boolean':\n      case 'date':\n      case 'regexp':\n        return 'a ' + type;\n      default:\n        return type;\n    }\n  }\n\n  // Returns class name of the object, if any.\n  function getClassName(propValue) {\n    if (!propValue.constructor || !propValue.constructor.name) {\n      return ANONYMOUS;\n    }\n    return propValue.constructor.name;\n  }\n\n  ReactPropTypes.checkPropTypes = checkPropTypes_1;\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n\nvar factoryWithThrowingShims = function() {\n  function shim(props, propName, componentName, location, propFullName, secret) {\n    if (secret === ReactPropTypesSecret_1) {\n      // It is still safe when called from React.\n      return;\n    }\n    invariant_1(\n      false,\n      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n      'Use PropTypes.checkPropTypes() to call them. ' +\n      'Read more at http://fb.me/use-check-prop-types'\n    );\n  }  shim.isRequired = shim;\n  function getShim() {\n    return shim;\n  }  // Important!\n  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.\n  var ReactPropTypes = {\n    array: shim,\n    bool: shim,\n    func: shim,\n    number: shim,\n    object: shim,\n    string: shim,\n    symbol: shim,\n\n    any: shim,\n    arrayOf: getShim,\n    element: shim,\n    instanceOf: getShim,\n    node: shim,\n    objectOf: getShim,\n    oneOf: getShim,\n    oneOfType: getShim,\n    shape: getShim,\n    exact: getShim\n  };\n\n  ReactPropTypes.checkPropTypes = emptyFunction_1;\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n\nvar propTypes = createCommonjsModule(function (module) {\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nif (false) { var throwOnDirectAccess, isValidElement, REACT_ELEMENT_TYPE; } else {\n  // By explicitly using `prop-types` you are opting into new production behavior.\n  // http://fb.me/prop-types-in-prod\n  module.exports = factoryWithThrowingShims();\n}\n});\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;\n\nvar _freeGlobal = freeGlobal;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = _freeGlobal || freeSelf || Function('return this')();\n\nvar _root = root;\n\n/** Built-in value references. */\nvar Symbol$1 = _root.Symbol;\n\nvar _Symbol = Symbol$1;\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$1 = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty$1.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nvar _getRawTag = getRawTag;\n\n/** Used for built-in method references. */\nvar objectProto$1 = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString$1 = objectProto$1.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString$1.call(value);\n}\n\nvar _objectToString = objectToString;\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag$1 && symToStringTag$1 in Object(value))\n    ? _getRawTag(value)\n    : _objectToString(value);\n}\n\nvar _baseGetTag = baseGetTag;\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nvar isObject_1 = isObject;\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject_1(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = _baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nvar isFunction_1 = isFunction;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = _root['__core-js_shared__'];\n\nvar _coreJsData = coreJsData;\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nvar _isMasked = isMasked;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nvar _toSource = toSource;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto$1 = Function.prototype,\n    objectProto$2 = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString$1 = funcProto$1.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$2 = objectProto$2.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString$1.call(hasOwnProperty$2).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject_1(value) || _isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(_toSource(value));\n}\n\nvar _baseIsNative = baseIsNative;\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nvar _getValue = getValue;\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = _getValue(object, key);\n  return _baseIsNative(value) ? value : undefined;\n}\n\nvar _getNative = getNative;\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = _getNative(Object, 'create');\n\nvar _nativeCreate = nativeCreate;\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = _nativeCreate ? _nativeCreate(null) : {};\n  this.size = 0;\n}\n\nvar _hashClear = hashClear;\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nvar _hashDelete = hashDelete;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto$3 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$3 = objectProto$3.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (_nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty$3.call(data, key) ? data[key] : undefined;\n}\n\nvar _hashGet = hashGet;\n\n/** Used for built-in method references. */\nvar objectProto$4 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$4 = objectProto$4.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return _nativeCreate ? (data[key] !== undefined) : hasOwnProperty$4.call(data, key);\n}\n\nvar _hashHas = hashHas;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED$1 = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (_nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;\n  return this;\n}\n\nvar _hashSet = hashSet;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = _hashClear;\nHash.prototype['delete'] = _hashDelete;\nHash.prototype.get = _hashGet;\nHash.prototype.has = _hashHas;\nHash.prototype.set = _hashSet;\n\nvar _Hash = Hash;\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nvar _listCacheClear = listCacheClear;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nvar eq_1 = eq;\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq_1(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nvar _assocIndexOf = assocIndexOf;\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = _assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nvar _listCacheDelete = listCacheDelete;\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = _assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nvar _listCacheGet = listCacheGet;\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return _assocIndexOf(this.__data__, key) > -1;\n}\n\nvar _listCacheHas = listCacheHas;\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = _assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nvar _listCacheSet = listCacheSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = _listCacheClear;\nListCache.prototype['delete'] = _listCacheDelete;\nListCache.prototype.get = _listCacheGet;\nListCache.prototype.has = _listCacheHas;\nListCache.prototype.set = _listCacheSet;\n\nvar _ListCache = ListCache;\n\n/* Built-in method references that are verified to be native. */\nvar Map = _getNative(_root, 'Map');\n\nvar _Map = Map;\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new _Hash,\n    'map': new (_Map || _ListCache),\n    'string': new _Hash\n  };\n}\n\nvar _mapCacheClear = mapCacheClear;\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nvar _isKeyable = isKeyable;\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return _isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nvar _getMapData = getMapData;\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = _getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nvar _mapCacheDelete = mapCacheDelete;\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return _getMapData(this, key).get(key);\n}\n\nvar _mapCacheGet = mapCacheGet;\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return _getMapData(this, key).has(key);\n}\n\nvar _mapCacheHas = mapCacheHas;\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = _getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nvar _mapCacheSet = mapCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = _mapCacheClear;\nMapCache.prototype['delete'] = _mapCacheDelete;\nMapCache.prototype.get = _mapCacheGet;\nMapCache.prototype.has = _mapCacheHas;\nMapCache.prototype.set = _mapCacheSet;\n\nvar _MapCache = MapCache;\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || _MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = _MapCache;\n\nvar memoize_1 = memoize;\n\nvar MEASUREMENT_ELEMENT_ID = '__react_svg_text_measurement_id';\n\nfunction getStringWidth(str, style) {\n  try {\n    // Calculate length of each word to be used to determine number of words per line\n    var textEl = document.getElementById(MEASUREMENT_ELEMENT_ID);\n    if (!textEl) {\n      var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n      svg.style.width = 0;\n      svg.style.height = 0;\n      svg.style.position = 'absolute';\n      svg.style.top = '-100%';\n      svg.style.left = '-100%';\n      textEl = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n      textEl.setAttribute('id', MEASUREMENT_ELEMENT_ID);\n      svg.appendChild(textEl);\n      document.body.appendChild(svg);\n    }\n\n    Object.assign(textEl.style, style);\n    textEl.textContent = str;\n    return textEl.getComputedTextLength();\n  } catch (e) {\n    return null;\n  }\n}\n\nvar getStringWidth$1 = memoize_1(getStringWidth, function (str, style) {\n  return str + '_' + JSON.stringify(style);\n});\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar Text = function (_Component) {\n  inherits(Text, _Component);\n\n  function Text(props) {\n    classCallCheck(this, Text);\n\n    var _this = possibleConstructorReturn(this, (Text.__proto__ || Object.getPrototypeOf(Text)).call(this, props));\n\n    _this.state = {\n      wordsByLines: []\n    };\n    return _this;\n  }\n\n  createClass(Text, [{\n    key: 'componentWillMount',\n    value: function componentWillMount() {\n      this.updateWordsByLines(this.props, true);\n    }\n  }, {\n    key: 'componentWillReceiveProps',\n    value: function componentWillReceiveProps(nextProps) {\n      var needCalculate = this.props.children !== nextProps.children || this.props.style !== nextProps.style;\n      this.updateWordsByLines(nextProps, needCalculate);\n    }\n  }, {\n    key: 'updateWordsByLines',\n    value: function updateWordsByLines(props, needCalculate) {\n      // Only perform calculations if using features that require them (multiline, scaleToFit)\n      if (props.width || props.scaleToFit) {\n        if (needCalculate) {\n          var words = props.children ? props.children.toString().split(/\\s+/) : [];\n\n          this.wordsWithComputedWidth = words.map(function (word) {\n            return {\n              word: word,\n              width: getStringWidth$1(word, props.style)\n            };\n          });\n          this.spaceWidth = getStringWidth$1('\\xA0', props.style);\n        }\n\n        var wordsByLines = this.calculateWordsByLines(this.wordsWithComputedWidth, this.spaceWidth, props.width);\n        this.setState({ wordsByLines: wordsByLines });\n      } else {\n        this.updateWordsWithoutCalculate(props);\n      }\n    }\n  }, {\n    key: 'updateWordsWithoutCalculate',\n    value: function updateWordsWithoutCalculate(props) {\n      var words = props.children ? props.children.toString().split(/\\s+/) : [];\n      this.setState({ wordsByLines: [{ words: words }] });\n    }\n  }, {\n    key: 'calculateWordsByLines',\n    value: function calculateWordsByLines(wordsWithComputedWidth, spaceWidth, lineWidth) {\n      var scaleToFit = this.props.scaleToFit;\n\n      return wordsWithComputedWidth.reduce(function (result, _ref) {\n        var word = _ref.word,\n            width = _ref.width;\n\n        var currentLine = result[result.length - 1];\n\n        if (currentLine && (lineWidth == null || scaleToFit || currentLine.width + width + spaceWidth < lineWidth)) {\n          // Word can be added to an existing line\n          currentLine.words.push(word);\n          currentLine.width += width + spaceWidth;\n        } else {\n          // Add first word to line or word is too long to scaleToFit on existing line\n          var newLine = { words: [word], width: width };\n          result.push(newLine);\n        }\n\n        return result;\n      }, []);\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props = this.props,\n          dx = _props.dx,\n          dy = _props.dy,\n          textAnchor = _props.textAnchor,\n          verticalAnchor = _props.verticalAnchor,\n          scaleToFit = _props.scaleToFit,\n          angle = _props.angle,\n          lineHeight = _props.lineHeight,\n          capHeight = _props.capHeight,\n          innerRef = _props.innerRef,\n          textProps = objectWithoutProperties(_props, ['dx', 'dy', 'textAnchor', 'verticalAnchor', 'scaleToFit', 'angle', 'lineHeight', 'capHeight', 'innerRef']);\n      var wordsByLines = this.state.wordsByLines;\n\n\n      var x = textProps.x;\n      var y = textProps.y;\n\n      var startDy = void 0;\n      switch (verticalAnchor) {\n        case 'start':\n          startDy = reduce_css_calc__WEBPACK_IMPORTED_MODULE_1___default()('calc(' + capHeight + ')');\n          break;\n        case 'middle':\n          startDy = reduce_css_calc__WEBPACK_IMPORTED_MODULE_1___default()('calc(' + (wordsByLines.length - 1) / 2 + ' * -' + lineHeight + ' + (' + capHeight + ' / 2))');\n          break;\n        default:\n          startDy = reduce_css_calc__WEBPACK_IMPORTED_MODULE_1___default()('calc(' + (wordsByLines.length - 1) + ' * -' + lineHeight + ')');\n          break;\n      }\n\n      var transforms = [];\n      if (scaleToFit && wordsByLines.length) {\n        var lineWidth = wordsByLines[0].width;\n        var sx = this.props.width / lineWidth;\n        var sy = sx;\n        var originX = x - sx * x;\n        var originY = y - sy * y;\n        transforms.push('matrix(' + sx + ', 0, 0, ' + sy + ', ' + originX + ', ' + originY + ')');\n      }\n      if (angle) {\n        transforms.push('rotate(' + angle + ', ' + x + ', ' + y + ')');\n      }\n      if (transforms.length) {\n        textProps.transform = transforms.join(' ');\n      }\n\n      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n        'svg',\n        {\n          ref: innerRef,\n          x: dx,\n          y: dy,\n          fontSize: textProps.fontSize,\n          style: { overflow: 'visible' }\n        },\n        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n          'text',\n          _extends({}, textProps, { textAnchor: textAnchor }),\n          wordsByLines.map(function (line, index) {\n            return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n              'tspan',\n              { x: x, dy: index === 0 ? startDy : lineHeight, key: index },\n              line.words.join(' ')\n            );\n          })\n        )\n      );\n    }\n  }]);\n  return Text;\n}(react__WEBPACK_IMPORTED_MODULE_0__[\"Component\"]);\n\nText.defaultProps = {\n  x: 0,\n  y: 0,\n  dx: 0,\n  dy: 0,\n  lineHeight: '1em',\n  capHeight: '0.71em', // Magic number from d3\n  scaleToFit: false,\n  textAnchor: 'start',\n  verticalAnchor: 'end' // default SVG behavior\n};\n\nText.propTypes = {\n  scaleToFit: propTypes.bool,\n  angle: propTypes.number,\n  textAnchor: propTypes.oneOf(['start', 'middle', 'end', 'inherit']),\n  verticalAnchor: propTypes.oneOf(['start', 'middle', 'end']),\n  style: propTypes.object,\n  innerRef: propTypes.func\n};\n\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(69)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk0NC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL3h5LWNoYXJ0L25vZGVfbW9kdWxlcy9AdngvYXhpcy9ub2RlX21vZHVsZXMvQHZ4L3RleHQvZGlzdC92eC10ZXh0LmVzLmpzPzkwZDciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCByZWR1Y2VDU1NDYWxjIGZyb20gJ3JlZHVjZS1jc3MtY2FsYyc7XG5cbnZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuLCBtb2R1bGUpIHtcblx0cmV0dXJuIG1vZHVsZSA9IHsgZXhwb3J0czoge30gfSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG5cbmZ1bmN0aW9uIG1ha2VFbXB0eUZ1bmN0aW9uKGFyZykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhcmc7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIGFuZCBkaXNjYXJkcyBpbnB1dHM7IGl0IGhhcyBubyBzaWRlIGVmZmVjdHMuIFRoaXMgaXNcbiAqIHByaW1hcmlseSB1c2VmdWwgaWRpb21hdGljYWxseSBmb3Igb3ZlcnJpZGFibGUgZnVuY3Rpb24gZW5kcG9pbnRzIHdoaWNoXG4gKiBhbHdheXMgbmVlZCB0byBiZSBjYWxsYWJsZSwgc2luY2UgSlMgbGFja3MgYSBudWxsLWNhbGwgaWRpb20gYWxhIENvY29hLlxuICovXG52YXIgZW1wdHlGdW5jdGlvbiA9IGZ1bmN0aW9uIGVtcHR5RnVuY3Rpb24oKSB7fTtcblxuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucyA9IG1ha2VFbXB0eUZ1bmN0aW9uO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlID0gbWFrZUVtcHR5RnVuY3Rpb24oZmFsc2UpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWUgPSBtYWtlRW1wdHlGdW5jdGlvbih0cnVlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsID0gbWFrZUVtcHR5RnVuY3Rpb24obnVsbCk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVGhpcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50ID0gZnVuY3Rpb24gKGFyZykge1xuICByZXR1cm4gYXJnO1xufTtcblxudmFyIGVtcHR5RnVuY3Rpb25fMSA9IGVtcHR5RnVuY3Rpb247XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbnZhciB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgdmFsaWRhdGVGb3JtYXQoZm9ybWF0KTtcblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKCdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICsgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSkpO1xuICAgICAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICB9XG5cbiAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxudmFyIGludmFyaWFudF8xID0gaW52YXJpYW50O1xuXG4vKipcbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgd2FybmluZyA9IGVtcHR5RnVuY3Rpb25fMTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIHByaW50V2FybmluZyhmb3JtYXQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xuXG4gIHdhcm5pbmcgPSBmdW5jdGlvbiB3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXQuaW5kZXhPZignRmFpbGVkIENvbXBvc2l0ZSBwcm9wVHlwZTogJykgPT09IDApIHtcbiAgICAgIHJldHVybjsgLy8gSWdub3JlIENvbXBvc2l0ZUNvbXBvbmVudCBwcm9wdHlwZSBjaGVjay5cbiAgICB9XG5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMl0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcuYXBwbHkodW5kZWZpbmVkLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIHdhcm5pbmdfMSA9IHdhcm5pbmc7XG5cbi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdH1cblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdH0pO1xuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0fSk7XG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxudmFyIG9iamVjdEFzc2lnbiA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0XzEgPSBSZWFjdFByb3BUeXBlc1NlY3JldDtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGludmFyaWFudCQxID0gaW52YXJpYW50XzE7XG4gIHZhciB3YXJuaW5nJDEgPSB3YXJuaW5nXzE7XG4gIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCQxID0gUmVhY3RQcm9wVHlwZXNTZWNyZXRfMTtcbiAgdmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xufVxuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cbiAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gez9GdW5jdGlvbn0gZ2V0U3RhY2sgUmV0dXJucyB0aGUgY29tcG9uZW50IHN0YWNrLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBnZXRTdGFjaykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmICh0eXBlU3BlY3MuaGFzT3duUHJvcGVydHkodHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpbnZhcmlhbnQkMSh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gPT09ICdmdW5jdGlvbicsICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tICcgKyAndGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCVzYC4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSk7XG4gICAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0JDEpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yID0gZXg7XG4gICAgICAgIH1cbiAgICAgICAgd2FybmluZyQxKCFlcnJvciB8fCBlcnJvciBpbnN0YW5jZW9mIEVycm9yLCAnJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBzdGFjayA9IGdldFN0YWNrID8gZ2V0U3RhY2soKSA6ICcnO1xuXG4gICAgICAgICAgd2FybmluZyQxKGZhbHNlLCAnRmFpbGVkICVzIHR5cGU6ICVzJXMnLCBsb2NhdGlvbiwgZXJyb3IubWVzc2FnZSwgc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBjaGVja1Byb3BUeXBlc18xID0gY2hlY2tQcm9wVHlwZXM7XG5cbnZhciBmYWN0b3J5V2l0aFR5cGVDaGVja2VycyA9IGZ1bmN0aW9uKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gIC8qIGdsb2JhbCBTeW1ib2wgKi9cbiAgdmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xuICB2YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICAgKlxuICAgKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcbiAgICpcbiAgICogICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihteUl0ZXJhYmxlKTtcbiAgICogICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAgICogICAgICAgLi4uXG4gICAqICAgICB9XG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbWF5YmVJdGVyYWJsZVxuICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG4gICAqL1xuICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXG4gICAqIHN1cHBsaWVkIHRvIFJlYWN0IGNvbXBvbmVudHMuIEV4YW1wbGUgdXNhZ2U6XG4gICAqXG4gICAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcbiAgICogICB2YXIgTXlBcnRpY2xlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFwiZGVzY3JpcHRpb25cIi5cbiAgICogICAgICAgZGVzY3JpcHRpb246IFByb3BzLnN0cmluZyxcbiAgICpcbiAgICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXCJjYXRlZ29yeVwiLlxuICAgKiAgICAgICBjYXRlZ29yeTogUHJvcHMub25lT2YoWydOZXdzJywnUGhvdG9zJ10pLmlzUmVxdWlyZWQsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcImRpYWxvZ1wiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxuICAgKiAgICAgICBkaWFsb2c6IFByb3BzLmluc3RhbmNlT2YoRGlhbG9nKS5pc1JlcXVpcmVkXG4gICAqICAgICB9LFxuICAgKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxuICAgKlxuICAgKiAgIHR5cGUgOj0gYXJyYXl8Ym9vbHxmdW5jfG9iamVjdHxudW1iZXJ8c3RyaW5nfG9uZU9mKFsuLi5dKXxpbnN0YW5jZU9mKC4uLilcbiAgICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XG4gICAqXG4gICAqIEVhY2ggYW5kIGV2ZXJ5IGRlY2xhcmF0aW9uIHByb2R1Y2VzIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBzaWduYXR1cmUuIFRoaXNcbiAgICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiAgdmFyIE15TGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIG9yIFVSSSBwcm9wIG5hbWVkIFwiaHJlZlwiLlxuICAgKiAgICAgIGhyZWY6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICogICAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICAgKiAgICAgICAgICAgICEocHJvcFZhbHVlIGluc3RhbmNlb2YgVVJJKSkge1xuICAgKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgKiAgICAgICAgICAgICdFeHBlY3RlZCBhIHN0cmluZyBvciBhbiBVUkkgZm9yICcgKyBwcm9wTmFtZSArICcgaW4gJyArXG4gICAqICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgKiAgICAgICAgICApO1xuICAgKiAgICAgICAgfVxuICAgKiAgICAgIH1cbiAgICogICAgfSxcbiAgICogICAgcmVuZGVyOiBmdW5jdGlvbigpIHsuLi59XG4gICAqICB9KTtcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG4gIHZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XG5cbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2FycmF5JyksXG4gICAgYm9vbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Jvb2xlYW4nKSxcbiAgICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcbiAgICBudW1iZXI6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdudW1iZXInKSxcbiAgICBvYmplY3Q6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdvYmplY3QnKSxcbiAgICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcbiAgICBzeW1ib2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzeW1ib2wnKSxcblxuICAgIGFueTogY3JlYXRlQW55VHlwZUNoZWNrZXIoKSxcbiAgICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXG4gICAgZWxlbWVudDogY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCksXG4gICAgaW5zdGFuY2VPZjogY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcixcbiAgICBub2RlOiBjcmVhdGVOb2RlQ2hlY2tlcigpLFxuICAgIG9iamVjdE9mOiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyLFxuICAgIG9uZU9mOiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIsXG4gICAgb25lT2ZUeXBlOiBjcmVhdGVVbmlvblR5cGVDaGVja2VyLFxuICAgIHNoYXBlOiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyLFxuICAgIGV4YWN0OiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyLFxuICB9O1xuXG4gIC8qKlxuICAgKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICAgKi9cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuICBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gICAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICAgIH1cbiAgfVxuICAvKmVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlKi9cblxuICAvKipcbiAgICogV2UgdXNlIGFuIEVycm9yLWxpa2Ugb2JqZWN0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGFzIHBlb3BsZSBtYXkgY2FsbFxuICAgKiBQcm9wVHlwZXMgZGlyZWN0bHkgYW5kIGluc3BlY3QgdGhlaXIgb3V0cHV0LiBIb3dldmVyLCB3ZSBkb24ndCB1c2UgcmVhbFxuICAgKiBFcnJvcnMgYW55bW9yZS4gV2UgZG9uJ3QgaW5zcGVjdCB0aGVpciBzdGFjayBhbnl3YXksIGFuZCBjcmVhdGluZyB0aGVtXG4gICAqIGlzIHByb2hpYml0aXZlbHkgZXhwZW5zaXZlIGlmIHRoZXkgYXJlIGNyZWF0ZWQgdG9vIG9mdGVuLCBzdWNoIGFzIHdoYXRcbiAgICogaGFwcGVucyBpbiBvbmVPZlR5cGUoKSBmb3IgYW55IHR5cGUgYmVmb3JlIHRoZSBvbmUgdGhhdCBtYXRjaGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gUHJvcFR5cGVFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLnN0YWNrID0gJyc7XG4gIH1cbiAgLy8gTWFrZSBgaW5zdGFuY2VvZiBFcnJvcmAgc3RpbGwgd29yayBmb3IgcmV0dXJuZWQgZXJyb3JzLlxuICBQcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuXG4gICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldF8xKSB7XG4gICAgICAgIGlmICh0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gICAgICAgICAgLy8gTmV3IGJlaGF2aW9yIG9ubHkgZm9yIHVzZXJzIG9mIGBwcm9wLXR5cGVzYCBwYWNrYWdlXG4gICAgICAgICAgaW52YXJpYW50XzEoXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICdVc2UgYFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpYCB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIE9sZCBiZWhhdmlvciBmb3IgcGVvcGxlIHVzaW5nIFJlYWN0LlByb3BUeXBlc1xuICAgICAgICAgIHZhciBjYWNoZUtleSA9IGNvbXBvbmVudE5hbWUgKyAnOicgKyBwcm9wTmFtZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldICYmXG4gICAgICAgICAgICAvLyBBdm9pZCBzcGFtbWluZyB0aGUgY29uc29sZSBiZWNhdXNlIHRoZXkgYXJlIG9mdGVuIG5vdCBhY3Rpb25hYmxlIGV4Y2VwdCBmb3IgbGliIGF1dGhvcnNcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50IDwgM1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgd2FybmluZ18xKFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgK1xuICAgICAgICAgICAgICAnZnVuY3Rpb24gZm9yIHRoZSBgJXNgIHByb3Agb24gYCVzYC4gVGhpcyBpcyBkZXByZWNhdGVkICcgK1xuICAgICAgICAgICAgICAnYW5kIHdpbGwgdGhyb3cgaW4gdGhlIHN0YW5kYWxvbmUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgICAnWW91IG1heSBiZSBzZWVpbmcgdGhpcyB3YXJuaW5nIGR1ZSB0byBhIHRoaXJkLXBhcnR5IFByb3BUeXBlcyAnICtcbiAgICAgICAgICAgICAgJ2xpYnJhcnkuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctZG9udC1jYWxsLXByb3B0eXBlcyAnICsgJ2ZvciBkZXRhaWxzLicsXG4gICAgICAgICAgICAgIHByb3BGdWxsTmFtZSxcbiAgICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uXzEudGhhdFJldHVybnNOdWxsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBhcnJheU9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScsIFJlYWN0UHJvcFR5cGVzU2VjcmV0XzEpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nXzEoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uXzEudGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzKHByb3BWYWx1ZSwgZXhwZWN0ZWRWYWx1ZXNbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KGV4cGVjdGVkVmFsdWVzKTtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdmFsdWUgYCcgKyBwcm9wVmFsdWUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgb25lIG9mICcgKyB2YWx1ZXNTdHJpbmcgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgICAgaWYgKHByb3BWYWx1ZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0XzEpO1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmdfMShmYWxzZSwgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uXzEudGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgaWYgKHR5cGVvZiBjaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5pbmdfMShcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUuIEV4cGVjdGVkIGFuIGFycmF5IG9mIGNoZWNrIGZ1bmN0aW9ucywgYnV0ICcgK1xuICAgICAgICAgICdyZWNlaXZlZCAlcyBhdCBpbmRleCAlcy4nLFxuICAgICAgICAgIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyhjaGVja2VyKSxcbiAgICAgICAgICBpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uXzEudGhhdFJldHVybnNOdWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgICAgaWYgKGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBSZWFjdFByb3BUeXBlc1NlY3JldF8xKSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVOb2RlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghaXNOb2RlKHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBSZWFjdE5vZGUuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc2hhcGVUeXBlcykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXRfMSk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGFsbCBrZXlzIGluIGNhc2Ugc29tZSBhcmUgcmVxdWlyZWQgYnV0IG1pc3NpbmcgZnJvbVxuICAgICAgLy8gcHJvcHMuXG4gICAgICB2YXIgYWxsS2V5cyA9IG9iamVjdEFzc2lnbih7fSwgcHJvcHNbcHJvcE5hbWVdLCBzaGFwZVR5cGVzKTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBhbGxLZXlzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAgICAgICAnSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Aga2V5IGAnICsga2V5ICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJyArXG4gICAgICAgICAgICAnXFxuQmFkIG9iamVjdDogJyArIEpTT04uc3RyaW5naWZ5KHByb3BzW3Byb3BOYW1lXSwgbnVsbCwgJyAgJykgK1xuICAgICAgICAgICAgJ1xcblZhbGlkIGtleXM6ICcgKyAgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMoc2hhcGVUeXBlcyksIG51bGwsICcgICcpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldF8xKTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XG4gICAgLy8gTmF0aXZlIFN5bWJvbC5cbiAgICBpZiAocHJvcFR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddID09PSAnU3ltYm9sJ1xuICAgIGlmIChwcm9wVmFsdWVbJ0BAdG9TdHJpbmdUYWcnXSA9PT0gJ1N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIGZvciBub24tc3BlYyBjb21wbGlhbnQgU3ltYm9scyB3aGljaCBhcmUgcG9seWZpbGxlZC5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wVmFsdWUgaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cbiAgZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gICAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ2FycmF5JztcbiAgICB9XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxuICAgICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG4gICAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICB9XG4gICAgaWYgKGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ3N5bWJvbCc7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFRoaXMgaGFuZGxlcyBtb3JlIHR5cGVzIHRoYW4gYGdldFByb3BUeXBlYC4gT25seSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cbiAgLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXG4gIGZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAndW5kZWZpbmVkJyB8fCBwcm9wVmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJyArIHByb3BWYWx1ZTtcbiAgICB9XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gJ2RhdGUnO1xuICAgICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgaXMgcG9zdGZpeGVkIHRvIGEgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIHR5cGUuXG4gIC8vIEZvciBleGFtcGxlLCBcInVuZGVmaW5lZFwiIG9yIFwib2YgdHlwZSBhcnJheVwiXG4gIGZ1bmN0aW9uIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgcmV0dXJuICdhbiAnICsgdHlwZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjYXNlICdyZWdleHAnOlxuICAgICAgICByZXR1cm4gJ2EgJyArIHR5cGU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuICBmdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XG4gICAgaWYgKCFwcm9wVmFsdWUuY29uc3RydWN0b3IgfHwgIXByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICByZXR1cm4gQU5PTllNT1VTO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGNoZWNrUHJvcFR5cGVzXzE7XG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG5cbnZhciBmYWN0b3J5V2l0aFRocm93aW5nU2hpbXMgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gc2hpbShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgIGlmIChzZWNyZXQgPT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0XzEpIHtcbiAgICAgIC8vIEl0IGlzIHN0aWxsIHNhZmUgd2hlbiBjYWxsZWQgZnJvbSBSZWFjdC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW52YXJpYW50XzEoXG4gICAgICBmYWxzZSxcbiAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICdVc2UgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCkgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICk7XG4gIH0gIHNoaW0uaXNSZXF1aXJlZCA9IHNoaW07XG4gIGZ1bmN0aW9uIGdldFNoaW0oKSB7XG4gICAgcmV0dXJuIHNoaW07XG4gIH0gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogc2hpbSxcbiAgICBib29sOiBzaGltLFxuICAgIGZ1bmM6IHNoaW0sXG4gICAgbnVtYmVyOiBzaGltLFxuICAgIG9iamVjdDogc2hpbSxcbiAgICBzdHJpbmc6IHNoaW0sXG4gICAgc3ltYm9sOiBzaGltLFxuXG4gICAgYW55OiBzaGltLFxuICAgIGFycmF5T2Y6IGdldFNoaW0sXG4gICAgZWxlbWVudDogc2hpbSxcbiAgICBpbnN0YW5jZU9mOiBnZXRTaGltLFxuICAgIG5vZGU6IHNoaW0sXG4gICAgb2JqZWN0T2Y6IGdldFNoaW0sXG4gICAgb25lT2Y6IGdldFNoaW0sXG4gICAgb25lT2ZUeXBlOiBnZXRTaGltLFxuICAgIHNoYXBlOiBnZXRTaGltLFxuICAgIGV4YWN0OiBnZXRTaGltXG4gIH07XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBlbXB0eUZ1bmN0aW9uXzE7XG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG5cbnZhciBwcm9wVHlwZXMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIFN5bWJvbC5mb3IgJiZcbiAgICBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykpIHx8XG4gICAgMHhlYWM3O1xuXG4gIHZhciBpc1ZhbGlkRWxlbWVudCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgb2JqZWN0ICE9PSBudWxsICYmXG4gICAgICBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfTtcblxuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBkZXZlbG9wbWVudCBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICB2YXIgdGhyb3dPbkRpcmVjdEFjY2VzcyA9IHRydWU7XG4gIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMoaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpO1xufSBlbHNlIHtcbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgcHJvZHVjdGlvbiBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcygpO1xufVxufSk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBjb21tb25qc0dsb2JhbCA9PSAnb2JqZWN0JyAmJiBjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBjb21tb25qc0dsb2JhbDtcblxudmFyIF9mcmVlR2xvYmFsID0gZnJlZUdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gX2ZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxudmFyIF9yb290ID0gcm9vdDtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sJDEgPSBfcm9vdC5TeW1ib2w7XG5cbnZhciBfU3ltYm9sID0gU3ltYm9sJDE7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5JDEgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gX1N5bWJvbCA/IF9TeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5JDEuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX2dldFJhd1RhZyA9IGdldFJhd1RhZztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvJDEgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmckMSA9IG9iamVjdFByb3RvJDEudG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmckMS5jYWxsKHZhbHVlKTtcbn1cblxudmFyIF9vYmplY3RUb1N0cmluZyA9IG9iamVjdFRvU3RyaW5nO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWckMSA9IF9TeW1ib2wgPyBfU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnJDEgJiYgc3ltVG9TdHJpbmdUYWckMSBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gX2dldFJhd1RhZyh2YWx1ZSlcbiAgICA6IF9vYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbnZhciBfYmFzZUdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG52YXIgaXNPYmplY3RfMSA9IGlzT2JqZWN0O1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RfMSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gX2Jhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG52YXIgaXNGdW5jdGlvbl8xID0gaXNGdW5jdGlvbjtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSBfcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbnZhciBfY29yZUpzRGF0YSA9IGNvcmVKc0RhdGE7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoX2NvcmVKc0RhdGEgJiYgX2NvcmVKc0RhdGEua2V5cyAmJiBfY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbnZhciBfaXNNYXNrZWQgPSBpc01hc2tlZDtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgX3RvU291cmNlID0gdG9Tb3VyY2U7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvJDEgPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8kMiA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmckMSA9IGZ1bmNQcm90byQxLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSQyID0gb2JqZWN0UHJvdG8kMi5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZyQxLmNhbGwoaGFzT3duUHJvcGVydHkkMikucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RfMSh2YWx1ZSkgfHwgX2lzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb25fMSh2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KF90b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG52YXIgX2Jhc2VJc05hdGl2ZSA9IGJhc2VJc05hdGl2ZTtcblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbnZhciBfZ2V0VmFsdWUgPSBnZXRWYWx1ZTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IF9nZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBfYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG52YXIgX2dldE5hdGl2ZSA9IGdldE5hdGl2ZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIG5hdGl2ZUNyZWF0ZSA9IF9nZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbnZhciBfbmF0aXZlQ3JlYXRlID0gbmF0aXZlQ3JlYXRlO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBfbmF0aXZlQ3JlYXRlID8gX25hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG52YXIgX2hhc2hDbGVhciA9IGhhc2hDbGVhcjtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9oYXNoRGVsZXRlID0gaGFzaERlbGV0ZTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8kMyA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5JDMgPSBvYmplY3RQcm90byQzLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoX25hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5JDMuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG52YXIgX2hhc2hHZXQgPSBoYXNoR2V0O1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8kNCA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5JDQgPSBvYmplY3RQcm90byQ0Lmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIF9uYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkkNC5jYWxsKGRhdGEsIGtleSk7XG59XG5cbnZhciBfaGFzaEhhcyA9IGhhc2hIYXM7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCQxID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAoX25hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEJDEgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBfaGFzaFNldCA9IGhhc2hTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBfaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gX2hhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBfaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IF9oYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gX2hhc2hTZXQ7XG5cbnZhciBfSGFzaCA9IEhhc2g7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxudmFyIF9saXN0Q2FjaGVDbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuXG4vKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxudmFyIGVxXzEgPSBlcTtcblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxXzEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG52YXIgX2Fzc29jSW5kZXhPZiA9IGFzc29jSW5kZXhPZjtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gX2Fzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIF9saXN0Q2FjaGVEZWxldGUgPSBsaXN0Q2FjaGVEZWxldGU7XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBfYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG52YXIgX2xpc3RDYWNoZUdldCA9IGxpc3RDYWNoZUdldDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIF9hc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG52YXIgX2xpc3RDYWNoZUhhcyA9IGxpc3RDYWNoZUhhcztcblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IF9hc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxudmFyIF9saXN0Q2FjaGVTZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gX2xpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBfbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBfbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBfbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBfbGlzdENhY2hlU2V0O1xuXG52YXIgX0xpc3RDYWNoZSA9IExpc3RDYWNoZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIE1hcCA9IF9nZXROYXRpdmUoX3Jvb3QsICdNYXAnKTtcblxudmFyIF9NYXAgPSBNYXA7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgX0hhc2gsXG4gICAgJ21hcCc6IG5ldyAoX01hcCB8fCBfTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IF9IYXNoXG4gIH07XG59XG5cbnZhciBfbWFwQ2FjaGVDbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxudmFyIF9pc0tleWFibGUgPSBpc0tleWFibGU7XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBfaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbnZhciBfZ2V0TWFwRGF0YSA9IGdldE1hcERhdGE7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IF9nZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9tYXBDYWNoZURlbGV0ZSA9IG1hcENhY2hlRGVsZXRlO1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBfZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG52YXIgX21hcENhY2hlR2V0ID0gbWFwQ2FjaGVHZXQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBfZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG52YXIgX21hcENhY2hlSGFzID0gbWFwQ2FjaGVIYXM7XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IF9nZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBfbWFwQ2FjaGVTZXQgPSBtYXBDYWNoZVNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IF9tYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IF9tYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBfbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gX21hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IF9tYXBDYWNoZVNldDtcblxudmFyIF9NYXBDYWNoZSA9IE1hcENhY2hlO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAqXG4gKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogdmFsdWVzKG90aGVyKTtcbiAqIC8vID0+IFszLCA0XVxuICpcbiAqIG9iamVjdC5hID0gMjtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBfTWFwQ2FjaGUpO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxubWVtb2l6ZS5DYWNoZSA9IF9NYXBDYWNoZTtcblxudmFyIG1lbW9pemVfMSA9IG1lbW9pemU7XG5cbnZhciBNRUFTVVJFTUVOVF9FTEVNRU5UX0lEID0gJ19fcmVhY3Rfc3ZnX3RleHRfbWVhc3VyZW1lbnRfaWQnO1xuXG5mdW5jdGlvbiBnZXRTdHJpbmdXaWR0aChzdHIsIHN0eWxlKSB7XG4gIHRyeSB7XG4gICAgLy8gQ2FsY3VsYXRlIGxlbmd0aCBvZiBlYWNoIHdvcmQgdG8gYmUgdXNlZCB0byBkZXRlcm1pbmUgbnVtYmVyIG9mIHdvcmRzIHBlciBsaW5lXG4gICAgdmFyIHRleHRFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKE1FQVNVUkVNRU5UX0VMRU1FTlRfSUQpO1xuICAgIGlmICghdGV4dEVsKSB7XG4gICAgICB2YXIgc3ZnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdzdmcnKTtcbiAgICAgIHN2Zy5zdHlsZS53aWR0aCA9IDA7XG4gICAgICBzdmcuc3R5bGUuaGVpZ2h0ID0gMDtcbiAgICAgIHN2Zy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICBzdmcuc3R5bGUudG9wID0gJy0xMDAlJztcbiAgICAgIHN2Zy5zdHlsZS5sZWZ0ID0gJy0xMDAlJztcbiAgICAgIHRleHRFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAndGV4dCcpO1xuICAgICAgdGV4dEVsLnNldEF0dHJpYnV0ZSgnaWQnLCBNRUFTVVJFTUVOVF9FTEVNRU5UX0lEKTtcbiAgICAgIHN2Zy5hcHBlbmRDaGlsZCh0ZXh0RWwpO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzdmcpO1xuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24odGV4dEVsLnN0eWxlLCBzdHlsZSk7XG4gICAgdGV4dEVsLnRleHRDb250ZW50ID0gc3RyO1xuICAgIHJldHVybiB0ZXh0RWwuZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG52YXIgZ2V0U3RyaW5nV2lkdGgkMSA9IG1lbW9pemVfMShnZXRTdHJpbmdXaWR0aCwgZnVuY3Rpb24gKHN0ciwgc3R5bGUpIHtcbiAgcmV0dXJuIHN0ciArICdfJyArIEpTT04uc3RyaW5naWZ5KHN0eWxlKTtcbn0pO1xuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxudmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxudmFyIGluaGVyaXRzID0gZnVuY3Rpb24gKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufTtcblxudmFyIG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG9iaiwga2V5cykge1xuICB2YXIgdGFyZ2V0ID0ge307XG5cbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlO1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlO1xuICAgIHRhcmdldFtpXSA9IG9ialtpXTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG52YXIgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiA9IGZ1bmN0aW9uIChzZWxmLCBjYWxsKSB7XG4gIGlmICghc2VsZikge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmO1xufTtcblxudmFyIFRleHQgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhUZXh0LCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBUZXh0KHByb3BzKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dCk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChUZXh0Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVGV4dCkpLmNhbGwodGhpcywgcHJvcHMpKTtcblxuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgd29yZHNCeUxpbmVzOiBbXVxuICAgIH07XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoVGV4dCwgW3tcbiAgICBrZXk6ICdjb21wb25lbnRXaWxsTW91bnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgICB0aGlzLnVwZGF0ZVdvcmRzQnlMaW5lcyh0aGlzLnByb3BzLCB0cnVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgIHZhciBuZWVkQ2FsY3VsYXRlID0gdGhpcy5wcm9wcy5jaGlsZHJlbiAhPT0gbmV4dFByb3BzLmNoaWxkcmVuIHx8IHRoaXMucHJvcHMuc3R5bGUgIT09IG5leHRQcm9wcy5zdHlsZTtcbiAgICAgIHRoaXMudXBkYXRlV29yZHNCeUxpbmVzKG5leHRQcm9wcywgbmVlZENhbGN1bGF0ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlV29yZHNCeUxpbmVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlV29yZHNCeUxpbmVzKHByb3BzLCBuZWVkQ2FsY3VsYXRlKSB7XG4gICAgICAvLyBPbmx5IHBlcmZvcm0gY2FsY3VsYXRpb25zIGlmIHVzaW5nIGZlYXR1cmVzIHRoYXQgcmVxdWlyZSB0aGVtIChtdWx0aWxpbmUsIHNjYWxlVG9GaXQpXG4gICAgICBpZiAocHJvcHMud2lkdGggfHwgcHJvcHMuc2NhbGVUb0ZpdCkge1xuICAgICAgICBpZiAobmVlZENhbGN1bGF0ZSkge1xuICAgICAgICAgIHZhciB3b3JkcyA9IHByb3BzLmNoaWxkcmVuID8gcHJvcHMuY2hpbGRyZW4udG9TdHJpbmcoKS5zcGxpdCgvXFxzKy8pIDogW107XG5cbiAgICAgICAgICB0aGlzLndvcmRzV2l0aENvbXB1dGVkV2lkdGggPSB3b3Jkcy5tYXAoZnVuY3Rpb24gKHdvcmQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHdvcmQ6IHdvcmQsXG4gICAgICAgICAgICAgIHdpZHRoOiBnZXRTdHJpbmdXaWR0aCQxKHdvcmQsIHByb3BzLnN0eWxlKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLnNwYWNlV2lkdGggPSBnZXRTdHJpbmdXaWR0aCQxKCdcXHhBMCcsIHByb3BzLnN0eWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB3b3Jkc0J5TGluZXMgPSB0aGlzLmNhbGN1bGF0ZVdvcmRzQnlMaW5lcyh0aGlzLndvcmRzV2l0aENvbXB1dGVkV2lkdGgsIHRoaXMuc3BhY2VXaWR0aCwgcHJvcHMud2lkdGgpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgd29yZHNCeUxpbmVzOiB3b3Jkc0J5TGluZXMgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnVwZGF0ZVdvcmRzV2l0aG91dENhbGN1bGF0ZShwcm9wcyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlV29yZHNXaXRob3V0Q2FsY3VsYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlV29yZHNXaXRob3V0Q2FsY3VsYXRlKHByb3BzKSB7XG4gICAgICB2YXIgd29yZHMgPSBwcm9wcy5jaGlsZHJlbiA/IHByb3BzLmNoaWxkcmVuLnRvU3RyaW5nKCkuc3BsaXQoL1xccysvKSA6IFtdO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IHdvcmRzQnlMaW5lczogW3sgd29yZHM6IHdvcmRzIH1dIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NhbGN1bGF0ZVdvcmRzQnlMaW5lcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZVdvcmRzQnlMaW5lcyh3b3Jkc1dpdGhDb21wdXRlZFdpZHRoLCBzcGFjZVdpZHRoLCBsaW5lV2lkdGgpIHtcbiAgICAgIHZhciBzY2FsZVRvRml0ID0gdGhpcy5wcm9wcy5zY2FsZVRvRml0O1xuXG4gICAgICByZXR1cm4gd29yZHNXaXRoQ29tcHV0ZWRXaWR0aC5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgX3JlZikge1xuICAgICAgICB2YXIgd29yZCA9IF9yZWYud29yZCxcbiAgICAgICAgICAgIHdpZHRoID0gX3JlZi53aWR0aDtcblxuICAgICAgICB2YXIgY3VycmVudExpbmUgPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGlmIChjdXJyZW50TGluZSAmJiAobGluZVdpZHRoID09IG51bGwgfHwgc2NhbGVUb0ZpdCB8fCBjdXJyZW50TGluZS53aWR0aCArIHdpZHRoICsgc3BhY2VXaWR0aCA8IGxpbmVXaWR0aCkpIHtcbiAgICAgICAgICAvLyBXb3JkIGNhbiBiZSBhZGRlZCB0byBhbiBleGlzdGluZyBsaW5lXG4gICAgICAgICAgY3VycmVudExpbmUud29yZHMucHVzaCh3b3JkKTtcbiAgICAgICAgICBjdXJyZW50TGluZS53aWR0aCArPSB3aWR0aCArIHNwYWNlV2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQWRkIGZpcnN0IHdvcmQgdG8gbGluZSBvciB3b3JkIGlzIHRvbyBsb25nIHRvIHNjYWxlVG9GaXQgb24gZXhpc3RpbmcgbGluZVxuICAgICAgICAgIHZhciBuZXdMaW5lID0geyB3b3JkczogW3dvcmRdLCB3aWR0aDogd2lkdGggfTtcbiAgICAgICAgICByZXN1bHQucHVzaChuZXdMaW5lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LCBbXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVuZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgZHggPSBfcHJvcHMuZHgsXG4gICAgICAgICAgZHkgPSBfcHJvcHMuZHksXG4gICAgICAgICAgdGV4dEFuY2hvciA9IF9wcm9wcy50ZXh0QW5jaG9yLFxuICAgICAgICAgIHZlcnRpY2FsQW5jaG9yID0gX3Byb3BzLnZlcnRpY2FsQW5jaG9yLFxuICAgICAgICAgIHNjYWxlVG9GaXQgPSBfcHJvcHMuc2NhbGVUb0ZpdCxcbiAgICAgICAgICBhbmdsZSA9IF9wcm9wcy5hbmdsZSxcbiAgICAgICAgICBsaW5lSGVpZ2h0ID0gX3Byb3BzLmxpbmVIZWlnaHQsXG4gICAgICAgICAgY2FwSGVpZ2h0ID0gX3Byb3BzLmNhcEhlaWdodCxcbiAgICAgICAgICBpbm5lclJlZiA9IF9wcm9wcy5pbm5lclJlZixcbiAgICAgICAgICB0ZXh0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcHJvcHMsIFsnZHgnLCAnZHknLCAndGV4dEFuY2hvcicsICd2ZXJ0aWNhbEFuY2hvcicsICdzY2FsZVRvRml0JywgJ2FuZ2xlJywgJ2xpbmVIZWlnaHQnLCAnY2FwSGVpZ2h0JywgJ2lubmVyUmVmJ10pO1xuICAgICAgdmFyIHdvcmRzQnlMaW5lcyA9IHRoaXMuc3RhdGUud29yZHNCeUxpbmVzO1xuXG5cbiAgICAgIHZhciB4ID0gdGV4dFByb3BzLng7XG4gICAgICB2YXIgeSA9IHRleHRQcm9wcy55O1xuXG4gICAgICB2YXIgc3RhcnREeSA9IHZvaWQgMDtcbiAgICAgIHN3aXRjaCAodmVydGljYWxBbmNob3IpIHtcbiAgICAgICAgY2FzZSAnc3RhcnQnOlxuICAgICAgICAgIHN0YXJ0RHkgPSByZWR1Y2VDU1NDYWxjKCdjYWxjKCcgKyBjYXBIZWlnaHQgKyAnKScpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICAgIHN0YXJ0RHkgPSByZWR1Y2VDU1NDYWxjKCdjYWxjKCcgKyAod29yZHNCeUxpbmVzLmxlbmd0aCAtIDEpIC8gMiArICcgKiAtJyArIGxpbmVIZWlnaHQgKyAnICsgKCcgKyBjYXBIZWlnaHQgKyAnIC8gMikpJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgc3RhcnREeSA9IHJlZHVjZUNTU0NhbGMoJ2NhbGMoJyArICh3b3Jkc0J5TGluZXMubGVuZ3RoIC0gMSkgKyAnICogLScgKyBsaW5lSGVpZ2h0ICsgJyknKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdmFyIHRyYW5zZm9ybXMgPSBbXTtcbiAgICAgIGlmIChzY2FsZVRvRml0ICYmIHdvcmRzQnlMaW5lcy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGxpbmVXaWR0aCA9IHdvcmRzQnlMaW5lc1swXS53aWR0aDtcbiAgICAgICAgdmFyIHN4ID0gdGhpcy5wcm9wcy53aWR0aCAvIGxpbmVXaWR0aDtcbiAgICAgICAgdmFyIHN5ID0gc3g7XG4gICAgICAgIHZhciBvcmlnaW5YID0geCAtIHN4ICogeDtcbiAgICAgICAgdmFyIG9yaWdpblkgPSB5IC0gc3kgKiB5O1xuICAgICAgICB0cmFuc2Zvcm1zLnB1c2goJ21hdHJpeCgnICsgc3ggKyAnLCAwLCAwLCAnICsgc3kgKyAnLCAnICsgb3JpZ2luWCArICcsICcgKyBvcmlnaW5ZICsgJyknKTtcbiAgICAgIH1cbiAgICAgIGlmIChhbmdsZSkge1xuICAgICAgICB0cmFuc2Zvcm1zLnB1c2goJ3JvdGF0ZSgnICsgYW5nbGUgKyAnLCAnICsgeCArICcsICcgKyB5ICsgJyknKTtcbiAgICAgIH1cbiAgICAgIGlmICh0cmFuc2Zvcm1zLmxlbmd0aCkge1xuICAgICAgICB0ZXh0UHJvcHMudHJhbnNmb3JtID0gdHJhbnNmb3Jtcy5qb2luKCcgJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAnc3ZnJyxcbiAgICAgICAge1xuICAgICAgICAgIHJlZjogaW5uZXJSZWYsXG4gICAgICAgICAgeDogZHgsXG4gICAgICAgICAgeTogZHksXG4gICAgICAgICAgZm9udFNpemU6IHRleHRQcm9wcy5mb250U2l6ZSxcbiAgICAgICAgICBzdHlsZTogeyBvdmVyZmxvdzogJ3Zpc2libGUnIH1cbiAgICAgICAgfSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAndGV4dCcsXG4gICAgICAgICAgX2V4dGVuZHMoe30sIHRleHRQcm9wcywgeyB0ZXh0QW5jaG9yOiB0ZXh0QW5jaG9yIH0pLFxuICAgICAgICAgIHdvcmRzQnlMaW5lcy5tYXAoZnVuY3Rpb24gKGxpbmUsIGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgJ3RzcGFuJyxcbiAgICAgICAgICAgICAgeyB4OiB4LCBkeTogaW5kZXggPT09IDAgPyBzdGFydER5IDogbGluZUhlaWdodCwga2V5OiBpbmRleCB9LFxuICAgICAgICAgICAgICBsaW5lLndvcmRzLmpvaW4oJyAnKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVGV4dDtcbn0oQ29tcG9uZW50KTtcblxuVGV4dC5kZWZhdWx0UHJvcHMgPSB7XG4gIHg6IDAsXG4gIHk6IDAsXG4gIGR4OiAwLFxuICBkeTogMCxcbiAgbGluZUhlaWdodDogJzFlbScsXG4gIGNhcEhlaWdodDogJzAuNzFlbScsIC8vIE1hZ2ljIG51bWJlciBmcm9tIGQzXG4gIHNjYWxlVG9GaXQ6IGZhbHNlLFxuICB0ZXh0QW5jaG9yOiAnc3RhcnQnLFxuICB2ZXJ0aWNhbEFuY2hvcjogJ2VuZCcgLy8gZGVmYXVsdCBTVkcgYmVoYXZpb3Jcbn07XG5cblRleHQucHJvcFR5cGVzID0ge1xuICBzY2FsZVRvRml0OiBwcm9wVHlwZXMuYm9vbCxcbiAgYW5nbGU6IHByb3BUeXBlcy5udW1iZXIsXG4gIHRleHRBbmNob3I6IHByb3BUeXBlcy5vbmVPZihbJ3N0YXJ0JywgJ21pZGRsZScsICdlbmQnLCAnaW5oZXJpdCddKSxcbiAgdmVydGljYWxBbmNob3I6IHByb3BUeXBlcy5vbmVPZihbJ3N0YXJ0JywgJ21pZGRsZScsICdlbmQnXSksXG4gIHN0eWxlOiBwcm9wVHlwZXMub2JqZWN0LFxuICBpbm5lclJlZjogcHJvcFR5cGVzLmZ1bmNcbn07XG5cbmV4cG9ydCB7IFRleHQsIGdldFN0cmluZ1dpZHRoJDEgYXMgZ2V0U3RyaW5nV2lkdGggfTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREEyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1944\n")},1945:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return convertScaleToDataUIScale; });\nfunction isCompatibleDomainOrRange(array) {\n    return (typeof array !== 'undefined' &&\n        array.length > 0 &&\n        (typeof array[0] === 'string' || typeof array[0] === 'number'));\n}\n/**\n * Convert encodeable scale object into @data-ui's scale config\n * @param scale\n */\nfunction convertScaleToDataUIScale(scale) {\n    const { type, domain, range } = scale;\n    let outputType;\n    if (type === 'linear' || type === 'time' || type === 'band') {\n        outputType = type;\n    }\n    else if (type === 'utc') {\n        outputType = 'timeUtc';\n    }\n    else {\n        throw new Error(`Unsupported scale type: ${type}`);\n    }\n    const output = { type: outputType };\n    if (isCompatibleDomainOrRange(domain)) {\n        output.domain = domain;\n    }\n    if (isCompatibleDomainOrRange(range)) {\n        output.range = range;\n    }\n    if ('nice' in scale && typeof scale.nice === 'boolean') {\n        output.nice = scale.nice;\n    }\n    if ('paddingInner' in scale && typeof scale.paddingInner !== 'undefined') {\n        output.paddingInner = scale.paddingInner;\n    }\n    if ('paddingOuter' in scale && typeof scale.paddingOuter !== 'undefined') {\n        output.paddingOuter = scale.paddingOuter;\n    }\n    return output;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk0NS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wcmVzZXQtY2hhcnQteHkvc3JjL3V0aWxzL2NvbnZlcnRTY2FsZVRvRGF0YVVJU2NhbGVTaGFwZS50cz8wNDdmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFZhbHVlLCBTY2FsZUNvbmZpZyB9IGZyb20gJ2VuY29kYWJsZSc7XG5cbnR5cGUgRGF0YVVJU2NhbGVUeXBlID0gJ3RpbWUnIHwgJ3RpbWVVdGMnIHwgJ2xpbmVhcicgfCAnYmFuZCc7XG5cbmludGVyZmFjZSBEYXRhVUlTY2FsZSB7XG4gIHR5cGU6IERhdGFVSVNjYWxlVHlwZTtcbiAgZG9tYWluPzogbnVtYmVyW10gfCBzdHJpbmdbXTtcbiAgaW5jbHVkZVplcm8/OiBib29sZWFuO1xuICBuaWNlPzogYm9vbGVhbjtcbiAgcGFkZGluZ0lubmVyPzogbnVtYmVyO1xuICBwYWRkaW5nT3V0ZXI/OiBudW1iZXI7XG4gIHJhbmdlPzogbnVtYmVyW10gfCBzdHJpbmdbXTtcbiAgcmFuZ2VSb3VuZD86IG51bWJlcltdIHwgc3RyaW5nW107XG59XG5cbmZ1bmN0aW9uIGlzQ29tcGF0aWJsZURvbWFpbk9yUmFuZ2UoXG4gIGFycmF5OiBTY2FsZUNvbmZpZ1snZG9tYWluJ10gfCBTY2FsZUNvbmZpZ1sncmFuZ2UnXSxcbik6IGFycmF5IGlzIG51bWJlcltdIHwgc3RyaW5nW10ge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBhcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICBhcnJheS5sZW5ndGggPiAwICYmXG4gICAgKHR5cGVvZiBhcnJheVswXSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGFycmF5WzBdID09PSAnbnVtYmVyJylcbiAgKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGVuY29kZWFibGUgc2NhbGUgb2JqZWN0IGludG8gQGRhdGEtdWkncyBzY2FsZSBjb25maWdcbiAqIEBwYXJhbSBzY2FsZVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb252ZXJ0U2NhbGVUb0RhdGFVSVNjYWxlPE91dHB1dCBleHRlbmRzIFZhbHVlPihcbiAgc2NhbGU6IFNjYWxlQ29uZmlnPE91dHB1dD4sXG4pIHtcbiAgY29uc3QgeyB0eXBlLCBkb21haW4sIHJhbmdlIH0gPSBzY2FsZTtcblxuICBsZXQgb3V0cHV0VHlwZTogRGF0YVVJU2NhbGVUeXBlO1xuXG4gIGlmICh0eXBlID09PSAnbGluZWFyJyB8fCB0eXBlID09PSAndGltZScgfHwgdHlwZSA9PT0gJ2JhbmQnKSB7XG4gICAgb3V0cHV0VHlwZSA9IHR5cGU7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3V0YycpIHtcbiAgICBvdXRwdXRUeXBlID0gJ3RpbWVVdGMnO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgc2NhbGUgdHlwZTogJHt0eXBlfWApO1xuICB9XG5cbiAgY29uc3Qgb3V0cHV0OiBEYXRhVUlTY2FsZSA9IHsgdHlwZTogb3V0cHV0VHlwZSB9O1xuICBpZiAoaXNDb21wYXRpYmxlRG9tYWluT3JSYW5nZShkb21haW4pKSB7XG4gICAgb3V0cHV0LmRvbWFpbiA9IGRvbWFpbjtcbiAgfVxuICBpZiAoaXNDb21wYXRpYmxlRG9tYWluT3JSYW5nZShyYW5nZSkpIHtcbiAgICBvdXRwdXQucmFuZ2UgPSByYW5nZTtcbiAgfVxuICBpZiAoJ25pY2UnIGluIHNjYWxlICYmIHR5cGVvZiBzY2FsZS5uaWNlID09PSAnYm9vbGVhbicpIHtcbiAgICBvdXRwdXQubmljZSA9IHNjYWxlLm5pY2U7XG4gIH1cbiAgaWYgKCdwYWRkaW5nSW5uZXInIGluIHNjYWxlICYmIHR5cGVvZiBzY2FsZS5wYWRkaW5nSW5uZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgb3V0cHV0LnBhZGRpbmdJbm5lciA9IHNjYWxlLnBhZGRpbmdJbm5lcjtcbiAgfVxuICBpZiAoJ3BhZGRpbmdPdXRlcicgaW4gc2NhbGUgJiYgdHlwZW9mIHNjYWxlLnBhZGRpbmdPdXRlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBvdXRwdXQucGFkZGluZ091dGVyID0gc2NhbGUucGFkZGluZ091dGVyO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBZUE7QUFBQTtBQUdBO0FBRUE7QUFDQTtBQUVBO0FBRUE7OztBQUdBO0FBQ0E7QUFHQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1945\n")},1946:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"a\", function() { return /* binding */ createXYChartLayoutWithTheme; });\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react/index.js\nvar react = __webpack_require__(0);\nvar react_default = /*#__PURE__*/__webpack_require__.n(react);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/prop-types/index.js\nvar prop_types = __webpack_require__(57);\nvar prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/classnames/index.js\nvar classnames = __webpack_require__(75);\nvar classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-shape/src/arc.js\nvar arc = __webpack_require__(2156);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-shape/src/pie.js + 2 modules\nvar pie = __webpack_require__(2227);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-shape/src/line.js\nvar line = __webpack_require__(1949);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-shape/src/lineRadial.js\nvar lineRadial = __webpack_require__(1950);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-shape/src/area.js\nvar src_area = __webpack_require__(2114);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-shape/src/stack.js\nvar stack = __webpack_require__(2158);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-shape/src/order/ascending.js\nvar ascending = __webpack_require__(1951);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-shape/src/order/descending.js\nvar descending = __webpack_require__(2160);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-shape/src/order/insideOut.js\nvar insideOut = __webpack_require__(2161);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-shape/src/order/none.js\nvar none = __webpack_require__(1919);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-shape/src/order/reverse.js\nvar order_reverse = __webpack_require__(2162);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-shape/src/offset/expand.js\nvar expand = __webpack_require__(2163);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-shape/src/offset/diverging.js\nvar diverging = __webpack_require__(2164);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-shape/src/offset/none.js\nvar offset_none = __webpack_require__(1920);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-shape/src/offset/silhouette.js\nvar silhouette = __webpack_require__(2165);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-shape/src/offset/wiggle.js\nvar wiggle = __webpack_require__(2166);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-shape/src/link/index.js\nvar src_link = __webpack_require__(1952);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/node_modules/@vx/axis/node_modules/@vx/group/dist/vx-group.es.js\n\n\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nfunction Group(_ref) {\n  var _ref$top = _ref.top,\n      top = _ref$top === undefined ? 0 : _ref$top,\n      _ref$left = _ref.left,\n      left = _ref$left === undefined ? 0 : _ref$left,\n      transform = _ref.transform,\n      className = _ref.className,\n      children = _ref.children,\n      restProps = objectWithoutProperties(_ref, ['top', 'left', 'transform', 'className', 'children']);\n\n  return react_default.a.createElement(\n    'g',\n    _extends({\n      className: classnames_default()('vx-group', className),\n      transform: transform || 'translate(' + left + ', ' + top + ')'\n    }, restProps),\n    children\n  );\n}\n\n\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/point/dist/vx-point.es.js\nvar vx_point_es = __webpack_require__(1893);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-shape/src/curve/linear.js\nvar linear = __webpack_require__(1918);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-path/src/path.js\nvar path = __webpack_require__(2472);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/node_modules/@vx/axis/node_modules/@vx/shape/dist/vx-shape.es.js\n\n\n\n\n\n\n\n\n\nfunction callOrValue(maybeFn, data) {\n  if (typeof maybeFn === 'function') {\n    return maybeFn(data);\n  }\n  return maybeFn;\n}\n\nfunction additionalProps(restProps, data) {\n  return Object.keys(restProps).reduce(function (ret, cur) {\n    ret[cur] = callOrValue(restProps[cur], data);\n    return ret;\n  }, {});\n}\n\nvar vx_shape_es_extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar vx_shape_es_objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\nfunction Arc(_ref) {\n  var className = _ref.className,\n      data = _ref.data,\n      centroid = _ref.centroid,\n      innerRadius = _ref.innerRadius,\n      outerRadius = _ref.outerRadius,\n      cornerRadius = _ref.cornerRadius,\n      startAngle = _ref.startAngle,\n      endAngle = _ref.endAngle,\n      padAngle = _ref.padAngle,\n      padRadius = _ref.padRadius,\n      restProps = vx_shape_es_objectWithoutProperties(_ref, ['className', 'data', 'centroid', 'innerRadius', 'outerRadius', 'cornerRadius', 'startAngle', 'endAngle', 'padAngle', 'padRadius']);\n\n  var arc$$1 = Object(arc[\"a\" /* default */])();\n  if (centroid) arc$$1.centroid(centroid);\n  if (innerRadius) arc$$1.innerRadius(innerRadius);\n  if (outerRadius) arc$$1.outerRadius(outerRadius);\n  if (cornerRadius) arc$$1.cornerRadius(cornerRadius);\n  if (startAngle) arc$$1.startAngle(startAngle);\n  if (endAngle) arc$$1.endAngle(endAngle);\n  if (padAngle) arc$$1.padAngle(padAngle);\n  if (padRadius) arc$$1.padRadius(padRadius);\n  return react_default.a.createElement('path', vx_shape_es_extends({ className: classnames_default()('vx-arc', className), d: arc$$1(data) }, additionalProps(restProps, data)));\n}\n\nfunction Pie(_ref) {\n  var _ref$className = _ref.className,\n      className = _ref$className === undefined ? '' : _ref$className,\n      _ref$top = _ref.top,\n      top = _ref$top === undefined ? 0 : _ref$top,\n      _ref$left = _ref.left,\n      left = _ref$left === undefined ? 0 : _ref$left,\n      data = _ref.data,\n      centroid = _ref.centroid,\n      _ref$innerRadius = _ref.innerRadius,\n      innerRadius = _ref$innerRadius === undefined ? 0 : _ref$innerRadius,\n      outerRadius = _ref.outerRadius,\n      cornerRadius = _ref.cornerRadius,\n      _ref$startAngle = _ref.startAngle,\n      startAngle = _ref$startAngle === undefined ? 0 : _ref$startAngle,\n      endAngle = _ref.endAngle,\n      padAngle = _ref.padAngle,\n      padRadius = _ref.padRadius,\n      pieSort = _ref.pieSort,\n      pieSortValues = _ref.pieSortValues,\n      pieValue = _ref.pieValue,\n      children = _ref.children,\n      restProps = vx_shape_es_objectWithoutProperties(_ref, ['className', 'top', 'left', 'data', 'centroid', 'innerRadius', 'outerRadius', 'cornerRadius', 'startAngle', 'endAngle', 'padAngle', 'padRadius', 'pieSort', 'pieSortValues', 'pieValue', 'children']);\n\n  var path$$1 = Object(arc[\"a\" /* default */])();\n  path$$1.innerRadius(innerRadius);\n  if (outerRadius) path$$1.outerRadius(outerRadius);\n  if (cornerRadius) path$$1.cornerRadius(cornerRadius);\n  if (padRadius) path$$1.padRadius(padRadius);\n  var pie$$1 = Object(pie[\"a\" /* default */])();\n  if (pieSort !== undefined) pie$$1.sort(pieSort);\n  if (pieSortValues !== undefined) pie$$1.sortValues(pieSortValues);\n  if (pieValue) pie$$1.value(pieValue);\n  if (padAngle != null) pie$$1.padAngle(padAngle);\n  if (startAngle != null) pie$$1.startAngle(startAngle);\n  if (endAngle != null) pie$$1.endAngle(endAngle);\n  var arcs = pie$$1(data);\n  var renderFunctionArg = {\n    arcs: arcs,\n    generatePathProps: function generatePathProps(arc$$1, index) {\n      return vx_shape_es_extends({\n        className: classnames_default()('vx-pie-arc', className),\n        d: path$$1(arc$$1)\n      }, additionalProps(restProps, vx_shape_es_extends({}, arc$$1, {\n        index: index,\n        centroid: centroid ? path$$1.centroid(arc$$1) : undefined\n      })));\n    },\n    generateCentroid: function generateCentroid(arc$$1) {\n      return centroid && centroid(path$$1.centroid(arc$$1), arc$$1);\n    }\n  };\n  return react_default.a.createElement(\n    Group,\n    { className: 'vx-pie-arcs-group', top: top, left: left },\n    children ? children(renderFunctionArg) : arcs.map(function (arc$$1, i) {\n      var pathProps = renderFunctionArg.generatePathProps(arc$$1, i);\n      return react_default.a.createElement(\n        'g',\n        { key: 'pie-arc-' + i },\n        react_default.a.createElement('path', pathProps),\n        renderFunctionArg.generateCentroid(arc$$1)\n      );\n    })\n  );\n}\n\nLine.propTypes = {\n  innerRef: prop_types_default.a.func\n};\n\nfunction Line(_ref) {\n  var _ref$from = _ref.from,\n      from = _ref$from === undefined ? new vx_point_es[\"Point\"]({ x: 0, y: 0 }) : _ref$from,\n      _ref$to = _ref.to,\n      to = _ref$to === undefined ? new vx_point_es[\"Point\"]({ x: 1, y: 1 }) : _ref$to,\n      _ref$stroke = _ref.stroke,\n      stroke = _ref$stroke === undefined ? 'black' : _ref$stroke,\n      _ref$strokeWidth = _ref.strokeWidth,\n      strokeWidth = _ref$strokeWidth === undefined ? 1 : _ref$strokeWidth,\n      _ref$strokeDasharray = _ref.strokeDasharray,\n      strokeDasharray = _ref$strokeDasharray === undefined ? '' : _ref$strokeDasharray,\n      _ref$transform = _ref.transform,\n      transform = _ref$transform === undefined ? '' : _ref$transform,\n      _ref$className = _ref.className,\n      className = _ref$className === undefined ? '' : _ref$className,\n      data = _ref.data,\n      innerRef = _ref.innerRef,\n      restProps = vx_shape_es_objectWithoutProperties(_ref, ['from', 'to', 'stroke', 'strokeWidth', 'strokeDasharray', 'transform', 'className', 'data', 'innerRef']);\n\n  return react_default.a.createElement('line', vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-line', className),\n    x1: from.x,\n    y1: from.y,\n    x2: to.x,\n    y2: to.y,\n    stroke: stroke,\n    strokeWidth: strokeWidth,\n    strokeDasharray: strokeDasharray,\n    transform: transform\n  }, additionalProps(restProps, data)));\n}\n\nLinePath.propTypes = {\n  innerRef: prop_types_default.a.func,\n  xScale: prop_types_default.a.func,\n  yScale: prop_types_default.a.func,\n  data: prop_types_default.a.array,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  defined: prop_types_default.a.func,\n  stroke: prop_types_default.a.string,\n  strokeWidth: prop_types_default.a.number,\n  glyph: prop_types_default.a.func,\n  curve: prop_types_default.a.func\n};\n\nfunction LinePath(_ref) {\n  var children = _ref.children,\n      data = _ref.data,\n      xScale = _ref.xScale,\n      yScale = _ref.yScale,\n      x = _ref.x,\n      y = _ref.y,\n      _ref$defined = _ref.defined,\n      defined = _ref$defined === undefined ? function () {\n    return true;\n  } : _ref$defined,\n      className = _ref.className,\n      _ref$stroke = _ref.stroke,\n      stroke = _ref$stroke === undefined ? 'steelblue' : _ref$stroke,\n      _ref$strokeWidth = _ref.strokeWidth,\n      strokeWidth = _ref$strokeWidth === undefined ? 2 : _ref$strokeWidth,\n      _ref$strokeDasharray = _ref.strokeDasharray,\n      strokeDasharray = _ref$strokeDasharray === undefined ? '' : _ref$strokeDasharray,\n      _ref$strokeDashoffset = _ref.strokeDashoffset,\n      strokeDashoffset = _ref$strokeDashoffset === undefined ? 0 : _ref$strokeDashoffset,\n      _ref$fill = _ref.fill,\n      fill = _ref$fill === undefined ? 'none' : _ref$fill,\n      _ref$curve = _ref.curve,\n      curve = _ref$curve === undefined ? linear[\"a\" /* default */] : _ref$curve,\n      glyph = _ref.glyph,\n      innerRef = _ref.innerRef,\n      restProps = vx_shape_es_objectWithoutProperties(_ref, ['children', 'data', 'xScale', 'yScale', 'x', 'y', 'defined', 'className', 'stroke', 'strokeWidth', 'strokeDasharray', 'strokeDashoffset', 'fill', 'curve', 'glyph', 'innerRef']);\n\n  var path$$1 = Object(line[\"a\" /* default */])().x(function () {\n    return xScale(x.apply(undefined, arguments));\n  }).y(function () {\n    return yScale(y.apply(undefined, arguments));\n  }).defined(defined).curve(curve);\n  if (children) return children({ path: path$$1 });\n  return react_default.a.createElement(\n    'g',\n    null,\n    react_default.a.createElement('path', vx_shape_es_extends({\n      ref: innerRef,\n      className: classnames_default()('vx-linepath', className),\n      d: path$$1(data),\n      stroke: stroke,\n      strokeWidth: strokeWidth,\n      strokeDasharray: strokeDasharray,\n      strokeDashoffset: strokeDashoffset,\n      fill: fill\n    }, additionalProps(restProps, data))),\n    glyph && react_default.a.createElement(\n      'g',\n      { className: 'vx-linepath-glyphs' },\n      data.map(glyph)\n    )\n  );\n}\n\nLineRadial.propTypes = {\n  innerRef: prop_types_default.a.func\n};\n\nfunction LineRadial(_ref) {\n  var _ref$className = _ref.className,\n      className = _ref$className === undefined ? '' : _ref$className,\n      angle = _ref.angle,\n      radius = _ref.radius,\n      defined = _ref.defined,\n      curve = _ref.curve,\n      data = _ref.data,\n      innerRef = _ref.innerRef,\n      restProps = vx_shape_es_objectWithoutProperties(_ref, ['className', 'angle', 'radius', 'defined', 'curve', 'data', 'innerRef']);\n\n  var path$$1 = Object(lineRadial[\"a\" /* default */])();\n  if (angle) path$$1.angle(angle);\n  if (radius) path$$1.radius(radius);\n  if (defined) path$$1.defined(defined);\n  if (curve) path$$1.curve(curve);\n  return react_default.a.createElement(\n    'g',\n    null,\n    react_default.a.createElement('path', vx_shape_es_extends({\n      ref: innerRef,\n      className: classnames_default()('vx-line-radial', className),\n      d: path$$1(data)\n    }, additionalProps(restProps, data)))\n  );\n}\n\nArea.propTypes = {\n  x: prop_types_default.a.func,\n  x0: prop_types_default.a.func,\n  x1: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  y0: prop_types_default.a.func,\n  y1: prop_types_default.a.func,\n  xScale: prop_types_default.a.func,\n  yScale: prop_types_default.a.func,\n  data: prop_types_default.a.array,\n  defined: prop_types_default.a.func,\n  className: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.bool, prop_types_default.a.object, prop_types_default.a.array]),\n  innerRef: prop_types_default.a.func,\n  strokeDasharray: prop_types_default.a.string,\n  strokeWidth: prop_types_default.a.number,\n  stroke: prop_types_default.a.string,\n  fill: prop_types_default.a.string,\n  curve: prop_types_default.a.func\n};\n\nfunction Area(_ref) {\n  var children = _ref.children,\n      x = _ref.x,\n      x0 = _ref.x0,\n      x1 = _ref.x1,\n      y = _ref.y,\n      y0 = _ref.y0,\n      y1 = _ref.y1,\n      xScale = _ref.xScale,\n      yScale = _ref.yScale,\n      _ref$data = _ref.data,\n      data = _ref$data === undefined ? [] : _ref$data,\n      _ref$defined = _ref.defined,\n      defined = _ref$defined === undefined ? function () {\n    return true;\n  } : _ref$defined,\n      className = _ref.className,\n      strokeDasharray = _ref.strokeDasharray,\n      _ref$strokeWidth = _ref.strokeWidth,\n      strokeWidth = _ref$strokeWidth === undefined ? 2 : _ref$strokeWidth,\n      _ref$stroke = _ref.stroke,\n      stroke = _ref$stroke === undefined ? 'black' : _ref$stroke,\n      _ref$fill = _ref.fill,\n      fill = _ref$fill === undefined ? 'rgba(0,0,0,0.3)' : _ref$fill,\n      curve = _ref.curve,\n      innerRef = _ref.innerRef,\n      restProps = vx_shape_es_objectWithoutProperties(_ref, ['children', 'x', 'x0', 'x1', 'y', 'y0', 'y1', 'xScale', 'yScale', 'data', 'defined', 'className', 'strokeDasharray', 'strokeWidth', 'stroke', 'fill', 'curve', 'innerRef']);\n\n  var path$$1 = Object(src_area[\"a\" /* default */])();\n  if (x) path$$1.x(function () {\n    return xScale(x.apply(undefined, arguments));\n  });\n  if (x0) path$$1.x0(function () {\n    return xScale(x0.apply(undefined, arguments));\n  });\n  if (x1) path$$1.x1(function () {\n    return xScale(x1.apply(undefined, arguments));\n  });\n  if (y) path$$1.y(function () {\n    return yScale(y.apply(undefined, arguments));\n  });\n  if (y0) path$$1.y0(function () {\n    return yScale(y0.apply(undefined, arguments));\n  });\n  if (y1) path$$1.y1(function () {\n    return yScale(y1.apply(undefined, arguments));\n  });\n  if (defined) path$$1.defined(defined);\n  if (curve) path$$1.curve(curve);\n  if (children) return children({ path: path$$1 });\n  return react_default.a.createElement(\n    'g',\n    null,\n    react_default.a.createElement('path', vx_shape_es_extends({\n      ref: innerRef,\n      className: classnames_default()('vx-area', className),\n      d: path$$1(data),\n      stroke: stroke,\n      strokeWidth: strokeWidth,\n      strokeDasharray: strokeDasharray,\n      fill: fill\n    }, additionalProps(restProps, data)))\n  );\n}\n\nAreaClosed.propTypes = {\n  innerRef: prop_types_default.a.func\n};\n\nfunction AreaClosed(_ref) {\n  var x = _ref.x,\n      y = _ref.y,\n      y0 = _ref.y0,\n      xScale = _ref.xScale,\n      yScale = _ref.yScale,\n      data = _ref.data,\n      _ref$defined = _ref.defined,\n      defined = _ref$defined === undefined ? function () {\n    return true;\n  } : _ref$defined,\n      className = _ref.className,\n      strokeDasharray = _ref.strokeDasharray,\n      _ref$strokeWidth = _ref.strokeWidth,\n      strokeWidth = _ref$strokeWidth === undefined ? 2 : _ref$strokeWidth,\n      _ref$stroke = _ref.stroke,\n      stroke = _ref$stroke === undefined ? 'black' : _ref$stroke,\n      _ref$fill = _ref.fill,\n      fill = _ref$fill === undefined ? 'rgba(0,0,0,0.3)' : _ref$fill,\n      curve = _ref.curve,\n      innerRef = _ref.innerRef,\n      restProps = vx_shape_es_objectWithoutProperties(_ref, ['x', 'y', 'y0', 'xScale', 'yScale', 'data', 'defined', 'className', 'strokeDasharray', 'strokeWidth', 'stroke', 'fill', 'curve', 'innerRef']);\n\n  var path$$1 = Object(src_area[\"a\" /* default */])().x(function () {\n    return xScale(x.apply(undefined, arguments));\n  }).y0(y0 || yScale.range()[0]).y1(function () {\n    return yScale(y.apply(undefined, arguments));\n  }).defined(defined);\n  if (curve) path$$1.curve(curve);\n  return react_default.a.createElement(\n    'g',\n    null,\n    react_default.a.createElement('path', vx_shape_es_extends({\n      ref: innerRef,\n      className: classnames_default()('vx-area-closed', className),\n      d: path$$1(data),\n      stroke: stroke,\n      strokeWidth: strokeWidth,\n      strokeDasharray: strokeDasharray,\n      fill: fill\n    }, additionalProps(restProps, data)))\n  );\n}\n\nfunction AreaStack(_ref) {\n  var className = _ref.className,\n      _ref$top = _ref.top,\n      _ref$left = _ref.left,\n      keys = _ref.keys,\n      data = _ref.data,\n      curve = _ref.curve,\n      defined = _ref.defined,\n      x = _ref.x,\n      x0 = _ref.x0,\n      x1 = _ref.x1,\n      y0 = _ref.y0,\n      y1 = _ref.y1,\n      glyph = _ref.glyph,\n      _ref$reverse = _ref.reverse,\n      reverse = _ref$reverse === undefined ? false : _ref$reverse,\n      restProps = vx_shape_es_objectWithoutProperties(_ref, ['className', 'top', 'left', 'keys', 'data', 'curve', 'defined', 'x', 'x0', 'x1', 'y0', 'y1', 'glyph', 'reverse']);\n\n  var stack$$1 = Object(stack[\"a\" /* default */])();\n  if (keys) stack$$1.keys(keys);\n\n  var path$$1 = Object(src_area[\"a\" /* default */])();\n  if (x) path$$1.x(x);\n  if (x0) path$$1.x0(x0);\n  if (x1) path$$1.x1(x1);\n  if (y0) path$$1.y0(y0);\n  if (y1) path$$1.y1(y1);\n  if (curve) path$$1.curve(curve);\n  if (defined) path$$1.defined(defined);\n\n  var seriesData = stack$$1(data);\n  if (reverse) seriesData.reverse();\n\n  return react_default.a.createElement(\n    'g',\n    null,\n    seriesData.map(function (series, i) {\n      return react_default.a.createElement('path', vx_shape_es_extends({\n        className: classnames_default()('vx-area-stack', className),\n        key: 'area-stack-' + i + '-' + (series.key || ''),\n        d: path$$1(series)\n      }, additionalProps(restProps, {\n        datum: series[i],\n        index: i,\n        series: series\n      })));\n    }),\n    !!glyph && react_default.a.createElement(\n      'g',\n      { className: 'vx-area-stack-glyphs' },\n      data.map(glyph)\n    )\n  );\n}\n\nBar.propTypes = {\n  innerRef: prop_types_default.a.func\n};\n\nfunction Bar(_ref) {\n  var className = _ref.className,\n      innerRef = _ref.innerRef,\n      data = _ref.data,\n      _ref$x = _ref.x,\n      x = _ref$x === undefined ? 0 : _ref$x,\n      _ref$y = _ref.y,\n      y = _ref$y === undefined ? 0 : _ref$y,\n      width = _ref.width,\n      height = _ref.height,\n      rx = _ref.rx,\n      ry = _ref.ry,\n      _ref$fill = _ref.fill,\n      fill = _ref$fill === undefined ? 'steelblue' : _ref$fill,\n      fillOpacity = _ref.fillOpacity,\n      stroke = _ref.stroke,\n      strokeWidth = _ref.strokeWidth,\n      strokeDasharray = _ref.strokeDasharray,\n      strokeLinecap = _ref.strokeLinecap,\n      strokeLinejoin = _ref.strokeLinejoin,\n      strokeMiterlimit = _ref.strokeMiterlimit,\n      strokeOpacity = _ref.strokeOpacity,\n      restProps = vx_shape_es_objectWithoutProperties(_ref, ['className', 'innerRef', 'data', 'x', 'y', 'width', 'height', 'rx', 'ry', 'fill', 'fillOpacity', 'stroke', 'strokeWidth', 'strokeDasharray', 'strokeLinecap', 'strokeLinejoin', 'strokeMiterlimit', 'strokeOpacity']);\n\n  return react_default.a.createElement('rect', vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-bar', className),\n    x: x,\n    y: y,\n    width: width,\n    height: height,\n    rx: rx,\n    ry: ry,\n    fill: fill,\n    fillOpacity: fillOpacity,\n    stroke: stroke,\n    strokeWidth: strokeWidth,\n    strokeDasharray: strokeDasharray,\n    strokeLinecap: strokeLinecap,\n    strokeLinejoin: strokeLinejoin,\n    strokeMiterlimit: strokeMiterlimit,\n    strokeOpacity: strokeOpacity\n  }, additionalProps(restProps, data)));\n}\n\nfunction BarGroup(_ref) {\n  var data = _ref.data,\n      className = _ref.className,\n      top = _ref.top,\n      left = _ref.left,\n      x0 = _ref.x0,\n      x0Scale = _ref.x0Scale,\n      x1Scale = _ref.x1Scale,\n      yScale = _ref.yScale,\n      zScale = _ref.zScale,\n      keys = _ref.keys,\n      height = _ref.height,\n      restProps = vx_shape_es_objectWithoutProperties(_ref, ['data', 'className', 'top', 'left', 'x0', 'x0Scale', 'x1Scale', 'yScale', 'zScale', 'keys', 'height']);\n\n  var format = x0Scale.tickFormat ? x0Scale.tickFormat() : function (d) {\n    return d;\n  };\n  return react_default.a.createElement(\n    Group,\n    { className: classnames_default()('vx-bar-group', className), top: top, left: left },\n    data && data.map(function (d, i) {\n      return react_default.a.createElement(\n        Group,\n        { key: 'bar-group-' + i + '-' + x0(d), left: x0Scale(x0(d)) },\n        keys && keys.map(function (key, i) {\n          var value = d[key];\n          return react_default.a.createElement(Bar, vx_shape_es_extends({\n            key: 'bar-group-bar-' + i + '-' + value + '-' + key,\n            x: x1Scale(key),\n            y: yScale(value),\n            width: x1Scale.bandwidth(),\n            height: height - yScale(value),\n            fill: zScale(key),\n            data: {\n              key: key,\n              value: value,\n              x: format(x0(d)),\n              data: d\n            }\n          }, restProps));\n        })\n      );\n    })\n  );\n}\n\nBarGroup.propTypes = {\n  data: prop_types_default.a.array.isRequired,\n  x0: prop_types_default.a.func.isRequired,\n  x0Scale: prop_types_default.a.func.isRequired,\n  x1Scale: prop_types_default.a.func.isRequired,\n  yScale: prop_types_default.a.func.isRequired,\n  zScale: prop_types_default.a.func.isRequired,\n  keys: prop_types_default.a.array.isRequired,\n  height: prop_types_default.a.number.isRequired,\n  className: prop_types_default.a.string,\n  top: prop_types_default.a.number,\n  left: prop_types_default.a.number\n};\n\nfunction BarGroupHorizontal(_ref) {\n  var data = _ref.data,\n      className = _ref.className,\n      top = _ref.top,\n      left = _ref.left,\n      y0 = _ref.y0,\n      y0Scale = _ref.y0Scale,\n      y1Scale = _ref.y1Scale,\n      xScale = _ref.xScale,\n      zScale = _ref.zScale,\n      keys = _ref.keys,\n      width = _ref.width,\n      restProps = vx_shape_es_objectWithoutProperties(_ref, ['data', 'className', 'top', 'left', 'y0', 'y0Scale', 'y1Scale', 'xScale', 'zScale', 'keys', 'width']);\n\n  var format = y0Scale.tickFormat ? y0Scale.tickFormat() : function (d) {\n    return d;\n  };\n  return react_default.a.createElement(\n    Group,\n    { className: classnames_default()('vx-bar-group-horizontal', className), top: top, left: left },\n    data && data.map(function (d, i) {\n      return react_default.a.createElement(\n        Group,\n        { key: 'bar-group-' + i + '-' + y0(d), top: y0Scale(y0(d)) },\n        keys && keys.map(function (key, i) {\n          var value = d[key];\n          return react_default.a.createElement(Bar, vx_shape_es_extends({\n            key: 'bar-group-bar-' + i + '-' + value + '-' + key,\n            x: 0,\n            y: y1Scale(key),\n            width: width - xScale(value),\n            height: y1Scale.bandwidth(),\n            fill: zScale(key),\n            data: {\n              key: key,\n              value: value,\n              y: format(y0(d)),\n              data: d\n            }\n          }, restProps));\n        })\n      );\n    })\n  );\n}\n\nBarGroupHorizontal.propTypes = {\n  data: prop_types_default.a.array.isRequired,\n  y0: prop_types_default.a.func.isRequired,\n  y0Scale: prop_types_default.a.func.isRequired,\n  y1Scale: prop_types_default.a.func.isRequired,\n  xScale: prop_types_default.a.func.isRequired,\n  zScale: prop_types_default.a.func.isRequired,\n  keys: prop_types_default.a.array.isRequired,\n  width: prop_types_default.a.number.isRequired,\n  className: prop_types_default.a.string,\n  top: prop_types_default.a.number,\n  left: prop_types_default.a.number\n};\n\nfunction BarStack(_ref) {\n  var data = _ref.data,\n      className = _ref.className,\n      top = _ref.top,\n      left = _ref.left,\n      x = _ref.x,\n      xScale = _ref.xScale,\n      yScale = _ref.yScale,\n      zScale = _ref.zScale,\n      keys = _ref.keys,\n      height = _ref.height,\n      restProps = vx_shape_es_objectWithoutProperties(_ref, ['data', 'className', 'top', 'left', 'x', 'xScale', 'yScale', 'zScale', 'keys', 'height']);\n\n  var series = Object(stack[\"a\" /* default */])().keys(keys)(data);\n  var format = xScale.tickFormat ? xScale.tickFormat() : function (d) {\n    return d;\n  };\n  var bandwidth = xScale.bandwidth();\n  var step = xScale.step();\n  var paddingInner = xScale.paddingInner();\n  var paddingOuter = xScale.paddingOuter();\n  return react_default.a.createElement(\n    Group,\n    { className: classnames_default()('vx-bar-stack', className), top: top, left: left },\n    series && series.map(function (s, i) {\n      return react_default.a.createElement(\n        Group,\n        { key: 'vx-bar-stack-' + i },\n        s.map(function (d, ii) {\n          var barHeight = yScale(d[0]) - yScale(d[1]);\n          return react_default.a.createElement(Bar, vx_shape_es_extends({\n            key: 'bar-group-bar-' + i + '-' + ii + '-' + s.key,\n            x: xScale(x(d.data)),\n            y: yScale(d[1]),\n            width: bandwidth,\n            height: barHeight,\n            fill: zScale(s.key),\n            data: {\n              bandwidth: bandwidth,\n              paddingInner: paddingInner,\n              paddingOuter: paddingOuter,\n              step: step,\n              key: s.key,\n              value: d[1],\n              height: barHeight,\n              width: bandwidth,\n              x: x(d.data),\n              xFormatted: format(x(d.data)),\n              data: d.data\n            }\n          }, restProps));\n        })\n      );\n    })\n  );\n}\n\nBarStack.propTypes = {\n  data: prop_types_default.a.array.isRequired,\n  x: prop_types_default.a.func.isRequired,\n  xScale: prop_types_default.a.func.isRequired,\n  yScale: prop_types_default.a.func.isRequired,\n  zScale: prop_types_default.a.func.isRequired,\n  keys: prop_types_default.a.array.isRequired,\n  className: prop_types_default.a.string,\n  top: prop_types_default.a.number,\n  left: prop_types_default.a.number\n};\n\nfunction BarStackHorizontal(_ref) {\n  var data = _ref.data,\n      className = _ref.className,\n      top = _ref.top,\n      left = _ref.left,\n      y = _ref.y,\n      xScale = _ref.xScale,\n      yScale = _ref.yScale,\n      zScale = _ref.zScale,\n      keys = _ref.keys,\n      height = _ref.height,\n      restProps = vx_shape_es_objectWithoutProperties(_ref, ['data', 'className', 'top', 'left', 'y', 'xScale', 'yScale', 'zScale', 'keys', 'height']);\n\n  var series = Object(stack[\"a\" /* default */])().keys(keys)(data);\n  var format = yScale.tickFormat ? yScale.tickFormat() : function (d) {\n    return d;\n  };\n  var bandwidth = yScale.bandwidth();\n  var step = yScale.step();\n  var paddingInner = yScale.paddingInner();\n  var paddingOuter = yScale.paddingOuter();\n  return react_default.a.createElement(\n    Group,\n    { className: classnames_default()('vx-bar-stack-horizontal', className), top: top, left: left },\n    series && series.map(function (s, i) {\n      return react_default.a.createElement(\n        Group,\n        { key: 'vx-bar-stack-horizontal-' + i },\n        s.map(function (d, ii) {\n          var barWidth = xScale(d[1]) - xScale(d[0]);\n          return react_default.a.createElement(Bar, vx_shape_es_extends({\n            key: 'bar-group-bar-' + i + '-' + ii + '-' + s.key,\n            x: xScale(d[0]),\n            y: yScale(y(d.data)),\n            width: barWidth,\n            height: bandwidth,\n            fill: zScale(s.key),\n            data: {\n              bandwidth: bandwidth,\n              paddingInner: paddingInner,\n              paddingOuter: paddingOuter,\n              step: step,\n              key: s.key,\n              value: d[0],\n              height: bandwidth,\n              width: barWidth,\n              y: y(d.data),\n              yFormatted: format(y(d.data)),\n              data: d.data\n            }\n          }, restProps));\n        })\n      );\n    })\n  );\n}\n\nBarStackHorizontal.propTypes = {\n  data: prop_types_default.a.array.isRequired,\n  y: prop_types_default.a.func.isRequired,\n  xScale: prop_types_default.a.func.isRequired,\n  yScale: prop_types_default.a.func.isRequired,\n  zScale: prop_types_default.a.func.isRequired,\n  keys: prop_types_default.a.array.isRequired,\n  className: prop_types_default.a.string,\n  top: prop_types_default.a.number,\n  left: prop_types_default.a.number\n};\n\nvar STACK_ORDERS = {\n  ascending: ascending[\"a\" /* default */],\n  descending: descending[\"a\" /* default */],\n  insideout: insideOut[\"a\" /* default */],\n  none: none[\"a\" /* default */],\n  reverse: order_reverse[\"a\" /* default */]\n};\n\nvar STACK_ORDER_NAMES = Object.keys(STACK_ORDERS);\n\nfunction stackOrder(order) {\n  return STACK_ORDERS[order] || STACK_ORDERS.none;\n}\n\nvar STACK_OFFSETS = {\n  expand: expand[\"a\" /* default */],\n  diverging: diverging[\"a\" /* default */],\n  none: offset_none[\"a\" /* default */],\n  silhouette: silhouette[\"a\" /* default */],\n  wiggle: wiggle[\"a\" /* default */]\n};\n\nvar STACK_OFFSET_NAMES = Object.keys(STACK_OFFSETS);\n\nfunction stackOffset(offset) {\n  return STACK_OFFSETS[offset] || STACK_OFFSETS.none;\n}\n\nfunction Stack(_ref) {\n  var className = _ref.className,\n      _ref$top = _ref.top,\n      top = _ref$top === undefined ? 0 : _ref$top,\n      _ref$left = _ref.left,\n      left = _ref$left === undefined ? 0 : _ref$left,\n      keys = _ref.keys,\n      data = _ref.data,\n      curve = _ref.curve,\n      defined = _ref.defined,\n      x = _ref.x,\n      x0 = _ref.x0,\n      x1 = _ref.x1,\n      y0 = _ref.y0,\n      y1 = _ref.y1,\n      value = _ref.value,\n      order = _ref.order,\n      offset = _ref.offset,\n      render = _ref.render,\n      _ref$reverse = _ref.reverse,\n      reverse = _ref$reverse === undefined ? false : _ref$reverse,\n      restProps = vx_shape_es_objectWithoutProperties(_ref, ['className', 'top', 'left', 'keys', 'data', 'curve', 'defined', 'x', 'x0', 'x1', 'y0', 'y1', 'value', 'order', 'offset', 'render', 'reverse']);\n\n  var stack$$1 = Object(stack[\"a\" /* default */])();\n  if (keys) stack$$1.keys(keys);\n  if (value) stack$$1.value(value);\n  if (order) stack$$1.order(stackOrder(order));\n  if (offset) stack$$1.offset(stackOffset(offset));\n\n  var path$$1 = Object(src_area[\"a\" /* default */])();\n  if (x) path$$1.x(x);\n  if (x0) path$$1.x0(x0);\n  if (x1) path$$1.x1(x1);\n  if (y0) path$$1.y0(y0);\n  if (y1) path$$1.y1(y1);\n  if (curve) path$$1.curve(curve);\n  if (defined) path$$1.defined(defined);\n\n  var seriesData = stack$$1(data);\n  if (reverse) seriesData.reverse();\n\n  if (render) return react_default.a.createElement(\n    Group,\n    { top: top, left: left },\n    render({ seriesData: seriesData, path: path$$1 })\n  );\n\n  return react_default.a.createElement(\n    Group,\n    { top: top, left: left },\n    seriesData.map(function (series, i) {\n      return react_default.a.createElement('path', vx_shape_es_extends({\n        className: classnames_default()('vx-stack', className),\n        key: 'stack-' + i + '-' + (series.key || ''),\n        d: path$$1(series)\n      }, additionalProps(restProps, {\n        datum: series[i],\n        index: i,\n        series: series\n      })));\n    })\n  );\n}\n\nvar degreesToRadians = function degreesToRadians(degrees) {\n  return Math.PI / 180 * degrees;\n};\n\nfunction pathHorizontalDiagonal(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y;\n\n  return function (data) {\n    var link = Object(src_link[\"a\" /* linkHorizontal */])();\n    link.x(x);\n    link.y(y);\n    link.source(source);\n    link.target(target);\n    return link(data);\n  };\n}\n\nLinkHorizontal.propTypes = {\n  innerRef: prop_types_default.a.func,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func,\n  path: prop_types_default.a.func\n};\n\nfunction LinkHorizontal(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.y;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.x;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || pathHorizontalDiagonal({ source: source, target: target, x: x, y: y });\n  return react_default.a.createElement('path', vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link-horizontal', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathVerticalDiagonal(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y;\n\n  return function (data) {\n    var link = Object(src_link[\"c\" /* linkVertical */])();\n    link.x(x);\n    link.y(y);\n    link.source(source);\n    link.target(target);\n    return link(data);\n  };\n}\n\nLinkVertical.propTypes = {\n  innerRef: prop_types_default.a.func,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func,\n  path: prop_types_default.a.func\n};\n\nfunction LinkVertical(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.x;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.y;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || pathVerticalDiagonal({ source: source, target: target, x: x, y: y });\n  return react_default.a.createElement('path', vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link-vertical', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathRadialDiagonal(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      angle = _ref.angle,\n      radius = _ref.radius;\n\n  return function (data) {\n    var link = Object(src_link[\"b\" /* linkRadial */])();\n    link.angle(angle);\n    link.radius(radius);\n    link.source(source);\n    link.target(target);\n    return link(data);\n  };\n}\n\nLinkRadial.propTypes = {\n  innerRef: prop_types_default.a.func,\n  angle: prop_types_default.a.func,\n  radius: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func,\n  path: prop_types_default.a.func\n};\n\nfunction LinkRadial(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$angle = _ref2.angle,\n      angle = _ref2$angle === undefined ? function (d) {\n    return d.x;\n  } : _ref2$angle,\n      _ref2$radius = _ref2.radius,\n      radius = _ref2$radius === undefined ? function (d) {\n    return d.y;\n  } : _ref2$radius,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'angle', 'radius', 'source', 'target']);\n\n  path$$1 = path$$1 || pathRadialDiagonal({ source: source, target: target, angle: angle, radius: radius });\n  return react_default.a.createElement('path', vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link-radius', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathHorizontalCurve(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y,\n      percent = _ref.percent;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sx = x(sourceData);\n    var sy = y(sourceData);\n    var tx = x(targetData);\n    var ty = y(targetData);\n\n    var dx = tx - sx;\n    var dy = ty - sy;\n    var ix = percent * (dx + dy);\n    var iy = percent * (dy - dx);\n\n    var path$$1 = Object(path[\"a\" /* default */])();\n    path$$1.moveTo(sx, sy);\n    path$$1.bezierCurveTo(sx + ix, sy + iy, tx + iy, ty - ix, tx, ty);\n\n    return path$$1.toString();\n  };\n}\n\nLinkHorizontalCurve.propTypes = {\n  innerRef: prop_types_default.a.func,\n  percent: prop_types_default.a.number,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func,\n  path: prop_types_default.a.func\n};\n\nfunction LinkHorizontalCurve(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.y;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.x;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      _ref2$percent = _ref2.percent,\n      percent = _ref2$percent === undefined ? 0.2 : _ref2$percent,\n      restProps = vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target', 'percent']);\n\n  path$$1 = path$$1 || pathHorizontalCurve({ source: source, target: target, x: x, y: y, percent: percent });\n  return react_default.a.createElement('path', vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathVerticalCurve(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y,\n      percent = _ref.percent;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sx = x(sourceData);\n    var sy = y(sourceData);\n    var tx = x(targetData);\n    var ty = y(targetData);\n\n    var dx = tx - sx;\n    var dy = ty - sy;\n    var ix = percent * (dx + dy);\n    var iy = percent * (dy - dx);\n\n    var path$$1 = Object(path[\"a\" /* default */])();\n    path$$1.moveTo(sx, sy);\n    path$$1.bezierCurveTo(sx + ix, sy + iy, tx + iy, ty - ix, tx, ty);\n\n    return path$$1.toString();\n  };\n}\n\nLinkVerticalCurve.propTypes = {\n  innerRef: prop_types_default.a.func,\n  percent: prop_types_default.a.number,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func,\n  path: prop_types_default.a.func\n};\n\nfunction LinkVerticalCurve(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.x;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.y;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      _ref2$percent = _ref2.percent,\n      percent = _ref2$percent === undefined ? 0.2 : _ref2$percent,\n      restProps = vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target', 'percent']);\n\n  path$$1 = path$$1 || pathVerticalCurve({ source: source, target: target, x: x, y: y, percent: percent });\n  return react_default.a.createElement('path', vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathRadialCurve(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y,\n      percent = _ref.percent;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sa = x(sourceData) - Math.PI / 2;\n    var sr = y(sourceData);\n    var ta = x(targetData) - Math.PI / 2;\n    var tr = y(targetData);\n\n    var sc = Math.cos(sa);\n    var ss = Math.sin(sa);\n    var tc = Math.cos(ta);\n    var ts = Math.sin(ta);\n\n    var sx = sr * sc;\n    var sy = sr * ss;\n    var tx = tr * tc;\n    var ty = tr * ts;\n\n    var dx = tx - sx;\n    var dy = ty - sy;\n    var ix = percent * (dx + dy);\n    var iy = percent * (dy - dx);\n\n    var path$$1 = Object(path[\"a\" /* default */])();\n    path$$1.moveTo(sx, sy);\n    path$$1.bezierCurveTo(sx + ix, sy + iy, tx + iy, ty - ix, tx, ty);\n\n    return path$$1.toString();\n  };\n}\n\nLinkRadialCurve.propTypes = {\n  innerRef: prop_types_default.a.func,\n  percent: prop_types_default.a.number,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func,\n  path: prop_types_default.a.func\n};\n\nfunction LinkRadialCurve(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.x;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.y;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      _ref2$percent = _ref2.percent,\n      percent = _ref2$percent === undefined ? 0.2 : _ref2$percent,\n      restProps = vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target', 'percent']);\n\n  path$$1 = path$$1 || pathRadialCurve({ source: source, target: target, x: x, y: y, percent: percent });\n  return react_default.a.createElement('path', vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathHorizontalLine(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sx = x(sourceData);\n    var sy = y(sourceData);\n    var tx = x(targetData);\n    var ty = y(targetData);\n\n    var path$$1 = Object(path[\"a\" /* default */])();\n    path$$1.moveTo(sx, sy);\n    path$$1.lineTo(tx, ty);\n\n    return path$$1.toString();\n  };\n}\n\nLinkHorizontalLine.propTypes = {\n  innerRef: prop_types_default.a.func,\n  path: prop_types_default.a.func,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func\n};\n\nfunction LinkHorizontalLine(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.y;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.x;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || pathHorizontalLine({ source: source, target: target, x: x, y: y });\n  return react_default.a.createElement('path', vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathVerticalLine(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sx = x(sourceData);\n    var sy = y(sourceData);\n    var tx = x(targetData);\n    var ty = y(targetData);\n\n    var path$$1 = Object(path[\"a\" /* default */])();\n    path$$1.moveTo(sx, sy);\n    path$$1.lineTo(tx, ty);\n\n    return path$$1.toString();\n  };\n}\n\nLinkVerticalLine.propTypes = {\n  innerRef: prop_types_default.a.func,\n  path: prop_types_default.a.func,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func\n};\n\nfunction LinkVerticalLine(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.x;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.y;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || pathVerticalLine({ source: source, target: target, x: x, y: y });\n  return react_default.a.createElement('path', vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathRadialLine(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sa = x(sourceData) - Math.PI / 2;\n    var sr = y(sourceData);\n    var ta = x(targetData) - Math.PI / 2;\n    var tr = y(targetData);\n\n    var sc = Math.cos(sa);\n    var ss = Math.sin(sa);\n    var tc = Math.cos(ta);\n    var ts = Math.sin(ta);\n\n    var path$$1 = Object(path[\"a\" /* default */])();\n    path$$1.moveTo(sr * sc, sr * ss);\n    path$$1.lineTo(tr * tc, tr * ts);\n\n    return path$$1.toString();\n  };\n}\n\nLinkRadialStep.propTypes = {\n  innerRef: prop_types_default.a.func,\n  path: prop_types_default.a.func,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func\n};\n\nfunction LinkRadialStep(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.x;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.y;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || pathRadialLine({ source: source, target: target, x: x, y: y });\n  return react_default.a.createElement('path', vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathHorizontalStep(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y,\n      percent = _ref.percent;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sx = x(sourceData);\n    var sy = y(sourceData);\n    var tx = x(targetData);\n    var ty = y(targetData);\n\n    var path$$1 = Object(path[\"a\" /* default */])();\n    path$$1.moveTo(sx, sy);\n    path$$1.lineTo(sx + (tx - sx) * percent, sy);\n    path$$1.lineTo(sx + (tx - sx) * percent, ty);\n    path$$1.lineTo(tx, ty);\n\n    return path$$1.toString();\n  };\n}\n\nLinkHorizontalStep.propTypes = {\n  innerRef: prop_types_default.a.func,\n  percent: prop_types_default.a.number,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func,\n  path: prop_types_default.a.func\n};\n\nfunction LinkHorizontalStep(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$percent = _ref2.percent,\n      percent = _ref2$percent === undefined ? 0.5 : _ref2$percent,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.y;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.x;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'percent', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || pathHorizontalStep({ source: source, target: target, x: x, y: y, percent: percent });\n  return react_default.a.createElement('path', vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathVerticalStep(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y,\n      percent = _ref.percent;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sx = x(sourceData);\n    var sy = y(sourceData);\n    var tx = x(targetData);\n    var ty = y(targetData);\n\n    var path$$1 = Object(path[\"a\" /* default */])();\n    path$$1.moveTo(sx, sy);\n    path$$1.lineTo(sx, sy + (ty - sy) * percent);\n    path$$1.lineTo(tx, sy + (ty - sy) * percent);\n    path$$1.lineTo(tx, ty);\n\n    return path$$1.toString();\n  };\n}\n\nLinkVerticalStep.propTypes = {\n  innerRef: prop_types_default.a.func,\n  percent: prop_types_default.a.number,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func,\n  path: prop_types_default.a.func\n};\n\nfunction LinkVerticalStep(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$percent = _ref2.percent,\n      percent = _ref2$percent === undefined ? 0.5 : _ref2$percent,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.x;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.y;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'percent', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || pathVerticalStep({ source: source, target: target, x: x, y: y, percent: percent });\n  return react_default.a.createElement('path', vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathRadialStep(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sx = x(sourceData);\n    var sy = y(sourceData);\n    var tx = x(targetData);\n    var ty = y(targetData);\n\n    var sa = sx - Math.PI / 2;\n    var sr = sy;\n    var ta = tx - Math.PI / 2;\n    var tr = ty;\n\n    var sc = Math.cos(sa);\n    var ss = Math.sin(sa);\n    var tc = Math.cos(ta);\n    var ts = Math.sin(ta);\n    var sf = Math.abs(ta - sa) > Math.PI ? ta <= sa : ta > sa;\n\n    return '\\n      M' + sr * sc + ',' + sr * ss + '\\n      A' + sr + ',' + sr + ',0,0,' + (sf ? 1 : 0) + ',' + sr * tc + ',' + sr * ts + '\\n      L' + tr * tc + ',' + tr * ts + '\\n    ';\n  };\n}\n\nLinkRadialStep$1.propTypes = {\n  innerRef: prop_types_default.a.func,\n  x: prop_types_default.a.func,\n  y: prop_types_default.a.func,\n  source: prop_types_default.a.func,\n  target: prop_types_default.a.func,\n  path: prop_types_default.a.func\n};\n\nfunction LinkRadialStep$1(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.x;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.y;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = vx_shape_es_objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || pathRadialStep({ source: source, target: target, x: x, y: y });\n  return react_default.a.createElement('path', vx_shape_es_extends({\n    ref: innerRef,\n    className: classnames_default()('vx-link', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nPolygon.propTypes = {\n  sides: prop_types_default.a.number.isRequired,\n  size: prop_types_default.a.number.isRequired,\n  className: prop_types_default.a.string,\n  rotate: prop_types_default.a.number,\n  fill: prop_types_default.a.string,\n  strokeDasharray: prop_types_default.a.string,\n  strokeWidth: prop_types_default.a.number,\n  stroke: prop_types_default.a.string\n};\n\nvar vx_shape_es_getPoint = function getPoint(_ref) {\n  var sides = _ref.sides,\n      size = _ref.size,\n      center = _ref.center,\n      rotate = _ref.rotate,\n      side = _ref.side;\n\n  var degrees = 360 / sides * side - rotate;\n  var radians = degreesToRadians(degrees);\n\n  return new vx_point_es[\"Point\"]({\n    x: center.x + size * Math.cos(radians),\n    y: center.y + size * Math.sin(radians)\n  });\n};\n\nvar getPoints = function getPoints(_ref2) {\n  var sides = _ref2.sides,\n      size = _ref2.size,\n      center = _ref2.center,\n      rotate = _ref2.rotate;\n  return [].concat(toConsumableArray(Array(sides).keys())).map(function (side) {\n    return vx_shape_es_getPoint({\n      sides: sides,\n      size: size,\n      center: center,\n      rotate: rotate,\n      side: side\n    });\n  });\n};\n\nfunction Polygon(_ref3) {\n  var sides = _ref3.sides,\n      _ref3$size = _ref3.size,\n      size = _ref3$size === undefined ? 25 : _ref3$size,\n      _ref3$center = _ref3.center,\n      center = _ref3$center === undefined ? new vx_point_es[\"Point\"]({ x: 0, y: 0 }) : _ref3$center,\n      _ref3$rotate = _ref3.rotate,\n      rotate = _ref3$rotate === undefined ? 0 : _ref3$rotate,\n      className = _ref3.className,\n      clickHandler = _ref3.clickHandler,\n      fill = _ref3.fill,\n      strokeDasharray = _ref3.strokeDasharray,\n      _ref3$strokeWidth = _ref3.strokeWidth,\n      _ref3$stroke = _ref3.stroke,\n      restProps = vx_shape_es_objectWithoutProperties(_ref3, ['sides', 'size', 'center', 'rotate', 'className', 'clickHandler', 'fill', 'strokeDasharray', 'strokeWidth', 'stroke']);\n\n  var points = getPoints({\n    sides: sides,\n    size: size,\n    center: center,\n    rotate: rotate\n  }).map(function (p) {\n    return p.toArray();\n  }).join(' ');\n\n  return react_default.a.createElement('polygon', vx_shape_es_extends({ points: points, className: className, fill: fill }, restProps));\n}\n\n\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/node_modules/@vx/axis/node_modules/@vx/text/dist/vx-text.es.js\nvar vx_text_es = __webpack_require__(1944);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/node_modules/@vx/axis/dist/vx-axis.es.js\n\n\n\n\n\n\n\n\nfunction vx_axis_es_center(scale) {\n  var offset = scale.bandwidth() / 2;\n  if (scale.round()) offset = Math.round(offset);\n  return function (d) {\n    return scale(d) + offset;\n  };\n}\n\nfunction identity(x) {\n  return x;\n}\n\nvar ORIENT = {\n  top: 'top',\n  left: 'left',\n  right: 'right',\n  bottom: 'bottom'\n};\n\nfunction labelTransform(_ref) {\n  var labelOffset = _ref.labelOffset,\n      labelProps = _ref.labelProps,\n      orientation = _ref.orientation,\n      range = _ref.range,\n      tickLabelFontSize = _ref.tickLabelFontSize,\n      tickLength = _ref.tickLength;\n\n  var sign = orientation === ORIENT.left || orientation === ORIENT.top ? -1 : 1;\n\n  var x = void 0,\n      y = void 0,\n      transform = null;\n  if (orientation === ORIENT.top || orientation === ORIENT.bottom) {\n    x = (range[0] + range[range.length - 1]) / 2;\n    y = sign * (tickLength + labelOffset + tickLabelFontSize + (orientation === ORIENT.bottom ? labelProps.fontSize : 0));\n  } else {\n    x = sign * ((range[0] + range[range.length - 1]) / 2);\n    y = -(tickLength + labelOffset);\n    transform = 'rotate(' + sign * 90 + ')';\n  }\n\n  return { x: x, y: y, transform: transform };\n}\n\nvar vx_axis_es_extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar propTypes = {\n  axisClassName: prop_types_default.a.string,\n  axisLineClassName: prop_types_default.a.string,\n  hideAxisLine: prop_types_default.a.bool,\n  hideTicks: prop_types_default.a.bool,\n  hideZero: prop_types_default.a.bool,\n  label: prop_types_default.a.string,\n  labelClassName: prop_types_default.a.string,\n  labelOffset: prop_types_default.a.number,\n  labelProps: prop_types_default.a.object,\n  left: prop_types_default.a.number,\n  numTicks: prop_types_default.a.number,\n  orientation: prop_types_default.a.oneOf([ORIENT.top, ORIENT.right, ORIENT.bottom, ORIENT.left]),\n  rangePadding: prop_types_default.a.number,\n  scale: prop_types_default.a.func.isRequired,\n  stroke: prop_types_default.a.string,\n  strokeWidth: prop_types_default.a.number,\n  strokeDasharray: prop_types_default.a.string,\n  tickClassName: prop_types_default.a.string,\n  tickFormat: prop_types_default.a.func,\n  tickLabelProps: prop_types_default.a.func,\n  tickLength: prop_types_default.a.number,\n  tickStroke: prop_types_default.a.string,\n  tickTransform: prop_types_default.a.string,\n  tickValues: prop_types_default.a.array,\n  tickComponent: prop_types_default.a.func,\n  top: prop_types_default.a.number,\n  children: prop_types_default.a.func\n};\n\nfunction vx_axis_es_Axis(_ref) {\n  var children = _ref.children,\n      axisClassName = _ref.axisClassName,\n      axisLineClassName = _ref.axisLineClassName,\n      _ref$hideAxisLine = _ref.hideAxisLine,\n      hideAxisLine = _ref$hideAxisLine === undefined ? false : _ref$hideAxisLine,\n      _ref$hideTicks = _ref.hideTicks,\n      hideTicks = _ref$hideTicks === undefined ? false : _ref$hideTicks,\n      _ref$hideZero = _ref.hideZero,\n      hideZero = _ref$hideZero === undefined ? false : _ref$hideZero,\n      _ref$label = _ref.label,\n      label = _ref$label === undefined ? '' : _ref$label,\n      labelClassName = _ref.labelClassName,\n      _ref$labelOffset = _ref.labelOffset,\n      labelOffset = _ref$labelOffset === undefined ? 14 : _ref$labelOffset,\n      _ref$labelProps = _ref.labelProps,\n      labelProps = _ref$labelProps === undefined ? {\n    textAnchor: 'middle',\n    fontFamily: 'Arial',\n    fontSize: 10,\n    fill: 'black'\n  } : _ref$labelProps,\n      _ref$left = _ref.left,\n      left = _ref$left === undefined ? 0 : _ref$left,\n      _ref$numTicks = _ref.numTicks,\n      numTicks = _ref$numTicks === undefined ? 10 : _ref$numTicks,\n      _ref$orientation = _ref.orientation,\n      orientation = _ref$orientation === undefined ? ORIENT.bottom : _ref$orientation,\n      _ref$rangePadding = _ref.rangePadding,\n      rangePadding = _ref$rangePadding === undefined ? 0 : _ref$rangePadding,\n      scale = _ref.scale,\n      _ref$stroke = _ref.stroke,\n      stroke = _ref$stroke === undefined ? 'black' : _ref$stroke,\n      _ref$strokeWidth = _ref.strokeWidth,\n      strokeWidth = _ref$strokeWidth === undefined ? 1 : _ref$strokeWidth,\n      strokeDasharray = _ref.strokeDasharray,\n      tickClassName = _ref.tickClassName,\n      tickFormat = _ref.tickFormat,\n      _ref$tickLabelProps = _ref.tickLabelProps,\n      tickLabelProps = _ref$tickLabelProps === undefined ? function (tickValue, index) {\n    return {\n      textAnchor: 'middle',\n      fontFamily: 'Arial',\n      fontSize: 10,\n      fill: 'black'\n    };\n  } : _ref$tickLabelProps,\n      _ref$tickLength = _ref.tickLength,\n      tickLength = _ref$tickLength === undefined ? 8 : _ref$tickLength,\n      _ref$tickStroke = _ref.tickStroke,\n      tickStroke = _ref$tickStroke === undefined ? 'black' : _ref$tickStroke,\n      tickTransform = _ref.tickTransform,\n      tickValues = _ref.tickValues,\n      tickComponent = _ref.tickComponent,\n      _ref$top = _ref.top,\n      top = _ref$top === undefined ? 0 : _ref$top;\n\n  var values = scale.ticks ? scale.ticks(numTicks) : scale.domain();\n  if (tickValues) values = tickValues;\n  var format = scale.tickFormat ? scale.tickFormat() : identity;\n  if (tickFormat) format = tickFormat;\n\n  var range = scale.range();\n  var range0 = range[0] + 0.5 - rangePadding;\n  var range1 = range[range.length - 1] + 0.5 + rangePadding;\n\n  var horizontal = orientation !== ORIENT.left && orientation !== ORIENT.right;\n  var isLeft = orientation === ORIENT.left;\n  var isTop = orientation === ORIENT.top;\n  var tickSign = isLeft || isTop ? -1 : 1;\n\n  var position = (scale.bandwidth ? vx_axis_es_center : identity)(scale.copy());\n\n  var axisFromPoint = new vx_point_es[\"Point\"]({\n    x: horizontal ? range0 : 0,\n    y: horizontal ? 0 : range0\n  });\n  var axisToPoint = new vx_point_es[\"Point\"]({\n    x: horizontal ? range1 : 0,\n    y: horizontal ? 0 : range1\n  });\n\n  var tickLabelFontSize = 10; // track the max tick label size to compute label offset\n\n  if (!!children) {\n    return react_default.a.createElement(\n      Group,\n      { className: classnames_default()('vx-axis', axisClassName), top: top, left: left },\n      children({\n        axisFromPoint: axisFromPoint,\n        axisToPoint: axisToPoint,\n        horizontal: horizontal,\n        tickSign: tickSign,\n        numTicks: numTicks,\n        label: label,\n        rangePadding: rangePadding,\n        tickLength: tickLength,\n        tickFormat: format,\n        tickPosition: position,\n        ticks: values.map(function (value, index) {\n          var from = new vx_point_es[\"Point\"]({\n            x: horizontal ? position(value) : 0,\n            y: horizontal ? 0 : position(value)\n          });\n          var to = new vx_point_es[\"Point\"]({\n            x: horizontal ? position(value) : tickSign * tickLength,\n            y: horizontal ? tickLength * tickSign : position(value)\n          });\n          return {\n            value: value,\n            index: index,\n            from: from,\n            to: to,\n            formattedValue: format(value, index)\n          };\n        })\n      })\n    );\n  }\n\n  return react_default.a.createElement(\n    Group,\n    { className: classnames_default()('vx-axis', axisClassName), top: top, left: left },\n    values.map(function (val, index) {\n      if (hideZero && val === 0) return null;\n\n      var tickFromPoint = new vx_point_es[\"Point\"]({\n        x: horizontal ? position(val) : 0,\n        y: horizontal ? 0 : position(val)\n      });\n      var tickToPoint = new vx_point_es[\"Point\"]({\n        x: horizontal ? position(val) : tickSign * tickLength,\n        y: horizontal ? tickLength * tickSign : position(val)\n      });\n\n      var tickLabelPropsObj = tickLabelProps(val, index);\n      tickLabelFontSize = Math.max(tickLabelFontSize, tickLabelPropsObj.fontSize || 0);\n\n      return react_default.a.createElement(\n        Group,\n        {\n          key: 'vx-tick-' + val + '-' + index,\n          className: classnames_default()('vx-axis-tick', tickClassName),\n          transform: tickTransform\n        },\n        !hideTicks && react_default.a.createElement(Line, { from: tickFromPoint, to: tickToPoint, stroke: tickStroke }),\n        tickComponent ? tickComponent(vx_axis_es_extends({\n          x: tickToPoint.x,\n          y: tickToPoint.y + (horizontal && !isTop ? tickLabelFontSize : 0),\n          formattedValue: format(val, index)\n        }, tickLabelPropsObj)) : react_default.a.createElement(\n          vx_text_es[\"a\" /* Text */],\n          vx_axis_es_extends({\n            x: tickToPoint.x,\n            y: tickToPoint.y + (horizontal && !isTop ? tickLabelFontSize : 0)\n          }, tickLabelPropsObj),\n          format(val, index)\n        )\n      );\n    }),\n    !hideAxisLine && react_default.a.createElement(Line, {\n      className: classnames_default()('vx-axis-line', axisLineClassName),\n      from: axisFromPoint,\n      to: axisToPoint,\n      stroke: stroke,\n      strokeWidth: strokeWidth,\n      strokeDasharray: strokeDasharray\n    }),\n    label && react_default.a.createElement(\n      vx_text_es[\"a\" /* Text */],\n      vx_axis_es_extends({\n        className: classnames_default()('vx-axis-label', labelClassName)\n      }, labelTransform({\n        labelOffset: labelOffset,\n        labelProps: labelProps,\n        orientation: orientation,\n        range: range,\n        tickLabelFontSize: tickLabelFontSize,\n        tickLength: tickLength\n      }), labelProps),\n      label\n    )\n  );\n}\n\nvx_axis_es_Axis.propTypes = propTypes;\n\nvar propTypes$1 = {\n  axisClassName: prop_types_default.a.string,\n  axisLineClassName: prop_types_default.a.string,\n  hideAxisLine: prop_types_default.a.bool,\n  hideTicks: prop_types_default.a.bool,\n  hideZero: prop_types_default.a.bool,\n  label: prop_types_default.a.string,\n  labelClassName: prop_types_default.a.string,\n  labelOffset: prop_types_default.a.number,\n  labelProps: prop_types_default.a.object,\n  left: prop_types_default.a.number,\n  numTicks: prop_types_default.a.number,\n  rangePadding: prop_types_default.a.number,\n  scale: prop_types_default.a.func.isRequired,\n  stroke: prop_types_default.a.string,\n  strokeWidth: prop_types_default.a.number,\n  strokeDasharray: prop_types_default.a.string,\n  tickClassName: prop_types_default.a.string,\n  tickFormat: prop_types_default.a.func,\n  tickLabelProps: prop_types_default.a.func,\n  tickLength: prop_types_default.a.number,\n  tickStroke: prop_types_default.a.string,\n  tickTransform: prop_types_default.a.string,\n  tickValues: prop_types_default.a.array,\n  tickComponent: prop_types_default.a.func,\n  top: prop_types_default.a.number,\n  children: prop_types_default.a.func\n};\n\nfunction AxisLeft(_ref) {\n  var children = _ref.children,\n      axisClassName = _ref.axisClassName,\n      axisLineClassName = _ref.axisLineClassName,\n      hideAxisLine = _ref.hideAxisLine,\n      hideTicks = _ref.hideTicks,\n      hideZero = _ref.hideZero,\n      label = _ref.label,\n      labelClassName = _ref.labelClassName,\n      _ref$labelOffset = _ref.labelOffset,\n      labelOffset = _ref$labelOffset === undefined ? 36 : _ref$labelOffset,\n      labelProps = _ref.labelProps,\n      left = _ref.left,\n      numTicks = _ref.numTicks,\n      rangePadding = _ref.rangePadding,\n      scale = _ref.scale,\n      stroke = _ref.stroke,\n      strokeWidth = _ref.strokeWidth,\n      strokeDasharray = _ref.strokeDasharray,\n      tickClassName = _ref.tickClassName,\n      tickFormat = _ref.tickFormat,\n      _ref$tickLabelProps = _ref.tickLabelProps,\n      tickLabelProps = _ref$tickLabelProps === undefined ? function (_ref2) {\n    var tick = _ref2.tick,\n        index = _ref2.index;\n    return {\n      dx: '-0.25em',\n      dy: '0.25em',\n      fill: 'black',\n      fontFamily: 'Arial',\n      fontSize: 10,\n      textAnchor: 'end'\n    };\n  } : _ref$tickLabelProps,\n      _ref$tickLength = _ref.tickLength,\n      tickLength = _ref$tickLength === undefined ? 8 : _ref$tickLength,\n      tickStroke = _ref.tickStroke,\n      tickTransform = _ref.tickTransform,\n      tickValues = _ref.tickValues,\n      tickComponent = _ref.tickComponent,\n      top = _ref.top;\n\n  return react_default.a.createElement(vx_axis_es_Axis, {\n    axisClassName: classnames_default()('vx-axis-left', axisClassName),\n    axisLineClassName: axisLineClassName,\n    hideAxisLine: hideAxisLine,\n    hideTicks: hideTicks,\n    hideZero: hideZero,\n    label: label,\n    labelClassName: labelClassName,\n    labelOffset: labelOffset,\n    labelProps: labelProps,\n    left: left,\n    numTicks: numTicks,\n    orientation: ORIENT.left,\n    rangePadding: rangePadding,\n    scale: scale,\n    stroke: stroke,\n    strokeWidth: strokeWidth,\n    strokeDasharray: strokeDasharray,\n    tickClassName: tickClassName,\n    tickFormat: tickFormat,\n    tickLabelProps: tickLabelProps,\n    tickLength: tickLength,\n    tickStroke: tickStroke,\n    tickTransform: tickTransform,\n    tickValues: tickValues,\n    tickComponent: tickComponent,\n    top: top,\n    children: children\n  });\n}\n\nAxisLeft.propTypes = propTypes$1;\n\nvar propTypes$2 = {\n  axisClassName: prop_types_default.a.string,\n  axisLineClassName: prop_types_default.a.string,\n  hideAxisLine: prop_types_default.a.bool,\n  hideTicks: prop_types_default.a.bool,\n  hideZero: prop_types_default.a.bool,\n  label: prop_types_default.a.string,\n  labelClassName: prop_types_default.a.string,\n  labelOffset: prop_types_default.a.number,\n  labelProps: prop_types_default.a.object,\n  left: prop_types_default.a.number,\n  numTicks: prop_types_default.a.number,\n  rangePadding: prop_types_default.a.number,\n  scale: prop_types_default.a.func.isRequired,\n  stroke: prop_types_default.a.string,\n  strokeWidth: prop_types_default.a.number,\n  strokeDasharray: prop_types_default.a.string,\n  tickClassName: prop_types_default.a.string,\n  tickFormat: prop_types_default.a.func,\n  tickLabelProps: prop_types_default.a.func,\n  tickLength: prop_types_default.a.number,\n  tickStroke: prop_types_default.a.string,\n  tickTransform: prop_types_default.a.string,\n  tickValues: prop_types_default.a.array,\n  tickComponent: prop_types_default.a.func,\n  top: prop_types_default.a.number,\n  children: prop_types_default.a.func\n};\n\nfunction AxisRight(_ref) {\n  var children = _ref.children,\n      axisClassName = _ref.axisClassName,\n      axisLineClassName = _ref.axisLineClassName,\n      hideAxisLine = _ref.hideAxisLine,\n      hideTicks = _ref.hideTicks,\n      hideZero = _ref.hideZero,\n      label = _ref.label,\n      labelClassName = _ref.labelClassName,\n      _ref$labelOffset = _ref.labelOffset,\n      labelOffset = _ref$labelOffset === undefined ? 36 : _ref$labelOffset,\n      labelProps = _ref.labelProps,\n      left = _ref.left,\n      numTicks = _ref.numTicks,\n      rangePadding = _ref.rangePadding,\n      scale = _ref.scale,\n      stroke = _ref.stroke,\n      strokeWidth = _ref.strokeWidth,\n      strokeDasharray = _ref.strokeDasharray,\n      tickClassName = _ref.tickClassName,\n      tickFormat = _ref.tickFormat,\n      _ref$tickLabelProps = _ref.tickLabelProps,\n      tickLabelProps = _ref$tickLabelProps === undefined ? function (_ref2) {\n    var tick = _ref2.tick,\n        index = _ref2.index;\n    return {\n      dx: '0.25em',\n      dy: '0.25em',\n      fill: 'black',\n      fontFamily: 'Arial',\n      fontSize: 10,\n      textAnchor: 'start'\n    };\n  } : _ref$tickLabelProps,\n      _ref$tickLength = _ref.tickLength,\n      tickLength = _ref$tickLength === undefined ? 8 : _ref$tickLength,\n      tickStroke = _ref.tickStroke,\n      tickTransform = _ref.tickTransform,\n      tickValues = _ref.tickValues,\n      tickComponent = _ref.tickComponent,\n      top = _ref.top;\n\n  return react_default.a.createElement(vx_axis_es_Axis, {\n    axisClassName: classnames_default()('vx-axis-right', axisClassName),\n    axisLineClassName: axisLineClassName,\n    hideAxisLine: hideAxisLine,\n    hideTicks: hideTicks,\n    hideZero: hideZero,\n    label: label,\n    labelClassName: labelClassName,\n    labelOffset: labelOffset,\n    labelProps: labelProps,\n    left: left,\n    numTicks: numTicks,\n    orientation: ORIENT.right,\n    rangePadding: rangePadding,\n    scale: scale,\n    stroke: stroke,\n    strokeWidth: strokeWidth,\n    strokeDasharray: strokeDasharray,\n    tickClassName: tickClassName,\n    tickFormat: tickFormat,\n    tickLabelProps: tickLabelProps,\n    tickLength: tickLength,\n    tickStroke: tickStroke,\n    tickTransform: tickTransform,\n    tickValues: tickValues,\n    tickComponent: tickComponent,\n    top: top,\n    children: children\n  });\n}\n\nAxisRight.propTypes = propTypes$2;\n\nvar propTypes$3 = {\n  axisClassName: prop_types_default.a.string,\n  axisLineClassName: prop_types_default.a.string,\n  hideAxisLine: prop_types_default.a.bool,\n  hideTicks: prop_types_default.a.bool,\n  hideZero: prop_types_default.a.bool,\n  label: prop_types_default.a.string,\n  labelClassName: prop_types_default.a.string,\n  labelOffset: prop_types_default.a.number,\n  labelProps: prop_types_default.a.object,\n  left: prop_types_default.a.number,\n  numTicks: prop_types_default.a.number,\n  rangePadding: prop_types_default.a.number,\n  scale: prop_types_default.a.func.isRequired,\n  stroke: prop_types_default.a.string,\n  strokeWidth: prop_types_default.a.number,\n  strokeDasharray: prop_types_default.a.string,\n  tickClassName: prop_types_default.a.string,\n  tickFormat: prop_types_default.a.func,\n  tickLabelProps: prop_types_default.a.func,\n  tickLength: prop_types_default.a.number,\n  tickStroke: prop_types_default.a.string,\n  tickTransform: prop_types_default.a.string,\n  tickValues: prop_types_default.a.array,\n  tickComponent: prop_types_default.a.func,\n  top: prop_types_default.a.number,\n  children: prop_types_default.a.func\n};\n\nfunction AxisTop(_ref) {\n  var children = _ref.children,\n      axisClassName = _ref.axisClassName,\n      axisLineClassName = _ref.axisLineClassName,\n      hideAxisLine = _ref.hideAxisLine,\n      hideTicks = _ref.hideTicks,\n      hideZero = _ref.hideZero,\n      label = _ref.label,\n      labelClassName = _ref.labelClassName,\n      _ref$labelOffset = _ref.labelOffset,\n      labelOffset = _ref$labelOffset === undefined ? 8 : _ref$labelOffset,\n      labelProps = _ref.labelProps,\n      left = _ref.left,\n      numTicks = _ref.numTicks,\n      rangePadding = _ref.rangePadding,\n      scale = _ref.scale,\n      stroke = _ref.stroke,\n      strokeWidth = _ref.strokeWidth,\n      strokeDasharray = _ref.strokeDasharray,\n      tickClassName = _ref.tickClassName,\n      tickFormat = _ref.tickFormat,\n      _ref$tickLabelProps = _ref.tickLabelProps,\n      tickLabelProps = _ref$tickLabelProps === undefined ? function (_ref2) {\n    var tick = _ref2.tick,\n        index = _ref2.index;\n    return {\n      dy: '-0.25em',\n      fill: 'black',\n      fontFamily: 'Arial',\n      fontSize: 10,\n      textAnchor: 'middle'\n    };\n  } : _ref$tickLabelProps,\n      _ref$tickLength = _ref.tickLength,\n      tickLength = _ref$tickLength === undefined ? 8 : _ref$tickLength,\n      tickStroke = _ref.tickStroke,\n      tickTransform = _ref.tickTransform,\n      tickValues = _ref.tickValues,\n      tickComponent = _ref.tickComponent,\n      top = _ref.top;\n\n  return react_default.a.createElement(vx_axis_es_Axis, {\n    axisClassName: classnames_default()('vx-axis-top', axisClassName),\n    axisLineClassName: axisLineClassName,\n    hideAxisLine: hideAxisLine,\n    hideTicks: hideTicks,\n    hideZero: hideZero,\n    label: label,\n    labelClassName: labelClassName,\n    labelOffset: labelOffset,\n    labelProps: labelProps,\n    left: left,\n    numTicks: numTicks,\n    orientation: ORIENT.top,\n    rangePadding: rangePadding,\n    scale: scale,\n    stroke: stroke,\n    strokeWidth: strokeWidth,\n    strokeDasharray: strokeDasharray,\n    tickClassName: tickClassName,\n    tickFormat: tickFormat,\n    tickLabelProps: tickLabelProps,\n    tickLength: tickLength,\n    tickStroke: tickStroke,\n    tickTransform: tickTransform,\n    tickValues: tickValues,\n    tickComponent: tickComponent,\n    top: top,\n    children: children\n  });\n}\n\nAxisTop.propTypes = propTypes$3;\n\nvar propTypes$4 = {\n  axisClassName: prop_types_default.a.string,\n  axisLineClassName: prop_types_default.a.string,\n  hideAxisLine: prop_types_default.a.bool,\n  hideTicks: prop_types_default.a.bool,\n  hideZero: prop_types_default.a.bool,\n  label: prop_types_default.a.string,\n  labelClassName: prop_types_default.a.string,\n  labelOffset: prop_types_default.a.number,\n  labelProps: prop_types_default.a.object,\n  left: prop_types_default.a.number,\n  numTicks: prop_types_default.a.number,\n  rangePadding: prop_types_default.a.number,\n  scale: prop_types_default.a.func.isRequired,\n  stroke: prop_types_default.a.string,\n  strokeWidth: prop_types_default.a.number,\n  strokeDasharray: prop_types_default.a.string,\n  tickClassName: prop_types_default.a.string,\n  tickFormat: prop_types_default.a.func,\n  tickLabelProps: prop_types_default.a.func,\n  tickLength: prop_types_default.a.number,\n  tickStroke: prop_types_default.a.string,\n  tickTransform: prop_types_default.a.string,\n  tickValues: prop_types_default.a.array,\n  tickComponent: prop_types_default.a.func,\n  top: prop_types_default.a.number,\n  children: prop_types_default.a.func\n};\n\nfunction AxisBottom(_ref) {\n  var children = _ref.children,\n      axisClassName = _ref.axisClassName,\n      axisLineClassName = _ref.axisLineClassName,\n      hideAxisLine = _ref.hideAxisLine,\n      hideTicks = _ref.hideTicks,\n      hideZero = _ref.hideZero,\n      label = _ref.label,\n      labelClassName = _ref.labelClassName,\n      _ref$labelOffset = _ref.labelOffset,\n      labelOffset = _ref$labelOffset === undefined ? 8 : _ref$labelOffset,\n      labelProps = _ref.labelProps,\n      left = _ref.left,\n      numTicks = _ref.numTicks,\n      rangePadding = _ref.rangePadding,\n      scale = _ref.scale,\n      stroke = _ref.stroke,\n      strokeWidth = _ref.strokeWidth,\n      strokeDasharray = _ref.strokeDasharray,\n      tickClassName = _ref.tickClassName,\n      tickFormat = _ref.tickFormat,\n      _ref$tickLabelProps = _ref.tickLabelProps,\n      tickLabelProps = _ref$tickLabelProps === undefined ? function (_ref2) {\n    var tick = _ref2.tick,\n        index = _ref2.index;\n    return {\n      dy: '0.25em',\n      fill: 'black',\n      fontFamily: 'Arial',\n      fontSize: 10,\n      textAnchor: 'middle'\n    };\n  } : _ref$tickLabelProps,\n      _ref$tickLength = _ref.tickLength,\n      tickLength = _ref$tickLength === undefined ? 8 : _ref$tickLength,\n      tickStroke = _ref.tickStroke,\n      tickTransform = _ref.tickTransform,\n      tickValues = _ref.tickValues,\n      tickComponent = _ref.tickComponent,\n      top = _ref.top;\n\n  return react_default.a.createElement(vx_axis_es_Axis, {\n    axisClassName: classnames_default()('vx-axis-bottom', axisClassName),\n    axisLineClassName: axisLineClassName,\n    hideAxisLine: hideAxisLine,\n    hideTicks: hideTicks,\n    hideZero: hideZero,\n    label: label,\n    labelClassName: labelClassName,\n    labelOffset: labelOffset,\n    labelProps: labelProps,\n    left: left,\n    numTicks: numTicks,\n    orientation: ORIENT.bottom,\n    rangePadding: rangePadding,\n    scale: scale,\n    stroke: stroke,\n    strokeWidth: strokeWidth,\n    strokeDasharray: strokeDasharray,\n    tickClassName: tickClassName,\n    tickFormat: tickFormat,\n    tickLabelProps: tickLabelProps,\n    tickLength: tickLength,\n    tickStroke: tickStroke,\n    tickTransform: tickTransform,\n    tickValues: tickValues,\n    tickComponent: tickComponent,\n    top: top,\n    children: children\n  });\n}\n\nAxisBottom.propTypes = propTypes$4;\n\n\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/utils/propShapes.js\nvar propShapes = __webpack_require__(1894);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/axis/XAxis.js\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\n\n\n\n\nvar XAxis_propTypes = {\n  axisStyles: propShapes[\"b\" /* axisStylesShape */],\n  hideZero: prop_types_default.a.bool,\n  label: prop_types_default.a.string,\n  labelOffset: prop_types_default.a.number,\n  labelProps: prop_types_default.a.objectOf(prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string])),\n  numTicks: prop_types_default.a.number,\n  orientation: prop_types_default.a.oneOf(['bottom', 'top']),\n  rangePadding: prop_types_default.a.number,\n  tickStyles: propShapes[\"l\" /* tickStylesShape */],\n  tickComponent: prop_types_default.a.func,\n  tickLabelProps: prop_types_default.a.func,\n  tickFormat: prop_types_default.a.func,\n  tickValues: prop_types_default.a.arrayOf( // number or date/moment object\n  prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.object, prop_types_default.a.string])),\n  // probably injected by parent\n  innerHeight: prop_types_default.a.number,\n  scale: prop_types_default.a.func\n};\nvar defaultProps = {\n  axisStyles: {},\n  hideZero: false,\n  innerHeight: null,\n  label: null,\n  labelOffset: 14,\n  labelProps: null,\n  numTicks: null,\n  orientation: 'bottom',\n  rangePadding: null,\n  scale: null,\n  tickComponent: null,\n  tickFormat: null,\n  tickLabelProps: null,\n  tickStyles: {},\n  tickValues: undefined\n};\n\nvar XAxis_XAxis =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inheritsLoose(XAxis, _React$PureComponent);\n\n  function XAxis() {\n    return _React$PureComponent.apply(this, arguments) || this;\n  }\n\n  var _proto = XAxis.prototype;\n\n  _proto.render = function render() {\n    var _this$props = this.props,\n        axisStyles = _this$props.axisStyles,\n        innerHeight = _this$props.innerHeight,\n        hideZero = _this$props.hideZero,\n        label = _this$props.label,\n        labelOffset = _this$props.labelOffset,\n        labelProps = _this$props.labelProps,\n        numTicks = _this$props.numTicks,\n        orientation = _this$props.orientation,\n        rangePadding = _this$props.rangePadding,\n        scale = _this$props.scale,\n        tickComponent = _this$props.tickComponent,\n        tickFormat = _this$props.tickFormat,\n        passedTickLabelProps = _this$props.tickLabelProps,\n        tickStyles = _this$props.tickStyles,\n        tickValues = _this$props.tickValues;\n    if (!scale || !innerHeight) return null;\n    var Axis = orientation === 'bottom' ? AxisBottom : AxisTop;\n    var tickLabelProps = passedTickLabelProps;\n\n    if (!tickLabelProps) {\n      tickLabelProps = tickStyles.label && tickStyles.label[orientation] ? function () {\n        return tickStyles.label[orientation];\n      } : undefined;\n    }\n\n    return react_default.a.createElement(Axis, {\n      top: orientation === 'bottom' ? innerHeight : 0,\n      left: 0,\n      rangePadding: rangePadding,\n      hideTicks: numTicks === 0,\n      hideZero: hideZero,\n      label: label,\n      labelOffset: labelOffset,\n      labelProps: labelProps || (axisStyles.label || {})[orientation],\n      numTicks: numTicks,\n      scale: scale,\n      stroke: axisStyles.stroke,\n      strokeWidth: axisStyles.strokeWidth,\n      tickComponent: tickComponent,\n      tickFormat: tickFormat,\n      tickLabelProps: tickLabelProps,\n      tickLength: tickStyles.tickLength,\n      tickStroke: tickStyles.stroke,\n      tickValues: tickValues\n    });\n  };\n\n  return XAxis;\n}(react_default.a.PureComponent);\n\n\nXAxis_XAxis.propTypes = XAxis_propTypes;\nXAxis_XAxis.defaultProps = defaultProps;\nXAxis_XAxis.displayName = 'XAxis';\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/axis/YAxis.js\nfunction YAxis_extends() { YAxis_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return YAxis_extends.apply(this, arguments); }\n\nfunction YAxis_inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\n\n\n\n\nvar YAxis_propTypes = {\n  axisStyles: propShapes[\"b\" /* axisStylesShape */],\n  hideZero: prop_types_default.a.bool,\n  label: prop_types_default.a.string,\n  labelProps: prop_types_default.a.objectOf(prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string])),\n  labelOffset: prop_types_default.a.number,\n  numTicks: prop_types_default.a.number,\n  orientation: prop_types_default.a.oneOf(['left', 'right']),\n  rangePadding: prop_types_default.a.number,\n  tickComponent: prop_types_default.a.func,\n  tickStyles: propShapes[\"l\" /* tickStylesShape */],\n  tickLabelProps: prop_types_default.a.func,\n  tickFormat: prop_types_default.a.func,\n  tickValues: prop_types_default.a.arrayOf( // number or date/moment object\n  prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.object, prop_types_default.a.string])),\n  // probably injected by parent\n  innerWidth: prop_types_default.a.number,\n  height: prop_types_default.a.number,\n  scale: prop_types_default.a.func\n};\nvar YAxis_defaultProps = {\n  axisStyles: {},\n  hideZero: false,\n  innerWidth: null,\n  height: null,\n  label: null,\n  labelProps: null,\n  labelOffset: undefined,\n  numTicks: null,\n  orientation: 'right',\n  rangePadding: null,\n  scale: null,\n  tickComponent: null,\n  tickFormat: null,\n  tickLabelProps: null,\n  tickStyles: {},\n  tickValues: undefined\n};\n\nvar YAxis_YAxis =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  YAxis_inheritsLoose(YAxis, _React$PureComponent);\n\n  function YAxis() {\n    return _React$PureComponent.apply(this, arguments) || this;\n  }\n\n  var _proto = YAxis.prototype;\n\n  _proto.render = function render() {\n    var _this$props = this.props,\n        axisStyles = _this$props.axisStyles,\n        hideZero = _this$props.hideZero,\n        innerWidth = _this$props.innerWidth,\n        height = _this$props.height,\n        label = _this$props.label,\n        labelProps = _this$props.labelProps,\n        labelOffset = _this$props.labelOffset,\n        numTicks = _this$props.numTicks,\n        orientation = _this$props.orientation,\n        rangePadding = _this$props.rangePadding,\n        scale = _this$props.scale,\n        tickComponent = _this$props.tickComponent,\n        tickFormat = _this$props.tickFormat,\n        passedTickLabelProps = _this$props.tickLabelProps,\n        tickStyles = _this$props.tickStyles,\n        tickValues = _this$props.tickValues;\n    if (!scale || !innerWidth) return null;\n    var Axis = orientation === 'left' ? AxisLeft : AxisRight;\n    var tickLabelProps = passedTickLabelProps;\n\n    if (!tickLabelProps) {\n      tickLabelProps = tickStyles.label && tickStyles.label[orientation] ? function () {\n        return tickStyles.label[orientation];\n      } : undefined;\n    }\n\n    return react_default.a.createElement(Axis, {\n      top: 0,\n      left: orientation === 'right' ? innerWidth : 0,\n      rangePadding: rangePadding,\n      hideTicks: numTicks === 0,\n      hideZero: hideZero,\n      label: label,\n      labelProps: YAxis_extends({\n        verticalAnchor: 'start',\n        width: Math.max.apply(Math, scale.range().concat([height || 0]))\n      }, labelProps || (axisStyles.label || {})[orientation]),\n      labelOffset: labelOffset,\n      numTicks: numTicks,\n      scale: scale,\n      stroke: axisStyles.stroke,\n      strokeWidth: axisStyles.strokeWidth,\n      tickComponent: tickComponent,\n      tickFormat: tickFormat,\n      tickLabelProps: tickLabelProps,\n      tickLength: tickStyles.tickLength,\n      tickStroke: tickStyles.stroke,\n      tickValues: tickValues\n    });\n  };\n\n  return YAxis;\n}(react_default.a.PureComponent);\n\n\nYAxis_YAxis.propTypes = YAxis_propTypes;\nYAxis_YAxis.defaultProps = YAxis_defaultProps;\nYAxis_YAxis.displayName = 'YAxis';\n// EXTERNAL MODULE: ../superset-ui-core/src/dimension/mergeMargin.ts\nvar mergeMargin = __webpack_require__(1013);\n\n// EXTERNAL MODULE: ../superset-ui-core/src/chart-composition/ChartFrame.tsx\nvar ChartFrame = __webpack_require__(1016);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/utils/createTickComponent.tsx\nvar __rest = (undefined && undefined.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n\nfunction createTickComponent({ axisWidth, labelAngle, labelFlush, labelOverlap, orient, tickLabels, tickLabelDimensions, tickTextAnchor = 'middle', }) {\n    if (labelOverlap === 'rotate' && labelAngle !== 0) {\n        let xOffset = labelAngle > 0 ? -6 : 6;\n        if (orient === 'top') {\n            xOffset = 0;\n        }\n        const yOffset = orient === 'top' ? -3 : 0;\n        return (_a) => {\n            var { x, y, formattedValue = '' } = _a, textStyle = __rest(_a, [\"x\", \"y\", \"formattedValue\"]);\n            return (react_default.a.createElement(\"g\", { transform: `translate(${x + xOffset}, ${y + yOffset})` },\n                react_default.a.createElement(\"text\", Object.assign({ transform: `rotate(${labelAngle})` }, textStyle, { textAnchor: tickTextAnchor }), formattedValue)));\n        };\n    }\n    if (labelFlush === true || typeof labelFlush === 'number') {\n        const labelToDimensionMap = new Map();\n        tickLabels.forEach((label, i) => {\n            labelToDimensionMap.set(label, tickLabelDimensions[i]);\n        });\n        return (_a) => {\n            var { x, y, formattedValue = '' } = _a, textStyle = __rest(_a, [\"x\", \"y\", \"formattedValue\"]);\n            const dimension = labelToDimensionMap.get(formattedValue);\n            const labelWidth = typeof dimension === 'undefined' ? 0 : dimension.width;\n            let textAnchor = tickTextAnchor;\n            let xOffset = 0;\n            if (x - labelWidth / 2 < 0) {\n                textAnchor = 'start';\n                if (typeof labelFlush === 'number') {\n                    xOffset -= labelFlush;\n                }\n            }\n            else if (x + labelWidth / 2 > axisWidth) {\n                textAnchor = 'end';\n                if (typeof labelFlush === 'number') {\n                    xOffset += labelFlush;\n                }\n            }\n            return (react_default.a.createElement(\"text\", Object.assign({ x: x + xOffset, y: y }, textStyle, { textAnchor: textAnchor }), formattedValue));\n        };\n    }\n    // This will render the tick as horizontal string.\n    return null;\n}\n\n// EXTERNAL MODULE: ../superset-ui-core/src/dimension/getTextDimension.ts\nvar getTextDimension = __webpack_require__(426);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/utils/computeAxisLayout.ts\n\nfunction computeAxisLayout(axis, { axisTitleHeight = 20, axisWidth, gapBetweenAxisLabelAndBorder = 4, gapBetweenTickAndTickLabel = 4, defaultTickSize = 8, tickTextStyle = {}, }) {\n    const tickLabels = axis.getTickLabels();\n    const tickLabelDimensions = tickLabels.map((text) => Object(getTextDimension[\"a\" /* default */])({\n        style: tickTextStyle,\n        text,\n    }));\n    const { labelAngle, labelFlush, labelOverlap, labelPadding, orient, tickSize = defaultTickSize, } = axis.config;\n    const maxWidth = Math.max(...tickLabelDimensions.map(d => d.width), 0);\n    // cheap heuristic, can improve\n    const widthPerTick = axisWidth / tickLabels.length;\n    const isLabelOverlap = maxWidth > widthPerTick;\n    const labelAngleIfOverlap = labelOverlap.strategy === 'rotate' ? labelOverlap.labelAngle : 0;\n    const labelAngleAfterOverlapCheck = isLabelOverlap ? labelAngleIfOverlap : 0;\n    const finalLabelAngle = labelAngle === 0 ? labelAngleAfterOverlapCheck : labelAngle;\n    const spaceForAxisTitle = axis.hasTitle() ? labelPadding + axisTitleHeight : 0;\n    let tickTextAnchor = 'middle';\n    let labelOffset = 0;\n    let requiredMargin = tickSize + gapBetweenTickAndTickLabel + spaceForAxisTitle + gapBetweenAxisLabelAndBorder;\n    if (axis.channelEncoder.isX()) {\n        if (finalLabelAngle === 0) {\n            const labelHeight = tickLabelDimensions.length > 0 ? tickLabelDimensions[0].height : 0;\n            labelOffset = labelHeight + labelPadding;\n            requiredMargin += labelHeight;\n        }\n        else {\n            const labelHeight = Math.ceil(Math.abs(maxWidth * Math.sin((finalLabelAngle * Math.PI) / 180)));\n            labelOffset = labelHeight + labelPadding;\n            requiredMargin += labelHeight;\n            tickTextAnchor =\n                (orient === 'top' && finalLabelAngle > 0) || (orient === 'bottom' && finalLabelAngle < 0)\n                    ? 'end'\n                    : 'start';\n        }\n        requiredMargin += 8;\n    }\n    else {\n        labelOffset = maxWidth + spaceForAxisTitle;\n        requiredMargin += maxWidth;\n    }\n    return {\n        axisWidth,\n        labelAngle: finalLabelAngle,\n        labelFlush,\n        labelOffset,\n        labelOverlap: isLabelOverlap ? labelOverlap.strategy : 'flat',\n        minMargin: {\n            [orient]: Math.ceil(requiredMargin),\n        },\n        orient,\n        tickLabelDimensions,\n        tickLabels,\n        tickTextAnchor,\n    };\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/utils/XYChartLayout.tsx\n\n\n\n\n\nconst DEFAULT_LABEL_ANGLE = 40;\n// Additional margin to avoid content hidden behind scroll bar\nconst OVERFLOW_MARGIN = 8;\nclass XYChartLayout_XYChartLayout {\n    constructor(config) {\n        const { width, height, minContentWidth = 0, minContentHeight = 0, margin, xEncoder, xTickSize, xTickTextStyle, autoAdjustXMargin = true, yEncoder, yTickSize, yTickTextStyle, autoAdjustYMargin = true, } = config;\n        this.xEncoder = xEncoder;\n        this.yEncoder = yEncoder;\n        if (typeof yEncoder.axis !== 'undefined') {\n            this.yLayout = computeAxisLayout(yEncoder.axis, {\n                axisWidth: Math.max(height - margin.top - margin.bottom),\n                defaultTickSize: yTickSize,\n                tickTextStyle: yTickTextStyle,\n            });\n        }\n        const secondMargin = this.yLayout && autoAdjustYMargin ? Object(mergeMargin[\"a\" /* default */])(margin, this.yLayout.minMargin) : margin;\n        const innerWidth = Math.max(width - secondMargin.left - secondMargin.right, minContentWidth);\n        if (typeof xEncoder.axis !== 'undefined') {\n            this.xLayout = computeAxisLayout(xEncoder.axis, {\n                axisWidth: innerWidth,\n                defaultTickSize: xTickSize,\n                tickTextStyle: xTickTextStyle,\n            });\n        }\n        const finalMargin = this.xLayout && autoAdjustXMargin\n            ? Object(mergeMargin[\"a\" /* default */])(secondMargin, this.xLayout.minMargin)\n            : secondMargin;\n        const innerHeight = Math.max(height - finalMargin.top - finalMargin.bottom, minContentHeight);\n        const chartWidth = Math.round(innerWidth + finalMargin.left + finalMargin.right);\n        const chartHeight = Math.round(innerHeight + finalMargin.top + finalMargin.bottom);\n        const isOverFlowX = chartWidth > width;\n        const isOverFlowY = chartHeight > height;\n        if (isOverFlowX) {\n            finalMargin.bottom += OVERFLOW_MARGIN;\n        }\n        if (isOverFlowY) {\n            finalMargin.right += OVERFLOW_MARGIN;\n        }\n        this.chartWidth = isOverFlowX ? chartWidth + OVERFLOW_MARGIN : chartWidth;\n        this.chartHeight = isOverFlowY ? chartHeight + OVERFLOW_MARGIN : chartHeight;\n        this.containerWidth = width;\n        this.containerHeight = height;\n        this.margin = finalMargin;\n    }\n    renderChartWithFrame(renderChart) {\n        return (react_default.a.createElement(ChartFrame[\"a\" /* default */], { width: this.containerWidth, height: this.containerHeight, contentWidth: this.chartWidth, contentHeight: this.chartHeight, renderContent: renderChart }));\n    }\n    renderXAxis(props) {\n        const { axis } = this.xEncoder;\n        return axis && this.xLayout ? (react_default.a.createElement(XAxis_XAxis, Object.assign({ label: axis.getTitle(), labelOffset: this.xLayout.labelOffset, numTicks: axis.config.tickCount, orientation: axis.config.orient, tickComponent: createTickComponent(this.xLayout), tickFormat: axis.formatValue }, props))) : null;\n    }\n    renderYAxis(props) {\n        const { axis } = this.yEncoder;\n        return axis && this.yLayout ? (react_default.a.createElement(YAxis_YAxis, Object.assign({ label: axis.getTitle(), labelOffset: this.yLayout.labelOffset, numTicks: axis.config.tickCount, orientation: axis.config.orient, tickFormat: axis.formatValue }, props))) : null;\n    }\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/utils/createXYChartLayoutWithTheme.ts\nvar createXYChartLayoutWithTheme_rest = (undefined && undefined.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n\nfunction createXYChartLayoutWithTheme(config) {\n    const { theme } = config, rest = createXYChartLayoutWithTheme_rest(config, [\"theme\"]);\n    return new XYChartLayout_XYChartLayout(Object.assign(Object.assign({}, rest), { \n        // @ts-ignore\n        xTickSize: theme.xTickStyles.length || theme.xTickStyles.tickLength, xTickTextStyle: theme.xTickStyles.label.bottom || theme.xTickStyles.label.top, \n        // @ts-ignore\n        yTickSize: theme.yTickStyles.length || theme.yTickStyles.tickLength, yTickTextStyle: theme.yTickStyles.label.left || theme.yTickStyles.label.right }));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk0Ni5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL3h5LWNoYXJ0L25vZGVfbW9kdWxlcy9AdngvYXhpcy9ub2RlX21vZHVsZXMvQHZ4L2dyb3VwL2Rpc3QvdngtZ3JvdXAuZXMuanM/ZDYwNyIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS94eS1jaGFydC9ub2RlX21vZHVsZXMvQHZ4L2F4aXMvbm9kZV9tb2R1bGVzL0B2eC9zaGFwZS9kaXN0L3Z4LXNoYXBlLmVzLmpzPzhiNWUiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkveHktY2hhcnQvbm9kZV9tb2R1bGVzL0B2eC9heGlzL2Rpc3QvdngtYXhpcy5lcy5qcz8xZjFmIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL3h5LWNoYXJ0L2VzbS9heGlzL1hBeGlzLmpzP2M1NjAiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkveHktY2hhcnQvZXNtL2F4aXMvWUF4aXMuanM/NGVmNyIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvcHJlc2V0LWNoYXJ0LXh5L3NyYy91dGlscy9jcmVhdGVUaWNrQ29tcG9uZW50LnRzeD9lMTlkIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wcmVzZXQtY2hhcnQteHkvc3JjL3V0aWxzL2NvbXB1dGVBeGlzTGF5b3V0LnRzP2I5NmQiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9wbHVnaW5zL3ByZXNldC1jaGFydC14eS9zcmMvdXRpbHMvWFlDaGFydExheW91dC50c3g/N2M2ZiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvcHJlc2V0LWNoYXJ0LXh5L3NyYy91dGlscy9jcmVhdGVYWUNoYXJ0TGF5b3V0V2l0aFRoZW1lLnRzP2QyODkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjeCBmcm9tICdjbGFzc25hbWVzJztcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbnZhciBvYmplY3RXaXRob3V0UHJvcGVydGllcyA9IGZ1bmN0aW9uIChvYmosIGtleXMpIHtcbiAgdmFyIHRhcmdldCA9IHt9O1xuXG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTtcbiAgICB0YXJnZXRbaV0gPSBvYmpbaV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuZnVuY3Rpb24gR3JvdXAoX3JlZikge1xuICB2YXIgX3JlZiR0b3AgPSBfcmVmLnRvcCxcbiAgICAgIHRvcCA9IF9yZWYkdG9wID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiR0b3AsXG4gICAgICBfcmVmJGxlZnQgPSBfcmVmLmxlZnQsXG4gICAgICBsZWZ0ID0gX3JlZiRsZWZ0ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiRsZWZ0LFxuICAgICAgdHJhbnNmb3JtID0gX3JlZi50cmFuc2Zvcm0sXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsndG9wJywgJ2xlZnQnLCAndHJhbnNmb3JtJywgJ2NsYXNzTmFtZScsICdjaGlsZHJlbiddKTtcblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAnZycsXG4gICAgX2V4dGVuZHMoe1xuICAgICAgY2xhc3NOYW1lOiBjeCgndngtZ3JvdXAnLCBjbGFzc05hbWUpLFxuICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0gfHwgJ3RyYW5zbGF0ZSgnICsgbGVmdCArICcsICcgKyB0b3AgKyAnKSdcbiAgICB9LCByZXN0UHJvcHMpLFxuICAgIGNoaWxkcmVuXG4gICk7XG59XG5cbmV4cG9ydCB7IEdyb3VwIH07XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IGN4IGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IHsgYXJjLCBwaWUsIGxpbmUsIHJhZGlhbExpbmUsIGFyZWEsIHN0YWNrLCBzdGFja09yZGVyQXNjZW5kaW5nLCBzdGFja09yZGVyRGVzY2VuZGluZywgc3RhY2tPcmRlckluc2lkZU91dCwgc3RhY2tPcmRlck5vbmUsIHN0YWNrT3JkZXJSZXZlcnNlLCBzdGFja09mZnNldEV4cGFuZCwgc3RhY2tPZmZzZXREaXZlcmdpbmcsIHN0YWNrT2Zmc2V0Tm9uZSwgc3RhY2tPZmZzZXRTaWxob3VldHRlLCBzdGFja09mZnNldFdpZ2dsZSwgbGlua0hvcml6b250YWwsIGxpbmtWZXJ0aWNhbCwgbGlua1JhZGlhbCB9IGZyb20gJ2QzLXNoYXBlJztcbmltcG9ydCB7IEdyb3VwIH0gZnJvbSAnQHZ4L2dyb3VwJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJ0B2eC9wb2ludCc7XG5pbXBvcnQgeyBjdXJ2ZUxpbmVhciB9IGZyb20gJ0B2eC9jdXJ2ZSc7XG5pbXBvcnQgeyBwYXRoIH0gZnJvbSAnZDMtcGF0aCc7XG5cbmZ1bmN0aW9uIGNhbGxPclZhbHVlKG1heWJlRm4sIGRhdGEpIHtcbiAgaWYgKHR5cGVvZiBtYXliZUZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlRm4oZGF0YSk7XG4gIH1cbiAgcmV0dXJuIG1heWJlRm47XG59XG5cbmZ1bmN0aW9uIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHJlc3RQcm9wcykucmVkdWNlKGZ1bmN0aW9uIChyZXQsIGN1cikge1xuICAgIHJldFtjdXJdID0gY2FsbE9yVmFsdWUocmVzdFByb3BzW2N1cl0sIGRhdGEpO1xuICAgIHJldHVybiByZXQ7XG4gIH0sIHt9KTtcbn1cblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbnZhciBvYmplY3RXaXRob3V0UHJvcGVydGllcyA9IGZ1bmN0aW9uIChvYmosIGtleXMpIHtcbiAgdmFyIHRhcmdldCA9IHt9O1xuXG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTtcbiAgICB0YXJnZXRbaV0gPSBvYmpbaV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxudmFyIHRvQ29uc3VtYWJsZUFycmF5ID0gZnVuY3Rpb24gKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICAgIHJldHVybiBhcnIyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGFycik7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIEFyYyhfcmVmKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICBjZW50cm9pZCA9IF9yZWYuY2VudHJvaWQsXG4gICAgICBpbm5lclJhZGl1cyA9IF9yZWYuaW5uZXJSYWRpdXMsXG4gICAgICBvdXRlclJhZGl1cyA9IF9yZWYub3V0ZXJSYWRpdXMsXG4gICAgICBjb3JuZXJSYWRpdXMgPSBfcmVmLmNvcm5lclJhZGl1cyxcbiAgICAgIHN0YXJ0QW5nbGUgPSBfcmVmLnN0YXJ0QW5nbGUsXG4gICAgICBlbmRBbmdsZSA9IF9yZWYuZW5kQW5nbGUsXG4gICAgICBwYWRBbmdsZSA9IF9yZWYucGFkQW5nbGUsXG4gICAgICBwYWRSYWRpdXMgPSBfcmVmLnBhZFJhZGl1cyxcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnY2xhc3NOYW1lJywgJ2RhdGEnLCAnY2VudHJvaWQnLCAnaW5uZXJSYWRpdXMnLCAnb3V0ZXJSYWRpdXMnLCAnY29ybmVyUmFkaXVzJywgJ3N0YXJ0QW5nbGUnLCAnZW5kQW5nbGUnLCAncGFkQW5nbGUnLCAncGFkUmFkaXVzJ10pO1xuXG4gIHZhciBhcmMkJDEgPSBhcmMoKTtcbiAgaWYgKGNlbnRyb2lkKSBhcmMkJDEuY2VudHJvaWQoY2VudHJvaWQpO1xuICBpZiAoaW5uZXJSYWRpdXMpIGFyYyQkMS5pbm5lclJhZGl1cyhpbm5lclJhZGl1cyk7XG4gIGlmIChvdXRlclJhZGl1cykgYXJjJCQxLm91dGVyUmFkaXVzKG91dGVyUmFkaXVzKTtcbiAgaWYgKGNvcm5lclJhZGl1cykgYXJjJCQxLmNvcm5lclJhZGl1cyhjb3JuZXJSYWRpdXMpO1xuICBpZiAoc3RhcnRBbmdsZSkgYXJjJCQxLnN0YXJ0QW5nbGUoc3RhcnRBbmdsZSk7XG4gIGlmIChlbmRBbmdsZSkgYXJjJCQxLmVuZEFuZ2xlKGVuZEFuZ2xlKTtcbiAgaWYgKHBhZEFuZ2xlKSBhcmMkJDEucGFkQW5nbGUocGFkQW5nbGUpO1xuICBpZiAocGFkUmFkaXVzKSBhcmMkJDEucGFkUmFkaXVzKHBhZFJhZGl1cyk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoeyBjbGFzc05hbWU6IGN4KCd2eC1hcmMnLCBjbGFzc05hbWUpLCBkOiBhcmMkJDEoZGF0YSkgfSwgYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcywgZGF0YSkpKTtcbn1cblxuZnVuY3Rpb24gUGllKF9yZWYpIHtcbiAgdmFyIF9yZWYkY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBjbGFzc05hbWUgPSBfcmVmJGNsYXNzTmFtZSA9PT0gdW5kZWZpbmVkID8gJycgOiBfcmVmJGNsYXNzTmFtZSxcbiAgICAgIF9yZWYkdG9wID0gX3JlZi50b3AsXG4gICAgICB0b3AgPSBfcmVmJHRvcCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkdG9wLFxuICAgICAgX3JlZiRsZWZ0ID0gX3JlZi5sZWZ0LFxuICAgICAgbGVmdCA9IF9yZWYkbGVmdCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkbGVmdCxcbiAgICAgIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICBjZW50cm9pZCA9IF9yZWYuY2VudHJvaWQsXG4gICAgICBfcmVmJGlubmVyUmFkaXVzID0gX3JlZi5pbm5lclJhZGl1cyxcbiAgICAgIGlubmVyUmFkaXVzID0gX3JlZiRpbm5lclJhZGl1cyA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkaW5uZXJSYWRpdXMsXG4gICAgICBvdXRlclJhZGl1cyA9IF9yZWYub3V0ZXJSYWRpdXMsXG4gICAgICBjb3JuZXJSYWRpdXMgPSBfcmVmLmNvcm5lclJhZGl1cyxcbiAgICAgIF9yZWYkc3RhcnRBbmdsZSA9IF9yZWYuc3RhcnRBbmdsZSxcbiAgICAgIHN0YXJ0QW5nbGUgPSBfcmVmJHN0YXJ0QW5nbGUgPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmJHN0YXJ0QW5nbGUsXG4gICAgICBlbmRBbmdsZSA9IF9yZWYuZW5kQW5nbGUsXG4gICAgICBwYWRBbmdsZSA9IF9yZWYucGFkQW5nbGUsXG4gICAgICBwYWRSYWRpdXMgPSBfcmVmLnBhZFJhZGl1cyxcbiAgICAgIHBpZVNvcnQgPSBfcmVmLnBpZVNvcnQsXG4gICAgICBwaWVTb3J0VmFsdWVzID0gX3JlZi5waWVTb3J0VmFsdWVzLFxuICAgICAgcGllVmFsdWUgPSBfcmVmLnBpZVZhbHVlLFxuICAgICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgWydjbGFzc05hbWUnLCAndG9wJywgJ2xlZnQnLCAnZGF0YScsICdjZW50cm9pZCcsICdpbm5lclJhZGl1cycsICdvdXRlclJhZGl1cycsICdjb3JuZXJSYWRpdXMnLCAnc3RhcnRBbmdsZScsICdlbmRBbmdsZScsICdwYWRBbmdsZScsICdwYWRSYWRpdXMnLCAncGllU29ydCcsICdwaWVTb3J0VmFsdWVzJywgJ3BpZVZhbHVlJywgJ2NoaWxkcmVuJ10pO1xuXG4gIHZhciBwYXRoJCQxID0gYXJjKCk7XG4gIHBhdGgkJDEuaW5uZXJSYWRpdXMoaW5uZXJSYWRpdXMpO1xuICBpZiAob3V0ZXJSYWRpdXMpIHBhdGgkJDEub3V0ZXJSYWRpdXMob3V0ZXJSYWRpdXMpO1xuICBpZiAoY29ybmVyUmFkaXVzKSBwYXRoJCQxLmNvcm5lclJhZGl1cyhjb3JuZXJSYWRpdXMpO1xuICBpZiAocGFkUmFkaXVzKSBwYXRoJCQxLnBhZFJhZGl1cyhwYWRSYWRpdXMpO1xuICB2YXIgcGllJCQxID0gcGllKCk7XG4gIGlmIChwaWVTb3J0ICE9PSB1bmRlZmluZWQpIHBpZSQkMS5zb3J0KHBpZVNvcnQpO1xuICBpZiAocGllU29ydFZhbHVlcyAhPT0gdW5kZWZpbmVkKSBwaWUkJDEuc29ydFZhbHVlcyhwaWVTb3J0VmFsdWVzKTtcbiAgaWYgKHBpZVZhbHVlKSBwaWUkJDEudmFsdWUocGllVmFsdWUpO1xuICBpZiAocGFkQW5nbGUgIT0gbnVsbCkgcGllJCQxLnBhZEFuZ2xlKHBhZEFuZ2xlKTtcbiAgaWYgKHN0YXJ0QW5nbGUgIT0gbnVsbCkgcGllJCQxLnN0YXJ0QW5nbGUoc3RhcnRBbmdsZSk7XG4gIGlmIChlbmRBbmdsZSAhPSBudWxsKSBwaWUkJDEuZW5kQW5nbGUoZW5kQW5nbGUpO1xuICB2YXIgYXJjcyA9IHBpZSQkMShkYXRhKTtcbiAgdmFyIHJlbmRlckZ1bmN0aW9uQXJnID0ge1xuICAgIGFyY3M6IGFyY3MsXG4gICAgZ2VuZXJhdGVQYXRoUHJvcHM6IGZ1bmN0aW9uIGdlbmVyYXRlUGF0aFByb3BzKGFyYyQkMSwgaW5kZXgpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICAgIGNsYXNzTmFtZTogY3goJ3Z4LXBpZS1hcmMnLCBjbGFzc05hbWUpLFxuICAgICAgICBkOiBwYXRoJCQxKGFyYyQkMSlcbiAgICAgIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIF9leHRlbmRzKHt9LCBhcmMkJDEsIHtcbiAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICBjZW50cm9pZDogY2VudHJvaWQgPyBwYXRoJCQxLmNlbnRyb2lkKGFyYyQkMSkgOiB1bmRlZmluZWRcbiAgICAgIH0pKSk7XG4gICAgfSxcbiAgICBnZW5lcmF0ZUNlbnRyb2lkOiBmdW5jdGlvbiBnZW5lcmF0ZUNlbnRyb2lkKGFyYyQkMSkge1xuICAgICAgcmV0dXJuIGNlbnRyb2lkICYmIGNlbnRyb2lkKHBhdGgkJDEuY2VudHJvaWQoYXJjJCQxKSwgYXJjJCQxKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIEdyb3VwLFxuICAgIHsgY2xhc3NOYW1lOiAndngtcGllLWFyY3MtZ3JvdXAnLCB0b3A6IHRvcCwgbGVmdDogbGVmdCB9LFxuICAgIGNoaWxkcmVuID8gY2hpbGRyZW4ocmVuZGVyRnVuY3Rpb25BcmcpIDogYXJjcy5tYXAoZnVuY3Rpb24gKGFyYyQkMSwgaSkge1xuICAgICAgdmFyIHBhdGhQcm9wcyA9IHJlbmRlckZ1bmN0aW9uQXJnLmdlbmVyYXRlUGF0aFByb3BzKGFyYyQkMSwgaSk7XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ2cnLFxuICAgICAgICB7IGtleTogJ3BpZS1hcmMtJyArIGkgfSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudCgncGF0aCcsIHBhdGhQcm9wcyksXG4gICAgICAgIHJlbmRlckZ1bmN0aW9uQXJnLmdlbmVyYXRlQ2VudHJvaWQoYXJjJCQxKVxuICAgICAgKTtcbiAgICB9KVxuICApO1xufVxuXG5MaW5lLnByb3BUeXBlcyA9IHtcbiAgaW5uZXJSZWY6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5mdW5jdGlvbiBMaW5lKF9yZWYpIHtcbiAgdmFyIF9yZWYkZnJvbSA9IF9yZWYuZnJvbSxcbiAgICAgIGZyb20gPSBfcmVmJGZyb20gPT09IHVuZGVmaW5lZCA/IG5ldyBQb2ludCh7IHg6IDAsIHk6IDAgfSkgOiBfcmVmJGZyb20sXG4gICAgICBfcmVmJHRvID0gX3JlZi50byxcbiAgICAgIHRvID0gX3JlZiR0byA9PT0gdW5kZWZpbmVkID8gbmV3IFBvaW50KHsgeDogMSwgeTogMSB9KSA6IF9yZWYkdG8sXG4gICAgICBfcmVmJHN0cm9rZSA9IF9yZWYuc3Ryb2tlLFxuICAgICAgc3Ryb2tlID0gX3JlZiRzdHJva2UgPT09IHVuZGVmaW5lZCA/ICdibGFjaycgOiBfcmVmJHN0cm9rZSxcbiAgICAgIF9yZWYkc3Ryb2tlV2lkdGggPSBfcmVmLnN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlV2lkdGggPSBfcmVmJHN0cm9rZVdpZHRoID09PSB1bmRlZmluZWQgPyAxIDogX3JlZiRzdHJva2VXaWR0aCxcbiAgICAgIF9yZWYkc3Ryb2tlRGFzaGFycmF5ID0gX3JlZi5zdHJva2VEYXNoYXJyYXksXG4gICAgICBzdHJva2VEYXNoYXJyYXkgPSBfcmVmJHN0cm9rZURhc2hhcnJheSA9PT0gdW5kZWZpbmVkID8gJycgOiBfcmVmJHN0cm9rZURhc2hhcnJheSxcbiAgICAgIF9yZWYkdHJhbnNmb3JtID0gX3JlZi50cmFuc2Zvcm0sXG4gICAgICB0cmFuc2Zvcm0gPSBfcmVmJHRyYW5zZm9ybSA9PT0gdW5kZWZpbmVkID8gJycgOiBfcmVmJHRyYW5zZm9ybSxcbiAgICAgIF9yZWYkY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBjbGFzc05hbWUgPSBfcmVmJGNsYXNzTmFtZSA9PT0gdW5kZWZpbmVkID8gJycgOiBfcmVmJGNsYXNzTmFtZSxcbiAgICAgIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICBpbm5lclJlZiA9IF9yZWYuaW5uZXJSZWYsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2Zyb20nLCAndG8nLCAnc3Ryb2tlJywgJ3N0cm9rZVdpZHRoJywgJ3N0cm9rZURhc2hhcnJheScsICd0cmFuc2Zvcm0nLCAnY2xhc3NOYW1lJywgJ2RhdGEnLCAnaW5uZXJSZWYnXSk7XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2xpbmUnLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBpbm5lclJlZixcbiAgICBjbGFzc05hbWU6IGN4KCd2eC1saW5lJywgY2xhc3NOYW1lKSxcbiAgICB4MTogZnJvbS54LFxuICAgIHkxOiBmcm9tLnksXG4gICAgeDI6IHRvLngsXG4gICAgeTI6IHRvLnksXG4gICAgc3Ryb2tlOiBzdHJva2UsXG4gICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgIHN0cm9rZURhc2hhcnJheTogc3Ryb2tlRGFzaGFycmF5LFxuICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtXG4gIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSk7XG59XG5cbkxpbmVQYXRoLnByb3BUeXBlcyA9IHtcbiAgaW5uZXJSZWY6IFByb3BUeXBlcy5mdW5jLFxuICB4U2NhbGU6IFByb3BUeXBlcy5mdW5jLFxuICB5U2NhbGU6IFByb3BUeXBlcy5mdW5jLFxuICBkYXRhOiBQcm9wVHlwZXMuYXJyYXksXG4gIHg6IFByb3BUeXBlcy5mdW5jLFxuICB5OiBQcm9wVHlwZXMuZnVuYyxcbiAgZGVmaW5lZDogUHJvcFR5cGVzLmZ1bmMsXG4gIHN0cm9rZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgc3Ryb2tlV2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXG4gIGdseXBoOiBQcm9wVHlwZXMuZnVuYyxcbiAgY3VydmU6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5mdW5jdGlvbiBMaW5lUGF0aChfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgeFNjYWxlID0gX3JlZi54U2NhbGUsXG4gICAgICB5U2NhbGUgPSBfcmVmLnlTY2FsZSxcbiAgICAgIHggPSBfcmVmLngsXG4gICAgICB5ID0gX3JlZi55LFxuICAgICAgX3JlZiRkZWZpbmVkID0gX3JlZi5kZWZpbmVkLFxuICAgICAgZGVmaW5lZCA9IF9yZWYkZGVmaW5lZCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IDogX3JlZiRkZWZpbmVkLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBfcmVmJHN0cm9rZSA9IF9yZWYuc3Ryb2tlLFxuICAgICAgc3Ryb2tlID0gX3JlZiRzdHJva2UgPT09IHVuZGVmaW5lZCA/ICdzdGVlbGJsdWUnIDogX3JlZiRzdHJva2UsXG4gICAgICBfcmVmJHN0cm9rZVdpZHRoID0gX3JlZi5zdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZVdpZHRoID0gX3JlZiRzdHJva2VXaWR0aCA9PT0gdW5kZWZpbmVkID8gMiA6IF9yZWYkc3Ryb2tlV2lkdGgsXG4gICAgICBfcmVmJHN0cm9rZURhc2hhcnJheSA9IF9yZWYuc3Ryb2tlRGFzaGFycmF5LFxuICAgICAgc3Ryb2tlRGFzaGFycmF5ID0gX3JlZiRzdHJva2VEYXNoYXJyYXkgPT09IHVuZGVmaW5lZCA/ICcnIDogX3JlZiRzdHJva2VEYXNoYXJyYXksXG4gICAgICBfcmVmJHN0cm9rZURhc2hvZmZzZXQgPSBfcmVmLnN0cm9rZURhc2hvZmZzZXQsXG4gICAgICBzdHJva2VEYXNob2Zmc2V0ID0gX3JlZiRzdHJva2VEYXNob2Zmc2V0ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiRzdHJva2VEYXNob2Zmc2V0LFxuICAgICAgX3JlZiRmaWxsID0gX3JlZi5maWxsLFxuICAgICAgZmlsbCA9IF9yZWYkZmlsbCA9PT0gdW5kZWZpbmVkID8gJ25vbmUnIDogX3JlZiRmaWxsLFxuICAgICAgX3JlZiRjdXJ2ZSA9IF9yZWYuY3VydmUsXG4gICAgICBjdXJ2ZSA9IF9yZWYkY3VydmUgPT09IHVuZGVmaW5lZCA/IGN1cnZlTGluZWFyIDogX3JlZiRjdXJ2ZSxcbiAgICAgIGdseXBoID0gX3JlZi5nbHlwaCxcbiAgICAgIGlubmVyUmVmID0gX3JlZi5pbm5lclJlZixcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnY2hpbGRyZW4nLCAnZGF0YScsICd4U2NhbGUnLCAneVNjYWxlJywgJ3gnLCAneScsICdkZWZpbmVkJywgJ2NsYXNzTmFtZScsICdzdHJva2UnLCAnc3Ryb2tlV2lkdGgnLCAnc3Ryb2tlRGFzaGFycmF5JywgJ3N0cm9rZURhc2hvZmZzZXQnLCAnZmlsbCcsICdjdXJ2ZScsICdnbHlwaCcsICdpbm5lclJlZiddKTtcblxuICB2YXIgcGF0aCQkMSA9IGxpbmUoKS54KGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4geFNjYWxlKHguYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKTtcbiAgfSkueShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHlTY2FsZSh5LmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSk7XG4gIH0pLmRlZmluZWQoZGVmaW5lZCkuY3VydmUoY3VydmUpO1xuICBpZiAoY2hpbGRyZW4pIHJldHVybiBjaGlsZHJlbih7IHBhdGg6IHBhdGgkJDEgfSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICdnJyxcbiAgICBudWxsLFxuICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCBfZXh0ZW5kcyh7XG4gICAgICByZWY6IGlubmVyUmVmLFxuICAgICAgY2xhc3NOYW1lOiBjeCgndngtbGluZXBhdGgnLCBjbGFzc05hbWUpLFxuICAgICAgZDogcGF0aCQkMShkYXRhKSxcbiAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlRGFzaGFycmF5OiBzdHJva2VEYXNoYXJyYXksXG4gICAgICBzdHJva2VEYXNob2Zmc2V0OiBzdHJva2VEYXNob2Zmc2V0LFxuICAgICAgZmlsbDogZmlsbFxuICAgIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSksXG4gICAgZ2x5cGggJiYgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICdnJyxcbiAgICAgIHsgY2xhc3NOYW1lOiAndngtbGluZXBhdGgtZ2x5cGhzJyB9LFxuICAgICAgZGF0YS5tYXAoZ2x5cGgpXG4gICAgKVxuICApO1xufVxuXG5MaW5lUmFkaWFsLnByb3BUeXBlcyA9IHtcbiAgaW5uZXJSZWY6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5mdW5jdGlvbiBMaW5lUmFkaWFsKF9yZWYpIHtcbiAgdmFyIF9yZWYkY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBjbGFzc05hbWUgPSBfcmVmJGNsYXNzTmFtZSA9PT0gdW5kZWZpbmVkID8gJycgOiBfcmVmJGNsYXNzTmFtZSxcbiAgICAgIGFuZ2xlID0gX3JlZi5hbmdsZSxcbiAgICAgIHJhZGl1cyA9IF9yZWYucmFkaXVzLFxuICAgICAgZGVmaW5lZCA9IF9yZWYuZGVmaW5lZCxcbiAgICAgIGN1cnZlID0gX3JlZi5jdXJ2ZSxcbiAgICAgIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICBpbm5lclJlZiA9IF9yZWYuaW5uZXJSZWYsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2NsYXNzTmFtZScsICdhbmdsZScsICdyYWRpdXMnLCAnZGVmaW5lZCcsICdjdXJ2ZScsICdkYXRhJywgJ2lubmVyUmVmJ10pO1xuXG4gIHZhciBwYXRoJCQxID0gcmFkaWFsTGluZSgpO1xuICBpZiAoYW5nbGUpIHBhdGgkJDEuYW5nbGUoYW5nbGUpO1xuICBpZiAocmFkaXVzKSBwYXRoJCQxLnJhZGl1cyhyYWRpdXMpO1xuICBpZiAoZGVmaW5lZCkgcGF0aCQkMS5kZWZpbmVkKGRlZmluZWQpO1xuICBpZiAoY3VydmUpIHBhdGgkJDEuY3VydmUoY3VydmUpO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAnZycsXG4gICAgbnVsbCxcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgICAgcmVmOiBpbm5lclJlZixcbiAgICAgIGNsYXNzTmFtZTogY3goJ3Z4LWxpbmUtcmFkaWFsJywgY2xhc3NOYW1lKSxcbiAgICAgIGQ6IHBhdGgkJDEoZGF0YSlcbiAgICB9LCBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzLCBkYXRhKSkpXG4gICk7XG59XG5cbkFyZWEucHJvcFR5cGVzID0ge1xuICB4OiBQcm9wVHlwZXMuZnVuYyxcbiAgeDA6IFByb3BUeXBlcy5mdW5jLFxuICB4MTogUHJvcFR5cGVzLmZ1bmMsXG4gIHk6IFByb3BUeXBlcy5mdW5jLFxuICB5MDogUHJvcFR5cGVzLmZ1bmMsXG4gIHkxOiBQcm9wVHlwZXMuZnVuYyxcbiAgeFNjYWxlOiBQcm9wVHlwZXMuZnVuYyxcbiAgeVNjYWxlOiBQcm9wVHlwZXMuZnVuYyxcbiAgZGF0YTogUHJvcFR5cGVzLmFycmF5LFxuICBkZWZpbmVkOiBQcm9wVHlwZXMuZnVuYyxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuYm9vbCwgUHJvcFR5cGVzLm9iamVjdCwgUHJvcFR5cGVzLmFycmF5XSksXG4gIGlubmVyUmVmOiBQcm9wVHlwZXMuZnVuYyxcbiAgc3Ryb2tlRGFzaGFycmF5OiBQcm9wVHlwZXMuc3RyaW5nLFxuICBzdHJva2VXaWR0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgc3Ryb2tlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBmaWxsOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBjdXJ2ZTogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIEFyZWEoX3JlZikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgeCA9IF9yZWYueCxcbiAgICAgIHgwID0gX3JlZi54MCxcbiAgICAgIHgxID0gX3JlZi54MSxcbiAgICAgIHkgPSBfcmVmLnksXG4gICAgICB5MCA9IF9yZWYueTAsXG4gICAgICB5MSA9IF9yZWYueTEsXG4gICAgICB4U2NhbGUgPSBfcmVmLnhTY2FsZSxcbiAgICAgIHlTY2FsZSA9IF9yZWYueVNjYWxlLFxuICAgICAgX3JlZiRkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgZGF0YSA9IF9yZWYkZGF0YSA9PT0gdW5kZWZpbmVkID8gW10gOiBfcmVmJGRhdGEsXG4gICAgICBfcmVmJGRlZmluZWQgPSBfcmVmLmRlZmluZWQsXG4gICAgICBkZWZpbmVkID0gX3JlZiRkZWZpbmVkID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gOiBfcmVmJGRlZmluZWQsXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIHN0cm9rZURhc2hhcnJheSA9IF9yZWYuc3Ryb2tlRGFzaGFycmF5LFxuICAgICAgX3JlZiRzdHJva2VXaWR0aCA9IF9yZWYuc3Ryb2tlV2lkdGgsXG4gICAgICBzdHJva2VXaWR0aCA9IF9yZWYkc3Ryb2tlV2lkdGggPT09IHVuZGVmaW5lZCA/IDIgOiBfcmVmJHN0cm9rZVdpZHRoLFxuICAgICAgX3JlZiRzdHJva2UgPSBfcmVmLnN0cm9rZSxcbiAgICAgIHN0cm9rZSA9IF9yZWYkc3Ryb2tlID09PSB1bmRlZmluZWQgPyAnYmxhY2snIDogX3JlZiRzdHJva2UsXG4gICAgICBfcmVmJGZpbGwgPSBfcmVmLmZpbGwsXG4gICAgICBmaWxsID0gX3JlZiRmaWxsID09PSB1bmRlZmluZWQgPyAncmdiYSgwLDAsMCwwLjMpJyA6IF9yZWYkZmlsbCxcbiAgICAgIGN1cnZlID0gX3JlZi5jdXJ2ZSxcbiAgICAgIGlubmVyUmVmID0gX3JlZi5pbm5lclJlZixcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnY2hpbGRyZW4nLCAneCcsICd4MCcsICd4MScsICd5JywgJ3kwJywgJ3kxJywgJ3hTY2FsZScsICd5U2NhbGUnLCAnZGF0YScsICdkZWZpbmVkJywgJ2NsYXNzTmFtZScsICdzdHJva2VEYXNoYXJyYXknLCAnc3Ryb2tlV2lkdGgnLCAnc3Ryb2tlJywgJ2ZpbGwnLCAnY3VydmUnLCAnaW5uZXJSZWYnXSk7XG5cbiAgdmFyIHBhdGgkJDEgPSBhcmVhKCk7XG4gIGlmICh4KSBwYXRoJCQxLngoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB4U2NhbGUoeC5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykpO1xuICB9KTtcbiAgaWYgKHgwKSBwYXRoJCQxLngwKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4geFNjYWxlKHgwLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSk7XG4gIH0pO1xuICBpZiAoeDEpIHBhdGgkJDEueDEoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB4U2NhbGUoeDEuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKTtcbiAgfSk7XG4gIGlmICh5KSBwYXRoJCQxLnkoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB5U2NhbGUoeS5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykpO1xuICB9KTtcbiAgaWYgKHkwKSBwYXRoJCQxLnkwKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4geVNjYWxlKHkwLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSk7XG4gIH0pO1xuICBpZiAoeTEpIHBhdGgkJDEueTEoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB5U2NhbGUoeTEuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKTtcbiAgfSk7XG4gIGlmIChkZWZpbmVkKSBwYXRoJCQxLmRlZmluZWQoZGVmaW5lZCk7XG4gIGlmIChjdXJ2ZSkgcGF0aCQkMS5jdXJ2ZShjdXJ2ZSk7XG4gIGlmIChjaGlsZHJlbikgcmV0dXJuIGNoaWxkcmVuKHsgcGF0aDogcGF0aCQkMSB9KTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgJ2cnLFxuICAgIG51bGwsXG4gICAgUmVhY3QuY3JlYXRlRWxlbWVudCgncGF0aCcsIF9leHRlbmRzKHtcbiAgICAgIHJlZjogaW5uZXJSZWYsXG4gICAgICBjbGFzc05hbWU6IGN4KCd2eC1hcmVhJywgY2xhc3NOYW1lKSxcbiAgICAgIGQ6IHBhdGgkJDEoZGF0YSksXG4gICAgICBzdHJva2U6IHN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZURhc2hhcnJheTogc3Ryb2tlRGFzaGFycmF5LFxuICAgICAgZmlsbDogZmlsbFxuICAgIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSlcbiAgKTtcbn1cblxuQXJlYUNsb3NlZC5wcm9wVHlwZXMgPSB7XG4gIGlubmVyUmVmOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuZnVuY3Rpb24gQXJlYUNsb3NlZChfcmVmKSB7XG4gIHZhciB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueSxcbiAgICAgIHkwID0gX3JlZi55MCxcbiAgICAgIHhTY2FsZSA9IF9yZWYueFNjYWxlLFxuICAgICAgeVNjYWxlID0gX3JlZi55U2NhbGUsXG4gICAgICBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgX3JlZiRkZWZpbmVkID0gX3JlZi5kZWZpbmVkLFxuICAgICAgZGVmaW5lZCA9IF9yZWYkZGVmaW5lZCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IDogX3JlZiRkZWZpbmVkLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBzdHJva2VEYXNoYXJyYXkgPSBfcmVmLnN0cm9rZURhc2hhcnJheSxcbiAgICAgIF9yZWYkc3Ryb2tlV2lkdGggPSBfcmVmLnN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlV2lkdGggPSBfcmVmJHN0cm9rZVdpZHRoID09PSB1bmRlZmluZWQgPyAyIDogX3JlZiRzdHJva2VXaWR0aCxcbiAgICAgIF9yZWYkc3Ryb2tlID0gX3JlZi5zdHJva2UsXG4gICAgICBzdHJva2UgPSBfcmVmJHN0cm9rZSA9PT0gdW5kZWZpbmVkID8gJ2JsYWNrJyA6IF9yZWYkc3Ryb2tlLFxuICAgICAgX3JlZiRmaWxsID0gX3JlZi5maWxsLFxuICAgICAgZmlsbCA9IF9yZWYkZmlsbCA9PT0gdW5kZWZpbmVkID8gJ3JnYmEoMCwwLDAsMC4zKScgOiBfcmVmJGZpbGwsXG4gICAgICBjdXJ2ZSA9IF9yZWYuY3VydmUsXG4gICAgICBpbm5lclJlZiA9IF9yZWYuaW5uZXJSZWYsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ3gnLCAneScsICd5MCcsICd4U2NhbGUnLCAneVNjYWxlJywgJ2RhdGEnLCAnZGVmaW5lZCcsICdjbGFzc05hbWUnLCAnc3Ryb2tlRGFzaGFycmF5JywgJ3N0cm9rZVdpZHRoJywgJ3N0cm9rZScsICdmaWxsJywgJ2N1cnZlJywgJ2lubmVyUmVmJ10pO1xuXG4gIHZhciBwYXRoJCQxID0gYXJlYSgpLngoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB4U2NhbGUoeC5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykpO1xuICB9KS55MCh5MCB8fCB5U2NhbGUucmFuZ2UoKVswXSkueTEoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB5U2NhbGUoeS5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykpO1xuICB9KS5kZWZpbmVkKGRlZmluZWQpO1xuICBpZiAoY3VydmUpIHBhdGgkJDEuY3VydmUoY3VydmUpO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAnZycsXG4gICAgbnVsbCxcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgICAgcmVmOiBpbm5lclJlZixcbiAgICAgIGNsYXNzTmFtZTogY3goJ3Z4LWFyZWEtY2xvc2VkJywgY2xhc3NOYW1lKSxcbiAgICAgIGQ6IHBhdGgkJDEoZGF0YSksXG4gICAgICBzdHJva2U6IHN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZURhc2hhcnJheTogc3Ryb2tlRGFzaGFycmF5LFxuICAgICAgZmlsbDogZmlsbFxuICAgIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSlcbiAgKTtcbn1cblxuZnVuY3Rpb24gQXJlYVN0YWNrKF9yZWYpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgX3JlZiR0b3AgPSBfcmVmLnRvcCxcbiAgICAgIF9yZWYkbGVmdCA9IF9yZWYubGVmdCxcbiAgICAgIGtleXMgPSBfcmVmLmtleXMsXG4gICAgICBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgY3VydmUgPSBfcmVmLmN1cnZlLFxuICAgICAgZGVmaW5lZCA9IF9yZWYuZGVmaW5lZCxcbiAgICAgIHggPSBfcmVmLngsXG4gICAgICB4MCA9IF9yZWYueDAsXG4gICAgICB4MSA9IF9yZWYueDEsXG4gICAgICB5MCA9IF9yZWYueTAsXG4gICAgICB5MSA9IF9yZWYueTEsXG4gICAgICBnbHlwaCA9IF9yZWYuZ2x5cGgsXG4gICAgICBfcmVmJHJldmVyc2UgPSBfcmVmLnJldmVyc2UsXG4gICAgICByZXZlcnNlID0gX3JlZiRyZXZlcnNlID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkcmV2ZXJzZSxcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnY2xhc3NOYW1lJywgJ3RvcCcsICdsZWZ0JywgJ2tleXMnLCAnZGF0YScsICdjdXJ2ZScsICdkZWZpbmVkJywgJ3gnLCAneDAnLCAneDEnLCAneTAnLCAneTEnLCAnZ2x5cGgnLCAncmV2ZXJzZSddKTtcblxuICB2YXIgc3RhY2skJDEgPSBzdGFjaygpO1xuICBpZiAoa2V5cykgc3RhY2skJDEua2V5cyhrZXlzKTtcblxuICB2YXIgcGF0aCQkMSA9IGFyZWEoKTtcbiAgaWYgKHgpIHBhdGgkJDEueCh4KTtcbiAgaWYgKHgwKSBwYXRoJCQxLngwKHgwKTtcbiAgaWYgKHgxKSBwYXRoJCQxLngxKHgxKTtcbiAgaWYgKHkwKSBwYXRoJCQxLnkwKHkwKTtcbiAgaWYgKHkxKSBwYXRoJCQxLnkxKHkxKTtcbiAgaWYgKGN1cnZlKSBwYXRoJCQxLmN1cnZlKGN1cnZlKTtcbiAgaWYgKGRlZmluZWQpIHBhdGgkJDEuZGVmaW5lZChkZWZpbmVkKTtcblxuICB2YXIgc2VyaWVzRGF0YSA9IHN0YWNrJCQxKGRhdGEpO1xuICBpZiAocmV2ZXJzZSkgc2VyaWVzRGF0YS5yZXZlcnNlKCk7XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgJ2cnLFxuICAgIG51bGwsXG4gICAgc2VyaWVzRGF0YS5tYXAoZnVuY3Rpb24gKHNlcmllcywgaSkge1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCBfZXh0ZW5kcyh7XG4gICAgICAgIGNsYXNzTmFtZTogY3goJ3Z4LWFyZWEtc3RhY2snLCBjbGFzc05hbWUpLFxuICAgICAgICBrZXk6ICdhcmVhLXN0YWNrLScgKyBpICsgJy0nICsgKHNlcmllcy5rZXkgfHwgJycpLFxuICAgICAgICBkOiBwYXRoJCQxKHNlcmllcylcbiAgICAgIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIHtcbiAgICAgICAgZGF0dW06IHNlcmllc1tpXSxcbiAgICAgICAgaW5kZXg6IGksXG4gICAgICAgIHNlcmllczogc2VyaWVzXG4gICAgICB9KSkpO1xuICAgIH0pLFxuICAgICEhZ2x5cGggJiYgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICdnJyxcbiAgICAgIHsgY2xhc3NOYW1lOiAndngtYXJlYS1zdGFjay1nbHlwaHMnIH0sXG4gICAgICBkYXRhLm1hcChnbHlwaClcbiAgICApXG4gICk7XG59XG5cbkJhci5wcm9wVHlwZXMgPSB7XG4gIGlubmVyUmVmOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuZnVuY3Rpb24gQmFyKF9yZWYpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgaW5uZXJSZWYgPSBfcmVmLmlubmVyUmVmLFxuICAgICAgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgIF9yZWYkeCA9IF9yZWYueCxcbiAgICAgIHggPSBfcmVmJHggPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmJHgsXG4gICAgICBfcmVmJHkgPSBfcmVmLnksXG4gICAgICB5ID0gX3JlZiR5ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiR5LFxuICAgICAgd2lkdGggPSBfcmVmLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQsXG4gICAgICByeCA9IF9yZWYucngsXG4gICAgICByeSA9IF9yZWYucnksXG4gICAgICBfcmVmJGZpbGwgPSBfcmVmLmZpbGwsXG4gICAgICBmaWxsID0gX3JlZiRmaWxsID09PSB1bmRlZmluZWQgPyAnc3RlZWxibHVlJyA6IF9yZWYkZmlsbCxcbiAgICAgIGZpbGxPcGFjaXR5ID0gX3JlZi5maWxsT3BhY2l0eSxcbiAgICAgIHN0cm9rZSA9IF9yZWYuc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGggPSBfcmVmLnN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlRGFzaGFycmF5ID0gX3JlZi5zdHJva2VEYXNoYXJyYXksXG4gICAgICBzdHJva2VMaW5lY2FwID0gX3JlZi5zdHJva2VMaW5lY2FwLFxuICAgICAgc3Ryb2tlTGluZWpvaW4gPSBfcmVmLnN0cm9rZUxpbmVqb2luLFxuICAgICAgc3Ryb2tlTWl0ZXJsaW1pdCA9IF9yZWYuc3Ryb2tlTWl0ZXJsaW1pdCxcbiAgICAgIHN0cm9rZU9wYWNpdHkgPSBfcmVmLnN0cm9rZU9wYWNpdHksXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2NsYXNzTmFtZScsICdpbm5lclJlZicsICdkYXRhJywgJ3gnLCAneScsICd3aWR0aCcsICdoZWlnaHQnLCAncngnLCAncnknLCAnZmlsbCcsICdmaWxsT3BhY2l0eScsICdzdHJva2UnLCAnc3Ryb2tlV2lkdGgnLCAnc3Ryb2tlRGFzaGFycmF5JywgJ3N0cm9rZUxpbmVjYXAnLCAnc3Ryb2tlTGluZWpvaW4nLCAnc3Ryb2tlTWl0ZXJsaW1pdCcsICdzdHJva2VPcGFjaXR5J10pO1xuXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdyZWN0JywgX2V4dGVuZHMoe1xuICAgIHJlZjogaW5uZXJSZWYsXG4gICAgY2xhc3NOYW1lOiBjeCgndngtYmFyJywgY2xhc3NOYW1lKSxcbiAgICB4OiB4LFxuICAgIHk6IHksXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHJ4OiByeCxcbiAgICByeTogcnksXG4gICAgZmlsbDogZmlsbCxcbiAgICBmaWxsT3BhY2l0eTogZmlsbE9wYWNpdHksXG4gICAgc3Ryb2tlOiBzdHJva2UsXG4gICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgIHN0cm9rZURhc2hhcnJheTogc3Ryb2tlRGFzaGFycmF5LFxuICAgIHN0cm9rZUxpbmVjYXA6IHN0cm9rZUxpbmVjYXAsXG4gICAgc3Ryb2tlTGluZWpvaW46IHN0cm9rZUxpbmVqb2luLFxuICAgIHN0cm9rZU1pdGVybGltaXQ6IHN0cm9rZU1pdGVybGltaXQsXG4gICAgc3Ryb2tlT3BhY2l0eTogc3Ryb2tlT3BhY2l0eVxuICB9LCBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzLCBkYXRhKSkpO1xufVxuXG5mdW5jdGlvbiBCYXJHcm91cChfcmVmKSB7XG4gIHZhciBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICB0b3AgPSBfcmVmLnRvcCxcbiAgICAgIGxlZnQgPSBfcmVmLmxlZnQsXG4gICAgICB4MCA9IF9yZWYueDAsXG4gICAgICB4MFNjYWxlID0gX3JlZi54MFNjYWxlLFxuICAgICAgeDFTY2FsZSA9IF9yZWYueDFTY2FsZSxcbiAgICAgIHlTY2FsZSA9IF9yZWYueVNjYWxlLFxuICAgICAgelNjYWxlID0gX3JlZi56U2NhbGUsXG4gICAgICBrZXlzID0gX3JlZi5rZXlzLFxuICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2RhdGEnLCAnY2xhc3NOYW1lJywgJ3RvcCcsICdsZWZ0JywgJ3gwJywgJ3gwU2NhbGUnLCAneDFTY2FsZScsICd5U2NhbGUnLCAnelNjYWxlJywgJ2tleXMnLCAnaGVpZ2h0J10pO1xuXG4gIHZhciBmb3JtYXQgPSB4MFNjYWxlLnRpY2tGb3JtYXQgPyB4MFNjYWxlLnRpY2tGb3JtYXQoKSA6IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQ7XG4gIH07XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIEdyb3VwLFxuICAgIHsgY2xhc3NOYW1lOiBjeCgndngtYmFyLWdyb3VwJywgY2xhc3NOYW1lKSwgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfSxcbiAgICBkYXRhICYmIGRhdGEubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgR3JvdXAsXG4gICAgICAgIHsga2V5OiAnYmFyLWdyb3VwLScgKyBpICsgJy0nICsgeDAoZCksIGxlZnQ6IHgwU2NhbGUoeDAoZCkpIH0sXG4gICAgICAgIGtleXMgJiYga2V5cy5tYXAoZnVuY3Rpb24gKGtleSwgaSkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGRba2V5XTtcbiAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChCYXIsIF9leHRlbmRzKHtcbiAgICAgICAgICAgIGtleTogJ2Jhci1ncm91cC1iYXItJyArIGkgKyAnLScgKyB2YWx1ZSArICctJyArIGtleSxcbiAgICAgICAgICAgIHg6IHgxU2NhbGUoa2V5KSxcbiAgICAgICAgICAgIHk6IHlTY2FsZSh2YWx1ZSksXG4gICAgICAgICAgICB3aWR0aDogeDFTY2FsZS5iYW5kd2lkdGgoKSxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0IC0geVNjYWxlKHZhbHVlKSxcbiAgICAgICAgICAgIGZpbGw6IHpTY2FsZShrZXkpLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICB4OiBmb3JtYXQoeDAoZCkpLFxuICAgICAgICAgICAgICBkYXRhOiBkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVzdFByb3BzKSk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pXG4gICk7XG59XG5cbkJhckdyb3VwLnByb3BUeXBlcyA9IHtcbiAgZGF0YTogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsXG4gIHgwOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB4MFNjYWxlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB4MVNjYWxlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB5U2NhbGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHpTY2FsZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAga2V5czogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsXG4gIGhlaWdodDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRvcDogUHJvcFR5cGVzLm51bWJlcixcbiAgbGVmdDogUHJvcFR5cGVzLm51bWJlclxufTtcblxuZnVuY3Rpb24gQmFyR3JvdXBIb3Jpem9udGFsKF9yZWYpIHtcbiAgdmFyIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIHRvcCA9IF9yZWYudG9wLFxuICAgICAgbGVmdCA9IF9yZWYubGVmdCxcbiAgICAgIHkwID0gX3JlZi55MCxcbiAgICAgIHkwU2NhbGUgPSBfcmVmLnkwU2NhbGUsXG4gICAgICB5MVNjYWxlID0gX3JlZi55MVNjYWxlLFxuICAgICAgeFNjYWxlID0gX3JlZi54U2NhbGUsXG4gICAgICB6U2NhbGUgPSBfcmVmLnpTY2FsZSxcbiAgICAgIGtleXMgPSBfcmVmLmtleXMsXG4gICAgICB3aWR0aCA9IF9yZWYud2lkdGgsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2RhdGEnLCAnY2xhc3NOYW1lJywgJ3RvcCcsICdsZWZ0JywgJ3kwJywgJ3kwU2NhbGUnLCAneTFTY2FsZScsICd4U2NhbGUnLCAnelNjYWxlJywgJ2tleXMnLCAnd2lkdGgnXSk7XG5cbiAgdmFyIGZvcm1hdCA9IHkwU2NhbGUudGlja0Zvcm1hdCA/IHkwU2NhbGUudGlja0Zvcm1hdCgpIDogZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZDtcbiAgfTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgR3JvdXAsXG4gICAgeyBjbGFzc05hbWU6IGN4KCd2eC1iYXItZ3JvdXAtaG9yaXpvbnRhbCcsIGNsYXNzTmFtZSksIHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH0sXG4gICAgZGF0YSAmJiBkYXRhLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIEdyb3VwLFxuICAgICAgICB7IGtleTogJ2Jhci1ncm91cC0nICsgaSArICctJyArIHkwKGQpLCB0b3A6IHkwU2NhbGUoeTAoZCkpIH0sXG4gICAgICAgIGtleXMgJiYga2V5cy5tYXAoZnVuY3Rpb24gKGtleSwgaSkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGRba2V5XTtcbiAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChCYXIsIF9leHRlbmRzKHtcbiAgICAgICAgICAgIGtleTogJ2Jhci1ncm91cC1iYXItJyArIGkgKyAnLScgKyB2YWx1ZSArICctJyArIGtleSxcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiB5MVNjYWxlKGtleSksXG4gICAgICAgICAgICB3aWR0aDogd2lkdGggLSB4U2NhbGUodmFsdWUpLFxuICAgICAgICAgICAgaGVpZ2h0OiB5MVNjYWxlLmJhbmR3aWR0aCgpLFxuICAgICAgICAgICAgZmlsbDogelNjYWxlKGtleSksXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgIHk6IGZvcm1hdCh5MChkKSksXG4gICAgICAgICAgICAgIGRhdGE6IGRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCByZXN0UHJvcHMpKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSlcbiAgKTtcbn1cblxuQmFyR3JvdXBIb3Jpem9udGFsLnByb3BUeXBlcyA9IHtcbiAgZGF0YTogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsXG4gIHkwOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB5MFNjYWxlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB5MVNjYWxlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB4U2NhbGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHpTY2FsZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAga2V5czogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsXG4gIHdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdG9wOiBQcm9wVHlwZXMubnVtYmVyLFxuICBsZWZ0OiBQcm9wVHlwZXMubnVtYmVyXG59O1xuXG5mdW5jdGlvbiBCYXJTdGFjayhfcmVmKSB7XG4gIHZhciBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICB0b3AgPSBfcmVmLnRvcCxcbiAgICAgIGxlZnQgPSBfcmVmLmxlZnQsXG4gICAgICB4ID0gX3JlZi54LFxuICAgICAgeFNjYWxlID0gX3JlZi54U2NhbGUsXG4gICAgICB5U2NhbGUgPSBfcmVmLnlTY2FsZSxcbiAgICAgIHpTY2FsZSA9IF9yZWYuelNjYWxlLFxuICAgICAga2V5cyA9IF9yZWYua2V5cyxcbiAgICAgIGhlaWdodCA9IF9yZWYuaGVpZ2h0LFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgWydkYXRhJywgJ2NsYXNzTmFtZScsICd0b3AnLCAnbGVmdCcsICd4JywgJ3hTY2FsZScsICd5U2NhbGUnLCAnelNjYWxlJywgJ2tleXMnLCAnaGVpZ2h0J10pO1xuXG4gIHZhciBzZXJpZXMgPSBzdGFjaygpLmtleXMoa2V5cykoZGF0YSk7XG4gIHZhciBmb3JtYXQgPSB4U2NhbGUudGlja0Zvcm1hdCA/IHhTY2FsZS50aWNrRm9ybWF0KCkgOiBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkO1xuICB9O1xuICB2YXIgYmFuZHdpZHRoID0geFNjYWxlLmJhbmR3aWR0aCgpO1xuICB2YXIgc3RlcCA9IHhTY2FsZS5zdGVwKCk7XG4gIHZhciBwYWRkaW5nSW5uZXIgPSB4U2NhbGUucGFkZGluZ0lubmVyKCk7XG4gIHZhciBwYWRkaW5nT3V0ZXIgPSB4U2NhbGUucGFkZGluZ091dGVyKCk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIEdyb3VwLFxuICAgIHsgY2xhc3NOYW1lOiBjeCgndngtYmFyLXN0YWNrJywgY2xhc3NOYW1lKSwgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfSxcbiAgICBzZXJpZXMgJiYgc2VyaWVzLm1hcChmdW5jdGlvbiAocywgaSkge1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIEdyb3VwLFxuICAgICAgICB7IGtleTogJ3Z4LWJhci1zdGFjay0nICsgaSB9LFxuICAgICAgICBzLm1hcChmdW5jdGlvbiAoZCwgaWkpIHtcbiAgICAgICAgICB2YXIgYmFySGVpZ2h0ID0geVNjYWxlKGRbMF0pIC0geVNjYWxlKGRbMV0pO1xuICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEJhciwgX2V4dGVuZHMoe1xuICAgICAgICAgICAga2V5OiAnYmFyLWdyb3VwLWJhci0nICsgaSArICctJyArIGlpICsgJy0nICsgcy5rZXksXG4gICAgICAgICAgICB4OiB4U2NhbGUoeChkLmRhdGEpKSxcbiAgICAgICAgICAgIHk6IHlTY2FsZShkWzFdKSxcbiAgICAgICAgICAgIHdpZHRoOiBiYW5kd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGJhckhlaWdodCxcbiAgICAgICAgICAgIGZpbGw6IHpTY2FsZShzLmtleSksXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIGJhbmR3aWR0aDogYmFuZHdpZHRoLFxuICAgICAgICAgICAgICBwYWRkaW5nSW5uZXI6IHBhZGRpbmdJbm5lcixcbiAgICAgICAgICAgICAgcGFkZGluZ091dGVyOiBwYWRkaW5nT3V0ZXIsXG4gICAgICAgICAgICAgIHN0ZXA6IHN0ZXAsXG4gICAgICAgICAgICAgIGtleTogcy5rZXksXG4gICAgICAgICAgICAgIHZhbHVlOiBkWzFdLFxuICAgICAgICAgICAgICBoZWlnaHQ6IGJhckhlaWdodCxcbiAgICAgICAgICAgICAgd2lkdGg6IGJhbmR3aWR0aCxcbiAgICAgICAgICAgICAgeDogeChkLmRhdGEpLFxuICAgICAgICAgICAgICB4Rm9ybWF0dGVkOiBmb3JtYXQoeChkLmRhdGEpKSxcbiAgICAgICAgICAgICAgZGF0YTogZC5kYXRhXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVzdFByb3BzKSk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pXG4gICk7XG59XG5cbkJhclN0YWNrLnByb3BUeXBlcyA9IHtcbiAgZGF0YTogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsXG4gIHg6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHhTY2FsZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgeVNjYWxlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB6U2NhbGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIGtleXM6IFByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLFxuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRvcDogUHJvcFR5cGVzLm51bWJlcixcbiAgbGVmdDogUHJvcFR5cGVzLm51bWJlclxufTtcblxuZnVuY3Rpb24gQmFyU3RhY2tIb3Jpem9udGFsKF9yZWYpIHtcbiAgdmFyIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIHRvcCA9IF9yZWYudG9wLFxuICAgICAgbGVmdCA9IF9yZWYubGVmdCxcbiAgICAgIHkgPSBfcmVmLnksXG4gICAgICB4U2NhbGUgPSBfcmVmLnhTY2FsZSxcbiAgICAgIHlTY2FsZSA9IF9yZWYueVNjYWxlLFxuICAgICAgelNjYWxlID0gX3JlZi56U2NhbGUsXG4gICAgICBrZXlzID0gX3JlZi5rZXlzLFxuICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2RhdGEnLCAnY2xhc3NOYW1lJywgJ3RvcCcsICdsZWZ0JywgJ3knLCAneFNjYWxlJywgJ3lTY2FsZScsICd6U2NhbGUnLCAna2V5cycsICdoZWlnaHQnXSk7XG5cbiAgdmFyIHNlcmllcyA9IHN0YWNrKCkua2V5cyhrZXlzKShkYXRhKTtcbiAgdmFyIGZvcm1hdCA9IHlTY2FsZS50aWNrRm9ybWF0ID8geVNjYWxlLnRpY2tGb3JtYXQoKSA6IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQ7XG4gIH07XG4gIHZhciBiYW5kd2lkdGggPSB5U2NhbGUuYmFuZHdpZHRoKCk7XG4gIHZhciBzdGVwID0geVNjYWxlLnN0ZXAoKTtcbiAgdmFyIHBhZGRpbmdJbm5lciA9IHlTY2FsZS5wYWRkaW5nSW5uZXIoKTtcbiAgdmFyIHBhZGRpbmdPdXRlciA9IHlTY2FsZS5wYWRkaW5nT3V0ZXIoKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgR3JvdXAsXG4gICAgeyBjbGFzc05hbWU6IGN4KCd2eC1iYXItc3RhY2staG9yaXpvbnRhbCcsIGNsYXNzTmFtZSksIHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH0sXG4gICAgc2VyaWVzICYmIHNlcmllcy5tYXAoZnVuY3Rpb24gKHMsIGkpIHtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICBHcm91cCxcbiAgICAgICAgeyBrZXk6ICd2eC1iYXItc3RhY2staG9yaXpvbnRhbC0nICsgaSB9LFxuICAgICAgICBzLm1hcChmdW5jdGlvbiAoZCwgaWkpIHtcbiAgICAgICAgICB2YXIgYmFyV2lkdGggPSB4U2NhbGUoZFsxXSkgLSB4U2NhbGUoZFswXSk7XG4gICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQmFyLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgICBrZXk6ICdiYXItZ3JvdXAtYmFyLScgKyBpICsgJy0nICsgaWkgKyAnLScgKyBzLmtleSxcbiAgICAgICAgICAgIHg6IHhTY2FsZShkWzBdKSxcbiAgICAgICAgICAgIHk6IHlTY2FsZSh5KGQuZGF0YSkpLFxuICAgICAgICAgICAgd2lkdGg6IGJhcldpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBiYW5kd2lkdGgsXG4gICAgICAgICAgICBmaWxsOiB6U2NhbGUocy5rZXkpLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBiYW5kd2lkdGg6IGJhbmR3aWR0aCxcbiAgICAgICAgICAgICAgcGFkZGluZ0lubmVyOiBwYWRkaW5nSW5uZXIsXG4gICAgICAgICAgICAgIHBhZGRpbmdPdXRlcjogcGFkZGluZ091dGVyLFxuICAgICAgICAgICAgICBzdGVwOiBzdGVwLFxuICAgICAgICAgICAgICBrZXk6IHMua2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogZFswXSxcbiAgICAgICAgICAgICAgaGVpZ2h0OiBiYW5kd2lkdGgsXG4gICAgICAgICAgICAgIHdpZHRoOiBiYXJXaWR0aCxcbiAgICAgICAgICAgICAgeTogeShkLmRhdGEpLFxuICAgICAgICAgICAgICB5Rm9ybWF0dGVkOiBmb3JtYXQoeShkLmRhdGEpKSxcbiAgICAgICAgICAgICAgZGF0YTogZC5kYXRhXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVzdFByb3BzKSk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pXG4gICk7XG59XG5cbkJhclN0YWNrSG9yaXpvbnRhbC5wcm9wVHlwZXMgPSB7XG4gIGRhdGE6IFByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLFxuICB5OiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB4U2NhbGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHlTY2FsZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgelNjYWxlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBrZXlzOiBQcm9wVHlwZXMuYXJyYXkuaXNSZXF1aXJlZCxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICB0b3A6IFByb3BUeXBlcy5udW1iZXIsXG4gIGxlZnQ6IFByb3BUeXBlcy5udW1iZXJcbn07XG5cbnZhciBTVEFDS19PUkRFUlMgPSB7XG4gIGFzY2VuZGluZzogc3RhY2tPcmRlckFzY2VuZGluZyxcbiAgZGVzY2VuZGluZzogc3RhY2tPcmRlckRlc2NlbmRpbmcsXG4gIGluc2lkZW91dDogc3RhY2tPcmRlckluc2lkZU91dCxcbiAgbm9uZTogc3RhY2tPcmRlck5vbmUsXG4gIHJldmVyc2U6IHN0YWNrT3JkZXJSZXZlcnNlXG59O1xuXG52YXIgU1RBQ0tfT1JERVJfTkFNRVMgPSBPYmplY3Qua2V5cyhTVEFDS19PUkRFUlMpO1xuXG5mdW5jdGlvbiBzdGFja09yZGVyKG9yZGVyKSB7XG4gIHJldHVybiBTVEFDS19PUkRFUlNbb3JkZXJdIHx8IFNUQUNLX09SREVSUy5ub25lO1xufVxuXG52YXIgU1RBQ0tfT0ZGU0VUUyA9IHtcbiAgZXhwYW5kOiBzdGFja09mZnNldEV4cGFuZCxcbiAgZGl2ZXJnaW5nOiBzdGFja09mZnNldERpdmVyZ2luZyxcbiAgbm9uZTogc3RhY2tPZmZzZXROb25lLFxuICBzaWxob3VldHRlOiBzdGFja09mZnNldFNpbGhvdWV0dGUsXG4gIHdpZ2dsZTogc3RhY2tPZmZzZXRXaWdnbGVcbn07XG5cbnZhciBTVEFDS19PRkZTRVRfTkFNRVMgPSBPYmplY3Qua2V5cyhTVEFDS19PRkZTRVRTKTtcblxuZnVuY3Rpb24gc3RhY2tPZmZzZXQob2Zmc2V0KSB7XG4gIHJldHVybiBTVEFDS19PRkZTRVRTW29mZnNldF0gfHwgU1RBQ0tfT0ZGU0VUUy5ub25lO1xufVxuXG5mdW5jdGlvbiBTdGFjayhfcmVmKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIF9yZWYkdG9wID0gX3JlZi50b3AsXG4gICAgICB0b3AgPSBfcmVmJHRvcCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkdG9wLFxuICAgICAgX3JlZiRsZWZ0ID0gX3JlZi5sZWZ0LFxuICAgICAgbGVmdCA9IF9yZWYkbGVmdCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkbGVmdCxcbiAgICAgIGtleXMgPSBfcmVmLmtleXMsXG4gICAgICBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgY3VydmUgPSBfcmVmLmN1cnZlLFxuICAgICAgZGVmaW5lZCA9IF9yZWYuZGVmaW5lZCxcbiAgICAgIHggPSBfcmVmLngsXG4gICAgICB4MCA9IF9yZWYueDAsXG4gICAgICB4MSA9IF9yZWYueDEsXG4gICAgICB5MCA9IF9yZWYueTAsXG4gICAgICB5MSA9IF9yZWYueTEsXG4gICAgICB2YWx1ZSA9IF9yZWYudmFsdWUsXG4gICAgICBvcmRlciA9IF9yZWYub3JkZXIsXG4gICAgICBvZmZzZXQgPSBfcmVmLm9mZnNldCxcbiAgICAgIHJlbmRlciA9IF9yZWYucmVuZGVyLFxuICAgICAgX3JlZiRyZXZlcnNlID0gX3JlZi5yZXZlcnNlLFxuICAgICAgcmV2ZXJzZSA9IF9yZWYkcmV2ZXJzZSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJHJldmVyc2UsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2NsYXNzTmFtZScsICd0b3AnLCAnbGVmdCcsICdrZXlzJywgJ2RhdGEnLCAnY3VydmUnLCAnZGVmaW5lZCcsICd4JywgJ3gwJywgJ3gxJywgJ3kwJywgJ3kxJywgJ3ZhbHVlJywgJ29yZGVyJywgJ29mZnNldCcsICdyZW5kZXInLCAncmV2ZXJzZSddKTtcblxuICB2YXIgc3RhY2skJDEgPSBzdGFjaygpO1xuICBpZiAoa2V5cykgc3RhY2skJDEua2V5cyhrZXlzKTtcbiAgaWYgKHZhbHVlKSBzdGFjayQkMS52YWx1ZSh2YWx1ZSk7XG4gIGlmIChvcmRlcikgc3RhY2skJDEub3JkZXIoc3RhY2tPcmRlcihvcmRlcikpO1xuICBpZiAob2Zmc2V0KSBzdGFjayQkMS5vZmZzZXQoc3RhY2tPZmZzZXQob2Zmc2V0KSk7XG5cbiAgdmFyIHBhdGgkJDEgPSBhcmVhKCk7XG4gIGlmICh4KSBwYXRoJCQxLngoeCk7XG4gIGlmICh4MCkgcGF0aCQkMS54MCh4MCk7XG4gIGlmICh4MSkgcGF0aCQkMS54MSh4MSk7XG4gIGlmICh5MCkgcGF0aCQkMS55MCh5MCk7XG4gIGlmICh5MSkgcGF0aCQkMS55MSh5MSk7XG4gIGlmIChjdXJ2ZSkgcGF0aCQkMS5jdXJ2ZShjdXJ2ZSk7XG4gIGlmIChkZWZpbmVkKSBwYXRoJCQxLmRlZmluZWQoZGVmaW5lZCk7XG5cbiAgdmFyIHNlcmllc0RhdGEgPSBzdGFjayQkMShkYXRhKTtcbiAgaWYgKHJldmVyc2UpIHNlcmllc0RhdGEucmV2ZXJzZSgpO1xuXG4gIGlmIChyZW5kZXIpIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIEdyb3VwLFxuICAgIHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfSxcbiAgICByZW5kZXIoeyBzZXJpZXNEYXRhOiBzZXJpZXNEYXRhLCBwYXRoOiBwYXRoJCQxIH0pXG4gICk7XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgR3JvdXAsXG4gICAgeyB0b3A6IHRvcCwgbGVmdDogbGVmdCB9LFxuICAgIHNlcmllc0RhdGEubWFwKGZ1bmN0aW9uIChzZXJpZXMsIGkpIHtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgICAgICBjbGFzc05hbWU6IGN4KCd2eC1zdGFjaycsIGNsYXNzTmFtZSksXG4gICAgICAgIGtleTogJ3N0YWNrLScgKyBpICsgJy0nICsgKHNlcmllcy5rZXkgfHwgJycpLFxuICAgICAgICBkOiBwYXRoJCQxKHNlcmllcylcbiAgICAgIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIHtcbiAgICAgICAgZGF0dW06IHNlcmllc1tpXSxcbiAgICAgICAgaW5kZXg6IGksXG4gICAgICAgIHNlcmllczogc2VyaWVzXG4gICAgICB9KSkpO1xuICAgIH0pXG4gICk7XG59XG5cbnZhciBkZWdyZWVzVG9SYWRpYW5zID0gZnVuY3Rpb24gZGVncmVlc1RvUmFkaWFucyhkZWdyZWVzKSB7XG4gIHJldHVybiBNYXRoLlBJIC8gMTgwICogZGVncmVlcztcbn07XG5cbmZ1bmN0aW9uIHBhdGhIb3Jpem9udGFsRGlhZ29uYWwoX3JlZikge1xuICB2YXIgc291cmNlID0gX3JlZi5zb3VyY2UsXG4gICAgICB0YXJnZXQgPSBfcmVmLnRhcmdldCxcbiAgICAgIHggPSBfcmVmLngsXG4gICAgICB5ID0gX3JlZi55O1xuXG4gIHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBsaW5rID0gbGlua0hvcml6b250YWwoKTtcbiAgICBsaW5rLngoeCk7XG4gICAgbGluay55KHkpO1xuICAgIGxpbmsuc291cmNlKHNvdXJjZSk7XG4gICAgbGluay50YXJnZXQodGFyZ2V0KTtcbiAgICByZXR1cm4gbGluayhkYXRhKTtcbiAgfTtcbn1cblxuTGlua0hvcml6b250YWwucHJvcFR5cGVzID0ge1xuICBpbm5lclJlZjogUHJvcFR5cGVzLmZ1bmMsXG4gIHg6IFByb3BUeXBlcy5mdW5jLFxuICB5OiBQcm9wVHlwZXMuZnVuYyxcbiAgc291cmNlOiBQcm9wVHlwZXMuZnVuYyxcbiAgdGFyZ2V0OiBQcm9wVHlwZXMuZnVuYyxcbiAgcGF0aDogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIExpbmtIb3Jpem9udGFsKF9yZWYyKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmMi5jbGFzc05hbWUsXG4gICAgICBpbm5lclJlZiA9IF9yZWYyLmlubmVyUmVmLFxuICAgICAgZGF0YSA9IF9yZWYyLmRhdGEsXG4gICAgICBwYXRoJCQxID0gX3JlZjIucGF0aCxcbiAgICAgIF9yZWYyJHggPSBfcmVmMi54LFxuICAgICAgeCA9IF9yZWYyJHggPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueTtcbiAgfSA6IF9yZWYyJHgsXG4gICAgICBfcmVmMiR5ID0gX3JlZjIueSxcbiAgICAgIHkgPSBfcmVmMiR5ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLng7XG4gIH0gOiBfcmVmMiR5LFxuICAgICAgX3JlZjIkc291cmNlID0gX3JlZjIuc291cmNlLFxuICAgICAgc291cmNlID0gX3JlZjIkc291cmNlID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnNvdXJjZTtcbiAgfSA6IF9yZWYyJHNvdXJjZSxcbiAgICAgIF9yZWYyJHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgIHRhcmdldCA9IF9yZWYyJHRhcmdldCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC50YXJnZXQ7XG4gIH0gOiBfcmVmMiR0YXJnZXQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgWydjbGFzc05hbWUnLCAnaW5uZXJSZWYnLCAnZGF0YScsICdwYXRoJywgJ3gnLCAneScsICdzb3VyY2UnLCAndGFyZ2V0J10pO1xuXG4gIHBhdGgkJDEgPSBwYXRoJCQxIHx8IHBhdGhIb3Jpem9udGFsRGlhZ29uYWwoeyBzb3VyY2U6IHNvdXJjZSwgdGFyZ2V0OiB0YXJnZXQsIHg6IHgsIHk6IHkgfSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgIHJlZjogaW5uZXJSZWYsXG4gICAgY2xhc3NOYW1lOiBjeCgndngtbGluay1ob3Jpem9udGFsJywgY2xhc3NOYW1lKSxcbiAgICBkOiBwYXRoJCQxKGRhdGEpXG4gIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSk7XG59XG5cbmZ1bmN0aW9uIHBhdGhWZXJ0aWNhbERpYWdvbmFsKF9yZWYpIHtcbiAgdmFyIHNvdXJjZSA9IF9yZWYuc291cmNlLFxuICAgICAgdGFyZ2V0ID0gX3JlZi50YXJnZXQsXG4gICAgICB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueTtcblxuICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgbGluayA9IGxpbmtWZXJ0aWNhbCgpO1xuICAgIGxpbmsueCh4KTtcbiAgICBsaW5rLnkoeSk7XG4gICAgbGluay5zb3VyY2Uoc291cmNlKTtcbiAgICBsaW5rLnRhcmdldCh0YXJnZXQpO1xuICAgIHJldHVybiBsaW5rKGRhdGEpO1xuICB9O1xufVxuXG5MaW5rVmVydGljYWwucHJvcFR5cGVzID0ge1xuICBpbm5lclJlZjogUHJvcFR5cGVzLmZ1bmMsXG4gIHg6IFByb3BUeXBlcy5mdW5jLFxuICB5OiBQcm9wVHlwZXMuZnVuYyxcbiAgc291cmNlOiBQcm9wVHlwZXMuZnVuYyxcbiAgdGFyZ2V0OiBQcm9wVHlwZXMuZnVuYyxcbiAgcGF0aDogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIExpbmtWZXJ0aWNhbChfcmVmMikge1xuICB2YXIgY2xhc3NOYW1lID0gX3JlZjIuY2xhc3NOYW1lLFxuICAgICAgaW5uZXJSZWYgPSBfcmVmMi5pbm5lclJlZixcbiAgICAgIGRhdGEgPSBfcmVmMi5kYXRhLFxuICAgICAgcGF0aCQkMSA9IF9yZWYyLnBhdGgsXG4gICAgICBfcmVmMiR4ID0gX3JlZjIueCxcbiAgICAgIHggPSBfcmVmMiR4ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLng7XG4gIH0gOiBfcmVmMiR4LFxuICAgICAgX3JlZjIkeSA9IF9yZWYyLnksXG4gICAgICB5ID0gX3JlZjIkeSA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC55O1xuICB9IDogX3JlZjIkeSxcbiAgICAgIF9yZWYyJHNvdXJjZSA9IF9yZWYyLnNvdXJjZSxcbiAgICAgIHNvdXJjZSA9IF9yZWYyJHNvdXJjZSA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC5zb3VyY2U7XG4gIH0gOiBfcmVmMiRzb3VyY2UsXG4gICAgICBfcmVmMiR0YXJnZXQgPSBfcmVmMi50YXJnZXQsXG4gICAgICB0YXJnZXQgPSBfcmVmMiR0YXJnZXQgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQudGFyZ2V0O1xuICB9IDogX3JlZjIkdGFyZ2V0LFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjIsIFsnY2xhc3NOYW1lJywgJ2lubmVyUmVmJywgJ2RhdGEnLCAncGF0aCcsICd4JywgJ3knLCAnc291cmNlJywgJ3RhcmdldCddKTtcblxuICBwYXRoJCQxID0gcGF0aCQkMSB8fCBwYXRoVmVydGljYWxEaWFnb25hbCh7IHNvdXJjZTogc291cmNlLCB0YXJnZXQ6IHRhcmdldCwgeDogeCwgeTogeSB9KTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBpbm5lclJlZixcbiAgICBjbGFzc05hbWU6IGN4KCd2eC1saW5rLXZlcnRpY2FsJywgY2xhc3NOYW1lKSxcbiAgICBkOiBwYXRoJCQxKGRhdGEpXG4gIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSk7XG59XG5cbmZ1bmN0aW9uIHBhdGhSYWRpYWxEaWFnb25hbChfcmVmKSB7XG4gIHZhciBzb3VyY2UgPSBfcmVmLnNvdXJjZSxcbiAgICAgIHRhcmdldCA9IF9yZWYudGFyZ2V0LFxuICAgICAgYW5nbGUgPSBfcmVmLmFuZ2xlLFxuICAgICAgcmFkaXVzID0gX3JlZi5yYWRpdXM7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIGxpbmsgPSBsaW5rUmFkaWFsKCk7XG4gICAgbGluay5hbmdsZShhbmdsZSk7XG4gICAgbGluay5yYWRpdXMocmFkaXVzKTtcbiAgICBsaW5rLnNvdXJjZShzb3VyY2UpO1xuICAgIGxpbmsudGFyZ2V0KHRhcmdldCk7XG4gICAgcmV0dXJuIGxpbmsoZGF0YSk7XG4gIH07XG59XG5cbkxpbmtSYWRpYWwucHJvcFR5cGVzID0ge1xuICBpbm5lclJlZjogUHJvcFR5cGVzLmZ1bmMsXG4gIGFuZ2xlOiBQcm9wVHlwZXMuZnVuYyxcbiAgcmFkaXVzOiBQcm9wVHlwZXMuZnVuYyxcbiAgc291cmNlOiBQcm9wVHlwZXMuZnVuYyxcbiAgdGFyZ2V0OiBQcm9wVHlwZXMuZnVuYyxcbiAgcGF0aDogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIExpbmtSYWRpYWwoX3JlZjIpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYyLmNsYXNzTmFtZSxcbiAgICAgIGlubmVyUmVmID0gX3JlZjIuaW5uZXJSZWYsXG4gICAgICBkYXRhID0gX3JlZjIuZGF0YSxcbiAgICAgIHBhdGgkJDEgPSBfcmVmMi5wYXRoLFxuICAgICAgX3JlZjIkYW5nbGUgPSBfcmVmMi5hbmdsZSxcbiAgICAgIGFuZ2xlID0gX3JlZjIkYW5nbGUgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueDtcbiAgfSA6IF9yZWYyJGFuZ2xlLFxuICAgICAgX3JlZjIkcmFkaXVzID0gX3JlZjIucmFkaXVzLFxuICAgICAgcmFkaXVzID0gX3JlZjIkcmFkaXVzID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnk7XG4gIH0gOiBfcmVmMiRyYWRpdXMsXG4gICAgICBfcmVmMiRzb3VyY2UgPSBfcmVmMi5zb3VyY2UsXG4gICAgICBzb3VyY2UgPSBfcmVmMiRzb3VyY2UgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQuc291cmNlO1xuICB9IDogX3JlZjIkc291cmNlLFxuICAgICAgX3JlZjIkdGFyZ2V0ID0gX3JlZjIudGFyZ2V0LFxuICAgICAgdGFyZ2V0ID0gX3JlZjIkdGFyZ2V0ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnRhcmdldDtcbiAgfSA6IF9yZWYyJHRhcmdldCxcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYyLCBbJ2NsYXNzTmFtZScsICdpbm5lclJlZicsICdkYXRhJywgJ3BhdGgnLCAnYW5nbGUnLCAncmFkaXVzJywgJ3NvdXJjZScsICd0YXJnZXQnXSk7XG5cbiAgcGF0aCQkMSA9IHBhdGgkJDEgfHwgcGF0aFJhZGlhbERpYWdvbmFsKHsgc291cmNlOiBzb3VyY2UsIHRhcmdldDogdGFyZ2V0LCBhbmdsZTogYW5nbGUsIHJhZGl1czogcmFkaXVzIH0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgncGF0aCcsIF9leHRlbmRzKHtcbiAgICByZWY6IGlubmVyUmVmLFxuICAgIGNsYXNzTmFtZTogY3goJ3Z4LWxpbmstcmFkaXVzJywgY2xhc3NOYW1lKSxcbiAgICBkOiBwYXRoJCQxKGRhdGEpXG4gIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSk7XG59XG5cbmZ1bmN0aW9uIHBhdGhIb3Jpem9udGFsQ3VydmUoX3JlZikge1xuICB2YXIgc291cmNlID0gX3JlZi5zb3VyY2UsXG4gICAgICB0YXJnZXQgPSBfcmVmLnRhcmdldCxcbiAgICAgIHggPSBfcmVmLngsXG4gICAgICB5ID0gX3JlZi55LFxuICAgICAgcGVyY2VudCA9IF9yZWYucGVyY2VudDtcblxuICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgc291cmNlRGF0YSA9IHNvdXJjZShkYXRhKTtcbiAgICB2YXIgdGFyZ2V0RGF0YSA9IHRhcmdldChkYXRhKTtcblxuICAgIHZhciBzeCA9IHgoc291cmNlRGF0YSk7XG4gICAgdmFyIHN5ID0geShzb3VyY2VEYXRhKTtcbiAgICB2YXIgdHggPSB4KHRhcmdldERhdGEpO1xuICAgIHZhciB0eSA9IHkodGFyZ2V0RGF0YSk7XG5cbiAgICB2YXIgZHggPSB0eCAtIHN4O1xuICAgIHZhciBkeSA9IHR5IC0gc3k7XG4gICAgdmFyIGl4ID0gcGVyY2VudCAqIChkeCArIGR5KTtcbiAgICB2YXIgaXkgPSBwZXJjZW50ICogKGR5IC0gZHgpO1xuXG4gICAgdmFyIHBhdGgkJDEgPSBwYXRoKCk7XG4gICAgcGF0aCQkMS5tb3ZlVG8oc3gsIHN5KTtcbiAgICBwYXRoJCQxLmJlemllckN1cnZlVG8oc3ggKyBpeCwgc3kgKyBpeSwgdHggKyBpeSwgdHkgLSBpeCwgdHgsIHR5KTtcblxuICAgIHJldHVybiBwYXRoJCQxLnRvU3RyaW5nKCk7XG4gIH07XG59XG5cbkxpbmtIb3Jpem9udGFsQ3VydmUucHJvcFR5cGVzID0ge1xuICBpbm5lclJlZjogUHJvcFR5cGVzLmZ1bmMsXG4gIHBlcmNlbnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIHg6IFByb3BUeXBlcy5mdW5jLFxuICB5OiBQcm9wVHlwZXMuZnVuYyxcbiAgc291cmNlOiBQcm9wVHlwZXMuZnVuYyxcbiAgdGFyZ2V0OiBQcm9wVHlwZXMuZnVuYyxcbiAgcGF0aDogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIExpbmtIb3Jpem9udGFsQ3VydmUoX3JlZjIpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYyLmNsYXNzTmFtZSxcbiAgICAgIGlubmVyUmVmID0gX3JlZjIuaW5uZXJSZWYsXG4gICAgICBkYXRhID0gX3JlZjIuZGF0YSxcbiAgICAgIHBhdGgkJDEgPSBfcmVmMi5wYXRoLFxuICAgICAgX3JlZjIkeCA9IF9yZWYyLngsXG4gICAgICB4ID0gX3JlZjIkeCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC55O1xuICB9IDogX3JlZjIkeCxcbiAgICAgIF9yZWYyJHkgPSBfcmVmMi55LFxuICAgICAgeSA9IF9yZWYyJHkgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueDtcbiAgfSA6IF9yZWYyJHksXG4gICAgICBfcmVmMiRzb3VyY2UgPSBfcmVmMi5zb3VyY2UsXG4gICAgICBzb3VyY2UgPSBfcmVmMiRzb3VyY2UgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQuc291cmNlO1xuICB9IDogX3JlZjIkc291cmNlLFxuICAgICAgX3JlZjIkdGFyZ2V0ID0gX3JlZjIudGFyZ2V0LFxuICAgICAgdGFyZ2V0ID0gX3JlZjIkdGFyZ2V0ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnRhcmdldDtcbiAgfSA6IF9yZWYyJHRhcmdldCxcbiAgICAgIF9yZWYyJHBlcmNlbnQgPSBfcmVmMi5wZXJjZW50LFxuICAgICAgcGVyY2VudCA9IF9yZWYyJHBlcmNlbnQgPT09IHVuZGVmaW5lZCA/IDAuMiA6IF9yZWYyJHBlcmNlbnQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgWydjbGFzc05hbWUnLCAnaW5uZXJSZWYnLCAnZGF0YScsICdwYXRoJywgJ3gnLCAneScsICdzb3VyY2UnLCAndGFyZ2V0JywgJ3BlcmNlbnQnXSk7XG5cbiAgcGF0aCQkMSA9IHBhdGgkJDEgfHwgcGF0aEhvcml6b250YWxDdXJ2ZSh7IHNvdXJjZTogc291cmNlLCB0YXJnZXQ6IHRhcmdldCwgeDogeCwgeTogeSwgcGVyY2VudDogcGVyY2VudCB9KTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBpbm5lclJlZixcbiAgICBjbGFzc05hbWU6IGN4KCd2eC1saW5rJywgY2xhc3NOYW1lKSxcbiAgICBkOiBwYXRoJCQxKGRhdGEpXG4gIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSk7XG59XG5cbmZ1bmN0aW9uIHBhdGhWZXJ0aWNhbEN1cnZlKF9yZWYpIHtcbiAgdmFyIHNvdXJjZSA9IF9yZWYuc291cmNlLFxuICAgICAgdGFyZ2V0ID0gX3JlZi50YXJnZXQsXG4gICAgICB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueSxcbiAgICAgIHBlcmNlbnQgPSBfcmVmLnBlcmNlbnQ7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIHNvdXJjZURhdGEgPSBzb3VyY2UoZGF0YSk7XG4gICAgdmFyIHRhcmdldERhdGEgPSB0YXJnZXQoZGF0YSk7XG5cbiAgICB2YXIgc3ggPSB4KHNvdXJjZURhdGEpO1xuICAgIHZhciBzeSA9IHkoc291cmNlRGF0YSk7XG4gICAgdmFyIHR4ID0geCh0YXJnZXREYXRhKTtcbiAgICB2YXIgdHkgPSB5KHRhcmdldERhdGEpO1xuXG4gICAgdmFyIGR4ID0gdHggLSBzeDtcbiAgICB2YXIgZHkgPSB0eSAtIHN5O1xuICAgIHZhciBpeCA9IHBlcmNlbnQgKiAoZHggKyBkeSk7XG4gICAgdmFyIGl5ID0gcGVyY2VudCAqIChkeSAtIGR4KTtcblxuICAgIHZhciBwYXRoJCQxID0gcGF0aCgpO1xuICAgIHBhdGgkJDEubW92ZVRvKHN4LCBzeSk7XG4gICAgcGF0aCQkMS5iZXppZXJDdXJ2ZVRvKHN4ICsgaXgsIHN5ICsgaXksIHR4ICsgaXksIHR5IC0gaXgsIHR4LCB0eSk7XG5cbiAgICByZXR1cm4gcGF0aCQkMS50b1N0cmluZygpO1xuICB9O1xufVxuXG5MaW5rVmVydGljYWxDdXJ2ZS5wcm9wVHlwZXMgPSB7XG4gIGlubmVyUmVmOiBQcm9wVHlwZXMuZnVuYyxcbiAgcGVyY2VudDogUHJvcFR5cGVzLm51bWJlcixcbiAgeDogUHJvcFR5cGVzLmZ1bmMsXG4gIHk6IFByb3BUeXBlcy5mdW5jLFxuICBzb3VyY2U6IFByb3BUeXBlcy5mdW5jLFxuICB0YXJnZXQ6IFByb3BUeXBlcy5mdW5jLFxuICBwYXRoOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuZnVuY3Rpb24gTGlua1ZlcnRpY2FsQ3VydmUoX3JlZjIpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYyLmNsYXNzTmFtZSxcbiAgICAgIGlubmVyUmVmID0gX3JlZjIuaW5uZXJSZWYsXG4gICAgICBkYXRhID0gX3JlZjIuZGF0YSxcbiAgICAgIHBhdGgkJDEgPSBfcmVmMi5wYXRoLFxuICAgICAgX3JlZjIkeCA9IF9yZWYyLngsXG4gICAgICB4ID0gX3JlZjIkeCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC54O1xuICB9IDogX3JlZjIkeCxcbiAgICAgIF9yZWYyJHkgPSBfcmVmMi55LFxuICAgICAgeSA9IF9yZWYyJHkgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueTtcbiAgfSA6IF9yZWYyJHksXG4gICAgICBfcmVmMiRzb3VyY2UgPSBfcmVmMi5zb3VyY2UsXG4gICAgICBzb3VyY2UgPSBfcmVmMiRzb3VyY2UgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQuc291cmNlO1xuICB9IDogX3JlZjIkc291cmNlLFxuICAgICAgX3JlZjIkdGFyZ2V0ID0gX3JlZjIudGFyZ2V0LFxuICAgICAgdGFyZ2V0ID0gX3JlZjIkdGFyZ2V0ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnRhcmdldDtcbiAgfSA6IF9yZWYyJHRhcmdldCxcbiAgICAgIF9yZWYyJHBlcmNlbnQgPSBfcmVmMi5wZXJjZW50LFxuICAgICAgcGVyY2VudCA9IF9yZWYyJHBlcmNlbnQgPT09IHVuZGVmaW5lZCA/IDAuMiA6IF9yZWYyJHBlcmNlbnQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgWydjbGFzc05hbWUnLCAnaW5uZXJSZWYnLCAnZGF0YScsICdwYXRoJywgJ3gnLCAneScsICdzb3VyY2UnLCAndGFyZ2V0JywgJ3BlcmNlbnQnXSk7XG5cbiAgcGF0aCQkMSA9IHBhdGgkJDEgfHwgcGF0aFZlcnRpY2FsQ3VydmUoeyBzb3VyY2U6IHNvdXJjZSwgdGFyZ2V0OiB0YXJnZXQsIHg6IHgsIHk6IHksIHBlcmNlbnQ6IHBlcmNlbnQgfSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgIHJlZjogaW5uZXJSZWYsXG4gICAgY2xhc3NOYW1lOiBjeCgndngtbGluaycsIGNsYXNzTmFtZSksXG4gICAgZDogcGF0aCQkMShkYXRhKVxuICB9LCBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzLCBkYXRhKSkpO1xufVxuXG5mdW5jdGlvbiBwYXRoUmFkaWFsQ3VydmUoX3JlZikge1xuICB2YXIgc291cmNlID0gX3JlZi5zb3VyY2UsXG4gICAgICB0YXJnZXQgPSBfcmVmLnRhcmdldCxcbiAgICAgIHggPSBfcmVmLngsXG4gICAgICB5ID0gX3JlZi55LFxuICAgICAgcGVyY2VudCA9IF9yZWYucGVyY2VudDtcblxuICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgc291cmNlRGF0YSA9IHNvdXJjZShkYXRhKTtcbiAgICB2YXIgdGFyZ2V0RGF0YSA9IHRhcmdldChkYXRhKTtcblxuICAgIHZhciBzYSA9IHgoc291cmNlRGF0YSkgLSBNYXRoLlBJIC8gMjtcbiAgICB2YXIgc3IgPSB5KHNvdXJjZURhdGEpO1xuICAgIHZhciB0YSA9IHgodGFyZ2V0RGF0YSkgLSBNYXRoLlBJIC8gMjtcbiAgICB2YXIgdHIgPSB5KHRhcmdldERhdGEpO1xuXG4gICAgdmFyIHNjID0gTWF0aC5jb3Moc2EpO1xuICAgIHZhciBzcyA9IE1hdGguc2luKHNhKTtcbiAgICB2YXIgdGMgPSBNYXRoLmNvcyh0YSk7XG4gICAgdmFyIHRzID0gTWF0aC5zaW4odGEpO1xuXG4gICAgdmFyIHN4ID0gc3IgKiBzYztcbiAgICB2YXIgc3kgPSBzciAqIHNzO1xuICAgIHZhciB0eCA9IHRyICogdGM7XG4gICAgdmFyIHR5ID0gdHIgKiB0cztcblxuICAgIHZhciBkeCA9IHR4IC0gc3g7XG4gICAgdmFyIGR5ID0gdHkgLSBzeTtcbiAgICB2YXIgaXggPSBwZXJjZW50ICogKGR4ICsgZHkpO1xuICAgIHZhciBpeSA9IHBlcmNlbnQgKiAoZHkgLSBkeCk7XG5cbiAgICB2YXIgcGF0aCQkMSA9IHBhdGgoKTtcbiAgICBwYXRoJCQxLm1vdmVUbyhzeCwgc3kpO1xuICAgIHBhdGgkJDEuYmV6aWVyQ3VydmVUbyhzeCArIGl4LCBzeSArIGl5LCB0eCArIGl5LCB0eSAtIGl4LCB0eCwgdHkpO1xuXG4gICAgcmV0dXJuIHBhdGgkJDEudG9TdHJpbmcoKTtcbiAgfTtcbn1cblxuTGlua1JhZGlhbEN1cnZlLnByb3BUeXBlcyA9IHtcbiAgaW5uZXJSZWY6IFByb3BUeXBlcy5mdW5jLFxuICBwZXJjZW50OiBQcm9wVHlwZXMubnVtYmVyLFxuICB4OiBQcm9wVHlwZXMuZnVuYyxcbiAgeTogUHJvcFR5cGVzLmZ1bmMsXG4gIHNvdXJjZTogUHJvcFR5cGVzLmZ1bmMsXG4gIHRhcmdldDogUHJvcFR5cGVzLmZ1bmMsXG4gIHBhdGg6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5mdW5jdGlvbiBMaW5rUmFkaWFsQ3VydmUoX3JlZjIpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYyLmNsYXNzTmFtZSxcbiAgICAgIGlubmVyUmVmID0gX3JlZjIuaW5uZXJSZWYsXG4gICAgICBkYXRhID0gX3JlZjIuZGF0YSxcbiAgICAgIHBhdGgkJDEgPSBfcmVmMi5wYXRoLFxuICAgICAgX3JlZjIkeCA9IF9yZWYyLngsXG4gICAgICB4ID0gX3JlZjIkeCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC54O1xuICB9IDogX3JlZjIkeCxcbiAgICAgIF9yZWYyJHkgPSBfcmVmMi55LFxuICAgICAgeSA9IF9yZWYyJHkgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueTtcbiAgfSA6IF9yZWYyJHksXG4gICAgICBfcmVmMiRzb3VyY2UgPSBfcmVmMi5zb3VyY2UsXG4gICAgICBzb3VyY2UgPSBfcmVmMiRzb3VyY2UgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQuc291cmNlO1xuICB9IDogX3JlZjIkc291cmNlLFxuICAgICAgX3JlZjIkdGFyZ2V0ID0gX3JlZjIudGFyZ2V0LFxuICAgICAgdGFyZ2V0ID0gX3JlZjIkdGFyZ2V0ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnRhcmdldDtcbiAgfSA6IF9yZWYyJHRhcmdldCxcbiAgICAgIF9yZWYyJHBlcmNlbnQgPSBfcmVmMi5wZXJjZW50LFxuICAgICAgcGVyY2VudCA9IF9yZWYyJHBlcmNlbnQgPT09IHVuZGVmaW5lZCA/IDAuMiA6IF9yZWYyJHBlcmNlbnQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgWydjbGFzc05hbWUnLCAnaW5uZXJSZWYnLCAnZGF0YScsICdwYXRoJywgJ3gnLCAneScsICdzb3VyY2UnLCAndGFyZ2V0JywgJ3BlcmNlbnQnXSk7XG5cbiAgcGF0aCQkMSA9IHBhdGgkJDEgfHwgcGF0aFJhZGlhbEN1cnZlKHsgc291cmNlOiBzb3VyY2UsIHRhcmdldDogdGFyZ2V0LCB4OiB4LCB5OiB5LCBwZXJjZW50OiBwZXJjZW50IH0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgncGF0aCcsIF9leHRlbmRzKHtcbiAgICByZWY6IGlubmVyUmVmLFxuICAgIGNsYXNzTmFtZTogY3goJ3Z4LWxpbmsnLCBjbGFzc05hbWUpLFxuICAgIGQ6IHBhdGgkJDEoZGF0YSlcbiAgfSwgYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcywgZGF0YSkpKTtcbn1cblxuZnVuY3Rpb24gcGF0aEhvcml6b250YWxMaW5lKF9yZWYpIHtcbiAgdmFyIHNvdXJjZSA9IF9yZWYuc291cmNlLFxuICAgICAgdGFyZ2V0ID0gX3JlZi50YXJnZXQsXG4gICAgICB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueTtcblxuICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgc291cmNlRGF0YSA9IHNvdXJjZShkYXRhKTtcbiAgICB2YXIgdGFyZ2V0RGF0YSA9IHRhcmdldChkYXRhKTtcblxuICAgIHZhciBzeCA9IHgoc291cmNlRGF0YSk7XG4gICAgdmFyIHN5ID0geShzb3VyY2VEYXRhKTtcbiAgICB2YXIgdHggPSB4KHRhcmdldERhdGEpO1xuICAgIHZhciB0eSA9IHkodGFyZ2V0RGF0YSk7XG5cbiAgICB2YXIgcGF0aCQkMSA9IHBhdGgoKTtcbiAgICBwYXRoJCQxLm1vdmVUbyhzeCwgc3kpO1xuICAgIHBhdGgkJDEubGluZVRvKHR4LCB0eSk7XG5cbiAgICByZXR1cm4gcGF0aCQkMS50b1N0cmluZygpO1xuICB9O1xufVxuXG5MaW5rSG9yaXpvbnRhbExpbmUucHJvcFR5cGVzID0ge1xuICBpbm5lclJlZjogUHJvcFR5cGVzLmZ1bmMsXG4gIHBhdGg6IFByb3BUeXBlcy5mdW5jLFxuICB4OiBQcm9wVHlwZXMuZnVuYyxcbiAgeTogUHJvcFR5cGVzLmZ1bmMsXG4gIHNvdXJjZTogUHJvcFR5cGVzLmZ1bmMsXG4gIHRhcmdldDogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIExpbmtIb3Jpem9udGFsTGluZShfcmVmMikge1xuICB2YXIgY2xhc3NOYW1lID0gX3JlZjIuY2xhc3NOYW1lLFxuICAgICAgaW5uZXJSZWYgPSBfcmVmMi5pbm5lclJlZixcbiAgICAgIGRhdGEgPSBfcmVmMi5kYXRhLFxuICAgICAgcGF0aCQkMSA9IF9yZWYyLnBhdGgsXG4gICAgICBfcmVmMiR4ID0gX3JlZjIueCxcbiAgICAgIHggPSBfcmVmMiR4ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnk7XG4gIH0gOiBfcmVmMiR4LFxuICAgICAgX3JlZjIkeSA9IF9yZWYyLnksXG4gICAgICB5ID0gX3JlZjIkeSA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC54O1xuICB9IDogX3JlZjIkeSxcbiAgICAgIF9yZWYyJHNvdXJjZSA9IF9yZWYyLnNvdXJjZSxcbiAgICAgIHNvdXJjZSA9IF9yZWYyJHNvdXJjZSA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC5zb3VyY2U7XG4gIH0gOiBfcmVmMiRzb3VyY2UsXG4gICAgICBfcmVmMiR0YXJnZXQgPSBfcmVmMi50YXJnZXQsXG4gICAgICB0YXJnZXQgPSBfcmVmMiR0YXJnZXQgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQudGFyZ2V0O1xuICB9IDogX3JlZjIkdGFyZ2V0LFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjIsIFsnY2xhc3NOYW1lJywgJ2lubmVyUmVmJywgJ2RhdGEnLCAncGF0aCcsICd4JywgJ3knLCAnc291cmNlJywgJ3RhcmdldCddKTtcblxuICBwYXRoJCQxID0gcGF0aCQkMSB8fCBwYXRoSG9yaXpvbnRhbExpbmUoeyBzb3VyY2U6IHNvdXJjZSwgdGFyZ2V0OiB0YXJnZXQsIHg6IHgsIHk6IHkgfSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgIHJlZjogaW5uZXJSZWYsXG4gICAgY2xhc3NOYW1lOiBjeCgndngtbGluaycsIGNsYXNzTmFtZSksXG4gICAgZDogcGF0aCQkMShkYXRhKVxuICB9LCBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzLCBkYXRhKSkpO1xufVxuXG5mdW5jdGlvbiBwYXRoVmVydGljYWxMaW5lKF9yZWYpIHtcbiAgdmFyIHNvdXJjZSA9IF9yZWYuc291cmNlLFxuICAgICAgdGFyZ2V0ID0gX3JlZi50YXJnZXQsXG4gICAgICB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueTtcblxuICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgc291cmNlRGF0YSA9IHNvdXJjZShkYXRhKTtcbiAgICB2YXIgdGFyZ2V0RGF0YSA9IHRhcmdldChkYXRhKTtcblxuICAgIHZhciBzeCA9IHgoc291cmNlRGF0YSk7XG4gICAgdmFyIHN5ID0geShzb3VyY2VEYXRhKTtcbiAgICB2YXIgdHggPSB4KHRhcmdldERhdGEpO1xuICAgIHZhciB0eSA9IHkodGFyZ2V0RGF0YSk7XG5cbiAgICB2YXIgcGF0aCQkMSA9IHBhdGgoKTtcbiAgICBwYXRoJCQxLm1vdmVUbyhzeCwgc3kpO1xuICAgIHBhdGgkJDEubGluZVRvKHR4LCB0eSk7XG5cbiAgICByZXR1cm4gcGF0aCQkMS50b1N0cmluZygpO1xuICB9O1xufVxuXG5MaW5rVmVydGljYWxMaW5lLnByb3BUeXBlcyA9IHtcbiAgaW5uZXJSZWY6IFByb3BUeXBlcy5mdW5jLFxuICBwYXRoOiBQcm9wVHlwZXMuZnVuYyxcbiAgeDogUHJvcFR5cGVzLmZ1bmMsXG4gIHk6IFByb3BUeXBlcy5mdW5jLFxuICBzb3VyY2U6IFByb3BUeXBlcy5mdW5jLFxuICB0YXJnZXQ6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5mdW5jdGlvbiBMaW5rVmVydGljYWxMaW5lKF9yZWYyKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmMi5jbGFzc05hbWUsXG4gICAgICBpbm5lclJlZiA9IF9yZWYyLmlubmVyUmVmLFxuICAgICAgZGF0YSA9IF9yZWYyLmRhdGEsXG4gICAgICBwYXRoJCQxID0gX3JlZjIucGF0aCxcbiAgICAgIF9yZWYyJHggPSBfcmVmMi54LFxuICAgICAgeCA9IF9yZWYyJHggPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueDtcbiAgfSA6IF9yZWYyJHgsXG4gICAgICBfcmVmMiR5ID0gX3JlZjIueSxcbiAgICAgIHkgPSBfcmVmMiR5ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnk7XG4gIH0gOiBfcmVmMiR5LFxuICAgICAgX3JlZjIkc291cmNlID0gX3JlZjIuc291cmNlLFxuICAgICAgc291cmNlID0gX3JlZjIkc291cmNlID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnNvdXJjZTtcbiAgfSA6IF9yZWYyJHNvdXJjZSxcbiAgICAgIF9yZWYyJHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgIHRhcmdldCA9IF9yZWYyJHRhcmdldCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC50YXJnZXQ7XG4gIH0gOiBfcmVmMiR0YXJnZXQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgWydjbGFzc05hbWUnLCAnaW5uZXJSZWYnLCAnZGF0YScsICdwYXRoJywgJ3gnLCAneScsICdzb3VyY2UnLCAndGFyZ2V0J10pO1xuXG4gIHBhdGgkJDEgPSBwYXRoJCQxIHx8IHBhdGhWZXJ0aWNhbExpbmUoeyBzb3VyY2U6IHNvdXJjZSwgdGFyZ2V0OiB0YXJnZXQsIHg6IHgsIHk6IHkgfSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgIHJlZjogaW5uZXJSZWYsXG4gICAgY2xhc3NOYW1lOiBjeCgndngtbGluaycsIGNsYXNzTmFtZSksXG4gICAgZDogcGF0aCQkMShkYXRhKVxuICB9LCBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzLCBkYXRhKSkpO1xufVxuXG5mdW5jdGlvbiBwYXRoUmFkaWFsTGluZShfcmVmKSB7XG4gIHZhciBzb3VyY2UgPSBfcmVmLnNvdXJjZSxcbiAgICAgIHRhcmdldCA9IF9yZWYudGFyZ2V0LFxuICAgICAgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIHNvdXJjZURhdGEgPSBzb3VyY2UoZGF0YSk7XG4gICAgdmFyIHRhcmdldERhdGEgPSB0YXJnZXQoZGF0YSk7XG5cbiAgICB2YXIgc2EgPSB4KHNvdXJjZURhdGEpIC0gTWF0aC5QSSAvIDI7XG4gICAgdmFyIHNyID0geShzb3VyY2VEYXRhKTtcbiAgICB2YXIgdGEgPSB4KHRhcmdldERhdGEpIC0gTWF0aC5QSSAvIDI7XG4gICAgdmFyIHRyID0geSh0YXJnZXREYXRhKTtcblxuICAgIHZhciBzYyA9IE1hdGguY29zKHNhKTtcbiAgICB2YXIgc3MgPSBNYXRoLnNpbihzYSk7XG4gICAgdmFyIHRjID0gTWF0aC5jb3ModGEpO1xuICAgIHZhciB0cyA9IE1hdGguc2luKHRhKTtcblxuICAgIHZhciBwYXRoJCQxID0gcGF0aCgpO1xuICAgIHBhdGgkJDEubW92ZVRvKHNyICogc2MsIHNyICogc3MpO1xuICAgIHBhdGgkJDEubGluZVRvKHRyICogdGMsIHRyICogdHMpO1xuXG4gICAgcmV0dXJuIHBhdGgkJDEudG9TdHJpbmcoKTtcbiAgfTtcbn1cblxuTGlua1JhZGlhbFN0ZXAucHJvcFR5cGVzID0ge1xuICBpbm5lclJlZjogUHJvcFR5cGVzLmZ1bmMsXG4gIHBhdGg6IFByb3BUeXBlcy5mdW5jLFxuICB4OiBQcm9wVHlwZXMuZnVuYyxcbiAgeTogUHJvcFR5cGVzLmZ1bmMsXG4gIHNvdXJjZTogUHJvcFR5cGVzLmZ1bmMsXG4gIHRhcmdldDogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIExpbmtSYWRpYWxTdGVwKF9yZWYyKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmMi5jbGFzc05hbWUsXG4gICAgICBpbm5lclJlZiA9IF9yZWYyLmlubmVyUmVmLFxuICAgICAgZGF0YSA9IF9yZWYyLmRhdGEsXG4gICAgICBwYXRoJCQxID0gX3JlZjIucGF0aCxcbiAgICAgIF9yZWYyJHggPSBfcmVmMi54LFxuICAgICAgeCA9IF9yZWYyJHggPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueDtcbiAgfSA6IF9yZWYyJHgsXG4gICAgICBfcmVmMiR5ID0gX3JlZjIueSxcbiAgICAgIHkgPSBfcmVmMiR5ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnk7XG4gIH0gOiBfcmVmMiR5LFxuICAgICAgX3JlZjIkc291cmNlID0gX3JlZjIuc291cmNlLFxuICAgICAgc291cmNlID0gX3JlZjIkc291cmNlID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnNvdXJjZTtcbiAgfSA6IF9yZWYyJHNvdXJjZSxcbiAgICAgIF9yZWYyJHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgIHRhcmdldCA9IF9yZWYyJHRhcmdldCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC50YXJnZXQ7XG4gIH0gOiBfcmVmMiR0YXJnZXQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgWydjbGFzc05hbWUnLCAnaW5uZXJSZWYnLCAnZGF0YScsICdwYXRoJywgJ3gnLCAneScsICdzb3VyY2UnLCAndGFyZ2V0J10pO1xuXG4gIHBhdGgkJDEgPSBwYXRoJCQxIHx8IHBhdGhSYWRpYWxMaW5lKHsgc291cmNlOiBzb3VyY2UsIHRhcmdldDogdGFyZ2V0LCB4OiB4LCB5OiB5IH0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgncGF0aCcsIF9leHRlbmRzKHtcbiAgICByZWY6IGlubmVyUmVmLFxuICAgIGNsYXNzTmFtZTogY3goJ3Z4LWxpbmsnLCBjbGFzc05hbWUpLFxuICAgIGQ6IHBhdGgkJDEoZGF0YSlcbiAgfSwgYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcywgZGF0YSkpKTtcbn1cblxuZnVuY3Rpb24gcGF0aEhvcml6b250YWxTdGVwKF9yZWYpIHtcbiAgdmFyIHNvdXJjZSA9IF9yZWYuc291cmNlLFxuICAgICAgdGFyZ2V0ID0gX3JlZi50YXJnZXQsXG4gICAgICB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueSxcbiAgICAgIHBlcmNlbnQgPSBfcmVmLnBlcmNlbnQ7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIHNvdXJjZURhdGEgPSBzb3VyY2UoZGF0YSk7XG4gICAgdmFyIHRhcmdldERhdGEgPSB0YXJnZXQoZGF0YSk7XG5cbiAgICB2YXIgc3ggPSB4KHNvdXJjZURhdGEpO1xuICAgIHZhciBzeSA9IHkoc291cmNlRGF0YSk7XG4gICAgdmFyIHR4ID0geCh0YXJnZXREYXRhKTtcbiAgICB2YXIgdHkgPSB5KHRhcmdldERhdGEpO1xuXG4gICAgdmFyIHBhdGgkJDEgPSBwYXRoKCk7XG4gICAgcGF0aCQkMS5tb3ZlVG8oc3gsIHN5KTtcbiAgICBwYXRoJCQxLmxpbmVUbyhzeCArICh0eCAtIHN4KSAqIHBlcmNlbnQsIHN5KTtcbiAgICBwYXRoJCQxLmxpbmVUbyhzeCArICh0eCAtIHN4KSAqIHBlcmNlbnQsIHR5KTtcbiAgICBwYXRoJCQxLmxpbmVUbyh0eCwgdHkpO1xuXG4gICAgcmV0dXJuIHBhdGgkJDEudG9TdHJpbmcoKTtcbiAgfTtcbn1cblxuTGlua0hvcml6b250YWxTdGVwLnByb3BUeXBlcyA9IHtcbiAgaW5uZXJSZWY6IFByb3BUeXBlcy5mdW5jLFxuICBwZXJjZW50OiBQcm9wVHlwZXMubnVtYmVyLFxuICB4OiBQcm9wVHlwZXMuZnVuYyxcbiAgeTogUHJvcFR5cGVzLmZ1bmMsXG4gIHNvdXJjZTogUHJvcFR5cGVzLmZ1bmMsXG4gIHRhcmdldDogUHJvcFR5cGVzLmZ1bmMsXG4gIHBhdGg6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5mdW5jdGlvbiBMaW5rSG9yaXpvbnRhbFN0ZXAoX3JlZjIpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYyLmNsYXNzTmFtZSxcbiAgICAgIGlubmVyUmVmID0gX3JlZjIuaW5uZXJSZWYsXG4gICAgICBkYXRhID0gX3JlZjIuZGF0YSxcbiAgICAgIHBhdGgkJDEgPSBfcmVmMi5wYXRoLFxuICAgICAgX3JlZjIkcGVyY2VudCA9IF9yZWYyLnBlcmNlbnQsXG4gICAgICBwZXJjZW50ID0gX3JlZjIkcGVyY2VudCA9PT0gdW5kZWZpbmVkID8gMC41IDogX3JlZjIkcGVyY2VudCxcbiAgICAgIF9yZWYyJHggPSBfcmVmMi54LFxuICAgICAgeCA9IF9yZWYyJHggPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueTtcbiAgfSA6IF9yZWYyJHgsXG4gICAgICBfcmVmMiR5ID0gX3JlZjIueSxcbiAgICAgIHkgPSBfcmVmMiR5ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLng7XG4gIH0gOiBfcmVmMiR5LFxuICAgICAgX3JlZjIkc291cmNlID0gX3JlZjIuc291cmNlLFxuICAgICAgc291cmNlID0gX3JlZjIkc291cmNlID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnNvdXJjZTtcbiAgfSA6IF9yZWYyJHNvdXJjZSxcbiAgICAgIF9yZWYyJHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgIHRhcmdldCA9IF9yZWYyJHRhcmdldCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC50YXJnZXQ7XG4gIH0gOiBfcmVmMiR0YXJnZXQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgWydjbGFzc05hbWUnLCAnaW5uZXJSZWYnLCAnZGF0YScsICdwYXRoJywgJ3BlcmNlbnQnLCAneCcsICd5JywgJ3NvdXJjZScsICd0YXJnZXQnXSk7XG5cbiAgcGF0aCQkMSA9IHBhdGgkJDEgfHwgcGF0aEhvcml6b250YWxTdGVwKHsgc291cmNlOiBzb3VyY2UsIHRhcmdldDogdGFyZ2V0LCB4OiB4LCB5OiB5LCBwZXJjZW50OiBwZXJjZW50IH0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgncGF0aCcsIF9leHRlbmRzKHtcbiAgICByZWY6IGlubmVyUmVmLFxuICAgIGNsYXNzTmFtZTogY3goJ3Z4LWxpbmsnLCBjbGFzc05hbWUpLFxuICAgIGQ6IHBhdGgkJDEoZGF0YSlcbiAgfSwgYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcywgZGF0YSkpKTtcbn1cblxuZnVuY3Rpb24gcGF0aFZlcnRpY2FsU3RlcChfcmVmKSB7XG4gIHZhciBzb3VyY2UgPSBfcmVmLnNvdXJjZSxcbiAgICAgIHRhcmdldCA9IF9yZWYudGFyZ2V0LFxuICAgICAgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnksXG4gICAgICBwZXJjZW50ID0gX3JlZi5wZXJjZW50O1xuXG4gIHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBzb3VyY2VEYXRhID0gc291cmNlKGRhdGEpO1xuICAgIHZhciB0YXJnZXREYXRhID0gdGFyZ2V0KGRhdGEpO1xuXG4gICAgdmFyIHN4ID0geChzb3VyY2VEYXRhKTtcbiAgICB2YXIgc3kgPSB5KHNvdXJjZURhdGEpO1xuICAgIHZhciB0eCA9IHgodGFyZ2V0RGF0YSk7XG4gICAgdmFyIHR5ID0geSh0YXJnZXREYXRhKTtcblxuICAgIHZhciBwYXRoJCQxID0gcGF0aCgpO1xuICAgIHBhdGgkJDEubW92ZVRvKHN4LCBzeSk7XG4gICAgcGF0aCQkMS5saW5lVG8oc3gsIHN5ICsgKHR5IC0gc3kpICogcGVyY2VudCk7XG4gICAgcGF0aCQkMS5saW5lVG8odHgsIHN5ICsgKHR5IC0gc3kpICogcGVyY2VudCk7XG4gICAgcGF0aCQkMS5saW5lVG8odHgsIHR5KTtcblxuICAgIHJldHVybiBwYXRoJCQxLnRvU3RyaW5nKCk7XG4gIH07XG59XG5cbkxpbmtWZXJ0aWNhbFN0ZXAucHJvcFR5cGVzID0ge1xuICBpbm5lclJlZjogUHJvcFR5cGVzLmZ1bmMsXG4gIHBlcmNlbnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIHg6IFByb3BUeXBlcy5mdW5jLFxuICB5OiBQcm9wVHlwZXMuZnVuYyxcbiAgc291cmNlOiBQcm9wVHlwZXMuZnVuYyxcbiAgdGFyZ2V0OiBQcm9wVHlwZXMuZnVuYyxcbiAgcGF0aDogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIExpbmtWZXJ0aWNhbFN0ZXAoX3JlZjIpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYyLmNsYXNzTmFtZSxcbiAgICAgIGlubmVyUmVmID0gX3JlZjIuaW5uZXJSZWYsXG4gICAgICBkYXRhID0gX3JlZjIuZGF0YSxcbiAgICAgIHBhdGgkJDEgPSBfcmVmMi5wYXRoLFxuICAgICAgX3JlZjIkcGVyY2VudCA9IF9yZWYyLnBlcmNlbnQsXG4gICAgICBwZXJjZW50ID0gX3JlZjIkcGVyY2VudCA9PT0gdW5kZWZpbmVkID8gMC41IDogX3JlZjIkcGVyY2VudCxcbiAgICAgIF9yZWYyJHggPSBfcmVmMi54LFxuICAgICAgeCA9IF9yZWYyJHggPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueDtcbiAgfSA6IF9yZWYyJHgsXG4gICAgICBfcmVmMiR5ID0gX3JlZjIueSxcbiAgICAgIHkgPSBfcmVmMiR5ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnk7XG4gIH0gOiBfcmVmMiR5LFxuICAgICAgX3JlZjIkc291cmNlID0gX3JlZjIuc291cmNlLFxuICAgICAgc291cmNlID0gX3JlZjIkc291cmNlID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnNvdXJjZTtcbiAgfSA6IF9yZWYyJHNvdXJjZSxcbiAgICAgIF9yZWYyJHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgIHRhcmdldCA9IF9yZWYyJHRhcmdldCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC50YXJnZXQ7XG4gIH0gOiBfcmVmMiR0YXJnZXQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgWydjbGFzc05hbWUnLCAnaW5uZXJSZWYnLCAnZGF0YScsICdwYXRoJywgJ3BlcmNlbnQnLCAneCcsICd5JywgJ3NvdXJjZScsICd0YXJnZXQnXSk7XG5cbiAgcGF0aCQkMSA9IHBhdGgkJDEgfHwgcGF0aFZlcnRpY2FsU3RlcCh7IHNvdXJjZTogc291cmNlLCB0YXJnZXQ6IHRhcmdldCwgeDogeCwgeTogeSwgcGVyY2VudDogcGVyY2VudCB9KTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBpbm5lclJlZixcbiAgICBjbGFzc05hbWU6IGN4KCd2eC1saW5rJywgY2xhc3NOYW1lKSxcbiAgICBkOiBwYXRoJCQxKGRhdGEpXG4gIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSk7XG59XG5cbmZ1bmN0aW9uIHBhdGhSYWRpYWxTdGVwKF9yZWYpIHtcbiAgdmFyIHNvdXJjZSA9IF9yZWYuc291cmNlLFxuICAgICAgdGFyZ2V0ID0gX3JlZi50YXJnZXQsXG4gICAgICB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueTtcblxuICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgc291cmNlRGF0YSA9IHNvdXJjZShkYXRhKTtcbiAgICB2YXIgdGFyZ2V0RGF0YSA9IHRhcmdldChkYXRhKTtcblxuICAgIHZhciBzeCA9IHgoc291cmNlRGF0YSk7XG4gICAgdmFyIHN5ID0geShzb3VyY2VEYXRhKTtcbiAgICB2YXIgdHggPSB4KHRhcmdldERhdGEpO1xuICAgIHZhciB0eSA9IHkodGFyZ2V0RGF0YSk7XG5cbiAgICB2YXIgc2EgPSBzeCAtIE1hdGguUEkgLyAyO1xuICAgIHZhciBzciA9IHN5O1xuICAgIHZhciB0YSA9IHR4IC0gTWF0aC5QSSAvIDI7XG4gICAgdmFyIHRyID0gdHk7XG5cbiAgICB2YXIgc2MgPSBNYXRoLmNvcyhzYSk7XG4gICAgdmFyIHNzID0gTWF0aC5zaW4oc2EpO1xuICAgIHZhciB0YyA9IE1hdGguY29zKHRhKTtcbiAgICB2YXIgdHMgPSBNYXRoLnNpbih0YSk7XG4gICAgdmFyIHNmID0gTWF0aC5hYnModGEgLSBzYSkgPiBNYXRoLlBJID8gdGEgPD0gc2EgOiB0YSA+IHNhO1xuXG4gICAgcmV0dXJuICdcXG4gICAgICBNJyArIHNyICogc2MgKyAnLCcgKyBzciAqIHNzICsgJ1xcbiAgICAgIEEnICsgc3IgKyAnLCcgKyBzciArICcsMCwwLCcgKyAoc2YgPyAxIDogMCkgKyAnLCcgKyBzciAqIHRjICsgJywnICsgc3IgKiB0cyArICdcXG4gICAgICBMJyArIHRyICogdGMgKyAnLCcgKyB0ciAqIHRzICsgJ1xcbiAgICAnO1xuICB9O1xufVxuXG5MaW5rUmFkaWFsU3RlcCQxLnByb3BUeXBlcyA9IHtcbiAgaW5uZXJSZWY6IFByb3BUeXBlcy5mdW5jLFxuICB4OiBQcm9wVHlwZXMuZnVuYyxcbiAgeTogUHJvcFR5cGVzLmZ1bmMsXG4gIHNvdXJjZTogUHJvcFR5cGVzLmZ1bmMsXG4gIHRhcmdldDogUHJvcFR5cGVzLmZ1bmMsXG4gIHBhdGg6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5mdW5jdGlvbiBMaW5rUmFkaWFsU3RlcCQxKF9yZWYyKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmMi5jbGFzc05hbWUsXG4gICAgICBpbm5lclJlZiA9IF9yZWYyLmlubmVyUmVmLFxuICAgICAgZGF0YSA9IF9yZWYyLmRhdGEsXG4gICAgICBwYXRoJCQxID0gX3JlZjIucGF0aCxcbiAgICAgIF9yZWYyJHggPSBfcmVmMi54LFxuICAgICAgeCA9IF9yZWYyJHggPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueDtcbiAgfSA6IF9yZWYyJHgsXG4gICAgICBfcmVmMiR5ID0gX3JlZjIueSxcbiAgICAgIHkgPSBfcmVmMiR5ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnk7XG4gIH0gOiBfcmVmMiR5LFxuICAgICAgX3JlZjIkc291cmNlID0gX3JlZjIuc291cmNlLFxuICAgICAgc291cmNlID0gX3JlZjIkc291cmNlID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnNvdXJjZTtcbiAgfSA6IF9yZWYyJHNvdXJjZSxcbiAgICAgIF9yZWYyJHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgIHRhcmdldCA9IF9yZWYyJHRhcmdldCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC50YXJnZXQ7XG4gIH0gOiBfcmVmMiR0YXJnZXQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgWydjbGFzc05hbWUnLCAnaW5uZXJSZWYnLCAnZGF0YScsICdwYXRoJywgJ3gnLCAneScsICdzb3VyY2UnLCAndGFyZ2V0J10pO1xuXG4gIHBhdGgkJDEgPSBwYXRoJCQxIHx8IHBhdGhSYWRpYWxTdGVwKHsgc291cmNlOiBzb3VyY2UsIHRhcmdldDogdGFyZ2V0LCB4OiB4LCB5OiB5IH0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgncGF0aCcsIF9leHRlbmRzKHtcbiAgICByZWY6IGlubmVyUmVmLFxuICAgIGNsYXNzTmFtZTogY3goJ3Z4LWxpbmsnLCBjbGFzc05hbWUpLFxuICAgIGQ6IHBhdGgkJDEoZGF0YSlcbiAgfSwgYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcywgZGF0YSkpKTtcbn1cblxuUG9seWdvbi5wcm9wVHlwZXMgPSB7XG4gIHNpZGVzOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIHNpemU6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICByb3RhdGU6IFByb3BUeXBlcy5udW1iZXIsXG4gIGZpbGw6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHN0cm9rZURhc2hhcnJheTogUHJvcFR5cGVzLnN0cmluZyxcbiAgc3Ryb2tlV2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXG4gIHN0cm9rZTogUHJvcFR5cGVzLnN0cmluZ1xufTtcblxudmFyIGdldFBvaW50ID0gZnVuY3Rpb24gZ2V0UG9pbnQoX3JlZikge1xuICB2YXIgc2lkZXMgPSBfcmVmLnNpZGVzLFxuICAgICAgc2l6ZSA9IF9yZWYuc2l6ZSxcbiAgICAgIGNlbnRlciA9IF9yZWYuY2VudGVyLFxuICAgICAgcm90YXRlID0gX3JlZi5yb3RhdGUsXG4gICAgICBzaWRlID0gX3JlZi5zaWRlO1xuXG4gIHZhciBkZWdyZWVzID0gMzYwIC8gc2lkZXMgKiBzaWRlIC0gcm90YXRlO1xuICB2YXIgcmFkaWFucyA9IGRlZ3JlZXNUb1JhZGlhbnMoZGVncmVlcyk7XG5cbiAgcmV0dXJuIG5ldyBQb2ludCh7XG4gICAgeDogY2VudGVyLnggKyBzaXplICogTWF0aC5jb3MocmFkaWFucyksXG4gICAgeTogY2VudGVyLnkgKyBzaXplICogTWF0aC5zaW4ocmFkaWFucylcbiAgfSk7XG59O1xuXG52YXIgZ2V0UG9pbnRzID0gZnVuY3Rpb24gZ2V0UG9pbnRzKF9yZWYyKSB7XG4gIHZhciBzaWRlcyA9IF9yZWYyLnNpZGVzLFxuICAgICAgc2l6ZSA9IF9yZWYyLnNpemUsXG4gICAgICBjZW50ZXIgPSBfcmVmMi5jZW50ZXIsXG4gICAgICByb3RhdGUgPSBfcmVmMi5yb3RhdGU7XG4gIHJldHVybiBbXS5jb25jYXQodG9Db25zdW1hYmxlQXJyYXkoQXJyYXkoc2lkZXMpLmtleXMoKSkpLm1hcChmdW5jdGlvbiAoc2lkZSkge1xuICAgIHJldHVybiBnZXRQb2ludCh7XG4gICAgICBzaWRlczogc2lkZXMsXG4gICAgICBzaXplOiBzaXplLFxuICAgICAgY2VudGVyOiBjZW50ZXIsXG4gICAgICByb3RhdGU6IHJvdGF0ZSxcbiAgICAgIHNpZGU6IHNpZGVcbiAgICB9KTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBQb2x5Z29uKF9yZWYzKSB7XG4gIHZhciBzaWRlcyA9IF9yZWYzLnNpZGVzLFxuICAgICAgX3JlZjMkc2l6ZSA9IF9yZWYzLnNpemUsXG4gICAgICBzaXplID0gX3JlZjMkc2l6ZSA9PT0gdW5kZWZpbmVkID8gMjUgOiBfcmVmMyRzaXplLFxuICAgICAgX3JlZjMkY2VudGVyID0gX3JlZjMuY2VudGVyLFxuICAgICAgY2VudGVyID0gX3JlZjMkY2VudGVyID09PSB1bmRlZmluZWQgPyBuZXcgUG9pbnQoeyB4OiAwLCB5OiAwIH0pIDogX3JlZjMkY2VudGVyLFxuICAgICAgX3JlZjMkcm90YXRlID0gX3JlZjMucm90YXRlLFxuICAgICAgcm90YXRlID0gX3JlZjMkcm90YXRlID09PSB1bmRlZmluZWQgPyAwIDogX3JlZjMkcm90YXRlLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZjMuY2xhc3NOYW1lLFxuICAgICAgY2xpY2tIYW5kbGVyID0gX3JlZjMuY2xpY2tIYW5kbGVyLFxuICAgICAgZmlsbCA9IF9yZWYzLmZpbGwsXG4gICAgICBzdHJva2VEYXNoYXJyYXkgPSBfcmVmMy5zdHJva2VEYXNoYXJyYXksXG4gICAgICBfcmVmMyRzdHJva2VXaWR0aCA9IF9yZWYzLnN0cm9rZVdpZHRoLFxuICAgICAgX3JlZjMkc3Ryb2tlID0gX3JlZjMuc3Ryb2tlLFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjMsIFsnc2lkZXMnLCAnc2l6ZScsICdjZW50ZXInLCAncm90YXRlJywgJ2NsYXNzTmFtZScsICdjbGlja0hhbmRsZXInLCAnZmlsbCcsICdzdHJva2VEYXNoYXJyYXknLCAnc3Ryb2tlV2lkdGgnLCAnc3Ryb2tlJ10pO1xuXG4gIHZhciBwb2ludHMgPSBnZXRQb2ludHMoe1xuICAgIHNpZGVzOiBzaWRlcyxcbiAgICBzaXplOiBzaXplLFxuICAgIGNlbnRlcjogY2VudGVyLFxuICAgIHJvdGF0ZTogcm90YXRlXG4gIH0pLm1hcChmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBwLnRvQXJyYXkoKTtcbiAgfSkuam9pbignICcpO1xuXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdwb2x5Z29uJywgX2V4dGVuZHMoeyBwb2ludHM6IHBvaW50cywgY2xhc3NOYW1lOiBjbGFzc05hbWUsIGZpbGw6IGZpbGwgfSwgcmVzdFByb3BzKSk7XG59XG5cbmV4cG9ydCB7IEFyYywgUGllLCBMaW5lLCBMaW5lUGF0aCwgTGluZVJhZGlhbCwgQXJlYSwgQXJlYUNsb3NlZCwgQXJlYVN0YWNrLCBCYXIsIEJhckdyb3VwLCBCYXJHcm91cEhvcml6b250YWwsIEJhclN0YWNrLCBCYXJTdGFja0hvcml6b250YWwsIFN0YWNrLCBjYWxsT3JWYWx1ZSwgc3RhY2tPZmZzZXQsIFNUQUNLX09GRlNFVFMsIFNUQUNLX09GRlNFVF9OQU1FUywgc3RhY2tPcmRlciwgU1RBQ0tfT1JERVJTLCBTVEFDS19PUkRFUl9OQU1FUywgZGVncmVlc1RvUmFkaWFucywgTGlua0hvcml6b250YWwsIHBhdGhIb3Jpem9udGFsRGlhZ29uYWwsIExpbmtWZXJ0aWNhbCwgcGF0aFZlcnRpY2FsRGlhZ29uYWwsIExpbmtSYWRpYWwsIHBhdGhSYWRpYWxEaWFnb25hbCwgTGlua0hvcml6b250YWxDdXJ2ZSwgcGF0aEhvcml6b250YWxDdXJ2ZSwgTGlua1ZlcnRpY2FsQ3VydmUsIHBhdGhWZXJ0aWNhbEN1cnZlLCBMaW5rUmFkaWFsQ3VydmUsIHBhdGhSYWRpYWxDdXJ2ZSwgTGlua0hvcml6b250YWxMaW5lLCBwYXRoSG9yaXpvbnRhbExpbmUsIExpbmtWZXJ0aWNhbExpbmUsIHBhdGhWZXJ0aWNhbExpbmUsIExpbmtSYWRpYWxTdGVwIGFzIExpbmtSYWRpYWxMaW5lLCBwYXRoUmFkaWFsTGluZSwgTGlua0hvcml6b250YWxTdGVwLCBwYXRoSG9yaXpvbnRhbFN0ZXAsIExpbmtWZXJ0aWNhbFN0ZXAsIHBhdGhWZXJ0aWNhbFN0ZXAsIExpbmtSYWRpYWxTdGVwJDEgYXMgTGlua1JhZGlhbFN0ZXAsIHBhdGhSYWRpYWxTdGVwLCBQb2x5Z29uLCBnZXRQb2ludHMsIGdldFBvaW50IH07XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjeCBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCB7IExpbmUgfSBmcm9tICdAdngvc2hhcGUnO1xuaW1wb3J0IHsgUG9pbnQgfSBmcm9tICdAdngvcG9pbnQnO1xuaW1wb3J0IHsgR3JvdXAgfSBmcm9tICdAdngvZ3JvdXAnO1xuaW1wb3J0IHsgVGV4dCB9IGZyb20gJ0B2eC90ZXh0JztcblxuZnVuY3Rpb24gY2VudGVyKHNjYWxlKSB7XG4gIHZhciBvZmZzZXQgPSBzY2FsZS5iYW5kd2lkdGgoKSAvIDI7XG4gIGlmIChzY2FsZS5yb3VuZCgpKSBvZmZzZXQgPSBNYXRoLnJvdW5kKG9mZnNldCk7XG4gIHJldHVybiBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBzY2FsZShkKSArIG9mZnNldDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaWRlbnRpdHkoeCkge1xuICByZXR1cm4geDtcbn1cblxudmFyIE9SSUVOVCA9IHtcbiAgdG9wOiAndG9wJyxcbiAgbGVmdDogJ2xlZnQnLFxuICByaWdodDogJ3JpZ2h0JyxcbiAgYm90dG9tOiAnYm90dG9tJ1xufTtcblxuZnVuY3Rpb24gbGFiZWxUcmFuc2Zvcm0oX3JlZikge1xuICB2YXIgbGFiZWxPZmZzZXQgPSBfcmVmLmxhYmVsT2Zmc2V0LFxuICAgICAgbGFiZWxQcm9wcyA9IF9yZWYubGFiZWxQcm9wcyxcbiAgICAgIG9yaWVudGF0aW9uID0gX3JlZi5vcmllbnRhdGlvbixcbiAgICAgIHJhbmdlID0gX3JlZi5yYW5nZSxcbiAgICAgIHRpY2tMYWJlbEZvbnRTaXplID0gX3JlZi50aWNrTGFiZWxGb250U2l6ZSxcbiAgICAgIHRpY2tMZW5ndGggPSBfcmVmLnRpY2tMZW5ndGg7XG5cbiAgdmFyIHNpZ24gPSBvcmllbnRhdGlvbiA9PT0gT1JJRU5ULmxlZnQgfHwgb3JpZW50YXRpb24gPT09IE9SSUVOVC50b3AgPyAtMSA6IDE7XG5cbiAgdmFyIHggPSB2b2lkIDAsXG4gICAgICB5ID0gdm9pZCAwLFxuICAgICAgdHJhbnNmb3JtID0gbnVsbDtcbiAgaWYgKG9yaWVudGF0aW9uID09PSBPUklFTlQudG9wIHx8IG9yaWVudGF0aW9uID09PSBPUklFTlQuYm90dG9tKSB7XG4gICAgeCA9IChyYW5nZVswXSArIHJhbmdlW3JhbmdlLmxlbmd0aCAtIDFdKSAvIDI7XG4gICAgeSA9IHNpZ24gKiAodGlja0xlbmd0aCArIGxhYmVsT2Zmc2V0ICsgdGlja0xhYmVsRm9udFNpemUgKyAob3JpZW50YXRpb24gPT09IE9SSUVOVC5ib3R0b20gPyBsYWJlbFByb3BzLmZvbnRTaXplIDogMCkpO1xuICB9IGVsc2Uge1xuICAgIHggPSBzaWduICogKChyYW5nZVswXSArIHJhbmdlW3JhbmdlLmxlbmd0aCAtIDFdKSAvIDIpO1xuICAgIHkgPSAtKHRpY2tMZW5ndGggKyBsYWJlbE9mZnNldCk7XG4gICAgdHJhbnNmb3JtID0gJ3JvdGF0ZSgnICsgc2lnbiAqIDkwICsgJyknO1xuICB9XG5cbiAgcmV0dXJuIHsgeDogeCwgeTogeSwgdHJhbnNmb3JtOiB0cmFuc2Zvcm0gfTtcbn1cblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbnZhciBwcm9wVHlwZXMgPSB7XG4gIGF4aXNDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGF4aXNMaW5lQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBoaWRlQXhpc0xpbmU6IFByb3BUeXBlcy5ib29sLFxuICBoaWRlVGlja3M6IFByb3BUeXBlcy5ib29sLFxuICBoaWRlWmVybzogUHJvcFR5cGVzLmJvb2wsXG4gIGxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBsYWJlbENsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgbGFiZWxPZmZzZXQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIGxhYmVsUHJvcHM6IFByb3BUeXBlcy5vYmplY3QsXG4gIGxlZnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIG51bVRpY2tzOiBQcm9wVHlwZXMubnVtYmVyLFxuICBvcmllbnRhdGlvbjogUHJvcFR5cGVzLm9uZU9mKFtPUklFTlQudG9wLCBPUklFTlQucmlnaHQsIE9SSUVOVC5ib3R0b20sIE9SSUVOVC5sZWZ0XSksXG4gIHJhbmdlUGFkZGluZzogUHJvcFR5cGVzLm51bWJlcixcbiAgc2NhbGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHN0cm9rZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgc3Ryb2tlV2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXG4gIHN0cm9rZURhc2hhcnJheTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdGlja0NsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdGlja0Zvcm1hdDogUHJvcFR5cGVzLmZ1bmMsXG4gIHRpY2tMYWJlbFByb3BzOiBQcm9wVHlwZXMuZnVuYyxcbiAgdGlja0xlbmd0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgdGlja1N0cm9rZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdGlja1RyYW5zZm9ybTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdGlja1ZhbHVlczogUHJvcFR5cGVzLmFycmF5LFxuICB0aWNrQ29tcG9uZW50OiBQcm9wVHlwZXMuZnVuYyxcbiAgdG9wOiBQcm9wVHlwZXMubnVtYmVyLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIEF4aXMoX3JlZikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgYXhpc0NsYXNzTmFtZSA9IF9yZWYuYXhpc0NsYXNzTmFtZSxcbiAgICAgIGF4aXNMaW5lQ2xhc3NOYW1lID0gX3JlZi5heGlzTGluZUNsYXNzTmFtZSxcbiAgICAgIF9yZWYkaGlkZUF4aXNMaW5lID0gX3JlZi5oaWRlQXhpc0xpbmUsXG4gICAgICBoaWRlQXhpc0xpbmUgPSBfcmVmJGhpZGVBeGlzTGluZSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJGhpZGVBeGlzTGluZSxcbiAgICAgIF9yZWYkaGlkZVRpY2tzID0gX3JlZi5oaWRlVGlja3MsXG4gICAgICBoaWRlVGlja3MgPSBfcmVmJGhpZGVUaWNrcyA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJGhpZGVUaWNrcyxcbiAgICAgIF9yZWYkaGlkZVplcm8gPSBfcmVmLmhpZGVaZXJvLFxuICAgICAgaGlkZVplcm8gPSBfcmVmJGhpZGVaZXJvID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkaGlkZVplcm8sXG4gICAgICBfcmVmJGxhYmVsID0gX3JlZi5sYWJlbCxcbiAgICAgIGxhYmVsID0gX3JlZiRsYWJlbCA9PT0gdW5kZWZpbmVkID8gJycgOiBfcmVmJGxhYmVsLFxuICAgICAgbGFiZWxDbGFzc05hbWUgPSBfcmVmLmxhYmVsQ2xhc3NOYW1lLFxuICAgICAgX3JlZiRsYWJlbE9mZnNldCA9IF9yZWYubGFiZWxPZmZzZXQsXG4gICAgICBsYWJlbE9mZnNldCA9IF9yZWYkbGFiZWxPZmZzZXQgPT09IHVuZGVmaW5lZCA/IDE0IDogX3JlZiRsYWJlbE9mZnNldCxcbiAgICAgIF9yZWYkbGFiZWxQcm9wcyA9IF9yZWYubGFiZWxQcm9wcyxcbiAgICAgIGxhYmVsUHJvcHMgPSBfcmVmJGxhYmVsUHJvcHMgPT09IHVuZGVmaW5lZCA/IHtcbiAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJyxcbiAgICBmb250RmFtaWx5OiAnQXJpYWwnLFxuICAgIGZvbnRTaXplOiAxMCxcbiAgICBmaWxsOiAnYmxhY2snXG4gIH0gOiBfcmVmJGxhYmVsUHJvcHMsXG4gICAgICBfcmVmJGxlZnQgPSBfcmVmLmxlZnQsXG4gICAgICBsZWZ0ID0gX3JlZiRsZWZ0ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiRsZWZ0LFxuICAgICAgX3JlZiRudW1UaWNrcyA9IF9yZWYubnVtVGlja3MsXG4gICAgICBudW1UaWNrcyA9IF9yZWYkbnVtVGlja3MgPT09IHVuZGVmaW5lZCA/IDEwIDogX3JlZiRudW1UaWNrcyxcbiAgICAgIF9yZWYkb3JpZW50YXRpb24gPSBfcmVmLm9yaWVudGF0aW9uLFxuICAgICAgb3JpZW50YXRpb24gPSBfcmVmJG9yaWVudGF0aW9uID09PSB1bmRlZmluZWQgPyBPUklFTlQuYm90dG9tIDogX3JlZiRvcmllbnRhdGlvbixcbiAgICAgIF9yZWYkcmFuZ2VQYWRkaW5nID0gX3JlZi5yYW5nZVBhZGRpbmcsXG4gICAgICByYW5nZVBhZGRpbmcgPSBfcmVmJHJhbmdlUGFkZGluZyA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkcmFuZ2VQYWRkaW5nLFxuICAgICAgc2NhbGUgPSBfcmVmLnNjYWxlLFxuICAgICAgX3JlZiRzdHJva2UgPSBfcmVmLnN0cm9rZSxcbiAgICAgIHN0cm9rZSA9IF9yZWYkc3Ryb2tlID09PSB1bmRlZmluZWQgPyAnYmxhY2snIDogX3JlZiRzdHJva2UsXG4gICAgICBfcmVmJHN0cm9rZVdpZHRoID0gX3JlZi5zdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZVdpZHRoID0gX3JlZiRzdHJva2VXaWR0aCA9PT0gdW5kZWZpbmVkID8gMSA6IF9yZWYkc3Ryb2tlV2lkdGgsXG4gICAgICBzdHJva2VEYXNoYXJyYXkgPSBfcmVmLnN0cm9rZURhc2hhcnJheSxcbiAgICAgIHRpY2tDbGFzc05hbWUgPSBfcmVmLnRpY2tDbGFzc05hbWUsXG4gICAgICB0aWNrRm9ybWF0ID0gX3JlZi50aWNrRm9ybWF0LFxuICAgICAgX3JlZiR0aWNrTGFiZWxQcm9wcyA9IF9yZWYudGlja0xhYmVsUHJvcHMsXG4gICAgICB0aWNrTGFiZWxQcm9wcyA9IF9yZWYkdGlja0xhYmVsUHJvcHMgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uICh0aWNrVmFsdWUsIGluZGV4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHRBbmNob3I6ICdtaWRkbGUnLFxuICAgICAgZm9udEZhbWlseTogJ0FyaWFsJyxcbiAgICAgIGZvbnRTaXplOiAxMCxcbiAgICAgIGZpbGw6ICdibGFjaydcbiAgICB9O1xuICB9IDogX3JlZiR0aWNrTGFiZWxQcm9wcyxcbiAgICAgIF9yZWYkdGlja0xlbmd0aCA9IF9yZWYudGlja0xlbmd0aCxcbiAgICAgIHRpY2tMZW5ndGggPSBfcmVmJHRpY2tMZW5ndGggPT09IHVuZGVmaW5lZCA/IDggOiBfcmVmJHRpY2tMZW5ndGgsXG4gICAgICBfcmVmJHRpY2tTdHJva2UgPSBfcmVmLnRpY2tTdHJva2UsXG4gICAgICB0aWNrU3Ryb2tlID0gX3JlZiR0aWNrU3Ryb2tlID09PSB1bmRlZmluZWQgPyAnYmxhY2snIDogX3JlZiR0aWNrU3Ryb2tlLFxuICAgICAgdGlja1RyYW5zZm9ybSA9IF9yZWYudGlja1RyYW5zZm9ybSxcbiAgICAgIHRpY2tWYWx1ZXMgPSBfcmVmLnRpY2tWYWx1ZXMsXG4gICAgICB0aWNrQ29tcG9uZW50ID0gX3JlZi50aWNrQ29tcG9uZW50LFxuICAgICAgX3JlZiR0b3AgPSBfcmVmLnRvcCxcbiAgICAgIHRvcCA9IF9yZWYkdG9wID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiR0b3A7XG5cbiAgdmFyIHZhbHVlcyA9IHNjYWxlLnRpY2tzID8gc2NhbGUudGlja3MobnVtVGlja3MpIDogc2NhbGUuZG9tYWluKCk7XG4gIGlmICh0aWNrVmFsdWVzKSB2YWx1ZXMgPSB0aWNrVmFsdWVzO1xuICB2YXIgZm9ybWF0ID0gc2NhbGUudGlja0Zvcm1hdCA/IHNjYWxlLnRpY2tGb3JtYXQoKSA6IGlkZW50aXR5O1xuICBpZiAodGlja0Zvcm1hdCkgZm9ybWF0ID0gdGlja0Zvcm1hdDtcblxuICB2YXIgcmFuZ2UgPSBzY2FsZS5yYW5nZSgpO1xuICB2YXIgcmFuZ2UwID0gcmFuZ2VbMF0gKyAwLjUgLSByYW5nZVBhZGRpbmc7XG4gIHZhciByYW5nZTEgPSByYW5nZVtyYW5nZS5sZW5ndGggLSAxXSArIDAuNSArIHJhbmdlUGFkZGluZztcblxuICB2YXIgaG9yaXpvbnRhbCA9IG9yaWVudGF0aW9uICE9PSBPUklFTlQubGVmdCAmJiBvcmllbnRhdGlvbiAhPT0gT1JJRU5ULnJpZ2h0O1xuICB2YXIgaXNMZWZ0ID0gb3JpZW50YXRpb24gPT09IE9SSUVOVC5sZWZ0O1xuICB2YXIgaXNUb3AgPSBvcmllbnRhdGlvbiA9PT0gT1JJRU5ULnRvcDtcbiAgdmFyIHRpY2tTaWduID0gaXNMZWZ0IHx8IGlzVG9wID8gLTEgOiAxO1xuXG4gIHZhciBwb3NpdGlvbiA9IChzY2FsZS5iYW5kd2lkdGggPyBjZW50ZXIgOiBpZGVudGl0eSkoc2NhbGUuY29weSgpKTtcblxuICB2YXIgYXhpc0Zyb21Qb2ludCA9IG5ldyBQb2ludCh7XG4gICAgeDogaG9yaXpvbnRhbCA/IHJhbmdlMCA6IDAsXG4gICAgeTogaG9yaXpvbnRhbCA/IDAgOiByYW5nZTBcbiAgfSk7XG4gIHZhciBheGlzVG9Qb2ludCA9IG5ldyBQb2ludCh7XG4gICAgeDogaG9yaXpvbnRhbCA/IHJhbmdlMSA6IDAsXG4gICAgeTogaG9yaXpvbnRhbCA/IDAgOiByYW5nZTFcbiAgfSk7XG5cbiAgdmFyIHRpY2tMYWJlbEZvbnRTaXplID0gMTA7IC8vIHRyYWNrIHRoZSBtYXggdGljayBsYWJlbCBzaXplIHRvIGNvbXB1dGUgbGFiZWwgb2Zmc2V0XG5cbiAgaWYgKCEhY2hpbGRyZW4pIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgIEdyb3VwLFxuICAgICAgeyBjbGFzc05hbWU6IGN4KCd2eC1heGlzJywgYXhpc0NsYXNzTmFtZSksIHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH0sXG4gICAgICBjaGlsZHJlbih7XG4gICAgICAgIGF4aXNGcm9tUG9pbnQ6IGF4aXNGcm9tUG9pbnQsXG4gICAgICAgIGF4aXNUb1BvaW50OiBheGlzVG9Qb2ludCxcbiAgICAgICAgaG9yaXpvbnRhbDogaG9yaXpvbnRhbCxcbiAgICAgICAgdGlja1NpZ246IHRpY2tTaWduLFxuICAgICAgICBudW1UaWNrczogbnVtVGlja3MsXG4gICAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgICAgcmFuZ2VQYWRkaW5nOiByYW5nZVBhZGRpbmcsXG4gICAgICAgIHRpY2tMZW5ndGg6IHRpY2tMZW5ndGgsXG4gICAgICAgIHRpY2tGb3JtYXQ6IGZvcm1hdCxcbiAgICAgICAgdGlja1Bvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgICAgdGlja3M6IHZhbHVlcy5tYXAoZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgICAgIHZhciBmcm9tID0gbmV3IFBvaW50KHtcbiAgICAgICAgICAgIHg6IGhvcml6b250YWwgPyBwb3NpdGlvbih2YWx1ZSkgOiAwLFxuICAgICAgICAgICAgeTogaG9yaXpvbnRhbCA/IDAgOiBwb3NpdGlvbih2YWx1ZSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgdG8gPSBuZXcgUG9pbnQoe1xuICAgICAgICAgICAgeDogaG9yaXpvbnRhbCA/IHBvc2l0aW9uKHZhbHVlKSA6IHRpY2tTaWduICogdGlja0xlbmd0aCxcbiAgICAgICAgICAgIHk6IGhvcml6b250YWwgPyB0aWNrTGVuZ3RoICogdGlja1NpZ24gOiBwb3NpdGlvbih2YWx1ZSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgZnJvbTogZnJvbSxcbiAgICAgICAgICAgIHRvOiB0byxcbiAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlOiBmb3JtYXQodmFsdWUsIGluZGV4KVxuICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICBHcm91cCxcbiAgICB7IGNsYXNzTmFtZTogY3goJ3Z4LWF4aXMnLCBheGlzQ2xhc3NOYW1lKSwgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfSxcbiAgICB2YWx1ZXMubWFwKGZ1bmN0aW9uICh2YWwsIGluZGV4KSB7XG4gICAgICBpZiAoaGlkZVplcm8gJiYgdmFsID09PSAwKSByZXR1cm4gbnVsbDtcblxuICAgICAgdmFyIHRpY2tGcm9tUG9pbnQgPSBuZXcgUG9pbnQoe1xuICAgICAgICB4OiBob3Jpem9udGFsID8gcG9zaXRpb24odmFsKSA6IDAsXG4gICAgICAgIHk6IGhvcml6b250YWwgPyAwIDogcG9zaXRpb24odmFsKVxuICAgICAgfSk7XG4gICAgICB2YXIgdGlja1RvUG9pbnQgPSBuZXcgUG9pbnQoe1xuICAgICAgICB4OiBob3Jpem9udGFsID8gcG9zaXRpb24odmFsKSA6IHRpY2tTaWduICogdGlja0xlbmd0aCxcbiAgICAgICAgeTogaG9yaXpvbnRhbCA/IHRpY2tMZW5ndGggKiB0aWNrU2lnbiA6IHBvc2l0aW9uKHZhbClcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgdGlja0xhYmVsUHJvcHNPYmogPSB0aWNrTGFiZWxQcm9wcyh2YWwsIGluZGV4KTtcbiAgICAgIHRpY2tMYWJlbEZvbnRTaXplID0gTWF0aC5tYXgodGlja0xhYmVsRm9udFNpemUsIHRpY2tMYWJlbFByb3BzT2JqLmZvbnRTaXplIHx8IDApO1xuXG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgR3JvdXAsXG4gICAgICAgIHtcbiAgICAgICAgICBrZXk6ICd2eC10aWNrLScgKyB2YWwgKyAnLScgKyBpbmRleCxcbiAgICAgICAgICBjbGFzc05hbWU6IGN4KCd2eC1heGlzLXRpY2snLCB0aWNrQ2xhc3NOYW1lKSxcbiAgICAgICAgICB0cmFuc2Zvcm06IHRpY2tUcmFuc2Zvcm1cbiAgICAgICAgfSxcbiAgICAgICAgIWhpZGVUaWNrcyAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KExpbmUsIHsgZnJvbTogdGlja0Zyb21Qb2ludCwgdG86IHRpY2tUb1BvaW50LCBzdHJva2U6IHRpY2tTdHJva2UgfSksXG4gICAgICAgIHRpY2tDb21wb25lbnQgPyB0aWNrQ29tcG9uZW50KF9leHRlbmRzKHtcbiAgICAgICAgICB4OiB0aWNrVG9Qb2ludC54LFxuICAgICAgICAgIHk6IHRpY2tUb1BvaW50LnkgKyAoaG9yaXpvbnRhbCAmJiAhaXNUb3AgPyB0aWNrTGFiZWxGb250U2l6ZSA6IDApLFxuICAgICAgICAgIGZvcm1hdHRlZFZhbHVlOiBmb3JtYXQodmFsLCBpbmRleClcbiAgICAgICAgfSwgdGlja0xhYmVsUHJvcHNPYmopKSA6IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgVGV4dCxcbiAgICAgICAgICBfZXh0ZW5kcyh7XG4gICAgICAgICAgICB4OiB0aWNrVG9Qb2ludC54LFxuICAgICAgICAgICAgeTogdGlja1RvUG9pbnQueSArIChob3Jpem9udGFsICYmICFpc1RvcCA/IHRpY2tMYWJlbEZvbnRTaXplIDogMClcbiAgICAgICAgICB9LCB0aWNrTGFiZWxQcm9wc09iaiksXG4gICAgICAgICAgZm9ybWF0KHZhbCwgaW5kZXgpXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSksXG4gICAgIWhpZGVBeGlzTGluZSAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KExpbmUsIHtcbiAgICAgIGNsYXNzTmFtZTogY3goJ3Z4LWF4aXMtbGluZScsIGF4aXNMaW5lQ2xhc3NOYW1lKSxcbiAgICAgIGZyb206IGF4aXNGcm9tUG9pbnQsXG4gICAgICB0bzogYXhpc1RvUG9pbnQsXG4gICAgICBzdHJva2U6IHN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZURhc2hhcnJheTogc3Ryb2tlRGFzaGFycmF5XG4gICAgfSksXG4gICAgbGFiZWwgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgIFRleHQsXG4gICAgICBfZXh0ZW5kcyh7XG4gICAgICAgIGNsYXNzTmFtZTogY3goJ3Z4LWF4aXMtbGFiZWwnLCBsYWJlbENsYXNzTmFtZSlcbiAgICAgIH0sIGxhYmVsVHJhbnNmb3JtKHtcbiAgICAgICAgbGFiZWxPZmZzZXQ6IGxhYmVsT2Zmc2V0LFxuICAgICAgICBsYWJlbFByb3BzOiBsYWJlbFByb3BzLFxuICAgICAgICBvcmllbnRhdGlvbjogb3JpZW50YXRpb24sXG4gICAgICAgIHJhbmdlOiByYW5nZSxcbiAgICAgICAgdGlja0xhYmVsRm9udFNpemU6IHRpY2tMYWJlbEZvbnRTaXplLFxuICAgICAgICB0aWNrTGVuZ3RoOiB0aWNrTGVuZ3RoXG4gICAgICB9KSwgbGFiZWxQcm9wcyksXG4gICAgICBsYWJlbFxuICAgIClcbiAgKTtcbn1cblxuQXhpcy5wcm9wVHlwZXMgPSBwcm9wVHlwZXM7XG5cbnZhciBwcm9wVHlwZXMkMSA9IHtcbiAgYXhpc0NsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgYXhpc0xpbmVDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGhpZGVBeGlzTGluZTogUHJvcFR5cGVzLmJvb2wsXG4gIGhpZGVUaWNrczogUHJvcFR5cGVzLmJvb2wsXG4gIGhpZGVaZXJvOiBQcm9wVHlwZXMuYm9vbCxcbiAgbGFiZWw6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGxhYmVsQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBsYWJlbE9mZnNldDogUHJvcFR5cGVzLm51bWJlcixcbiAgbGFiZWxQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcbiAgbGVmdDogUHJvcFR5cGVzLm51bWJlcixcbiAgbnVtVGlja3M6IFByb3BUeXBlcy5udW1iZXIsXG4gIHJhbmdlUGFkZGluZzogUHJvcFR5cGVzLm51bWJlcixcbiAgc2NhbGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHN0cm9rZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgc3Ryb2tlV2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXG4gIHN0cm9rZURhc2hhcnJheTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdGlja0NsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdGlja0Zvcm1hdDogUHJvcFR5cGVzLmZ1bmMsXG4gIHRpY2tMYWJlbFByb3BzOiBQcm9wVHlwZXMuZnVuYyxcbiAgdGlja0xlbmd0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgdGlja1N0cm9rZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdGlja1RyYW5zZm9ybTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdGlja1ZhbHVlczogUHJvcFR5cGVzLmFycmF5LFxuICB0aWNrQ29tcG9uZW50OiBQcm9wVHlwZXMuZnVuYyxcbiAgdG9wOiBQcm9wVHlwZXMubnVtYmVyLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIEF4aXNMZWZ0KF9yZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIGF4aXNDbGFzc05hbWUgPSBfcmVmLmF4aXNDbGFzc05hbWUsXG4gICAgICBheGlzTGluZUNsYXNzTmFtZSA9IF9yZWYuYXhpc0xpbmVDbGFzc05hbWUsXG4gICAgICBoaWRlQXhpc0xpbmUgPSBfcmVmLmhpZGVBeGlzTGluZSxcbiAgICAgIGhpZGVUaWNrcyA9IF9yZWYuaGlkZVRpY2tzLFxuICAgICAgaGlkZVplcm8gPSBfcmVmLmhpZGVaZXJvLFxuICAgICAgbGFiZWwgPSBfcmVmLmxhYmVsLFxuICAgICAgbGFiZWxDbGFzc05hbWUgPSBfcmVmLmxhYmVsQ2xhc3NOYW1lLFxuICAgICAgX3JlZiRsYWJlbE9mZnNldCA9IF9yZWYubGFiZWxPZmZzZXQsXG4gICAgICBsYWJlbE9mZnNldCA9IF9yZWYkbGFiZWxPZmZzZXQgPT09IHVuZGVmaW5lZCA/IDM2IDogX3JlZiRsYWJlbE9mZnNldCxcbiAgICAgIGxhYmVsUHJvcHMgPSBfcmVmLmxhYmVsUHJvcHMsXG4gICAgICBsZWZ0ID0gX3JlZi5sZWZ0LFxuICAgICAgbnVtVGlja3MgPSBfcmVmLm51bVRpY2tzLFxuICAgICAgcmFuZ2VQYWRkaW5nID0gX3JlZi5yYW5nZVBhZGRpbmcsXG4gICAgICBzY2FsZSA9IF9yZWYuc2NhbGUsXG4gICAgICBzdHJva2UgPSBfcmVmLnN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoID0gX3JlZi5zdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZURhc2hhcnJheSA9IF9yZWYuc3Ryb2tlRGFzaGFycmF5LFxuICAgICAgdGlja0NsYXNzTmFtZSA9IF9yZWYudGlja0NsYXNzTmFtZSxcbiAgICAgIHRpY2tGb3JtYXQgPSBfcmVmLnRpY2tGb3JtYXQsXG4gICAgICBfcmVmJHRpY2tMYWJlbFByb3BzID0gX3JlZi50aWNrTGFiZWxQcm9wcyxcbiAgICAgIHRpY2tMYWJlbFByb3BzID0gX3JlZiR0aWNrTGFiZWxQcm9wcyA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgdmFyIHRpY2sgPSBfcmVmMi50aWNrLFxuICAgICAgICBpbmRleCA9IF9yZWYyLmluZGV4O1xuICAgIHJldHVybiB7XG4gICAgICBkeDogJy0wLjI1ZW0nLFxuICAgICAgZHk6ICcwLjI1ZW0nLFxuICAgICAgZmlsbDogJ2JsYWNrJyxcbiAgICAgIGZvbnRGYW1pbHk6ICdBcmlhbCcsXG4gICAgICBmb250U2l6ZTogMTAsXG4gICAgICB0ZXh0QW5jaG9yOiAnZW5kJ1xuICAgIH07XG4gIH0gOiBfcmVmJHRpY2tMYWJlbFByb3BzLFxuICAgICAgX3JlZiR0aWNrTGVuZ3RoID0gX3JlZi50aWNrTGVuZ3RoLFxuICAgICAgdGlja0xlbmd0aCA9IF9yZWYkdGlja0xlbmd0aCA9PT0gdW5kZWZpbmVkID8gOCA6IF9yZWYkdGlja0xlbmd0aCxcbiAgICAgIHRpY2tTdHJva2UgPSBfcmVmLnRpY2tTdHJva2UsXG4gICAgICB0aWNrVHJhbnNmb3JtID0gX3JlZi50aWNrVHJhbnNmb3JtLFxuICAgICAgdGlja1ZhbHVlcyA9IF9yZWYudGlja1ZhbHVlcyxcbiAgICAgIHRpY2tDb21wb25lbnQgPSBfcmVmLnRpY2tDb21wb25lbnQsXG4gICAgICB0b3AgPSBfcmVmLnRvcDtcblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChBeGlzLCB7XG4gICAgYXhpc0NsYXNzTmFtZTogY3goJ3Z4LWF4aXMtbGVmdCcsIGF4aXNDbGFzc05hbWUpLFxuICAgIGF4aXNMaW5lQ2xhc3NOYW1lOiBheGlzTGluZUNsYXNzTmFtZSxcbiAgICBoaWRlQXhpc0xpbmU6IGhpZGVBeGlzTGluZSxcbiAgICBoaWRlVGlja3M6IGhpZGVUaWNrcyxcbiAgICBoaWRlWmVybzogaGlkZVplcm8sXG4gICAgbGFiZWw6IGxhYmVsLFxuICAgIGxhYmVsQ2xhc3NOYW1lOiBsYWJlbENsYXNzTmFtZSxcbiAgICBsYWJlbE9mZnNldDogbGFiZWxPZmZzZXQsXG4gICAgbGFiZWxQcm9wczogbGFiZWxQcm9wcyxcbiAgICBsZWZ0OiBsZWZ0LFxuICAgIG51bVRpY2tzOiBudW1UaWNrcyxcbiAgICBvcmllbnRhdGlvbjogT1JJRU5ULmxlZnQsXG4gICAgcmFuZ2VQYWRkaW5nOiByYW5nZVBhZGRpbmcsXG4gICAgc2NhbGU6IHNjYWxlLFxuICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICBzdHJva2VEYXNoYXJyYXk6IHN0cm9rZURhc2hhcnJheSxcbiAgICB0aWNrQ2xhc3NOYW1lOiB0aWNrQ2xhc3NOYW1lLFxuICAgIHRpY2tGb3JtYXQ6IHRpY2tGb3JtYXQsXG4gICAgdGlja0xhYmVsUHJvcHM6IHRpY2tMYWJlbFByb3BzLFxuICAgIHRpY2tMZW5ndGg6IHRpY2tMZW5ndGgsXG4gICAgdGlja1N0cm9rZTogdGlja1N0cm9rZSxcbiAgICB0aWNrVHJhbnNmb3JtOiB0aWNrVHJhbnNmb3JtLFxuICAgIHRpY2tWYWx1ZXM6IHRpY2tWYWx1ZXMsXG4gICAgdGlja0NvbXBvbmVudDogdGlja0NvbXBvbmVudCxcbiAgICB0b3A6IHRvcCxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgfSk7XG59XG5cbkF4aXNMZWZ0LnByb3BUeXBlcyA9IHByb3BUeXBlcyQxO1xuXG52YXIgcHJvcFR5cGVzJDIgPSB7XG4gIGF4aXNDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGF4aXNMaW5lQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBoaWRlQXhpc0xpbmU6IFByb3BUeXBlcy5ib29sLFxuICBoaWRlVGlja3M6IFByb3BUeXBlcy5ib29sLFxuICBoaWRlWmVybzogUHJvcFR5cGVzLmJvb2wsXG4gIGxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBsYWJlbENsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgbGFiZWxPZmZzZXQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIGxhYmVsUHJvcHM6IFByb3BUeXBlcy5vYmplY3QsXG4gIGxlZnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIG51bVRpY2tzOiBQcm9wVHlwZXMubnVtYmVyLFxuICByYW5nZVBhZGRpbmc6IFByb3BUeXBlcy5udW1iZXIsXG4gIHNjYWxlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBzdHJva2U6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHN0cm9rZVdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLFxuICBzdHJva2VEYXNoYXJyYXk6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRpY2tDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRpY2tGb3JtYXQ6IFByb3BUeXBlcy5mdW5jLFxuICB0aWNrTGFiZWxQcm9wczogUHJvcFR5cGVzLmZ1bmMsXG4gIHRpY2tMZW5ndGg6IFByb3BUeXBlcy5udW1iZXIsXG4gIHRpY2tTdHJva2U6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRpY2tUcmFuc2Zvcm06IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRpY2tWYWx1ZXM6IFByb3BUeXBlcy5hcnJheSxcbiAgdGlja0NvbXBvbmVudDogUHJvcFR5cGVzLmZ1bmMsXG4gIHRvcDogUHJvcFR5cGVzLm51bWJlcixcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5mdW5jXG59O1xuXG5mdW5jdGlvbiBBeGlzUmlnaHQoX3JlZikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgYXhpc0NsYXNzTmFtZSA9IF9yZWYuYXhpc0NsYXNzTmFtZSxcbiAgICAgIGF4aXNMaW5lQ2xhc3NOYW1lID0gX3JlZi5heGlzTGluZUNsYXNzTmFtZSxcbiAgICAgIGhpZGVBeGlzTGluZSA9IF9yZWYuaGlkZUF4aXNMaW5lLFxuICAgICAgaGlkZVRpY2tzID0gX3JlZi5oaWRlVGlja3MsXG4gICAgICBoaWRlWmVybyA9IF9yZWYuaGlkZVplcm8sXG4gICAgICBsYWJlbCA9IF9yZWYubGFiZWwsXG4gICAgICBsYWJlbENsYXNzTmFtZSA9IF9yZWYubGFiZWxDbGFzc05hbWUsXG4gICAgICBfcmVmJGxhYmVsT2Zmc2V0ID0gX3JlZi5sYWJlbE9mZnNldCxcbiAgICAgIGxhYmVsT2Zmc2V0ID0gX3JlZiRsYWJlbE9mZnNldCA9PT0gdW5kZWZpbmVkID8gMzYgOiBfcmVmJGxhYmVsT2Zmc2V0LFxuICAgICAgbGFiZWxQcm9wcyA9IF9yZWYubGFiZWxQcm9wcyxcbiAgICAgIGxlZnQgPSBfcmVmLmxlZnQsXG4gICAgICBudW1UaWNrcyA9IF9yZWYubnVtVGlja3MsXG4gICAgICByYW5nZVBhZGRpbmcgPSBfcmVmLnJhbmdlUGFkZGluZyxcbiAgICAgIHNjYWxlID0gX3JlZi5zY2FsZSxcbiAgICAgIHN0cm9rZSA9IF9yZWYuc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGggPSBfcmVmLnN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlRGFzaGFycmF5ID0gX3JlZi5zdHJva2VEYXNoYXJyYXksXG4gICAgICB0aWNrQ2xhc3NOYW1lID0gX3JlZi50aWNrQ2xhc3NOYW1lLFxuICAgICAgdGlja0Zvcm1hdCA9IF9yZWYudGlja0Zvcm1hdCxcbiAgICAgIF9yZWYkdGlja0xhYmVsUHJvcHMgPSBfcmVmLnRpY2tMYWJlbFByb3BzLFxuICAgICAgdGlja0xhYmVsUHJvcHMgPSBfcmVmJHRpY2tMYWJlbFByb3BzID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICB2YXIgdGljayA9IF9yZWYyLnRpY2ssXG4gICAgICAgIGluZGV4ID0gX3JlZjIuaW5kZXg7XG4gICAgcmV0dXJuIHtcbiAgICAgIGR4OiAnMC4yNWVtJyxcbiAgICAgIGR5OiAnMC4yNWVtJyxcbiAgICAgIGZpbGw6ICdibGFjaycsXG4gICAgICBmb250RmFtaWx5OiAnQXJpYWwnLFxuICAgICAgZm9udFNpemU6IDEwLFxuICAgICAgdGV4dEFuY2hvcjogJ3N0YXJ0J1xuICAgIH07XG4gIH0gOiBfcmVmJHRpY2tMYWJlbFByb3BzLFxuICAgICAgX3JlZiR0aWNrTGVuZ3RoID0gX3JlZi50aWNrTGVuZ3RoLFxuICAgICAgdGlja0xlbmd0aCA9IF9yZWYkdGlja0xlbmd0aCA9PT0gdW5kZWZpbmVkID8gOCA6IF9yZWYkdGlja0xlbmd0aCxcbiAgICAgIHRpY2tTdHJva2UgPSBfcmVmLnRpY2tTdHJva2UsXG4gICAgICB0aWNrVHJhbnNmb3JtID0gX3JlZi50aWNrVHJhbnNmb3JtLFxuICAgICAgdGlja1ZhbHVlcyA9IF9yZWYudGlja1ZhbHVlcyxcbiAgICAgIHRpY2tDb21wb25lbnQgPSBfcmVmLnRpY2tDb21wb25lbnQsXG4gICAgICB0b3AgPSBfcmVmLnRvcDtcblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChBeGlzLCB7XG4gICAgYXhpc0NsYXNzTmFtZTogY3goJ3Z4LWF4aXMtcmlnaHQnLCBheGlzQ2xhc3NOYW1lKSxcbiAgICBheGlzTGluZUNsYXNzTmFtZTogYXhpc0xpbmVDbGFzc05hbWUsXG4gICAgaGlkZUF4aXNMaW5lOiBoaWRlQXhpc0xpbmUsXG4gICAgaGlkZVRpY2tzOiBoaWRlVGlja3MsXG4gICAgaGlkZVplcm86IGhpZGVaZXJvLFxuICAgIGxhYmVsOiBsYWJlbCxcbiAgICBsYWJlbENsYXNzTmFtZTogbGFiZWxDbGFzc05hbWUsXG4gICAgbGFiZWxPZmZzZXQ6IGxhYmVsT2Zmc2V0LFxuICAgIGxhYmVsUHJvcHM6IGxhYmVsUHJvcHMsXG4gICAgbGVmdDogbGVmdCxcbiAgICBudW1UaWNrczogbnVtVGlja3MsXG4gICAgb3JpZW50YXRpb246IE9SSUVOVC5yaWdodCxcbiAgICByYW5nZVBhZGRpbmc6IHJhbmdlUGFkZGluZyxcbiAgICBzY2FsZTogc2NhbGUsXG4gICAgc3Ryb2tlOiBzdHJva2UsXG4gICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgIHN0cm9rZURhc2hhcnJheTogc3Ryb2tlRGFzaGFycmF5LFxuICAgIHRpY2tDbGFzc05hbWU6IHRpY2tDbGFzc05hbWUsXG4gICAgdGlja0Zvcm1hdDogdGlja0Zvcm1hdCxcbiAgICB0aWNrTGFiZWxQcm9wczogdGlja0xhYmVsUHJvcHMsXG4gICAgdGlja0xlbmd0aDogdGlja0xlbmd0aCxcbiAgICB0aWNrU3Ryb2tlOiB0aWNrU3Ryb2tlLFxuICAgIHRpY2tUcmFuc2Zvcm06IHRpY2tUcmFuc2Zvcm0sXG4gICAgdGlja1ZhbHVlczogdGlja1ZhbHVlcyxcbiAgICB0aWNrQ29tcG9uZW50OiB0aWNrQ29tcG9uZW50LFxuICAgIHRvcDogdG9wLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICB9KTtcbn1cblxuQXhpc1JpZ2h0LnByb3BUeXBlcyA9IHByb3BUeXBlcyQyO1xuXG52YXIgcHJvcFR5cGVzJDMgPSB7XG4gIGF4aXNDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGF4aXNMaW5lQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBoaWRlQXhpc0xpbmU6IFByb3BUeXBlcy5ib29sLFxuICBoaWRlVGlja3M6IFByb3BUeXBlcy5ib29sLFxuICBoaWRlWmVybzogUHJvcFR5cGVzLmJvb2wsXG4gIGxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBsYWJlbENsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgbGFiZWxPZmZzZXQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIGxhYmVsUHJvcHM6IFByb3BUeXBlcy5vYmplY3QsXG4gIGxlZnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIG51bVRpY2tzOiBQcm9wVHlwZXMubnVtYmVyLFxuICByYW5nZVBhZGRpbmc6IFByb3BUeXBlcy5udW1iZXIsXG4gIHNjYWxlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBzdHJva2U6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHN0cm9rZVdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLFxuICBzdHJva2VEYXNoYXJyYXk6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRpY2tDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRpY2tGb3JtYXQ6IFByb3BUeXBlcy5mdW5jLFxuICB0aWNrTGFiZWxQcm9wczogUHJvcFR5cGVzLmZ1bmMsXG4gIHRpY2tMZW5ndGg6IFByb3BUeXBlcy5udW1iZXIsXG4gIHRpY2tTdHJva2U6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRpY2tUcmFuc2Zvcm06IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRpY2tWYWx1ZXM6IFByb3BUeXBlcy5hcnJheSxcbiAgdGlja0NvbXBvbmVudDogUHJvcFR5cGVzLmZ1bmMsXG4gIHRvcDogUHJvcFR5cGVzLm51bWJlcixcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5mdW5jXG59O1xuXG5mdW5jdGlvbiBBeGlzVG9wKF9yZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIGF4aXNDbGFzc05hbWUgPSBfcmVmLmF4aXNDbGFzc05hbWUsXG4gICAgICBheGlzTGluZUNsYXNzTmFtZSA9IF9yZWYuYXhpc0xpbmVDbGFzc05hbWUsXG4gICAgICBoaWRlQXhpc0xpbmUgPSBfcmVmLmhpZGVBeGlzTGluZSxcbiAgICAgIGhpZGVUaWNrcyA9IF9yZWYuaGlkZVRpY2tzLFxuICAgICAgaGlkZVplcm8gPSBfcmVmLmhpZGVaZXJvLFxuICAgICAgbGFiZWwgPSBfcmVmLmxhYmVsLFxuICAgICAgbGFiZWxDbGFzc05hbWUgPSBfcmVmLmxhYmVsQ2xhc3NOYW1lLFxuICAgICAgX3JlZiRsYWJlbE9mZnNldCA9IF9yZWYubGFiZWxPZmZzZXQsXG4gICAgICBsYWJlbE9mZnNldCA9IF9yZWYkbGFiZWxPZmZzZXQgPT09IHVuZGVmaW5lZCA/IDggOiBfcmVmJGxhYmVsT2Zmc2V0LFxuICAgICAgbGFiZWxQcm9wcyA9IF9yZWYubGFiZWxQcm9wcyxcbiAgICAgIGxlZnQgPSBfcmVmLmxlZnQsXG4gICAgICBudW1UaWNrcyA9IF9yZWYubnVtVGlja3MsXG4gICAgICByYW5nZVBhZGRpbmcgPSBfcmVmLnJhbmdlUGFkZGluZyxcbiAgICAgIHNjYWxlID0gX3JlZi5zY2FsZSxcbiAgICAgIHN0cm9rZSA9IF9yZWYuc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGggPSBfcmVmLnN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlRGFzaGFycmF5ID0gX3JlZi5zdHJva2VEYXNoYXJyYXksXG4gICAgICB0aWNrQ2xhc3NOYW1lID0gX3JlZi50aWNrQ2xhc3NOYW1lLFxuICAgICAgdGlja0Zvcm1hdCA9IF9yZWYudGlja0Zvcm1hdCxcbiAgICAgIF9yZWYkdGlja0xhYmVsUHJvcHMgPSBfcmVmLnRpY2tMYWJlbFByb3BzLFxuICAgICAgdGlja0xhYmVsUHJvcHMgPSBfcmVmJHRpY2tMYWJlbFByb3BzID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICB2YXIgdGljayA9IF9yZWYyLnRpY2ssXG4gICAgICAgIGluZGV4ID0gX3JlZjIuaW5kZXg7XG4gICAgcmV0dXJuIHtcbiAgICAgIGR5OiAnLTAuMjVlbScsXG4gICAgICBmaWxsOiAnYmxhY2snLFxuICAgICAgZm9udEZhbWlseTogJ0FyaWFsJyxcbiAgICAgIGZvbnRTaXplOiAxMCxcbiAgICAgIHRleHRBbmNob3I6ICdtaWRkbGUnXG4gICAgfTtcbiAgfSA6IF9yZWYkdGlja0xhYmVsUHJvcHMsXG4gICAgICBfcmVmJHRpY2tMZW5ndGggPSBfcmVmLnRpY2tMZW5ndGgsXG4gICAgICB0aWNrTGVuZ3RoID0gX3JlZiR0aWNrTGVuZ3RoID09PSB1bmRlZmluZWQgPyA4IDogX3JlZiR0aWNrTGVuZ3RoLFxuICAgICAgdGlja1N0cm9rZSA9IF9yZWYudGlja1N0cm9rZSxcbiAgICAgIHRpY2tUcmFuc2Zvcm0gPSBfcmVmLnRpY2tUcmFuc2Zvcm0sXG4gICAgICB0aWNrVmFsdWVzID0gX3JlZi50aWNrVmFsdWVzLFxuICAgICAgdGlja0NvbXBvbmVudCA9IF9yZWYudGlja0NvbXBvbmVudCxcbiAgICAgIHRvcCA9IF9yZWYudG9wO1xuXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEF4aXMsIHtcbiAgICBheGlzQ2xhc3NOYW1lOiBjeCgndngtYXhpcy10b3AnLCBheGlzQ2xhc3NOYW1lKSxcbiAgICBheGlzTGluZUNsYXNzTmFtZTogYXhpc0xpbmVDbGFzc05hbWUsXG4gICAgaGlkZUF4aXNMaW5lOiBoaWRlQXhpc0xpbmUsXG4gICAgaGlkZVRpY2tzOiBoaWRlVGlja3MsXG4gICAgaGlkZVplcm86IGhpZGVaZXJvLFxuICAgIGxhYmVsOiBsYWJlbCxcbiAgICBsYWJlbENsYXNzTmFtZTogbGFiZWxDbGFzc05hbWUsXG4gICAgbGFiZWxPZmZzZXQ6IGxhYmVsT2Zmc2V0LFxuICAgIGxhYmVsUHJvcHM6IGxhYmVsUHJvcHMsXG4gICAgbGVmdDogbGVmdCxcbiAgICBudW1UaWNrczogbnVtVGlja3MsXG4gICAgb3JpZW50YXRpb246IE9SSUVOVC50b3AsXG4gICAgcmFuZ2VQYWRkaW5nOiByYW5nZVBhZGRpbmcsXG4gICAgc2NhbGU6IHNjYWxlLFxuICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICBzdHJva2VEYXNoYXJyYXk6IHN0cm9rZURhc2hhcnJheSxcbiAgICB0aWNrQ2xhc3NOYW1lOiB0aWNrQ2xhc3NOYW1lLFxuICAgIHRpY2tGb3JtYXQ6IHRpY2tGb3JtYXQsXG4gICAgdGlja0xhYmVsUHJvcHM6IHRpY2tMYWJlbFByb3BzLFxuICAgIHRpY2tMZW5ndGg6IHRpY2tMZW5ndGgsXG4gICAgdGlja1N0cm9rZTogdGlja1N0cm9rZSxcbiAgICB0aWNrVHJhbnNmb3JtOiB0aWNrVHJhbnNmb3JtLFxuICAgIHRpY2tWYWx1ZXM6IHRpY2tWYWx1ZXMsXG4gICAgdGlja0NvbXBvbmVudDogdGlja0NvbXBvbmVudCxcbiAgICB0b3A6IHRvcCxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgfSk7XG59XG5cbkF4aXNUb3AucHJvcFR5cGVzID0gcHJvcFR5cGVzJDM7XG5cbnZhciBwcm9wVHlwZXMkNCA9IHtcbiAgYXhpc0NsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgYXhpc0xpbmVDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGhpZGVBeGlzTGluZTogUHJvcFR5cGVzLmJvb2wsXG4gIGhpZGVUaWNrczogUHJvcFR5cGVzLmJvb2wsXG4gIGhpZGVaZXJvOiBQcm9wVHlwZXMuYm9vbCxcbiAgbGFiZWw6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGxhYmVsQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBsYWJlbE9mZnNldDogUHJvcFR5cGVzLm51bWJlcixcbiAgbGFiZWxQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcbiAgbGVmdDogUHJvcFR5cGVzLm51bWJlcixcbiAgbnVtVGlja3M6IFByb3BUeXBlcy5udW1iZXIsXG4gIHJhbmdlUGFkZGluZzogUHJvcFR5cGVzLm51bWJlcixcbiAgc2NhbGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHN0cm9rZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgc3Ryb2tlV2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXG4gIHN0cm9rZURhc2hhcnJheTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdGlja0NsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdGlja0Zvcm1hdDogUHJvcFR5cGVzLmZ1bmMsXG4gIHRpY2tMYWJlbFByb3BzOiBQcm9wVHlwZXMuZnVuYyxcbiAgdGlja0xlbmd0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgdGlja1N0cm9rZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdGlja1RyYW5zZm9ybTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdGlja1ZhbHVlczogUHJvcFR5cGVzLmFycmF5LFxuICB0aWNrQ29tcG9uZW50OiBQcm9wVHlwZXMuZnVuYyxcbiAgdG9wOiBQcm9wVHlwZXMubnVtYmVyLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIEF4aXNCb3R0b20oX3JlZikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgYXhpc0NsYXNzTmFtZSA9IF9yZWYuYXhpc0NsYXNzTmFtZSxcbiAgICAgIGF4aXNMaW5lQ2xhc3NOYW1lID0gX3JlZi5heGlzTGluZUNsYXNzTmFtZSxcbiAgICAgIGhpZGVBeGlzTGluZSA9IF9yZWYuaGlkZUF4aXNMaW5lLFxuICAgICAgaGlkZVRpY2tzID0gX3JlZi5oaWRlVGlja3MsXG4gICAgICBoaWRlWmVybyA9IF9yZWYuaGlkZVplcm8sXG4gICAgICBsYWJlbCA9IF9yZWYubGFiZWwsXG4gICAgICBsYWJlbENsYXNzTmFtZSA9IF9yZWYubGFiZWxDbGFzc05hbWUsXG4gICAgICBfcmVmJGxhYmVsT2Zmc2V0ID0gX3JlZi5sYWJlbE9mZnNldCxcbiAgICAgIGxhYmVsT2Zmc2V0ID0gX3JlZiRsYWJlbE9mZnNldCA9PT0gdW5kZWZpbmVkID8gOCA6IF9yZWYkbGFiZWxPZmZzZXQsXG4gICAgICBsYWJlbFByb3BzID0gX3JlZi5sYWJlbFByb3BzLFxuICAgICAgbGVmdCA9IF9yZWYubGVmdCxcbiAgICAgIG51bVRpY2tzID0gX3JlZi5udW1UaWNrcyxcbiAgICAgIHJhbmdlUGFkZGluZyA9IF9yZWYucmFuZ2VQYWRkaW5nLFxuICAgICAgc2NhbGUgPSBfcmVmLnNjYWxlLFxuICAgICAgc3Ryb2tlID0gX3JlZi5zdHJva2UsXG4gICAgICBzdHJva2VXaWR0aCA9IF9yZWYuc3Ryb2tlV2lkdGgsXG4gICAgICBzdHJva2VEYXNoYXJyYXkgPSBfcmVmLnN0cm9rZURhc2hhcnJheSxcbiAgICAgIHRpY2tDbGFzc05hbWUgPSBfcmVmLnRpY2tDbGFzc05hbWUsXG4gICAgICB0aWNrRm9ybWF0ID0gX3JlZi50aWNrRm9ybWF0LFxuICAgICAgX3JlZiR0aWNrTGFiZWxQcm9wcyA9IF9yZWYudGlja0xhYmVsUHJvcHMsXG4gICAgICB0aWNrTGFiZWxQcm9wcyA9IF9yZWYkdGlja0xhYmVsUHJvcHMgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChfcmVmMikge1xuICAgIHZhciB0aWNrID0gX3JlZjIudGljayxcbiAgICAgICAgaW5kZXggPSBfcmVmMi5pbmRleDtcbiAgICByZXR1cm4ge1xuICAgICAgZHk6ICcwLjI1ZW0nLFxuICAgICAgZmlsbDogJ2JsYWNrJyxcbiAgICAgIGZvbnRGYW1pbHk6ICdBcmlhbCcsXG4gICAgICBmb250U2l6ZTogMTAsXG4gICAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJ1xuICAgIH07XG4gIH0gOiBfcmVmJHRpY2tMYWJlbFByb3BzLFxuICAgICAgX3JlZiR0aWNrTGVuZ3RoID0gX3JlZi50aWNrTGVuZ3RoLFxuICAgICAgdGlja0xlbmd0aCA9IF9yZWYkdGlja0xlbmd0aCA9PT0gdW5kZWZpbmVkID8gOCA6IF9yZWYkdGlja0xlbmd0aCxcbiAgICAgIHRpY2tTdHJva2UgPSBfcmVmLnRpY2tTdHJva2UsXG4gICAgICB0aWNrVHJhbnNmb3JtID0gX3JlZi50aWNrVHJhbnNmb3JtLFxuICAgICAgdGlja1ZhbHVlcyA9IF9yZWYudGlja1ZhbHVlcyxcbiAgICAgIHRpY2tDb21wb25lbnQgPSBfcmVmLnRpY2tDb21wb25lbnQsXG4gICAgICB0b3AgPSBfcmVmLnRvcDtcblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChBeGlzLCB7XG4gICAgYXhpc0NsYXNzTmFtZTogY3goJ3Z4LWF4aXMtYm90dG9tJywgYXhpc0NsYXNzTmFtZSksXG4gICAgYXhpc0xpbmVDbGFzc05hbWU6IGF4aXNMaW5lQ2xhc3NOYW1lLFxuICAgIGhpZGVBeGlzTGluZTogaGlkZUF4aXNMaW5lLFxuICAgIGhpZGVUaWNrczogaGlkZVRpY2tzLFxuICAgIGhpZGVaZXJvOiBoaWRlWmVybyxcbiAgICBsYWJlbDogbGFiZWwsXG4gICAgbGFiZWxDbGFzc05hbWU6IGxhYmVsQ2xhc3NOYW1lLFxuICAgIGxhYmVsT2Zmc2V0OiBsYWJlbE9mZnNldCxcbiAgICBsYWJlbFByb3BzOiBsYWJlbFByb3BzLFxuICAgIGxlZnQ6IGxlZnQsXG4gICAgbnVtVGlja3M6IG51bVRpY2tzLFxuICAgIG9yaWVudGF0aW9uOiBPUklFTlQuYm90dG9tLFxuICAgIHJhbmdlUGFkZGluZzogcmFuZ2VQYWRkaW5nLFxuICAgIHNjYWxlOiBzY2FsZSxcbiAgICBzdHJva2U6IHN0cm9rZSxcbiAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgc3Ryb2tlRGFzaGFycmF5OiBzdHJva2VEYXNoYXJyYXksXG4gICAgdGlja0NsYXNzTmFtZTogdGlja0NsYXNzTmFtZSxcbiAgICB0aWNrRm9ybWF0OiB0aWNrRm9ybWF0LFxuICAgIHRpY2tMYWJlbFByb3BzOiB0aWNrTGFiZWxQcm9wcyxcbiAgICB0aWNrTGVuZ3RoOiB0aWNrTGVuZ3RoLFxuICAgIHRpY2tTdHJva2U6IHRpY2tTdHJva2UsXG4gICAgdGlja1RyYW5zZm9ybTogdGlja1RyYW5zZm9ybSxcbiAgICB0aWNrVmFsdWVzOiB0aWNrVmFsdWVzLFxuICAgIHRpY2tDb21wb25lbnQ6IHRpY2tDb21wb25lbnQsXG4gICAgdG9wOiB0b3AsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gIH0pO1xufVxuXG5BeGlzQm90dG9tLnByb3BUeXBlcyA9IHByb3BUeXBlcyQ0O1xuXG5leHBvcnQgeyBBeGlzLCBBeGlzTGVmdCwgQXhpc1JpZ2h0LCBBeGlzVG9wLCBBeGlzQm90dG9tLCBPUklFTlQgYXMgT3JpZW50YXRpb24gfTtcbiIsImZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IEF4aXNCb3R0b20sIEF4aXNUb3AgfSBmcm9tICdAdngvYXhpcyc7XG5pbXBvcnQgeyBheGlzU3R5bGVzU2hhcGUsIHRpY2tTdHlsZXNTaGFwZSB9IGZyb20gJy4uL3V0aWxzL3Byb3BTaGFwZXMnO1xudmFyIHByb3BUeXBlcyA9IHtcbiAgYXhpc1N0eWxlczogYXhpc1N0eWxlc1NoYXBlLFxuICBoaWRlWmVybzogUHJvcFR5cGVzLmJvb2wsXG4gIGxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBsYWJlbE9mZnNldDogUHJvcFR5cGVzLm51bWJlcixcbiAgbGFiZWxQcm9wczogUHJvcFR5cGVzLm9iamVjdE9mKFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSksXG4gIG51bVRpY2tzOiBQcm9wVHlwZXMubnVtYmVyLFxuICBvcmllbnRhdGlvbjogUHJvcFR5cGVzLm9uZU9mKFsnYm90dG9tJywgJ3RvcCddKSxcbiAgcmFuZ2VQYWRkaW5nOiBQcm9wVHlwZXMubnVtYmVyLFxuICB0aWNrU3R5bGVzOiB0aWNrU3R5bGVzU2hhcGUsXG4gIHRpY2tDb21wb25lbnQ6IFByb3BUeXBlcy5mdW5jLFxuICB0aWNrTGFiZWxQcm9wczogUHJvcFR5cGVzLmZ1bmMsXG4gIHRpY2tGb3JtYXQ6IFByb3BUeXBlcy5mdW5jLFxuICB0aWNrVmFsdWVzOiBQcm9wVHlwZXMuYXJyYXlPZiggLy8gbnVtYmVyIG9yIGRhdGUvbW9tZW50IG9iamVjdFxuICBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMub2JqZWN0LCBQcm9wVHlwZXMuc3RyaW5nXSkpLFxuICAvLyBwcm9iYWJseSBpbmplY3RlZCBieSBwYXJlbnRcbiAgaW5uZXJIZWlnaHQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIHNjYWxlOiBQcm9wVHlwZXMuZnVuY1xufTtcbnZhciBkZWZhdWx0UHJvcHMgPSB7XG4gIGF4aXNTdHlsZXM6IHt9LFxuICBoaWRlWmVybzogZmFsc2UsXG4gIGlubmVySGVpZ2h0OiBudWxsLFxuICBsYWJlbDogbnVsbCxcbiAgbGFiZWxPZmZzZXQ6IDE0LFxuICBsYWJlbFByb3BzOiBudWxsLFxuICBudW1UaWNrczogbnVsbCxcbiAgb3JpZW50YXRpb246ICdib3R0b20nLFxuICByYW5nZVBhZGRpbmc6IG51bGwsXG4gIHNjYWxlOiBudWxsLFxuICB0aWNrQ29tcG9uZW50OiBudWxsLFxuICB0aWNrRm9ybWF0OiBudWxsLFxuICB0aWNrTGFiZWxQcm9wczogbnVsbCxcbiAgdGlja1N0eWxlczoge30sXG4gIHRpY2tWYWx1ZXM6IHVuZGVmaW5lZFxufTtcblxudmFyIFhBeGlzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUmVhY3QkUHVyZUNvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShYQXhpcywgX1JlYWN0JFB1cmVDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFhBeGlzKCkge1xuICAgIHJldHVybiBfUmVhY3QkUHVyZUNvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gWEF4aXMucHJvdG90eXBlO1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgYXhpc1N0eWxlcyA9IF90aGlzJHByb3BzLmF4aXNTdHlsZXMsXG4gICAgICAgIGlubmVySGVpZ2h0ID0gX3RoaXMkcHJvcHMuaW5uZXJIZWlnaHQsXG4gICAgICAgIGhpZGVaZXJvID0gX3RoaXMkcHJvcHMuaGlkZVplcm8sXG4gICAgICAgIGxhYmVsID0gX3RoaXMkcHJvcHMubGFiZWwsXG4gICAgICAgIGxhYmVsT2Zmc2V0ID0gX3RoaXMkcHJvcHMubGFiZWxPZmZzZXQsXG4gICAgICAgIGxhYmVsUHJvcHMgPSBfdGhpcyRwcm9wcy5sYWJlbFByb3BzLFxuICAgICAgICBudW1UaWNrcyA9IF90aGlzJHByb3BzLm51bVRpY2tzLFxuICAgICAgICBvcmllbnRhdGlvbiA9IF90aGlzJHByb3BzLm9yaWVudGF0aW9uLFxuICAgICAgICByYW5nZVBhZGRpbmcgPSBfdGhpcyRwcm9wcy5yYW5nZVBhZGRpbmcsXG4gICAgICAgIHNjYWxlID0gX3RoaXMkcHJvcHMuc2NhbGUsXG4gICAgICAgIHRpY2tDb21wb25lbnQgPSBfdGhpcyRwcm9wcy50aWNrQ29tcG9uZW50LFxuICAgICAgICB0aWNrRm9ybWF0ID0gX3RoaXMkcHJvcHMudGlja0Zvcm1hdCxcbiAgICAgICAgcGFzc2VkVGlja0xhYmVsUHJvcHMgPSBfdGhpcyRwcm9wcy50aWNrTGFiZWxQcm9wcyxcbiAgICAgICAgdGlja1N0eWxlcyA9IF90aGlzJHByb3BzLnRpY2tTdHlsZXMsXG4gICAgICAgIHRpY2tWYWx1ZXMgPSBfdGhpcyRwcm9wcy50aWNrVmFsdWVzO1xuICAgIGlmICghc2NhbGUgfHwgIWlubmVySGVpZ2h0KSByZXR1cm4gbnVsbDtcbiAgICB2YXIgQXhpcyA9IG9yaWVudGF0aW9uID09PSAnYm90dG9tJyA/IEF4aXNCb3R0b20gOiBBeGlzVG9wO1xuICAgIHZhciB0aWNrTGFiZWxQcm9wcyA9IHBhc3NlZFRpY2tMYWJlbFByb3BzO1xuXG4gICAgaWYgKCF0aWNrTGFiZWxQcm9wcykge1xuICAgICAgdGlja0xhYmVsUHJvcHMgPSB0aWNrU3R5bGVzLmxhYmVsICYmIHRpY2tTdHlsZXMubGFiZWxbb3JpZW50YXRpb25dID8gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGlja1N0eWxlcy5sYWJlbFtvcmllbnRhdGlvbl07XG4gICAgICB9IDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEF4aXMsIHtcbiAgICAgIHRvcDogb3JpZW50YXRpb24gPT09ICdib3R0b20nID8gaW5uZXJIZWlnaHQgOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHJhbmdlUGFkZGluZzogcmFuZ2VQYWRkaW5nLFxuICAgICAgaGlkZVRpY2tzOiBudW1UaWNrcyA9PT0gMCxcbiAgICAgIGhpZGVaZXJvOiBoaWRlWmVybyxcbiAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgIGxhYmVsT2Zmc2V0OiBsYWJlbE9mZnNldCxcbiAgICAgIGxhYmVsUHJvcHM6IGxhYmVsUHJvcHMgfHwgKGF4aXNTdHlsZXMubGFiZWwgfHwge30pW29yaWVudGF0aW9uXSxcbiAgICAgIG51bVRpY2tzOiBudW1UaWNrcyxcbiAgICAgIHNjYWxlOiBzY2FsZSxcbiAgICAgIHN0cm9rZTogYXhpc1N0eWxlcy5zdHJva2UsXG4gICAgICBzdHJva2VXaWR0aDogYXhpc1N0eWxlcy5zdHJva2VXaWR0aCxcbiAgICAgIHRpY2tDb21wb25lbnQ6IHRpY2tDb21wb25lbnQsXG4gICAgICB0aWNrRm9ybWF0OiB0aWNrRm9ybWF0LFxuICAgICAgdGlja0xhYmVsUHJvcHM6IHRpY2tMYWJlbFByb3BzLFxuICAgICAgdGlja0xlbmd0aDogdGlja1N0eWxlcy50aWNrTGVuZ3RoLFxuICAgICAgdGlja1N0cm9rZTogdGlja1N0eWxlcy5zdHJva2UsXG4gICAgICB0aWNrVmFsdWVzOiB0aWNrVmFsdWVzXG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFhBeGlzO1xufShSZWFjdC5QdXJlQ29tcG9uZW50KTtcblxuZXhwb3J0IHsgWEF4aXMgYXMgZGVmYXVsdCB9O1xuWEF4aXMucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xuWEF4aXMuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuWEF4aXMuZGlzcGxheU5hbWUgPSAnWEF4aXMnOyIsImZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IEF4aXNMZWZ0LCBBeGlzUmlnaHQgfSBmcm9tICdAdngvYXhpcyc7XG5pbXBvcnQgeyBheGlzU3R5bGVzU2hhcGUsIHRpY2tTdHlsZXNTaGFwZSB9IGZyb20gJy4uL3V0aWxzL3Byb3BTaGFwZXMnO1xudmFyIHByb3BUeXBlcyA9IHtcbiAgYXhpc1N0eWxlczogYXhpc1N0eWxlc1NoYXBlLFxuICBoaWRlWmVybzogUHJvcFR5cGVzLmJvb2wsXG4gIGxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBsYWJlbFByb3BzOiBQcm9wVHlwZXMub2JqZWN0T2YoUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pKSxcbiAgbGFiZWxPZmZzZXQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIG51bVRpY2tzOiBQcm9wVHlwZXMubnVtYmVyLFxuICBvcmllbnRhdGlvbjogUHJvcFR5cGVzLm9uZU9mKFsnbGVmdCcsICdyaWdodCddKSxcbiAgcmFuZ2VQYWRkaW5nOiBQcm9wVHlwZXMubnVtYmVyLFxuICB0aWNrQ29tcG9uZW50OiBQcm9wVHlwZXMuZnVuYyxcbiAgdGlja1N0eWxlczogdGlja1N0eWxlc1NoYXBlLFxuICB0aWNrTGFiZWxQcm9wczogUHJvcFR5cGVzLmZ1bmMsXG4gIHRpY2tGb3JtYXQ6IFByb3BUeXBlcy5mdW5jLFxuICB0aWNrVmFsdWVzOiBQcm9wVHlwZXMuYXJyYXlPZiggLy8gbnVtYmVyIG9yIGRhdGUvbW9tZW50IG9iamVjdFxuICBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMub2JqZWN0LCBQcm9wVHlwZXMuc3RyaW5nXSkpLFxuICAvLyBwcm9iYWJseSBpbmplY3RlZCBieSBwYXJlbnRcbiAgaW5uZXJXaWR0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgaGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLFxuICBzY2FsZTogUHJvcFR5cGVzLmZ1bmNcbn07XG52YXIgZGVmYXVsdFByb3BzID0ge1xuICBheGlzU3R5bGVzOiB7fSxcbiAgaGlkZVplcm86IGZhbHNlLFxuICBpbm5lcldpZHRoOiBudWxsLFxuICBoZWlnaHQ6IG51bGwsXG4gIGxhYmVsOiBudWxsLFxuICBsYWJlbFByb3BzOiBudWxsLFxuICBsYWJlbE9mZnNldDogdW5kZWZpbmVkLFxuICBudW1UaWNrczogbnVsbCxcbiAgb3JpZW50YXRpb246ICdyaWdodCcsXG4gIHJhbmdlUGFkZGluZzogbnVsbCxcbiAgc2NhbGU6IG51bGwsXG4gIHRpY2tDb21wb25lbnQ6IG51bGwsXG4gIHRpY2tGb3JtYXQ6IG51bGwsXG4gIHRpY2tMYWJlbFByb3BzOiBudWxsLFxuICB0aWNrU3R5bGVzOiB7fSxcbiAgdGlja1ZhbHVlczogdW5kZWZpbmVkXG59O1xuXG52YXIgWUF4aXMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9SZWFjdCRQdXJlQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKFlBeGlzLCBfUmVhY3QkUHVyZUNvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gWUF4aXMoKSB7XG4gICAgcmV0dXJuIF9SZWFjdCRQdXJlQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBZQXhpcy5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBheGlzU3R5bGVzID0gX3RoaXMkcHJvcHMuYXhpc1N0eWxlcyxcbiAgICAgICAgaGlkZVplcm8gPSBfdGhpcyRwcm9wcy5oaWRlWmVybyxcbiAgICAgICAgaW5uZXJXaWR0aCA9IF90aGlzJHByb3BzLmlubmVyV2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF90aGlzJHByb3BzLmhlaWdodCxcbiAgICAgICAgbGFiZWwgPSBfdGhpcyRwcm9wcy5sYWJlbCxcbiAgICAgICAgbGFiZWxQcm9wcyA9IF90aGlzJHByb3BzLmxhYmVsUHJvcHMsXG4gICAgICAgIGxhYmVsT2Zmc2V0ID0gX3RoaXMkcHJvcHMubGFiZWxPZmZzZXQsXG4gICAgICAgIG51bVRpY2tzID0gX3RoaXMkcHJvcHMubnVtVGlja3MsXG4gICAgICAgIG9yaWVudGF0aW9uID0gX3RoaXMkcHJvcHMub3JpZW50YXRpb24sXG4gICAgICAgIHJhbmdlUGFkZGluZyA9IF90aGlzJHByb3BzLnJhbmdlUGFkZGluZyxcbiAgICAgICAgc2NhbGUgPSBfdGhpcyRwcm9wcy5zY2FsZSxcbiAgICAgICAgdGlja0NvbXBvbmVudCA9IF90aGlzJHByb3BzLnRpY2tDb21wb25lbnQsXG4gICAgICAgIHRpY2tGb3JtYXQgPSBfdGhpcyRwcm9wcy50aWNrRm9ybWF0LFxuICAgICAgICBwYXNzZWRUaWNrTGFiZWxQcm9wcyA9IF90aGlzJHByb3BzLnRpY2tMYWJlbFByb3BzLFxuICAgICAgICB0aWNrU3R5bGVzID0gX3RoaXMkcHJvcHMudGlja1N0eWxlcyxcbiAgICAgICAgdGlja1ZhbHVlcyA9IF90aGlzJHByb3BzLnRpY2tWYWx1ZXM7XG4gICAgaWYgKCFzY2FsZSB8fCAhaW5uZXJXaWR0aCkgcmV0dXJuIG51bGw7XG4gICAgdmFyIEF4aXMgPSBvcmllbnRhdGlvbiA9PT0gJ2xlZnQnID8gQXhpc0xlZnQgOiBBeGlzUmlnaHQ7XG4gICAgdmFyIHRpY2tMYWJlbFByb3BzID0gcGFzc2VkVGlja0xhYmVsUHJvcHM7XG5cbiAgICBpZiAoIXRpY2tMYWJlbFByb3BzKSB7XG4gICAgICB0aWNrTGFiZWxQcm9wcyA9IHRpY2tTdHlsZXMubGFiZWwgJiYgdGlja1N0eWxlcy5sYWJlbFtvcmllbnRhdGlvbl0gPyBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aWNrU3R5bGVzLmxhYmVsW29yaWVudGF0aW9uXTtcbiAgICAgIH0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQXhpcywge1xuICAgICAgdG9wOiAwLFxuICAgICAgbGVmdDogb3JpZW50YXRpb24gPT09ICdyaWdodCcgPyBpbm5lcldpZHRoIDogMCxcbiAgICAgIHJhbmdlUGFkZGluZzogcmFuZ2VQYWRkaW5nLFxuICAgICAgaGlkZVRpY2tzOiBudW1UaWNrcyA9PT0gMCxcbiAgICAgIGhpZGVaZXJvOiBoaWRlWmVybyxcbiAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgIGxhYmVsUHJvcHM6IF9leHRlbmRzKHtcbiAgICAgICAgdmVydGljYWxBbmNob3I6ICdzdGFydCcsXG4gICAgICAgIHdpZHRoOiBNYXRoLm1heC5hcHBseShNYXRoLCBzY2FsZS5yYW5nZSgpLmNvbmNhdChbaGVpZ2h0IHx8IDBdKSlcbiAgICAgIH0sIGxhYmVsUHJvcHMgfHwgKGF4aXNTdHlsZXMubGFiZWwgfHwge30pW29yaWVudGF0aW9uXSksXG4gICAgICBsYWJlbE9mZnNldDogbGFiZWxPZmZzZXQsXG4gICAgICBudW1UaWNrczogbnVtVGlja3MsXG4gICAgICBzY2FsZTogc2NhbGUsXG4gICAgICBzdHJva2U6IGF4aXNTdHlsZXMuc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGg6IGF4aXNTdHlsZXMuc3Ryb2tlV2lkdGgsXG4gICAgICB0aWNrQ29tcG9uZW50OiB0aWNrQ29tcG9uZW50LFxuICAgICAgdGlja0Zvcm1hdDogdGlja0Zvcm1hdCxcbiAgICAgIHRpY2tMYWJlbFByb3BzOiB0aWNrTGFiZWxQcm9wcyxcbiAgICAgIHRpY2tMZW5ndGg6IHRpY2tTdHlsZXMudGlja0xlbmd0aCxcbiAgICAgIHRpY2tTdHJva2U6IHRpY2tTdHlsZXMuc3Ryb2tlLFxuICAgICAgdGlja1ZhbHVlczogdGlja1ZhbHVlc1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBZQXhpcztcbn0oUmVhY3QuUHVyZUNvbXBvbmVudCk7XG5cbmV4cG9ydCB7IFlBeGlzIGFzIGRlZmF1bHQgfTtcbllBeGlzLnByb3BUeXBlcyA9IHByb3BUeXBlcztcbllBeGlzLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbllBeGlzLmRpc3BsYXlOYW1lID0gJ1lBeGlzJzsiLCJpbXBvcnQgUmVhY3QsIHsgQ1NTUHJvcGVydGllcyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IERpbWVuc2lvbiB9IGZyb20gJ0BzdXBlcnNldC11aS9jb3JlJztcbmltcG9ydCB7IEF4aXNMYXlvdXQgfSBmcm9tICcuL2NvbXB1dGVBeGlzTGF5b3V0JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlVGlja0NvbXBvbmVudCh7XG4gIGF4aXNXaWR0aCxcbiAgbGFiZWxBbmdsZSxcbiAgbGFiZWxGbHVzaCxcbiAgbGFiZWxPdmVybGFwLFxuICBvcmllbnQsXG4gIHRpY2tMYWJlbHMsXG4gIHRpY2tMYWJlbERpbWVuc2lvbnMsXG4gIHRpY2tUZXh0QW5jaG9yID0gJ21pZGRsZScsXG59OiBBeGlzTGF5b3V0KSB7XG4gIGlmIChsYWJlbE92ZXJsYXAgPT09ICdyb3RhdGUnICYmIGxhYmVsQW5nbGUgIT09IDApIHtcbiAgICBsZXQgeE9mZnNldCA9IGxhYmVsQW5nbGUgPiAwID8gLTYgOiA2O1xuICAgIGlmIChvcmllbnQgPT09ICd0b3AnKSB7XG4gICAgICB4T2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgY29uc3QgeU9mZnNldCA9IG9yaWVudCA9PT0gJ3RvcCcgPyAtMyA6IDA7XG5cbiAgICByZXR1cm4gKHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgZm9ybWF0dGVkVmFsdWUgPSAnJyxcbiAgICAgIC4uLnRleHRTdHlsZVxuICAgIH06IHtcbiAgICAgIHg6IG51bWJlcjtcbiAgICAgIHk6IG51bWJlcjtcbiAgICAgIGR5PzogbnVtYmVyO1xuICAgICAgZm9ybWF0dGVkVmFsdWU6IHN0cmluZztcbiAgICAgIHRleHRTdHlsZTogQ1NTUHJvcGVydGllcztcbiAgICB9KSA9PiAoXG4gICAgICA8ZyB0cmFuc2Zvcm09e2B0cmFuc2xhdGUoJHt4ICsgeE9mZnNldH0sICR7eSArIHlPZmZzZXR9KWB9PlxuICAgICAgICA8dGV4dCB0cmFuc2Zvcm09e2Byb3RhdGUoJHtsYWJlbEFuZ2xlfSlgfSB7Li4udGV4dFN0eWxlfSB0ZXh0QW5jaG9yPXt0aWNrVGV4dEFuY2hvcn0+XG4gICAgICAgICAge2Zvcm1hdHRlZFZhbHVlfVxuICAgICAgICA8L3RleHQ+XG4gICAgICA8L2c+XG4gICAgKTtcbiAgfVxuXG4gIGlmIChsYWJlbEZsdXNoID09PSB0cnVlIHx8IHR5cGVvZiBsYWJlbEZsdXNoID09PSAnbnVtYmVyJykge1xuICAgIGNvbnN0IGxhYmVsVG9EaW1lbnNpb25NYXAgPSBuZXcgTWFwPHN0cmluZywgRGltZW5zaW9uPigpO1xuICAgIHRpY2tMYWJlbHMuZm9yRWFjaCgobGFiZWwsIGkpID0+IHtcbiAgICAgIGxhYmVsVG9EaW1lbnNpb25NYXAuc2V0KGxhYmVsLCB0aWNrTGFiZWxEaW1lbnNpb25zW2ldKTtcbiAgICB9KTtcblxuICAgIHJldHVybiAoe1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBmb3JtYXR0ZWRWYWx1ZSA9ICcnLFxuICAgICAgLi4udGV4dFN0eWxlXG4gICAgfToge1xuICAgICAgeDogbnVtYmVyO1xuICAgICAgeTogbnVtYmVyO1xuICAgICAgZHk/OiBudW1iZXI7XG4gICAgICBmb3JtYXR0ZWRWYWx1ZTogc3RyaW5nO1xuICAgICAgdGV4dFN0eWxlOiBDU1NQcm9wZXJ0aWVzO1xuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IGxhYmVsVG9EaW1lbnNpb25NYXAuZ2V0KGZvcm1hdHRlZFZhbHVlKTtcbiAgICAgIGNvbnN0IGxhYmVsV2lkdGggPSB0eXBlb2YgZGltZW5zaW9uID09PSAndW5kZWZpbmVkJyA/IDAgOiBkaW1lbnNpb24ud2lkdGg7XG4gICAgICBsZXQgdGV4dEFuY2hvciA9IHRpY2tUZXh0QW5jaG9yO1xuICAgICAgbGV0IHhPZmZzZXQgPSAwO1xuXG4gICAgICBpZiAoeCAtIGxhYmVsV2lkdGggLyAyIDwgMCkge1xuICAgICAgICB0ZXh0QW5jaG9yID0gJ3N0YXJ0JztcbiAgICAgICAgaWYgKHR5cGVvZiBsYWJlbEZsdXNoID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHhPZmZzZXQgLT0gbGFiZWxGbHVzaDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh4ICsgbGFiZWxXaWR0aCAvIDIgPiBheGlzV2lkdGgpIHtcbiAgICAgICAgdGV4dEFuY2hvciA9ICdlbmQnO1xuICAgICAgICBpZiAodHlwZW9mIGxhYmVsRmx1c2ggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgeE9mZnNldCArPSBsYWJlbEZsdXNoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgIDx0ZXh0IHg9e3ggKyB4T2Zmc2V0fSB5PXt5fSB7Li4udGV4dFN0eWxlfSB0ZXh0QW5jaG9yPXt0ZXh0QW5jaG9yfT5cbiAgICAgICAgICB7Zm9ybWF0dGVkVmFsdWV9XG4gICAgICAgIDwvdGV4dD5cbiAgICAgICk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIFRoaXMgd2lsbCByZW5kZXIgdGhlIHRpY2sgYXMgaG9yaXpvbnRhbCBzdHJpbmcuXG4gIHJldHVybiBudWxsO1xufVxuIiwiaW1wb3J0IHsgQ1NTUHJvcGVydGllcyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGdldFRleHREaW1lbnNpb24sIE1hcmdpbiwgRGltZW5zaW9uIH0gZnJvbSAnQHN1cGVyc2V0LXVpL2NvcmUnO1xuaW1wb3J0IHsgQXhpc09yaWVudCwgQ2hhbm5lbERlZiwgVmFsdWUgfSBmcm9tICdlbmNvZGFibGUnO1xuXG5pbXBvcnQgQ2hhbm5lbEVuY29kZXJBeGlzIGZyb20gJ2VuY29kYWJsZS9saWIvZW5jb2RlcnMvQ2hhbm5lbEVuY29kZXJBeGlzJztcblxuZXhwb3J0IGludGVyZmFjZSBBeGlzTGF5b3V0IHtcbiAgYXhpc1dpZHRoOiBudW1iZXI7XG4gIGxhYmVsQW5nbGU6IG51bWJlcjtcbiAgbGFiZWxGbHVzaDogbnVtYmVyIHwgYm9vbGVhbjtcbiAgbGFiZWxPZmZzZXQ6IG51bWJlcjtcbiAgbGFiZWxPdmVybGFwOiAnZmxhdCcgfCAncm90YXRlJztcbiAgbWluTWFyZ2luOiBQYXJ0aWFsPE1hcmdpbj47XG4gIG9yaWVudDogQXhpc09yaWVudDtcbiAgdGlja0xhYmVsRGltZW5zaW9uczogRGltZW5zaW9uW107XG4gIHRpY2tMYWJlbHM6IHN0cmluZ1tdO1xuICB0aWNrVGV4dEFuY2hvcj86IHN0cmluZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcHV0ZUF4aXNMYXlvdXQ8RGVmIGV4dGVuZHMgQ2hhbm5lbERlZjxPdXRwdXQ+LCBPdXRwdXQgZXh0ZW5kcyBWYWx1ZT4oXG4gIGF4aXM6IENoYW5uZWxFbmNvZGVyQXhpczxEZWYsIE91dHB1dD4sXG4gIHtcbiAgICBheGlzVGl0bGVIZWlnaHQgPSAyMCxcbiAgICBheGlzV2lkdGgsXG4gICAgZ2FwQmV0d2VlbkF4aXNMYWJlbEFuZEJvcmRlciA9IDQsXG4gICAgZ2FwQmV0d2VlblRpY2tBbmRUaWNrTGFiZWwgPSA0LFxuICAgIGRlZmF1bHRUaWNrU2l6ZSA9IDgsXG4gICAgdGlja1RleHRTdHlsZSA9IHt9LFxuICB9OiB7XG4gICAgYXhpc1RpdGxlSGVpZ2h0PzogbnVtYmVyO1xuICAgIGF4aXNXaWR0aDogbnVtYmVyO1xuICAgIGdhcEJldHdlZW5BeGlzTGFiZWxBbmRCb3JkZXI/OiBudW1iZXI7XG4gICAgZ2FwQmV0d2VlblRpY2tBbmRUaWNrTGFiZWw/OiBudW1iZXI7XG4gICAgZGVmYXVsdFRpY2tTaXplPzogbnVtYmVyO1xuICAgIHRpY2tUZXh0U3R5bGU/OiBDU1NQcm9wZXJ0aWVzO1xuICB9LFxuKTogQXhpc0xheW91dCB7XG4gIGNvbnN0IHRpY2tMYWJlbHMgPSBheGlzLmdldFRpY2tMYWJlbHMoKTtcbiAgY29uc3QgdGlja0xhYmVsRGltZW5zaW9ucyA9IHRpY2tMYWJlbHMubWFwKCh0ZXh0OiBzdHJpbmcpID0+XG4gICAgZ2V0VGV4dERpbWVuc2lvbih7XG4gICAgICBzdHlsZTogdGlja1RleHRTdHlsZSxcbiAgICAgIHRleHQsXG4gICAgfSksXG4gICk7XG5cbiAgY29uc3Qge1xuICAgIGxhYmVsQW5nbGUsXG4gICAgbGFiZWxGbHVzaCxcbiAgICBsYWJlbE92ZXJsYXAsXG4gICAgbGFiZWxQYWRkaW5nLFxuICAgIG9yaWVudCxcbiAgICB0aWNrU2l6ZSA9IGRlZmF1bHRUaWNrU2l6ZSxcbiAgfSA9IGF4aXMuY29uZmlnO1xuXG4gIGNvbnN0IG1heFdpZHRoID0gTWF0aC5tYXgoLi4udGlja0xhYmVsRGltZW5zaW9ucy5tYXAoZCA9PiBkLndpZHRoKSwgMCk7XG5cbiAgLy8gY2hlYXAgaGV1cmlzdGljLCBjYW4gaW1wcm92ZVxuICBjb25zdCB3aWR0aFBlclRpY2sgPSBheGlzV2lkdGggLyB0aWNrTGFiZWxzLmxlbmd0aDtcbiAgY29uc3QgaXNMYWJlbE92ZXJsYXAgPSBtYXhXaWR0aCA+IHdpZHRoUGVyVGljaztcbiAgY29uc3QgbGFiZWxBbmdsZUlmT3ZlcmxhcCA9IGxhYmVsT3ZlcmxhcC5zdHJhdGVneSA9PT0gJ3JvdGF0ZScgPyBsYWJlbE92ZXJsYXAubGFiZWxBbmdsZSA6IDA7XG4gIGNvbnN0IGxhYmVsQW5nbGVBZnRlck92ZXJsYXBDaGVjayA9IGlzTGFiZWxPdmVybGFwID8gbGFiZWxBbmdsZUlmT3ZlcmxhcCA6IDA7XG4gIGNvbnN0IGZpbmFsTGFiZWxBbmdsZSA9IGxhYmVsQW5nbGUgPT09IDAgPyBsYWJlbEFuZ2xlQWZ0ZXJPdmVybGFwQ2hlY2sgOiBsYWJlbEFuZ2xlO1xuXG4gIGNvbnN0IHNwYWNlRm9yQXhpc1RpdGxlID0gYXhpcy5oYXNUaXRsZSgpID8gbGFiZWxQYWRkaW5nICsgYXhpc1RpdGxlSGVpZ2h0IDogMDtcbiAgbGV0IHRpY2tUZXh0QW5jaG9yID0gJ21pZGRsZSc7XG4gIGxldCBsYWJlbE9mZnNldCA9IDA7XG4gIGxldCByZXF1aXJlZE1hcmdpbiA9XG4gICAgdGlja1NpemUgKyBnYXBCZXR3ZWVuVGlja0FuZFRpY2tMYWJlbCArIHNwYWNlRm9yQXhpc1RpdGxlICsgZ2FwQmV0d2VlbkF4aXNMYWJlbEFuZEJvcmRlcjtcblxuICBpZiAoYXhpcy5jaGFubmVsRW5jb2Rlci5pc1goKSkge1xuICAgIGlmIChmaW5hbExhYmVsQW5nbGUgPT09IDApIHtcbiAgICAgIGNvbnN0IGxhYmVsSGVpZ2h0ID0gdGlja0xhYmVsRGltZW5zaW9ucy5sZW5ndGggPiAwID8gdGlja0xhYmVsRGltZW5zaW9uc1swXS5oZWlnaHQgOiAwO1xuICAgICAgbGFiZWxPZmZzZXQgPSBsYWJlbEhlaWdodCArIGxhYmVsUGFkZGluZztcbiAgICAgIHJlcXVpcmVkTWFyZ2luICs9IGxhYmVsSGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsYWJlbEhlaWdodCA9IE1hdGguY2VpbChcbiAgICAgICAgTWF0aC5hYnMobWF4V2lkdGggKiBNYXRoLnNpbigoZmluYWxMYWJlbEFuZ2xlICogTWF0aC5QSSkgLyAxODApKSxcbiAgICAgICk7XG4gICAgICBsYWJlbE9mZnNldCA9IGxhYmVsSGVpZ2h0ICsgbGFiZWxQYWRkaW5nO1xuICAgICAgcmVxdWlyZWRNYXJnaW4gKz0gbGFiZWxIZWlnaHQ7XG4gICAgICB0aWNrVGV4dEFuY2hvciA9XG4gICAgICAgIChvcmllbnQgPT09ICd0b3AnICYmIGZpbmFsTGFiZWxBbmdsZSA+IDApIHx8IChvcmllbnQgPT09ICdib3R0b20nICYmIGZpbmFsTGFiZWxBbmdsZSA8IDApXG4gICAgICAgICAgPyAnZW5kJ1xuICAgICAgICAgIDogJ3N0YXJ0JztcbiAgICB9XG4gICAgcmVxdWlyZWRNYXJnaW4gKz0gODtcbiAgfSBlbHNlIHtcbiAgICBsYWJlbE9mZnNldCA9IG1heFdpZHRoICsgc3BhY2VGb3JBeGlzVGl0bGU7XG4gICAgcmVxdWlyZWRNYXJnaW4gKz0gbWF4V2lkdGg7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGF4aXNXaWR0aCxcbiAgICBsYWJlbEFuZ2xlOiBmaW5hbExhYmVsQW5nbGUsXG4gICAgbGFiZWxGbHVzaCxcbiAgICBsYWJlbE9mZnNldCxcbiAgICBsYWJlbE92ZXJsYXA6IGlzTGFiZWxPdmVybGFwID8gbGFiZWxPdmVybGFwLnN0cmF0ZWd5IDogJ2ZsYXQnLFxuICAgIG1pbk1hcmdpbjoge1xuICAgICAgW29yaWVudF06IE1hdGguY2VpbChyZXF1aXJlZE1hcmdpbiksXG4gICAgfSxcbiAgICBvcmllbnQsXG4gICAgdGlja0xhYmVsRGltZW5zaW9ucyxcbiAgICB0aWNrTGFiZWxzLFxuICAgIHRpY2tUZXh0QW5jaG9yLFxuICB9O1xufVxuIiwiaW1wb3J0IFJlYWN0LCB7IFJlYWN0Tm9kZSwgQ1NTUHJvcGVydGllcyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFhBeGlzLCBZQXhpcyB9IGZyb20gJ0BkYXRhLXVpL3h5LWNoYXJ0JztcbmltcG9ydCB7IENoYXJ0RnJhbWUsIE1hcmdpbiwgbWVyZ2VNYXJnaW4sIERpbWVuc2lvbiB9IGZyb20gJ0BzdXBlcnNldC11aS9jb3JlJztcbmltcG9ydCB7IENoYW5uZWxFbmNvZGVyLCBQbGFpbk9iamVjdCwgVmFsdWUsIFhGaWVsZERlZiwgWUZpZWxkRGVmIH0gZnJvbSAnZW5jb2RhYmxlJztcbmltcG9ydCBjcmVhdGVUaWNrQ29tcG9uZW50IGZyb20gJy4vY3JlYXRlVGlja0NvbXBvbmVudCc7XG5pbXBvcnQgY29tcHV0ZUF4aXNMYXlvdXQsIHsgQXhpc0xheW91dCB9IGZyb20gJy4vY29tcHV0ZUF4aXNMYXlvdXQnO1xuXG5leHBvcnQgY29uc3QgREVGQVVMVF9MQUJFTF9BTkdMRSA9IDQwO1xuXG4vLyBBZGRpdGlvbmFsIG1hcmdpbiB0byBhdm9pZCBjb250ZW50IGhpZGRlbiBiZWhpbmQgc2Nyb2xsIGJhclxuY29uc3QgT1ZFUkZMT1dfTUFSR0lOID0gODtcblxuZXhwb3J0IGludGVyZmFjZSBYWUNoYXJ0TGF5b3V0Q29uZmlnPFhPdXRwdXQgZXh0ZW5kcyBWYWx1ZSwgWU91dHB1dCBleHRlbmRzIFZhbHVlPiB7XG4gIHdpZHRoOiBudW1iZXI7XG4gIGhlaWdodDogbnVtYmVyO1xuICBtaW5Db250ZW50V2lkdGg/OiBudW1iZXI7XG4gIG1pbkNvbnRlbnRIZWlnaHQ/OiBudW1iZXI7XG4gIG1hcmdpbjogTWFyZ2luO1xuICB4RW5jb2RlcjogQ2hhbm5lbEVuY29kZXI8WEZpZWxkRGVmPFhPdXRwdXQ+LCBYT3V0cHV0PjtcbiAgeFRpY2tTaXplPzogbnVtYmVyO1xuICB4VGlja1RleHRTdHlsZT86IENTU1Byb3BlcnRpZXM7XG4gIGF1dG9BZGp1c3RYTWFyZ2luPzogYm9vbGVhbjtcbiAgeUVuY29kZXI6IENoYW5uZWxFbmNvZGVyPFlGaWVsZERlZjxZT3V0cHV0PiwgWU91dHB1dD47XG4gIHlUaWNrU2l6ZT86IG51bWJlcjtcbiAgeVRpY2tUZXh0U3R5bGU/OiBDU1NQcm9wZXJ0aWVzO1xuICBhdXRvQWRqdXN0WU1hcmdpbj86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFhZQ2hhcnRMYXlvdXQ8WE91dHB1dCBleHRlbmRzIFZhbHVlLCBZT3V0cHV0IGV4dGVuZHMgVmFsdWU+IHtcbiAgY2hhcnRXaWR0aDogbnVtYmVyO1xuXG4gIGNoYXJ0SGVpZ2h0OiBudW1iZXI7XG5cbiAgY29udGFpbmVyV2lkdGg6IG51bWJlcjtcblxuICBjb250YWluZXJIZWlnaHQ6IG51bWJlcjtcblxuICBtYXJnaW46IE1hcmdpbjtcblxuICB4RW5jb2RlcjogQ2hhbm5lbEVuY29kZXI8WEZpZWxkRGVmPFhPdXRwdXQ+LCBYT3V0cHV0PjtcblxuICB4TGF5b3V0PzogQXhpc0xheW91dDtcblxuICB5RW5jb2RlcjogQ2hhbm5lbEVuY29kZXI8WUZpZWxkRGVmPFlPdXRwdXQ+LCBZT3V0cHV0PjtcblxuICB5TGF5b3V0PzogQXhpc0xheW91dDtcblxuICBjb25zdHJ1Y3Rvcihjb25maWc6IFhZQ2hhcnRMYXlvdXRDb25maWc8WE91dHB1dCwgWU91dHB1dD4pIHtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIG1pbkNvbnRlbnRXaWR0aCA9IDAsXG4gICAgICBtaW5Db250ZW50SGVpZ2h0ID0gMCxcbiAgICAgIG1hcmdpbixcbiAgICAgIHhFbmNvZGVyLFxuICAgICAgeFRpY2tTaXplLFxuICAgICAgeFRpY2tUZXh0U3R5bGUsXG4gICAgICBhdXRvQWRqdXN0WE1hcmdpbiA9IHRydWUsXG4gICAgICB5RW5jb2RlcixcbiAgICAgIHlUaWNrU2l6ZSxcbiAgICAgIHlUaWNrVGV4dFN0eWxlLFxuICAgICAgYXV0b0FkanVzdFlNYXJnaW4gPSB0cnVlLFxuICAgIH0gPSBjb25maWc7XG5cbiAgICB0aGlzLnhFbmNvZGVyID0geEVuY29kZXI7XG4gICAgdGhpcy55RW5jb2RlciA9IHlFbmNvZGVyO1xuXG4gICAgaWYgKHR5cGVvZiB5RW5jb2Rlci5heGlzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy55TGF5b3V0ID0gY29tcHV0ZUF4aXNMYXlvdXQoeUVuY29kZXIuYXhpcywge1xuICAgICAgICBheGlzV2lkdGg6IE1hdGgubWF4KGhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tKSxcbiAgICAgICAgZGVmYXVsdFRpY2tTaXplOiB5VGlja1NpemUsXG4gICAgICAgIHRpY2tUZXh0U3R5bGU6IHlUaWNrVGV4dFN0eWxlLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2Vjb25kTWFyZ2luID1cbiAgICAgIHRoaXMueUxheW91dCAmJiBhdXRvQWRqdXN0WU1hcmdpbiA/IG1lcmdlTWFyZ2luKG1hcmdpbiwgdGhpcy55TGF5b3V0Lm1pbk1hcmdpbikgOiBtYXJnaW47XG4gICAgY29uc3QgaW5uZXJXaWR0aCA9IE1hdGgubWF4KHdpZHRoIC0gc2Vjb25kTWFyZ2luLmxlZnQgLSBzZWNvbmRNYXJnaW4ucmlnaHQsIG1pbkNvbnRlbnRXaWR0aCk7XG5cbiAgICBpZiAodHlwZW9mIHhFbmNvZGVyLmF4aXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLnhMYXlvdXQgPSBjb21wdXRlQXhpc0xheW91dCh4RW5jb2Rlci5heGlzLCB7XG4gICAgICAgIGF4aXNXaWR0aDogaW5uZXJXaWR0aCxcbiAgICAgICAgZGVmYXVsdFRpY2tTaXplOiB4VGlja1NpemUsXG4gICAgICAgIHRpY2tUZXh0U3R5bGU6IHhUaWNrVGV4dFN0eWxlLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgZmluYWxNYXJnaW4gPVxuICAgICAgdGhpcy54TGF5b3V0ICYmIGF1dG9BZGp1c3RYTWFyZ2luXG4gICAgICAgID8gbWVyZ2VNYXJnaW4oc2Vjb25kTWFyZ2luLCB0aGlzLnhMYXlvdXQubWluTWFyZ2luKVxuICAgICAgICA6IHNlY29uZE1hcmdpbjtcblxuICAgIGNvbnN0IGlubmVySGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0IC0gZmluYWxNYXJnaW4udG9wIC0gZmluYWxNYXJnaW4uYm90dG9tLCBtaW5Db250ZW50SGVpZ2h0KTtcblxuICAgIGNvbnN0IGNoYXJ0V2lkdGggPSBNYXRoLnJvdW5kKGlubmVyV2lkdGggKyBmaW5hbE1hcmdpbi5sZWZ0ICsgZmluYWxNYXJnaW4ucmlnaHQpO1xuICAgIGNvbnN0IGNoYXJ0SGVpZ2h0ID0gTWF0aC5yb3VuZChpbm5lckhlaWdodCArIGZpbmFsTWFyZ2luLnRvcCArIGZpbmFsTWFyZ2luLmJvdHRvbSk7XG5cbiAgICBjb25zdCBpc092ZXJGbG93WCA9IGNoYXJ0V2lkdGggPiB3aWR0aDtcbiAgICBjb25zdCBpc092ZXJGbG93WSA9IGNoYXJ0SGVpZ2h0ID4gaGVpZ2h0O1xuICAgIGlmIChpc092ZXJGbG93WCkge1xuICAgICAgZmluYWxNYXJnaW4uYm90dG9tICs9IE9WRVJGTE9XX01BUkdJTjtcbiAgICB9XG4gICAgaWYgKGlzT3ZlckZsb3dZKSB7XG4gICAgICBmaW5hbE1hcmdpbi5yaWdodCArPSBPVkVSRkxPV19NQVJHSU47XG4gICAgfVxuICAgIHRoaXMuY2hhcnRXaWR0aCA9IGlzT3ZlckZsb3dYID8gY2hhcnRXaWR0aCArIE9WRVJGTE9XX01BUkdJTiA6IGNoYXJ0V2lkdGg7XG4gICAgdGhpcy5jaGFydEhlaWdodCA9IGlzT3ZlckZsb3dZID8gY2hhcnRIZWlnaHQgKyBPVkVSRkxPV19NQVJHSU4gOiBjaGFydEhlaWdodDtcbiAgICB0aGlzLmNvbnRhaW5lcldpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5jb250YWluZXJIZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5tYXJnaW4gPSBmaW5hbE1hcmdpbjtcbiAgfVxuXG4gIHJlbmRlckNoYXJ0V2l0aEZyYW1lKHJlbmRlckNoYXJ0OiAoaW5wdXQ6IERpbWVuc2lvbikgPT4gUmVhY3ROb2RlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxDaGFydEZyYW1lXG4gICAgICAgIHdpZHRoPXt0aGlzLmNvbnRhaW5lcldpZHRofVxuICAgICAgICBoZWlnaHQ9e3RoaXMuY29udGFpbmVySGVpZ2h0fVxuICAgICAgICBjb250ZW50V2lkdGg9e3RoaXMuY2hhcnRXaWR0aH1cbiAgICAgICAgY29udGVudEhlaWdodD17dGhpcy5jaGFydEhlaWdodH1cbiAgICAgICAgcmVuZGVyQ29udGVudD17cmVuZGVyQ2hhcnR9XG4gICAgICAvPlxuICAgICk7XG4gIH1cblxuICByZW5kZXJYQXhpcyhwcm9wcz86IFBsYWluT2JqZWN0KSB7XG4gICAgY29uc3QgeyBheGlzIH0gPSB0aGlzLnhFbmNvZGVyO1xuXG4gICAgcmV0dXJuIGF4aXMgJiYgdGhpcy54TGF5b3V0ID8gKFxuICAgICAgPFhBeGlzXG4gICAgICAgIGxhYmVsPXtheGlzLmdldFRpdGxlKCl9XG4gICAgICAgIGxhYmVsT2Zmc2V0PXt0aGlzLnhMYXlvdXQubGFiZWxPZmZzZXR9XG4gICAgICAgIG51bVRpY2tzPXtheGlzLmNvbmZpZy50aWNrQ291bnR9XG4gICAgICAgIG9yaWVudGF0aW9uPXtheGlzLmNvbmZpZy5vcmllbnR9XG4gICAgICAgIHRpY2tDb21wb25lbnQ9e2NyZWF0ZVRpY2tDb21wb25lbnQodGhpcy54TGF5b3V0KX1cbiAgICAgICAgdGlja0Zvcm1hdD17YXhpcy5mb3JtYXRWYWx1ZX1cbiAgICAgICAgey4uLnByb3BzfVxuICAgICAgLz5cbiAgICApIDogbnVsbDtcbiAgfVxuXG4gIHJlbmRlcllBeGlzKHByb3BzPzogUGxhaW5PYmplY3QpIHtcbiAgICBjb25zdCB7IGF4aXMgfSA9IHRoaXMueUVuY29kZXI7XG5cbiAgICByZXR1cm4gYXhpcyAmJiB0aGlzLnlMYXlvdXQgPyAoXG4gICAgICA8WUF4aXNcbiAgICAgICAgbGFiZWw9e2F4aXMuZ2V0VGl0bGUoKX1cbiAgICAgICAgbGFiZWxPZmZzZXQ9e3RoaXMueUxheW91dC5sYWJlbE9mZnNldH1cbiAgICAgICAgbnVtVGlja3M9e2F4aXMuY29uZmlnLnRpY2tDb3VudH1cbiAgICAgICAgb3JpZW50YXRpb249e2F4aXMuY29uZmlnLm9yaWVudH1cbiAgICAgICAgdGlja0Zvcm1hdD17YXhpcy5mb3JtYXRWYWx1ZX1cbiAgICAgICAgey4uLnByb3BzfVxuICAgICAgLz5cbiAgICApIDogbnVsbDtcbiAgfVxufVxuIiwiaW1wb3J0IHsgQ2hhcnRUaGVtZSB9IGZyb20gJ0BkYXRhLXVpL3RoZW1lJztcbmltcG9ydCB7IFZhbHVlIH0gZnJvbSAnZW5jb2RhYmxlJztcbmltcG9ydCBYWUNoYXJ0TGF5b3V0LCB7IFhZQ2hhcnRMYXlvdXRDb25maWcgfSBmcm9tICcuL1hZQ2hhcnRMYXlvdXQnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVYWUNoYXJ0TGF5b3V0V2l0aFRoZW1lPFhPdXRwdXQgZXh0ZW5kcyBWYWx1ZSwgWU91dHB1dCBleHRlbmRzIFZhbHVlPihcbiAgY29uZmlnOiBYWUNoYXJ0TGF5b3V0Q29uZmlnPFhPdXRwdXQsIFlPdXRwdXQ+ICYge1xuICAgIHRoZW1lOiBDaGFydFRoZW1lO1xuICB9LFxuKSB7XG4gIGNvbnN0IHsgdGhlbWUsIC4uLnJlc3QgfSA9IGNvbmZpZztcblxuICByZXR1cm4gbmV3IFhZQ2hhcnRMYXlvdXQ8WE91dHB1dCwgWU91dHB1dD4oe1xuICAgIC4uLnJlc3QsXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHhUaWNrU2l6ZTogdGhlbWUueFRpY2tTdHlsZXMubGVuZ3RoIHx8IHRoZW1lLnhUaWNrU3R5bGVzLnRpY2tMZW5ndGgsXG4gICAgeFRpY2tUZXh0U3R5bGU6IHRoZW1lLnhUaWNrU3R5bGVzLmxhYmVsLmJvdHRvbSB8fCB0aGVtZS54VGlja1N0eWxlcy5sYWJlbC50b3AsXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHlUaWNrU2l6ZTogdGhlbWUueVRpY2tTdHlsZXMubGVuZ3RoIHx8IHRoZW1lLnlUaWNrU3R5bGVzLnRpY2tMZW5ndGgsXG4gICAgeVRpY2tUZXh0U3R5bGU6IHRoZW1lLnlUaWNrU3R5bGVzLmxhYmVsLmxlZnQgfHwgdGhlbWUueVRpY2tTdHlsZXMubGFiZWwucmlnaHQsXG4gIH0pO1xufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDbHREQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUN6ckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDckhBO0FBSUE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBV0E7QUFFQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7Ozs7QUNyRkE7QUFrQkE7QUFrQkE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBU0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFrQkE7QUFtQkE7QUFDQTtBQWdCQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQVNBO0FBRUE7QUFDQTtBQUVBO0FBV0E7QUFFQTtBQUNBO0FBRUE7QUFVQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3hKQTtBQUVBO0FBS0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1946\n")},1947:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"a\", function() { return /* binding */ createRenderLegend; });\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react/index.js\nvar react = __webpack_require__(0);\nvar react_default = /*#__PURE__*/__webpack_require__.n(react);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/legend/esm/legends/Legend/LegendItem.js\nvar LegendItem = __webpack_require__(2288);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/legend/esm/legends/Legend/LegendLabel.js\nvar LegendLabel = __webpack_require__(2289);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/components/legend/DefaultLegendItem.tsx\n\n\nconst MARK_SIZE = 8;\nconst MARK_STYLE = { display: 'inline-block' };\nfunction DefaultLegendItem({ group, item, MarkRenderer, LabelRenderer, }) {\n    var _a, _b, _c, _d;\n    return (react_default.a.createElement(LegendItem[\"a\" /* default */], { key: `legend-item-${group.field}-${item.input}`, margin: \"0 5px\" },\n        typeof MarkRenderer === 'undefined' ? (react_default.a.createElement(\"svg\", { width: MARK_SIZE, height: MARK_SIZE, style: MARK_STYLE },\n            react_default.a.createElement(\"circle\", { fill: \n                // @ts-ignore\n                ((_c = (_b = (_a = item.output.color) !== null && _a !== void 0 ? _a : \n                // @ts-ignore\n                item.output.fill) !== null && _b !== void 0 ? _b : \n                // @ts-ignore\n                item.output.stroke) !== null && _c !== void 0 ? _c : '#ccc'), stroke: \n                // @ts-ignore\n                ((_d = item.output.stroke) !== null && _d !== void 0 ? _d : 'none'), r: MARK_SIZE / 2, cx: MARK_SIZE / 2, cy: MARK_SIZE / 2 }))) : (react_default.a.createElement(MarkRenderer, { group: group, item: item })),\n        typeof LabelRenderer === 'undefined' ? (react_default.a.createElement(LegendLabel[\"a\" /* default */], { align: \"left\", margin: \"0 0 0 4px\" }, item.input)) : (react_default.a.createElement(LabelRenderer, { group: group, item: item }))));\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/components/legend/DefaultLegendGroup.tsx\n\n\nconst LEGEND_GROUP_STYLE = {\n    display: 'flex',\n    flexBasis: 'auto',\n    flexDirection: 'row',\n    flexGrow: 1,\n    flexShrink: 1,\n    flexWrap: 'wrap',\n    fontSize: '0.8em',\n    justifyContent: 'flex-end',\n    padding: 8,\n};\nfunction DefaultLegendGroupRenderer({ group, ItemRenderer = DefaultLegendItem, ItemMarkRenderer, ItemLabelRenderer, style, }) {\n    const combinedStyle = typeof style === 'undefined' ? LEGEND_GROUP_STYLE : Object.assign(Object.assign({}, LEGEND_GROUP_STYLE), style);\n    return (react_default.a.createElement(\"div\", { style: combinedStyle }, 'items' in group &&\n        group.items.map(item => (react_default.a.createElement(ItemRenderer, { key: `legend-item-${group.field}-${item.input}`, group: group, item: item, MarkRenderer: ItemMarkRenderer, LabelRenderer: ItemLabelRenderer })))));\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/components/legend/DefaultLegend.tsx\n\n\nconst LEGEND_CONTAINER_STYLE = {\n    display: 'flex',\n    flexBasis: 'auto',\n    flexGrow: 1,\n    flexShrink: 1,\n    maxHeight: 100,\n    overflowY: 'auto',\n    position: 'relative',\n};\nclass DefaultLegend_DefaultLegend extends react[\"PureComponent\"] {\n    render() {\n        const { groups, LegendGroupRenderer = DefaultLegendGroupRenderer, LegendItemRenderer, LegendItemMarkRenderer, LegendItemLabelRenderer, style, } = this.props;\n        const combinedStyle = typeof style === 'undefined'\n            ? LEGEND_CONTAINER_STYLE\n            : Object.assign(Object.assign({}, LEGEND_CONTAINER_STYLE), style);\n        return (react_default.a.createElement(\"div\", { style: combinedStyle }, groups\n            .filter(group => 'items' in group && group.items.length > 0)\n            .map(group => (react_default.a.createElement(LegendGroupRenderer, { key: group.field, group: group, ItemRenderer: LegendItemRenderer, ItemMarkRenderer: LegendItemMarkRenderer, ItemLabelRenderer: LegendItemLabelRenderer })))));\n    }\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/components/legend/createRenderLegend.tsx\n\n\nfunction createRenderLegend(encoder, data, props) {\n    if (encoder.hasLegend()) {\n        const { LegendRenderer = DefaultLegend_DefaultLegend, LegendGroupRenderer, LegendItemRenderer, LegendItemLabelRenderer, LegendItemMarkRenderer, } = props;\n        return () => (react_default.a.createElement(LegendRenderer, { groups: encoder.getLegendInformation(data), LegendGroupRenderer: LegendGroupRenderer, LegendItemRenderer: LegendItemRenderer, LegendItemMarkRenderer: LegendItemMarkRenderer, LegendItemLabelRenderer: LegendItemLabelRenderer }));\n    }\n    return undefined;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk0Ny5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wcmVzZXQtY2hhcnQteHkvc3JjL2NvbXBvbmVudHMvbGVnZW5kL0RlZmF1bHRMZWdlbmRJdGVtLnRzeD9hMTZmIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wcmVzZXQtY2hhcnQteHkvc3JjL2NvbXBvbmVudHMvbGVnZW5kL0RlZmF1bHRMZWdlbmRHcm91cC50c3g/NWM4MSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvcHJlc2V0LWNoYXJ0LXh5L3NyYy9jb21wb25lbnRzL2xlZ2VuZC9EZWZhdWx0TGVnZW5kLnRzeD9jMzA1Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wcmVzZXQtY2hhcnQteHkvc3JjL2NvbXBvbmVudHMvbGVnZW5kL2NyZWF0ZVJlbmRlckxlZ2VuZC50c3g/YTk1NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgQ1NTUHJvcGVydGllcyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IExlZ2VuZEl0ZW0sIExlZ2VuZExhYmVsIH0gZnJvbSAnQHZ4L2xlZ2VuZCc7XG5pbXBvcnQgeyBFbmNvZGluZ0NvbmZpZyB9IGZyb20gJ2VuY29kYWJsZSc7XG5pbXBvcnQgeyBMZWdlbmRJdGVtUmVuZGVyZXJQcm9wcyB9IGZyb20gJy4vdHlwZXMnO1xuXG5jb25zdCBNQVJLX1NJWkUgPSA4O1xuXG5jb25zdCBNQVJLX1NUWUxFOiBDU1NQcm9wZXJ0aWVzID0geyBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyB9O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEZWZhdWx0TGVnZW5kSXRlbTxDb25maWcgZXh0ZW5kcyBFbmNvZGluZ0NvbmZpZz4oe1xuICBncm91cCxcbiAgaXRlbSxcbiAgTWFya1JlbmRlcmVyLFxuICBMYWJlbFJlbmRlcmVyLFxufTogTGVnZW5kSXRlbVJlbmRlcmVyUHJvcHM8Q29uZmlnPikge1xuICByZXR1cm4gKFxuICAgIDxMZWdlbmRJdGVtIGtleT17YGxlZ2VuZC1pdGVtLSR7Z3JvdXAuZmllbGR9LSR7aXRlbS5pbnB1dH1gfSBtYXJnaW49XCIwIDVweFwiPlxuICAgICAge3R5cGVvZiBNYXJrUmVuZGVyZXIgPT09ICd1bmRlZmluZWQnID8gKFxuICAgICAgICA8c3ZnIHdpZHRoPXtNQVJLX1NJWkV9IGhlaWdodD17TUFSS19TSVpFfSBzdHlsZT17TUFSS19TVFlMRX0+XG4gICAgICAgICAgPGNpcmNsZVxuICAgICAgICAgICAgZmlsbD17XG4gICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgKGl0ZW0ub3V0cHV0LmNvbG9yID8/XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGl0ZW0ub3V0cHV0LmZpbGwgPz9cbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgaXRlbS5vdXRwdXQuc3Ryb2tlID8/XG4gICAgICAgICAgICAgICAgJyNjY2MnKSBhcyBzdHJpbmdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cm9rZT17XG4gICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgKGl0ZW0ub3V0cHV0LnN0cm9rZSA/PyAnbm9uZScpIGFzIHN0cmluZ1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcj17TUFSS19TSVpFIC8gMn1cbiAgICAgICAgICAgIGN4PXtNQVJLX1NJWkUgLyAyfVxuICAgICAgICAgICAgY3k9e01BUktfU0laRSAvIDJ9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9zdmc+XG4gICAgICApIDogKFxuICAgICAgICA8TWFya1JlbmRlcmVyIGdyb3VwPXtncm91cH0gaXRlbT17aXRlbX0gLz5cbiAgICAgICl9XG4gICAgICB7dHlwZW9mIExhYmVsUmVuZGVyZXIgPT09ICd1bmRlZmluZWQnID8gKFxuICAgICAgICA8TGVnZW5kTGFiZWwgYWxpZ249XCJsZWZ0XCIgbWFyZ2luPVwiMCAwIDAgNHB4XCI+XG4gICAgICAgICAge2l0ZW0uaW5wdXR9XG4gICAgICAgIDwvTGVnZW5kTGFiZWw+XG4gICAgICApIDogKFxuICAgICAgICA8TGFiZWxSZW5kZXJlciBncm91cD17Z3JvdXB9IGl0ZW09e2l0ZW19IC8+XG4gICAgICApfVxuICAgIDwvTGVnZW5kSXRlbT5cbiAgKTtcbn1cbiIsImltcG9ydCBSZWFjdCwgeyBDU1NQcm9wZXJ0aWVzIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgRW5jb2RpbmdDb25maWcgfSBmcm9tICdlbmNvZGFibGUnO1xuaW1wb3J0IHsgTGVnZW5kR3JvdXBSZW5kZXJlclByb3BzIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgRGVmYXVsdExlZ2VuZEl0ZW0gZnJvbSAnLi9EZWZhdWx0TGVnZW5kSXRlbSc7XG5cbmNvbnN0IExFR0VORF9HUk9VUF9TVFlMRTogQ1NTUHJvcGVydGllcyA9IHtcbiAgZGlzcGxheTogJ2ZsZXgnLFxuICBmbGV4QmFzaXM6ICdhdXRvJyxcbiAgZmxleERpcmVjdGlvbjogJ3JvdycsXG4gIGZsZXhHcm93OiAxLFxuICBmbGV4U2hyaW5rOiAxLFxuICBmbGV4V3JhcDogJ3dyYXAnLFxuICBmb250U2l6ZTogJzAuOGVtJyxcbiAganVzdGlmeUNvbnRlbnQ6ICdmbGV4LWVuZCcsXG4gIHBhZGRpbmc6IDgsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEZWZhdWx0TGVnZW5kR3JvdXBSZW5kZXJlcjxDb25maWcgZXh0ZW5kcyBFbmNvZGluZ0NvbmZpZz4oe1xuICBncm91cCxcbiAgSXRlbVJlbmRlcmVyID0gRGVmYXVsdExlZ2VuZEl0ZW0sXG4gIEl0ZW1NYXJrUmVuZGVyZXIsXG4gIEl0ZW1MYWJlbFJlbmRlcmVyLFxuICBzdHlsZSxcbn06IExlZ2VuZEdyb3VwUmVuZGVyZXJQcm9wczxDb25maWc+KSB7XG4gIGNvbnN0IGNvbWJpbmVkU3R5bGUgPVxuICAgIHR5cGVvZiBzdHlsZSA9PT0gJ3VuZGVmaW5lZCcgPyBMRUdFTkRfR1JPVVBfU1RZTEUgOiB7IC4uLkxFR0VORF9HUk9VUF9TVFlMRSwgLi4uc3R5bGUgfTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgc3R5bGU9e2NvbWJpbmVkU3R5bGV9PlxuICAgICAgeydpdGVtcycgaW4gZ3JvdXAgJiZcbiAgICAgICAgZ3JvdXAuaXRlbXMubWFwKGl0ZW0gPT4gKFxuICAgICAgICAgIDxJdGVtUmVuZGVyZXJcbiAgICAgICAgICAgIGtleT17YGxlZ2VuZC1pdGVtLSR7Z3JvdXAuZmllbGR9LSR7aXRlbS5pbnB1dH1gfVxuICAgICAgICAgICAgZ3JvdXA9e2dyb3VwfVxuICAgICAgICAgICAgaXRlbT17aXRlbX1cbiAgICAgICAgICAgIE1hcmtSZW5kZXJlcj17SXRlbU1hcmtSZW5kZXJlcn1cbiAgICAgICAgICAgIExhYmVsUmVuZGVyZXI9e0l0ZW1MYWJlbFJlbmRlcmVyfVxuICAgICAgICAgIC8+XG4gICAgICAgICkpfVxuICAgIDwvZGl2PlxuICApO1xufVxuIiwiaW1wb3J0IFJlYWN0LCB7IENTU1Byb3BlcnRpZXMsIFB1cmVDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBFbmNvZGluZ0NvbmZpZyB9IGZyb20gJ2VuY29kYWJsZSc7XG5pbXBvcnQgeyBMZWdlbmRSZW5kZXJlclByb3BzIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgRGVmYXVsdExlZ2VuZEdyb3VwIGZyb20gJy4vRGVmYXVsdExlZ2VuZEdyb3VwJztcblxuY29uc3QgTEVHRU5EX0NPTlRBSU5FUl9TVFlMRTogQ1NTUHJvcGVydGllcyA9IHtcbiAgZGlzcGxheTogJ2ZsZXgnLFxuICBmbGV4QmFzaXM6ICdhdXRvJyxcbiAgZmxleEdyb3c6IDEsXG4gIGZsZXhTaHJpbms6IDEsXG4gIG1heEhlaWdodDogMTAwLFxuICBvdmVyZmxvd1k6ICdhdXRvJyxcbiAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG59O1xuXG5leHBvcnQgdHlwZSBQcm9wczxDb25maWcgZXh0ZW5kcyBFbmNvZGluZ0NvbmZpZz4gPSBMZWdlbmRSZW5kZXJlclByb3BzPENvbmZpZz47XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlZmF1bHRMZWdlbmQ8Q29uZmlnIGV4dGVuZHMgRW5jb2RpbmdDb25maWc+IGV4dGVuZHMgUHVyZUNvbXBvbmVudDxcbiAgUHJvcHM8Q29uZmlnPlxuPiB7XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBncm91cHMsXG4gICAgICBMZWdlbmRHcm91cFJlbmRlcmVyID0gRGVmYXVsdExlZ2VuZEdyb3VwLFxuICAgICAgTGVnZW5kSXRlbVJlbmRlcmVyLFxuICAgICAgTGVnZW5kSXRlbU1hcmtSZW5kZXJlcixcbiAgICAgIExlZ2VuZEl0ZW1MYWJlbFJlbmRlcmVyLFxuICAgICAgc3R5bGUsXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCBjb21iaW5lZFN0eWxlID1cbiAgICAgIHR5cGVvZiBzdHlsZSA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyBMRUdFTkRfQ09OVEFJTkVSX1NUWUxFXG4gICAgICAgIDogeyAuLi5MRUdFTkRfQ09OVEFJTkVSX1NUWUxFLCAuLi5zdHlsZSB9O1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgc3R5bGU9e2NvbWJpbmVkU3R5bGV9PlxuICAgICAgICB7Z3JvdXBzXG4gICAgICAgICAgLmZpbHRlcihncm91cCA9PiAnaXRlbXMnIGluIGdyb3VwICYmIGdyb3VwLml0ZW1zLmxlbmd0aCA+IDApXG4gICAgICAgICAgLm1hcChncm91cCA9PiAoXG4gICAgICAgICAgICA8TGVnZW5kR3JvdXBSZW5kZXJlclxuICAgICAgICAgICAgICBrZXk9e2dyb3VwLmZpZWxkfVxuICAgICAgICAgICAgICBncm91cD17Z3JvdXB9XG4gICAgICAgICAgICAgIEl0ZW1SZW5kZXJlcj17TGVnZW5kSXRlbVJlbmRlcmVyfVxuICAgICAgICAgICAgICBJdGVtTWFya1JlbmRlcmVyPXtMZWdlbmRJdGVtTWFya1JlbmRlcmVyfVxuICAgICAgICAgICAgICBJdGVtTGFiZWxSZW5kZXJlcj17TGVnZW5kSXRlbUxhYmVsUmVuZGVyZXJ9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICkpfVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEVuY29kZXIsIEVuY29kaW5nQ29uZmlnLCBEYXRhc2V0IH0gZnJvbSAnZW5jb2RhYmxlJztcbmltcG9ydCB7IExlZ2VuZEhvb2tzIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgRGVmYXVsdExlZ2VuZCBmcm9tICcuL0RlZmF1bHRMZWdlbmQnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVSZW5kZXJMZWdlbmQ8Q29uZmlnIGV4dGVuZHMgRW5jb2RpbmdDb25maWc+KFxuICBlbmNvZGVyOiBFbmNvZGVyPENvbmZpZz4sXG4gIGRhdGE6IERhdGFzZXQsXG4gIHByb3BzOiBMZWdlbmRIb29rczxDb25maWc+LFxuKSB7XG4gIGlmIChlbmNvZGVyLmhhc0xlZ2VuZCgpKSB7XG4gICAgY29uc3Qge1xuICAgICAgTGVnZW5kUmVuZGVyZXIgPSBEZWZhdWx0TGVnZW5kLFxuICAgICAgTGVnZW5kR3JvdXBSZW5kZXJlcixcbiAgICAgIExlZ2VuZEl0ZW1SZW5kZXJlcixcbiAgICAgIExlZ2VuZEl0ZW1MYWJlbFJlbmRlcmVyLFxuICAgICAgTGVnZW5kSXRlbU1hcmtSZW5kZXJlcixcbiAgICB9ID0gcHJvcHM7XG5cbiAgICByZXR1cm4gKCkgPT4gKFxuICAgICAgPExlZ2VuZFJlbmRlcmVyXG4gICAgICAgIGdyb3Vwcz17ZW5jb2Rlci5nZXRMZWdlbmRJbmZvcm1hdGlvbihkYXRhKX1cbiAgICAgICAgTGVnZW5kR3JvdXBSZW5kZXJlcj17TGVnZW5kR3JvdXBSZW5kZXJlcn1cbiAgICAgICAgTGVnZW5kSXRlbVJlbmRlcmVyPXtMZWdlbmRJdGVtUmVuZGVyZXJ9XG4gICAgICAgIExlZ2VuZEl0ZW1NYXJrUmVuZGVyZXI9e0xlZ2VuZEl0ZW1NYXJrUmVuZGVyZXJ9XG4gICAgICAgIExlZ2VuZEl0ZW1MYWJlbFJlbmRlcmVyPXtMZWdlbmRJdGVtTGFiZWxSZW5kZXJlcn1cbiAgICAgIC8+XG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFJQTtBQUVBO0FBRUE7O0FBTUE7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQVVBO0FBU0E7OztBQ2xEQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBT0E7QUFHQTtBQUdBO0FBV0E7OztBQ3pDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFHQTtBQUNBO0FBU0E7QUFFQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBV0E7QUFDQTs7O0FDbkRBO0FBR0E7QUFFQTtBQUtBO0FBQ0E7QUFRQTtBQVNBO0FBRUE7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1947\n")},2494:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, "default", function() { return /* binding */ BoxPlot_BoxPlot; });\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react/index.js\nvar react = __webpack_require__(0);\nvar react_default = /*#__PURE__*/__webpack_require__.n(react);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/chart/XYChart.js + 51 modules\nvar XYChart = __webpack_require__(2493);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/classnames/index.js\nvar classnames = __webpack_require__(75);\nvar classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/@vx/group/dist/vx-group.es.js\n\n\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nfunction Group(_ref) {\n  var _ref$top = _ref.top,\n      top = _ref$top === undefined ? 0 : _ref$top,\n      _ref$left = _ref.left,\n      left = _ref$left === undefined ? 0 : _ref$left,\n      transform = _ref.transform,\n      className = _ref.className,\n      children = _ref.children,\n      restProps = objectWithoutProperties(_ref, [\'top\', \'left\', \'transform\', \'className\', \'children\']);\n\n  return react_default.a.createElement(\n    \'g\',\n    _extends({\n      className: classnames_default()(\'cx-group\', className),\n      transform: transform || \'translate(\' + left + \', \' + top + \')\'\n    }, restProps),\n    children\n  );\n}\n\n\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-array/src/index.js + 31 modules\nvar src = __webpack_require__(350);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/init.js\nfunction initRange(domain, range) {\n  switch (arguments.length) {\n    case 0: break;\n    case 1: this.range(domain); break;\n    default: this.range(range).domain(domain); break;\n  }\n  return this;\n}\n\nfunction initInterpolator(domain, interpolator) {\n  switch (arguments.length) {\n    case 0: break;\n    case 1: this.interpolator(domain); break;\n    default: this.interpolator(interpolator).domain(domain); break;\n  }\n  return this;\n}\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-collection/src/index.js + 6 modules\nvar d3_collection_src = __webpack_require__(846);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/array.js\nvar array = Array.prototype;\n\nvar map = array.map;\nvar slice = array.slice;\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/ordinal.js\n\n\n\n\nvar implicit = {name: "implicit"};\n\nfunction ordinal() {\n  var index = Object(d3_collection_src["map"])(),\n      domain = [],\n      range = [],\n      unknown = implicit;\n\n  function scale(d) {\n    var key = d + "", i = index.get(key);\n    if (!i) {\n      if (unknown !== implicit) return unknown;\n      index.set(key, i = domain.push(d));\n    }\n    return range[(i - 1) % range.length];\n  }\n\n  scale.domain = function(_) {\n    if (!arguments.length) return domain.slice();\n    domain = [], index = Object(d3_collection_src["map"])();\n    var i = -1, n = _.length, d, key;\n    while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));\n    return scale;\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = slice.call(_), scale) : range.slice();\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  scale.copy = function() {\n    return ordinal(domain, range).unknown(unknown);\n  };\n\n  initRange.apply(scale, arguments);\n\n  return scale;\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/band.js\n\n\n\n\nfunction band() {\n  var scale = ordinal().unknown(undefined),\n      domain = scale.domain,\n      ordinalRange = scale.range,\n      range = [0, 1],\n      step,\n      bandwidth,\n      round = false,\n      paddingInner = 0,\n      paddingOuter = 0,\n      align = 0.5;\n\n  delete scale.unknown;\n\n  function rescale() {\n    var n = domain().length,\n        reverse = range[1] < range[0],\n        start = range[reverse - 0],\n        stop = range[1 - reverse];\n    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);\n    if (round) step = Math.floor(step);\n    start += (stop - start - step * (n - paddingInner)) * align;\n    bandwidth = step * (1 - paddingInner);\n    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);\n    var values = Object(src["range"])(n).map(function(i) { return start + step * i; });\n    return ordinalRange(reverse ? values.reverse() : values);\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain(_), rescale()) : domain();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = [+_[0], +_[1]], rescale()) : range.slice();\n  };\n\n  scale.rangeRound = function(_) {\n    return range = [+_[0], +_[1]], round = true, rescale();\n  };\n\n  scale.bandwidth = function() {\n    return bandwidth;\n  };\n\n  scale.step = function() {\n    return step;\n  };\n\n  scale.round = function(_) {\n    return arguments.length ? (round = !!_, rescale()) : round;\n  };\n\n  scale.padding = function(_) {\n    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;\n  };\n\n  scale.paddingInner = function(_) {\n    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;\n  };\n\n  scale.paddingOuter = function(_) {\n    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;\n  };\n\n  scale.align = function(_) {\n    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;\n  };\n\n  scale.copy = function() {\n    return band(domain(), range)\n        .round(round)\n        .paddingInner(paddingInner)\n        .paddingOuter(paddingOuter)\n        .align(align);\n  };\n\n  return initRange.apply(rescale(), arguments);\n}\n\nfunction pointish(scale) {\n  var copy = scale.copy;\n\n  scale.padding = scale.paddingOuter;\n  delete scale.paddingInner;\n  delete scale.paddingOuter;\n\n  scale.copy = function() {\n    return pointish(copy());\n  };\n\n  return scale;\n}\n\nfunction point() {\n  return pointish(band.apply(null, arguments).paddingInner(1));\n}\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-interpolate/src/value.js\nvar src_value = __webpack_require__(184);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-interpolate/src/number.js\nvar number = __webpack_require__(90);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-interpolate/src/round.js\nvar src_round = __webpack_require__(441);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/constant.js\n/* harmony default export */ var constant = (function(x) {\n  return function() {\n    return x;\n  };\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/number.js\n/* harmony default export */ var src_number = (function(x) {\n  return +x;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/continuous.js\n\n\n\n\n\n\nvar unit = [0, 1];\n\nfunction identity(x) {\n  return x;\n}\n\nfunction normalize(a, b) {\n  return (b -= (a = +a))\n      ? function(x) { return (x - a) / b; }\n      : constant(isNaN(b) ? NaN : 0.5);\n}\n\nfunction clamper(domain) {\n  var a = domain[0], b = domain[domain.length - 1], t;\n  if (a > b) t = a, a = b, b = t;\n  return function(x) { return Math.max(a, Math.min(b, x)); };\n}\n\n// normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].\n// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].\nfunction bimap(domain, range, interpolate) {\n  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];\n  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);\n  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);\n  return function(x) { return r0(d0(x)); };\n}\n\nfunction polymap(domain, range, interpolate) {\n  var j = Math.min(domain.length, range.length) - 1,\n      d = new Array(j),\n      r = new Array(j),\n      i = -1;\n\n  // Reverse descending domains.\n  if (domain[j] < domain[0]) {\n    domain = domain.slice().reverse();\n    range = range.slice().reverse();\n  }\n\n  while (++i < j) {\n    d[i] = normalize(domain[i], domain[i + 1]);\n    r[i] = interpolate(range[i], range[i + 1]);\n  }\n\n  return function(x) {\n    var i = Object(src["bisect"])(domain, x, 1, j) - 1;\n    return r[i](d[i](x));\n  };\n}\n\nfunction copy(source, target) {\n  return target\n      .domain(source.domain())\n      .range(source.range())\n      .interpolate(source.interpolate())\n      .clamp(source.clamp())\n      .unknown(source.unknown());\n}\n\nfunction transformer() {\n  var domain = unit,\n      range = unit,\n      interpolate = src_value["a" /* default */],\n      transform,\n      untransform,\n      unknown,\n      clamp = identity,\n      piecewise,\n      output,\n      input;\n\n  function rescale() {\n    piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;\n    output = input = null;\n    return scale;\n  }\n\n  function scale(x) {\n    return isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));\n  }\n\n  scale.invert = function(y) {\n    return clamp(untransform((input || (input = piecewise(range, domain.map(transform), number["a" /* default */])))(y)));\n  };\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain = map.call(_, src_number), clamp === identity || (clamp = clamper(domain)), rescale()) : domain.slice();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = slice.call(_), rescale()) : range.slice();\n  };\n\n  scale.rangeRound = function(_) {\n    return range = slice.call(_), interpolate = src_round["a" /* default */], rescale();\n  };\n\n  scale.clamp = function(_) {\n    return arguments.length ? (clamp = _ ? clamper(domain) : identity, scale) : clamp !== identity;\n  };\n\n  scale.interpolate = function(_) {\n    return arguments.length ? (interpolate = _, rescale()) : interpolate;\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  return function(t, u) {\n    transform = t, untransform = u;\n    return rescale();\n  };\n}\n\nfunction continuous(transform, untransform) {\n  return transformer()(transform, untransform);\n}\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-format/src/formatSpecifier.js\nvar formatSpecifier = __webpack_require__(393);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-format/src/precisionPrefix.js\nvar precisionPrefix = __webpack_require__(1163);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-format/src/defaultLocale.js\nvar defaultLocale = __webpack_require__(213);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-format/src/precisionRound.js\nvar precisionRound = __webpack_require__(1164);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-format/src/precisionFixed.js\nvar precisionFixed = __webpack_require__(1165);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/tickFormat.js\n\n\n\n/* harmony default export */ var src_tickFormat = (function(start, stop, count, specifier) {\n  var step = Object(src["tickStep"])(start, stop, count),\n      precision;\n  specifier = Object(formatSpecifier["b" /* default */])(specifier == null ? ",f" : specifier);\n  switch (specifier.type) {\n    case "s": {\n      var value = Math.max(Math.abs(start), Math.abs(stop));\n      if (specifier.precision == null && !isNaN(precision = Object(precisionPrefix["a" /* default */])(step, value))) specifier.precision = precision;\n      return Object(defaultLocale["c" /* formatPrefix */])(specifier, value);\n    }\n    case "":\n    case "e":\n    case "g":\n    case "p":\n    case "r": {\n      if (specifier.precision == null && !isNaN(precision = Object(precisionRound["a" /* default */])(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");\n      break;\n    }\n    case "f":\n    case "%": {\n      if (specifier.precision == null && !isNaN(precision = Object(precisionFixed["a" /* default */])(step))) specifier.precision = precision - (specifier.type === "%") * 2;\n      break;\n    }\n  }\n  return Object(defaultLocale["b" /* format */])(specifier);\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/linear.js\n\n\n\n\n\nfunction linearish(scale) {\n  var domain = scale.domain;\n\n  scale.ticks = function(count) {\n    var d = domain();\n    return Object(src["ticks"])(d[0], d[d.length - 1], count == null ? 10 : count);\n  };\n\n  scale.tickFormat = function(count, specifier) {\n    var d = domain();\n    return src_tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);\n  };\n\n  scale.nice = function(count) {\n    if (count == null) count = 10;\n\n    var d = domain(),\n        i0 = 0,\n        i1 = d.length - 1,\n        start = d[i0],\n        stop = d[i1],\n        step;\n\n    if (stop < start) {\n      step = start, start = stop, stop = step;\n      step = i0, i0 = i1, i1 = step;\n    }\n\n    step = Object(src["tickIncrement"])(start, stop, count);\n\n    if (step > 0) {\n      start = Math.floor(start / step) * step;\n      stop = Math.ceil(stop / step) * step;\n      step = Object(src["tickIncrement"])(start, stop, count);\n    } else if (step < 0) {\n      start = Math.ceil(start * step) / step;\n      stop = Math.floor(stop * step) / step;\n      step = Object(src["tickIncrement"])(start, stop, count);\n    }\n\n    if (step > 0) {\n      d[i0] = Math.floor(start / step) * step;\n      d[i1] = Math.ceil(stop / step) * step;\n      domain(d);\n    } else if (step < 0) {\n      d[i0] = Math.ceil(start * step) / step;\n      d[i1] = Math.floor(stop * step) / step;\n      domain(d);\n    }\n\n    return scale;\n  };\n\n  return scale;\n}\n\nfunction linear() {\n  var scale = continuous(identity, identity);\n\n  scale.copy = function() {\n    return copy(scale, linear());\n  };\n\n  initRange.apply(scale, arguments);\n\n  return linearish(scale);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/identity.js\n\n\n\n\nfunction identity_identity(domain) {\n  var unknown;\n\n  function scale(x) {\n    return isNaN(x = +x) ? unknown : x;\n  }\n\n  scale.invert = scale;\n\n  scale.domain = scale.range = function(_) {\n    return arguments.length ? (domain = map.call(_, src_number), scale) : domain.slice();\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  scale.copy = function() {\n    return identity_identity(domain).unknown(unknown);\n  };\n\n  domain = arguments.length ? map.call(domain, src_number) : [0, 1];\n\n  return linearish(scale);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/nice.js\n/* harmony default export */ var src_nice = (function(domain, interval) {\n  domain = domain.slice();\n\n  var i0 = 0,\n      i1 = domain.length - 1,\n      x0 = domain[i0],\n      x1 = domain[i1],\n      t;\n\n  if (x1 < x0) {\n    t = i0, i0 = i1, i1 = t;\n    t = x0, x0 = x1, x1 = t;\n  }\n\n  domain[i0] = interval.floor(x0);\n  domain[i1] = interval.ceil(x1);\n  return domain;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/log.js\n\n\n\n\n\n\nfunction transformLog(x) {\n  return Math.log(x);\n}\n\nfunction transformExp(x) {\n  return Math.exp(x);\n}\n\nfunction transformLogn(x) {\n  return -Math.log(-x);\n}\n\nfunction transformExpn(x) {\n  return -Math.exp(-x);\n}\n\nfunction pow10(x) {\n  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;\n}\n\nfunction powp(base) {\n  return base === 10 ? pow10\n      : base === Math.E ? Math.exp\n      : function(x) { return Math.pow(base, x); };\n}\n\nfunction logp(base) {\n  return base === Math.E ? Math.log\n      : base === 10 && Math.log10\n      || base === 2 && Math.log2\n      || (base = Math.log(base), function(x) { return Math.log(x) / base; });\n}\n\nfunction reflect(f) {\n  return function(x) {\n    return -f(-x);\n  };\n}\n\nfunction loggish(transform) {\n  var scale = transform(transformLog, transformExp),\n      domain = scale.domain,\n      base = 10,\n      logs,\n      pows;\n\n  function rescale() {\n    logs = logp(base), pows = powp(base);\n    if (domain()[0] < 0) {\n      logs = reflect(logs), pows = reflect(pows);\n      transform(transformLogn, transformExpn);\n    } else {\n      transform(transformLog, transformExp);\n    }\n    return scale;\n  }\n\n  scale.base = function(_) {\n    return arguments.length ? (base = +_, rescale()) : base;\n  };\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain(_), rescale()) : domain();\n  };\n\n  scale.ticks = function(count) {\n    var d = domain(),\n        u = d[0],\n        v = d[d.length - 1],\n        r;\n\n    if (r = v < u) i = u, u = v, v = i;\n\n    var i = logs(u),\n        j = logs(v),\n        p,\n        k,\n        t,\n        n = count == null ? 10 : +count,\n        z = [];\n\n    if (!(base % 1) && j - i < n) {\n      i = Math.round(i) - 1, j = Math.round(j) + 1;\n      if (u > 0) for (; i < j; ++i) {\n        for (k = 1, p = pows(i); k < base; ++k) {\n          t = p * k;\n          if (t < u) continue;\n          if (t > v) break;\n          z.push(t);\n        }\n      } else for (; i < j; ++i) {\n        for (k = base - 1, p = pows(i); k >= 1; --k) {\n          t = p * k;\n          if (t < u) continue;\n          if (t > v) break;\n          z.push(t);\n        }\n      }\n    } else {\n      z = Object(src["ticks"])(i, j, Math.min(j - i, n)).map(pows);\n    }\n\n    return r ? z.reverse() : z;\n  };\n\n  scale.tickFormat = function(count, specifier) {\n    if (specifier == null) specifier = base === 10 ? ".0e" : ",";\n    if (typeof specifier !== "function") specifier = Object(defaultLocale["b" /* format */])(specifier);\n    if (count === Infinity) return specifier;\n    if (count == null) count = 10;\n    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?\n    return function(d) {\n      var i = d / pows(Math.round(logs(d)));\n      if (i * base < base - 0.5) i *= base;\n      return i <= k ? specifier(d) : "";\n    };\n  };\n\n  scale.nice = function() {\n    return domain(src_nice(domain(), {\n      floor: function(x) { return pows(Math.floor(logs(x))); },\n      ceil: function(x) { return pows(Math.ceil(logs(x))); }\n    }));\n  };\n\n  return scale;\n}\n\nfunction log() {\n  var scale = loggish(transformer()).domain([1, 10]);\n\n  scale.copy = function() {\n    return copy(scale, log()).base(scale.base());\n  };\n\n  initRange.apply(scale, arguments);\n\n  return scale;\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/symlog.js\n\n\n\n\nfunction transformSymlog(c) {\n  return function(x) {\n    return Math.sign(x) * Math.log1p(Math.abs(x / c));\n  };\n}\n\nfunction transformSymexp(c) {\n  return function(x) {\n    return Math.sign(x) * Math.expm1(Math.abs(x)) * c;\n  };\n}\n\nfunction symlogish(transform) {\n  var c = 1, scale = transform(transformSymlog(c), transformSymexp(c));\n\n  scale.constant = function(_) {\n    return arguments.length ? transform(transformSymlog(c = +_), transformSymexp(c)) : c;\n  };\n\n  return linearish(scale);\n}\n\nfunction symlog() {\n  var scale = symlogish(transformer());\n\n  scale.copy = function() {\n    return copy(scale, symlog()).constant(scale.constant());\n  };\n\n  return initRange.apply(scale, arguments);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/pow.js\n\n\n\n\nfunction transformPow(exponent) {\n  return function(x) {\n    return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);\n  };\n}\n\nfunction transformSqrt(x) {\n  return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);\n}\n\nfunction transformSquare(x) {\n  return x < 0 ? -x * x : x * x;\n}\n\nfunction powish(transform) {\n  var scale = transform(identity, identity),\n      exponent = 1;\n\n  function rescale() {\n    return exponent === 1 ? transform(identity, identity)\n        : exponent === 0.5 ? transform(transformSqrt, transformSquare)\n        : transform(transformPow(exponent), transformPow(1 / exponent));\n  }\n\n  scale.exponent = function(_) {\n    return arguments.length ? (exponent = +_, rescale()) : exponent;\n  };\n\n  return linearish(scale);\n}\n\nfunction pow() {\n  var scale = powish(transformer());\n\n  scale.copy = function() {\n    return copy(scale, pow()).exponent(scale.exponent());\n  };\n\n  initRange.apply(scale, arguments);\n\n  return scale;\n}\n\nfunction sqrt() {\n  return pow.apply(null, arguments).exponent(0.5);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/quantile.js\n\n\n\n\nfunction quantile() {\n  var domain = [],\n      range = [],\n      thresholds = [],\n      unknown;\n\n  function rescale() {\n    var i = 0, n = Math.max(1, range.length);\n    thresholds = new Array(n - 1);\n    while (++i < n) thresholds[i - 1] = Object(src["quantile"])(domain, i / n);\n    return scale;\n  }\n\n  function scale(x) {\n    return isNaN(x = +x) ? unknown : range[Object(src["bisect"])(thresholds, x)];\n  }\n\n  scale.invertExtent = function(y) {\n    var i = range.indexOf(y);\n    return i < 0 ? [NaN, NaN] : [\n      i > 0 ? thresholds[i - 1] : domain[0],\n      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]\n    ];\n  };\n\n  scale.domain = function(_) {\n    if (!arguments.length) return domain.slice();\n    domain = [];\n    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);\n    domain.sort(src["ascending"]);\n    return rescale();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = slice.call(_), rescale()) : range.slice();\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  scale.quantiles = function() {\n    return thresholds.slice();\n  };\n\n  scale.copy = function() {\n    return quantile()\n        .domain(domain)\n        .range(range)\n        .unknown(unknown);\n  };\n\n  return initRange.apply(scale, arguments);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/quantize.js\n\n\n\n\n\nfunction quantize() {\n  var x0 = 0,\n      x1 = 1,\n      n = 1,\n      domain = [0.5],\n      range = [0, 1],\n      unknown;\n\n  function scale(x) {\n    return x <= x ? range[Object(src["bisect"])(domain, x, 0, n)] : unknown;\n  }\n\n  function rescale() {\n    var i = -1;\n    domain = new Array(n);\n    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);\n    return scale;\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (n = (range = slice.call(_)).length - 1, rescale()) : range.slice();\n  };\n\n  scale.invertExtent = function(y) {\n    var i = range.indexOf(y);\n    return i < 0 ? [NaN, NaN]\n        : i < 1 ? [x0, domain[0]]\n        : i >= n ? [domain[n - 1], x1]\n        : [domain[i - 1], domain[i]];\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : scale;\n  };\n\n  scale.thresholds = function() {\n    return domain.slice();\n  };\n\n  scale.copy = function() {\n    return quantize()\n        .domain([x0, x1])\n        .range(range)\n        .unknown(unknown);\n  };\n\n  return initRange.apply(linearish(scale), arguments);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/threshold.js\n\n\n\n\nfunction threshold() {\n  var domain = [0.5],\n      range = [0, 1],\n      unknown,\n      n = 1;\n\n  function scale(x) {\n    return x <= x ? range[Object(src["bisect"])(domain, x, 0, n)] : unknown;\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain = slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();\n  };\n\n  scale.invertExtent = function(y) {\n    var i = range.indexOf(y);\n    return [domain[i - 1], domain[i]];\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  scale.copy = function() {\n    return threshold()\n        .domain(domain)\n        .range(range)\n        .unknown(unknown);\n  };\n\n  return initRange.apply(scale, arguments);\n}\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/year.js\nvar src_year = __webpack_require__(290);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/month.js\nvar src_month = __webpack_require__(1835);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/week.js\nvar src_week = __webpack_require__(199);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/day.js\nvar src_day = __webpack_require__(843);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/hour.js\nvar src_hour = __webpack_require__(1836);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/minute.js\nvar src_minute = __webpack_require__(1837);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/second.js\nvar src_second = __webpack_require__(1154);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/millisecond.js\nvar src_millisecond = __webpack_require__(1155);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time-format/src/defaultLocale.js\nvar src_defaultLocale = __webpack_require__(470);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/time.js\n\n\n\n\n\n\n\n\nvar durationSecond = 1000,\n    durationMinute = durationSecond * 60,\n    durationHour = durationMinute * 60,\n    durationDay = durationHour * 24,\n    durationWeek = durationDay * 7,\n    durationMonth = durationDay * 30,\n    durationYear = durationDay * 365;\n\nfunction date(t) {\n  return new Date(t);\n}\n\nfunction time_number(t) {\n  return t instanceof Date ? +t : +new Date(+t);\n}\n\nfunction calendar(year, month, week, day, hour, minute, second, millisecond, format) {\n  var scale = continuous(identity, identity),\n      invert = scale.invert,\n      domain = scale.domain;\n\n  var formatMillisecond = format(".%L"),\n      formatSecond = format(":%S"),\n      formatMinute = format("%I:%M"),\n      formatHour = format("%I %p"),\n      formatDay = format("%a %d"),\n      formatWeek = format("%b %d"),\n      formatMonth = format("%B"),\n      formatYear = format("%Y");\n\n  var tickIntervals = [\n    [second,  1,      durationSecond],\n    [second,  5,  5 * durationSecond],\n    [second, 15, 15 * durationSecond],\n    [second, 30, 30 * durationSecond],\n    [minute,  1,      durationMinute],\n    [minute,  5,  5 * durationMinute],\n    [minute, 15, 15 * durationMinute],\n    [minute, 30, 30 * durationMinute],\n    [  hour,  1,      durationHour  ],\n    [  hour,  3,  3 * durationHour  ],\n    [  hour,  6,  6 * durationHour  ],\n    [  hour, 12, 12 * durationHour  ],\n    [   day,  1,      durationDay   ],\n    [   day,  2,  2 * durationDay   ],\n    [  week,  1,      durationWeek  ],\n    [ month,  1,      durationMonth ],\n    [ month,  3,  3 * durationMonth ],\n    [  year,  1,      durationYear  ]\n  ];\n\n  function tickFormat(date) {\n    return (second(date) < date ? formatMillisecond\n        : minute(date) < date ? formatSecond\n        : hour(date) < date ? formatMinute\n        : day(date) < date ? formatHour\n        : month(date) < date ? (week(date) < date ? formatDay : formatWeek)\n        : year(date) < date ? formatMonth\n        : formatYear)(date);\n  }\n\n  function tickInterval(interval, start, stop, step) {\n    if (interval == null) interval = 10;\n\n    // If a desired tick count is specified, pick a reasonable tick interval\n    // based on the extent of the domain and a rough estimate of tick size.\n    // Otherwise, assume interval is already a time interval and use it.\n    if (typeof interval === "number") {\n      var target = Math.abs(stop - start) / interval,\n          i = Object(src["bisector"])(function(i) { return i[2]; }).right(tickIntervals, target);\n      if (i === tickIntervals.length) {\n        step = Object(src["tickStep"])(start / durationYear, stop / durationYear, interval);\n        interval = year;\n      } else if (i) {\n        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];\n        step = i[1];\n        interval = i[0];\n      } else {\n        step = Math.max(Object(src["tickStep"])(start, stop, interval), 1);\n        interval = millisecond;\n      }\n    }\n\n    return step == null ? interval : interval.every(step);\n  }\n\n  scale.invert = function(y) {\n    return new Date(invert(y));\n  };\n\n  scale.domain = function(_) {\n    return arguments.length ? domain(map.call(_, time_number)) : domain().map(date);\n  };\n\n  scale.ticks = function(interval, step) {\n    var d = domain(),\n        t0 = d[0],\n        t1 = d[d.length - 1],\n        r = t1 < t0,\n        t;\n    if (r) t = t0, t0 = t1, t1 = t;\n    t = tickInterval(interval, t0, t1, step);\n    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop\n    return r ? t.reverse() : t;\n  };\n\n  scale.tickFormat = function(count, specifier) {\n    return specifier == null ? tickFormat : format(specifier);\n  };\n\n  scale.nice = function(interval, step) {\n    var d = domain();\n    return (interval = tickInterval(interval, d[0], d[d.length - 1], step))\n        ? domain(src_nice(d, interval))\n        : scale;\n  };\n\n  scale.copy = function() {\n    return copy(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));\n  };\n\n  return scale;\n}\n\n/* harmony default export */ var time = (function() {\n  return initRange.apply(calendar(src_year["a" /* default */], src_month["a" /* default */], src_week["d" /* sunday */], src_day["a" /* default */], src_hour["a" /* default */], src_minute["a" /* default */], src_second["a" /* default */], src_millisecond["a" /* default */], src_defaultLocale["a" /* timeFormat */]).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);\n});\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/utcYear.js\nvar utcYear = __webpack_require__(291);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/utcMonth.js\nvar utcMonth = __webpack_require__(1838);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/utcWeek.js\nvar utcWeek = __webpack_require__(200);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/utcDay.js\nvar utcDay = __webpack_require__(844);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/utcHour.js\nvar utcHour = __webpack_require__(1839);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/utcMinute.js\nvar utcMinute = __webpack_require__(1840);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/utcTime.js\n\n\n\n\n\n/* harmony default export */ var utcTime = (function() {\n  return initRange.apply(calendar(utcYear["a" /* default */], utcMonth["a" /* default */], utcWeek["d" /* utcSunday */], utcDay["a" /* default */], utcHour["a" /* default */], utcMinute["a" /* default */], src_second["a" /* default */], src_millisecond["a" /* default */], src_defaultLocale["b" /* utcFormat */]).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]), arguments);\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/sequential.js\n\n\n\n\n\n\n\nfunction sequential_transformer() {\n  var x0 = 0,\n      x1 = 1,\n      t0,\n      t1,\n      k10,\n      transform,\n      interpolator = identity,\n      clamp = false,\n      unknown;\n\n  function scale(x) {\n    return isNaN(x = +x) ? unknown : interpolator(k10 === 0 ? 0.5 : (x = (transform(x) - t0) * k10, clamp ? Math.max(0, Math.min(1, x)) : x));\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (t0 = transform(x0 = +_[0]), t1 = transform(x1 = +_[1]), k10 = t0 === t1 ? 0 : 1 / (t1 - t0), scale) : [x0, x1];\n  };\n\n  scale.clamp = function(_) {\n    return arguments.length ? (clamp = !!_, scale) : clamp;\n  };\n\n  scale.interpolator = function(_) {\n    return arguments.length ? (interpolator = _, scale) : interpolator;\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  return function(t) {\n    transform = t, t0 = t(x0), t1 = t(x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0);\n    return scale;\n  };\n}\n\nfunction sequential_copy(source, target) {\n  return target\n      .domain(source.domain())\n      .interpolator(source.interpolator())\n      .clamp(source.clamp())\n      .unknown(source.unknown());\n}\n\nfunction sequential() {\n  var scale = linearish(sequential_transformer()(identity));\n\n  scale.copy = function() {\n    return sequential_copy(scale, sequential());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction sequentialLog() {\n  var scale = loggish(sequential_transformer()).domain([1, 10]);\n\n  scale.copy = function() {\n    return sequential_copy(scale, sequentialLog()).base(scale.base());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction sequentialSymlog() {\n  var scale = symlogish(sequential_transformer());\n\n  scale.copy = function() {\n    return sequential_copy(scale, sequentialSymlog()).constant(scale.constant());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction sequentialPow() {\n  var scale = powish(sequential_transformer());\n\n  scale.copy = function() {\n    return sequential_copy(scale, sequentialPow()).exponent(scale.exponent());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction sequentialSqrt() {\n  return sequentialPow.apply(null, arguments).exponent(0.5);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/sequentialQuantile.js\n\n\n\n\nfunction sequentialQuantile() {\n  var domain = [],\n      interpolator = identity;\n\n  function scale(x) {\n    if (!isNaN(x = +x)) return interpolator((Object(src["bisect"])(domain, x) - 1) / (domain.length - 1));\n  }\n\n  scale.domain = function(_) {\n    if (!arguments.length) return domain.slice();\n    domain = [];\n    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);\n    domain.sort(src["ascending"]);\n    return scale;\n  };\n\n  scale.interpolator = function(_) {\n    return arguments.length ? (interpolator = _, scale) : interpolator;\n  };\n\n  scale.copy = function() {\n    return sequentialQuantile(interpolator).domain(domain);\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/diverging.js\n\n\n\n\n\n\n\n\nfunction diverging_transformer() {\n  var x0 = 0,\n      x1 = 0.5,\n      x2 = 1,\n      t0,\n      t1,\n      t2,\n      k10,\n      k21,\n      interpolator = identity,\n      transform,\n      clamp = false,\n      unknown;\n\n  function scale(x) {\n    return isNaN(x = +x) ? unknown : (x = 0.5 + ((x = +transform(x)) - t1) * (x < t1 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x)) : x));\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (t0 = transform(x0 = +_[0]), t1 = transform(x1 = +_[1]), t2 = transform(x2 = +_[2]), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), scale) : [x0, x1, x2];\n  };\n\n  scale.clamp = function(_) {\n    return arguments.length ? (clamp = !!_, scale) : clamp;\n  };\n\n  scale.interpolator = function(_) {\n    return arguments.length ? (interpolator = _, scale) : interpolator;\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  return function(t) {\n    transform = t, t0 = t(x0), t1 = t(x1), t2 = t(x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1);\n    return scale;\n  };\n}\n\nfunction diverging() {\n  var scale = linearish(diverging_transformer()(identity));\n\n  scale.copy = function() {\n    return sequential_copy(scale, diverging());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction divergingLog() {\n  var scale = loggish(diverging_transformer()).domain([0.1, 1, 10]);\n\n  scale.copy = function() {\n    return sequential_copy(scale, divergingLog()).base(scale.base());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction divergingSymlog() {\n  var scale = symlogish(diverging_transformer());\n\n  scale.copy = function() {\n    return sequential_copy(scale, divergingSymlog()).constant(scale.constant());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction divergingPow() {\n  var scale = powish(diverging_transformer());\n\n  scale.copy = function() {\n    return sequential_copy(scale, divergingPow()).exponent(scale.exponent());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction divergingSqrt() {\n  return divergingPow.apply(null, arguments).exponent(0.5);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/@vx/scale/dist/vx-scale.es.js\n\n\nvar vx_scale_es_band = (function (_ref) {\n  var range = _ref.range,\n      rangeRound = _ref.rangeRound,\n      domain = _ref.domain,\n      padding = _ref.padding,\n      paddingInner = _ref.paddingInner,\n      paddingOuter = _ref.paddingOuter,\n      align = _ref.align,\n      tickFormat = _ref.tickFormat;\n\n  var scale = band();\n\n  if (range) scale.range(range);\n  if (rangeRound) scale.rangeRound(rangeRound);\n  if (domain) scale.domain(domain);\n  if (padding) scale.padding(padding);\n  if (paddingInner) scale.paddingInner(paddingInner);\n  if (paddingOuter) scale.paddingOuter(paddingOuter);\n  if (align) scale.align(align);\n  if (tickFormat) scale.tickFormat = tickFormat;\n\n  return scale;\n});\n\nvar vx_scale_es_point = (function (_ref) {\n  var range = _ref.range,\n      rangeRound = _ref.rangeRound,\n      domain = _ref.domain,\n      padding = _ref.padding,\n      align = _ref.align,\n      _ref$nice = _ref.nice,\n      nice = _ref$nice === undefined ? false : _ref$nice;\n\n  var scale = point();\n\n  if (range) scale.range(range);\n  if (rangeRound) scale.rangeRound(rangeRound);\n  if (domain) scale.domain(domain);\n  if (nice) scale.nice();\n  if (padding) scale.padding(padding);\n  if (align) scale.align(align);\n\n  return scale;\n});\n\nvar vx_scale_es_linear = (function (_ref) {\n  var range = _ref.range,\n      rangeRound = _ref.rangeRound,\n      domain = _ref.domain,\n      _ref$nice = _ref.nice,\n      nice = _ref$nice === undefined ? false : _ref$nice,\n      _ref$clamp = _ref.clamp,\n      clamp = _ref$clamp === undefined ? false : _ref$clamp;\n\n  var scale = linear();\n\n  if (range) scale.range(range);\n  if (rangeRound) scale.rangeRound(rangeRound);\n  if (domain) scale.domain(domain);\n  if (nice) scale.nice();\n  if (clamp) scale.clamp(true);\n\n  return scale;\n});\n\nvar vx_scale_es_time = (function (_ref) {\n  var range = _ref.range,\n      rangeRound = _ref.rangeRound,\n      domain = _ref.domain,\n      _ref$nice = _ref.nice,\n      nice = _ref$nice === undefined ? false : _ref$nice,\n      _ref$clamp = _ref.clamp,\n      clamp = _ref$clamp === undefined ? false : _ref$clamp;\n\n  var scale = time();\n\n  if (range) scale.range(range);\n  if (rangeRound) scale.rangeRound(rangeRound);\n  if (domain) scale.domain(domain);\n  if (nice) scale.nice();\n  if (clamp) scale.clamp(true);\n\n  return scale;\n});\n\nvar utc = (function (_ref) {\n  var range = _ref.range,\n      rangeRound = _ref.rangeRound,\n      domain = _ref.domain,\n      _ref$nice = _ref.nice,\n      nice = _ref$nice === undefined ? false : _ref$nice,\n      _ref$clamp = _ref.clamp,\n      clamp = _ref$clamp === undefined ? false : _ref$clamp;\n\n  var scale = utcTime();\n\n  if (range) scale.range(range);\n  if (rangeRound) scale.rangeRound(rangeRound);\n  if (domain) scale.domain(domain);\n  if (nice) scale.nice();\n  if (clamp) scale.clamp(true);\n\n  return scale;\n});\n\nvar vx_scale_es_log = (function (_ref) {\n  var range = _ref.range,\n      rangeRound = _ref.rangeRound,\n      domain = _ref.domain,\n      base = _ref.base,\n      _ref$nice = _ref.nice,\n      nice = _ref$nice === undefined ? false : _ref$nice,\n      _ref$clamp = _ref.clamp,\n      clamp = _ref$clamp === undefined ? false : _ref$clamp;\n\n  var scale = log();\n\n  if (range) scale.range(range);\n  if (rangeRound) scale.rangeRound(rangeRound);\n  if (domain) scale.domain(domain);\n  if (nice) scale.nice();\n  if (clamp) scale.clamp(true);\n  if (base) scale.base(base);\n\n  return scale;\n});\n\nvar power = (function (_ref) {\n  var range = _ref.range,\n      rangeRound = _ref.rangeRound,\n      domain = _ref.domain,\n      exponent = _ref.exponent,\n      _ref$nice = _ref.nice,\n      nice = _ref$nice === undefined ? false : _ref$nice,\n      _ref$clamp = _ref.clamp,\n      clamp = _ref$clamp === undefined ? false : _ref$clamp;\n\n  var scale = pow();\n\n  if (range) scale.range(range);\n  if (rangeRound) scale.rangeRound(rangeRound);\n  if (domain) scale.domain(domain);\n  if (nice) scale.nice();\n  if (clamp) scale.clamp(true);\n  if (exponent) scale.exponent(exponent);\n\n  return scale;\n});\n\nvar vx_scale_es_ordinal = (function (_ref) {\n  var range = _ref.range,\n      domain = _ref.domain,\n      unknown = _ref.unknown;\n\n  var scale = ordinal();\n\n  if (range) scale.range(range);\n  if (domain) scale.domain(domain);\n  if (unknown) scale.unknown(unknown);\n\n  return scale;\n});\n\nvar vx_scale_es_quantize = (function (_ref) {\n  var range = _ref.range,\n      domain = _ref.domain,\n      ticks = _ref.ticks,\n      tickFormat = _ref.tickFormat,\n      _ref$nice = _ref.nice,\n      nice = _ref$nice === undefined ? false : _ref$nice;\n\n  var scale = quantize();\n\n  if (range) scale.range(range);\n  if (domain) scale.domain(domain);\n  if (nice) scale.nice();\n  if (ticks) scale.ticks(ticks);\n  if (tickFormat) scale.tickFormat(tickFormat);\n\n  return scale;\n});\n\nvar vx_scale_es_quantile = (function (_ref) {\n  var range = _ref.range,\n      domain = _ref.domain;\n\n  var scale = quantile();\n\n  if (range) scale.range(range);\n  if (domain) scale.domain(domain);\n\n  return scale;\n});\n\nvar vx_scale_es_threshold = (function (_ref) {\n  var range = _ref.range,\n      domain = _ref.domain;\n\n  var scale = threshold();\n\n  if (range) scale.range(range);\n  if (domain) scale.domain(domain);\n\n  return scale;\n});\n\nvar vx_scale_es_objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nfunction updateScale(scale, _ref) {\n  var args = vx_scale_es_objectWithoutProperties(_ref, []);\n\n  var nextScale = scale.copy();\n  Object.keys(args).forEach(function (key) {\n    if (nextScale.hasOwnProperty(key)) nextScale[key](args[key]);\n  });\n  return nextScale;\n}\n\n\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-shape/src/line.js\nvar line = __webpack_require__(1949);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-shape/src/curve/cardinal.js\nvar cardinal = __webpack_require__(1908);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/dist/vx-stats.es.js\n\n\n\n\n\n\nfunction callOrValue(maybeFn, data) {\n  if (typeof maybeFn === \'function\') {\n    return maybeFn(data);\n  }\n  return maybeFn;\n}\n\nfunction additionalProps(restProps, data) {\n  return Object.keys(restProps).reduce(function (ret, cur) {\n    ret[cur] = callOrValue(restProps[cur], data);\n    return ret;\n  }, {});\n}\n\nvar vx_stats_es_extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar vx_stats_es_objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i["return"]) _i["return"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError("Invalid attempt to destructure non-iterable instance");\n    }\n  };\n}();\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\nfunction verticalToHorizontal(_ref) {\n  var _ref2 = slicedToArray(_ref, 4),\n      x1 = _ref2[0],\n      y1 = _ref2[1],\n      x2 = _ref2[2],\n      y2 = _ref2[3];\n\n  return [y1, x1, y2, x2];\n}\n\nfunction vx_stats_es_BoxPlot(_ref3) {\n  var _ref3$left = _ref3.left,\n      left = _ref3$left === undefined ? 0 : _ref3$left,\n      _ref3$top = _ref3.top,\n      top = _ref3$top === undefined ? 0 : _ref3$top,\n      className = _ref3.className,\n      data = _ref3.data,\n      max = _ref3.max,\n      min = _ref3.min,\n      firstQuartile = _ref3.firstQuartile,\n      thirdQuartile = _ref3.thirdQuartile,\n      median = _ref3.median,\n      boxWidth = _ref3.boxWidth,\n      fill = _ref3.fill,\n      fillOpacity = _ref3.fillOpacity,\n      stroke = _ref3.stroke,\n      strokeWidth = _ref3.strokeWidth,\n      _ref3$rx = _ref3.rx,\n      rx = _ref3$rx === undefined ? 2 : _ref3$rx,\n      _ref3$ry = _ref3.ry,\n      ry = _ref3$ry === undefined ? 2 : _ref3$ry,\n      valueScale = _ref3.valueScale,\n      outliers = _ref3.outliers,\n      horizontal = _ref3.horizontal,\n      _ref3$medianProps = _ref3.medianProps,\n      medianProps = _ref3$medianProps === undefined ? {} : _ref3$medianProps,\n      _ref3$maxProps = _ref3.maxProps,\n      maxProps = _ref3$maxProps === undefined ? {} : _ref3$maxProps,\n      _ref3$minProps = _ref3.minProps,\n      minProps = _ref3$minProps === undefined ? {} : _ref3$minProps,\n      _ref3$boxProps = _ref3.boxProps,\n      boxProps = _ref3$boxProps === undefined ? {} : _ref3$boxProps,\n      _ref3$outlierProps = _ref3.outlierProps,\n      outlierProps = _ref3$outlierProps === undefined ? {} : _ref3$outlierProps,\n      _ref3$container = _ref3.container,\n      container = _ref3$container === undefined ? false : _ref3$container,\n      _ref3$containerProps = _ref3.containerProps,\n      containerProps = _ref3$containerProps === undefined ? {} : _ref3$containerProps,\n      restProps = vx_stats_es_objectWithoutProperties(_ref3, [\'left\', \'top\', \'className\', \'data\', \'max\', \'min\', \'firstQuartile\', \'thirdQuartile\', \'median\', \'boxWidth\', \'fill\', \'fillOpacity\', \'stroke\', \'strokeWidth\', \'rx\', \'ry\', \'valueScale\', \'outliers\', \'horizontal\', \'medianProps\', \'maxProps\', \'minProps\', \'boxProps\', \'outlierProps\', \'container\', \'containerProps\']);\n\n  var offset = horizontal ? top : left;\n  var center = offset + boxWidth / 2;\n\n  var maxLinePos = Array(4).fill(0);\n  var maxToBoxLinePos = Array(4).fill(0);\n  var boxPos = Array(4).fill(0);\n  var medianLinePos = Array(4).fill(0);\n  var minToBoxLinePos = Array(4).fill(0);\n  var minLinePos = Array(4).fill(0);\n  var containerPos = Array(4).fill(0);\n\n  // all of these are [x0, y0, x1, y1]\n  maxLinePos[0] = center - boxWidth / 4;\n  maxLinePos[1] = valueScale(max);\n  maxLinePos[2] = center + boxWidth / 4;\n  maxLinePos[3] = valueScale(max);\n\n  maxToBoxLinePos[0] = center;\n  maxToBoxLinePos[1] = valueScale(max);\n  maxToBoxLinePos[2] = center;\n  maxToBoxLinePos[3] = valueScale(thirdQuartile);\n\n  boxPos[0] = offset;\n  boxPos[1] = valueScale(thirdQuartile);\n  boxPos[2] = boxWidth;\n  boxPos[3] = Math.abs(valueScale(thirdQuartile) - valueScale(firstQuartile));\n\n  medianLinePos[0] = offset;\n  medianLinePos[1] = valueScale(median);\n  medianLinePos[2] = offset + boxWidth;\n  medianLinePos[3] = valueScale(median);\n\n  minToBoxLinePos[0] = center;\n  minToBoxLinePos[1] = valueScale(firstQuartile);\n  minToBoxLinePos[2] = center;\n  minToBoxLinePos[3] = valueScale(min);\n\n  minLinePos[0] = center - boxWidth / 4;\n  minLinePos[1] = valueScale(min);\n  minLinePos[2] = center + boxWidth / 4;\n  minLinePos[3] = valueScale(min);\n\n  var valueRange = valueScale.range();\n  containerPos[0] = boxPos[0];\n  containerPos[1] = Math.min.apply(Math, toConsumableArray(valueRange));\n  containerPos[2] = boxPos[2];\n  containerPos[3] = Math.abs(valueRange[0] - valueRange[1]);\n\n  if (horizontal) {\n    maxLinePos = verticalToHorizontal(maxLinePos);\n    maxToBoxLinePos = verticalToHorizontal(maxToBoxLinePos);\n    boxPos = verticalToHorizontal(boxPos);\n    boxPos[0] = valueScale(firstQuartile);\n    medianLinePos = verticalToHorizontal(medianLinePos);\n    minToBoxLinePos = verticalToHorizontal(minToBoxLinePos);\n    minLinePos = verticalToHorizontal(minLinePos);\n    containerPos = verticalToHorizontal(containerPos);\n    containerPos[0] = Math.min.apply(Math, toConsumableArray(valueRange));\n  }\n  return react_default.a.createElement(\n    Group,\n    { className: classnames_default()(\'vx-boxplot\', className) },\n    outliers.map(function (d, i) {\n      var cx = horizontal ? valueScale(d) : center;\n      var cy = horizontal ? center : valueScale(d);\n      return react_default.a.createElement(\'circle\', vx_stats_es_extends({\n        key: i,\n        className: \'vx-boxplot-outlier\',\n        cx: cx,\n        cy: cy,\n        stroke: stroke,\n        strokeWidth: 1,\n        fill: fill,\n        fillOpacity: fillOpacity,\n        r: \'4\'\n      }, additionalProps(outlierProps, {\n        data: d,\n        cx: cx,\n        cy: cy\n      })));\n    }),\n    react_default.a.createElement(\'line\', vx_stats_es_extends({\n      className: \'vx-boxplot-max\',\n      x1: maxLinePos[0],\n      y1: maxLinePos[1],\n      x2: maxLinePos[2],\n      y2: maxLinePos[3],\n      stroke: stroke,\n      strokeWidth: strokeWidth\n    }, additionalProps(maxProps, {\n      data: data,\n      max: max,\n      x1: maxLinePos[0],\n      x2: maxLinePos[2],\n      y1: maxLinePos[1],\n      y2: maxLinePos[3]\n    }))),\n    react_default.a.createElement(\'line\', {\n      x1: maxToBoxLinePos[0],\n      y1: maxToBoxLinePos[1],\n      x2: maxToBoxLinePos[2],\n      y2: maxToBoxLinePos[3],\n      stroke: stroke,\n      strokeWidth: strokeWidth\n    }),\n    react_default.a.createElement(\'rect\', vx_stats_es_extends({\n      className: \'vx-boxplot-box\',\n      x: boxPos[0],\n      y: boxPos[1],\n      width: boxPos[2],\n      height: boxPos[3],\n      stroke: stroke,\n      strokeWidth: strokeWidth,\n      fill: fill,\n      fillOpacity: fillOpacity,\n      rx: rx,\n      ry: ry\n    }, additionalProps(boxProps, {\n      data: data,\n      height: boxPos[3],\n      median: median,\n      firstQuartile: firstQuartile,\n      thirdQuartile: thirdQuartile,\n      min: min,\n      max: max,\n      x1: boxPos[0],\n      x2: boxPos[0] + boxPos[2],\n      y1: boxPos[1],\n      y2: boxPos[1] + boxPos[3]\n    }))),\n    react_default.a.createElement(\'line\', vx_stats_es_extends({\n      className: \'vx-boxplot-median\',\n      x1: medianLinePos[0],\n      y1: medianLinePos[1],\n      x2: medianLinePos[2],\n      y2: medianLinePos[3],\n      stroke: stroke,\n      strokeWidth: strokeWidth\n    }, additionalProps(medianProps, {\n      data: data,\n      median: median,\n      x1: medianLinePos[0],\n      x2: medianLinePos[2],\n      y1: medianLinePos[1],\n      y2: medianLinePos[3]\n    }))),\n    react_default.a.createElement(\'line\', {\n      x1: minToBoxLinePos[0],\n      y1: minToBoxLinePos[1],\n      x2: minToBoxLinePos[2],\n      y2: minToBoxLinePos[3],\n      stroke: stroke,\n      strokeWidth: strokeWidth\n    }),\n    react_default.a.createElement(\'line\', vx_stats_es_extends({\n      className: \'vx-boxplot-min\',\n      x1: minLinePos[0],\n      y1: minLinePos[1],\n      x2: minLinePos[2],\n      y2: minLinePos[3],\n      stroke: stroke,\n      strokeWidth: strokeWidth\n    }, additionalProps(minProps, {\n      data: data,\n      min: min,\n      x1: minLinePos[0],\n      x2: minLinePos[2],\n      y1: minLinePos[1],\n      y2: minLinePos[3]\n    }))),\n    container && react_default.a.createElement(\'rect\', vx_stats_es_extends({\n      x: containerPos[0],\n      y: containerPos[1],\n      width: containerPos[2],\n      height: containerPos[3],\n      fillOpacity: \'0\'\n    }, additionalProps(containerProps, {\n      data: data,\n      x1: containerPos[0],\n      x2: containerPos[0] + containerPos[2],\n      y1: containerPos[1],\n      y2: containerPos[1] + containerPos[3],\n      median: median,\n      max: max,\n      min: min,\n      thirdQuartile: thirdQuartile,\n      firstQuartile: firstQuartile\n    })))\n  );\n}\n\nfunction ViolinPlot(_ref) {\n  var _ref$left = _ref.left,\n      left = _ref$left === undefined ? 0 : _ref$left,\n      _ref$top = _ref.top,\n      top = _ref$top === undefined ? 0 : _ref$top,\n      className = _ref.className,\n      binData = _ref.binData,\n      _ref$stroke = _ref.stroke,\n      stroke = _ref$stroke === undefined ? \'black\' : _ref$stroke,\n      _ref$fill = _ref.fill,\n      fill = _ref$fill === undefined ? \'rgba(0,0,0,0.3)\' : _ref$fill,\n      opacity = _ref.opacity,\n      strokeWidth = _ref.strokeWidth,\n      width = _ref.width,\n      valueScale = _ref.valueScale,\n      strokeDasharray = _ref.strokeDasharray,\n      horizontal = _ref.horizontal,\n      restProps = vx_stats_es_objectWithoutProperties(_ref, [\'left\', \'top\', \'className\', \'binData\', \'stroke\', \'fill\', \'opacity\', \'strokeWidth\', \'width\', \'valueScale\', \'strokeDasharray\', \'horizontal\']);\n\n  var center = (horizontal ? top : left) + width / 2;\n  var binCounts = binData.map(function (bin) {\n    return bin.count;\n  });\n  var widthScale = vx_scale_es_linear({\n    rangeRound: [0, width / 2],\n    domain: [0, Math.max.apply(Math, toConsumableArray(binCounts))]\n  });\n\n  var path = \'\';\n  if (horizontal) {\n    var topCurve = Object(line["a" /* default */])().x(function (d) {\n      return valueScale(d.value);\n    }).y(function (d) {\n      return center - widthScale(d.count);\n    }).curve(cardinal["b" /* default */]);\n\n    var bottomCurve = Object(line["a" /* default */])().x(function (d) {\n      return valueScale(d.value);\n    }).y(function (d) {\n      return center + widthScale(d.count);\n    }).curve(cardinal["b" /* default */]);\n\n    var topCurvePath = topCurve(binData);\n    var bottomCurvePath = bottomCurve([].concat(toConsumableArray(binData)).reverse());\n    path = topCurvePath + \' \' + bottomCurvePath.replace(\'M\', \'L\') + \' Z\';\n  } else {\n    var rightCurve = Object(line["a" /* default */])().x(function (d) {\n      return center + widthScale(d.count);\n    }).y(function (d) {\n      return valueScale(d.value);\n    }).curve(cardinal["b" /* default */]);\n\n    var leftCurve = Object(line["a" /* default */])().x(function (d) {\n      return center - widthScale(d.count);\n    }).y(function (d) {\n      return valueScale(d.value);\n    }).curve(cardinal["b" /* default */]);\n\n    var rightCurvePath = rightCurve(binData);\n    var leftCurvePath = leftCurve([].concat(toConsumableArray(binData)).reverse());\n    path = rightCurvePath + \' \' + leftCurvePath.replace(\'M\', \'L\') + \' Z\';\n  }\n  return react_default.a.createElement(\n    Group,\n    { className: classnames_default()(\'vx-violin\', className) },\n    react_default.a.createElement(\'path\', vx_stats_es_extends({\n      d: path,\n      stroke: stroke,\n      strokeWidth: strokeWidth,\n      strokeDasharray: strokeDasharray,\n      fill: fill,\n      fillOpacity: opacity\n    }, additionalProps(restProps, binData)))\n  );\n}\n\nfunction computeStats (numericalArray) {\n  var points = [].concat(toConsumableArray(numericalArray)).sort(function (a, b) {\n    return a - b;\n  });\n  var sampleSize = points.length;\n  var firstQuartile = points[Math.round(sampleSize / 4)];\n  var thirdQuartile = points[Math.round(3 * sampleSize / 4)];\n  var IQR = thirdQuartile - firstQuartile;\n\n  var min = firstQuartile - 1.5 * IQR;\n  var max = thirdQuartile + 1.5 * IQR;\n\n  var outliers = points.filter(function (p) {\n    return p < min || p > max;\n  });\n  var binWidth = 2 * IQR * Math.pow(sampleSize - outliers.length, -1 / 3);\n  var binNum = Math.round((max - min) / binWidth);\n  var actualBinWidth = (max - min) / binNum;\n\n  var bins = Array(binNum + 2).fill(0);\n  var values = Array(binNum + 2).fill(min);\n\n  for (var i = 1; i <= binNum; i += 1) {\n    values[i] += actualBinWidth * (i - 0.5);\n  }\n\n  values[values.length - 1] = max;\n\n  points.filter(function (p) {\n    return p >= min && p <= max;\n  }).forEach(function (p) {\n    bins[Math.floor((p - min) / actualBinWidth) + 1] += 1;\n  });\n\n  var binData = values.map(function (v, i) {\n    return {\n      value: v,\n      count: bins[i]\n    };\n  });\n\n  var boxPlot = {\n    min: min,\n    firstQuartile: firstQuartile,\n    median: points[Math.round(sampleSize / 2)],\n    thirdQuartile: thirdQuartile,\n    max: max,\n    outliers: outliers\n  };\n\n  return {\n    boxPlot: boxPlot,\n    binData: binData\n  };\n}\n\n\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/shared/esm/components/FocusBlurHandler.js\nvar FocusBlurHandler = __webpack_require__(2483);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/node_modules/@vx/group/dist/vx-group.es.js\nvar vx_group_es = __webpack_require__(1903);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/prop-types/index.js\nvar prop_types = __webpack_require__(57);\nvar prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/theme/esm/color.js\nvar esm_color = __webpack_require__(1954);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/utils/chartUtils.js\nvar chartUtils = __webpack_require__(1899);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/utils/propShapes.js\nvar propShapes = __webpack_require__(1894);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/utils/sharedSeriesProps.js\nvar sharedSeriesProps = __webpack_require__(1940);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/series/BoxPlotSeries.js\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nfunction BoxPlotSeries_extends() { BoxPlotSeries_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return BoxPlotSeries_extends.apply(this, arguments); }\n\n\n\n\n\n\n\n\n\n\n\nvar propTypes = BoxPlotSeries_extends({}, sharedSeriesProps["a" /* default */], {\n  containerEvents: prop_types_default.a.bool,\n  data: propShapes["c" /* boxPlotSeriesDataShape */].isRequired,\n  fill: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.string]),\n  horizontal: prop_types_default.a.bool,\n  stroke: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.string]),\n  strokeWidth: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  fillOpacity: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  widthRatio: prop_types_default.a.number,\n  containerProps: prop_types_default.a.object,\n  // eslint-disable-line react/forbid-prop-types\n  outlierProps: prop_types_default.a.object,\n  // eslint-disable-line react/forbid-prop-types\n  boxProps: prop_types_default.a.object,\n  // eslint-disable-line react/forbid-prop-types\n  minProps: prop_types_default.a.object,\n  // eslint-disable-line react/forbid-prop-types\n  maxProps: prop_types_default.a.object,\n  // eslint-disable-line react/forbid-prop-types\n  medianProps: prop_types_default.a.object // eslint-disable-line react/forbid-prop-types\n\n});\n\nvar defaultProps = {\n  containerEvents: true,\n  stroke: esm_color["a" /* default */].darkGray,\n  strokeWidth: 2,\n  fill: esm_color["a" /* default */].default,\n  fillOpacity: 1,\n  horizontal: false,\n  widthRatio: 1,\n  containerProps: null,\n  outlierProps: null,\n  boxProps: null,\n  minProps: null,\n  maxProps: null,\n  medianProps: null\n};\nvar MAX_BOX_WIDTH = 50;\n\nvar BoxPlotSeries_x = function x(d) {\n  return d.x;\n};\n\nvar BoxPlotSeries_y = function y(d) {\n  return d.y;\n};\n\nvar BoxPlotSeries_min = function min(d) {\n  return d.min;\n};\n\nvar BoxPlotSeries_max = function max(d) {\n  return d.max;\n};\n\nvar BoxPlotSeries_median = function median(d) {\n  return d.median;\n};\n\nvar BoxPlotSeries_firstQuartile = function firstQuartile(d) {\n  return d.firstQuartile;\n};\n\nvar BoxPlotSeries_thirdQuartile = function thirdQuartile(d) {\n  return d.thirdQuartile;\n};\n\nvar BoxPlotSeries_outliers = function outliers(d) {\n  return d.outliers || [];\n};\n\nvar BoxPlotSeries_BoxPlotSeries =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inheritsLoose(BoxPlotSeries, _React$PureComponent);\n\n  function BoxPlotSeries() {\n    return _React$PureComponent.apply(this, arguments) || this;\n  }\n\n  var _proto = BoxPlotSeries.prototype;\n\n  _proto.render = function render() {\n    var _this$props = this.props,\n        containerEvents = _this$props.containerEvents,\n        data = _this$props.data,\n        fill = _this$props.fill,\n        stroke = _this$props.stroke,\n        strokeWidth = _this$props.strokeWidth,\n        xScale = _this$props.xScale,\n        yScale = _this$props.yScale,\n        horizontal = _this$props.horizontal,\n        widthRatio = _this$props.widthRatio,\n        fillOpacity = _this$props.fillOpacity,\n        containerProps = _this$props.containerProps,\n        outlierProps = _this$props.outlierProps,\n        boxProps = _this$props.boxProps,\n        minProps = _this$props.minProps,\n        maxProps = _this$props.maxProps,\n        medianProps = _this$props.medianProps,\n        onMouseMove = _this$props.onMouseMove,\n        onMouseLeave = _this$props.onMouseLeave,\n        disableMouseEvents = _this$props.disableMouseEvents,\n        onClick = _this$props.onClick;\n    if (!xScale || !yScale) return null;\n    var offsetScale = horizontal ? yScale : xScale;\n    var offsetValue = horizontal ? BoxPlotSeries_y : BoxPlotSeries_x;\n    var valueScale = horizontal ? xScale : yScale;\n    var boxWidth = offsetScale.bandwidth();\n    var actualWidth = Math.min(MAX_BOX_WIDTH, boxWidth);\n    var offset = (offsetScale.offset || 0) - (boxWidth - actualWidth) / 2;\n    var offsetPropName = horizontal ? \'top\' : \'left\';\n\n    var offsetProp = function offsetProp(d) {\n      var _ref;\n\n      return _ref = {}, _ref[offsetPropName] = offsetScale(offsetValue(d)) - offset + (1 - widthRatio) / 2 * actualWidth, _ref;\n    };\n\n    var mouseEventProps = function mouseEventProps(d, i) {\n      return {\n        onMouseMove: disableMouseEvents ? null : onMouseMove && function () {\n          return function (event) {\n            onMouseMove({\n              event: event,\n              data: data,\n              datum: d,\n              index: i\n            });\n          };\n        },\n        onMouseLeave: disableMouseEvents ? null : onMouseLeave && function () {\n          return onMouseLeave;\n        },\n        onClick: disableMouseEvents ? null : onClick && function () {\n          return function (event) {\n            onClick({\n              event: event,\n              data: data,\n              datum: d,\n              index: i\n            });\n          };\n        }\n      };\n    };\n\n    return react_default.a.createElement(vx_group_es["a" /* Group */], null, data.map(function (d, i) {\n      var mouseEvents = mouseEventProps(d, i);\n      return Object(chartUtils["j" /* isDefined */])(BoxPlotSeries_min(d)) && react_default.a.createElement(FocusBlurHandler["a" /* default */], {\n        key: offsetValue(d),\n        xlinkHref: "#",\n        onBlur: disableMouseEvents ? null : onMouseLeave,\n        onFocus: disableMouseEvents ? null : function (event) {\n          onMouseMove({\n            event: event,\n            data: data,\n            datum: d,\n            index: i\n          });\n        }\n      }, react_default.a.createElement(vx_stats_es_BoxPlot, BoxPlotSeries_extends({\n        min: BoxPlotSeries_min(d),\n        max: BoxPlotSeries_max(d)\n      }, offsetProp(d), {\n        firstQuartile: BoxPlotSeries_firstQuartile(d),\n        thirdQuartile: BoxPlotSeries_thirdQuartile(d),\n        median: BoxPlotSeries_median(d),\n        boxWidth: actualWidth * widthRatio,\n        outliers: BoxPlotSeries_outliers(d),\n        fill: d.fill || Object(chartUtils["b" /* callOrValue */])(fill, d, i),\n        stroke: d.stroke || Object(chartUtils["b" /* callOrValue */])(stroke, d, i),\n        strokeWidth: d.strokeWidth || Object(chartUtils["b" /* callOrValue */])(strokeWidth, d, i),\n        fillOpacity: d.fillOpacity || Object(chartUtils["b" /* callOrValue */])(fillOpacity, d, i),\n        valueScale: valueScale,\n        horizontal: horizontal,\n        container: containerEvents,\n        containerProps: (containerEvents || containerProps || undefined) && BoxPlotSeries_extends({}, containerProps, containerEvents && mouseEvents),\n        outlierProps: (!containerEvents || outlierProps || undefined) && BoxPlotSeries_extends({}, outlierProps, !containerEvents && mouseEvents),\n        boxProps: (!containerEvents || boxProps || undefined) && BoxPlotSeries_extends({}, boxProps, !containerEvents && mouseEvents),\n        minProps: (!containerEvents || minProps || undefined) && BoxPlotSeries_extends({}, minProps, !containerEvents && mouseEvents),\n        maxProps: (!containerEvents || maxProps || undefined) && BoxPlotSeries_extends({}, maxProps, !containerEvents && mouseEvents),\n        medianProps: (!containerEvents || medianProps || undefined) && BoxPlotSeries_extends({}, medianProps, !containerEvents && mouseEvents)\n      })));\n    }));\n  };\n\n  return BoxPlotSeries;\n}(react_default.a.PureComponent);\n\n\nBoxPlotSeries_BoxPlotSeries.propTypes = propTypes;\nBoxPlotSeries_BoxPlotSeries.defaultProps = defaultProps;\nBoxPlotSeries_BoxPlotSeries.displayName = \'BoxPlotSeries\';\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/theme/esm/chartTheme.js + 2 modules\nvar chartTheme = __webpack_require__(2516);\n\n// EXTERNAL MODULE: ../superset-ui-core/src/chart-composition/legend/WithLegend.tsx\nvar WithLegend = __webpack_require__(1017);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/typeGuards/ChannelDef.js\nvar ChannelDef = __webpack_require__(232);\n\n// EXTERNAL MODULE: ../superset-ui-core/src/utils/isDefined.ts\nvar isDefined = __webpack_require__(452);\n\n// EXTERNAL MODULE: ../superset-ui-core/src/chart-composition/tooltip/TooltipFrame.tsx\nvar TooltipFrame = __webpack_require__(1018);\n\n// EXTERNAL MODULE: ../superset-ui-core/src/chart-composition/tooltip/TooltipTable.tsx\nvar TooltipTable = __webpack_require__(1019);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/components/BoxPlot/DefaultTooltipRenderer.tsx\n\n\nfunction DefaultTooltipRenderer({ datum, color, encoder, }) {\n    const { label, min, max, median, firstQuartile, thirdQuartile, outliers } = datum;\n    const { channels } = encoder;\n    const { formatValue } = channels.y;\n    const data = [];\n    if (Object(isDefined["a" /* default */])(min)) {\n        data.push({ key: \'Min\', valueColumn: formatValue(min) });\n    }\n    if (Object(isDefined["a" /* default */])(max)) {\n        data.push({ key: \'Max\', valueColumn: formatValue(max) });\n    }\n    if (Object(isDefined["a" /* default */])(median)) {\n        data.push({ key: \'Median\', valueColumn: formatValue(median) });\n    }\n    if (Object(isDefined["a" /* default */])(firstQuartile)) {\n        data.push({ key: \'1st Quartile\', valueColumn: formatValue(firstQuartile) });\n    }\n    if (Object(isDefined["a" /* default */])(thirdQuartile)) {\n        data.push({ key: \'3rd Quartile\', valueColumn: formatValue(thirdQuartile) });\n    }\n    if (Object(isDefined["a" /* default */])(outliers) && outliers.length > 0) {\n        data.push({ key: \'# Outliers\', valueColumn: outliers.length });\n    }\n    return (react_default.a.createElement(TooltipFrame["a" /* default */], null,\n        react_default.a.createElement("div", null,\n            react_default.a.createElement("strong", { style: { color } }, label)),\n        data.length > 0 && react_default.a.createElement("br", null),\n        react_default.a.createElement(TooltipTable["a" /* default */], { data: data })));\n}\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/encoders/createEncoderFactory.js\nvar createEncoderFactory = __webpack_require__(1167);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/components/BoxPlot/Encoder.ts\n\nconst boxPlotEncoderFactory = Object(createEncoderFactory["a" /* default */])({\n    channelTypes: {\n        x: \'XBand\',\n        y: \'YBand\',\n        color: \'Color\',\n    },\n    defaultEncoding: {\n        x: { field: \'x\', type: \'nominal\' },\n        y: { field: \'y\', type: \'quantitative\' },\n        color: { value: \'#222\' },\n    },\n});\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/utils/createMarginSelector.tsx\nvar createMarginSelector = __webpack_require__(1943);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/utils/convertScaleToDataUIScaleShape.ts\nvar convertScaleToDataUIScaleShape = __webpack_require__(1945);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/utils/createXYChartLayoutWithTheme.ts + 8 modules\nvar createXYChartLayoutWithTheme = __webpack_require__(1946);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/components/legend/createRenderLegend.tsx + 3 modules\nvar createRenderLegend = __webpack_require__(1947);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/components/BoxPlot/BoxPlot.tsx\n\n\n\n\n\n\n\n\n\n\n\nconst BoxPlot_defaultProps = {\n    className: \'\',\n    margin: createMarginSelector["a" /* DEFAULT_MARGIN */],\n    encoding: {},\n    theme: chartTheme["a" /* default */],\n    TooltipRenderer: DefaultTooltipRenderer,\n};\nclass BoxPlot_BoxPlot extends react_default.a.PureComponent {\n    constructor() {\n        super(...arguments);\n        this.createEncoder = boxPlotEncoderFactory.createSelector();\n        this.createMargin = Object(createMarginSelector["b" /* default */])();\n        this.renderChart = (dim) => {\n            const { width, height } = dim;\n            const { data, margin, theme, TooltipRenderer, encoding } = this.props;\n            const encoder = this.createEncoder(encoding);\n            const { channels } = encoder;\n            const isHorizontal = Object(ChannelDef["a" /* isFieldDef */])(channels.y.definition) && channels.y.definition.type === \'nominal\';\n            encoder.setDomainFromDataset(data);\n            const layout = Object(createXYChartLayoutWithTheme["a" /* default */])({\n                width,\n                height,\n                margin: this.createMargin(margin),\n                theme,\n                xEncoder: channels.x,\n                yEncoder: channels.y,\n            });\n            return layout.renderChartWithFrame((chartDim) => (react_default.a.createElement(XYChart["a" /* default */], { showYGrid: true, width: chartDim.width, height: chartDim.height, ariaLabel: "BoxPlot", margin: layout.margin, renderTooltip: ({ datum, color }) => (react_default.a.createElement(TooltipRenderer, { datum: datum, color: color, encoder: encoder })), theme: theme, \n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                xScale: Object(convertScaleToDataUIScaleShape["a" /* default */])(channels.x.definition.scale), \n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                yScale: Object(convertScaleToDataUIScaleShape["a" /* default */])(channels.y.definition.scale) },\n                layout.renderXAxis(),\n                layout.renderYAxis(),\n                react_default.a.createElement(BoxPlotSeries_BoxPlotSeries, { key: Object(ChannelDef["a" /* isFieldDef */])(channels.x.definition) ? channels.x.definition.field : \'\', animated: true, data: isHorizontal\n                        ? data.map(row => (Object.assign(Object.assign({}, row), { y: channels.y.getValueFromDatum(row) })))\n                        : data.map(row => (Object.assign(Object.assign({}, row), { x: channels.x.getValueFromDatum(row) }))), fill: (datum) => channels.color.encodeDatum(datum, \'#55acee\'), fillOpacity: 0.4, stroke: (datum) => channels.color.encodeDatum(datum), strokeWidth: 1, widthRatio: 0.6, horizontal: isHorizontal }))));\n        };\n    }\n    render() {\n        const { className, data, encoding, width, height } = this.props;\n        return (react_default.a.createElement(WithLegend["a" /* default */], { className: `superset-chart-box-plot ${className}`, width: width, height: height, position: "top", renderLegend: Object(createRenderLegend["a" /* default */])(this.createEncoder(encoding), data, this.props), renderChart: this.renderChart }));\n    }\n}\nBoxPlot_BoxPlot.defaultProps = BoxPlot_defaultProps;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQ5NC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0B2eC9zdGF0cy9ub2RlX21vZHVsZXMvQHZ4L2dyb3VwL2Rpc3QvdngtZ3JvdXAuZXMuanM/YzlmMCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9Adngvc3RhdHMvbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9pbml0LmpzPzc5OGUiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L3N0YXRzL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvYXJyYXkuanM/ZDIyNyIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9Adngvc3RhdHMvbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9vcmRpbmFsLmpzP2M2N2EiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L3N0YXRzL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvYmFuZC5qcz83ODE2Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0B2eC9zdGF0cy9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL2NvbnN0YW50LmpzPzI4MTciLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L3N0YXRzL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvbnVtYmVyLmpzPzk3NmQiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L3N0YXRzL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvY29udGludW91cy5qcz8zMGUxIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0B2eC9zdGF0cy9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL3RpY2tGb3JtYXQuanM/ZjJiMCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9Adngvc3RhdHMvbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9saW5lYXIuanM/ODlkZCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9Adngvc3RhdHMvbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9pZGVudGl0eS5qcz85ZGRkIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0B2eC9zdGF0cy9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL25pY2UuanM/YzkzMCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9Adngvc3RhdHMvbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9sb2cuanM/MDQ0ZCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9Adngvc3RhdHMvbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9zeW1sb2cuanM/MzY1NSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9Adngvc3RhdHMvbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9wb3cuanM/ODEzZCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9Adngvc3RhdHMvbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9xdWFudGlsZS5qcz80MzI1Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0B2eC9zdGF0cy9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL3F1YW50aXplLmpzP2MxYTkiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L3N0YXRzL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvdGhyZXNob2xkLmpzPzFhNjciLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L3N0YXRzL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvdGltZS5qcz80YWVkIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0B2eC9zdGF0cy9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL3V0Y1RpbWUuanM/ODU5YiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9Adngvc3RhdHMvbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9zZXF1ZW50aWFsLmpzP2M2M2IiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L3N0YXRzL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvc2VxdWVudGlhbFF1YW50aWxlLmpzPzQ4MTYiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L3N0YXRzL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvZGl2ZXJnaW5nLmpzPzI1ODMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L3N0YXRzL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvaW5kZXguanM/N2I4MyIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9Adngvc3RhdHMvbm9kZV9tb2R1bGVzL0B2eC9zY2FsZS9kaXN0L3Z4LXNjYWxlLmVzLmpzPzcxYzYiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L3N0YXRzL2Rpc3Qvdngtc3RhdHMuZXMuanM/YmRiNSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS94eS1jaGFydC9lc20vc2VyaWVzL0JveFBsb3RTZXJpZXMuanM/NTQ2YiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvcHJlc2V0LWNoYXJ0LXh5L3NyYy9jb21wb25lbnRzL0JveFBsb3QvRGVmYXVsdFRvb2x0aXBSZW5kZXJlci50c3g/ZWViNiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvcHJlc2V0LWNoYXJ0LXh5L3NyYy9jb21wb25lbnRzL0JveFBsb3QvRW5jb2Rlci50cz9iYzFiIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wcmVzZXQtY2hhcnQteHkvc3JjL2NvbXBvbmVudHMvQm94UGxvdC9Cb3hQbG90LnRzeD82Y2M5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY3ggZnJvbSAnY2xhc3NuYW1lcyc7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG52YXIgb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgPSBmdW5jdGlvbiAob2JqLCBrZXlzKSB7XG4gIHZhciB0YXJnZXQgPSB7fTtcblxuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7XG4gICAgdGFyZ2V0W2ldID0gb2JqW2ldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbmZ1bmN0aW9uIEdyb3VwKF9yZWYpIHtcbiAgdmFyIF9yZWYkdG9wID0gX3JlZi50b3AsXG4gICAgICB0b3AgPSBfcmVmJHRvcCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkdG9wLFxuICAgICAgX3JlZiRsZWZ0ID0gX3JlZi5sZWZ0LFxuICAgICAgbGVmdCA9IF9yZWYkbGVmdCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkbGVmdCxcbiAgICAgIHRyYW5zZm9ybSA9IF9yZWYudHJhbnNmb3JtLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ3RvcCcsICdsZWZ0JywgJ3RyYW5zZm9ybScsICdjbGFzc05hbWUnLCAnY2hpbGRyZW4nXSk7XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgJ2cnLFxuICAgIF9leHRlbmRzKHtcbiAgICAgIGNsYXNzTmFtZTogY3goJ2N4LWdyb3VwJywgY2xhc3NOYW1lKSxcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtIHx8ICd0cmFuc2xhdGUoJyArIGxlZnQgKyAnLCAnICsgdG9wICsgJyknXG4gICAgfSwgcmVzdFByb3BzKSxcbiAgICBjaGlsZHJlblxuICApO1xufVxuXG5leHBvcnQgeyBHcm91cCB9O1xuIiwiZXhwb3J0IGZ1bmN0aW9uIGluaXRSYW5nZShkb21haW4sIHJhbmdlKSB7XG4gIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogYnJlYWs7XG4gICAgY2FzZSAxOiB0aGlzLnJhbmdlKGRvbWFpbik7IGJyZWFrO1xuICAgIGRlZmF1bHQ6IHRoaXMucmFuZ2UocmFuZ2UpLmRvbWFpbihkb21haW4pOyBicmVhaztcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXRJbnRlcnBvbGF0b3IoZG9tYWluLCBpbnRlcnBvbGF0b3IpIHtcbiAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiBicmVhaztcbiAgICBjYXNlIDE6IHRoaXMuaW50ZXJwb2xhdG9yKGRvbWFpbik7IGJyZWFrO1xuICAgIGRlZmF1bHQ6IHRoaXMuaW50ZXJwb2xhdG9yKGludGVycG9sYXRvcikuZG9tYWluKGRvbWFpbik7IGJyZWFrO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuIiwidmFyIGFycmF5ID0gQXJyYXkucHJvdG90eXBlO1xuXG5leHBvcnQgdmFyIG1hcCA9IGFycmF5Lm1hcDtcbmV4cG9ydCB2YXIgc2xpY2UgPSBhcnJheS5zbGljZTtcbiIsImltcG9ydCB7bWFwfSBmcm9tIFwiZDMtY29sbGVjdGlvblwiO1xuaW1wb3J0IHtzbGljZX0gZnJvbSBcIi4vYXJyYXlcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0XCI7XG5cbmV4cG9ydCB2YXIgaW1wbGljaXQgPSB7bmFtZTogXCJpbXBsaWNpdFwifTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gb3JkaW5hbCgpIHtcbiAgdmFyIGluZGV4ID0gbWFwKCksXG4gICAgICBkb21haW4gPSBbXSxcbiAgICAgIHJhbmdlID0gW10sXG4gICAgICB1bmtub3duID0gaW1wbGljaXQ7XG5cbiAgZnVuY3Rpb24gc2NhbGUoZCkge1xuICAgIHZhciBrZXkgPSBkICsgXCJcIiwgaSA9IGluZGV4LmdldChrZXkpO1xuICAgIGlmICghaSkge1xuICAgICAgaWYgKHVua25vd24gIT09IGltcGxpY2l0KSByZXR1cm4gdW5rbm93bjtcbiAgICAgIGluZGV4LnNldChrZXksIGkgPSBkb21haW4ucHVzaChkKSk7XG4gICAgfVxuICAgIHJldHVybiByYW5nZVsoaSAtIDEpICUgcmFuZ2UubGVuZ3RoXTtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkb21haW4uc2xpY2UoKTtcbiAgICBkb21haW4gPSBbXSwgaW5kZXggPSBtYXAoKTtcbiAgICB2YXIgaSA9IC0xLCBuID0gXy5sZW5ndGgsIGQsIGtleTtcbiAgICB3aGlsZSAoKytpIDwgbikgaWYgKCFpbmRleC5oYXMoa2V5ID0gKGQgPSBfW2ldKSArIFwiXCIpKSBpbmRleC5zZXQoa2V5LCBkb21haW4ucHVzaChkKSk7XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmdlID0gc2xpY2UuY2FsbChfKSwgc2NhbGUpIDogcmFuZ2Uuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS51bmtub3duID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHVua25vd24gPSBfLCBzY2FsZSkgOiB1bmtub3duO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gb3JkaW5hbChkb21haW4sIHJhbmdlKS51bmtub3duKHVua25vd24pO1xuICB9O1xuXG4gIGluaXRSYW5nZS5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcblxuICByZXR1cm4gc2NhbGU7XG59XG4iLCJpbXBvcnQge3JhbmdlIGFzIHNlcXVlbmNlfSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0XCI7XG5pbXBvcnQgb3JkaW5hbCBmcm9tIFwiLi9vcmRpbmFsXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJhbmQoKSB7XG4gIHZhciBzY2FsZSA9IG9yZGluYWwoKS51bmtub3duKHVuZGVmaW5lZCksXG4gICAgICBkb21haW4gPSBzY2FsZS5kb21haW4sXG4gICAgICBvcmRpbmFsUmFuZ2UgPSBzY2FsZS5yYW5nZSxcbiAgICAgIHJhbmdlID0gWzAsIDFdLFxuICAgICAgc3RlcCxcbiAgICAgIGJhbmR3aWR0aCxcbiAgICAgIHJvdW5kID0gZmFsc2UsXG4gICAgICBwYWRkaW5nSW5uZXIgPSAwLFxuICAgICAgcGFkZGluZ091dGVyID0gMCxcbiAgICAgIGFsaWduID0gMC41O1xuXG4gIGRlbGV0ZSBzY2FsZS51bmtub3duO1xuXG4gIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgdmFyIG4gPSBkb21haW4oKS5sZW5ndGgsXG4gICAgICAgIHJldmVyc2UgPSByYW5nZVsxXSA8IHJhbmdlWzBdLFxuICAgICAgICBzdGFydCA9IHJhbmdlW3JldmVyc2UgLSAwXSxcbiAgICAgICAgc3RvcCA9IHJhbmdlWzEgLSByZXZlcnNlXTtcbiAgICBzdGVwID0gKHN0b3AgLSBzdGFydCkgLyBNYXRoLm1heCgxLCBuIC0gcGFkZGluZ0lubmVyICsgcGFkZGluZ091dGVyICogMik7XG4gICAgaWYgKHJvdW5kKSBzdGVwID0gTWF0aC5mbG9vcihzdGVwKTtcbiAgICBzdGFydCArPSAoc3RvcCAtIHN0YXJ0IC0gc3RlcCAqIChuIC0gcGFkZGluZ0lubmVyKSkgKiBhbGlnbjtcbiAgICBiYW5kd2lkdGggPSBzdGVwICogKDEgLSBwYWRkaW5nSW5uZXIpO1xuICAgIGlmIChyb3VuZCkgc3RhcnQgPSBNYXRoLnJvdW5kKHN0YXJ0KSwgYmFuZHdpZHRoID0gTWF0aC5yb3VuZChiYW5kd2lkdGgpO1xuICAgIHZhciB2YWx1ZXMgPSBzZXF1ZW5jZShuKS5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gc3RhcnQgKyBzdGVwICogaTsgfSk7XG4gICAgcmV0dXJuIG9yZGluYWxSYW5nZShyZXZlcnNlID8gdmFsdWVzLnJldmVyc2UoKSA6IHZhbHVlcyk7XG4gIH1cblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZG9tYWluKF8pLCByZXNjYWxlKCkpIDogZG9tYWluKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFuZ2UgPSBbK19bMF0sICtfWzFdXSwgcmVzY2FsZSgpKSA6IHJhbmdlLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2VSb3VuZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gcmFuZ2UgPSBbK19bMF0sICtfWzFdXSwgcm91bmQgPSB0cnVlLCByZXNjYWxlKCk7XG4gIH07XG5cbiAgc2NhbGUuYmFuZHdpZHRoID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGJhbmR3aWR0aDtcbiAgfTtcblxuICBzY2FsZS5zdGVwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHN0ZXA7XG4gIH07XG5cbiAgc2NhbGUucm91bmQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocm91bmQgPSAhIV8sIHJlc2NhbGUoKSkgOiByb3VuZDtcbiAgfTtcblxuICBzY2FsZS5wYWRkaW5nID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmdJbm5lciA9IE1hdGgubWluKDEsIHBhZGRpbmdPdXRlciA9ICtfKSwgcmVzY2FsZSgpKSA6IHBhZGRpbmdJbm5lcjtcbiAgfTtcblxuICBzY2FsZS5wYWRkaW5nSW5uZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ0lubmVyID0gTWF0aC5taW4oMSwgXyksIHJlc2NhbGUoKSkgOiBwYWRkaW5nSW5uZXI7XG4gIH07XG5cbiAgc2NhbGUucGFkZGluZ091dGVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmdPdXRlciA9ICtfLCByZXNjYWxlKCkpIDogcGFkZGluZ091dGVyO1xuICB9O1xuXG4gIHNjYWxlLmFsaWduID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGFsaWduID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgXykpLCByZXNjYWxlKCkpIDogYWxpZ247XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBiYW5kKGRvbWFpbigpLCByYW5nZSlcbiAgICAgICAgLnJvdW5kKHJvdW5kKVxuICAgICAgICAucGFkZGluZ0lubmVyKHBhZGRpbmdJbm5lcilcbiAgICAgICAgLnBhZGRpbmdPdXRlcihwYWRkaW5nT3V0ZXIpXG4gICAgICAgIC5hbGlnbihhbGlnbik7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRSYW5nZS5hcHBseShyZXNjYWxlKCksIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIHBvaW50aXNoKHNjYWxlKSB7XG4gIHZhciBjb3B5ID0gc2NhbGUuY29weTtcblxuICBzY2FsZS5wYWRkaW5nID0gc2NhbGUucGFkZGluZ091dGVyO1xuICBkZWxldGUgc2NhbGUucGFkZGluZ0lubmVyO1xuICBkZWxldGUgc2NhbGUucGFkZGluZ091dGVyO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcG9pbnRpc2goY29weSgpKTtcbiAgfTtcblxuICByZXR1cm4gc2NhbGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb2ludCgpIHtcbiAgcmV0dXJuIHBvaW50aXNoKGJhbmQuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5wYWRkaW5nSW5uZXIoMSkpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiAreDtcbn1cbiIsImltcG9ydCB7YmlzZWN0fSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7aW50ZXJwb2xhdGUgYXMgaW50ZXJwb2xhdGVWYWx1ZSwgaW50ZXJwb2xhdGVOdW1iZXIsIGludGVycG9sYXRlUm91bmR9IGZyb20gXCJkMy1pbnRlcnBvbGF0ZVwiO1xuaW1wb3J0IHttYXAsIHNsaWNlfSBmcm9tIFwiLi9hcnJheVwiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50XCI7XG5pbXBvcnQgbnVtYmVyIGZyb20gXCIuL251bWJlclwiO1xuXG52YXIgdW5pdCA9IFswLCAxXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlkZW50aXR5KHgpIHtcbiAgcmV0dXJuIHg7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZShhLCBiKSB7XG4gIHJldHVybiAoYiAtPSAoYSA9ICthKSlcbiAgICAgID8gZnVuY3Rpb24oeCkgeyByZXR1cm4gKHggLSBhKSAvIGI7IH1cbiAgICAgIDogY29uc3RhbnQoaXNOYU4oYikgPyBOYU4gOiAwLjUpO1xufVxuXG5mdW5jdGlvbiBjbGFtcGVyKGRvbWFpbikge1xuICB2YXIgYSA9IGRvbWFpblswXSwgYiA9IGRvbWFpbltkb21haW4ubGVuZ3RoIC0gMV0sIHQ7XG4gIGlmIChhID4gYikgdCA9IGEsIGEgPSBiLCBiID0gdDtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgubWF4KGEsIE1hdGgubWluKGIsIHgpKTsgfTtcbn1cblxuLy8gbm9ybWFsaXplKGEsIGIpKHgpIHRha2VzIGEgZG9tYWluIHZhbHVlIHggaW4gW2EsYl0gYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGFyYW1ldGVyIHQgaW4gWzAsMV0uXG4vLyBpbnRlcnBvbGF0ZShhLCBiKSh0KSB0YWtlcyBhIHBhcmFtZXRlciB0IGluIFswLDFdIGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHJhbmdlIHZhbHVlIHggaW4gW2EsYl0uXG5mdW5jdGlvbiBiaW1hcChkb21haW4sIHJhbmdlLCBpbnRlcnBvbGF0ZSkge1xuICB2YXIgZDAgPSBkb21haW5bMF0sIGQxID0gZG9tYWluWzFdLCByMCA9IHJhbmdlWzBdLCByMSA9IHJhbmdlWzFdO1xuICBpZiAoZDEgPCBkMCkgZDAgPSBub3JtYWxpemUoZDEsIGQwKSwgcjAgPSBpbnRlcnBvbGF0ZShyMSwgcjApO1xuICBlbHNlIGQwID0gbm9ybWFsaXplKGQwLCBkMSksIHIwID0gaW50ZXJwb2xhdGUocjAsIHIxKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHIwKGQwKHgpKTsgfTtcbn1cblxuZnVuY3Rpb24gcG9seW1hcChkb21haW4sIHJhbmdlLCBpbnRlcnBvbGF0ZSkge1xuICB2YXIgaiA9IE1hdGgubWluKGRvbWFpbi5sZW5ndGgsIHJhbmdlLmxlbmd0aCkgLSAxLFxuICAgICAgZCA9IG5ldyBBcnJheShqKSxcbiAgICAgIHIgPSBuZXcgQXJyYXkoaiksXG4gICAgICBpID0gLTE7XG5cbiAgLy8gUmV2ZXJzZSBkZXNjZW5kaW5nIGRvbWFpbnMuXG4gIGlmIChkb21haW5bal0gPCBkb21haW5bMF0pIHtcbiAgICBkb21haW4gPSBkb21haW4uc2xpY2UoKS5yZXZlcnNlKCk7XG4gICAgcmFuZ2UgPSByYW5nZS5zbGljZSgpLnJldmVyc2UoKTtcbiAgfVxuXG4gIHdoaWxlICgrK2kgPCBqKSB7XG4gICAgZFtpXSA9IG5vcm1hbGl6ZShkb21haW5baV0sIGRvbWFpbltpICsgMV0pO1xuICAgIHJbaV0gPSBpbnRlcnBvbGF0ZShyYW5nZVtpXSwgcmFuZ2VbaSArIDFdKTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgdmFyIGkgPSBiaXNlY3QoZG9tYWluLCB4LCAxLCBqKSAtIDE7XG4gICAgcmV0dXJuIHJbaV0oZFtpXSh4KSk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KHNvdXJjZSwgdGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXRcbiAgICAgIC5kb21haW4oc291cmNlLmRvbWFpbigpKVxuICAgICAgLnJhbmdlKHNvdXJjZS5yYW5nZSgpKVxuICAgICAgLmludGVycG9sYXRlKHNvdXJjZS5pbnRlcnBvbGF0ZSgpKVxuICAgICAgLmNsYW1wKHNvdXJjZS5jbGFtcCgpKVxuICAgICAgLnVua25vd24oc291cmNlLnVua25vd24oKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1lcigpIHtcbiAgdmFyIGRvbWFpbiA9IHVuaXQsXG4gICAgICByYW5nZSA9IHVuaXQsXG4gICAgICBpbnRlcnBvbGF0ZSA9IGludGVycG9sYXRlVmFsdWUsXG4gICAgICB0cmFuc2Zvcm0sXG4gICAgICB1bnRyYW5zZm9ybSxcbiAgICAgIHVua25vd24sXG4gICAgICBjbGFtcCA9IGlkZW50aXR5LFxuICAgICAgcGllY2V3aXNlLFxuICAgICAgb3V0cHV0LFxuICAgICAgaW5wdXQ7XG5cbiAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICBwaWVjZXdpc2UgPSBNYXRoLm1pbihkb21haW4ubGVuZ3RoLCByYW5nZS5sZW5ndGgpID4gMiA/IHBvbHltYXAgOiBiaW1hcDtcbiAgICBvdXRwdXQgPSBpbnB1dCA9IG51bGw7XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgIHJldHVybiBpc05hTih4ID0gK3gpID8gdW5rbm93biA6IChvdXRwdXQgfHwgKG91dHB1dCA9IHBpZWNld2lzZShkb21haW4ubWFwKHRyYW5zZm9ybSksIHJhbmdlLCBpbnRlcnBvbGF0ZSkpKSh0cmFuc2Zvcm0oY2xhbXAoeCkpKTtcbiAgfVxuXG4gIHNjYWxlLmludmVydCA9IGZ1bmN0aW9uKHkpIHtcbiAgICByZXR1cm4gY2xhbXAodW50cmFuc2Zvcm0oKGlucHV0IHx8IChpbnB1dCA9IHBpZWNld2lzZShyYW5nZSwgZG9tYWluLm1hcCh0cmFuc2Zvcm0pLCBpbnRlcnBvbGF0ZU51bWJlcikpKSh5KSkpO1xuICB9O1xuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4gPSBtYXAuY2FsbChfLCBudW1iZXIpLCBjbGFtcCA9PT0gaWRlbnRpdHkgfHwgKGNsYW1wID0gY2xhbXBlcihkb21haW4pKSwgcmVzY2FsZSgpKSA6IGRvbWFpbi5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmdlID0gc2xpY2UuY2FsbChfKSwgcmVzY2FsZSgpKSA6IHJhbmdlLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2VSb3VuZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gcmFuZ2UgPSBzbGljZS5jYWxsKF8pLCBpbnRlcnBvbGF0ZSA9IGludGVycG9sYXRlUm91bmQsIHJlc2NhbGUoKTtcbiAgfTtcblxuICBzY2FsZS5jbGFtcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjbGFtcCA9IF8gPyBjbGFtcGVyKGRvbWFpbikgOiBpZGVudGl0eSwgc2NhbGUpIDogY2xhbXAgIT09IGlkZW50aXR5O1xuICB9O1xuXG4gIHNjYWxlLmludGVycG9sYXRlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGludGVycG9sYXRlID0gXywgcmVzY2FsZSgpKSA6IGludGVycG9sYXRlO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHQsIHUpIHtcbiAgICB0cmFuc2Zvcm0gPSB0LCB1bnRyYW5zZm9ybSA9IHU7XG4gICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29udGludW91cyh0cmFuc2Zvcm0sIHVudHJhbnNmb3JtKSB7XG4gIHJldHVybiB0cmFuc2Zvcm1lcigpKHRyYW5zZm9ybSwgdW50cmFuc2Zvcm0pO1xufVxuIiwiaW1wb3J0IHt0aWNrU3RlcH0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge2Zvcm1hdCwgZm9ybWF0UHJlZml4LCBmb3JtYXRTcGVjaWZpZXIsIHByZWNpc2lvbkZpeGVkLCBwcmVjaXNpb25QcmVmaXgsIHByZWNpc2lvblJvdW5kfSBmcm9tIFwiZDMtZm9ybWF0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBjb3VudCwgc3BlY2lmaWVyKSB7XG4gIHZhciBzdGVwID0gdGlja1N0ZXAoc3RhcnQsIHN0b3AsIGNvdW50KSxcbiAgICAgIHByZWNpc2lvbjtcbiAgc3BlY2lmaWVyID0gZm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllciA9PSBudWxsID8gXCIsZlwiIDogc3BlY2lmaWVyKTtcbiAgc3dpdGNoIChzcGVjaWZpZXIudHlwZSkge1xuICAgIGNhc2UgXCJzXCI6IHtcbiAgICAgIHZhciB2YWx1ZSA9IE1hdGgubWF4KE1hdGguYWJzKHN0YXJ0KSwgTWF0aC5hYnMoc3RvcCkpO1xuICAgICAgaWYgKHNwZWNpZmllci5wcmVjaXNpb24gPT0gbnVsbCAmJiAhaXNOYU4ocHJlY2lzaW9uID0gcHJlY2lzaW9uUHJlZml4KHN0ZXAsIHZhbHVlKSkpIHNwZWNpZmllci5wcmVjaXNpb24gPSBwcmVjaXNpb247XG4gICAgICByZXR1cm4gZm9ybWF0UHJlZml4KHNwZWNpZmllciwgdmFsdWUpO1xuICAgIH1cbiAgICBjYXNlIFwiXCI6XG4gICAgY2FzZSBcImVcIjpcbiAgICBjYXNlIFwiZ1wiOlxuICAgIGNhc2UgXCJwXCI6XG4gICAgY2FzZSBcInJcIjoge1xuICAgICAgaWYgKHNwZWNpZmllci5wcmVjaXNpb24gPT0gbnVsbCAmJiAhaXNOYU4ocHJlY2lzaW9uID0gcHJlY2lzaW9uUm91bmQoc3RlcCwgTWF0aC5tYXgoTWF0aC5hYnMoc3RhcnQpLCBNYXRoLmFicyhzdG9wKSkpKSkgc3BlY2lmaWVyLnByZWNpc2lvbiA9IHByZWNpc2lvbiAtIChzcGVjaWZpZXIudHlwZSA9PT0gXCJlXCIpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJmXCI6XG4gICAgY2FzZSBcIiVcIjoge1xuICAgICAgaWYgKHNwZWNpZmllci5wcmVjaXNpb24gPT0gbnVsbCAmJiAhaXNOYU4ocHJlY2lzaW9uID0gcHJlY2lzaW9uRml4ZWQoc3RlcCkpKSBzcGVjaWZpZXIucHJlY2lzaW9uID0gcHJlY2lzaW9uIC0gKHNwZWNpZmllci50eXBlID09PSBcIiVcIikgKiAyO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBmb3JtYXQoc3BlY2lmaWVyKTtcbn1cbiIsImltcG9ydCB7dGlja3MsIHRpY2tJbmNyZW1lbnR9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IGNvbnRpbnVvdXMsIHtjb3B5LCBpZGVudGl0eX0gZnJvbSBcIi4vY29udGludW91c1wiO1xuaW1wb3J0IHtpbml0UmFuZ2V9IGZyb20gXCIuL2luaXRcIjtcbmltcG9ydCB0aWNrRm9ybWF0IGZyb20gXCIuL3RpY2tGb3JtYXRcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhcmlzaChzY2FsZSkge1xuICB2YXIgZG9tYWluID0gc2NhbGUuZG9tYWluO1xuXG4gIHNjYWxlLnRpY2tzID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICB2YXIgZCA9IGRvbWFpbigpO1xuICAgIHJldHVybiB0aWNrcyhkWzBdLCBkW2QubGVuZ3RoIC0gMV0sIGNvdW50ID09IG51bGwgPyAxMCA6IGNvdW50KTtcbiAgfTtcblxuICBzY2FsZS50aWNrRm9ybWF0ID0gZnVuY3Rpb24oY291bnQsIHNwZWNpZmllcikge1xuICAgIHZhciBkID0gZG9tYWluKCk7XG4gICAgcmV0dXJuIHRpY2tGb3JtYXQoZFswXSwgZFtkLmxlbmd0aCAtIDFdLCBjb3VudCA9PSBudWxsID8gMTAgOiBjb3VudCwgc3BlY2lmaWVyKTtcbiAgfTtcblxuICBzY2FsZS5uaWNlID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICBpZiAoY291bnQgPT0gbnVsbCkgY291bnQgPSAxMDtcblxuICAgIHZhciBkID0gZG9tYWluKCksXG4gICAgICAgIGkwID0gMCxcbiAgICAgICAgaTEgPSBkLmxlbmd0aCAtIDEsXG4gICAgICAgIHN0YXJ0ID0gZFtpMF0sXG4gICAgICAgIHN0b3AgPSBkW2kxXSxcbiAgICAgICAgc3RlcDtcblxuICAgIGlmIChzdG9wIDwgc3RhcnQpIHtcbiAgICAgIHN0ZXAgPSBzdGFydCwgc3RhcnQgPSBzdG9wLCBzdG9wID0gc3RlcDtcbiAgICAgIHN0ZXAgPSBpMCwgaTAgPSBpMSwgaTEgPSBzdGVwO1xuICAgIH1cblxuICAgIHN0ZXAgPSB0aWNrSW5jcmVtZW50KHN0YXJ0LCBzdG9wLCBjb3VudCk7XG5cbiAgICBpZiAoc3RlcCA+IDApIHtcbiAgICAgIHN0YXJ0ID0gTWF0aC5mbG9vcihzdGFydCAvIHN0ZXApICogc3RlcDtcbiAgICAgIHN0b3AgPSBNYXRoLmNlaWwoc3RvcCAvIHN0ZXApICogc3RlcDtcbiAgICAgIHN0ZXAgPSB0aWNrSW5jcmVtZW50KHN0YXJ0LCBzdG9wLCBjb3VudCk7XG4gICAgfSBlbHNlIGlmIChzdGVwIDwgMCkge1xuICAgICAgc3RhcnQgPSBNYXRoLmNlaWwoc3RhcnQgKiBzdGVwKSAvIHN0ZXA7XG4gICAgICBzdG9wID0gTWF0aC5mbG9vcihzdG9wICogc3RlcCkgLyBzdGVwO1xuICAgICAgc3RlcCA9IHRpY2tJbmNyZW1lbnQoc3RhcnQsIHN0b3AsIGNvdW50KTtcbiAgICB9XG5cbiAgICBpZiAoc3RlcCA+IDApIHtcbiAgICAgIGRbaTBdID0gTWF0aC5mbG9vcihzdGFydCAvIHN0ZXApICogc3RlcDtcbiAgICAgIGRbaTFdID0gTWF0aC5jZWlsKHN0b3AgLyBzdGVwKSAqIHN0ZXA7XG4gICAgICBkb21haW4oZCk7XG4gICAgfSBlbHNlIGlmIChzdGVwIDwgMCkge1xuICAgICAgZFtpMF0gPSBNYXRoLmNlaWwoc3RhcnQgKiBzdGVwKSAvIHN0ZXA7XG4gICAgICBkW2kxXSA9IE1hdGguZmxvb3Ioc3RvcCAqIHN0ZXApIC8gc3RlcDtcbiAgICAgIGRvbWFpbihkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2NhbGU7XG4gIH07XG5cbiAgcmV0dXJuIHNjYWxlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsaW5lYXIoKSB7XG4gIHZhciBzY2FsZSA9IGNvbnRpbnVvdXMoaWRlbnRpdHksIGlkZW50aXR5KTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIGxpbmVhcigpKTtcbiAgfTtcblxuICBpbml0UmFuZ2UuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG5cbiAgcmV0dXJuIGxpbmVhcmlzaChzY2FsZSk7XG59XG4iLCJpbXBvcnQge21hcH0gZnJvbSBcIi4vYXJyYXlcIjtcbmltcG9ydCB7bGluZWFyaXNofSBmcm9tIFwiLi9saW5lYXJcIjtcbmltcG9ydCBudW1iZXIgZnJvbSBcIi4vbnVtYmVyXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlkZW50aXR5KGRvbWFpbikge1xuICB2YXIgdW5rbm93bjtcblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgcmV0dXJuIGlzTmFOKHggPSAreCkgPyB1bmtub3duIDogeDtcbiAgfVxuXG4gIHNjYWxlLmludmVydCA9IHNjYWxlO1xuXG4gIHNjYWxlLmRvbWFpbiA9IHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRvbWFpbiA9IG1hcC5jYWxsKF8sIG51bWJlciksIHNjYWxlKSA6IGRvbWFpbi5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpZGVudGl0eShkb21haW4pLnVua25vd24odW5rbm93bik7XG4gIH07XG5cbiAgZG9tYWluID0gYXJndW1lbnRzLmxlbmd0aCA/IG1hcC5jYWxsKGRvbWFpbiwgbnVtYmVyKSA6IFswLCAxXTtcblxuICByZXR1cm4gbGluZWFyaXNoKHNjYWxlKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGRvbWFpbiwgaW50ZXJ2YWwpIHtcbiAgZG9tYWluID0gZG9tYWluLnNsaWNlKCk7XG5cbiAgdmFyIGkwID0gMCxcbiAgICAgIGkxID0gZG9tYWluLmxlbmd0aCAtIDEsXG4gICAgICB4MCA9IGRvbWFpbltpMF0sXG4gICAgICB4MSA9IGRvbWFpbltpMV0sXG4gICAgICB0O1xuXG4gIGlmICh4MSA8IHgwKSB7XG4gICAgdCA9IGkwLCBpMCA9IGkxLCBpMSA9IHQ7XG4gICAgdCA9IHgwLCB4MCA9IHgxLCB4MSA9IHQ7XG4gIH1cblxuICBkb21haW5baTBdID0gaW50ZXJ2YWwuZmxvb3IoeDApO1xuICBkb21haW5baTFdID0gaW50ZXJ2YWwuY2VpbCh4MSk7XG4gIHJldHVybiBkb21haW47XG59XG4iLCJpbXBvcnQge3RpY2tzfSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7Zm9ybWF0fSBmcm9tIFwiZDMtZm9ybWF0XCI7XG5pbXBvcnQgbmljZSBmcm9tIFwiLi9uaWNlXCI7XG5pbXBvcnQge2NvcHksIHRyYW5zZm9ybWVyfSBmcm9tIFwiLi9jb250aW51b3VzXCI7XG5pbXBvcnQge2luaXRSYW5nZX0gZnJvbSBcIi4vaW5pdFwiO1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Mb2coeCkge1xuICByZXR1cm4gTWF0aC5sb2coeCk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybUV4cCh4KSB7XG4gIHJldHVybiBNYXRoLmV4cCh4KTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtTG9nbih4KSB7XG4gIHJldHVybiAtTWF0aC5sb2coLXgpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1FeHBuKHgpIHtcbiAgcmV0dXJuIC1NYXRoLmV4cCgteCk7XG59XG5cbmZ1bmN0aW9uIHBvdzEwKHgpIHtcbiAgcmV0dXJuIGlzRmluaXRlKHgpID8gKyhcIjFlXCIgKyB4KSA6IHggPCAwID8gMCA6IHg7XG59XG5cbmZ1bmN0aW9uIHBvd3AoYmFzZSkge1xuICByZXR1cm4gYmFzZSA9PT0gMTAgPyBwb3cxMFxuICAgICAgOiBiYXNlID09PSBNYXRoLkUgPyBNYXRoLmV4cFxuICAgICAgOiBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLnBvdyhiYXNlLCB4KTsgfTtcbn1cblxuZnVuY3Rpb24gbG9ncChiYXNlKSB7XG4gIHJldHVybiBiYXNlID09PSBNYXRoLkUgPyBNYXRoLmxvZ1xuICAgICAgOiBiYXNlID09PSAxMCAmJiBNYXRoLmxvZzEwXG4gICAgICB8fCBiYXNlID09PSAyICYmIE1hdGgubG9nMlxuICAgICAgfHwgKGJhc2UgPSBNYXRoLmxvZyhiYXNlKSwgZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5sb2coeCkgLyBiYXNlOyB9KTtcbn1cblxuZnVuY3Rpb24gcmVmbGVjdChmKSB7XG4gIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIC1mKC14KTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvZ2dpc2godHJhbnNmb3JtKSB7XG4gIHZhciBzY2FsZSA9IHRyYW5zZm9ybSh0cmFuc2Zvcm1Mb2csIHRyYW5zZm9ybUV4cCksXG4gICAgICBkb21haW4gPSBzY2FsZS5kb21haW4sXG4gICAgICBiYXNlID0gMTAsXG4gICAgICBsb2dzLFxuICAgICAgcG93cztcblxuICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgIGxvZ3MgPSBsb2dwKGJhc2UpLCBwb3dzID0gcG93cChiYXNlKTtcbiAgICBpZiAoZG9tYWluKClbMF0gPCAwKSB7XG4gICAgICBsb2dzID0gcmVmbGVjdChsb2dzKSwgcG93cyA9IHJlZmxlY3QocG93cyk7XG4gICAgICB0cmFuc2Zvcm0odHJhbnNmb3JtTG9nbiwgdHJhbnNmb3JtRXhwbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYW5zZm9ybSh0cmFuc2Zvcm1Mb2csIHRyYW5zZm9ybUV4cCk7XG4gICAgfVxuICAgIHJldHVybiBzY2FsZTtcbiAgfVxuXG4gIHNjYWxlLmJhc2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYmFzZSA9ICtfLCByZXNjYWxlKCkpIDogYmFzZTtcbiAgfTtcblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZG9tYWluKF8pLCByZXNjYWxlKCkpIDogZG9tYWluKCk7XG4gIH07XG5cbiAgc2NhbGUudGlja3MgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIHZhciBkID0gZG9tYWluKCksXG4gICAgICAgIHUgPSBkWzBdLFxuICAgICAgICB2ID0gZFtkLmxlbmd0aCAtIDFdLFxuICAgICAgICByO1xuXG4gICAgaWYgKHIgPSB2IDwgdSkgaSA9IHUsIHUgPSB2LCB2ID0gaTtcblxuICAgIHZhciBpID0gbG9ncyh1KSxcbiAgICAgICAgaiA9IGxvZ3ModiksXG4gICAgICAgIHAsXG4gICAgICAgIGssXG4gICAgICAgIHQsXG4gICAgICAgIG4gPSBjb3VudCA9PSBudWxsID8gMTAgOiArY291bnQsXG4gICAgICAgIHogPSBbXTtcblxuICAgIGlmICghKGJhc2UgJSAxKSAmJiBqIC0gaSA8IG4pIHtcbiAgICAgIGkgPSBNYXRoLnJvdW5kKGkpIC0gMSwgaiA9IE1hdGgucm91bmQoaikgKyAxO1xuICAgICAgaWYgKHUgPiAwKSBmb3IgKDsgaSA8IGo7ICsraSkge1xuICAgICAgICBmb3IgKGsgPSAxLCBwID0gcG93cyhpKTsgayA8IGJhc2U7ICsraykge1xuICAgICAgICAgIHQgPSBwICogaztcbiAgICAgICAgICBpZiAodCA8IHUpIGNvbnRpbnVlO1xuICAgICAgICAgIGlmICh0ID4gdikgYnJlYWs7XG4gICAgICAgICAgei5wdXNoKHQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgZm9yICg7IGkgPCBqOyArK2kpIHtcbiAgICAgICAgZm9yIChrID0gYmFzZSAtIDEsIHAgPSBwb3dzKGkpOyBrID49IDE7IC0taykge1xuICAgICAgICAgIHQgPSBwICogaztcbiAgICAgICAgICBpZiAodCA8IHUpIGNvbnRpbnVlO1xuICAgICAgICAgIGlmICh0ID4gdikgYnJlYWs7XG4gICAgICAgICAgei5wdXNoKHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHogPSB0aWNrcyhpLCBqLCBNYXRoLm1pbihqIC0gaSwgbikpLm1hcChwb3dzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gciA/IHoucmV2ZXJzZSgpIDogejtcbiAgfTtcblxuICBzY2FsZS50aWNrRm9ybWF0ID0gZnVuY3Rpb24oY291bnQsIHNwZWNpZmllcikge1xuICAgIGlmIChzcGVjaWZpZXIgPT0gbnVsbCkgc3BlY2lmaWVyID0gYmFzZSA9PT0gMTAgPyBcIi4wZVwiIDogXCIsXCI7XG4gICAgaWYgKHR5cGVvZiBzcGVjaWZpZXIgIT09IFwiZnVuY3Rpb25cIikgc3BlY2lmaWVyID0gZm9ybWF0KHNwZWNpZmllcik7XG4gICAgaWYgKGNvdW50ID09PSBJbmZpbml0eSkgcmV0dXJuIHNwZWNpZmllcjtcbiAgICBpZiAoY291bnQgPT0gbnVsbCkgY291bnQgPSAxMDtcbiAgICB2YXIgayA9IE1hdGgubWF4KDEsIGJhc2UgKiBjb3VudCAvIHNjYWxlLnRpY2tzKCkubGVuZ3RoKTsgLy8gVE9ETyBmYXN0IGVzdGltYXRlP1xuICAgIHJldHVybiBmdW5jdGlvbihkKSB7XG4gICAgICB2YXIgaSA9IGQgLyBwb3dzKE1hdGgucm91bmQobG9ncyhkKSkpO1xuICAgICAgaWYgKGkgKiBiYXNlIDwgYmFzZSAtIDAuNSkgaSAqPSBiYXNlO1xuICAgICAgcmV0dXJuIGkgPD0gayA/IHNwZWNpZmllcihkKSA6IFwiXCI7XG4gICAgfTtcbiAgfTtcblxuICBzY2FsZS5uaWNlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRvbWFpbihuaWNlKGRvbWFpbigpLCB7XG4gICAgICBmbG9vcjogZnVuY3Rpb24oeCkgeyByZXR1cm4gcG93cyhNYXRoLmZsb29yKGxvZ3MoeCkpKTsgfSxcbiAgICAgIGNlaWw6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHBvd3MoTWF0aC5jZWlsKGxvZ3MoeCkpKTsgfVxuICAgIH0pKTtcbiAgfTtcblxuICByZXR1cm4gc2NhbGU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxvZygpIHtcbiAgdmFyIHNjYWxlID0gbG9nZ2lzaCh0cmFuc2Zvcm1lcigpKS5kb21haW4oWzEsIDEwXSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBsb2coKSkuYmFzZShzY2FsZS5iYXNlKCkpO1xuICB9O1xuXG4gIGluaXRSYW5nZS5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcblxuICByZXR1cm4gc2NhbGU7XG59XG4iLCJpbXBvcnQge2xpbmVhcmlzaH0gZnJvbSBcIi4vbGluZWFyXCI7XG5pbXBvcnQge2NvcHksIHRyYW5zZm9ybWVyfSBmcm9tIFwiLi9jb250aW51b3VzXCI7XG5pbXBvcnQge2luaXRSYW5nZX0gZnJvbSBcIi4vaW5pdFwiO1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TeW1sb2coYykge1xuICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBNYXRoLnNpZ24oeCkgKiBNYXRoLmxvZzFwKE1hdGguYWJzKHggLyBjKSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN5bWV4cChjKSB7XG4gIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIE1hdGguc2lnbih4KSAqIE1hdGguZXhwbTEoTWF0aC5hYnMoeCkpICogYztcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN5bWxvZ2lzaCh0cmFuc2Zvcm0pIHtcbiAgdmFyIGMgPSAxLCBzY2FsZSA9IHRyYW5zZm9ybSh0cmFuc2Zvcm1TeW1sb2coYyksIHRyYW5zZm9ybVN5bWV4cChjKSk7XG5cbiAgc2NhbGUuY29uc3RhbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0cmFuc2Zvcm0odHJhbnNmb3JtU3ltbG9nKGMgPSArXyksIHRyYW5zZm9ybVN5bWV4cChjKSkgOiBjO1xuICB9O1xuXG4gIHJldHVybiBsaW5lYXJpc2goc2NhbGUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzeW1sb2coKSB7XG4gIHZhciBzY2FsZSA9IHN5bWxvZ2lzaCh0cmFuc2Zvcm1lcigpKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIHN5bWxvZygpKS5jb25zdGFudChzY2FsZS5jb25zdGFudCgpKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdFJhbmdlLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuIiwiaW1wb3J0IHtsaW5lYXJpc2h9IGZyb20gXCIuL2xpbmVhclwiO1xuaW1wb3J0IHtjb3B5LCBpZGVudGl0eSwgdHJhbnNmb3JtZXJ9IGZyb20gXCIuL2NvbnRpbnVvdXNcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0XCI7XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVBvdyhleHBvbmVudCkge1xuICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB4IDwgMCA/IC1NYXRoLnBvdygteCwgZXhwb25lbnQpIDogTWF0aC5wb3coeCwgZXhwb25lbnQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TcXJ0KHgpIHtcbiAgcmV0dXJuIHggPCAwID8gLU1hdGguc3FydCgteCkgOiBNYXRoLnNxcnQoeCk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVNxdWFyZSh4KSB7XG4gIHJldHVybiB4IDwgMCA/IC14ICogeCA6IHggKiB4O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG93aXNoKHRyYW5zZm9ybSkge1xuICB2YXIgc2NhbGUgPSB0cmFuc2Zvcm0oaWRlbnRpdHksIGlkZW50aXR5KSxcbiAgICAgIGV4cG9uZW50ID0gMTtcblxuICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgIHJldHVybiBleHBvbmVudCA9PT0gMSA/IHRyYW5zZm9ybShpZGVudGl0eSwgaWRlbnRpdHkpXG4gICAgICAgIDogZXhwb25lbnQgPT09IDAuNSA/IHRyYW5zZm9ybSh0cmFuc2Zvcm1TcXJ0LCB0cmFuc2Zvcm1TcXVhcmUpXG4gICAgICAgIDogdHJhbnNmb3JtKHRyYW5zZm9ybVBvdyhleHBvbmVudCksIHRyYW5zZm9ybVBvdygxIC8gZXhwb25lbnQpKTtcbiAgfVxuXG4gIHNjYWxlLmV4cG9uZW50ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGV4cG9uZW50ID0gK18sIHJlc2NhbGUoKSkgOiBleHBvbmVudDtcbiAgfTtcblxuICByZXR1cm4gbGluZWFyaXNoKHNjYWxlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcG93KCkge1xuICB2YXIgc2NhbGUgPSBwb3dpc2godHJhbnNmb3JtZXIoKSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBwb3coKSkuZXhwb25lbnQoc2NhbGUuZXhwb25lbnQoKSk7XG4gIH07XG5cbiAgaW5pdFJhbmdlLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xuXG4gIHJldHVybiBzY2FsZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNxcnQoKSB7XG4gIHJldHVybiBwb3cuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5leHBvbmVudCgwLjUpO1xufVxuIiwiaW1wb3J0IHthc2NlbmRpbmcsIGJpc2VjdCwgcXVhbnRpbGUgYXMgdGhyZXNob2xkfSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7c2xpY2V9IGZyb20gXCIuL2FycmF5XCI7XG5pbXBvcnQge2luaXRSYW5nZX0gZnJvbSBcIi4vaW5pdFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBxdWFudGlsZSgpIHtcbiAgdmFyIGRvbWFpbiA9IFtdLFxuICAgICAgcmFuZ2UgPSBbXSxcbiAgICAgIHRocmVzaG9sZHMgPSBbXSxcbiAgICAgIHVua25vd247XG5cbiAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICB2YXIgaSA9IDAsIG4gPSBNYXRoLm1heCgxLCByYW5nZS5sZW5ndGgpO1xuICAgIHRocmVzaG9sZHMgPSBuZXcgQXJyYXkobiAtIDEpO1xuICAgIHdoaWxlICgrK2kgPCBuKSB0aHJlc2hvbGRzW2kgLSAxXSA9IHRocmVzaG9sZChkb21haW4sIGkgLyBuKTtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH1cblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgcmV0dXJuIGlzTmFOKHggPSAreCkgPyB1bmtub3duIDogcmFuZ2VbYmlzZWN0KHRocmVzaG9sZHMsIHgpXTtcbiAgfVxuXG4gIHNjYWxlLmludmVydEV4dGVudCA9IGZ1bmN0aW9uKHkpIHtcbiAgICB2YXIgaSA9IHJhbmdlLmluZGV4T2YoeSk7XG4gICAgcmV0dXJuIGkgPCAwID8gW05hTiwgTmFOXSA6IFtcbiAgICAgIGkgPiAwID8gdGhyZXNob2xkc1tpIC0gMV0gOiBkb21haW5bMF0sXG4gICAgICBpIDwgdGhyZXNob2xkcy5sZW5ndGggPyB0aHJlc2hvbGRzW2ldIDogZG9tYWluW2RvbWFpbi5sZW5ndGggLSAxXVxuICAgIF07XG4gIH07XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbi5zbGljZSgpO1xuICAgIGRvbWFpbiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gXy5sZW5ndGgsIGQ7IGkgPCBuOyArK2kpIGlmIChkID0gX1tpXSwgZCAhPSBudWxsICYmICFpc05hTihkID0gK2QpKSBkb21haW4ucHVzaChkKTtcbiAgICBkb21haW4uc29ydChhc2NlbmRpbmcpO1xuICAgIHJldHVybiByZXNjYWxlKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFuZ2UgPSBzbGljZS5jYWxsKF8pLCByZXNjYWxlKCkpIDogcmFuZ2Uuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS51bmtub3duID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHVua25vd24gPSBfLCBzY2FsZSkgOiB1bmtub3duO1xuICB9O1xuXG4gIHNjYWxlLnF1YW50aWxlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aHJlc2hvbGRzLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBxdWFudGlsZSgpXG4gICAgICAgIC5kb21haW4oZG9tYWluKVxuICAgICAgICAucmFuZ2UocmFuZ2UpXG4gICAgICAgIC51bmtub3duKHVua25vd24pO1xuICB9O1xuXG4gIHJldHVybiBpbml0UmFuZ2UuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG4iLCJpbXBvcnQge2Jpc2VjdH0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge3NsaWNlfSBmcm9tIFwiLi9hcnJheVwiO1xuaW1wb3J0IHtsaW5lYXJpc2h9IGZyb20gXCIuL2xpbmVhclwiO1xuaW1wb3J0IHtpbml0UmFuZ2V9IGZyb20gXCIuL2luaXRcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcXVhbnRpemUoKSB7XG4gIHZhciB4MCA9IDAsXG4gICAgICB4MSA9IDEsXG4gICAgICBuID0gMSxcbiAgICAgIGRvbWFpbiA9IFswLjVdLFxuICAgICAgcmFuZ2UgPSBbMCwgMV0sXG4gICAgICB1bmtub3duO1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICByZXR1cm4geCA8PSB4ID8gcmFuZ2VbYmlzZWN0KGRvbWFpbiwgeCwgMCwgbildIDogdW5rbm93bjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgdmFyIGkgPSAtMTtcbiAgICBkb21haW4gPSBuZXcgQXJyYXkobik7XG4gICAgd2hpbGUgKCsraSA8IG4pIGRvbWFpbltpXSA9ICgoaSArIDEpICogeDEgLSAoaSAtIG4pICogeDApIC8gKG4gKyAxKTtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH1cblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeDAgPSArX1swXSwgeDEgPSArX1sxXSwgcmVzY2FsZSgpKSA6IFt4MCwgeDFdO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG4gPSAocmFuZ2UgPSBzbGljZS5jYWxsKF8pKS5sZW5ndGggLSAxLCByZXNjYWxlKCkpIDogcmFuZ2Uuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS5pbnZlcnRFeHRlbnQgPSBmdW5jdGlvbih5KSB7XG4gICAgdmFyIGkgPSByYW5nZS5pbmRleE9mKHkpO1xuICAgIHJldHVybiBpIDwgMCA/IFtOYU4sIE5hTl1cbiAgICAgICAgOiBpIDwgMSA/IFt4MCwgZG9tYWluWzBdXVxuICAgICAgICA6IGkgPj0gbiA/IFtkb21haW5bbiAtIDFdLCB4MV1cbiAgICAgICAgOiBbZG9tYWluW2kgLSAxXSwgZG9tYWluW2ldXTtcbiAgfTtcblxuICBzY2FsZS51bmtub3duID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHVua25vd24gPSBfLCBzY2FsZSkgOiBzY2FsZTtcbiAgfTtcblxuICBzY2FsZS50aHJlc2hvbGRzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRvbWFpbi5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcXVhbnRpemUoKVxuICAgICAgICAuZG9tYWluKFt4MCwgeDFdKVxuICAgICAgICAucmFuZ2UocmFuZ2UpXG4gICAgICAgIC51bmtub3duKHVua25vd24pO1xuICB9O1xuXG4gIHJldHVybiBpbml0UmFuZ2UuYXBwbHkobGluZWFyaXNoKHNjYWxlKSwgYXJndW1lbnRzKTtcbn1cbiIsImltcG9ydCB7YmlzZWN0fSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7c2xpY2V9IGZyb20gXCIuL2FycmF5XCI7XG5pbXBvcnQge2luaXRSYW5nZX0gZnJvbSBcIi4vaW5pdFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0aHJlc2hvbGQoKSB7XG4gIHZhciBkb21haW4gPSBbMC41XSxcbiAgICAgIHJhbmdlID0gWzAsIDFdLFxuICAgICAgdW5rbm93bixcbiAgICAgIG4gPSAxO1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICByZXR1cm4geCA8PSB4ID8gcmFuZ2VbYmlzZWN0KGRvbWFpbiwgeCwgMCwgbildIDogdW5rbm93bjtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4gPSBzbGljZS5jYWxsKF8pLCBuID0gTWF0aC5taW4oZG9tYWluLmxlbmd0aCwgcmFuZ2UubGVuZ3RoIC0gMSksIHNjYWxlKSA6IGRvbWFpbi5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmdlID0gc2xpY2UuY2FsbChfKSwgbiA9IE1hdGgubWluKGRvbWFpbi5sZW5ndGgsIHJhbmdlLmxlbmd0aCAtIDEpLCBzY2FsZSkgOiByYW5nZS5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLmludmVydEV4dGVudCA9IGZ1bmN0aW9uKHkpIHtcbiAgICB2YXIgaSA9IHJhbmdlLmluZGV4T2YoeSk7XG4gICAgcmV0dXJuIFtkb21haW5baSAtIDFdLCBkb21haW5baV1dO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aHJlc2hvbGQoKVxuICAgICAgICAuZG9tYWluKGRvbWFpbilcbiAgICAgICAgLnJhbmdlKHJhbmdlKVxuICAgICAgICAudW5rbm93bih1bmtub3duKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdFJhbmdlLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuIiwiaW1wb3J0IHtiaXNlY3RvciwgdGlja1N0ZXB9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHt0aW1lWWVhciwgdGltZU1vbnRoLCB0aW1lV2VlaywgdGltZURheSwgdGltZUhvdXIsIHRpbWVNaW51dGUsIHRpbWVTZWNvbmQsIHRpbWVNaWxsaXNlY29uZH0gZnJvbSBcImQzLXRpbWVcIjtcbmltcG9ydCB7dGltZUZvcm1hdH0gZnJvbSBcImQzLXRpbWUtZm9ybWF0XCI7XG5pbXBvcnQge21hcH0gZnJvbSBcIi4vYXJyYXlcIjtcbmltcG9ydCBjb250aW51b3VzLCB7Y29weSwgaWRlbnRpdHl9IGZyb20gXCIuL2NvbnRpbnVvdXNcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0XCI7XG5pbXBvcnQgbmljZSBmcm9tIFwiLi9uaWNlXCI7XG5cbnZhciBkdXJhdGlvblNlY29uZCA9IDEwMDAsXG4gICAgZHVyYXRpb25NaW51dGUgPSBkdXJhdGlvblNlY29uZCAqIDYwLFxuICAgIGR1cmF0aW9uSG91ciA9IGR1cmF0aW9uTWludXRlICogNjAsXG4gICAgZHVyYXRpb25EYXkgPSBkdXJhdGlvbkhvdXIgKiAyNCxcbiAgICBkdXJhdGlvbldlZWsgPSBkdXJhdGlvbkRheSAqIDcsXG4gICAgZHVyYXRpb25Nb250aCA9IGR1cmF0aW9uRGF5ICogMzAsXG4gICAgZHVyYXRpb25ZZWFyID0gZHVyYXRpb25EYXkgKiAzNjU7XG5cbmZ1bmN0aW9uIGRhdGUodCkge1xuICByZXR1cm4gbmV3IERhdGUodCk7XG59XG5cbmZ1bmN0aW9uIG51bWJlcih0KSB7XG4gIHJldHVybiB0IGluc3RhbmNlb2YgRGF0ZSA/ICt0IDogK25ldyBEYXRlKCt0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGVuZGFyKHllYXIsIG1vbnRoLCB3ZWVrLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgZm9ybWF0KSB7XG4gIHZhciBzY2FsZSA9IGNvbnRpbnVvdXMoaWRlbnRpdHksIGlkZW50aXR5KSxcbiAgICAgIGludmVydCA9IHNjYWxlLmludmVydCxcbiAgICAgIGRvbWFpbiA9IHNjYWxlLmRvbWFpbjtcblxuICB2YXIgZm9ybWF0TWlsbGlzZWNvbmQgPSBmb3JtYXQoXCIuJUxcIiksXG4gICAgICBmb3JtYXRTZWNvbmQgPSBmb3JtYXQoXCI6JVNcIiksXG4gICAgICBmb3JtYXRNaW51dGUgPSBmb3JtYXQoXCIlSTolTVwiKSxcbiAgICAgIGZvcm1hdEhvdXIgPSBmb3JtYXQoXCIlSSAlcFwiKSxcbiAgICAgIGZvcm1hdERheSA9IGZvcm1hdChcIiVhICVkXCIpLFxuICAgICAgZm9ybWF0V2VlayA9IGZvcm1hdChcIiViICVkXCIpLFxuICAgICAgZm9ybWF0TW9udGggPSBmb3JtYXQoXCIlQlwiKSxcbiAgICAgIGZvcm1hdFllYXIgPSBmb3JtYXQoXCIlWVwiKTtcblxuICB2YXIgdGlja0ludGVydmFscyA9IFtcbiAgICBbc2Vjb25kLCAgMSwgICAgICBkdXJhdGlvblNlY29uZF0sXG4gICAgW3NlY29uZCwgIDUsICA1ICogZHVyYXRpb25TZWNvbmRdLFxuICAgIFtzZWNvbmQsIDE1LCAxNSAqIGR1cmF0aW9uU2Vjb25kXSxcbiAgICBbc2Vjb25kLCAzMCwgMzAgKiBkdXJhdGlvblNlY29uZF0sXG4gICAgW21pbnV0ZSwgIDEsICAgICAgZHVyYXRpb25NaW51dGVdLFxuICAgIFttaW51dGUsICA1LCAgNSAqIGR1cmF0aW9uTWludXRlXSxcbiAgICBbbWludXRlLCAxNSwgMTUgKiBkdXJhdGlvbk1pbnV0ZV0sXG4gICAgW21pbnV0ZSwgMzAsIDMwICogZHVyYXRpb25NaW51dGVdLFxuICAgIFsgIGhvdXIsICAxLCAgICAgIGR1cmF0aW9uSG91ciAgXSxcbiAgICBbICBob3VyLCAgMywgIDMgKiBkdXJhdGlvbkhvdXIgIF0sXG4gICAgWyAgaG91ciwgIDYsICA2ICogZHVyYXRpb25Ib3VyICBdLFxuICAgIFsgIGhvdXIsIDEyLCAxMiAqIGR1cmF0aW9uSG91ciAgXSxcbiAgICBbICAgZGF5LCAgMSwgICAgICBkdXJhdGlvbkRheSAgIF0sXG4gICAgWyAgIGRheSwgIDIsICAyICogZHVyYXRpb25EYXkgICBdLFxuICAgIFsgIHdlZWssICAxLCAgICAgIGR1cmF0aW9uV2VlayAgXSxcbiAgICBbIG1vbnRoLCAgMSwgICAgICBkdXJhdGlvbk1vbnRoIF0sXG4gICAgWyBtb250aCwgIDMsICAzICogZHVyYXRpb25Nb250aCBdLFxuICAgIFsgIHllYXIsICAxLCAgICAgIGR1cmF0aW9uWWVhciAgXVxuICBdO1xuXG4gIGZ1bmN0aW9uIHRpY2tGb3JtYXQoZGF0ZSkge1xuICAgIHJldHVybiAoc2Vjb25kKGRhdGUpIDwgZGF0ZSA/IGZvcm1hdE1pbGxpc2Vjb25kXG4gICAgICAgIDogbWludXRlKGRhdGUpIDwgZGF0ZSA/IGZvcm1hdFNlY29uZFxuICAgICAgICA6IGhvdXIoZGF0ZSkgPCBkYXRlID8gZm9ybWF0TWludXRlXG4gICAgICAgIDogZGF5KGRhdGUpIDwgZGF0ZSA/IGZvcm1hdEhvdXJcbiAgICAgICAgOiBtb250aChkYXRlKSA8IGRhdGUgPyAod2VlayhkYXRlKSA8IGRhdGUgPyBmb3JtYXREYXkgOiBmb3JtYXRXZWVrKVxuICAgICAgICA6IHllYXIoZGF0ZSkgPCBkYXRlID8gZm9ybWF0TW9udGhcbiAgICAgICAgOiBmb3JtYXRZZWFyKShkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRpY2tJbnRlcnZhbChpbnRlcnZhbCwgc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICBpZiAoaW50ZXJ2YWwgPT0gbnVsbCkgaW50ZXJ2YWwgPSAxMDtcblxuICAgIC8vIElmIGEgZGVzaXJlZCB0aWNrIGNvdW50IGlzIHNwZWNpZmllZCwgcGljayBhIHJlYXNvbmFibGUgdGljayBpbnRlcnZhbFxuICAgIC8vIGJhc2VkIG9uIHRoZSBleHRlbnQgb2YgdGhlIGRvbWFpbiBhbmQgYSByb3VnaCBlc3RpbWF0ZSBvZiB0aWNrIHNpemUuXG4gICAgLy8gT3RoZXJ3aXNlLCBhc3N1bWUgaW50ZXJ2YWwgaXMgYWxyZWFkeSBhIHRpbWUgaW50ZXJ2YWwgYW5kIHVzZSBpdC5cbiAgICBpZiAodHlwZW9mIGludGVydmFsID09PSBcIm51bWJlclwiKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gTWF0aC5hYnMoc3RvcCAtIHN0YXJ0KSAvIGludGVydmFsLFxuICAgICAgICAgIGkgPSBiaXNlY3RvcihmdW5jdGlvbihpKSB7IHJldHVybiBpWzJdOyB9KS5yaWdodCh0aWNrSW50ZXJ2YWxzLCB0YXJnZXQpO1xuICAgICAgaWYgKGkgPT09IHRpY2tJbnRlcnZhbHMubGVuZ3RoKSB7XG4gICAgICAgIHN0ZXAgPSB0aWNrU3RlcChzdGFydCAvIGR1cmF0aW9uWWVhciwgc3RvcCAvIGR1cmF0aW9uWWVhciwgaW50ZXJ2YWwpO1xuICAgICAgICBpbnRlcnZhbCA9IHllYXI7XG4gICAgICB9IGVsc2UgaWYgKGkpIHtcbiAgICAgICAgaSA9IHRpY2tJbnRlcnZhbHNbdGFyZ2V0IC8gdGlja0ludGVydmFsc1tpIC0gMV1bMl0gPCB0aWNrSW50ZXJ2YWxzW2ldWzJdIC8gdGFyZ2V0ID8gaSAtIDEgOiBpXTtcbiAgICAgICAgc3RlcCA9IGlbMV07XG4gICAgICAgIGludGVydmFsID0gaVswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ZXAgPSBNYXRoLm1heCh0aWNrU3RlcChzdGFydCwgc3RvcCwgaW50ZXJ2YWwpLCAxKTtcbiAgICAgICAgaW50ZXJ2YWwgPSBtaWxsaXNlY29uZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3RlcCA9PSBudWxsID8gaW50ZXJ2YWwgOiBpbnRlcnZhbC5ldmVyeShzdGVwKTtcbiAgfVxuXG4gIHNjYWxlLmludmVydCA9IGZ1bmN0aW9uKHkpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoaW52ZXJ0KHkpKTtcbiAgfTtcblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBkb21haW4obWFwLmNhbGwoXywgbnVtYmVyKSkgOiBkb21haW4oKS5tYXAoZGF0ZSk7XG4gIH07XG5cbiAgc2NhbGUudGlja3MgPSBmdW5jdGlvbihpbnRlcnZhbCwgc3RlcCkge1xuICAgIHZhciBkID0gZG9tYWluKCksXG4gICAgICAgIHQwID0gZFswXSxcbiAgICAgICAgdDEgPSBkW2QubGVuZ3RoIC0gMV0sXG4gICAgICAgIHIgPSB0MSA8IHQwLFxuICAgICAgICB0O1xuICAgIGlmIChyKSB0ID0gdDAsIHQwID0gdDEsIHQxID0gdDtcbiAgICB0ID0gdGlja0ludGVydmFsKGludGVydmFsLCB0MCwgdDEsIHN0ZXApO1xuICAgIHQgPSB0ID8gdC5yYW5nZSh0MCwgdDEgKyAxKSA6IFtdOyAvLyBpbmNsdXNpdmUgc3RvcFxuICAgIHJldHVybiByID8gdC5yZXZlcnNlKCkgOiB0O1xuICB9O1xuXG4gIHNjYWxlLnRpY2tGb3JtYXQgPSBmdW5jdGlvbihjb3VudCwgc3BlY2lmaWVyKSB7XG4gICAgcmV0dXJuIHNwZWNpZmllciA9PSBudWxsID8gdGlja0Zvcm1hdCA6IGZvcm1hdChzcGVjaWZpZXIpO1xuICB9O1xuXG4gIHNjYWxlLm5pY2UgPSBmdW5jdGlvbihpbnRlcnZhbCwgc3RlcCkge1xuICAgIHZhciBkID0gZG9tYWluKCk7XG4gICAgcmV0dXJuIChpbnRlcnZhbCA9IHRpY2tJbnRlcnZhbChpbnRlcnZhbCwgZFswXSwgZFtkLmxlbmd0aCAtIDFdLCBzdGVwKSlcbiAgICAgICAgPyBkb21haW4obmljZShkLCBpbnRlcnZhbCkpXG4gICAgICAgIDogc2NhbGU7XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBjYWxlbmRhcih5ZWFyLCBtb250aCwgd2VlaywgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIGZvcm1hdCkpO1xuICB9O1xuXG4gIHJldHVybiBzY2FsZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBpbml0UmFuZ2UuYXBwbHkoY2FsZW5kYXIodGltZVllYXIsIHRpbWVNb250aCwgdGltZVdlZWssIHRpbWVEYXksIHRpbWVIb3VyLCB0aW1lTWludXRlLCB0aW1lU2Vjb25kLCB0aW1lTWlsbGlzZWNvbmQsIHRpbWVGb3JtYXQpLmRvbWFpbihbbmV3IERhdGUoMjAwMCwgMCwgMSksIG5ldyBEYXRlKDIwMDAsIDAsIDIpXSksIGFyZ3VtZW50cyk7XG59XG4iLCJpbXBvcnQge2NhbGVuZGFyfSBmcm9tIFwiLi90aW1lXCI7XG5pbXBvcnQge3V0Y0Zvcm1hdH0gZnJvbSBcImQzLXRpbWUtZm9ybWF0XCI7XG5pbXBvcnQge3V0Y1llYXIsIHV0Y01vbnRoLCB1dGNXZWVrLCB1dGNEYXksIHV0Y0hvdXIsIHV0Y01pbnV0ZSwgdXRjU2Vjb25kLCB1dGNNaWxsaXNlY29uZH0gZnJvbSBcImQzLXRpbWVcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gaW5pdFJhbmdlLmFwcGx5KGNhbGVuZGFyKHV0Y1llYXIsIHV0Y01vbnRoLCB1dGNXZWVrLCB1dGNEYXksIHV0Y0hvdXIsIHV0Y01pbnV0ZSwgdXRjU2Vjb25kLCB1dGNNaWxsaXNlY29uZCwgdXRjRm9ybWF0KS5kb21haW4oW0RhdGUuVVRDKDIwMDAsIDAsIDEpLCBEYXRlLlVUQygyMDAwLCAwLCAyKV0pLCBhcmd1bWVudHMpO1xufVxuIiwiaW1wb3J0IHtpZGVudGl0eX0gZnJvbSBcIi4vY29udGludW91c1wiO1xuaW1wb3J0IHtpbml0SW50ZXJwb2xhdG9yfSBmcm9tIFwiLi9pbml0XCI7XG5pbXBvcnQge2xpbmVhcmlzaH0gZnJvbSBcIi4vbGluZWFyXCI7XG5pbXBvcnQge2xvZ2dpc2h9IGZyb20gXCIuL2xvZ1wiO1xuaW1wb3J0IHtzeW1sb2dpc2h9IGZyb20gXCIuL3N5bWxvZ1wiO1xuaW1wb3J0IHtwb3dpc2h9IGZyb20gXCIuL3Bvd1wiO1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1lcigpIHtcbiAgdmFyIHgwID0gMCxcbiAgICAgIHgxID0gMSxcbiAgICAgIHQwLFxuICAgICAgdDEsXG4gICAgICBrMTAsXG4gICAgICB0cmFuc2Zvcm0sXG4gICAgICBpbnRlcnBvbGF0b3IgPSBpZGVudGl0eSxcbiAgICAgIGNsYW1wID0gZmFsc2UsXG4gICAgICB1bmtub3duO1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICByZXR1cm4gaXNOYU4oeCA9ICt4KSA/IHVua25vd24gOiBpbnRlcnBvbGF0b3IoazEwID09PSAwID8gMC41IDogKHggPSAodHJhbnNmb3JtKHgpIC0gdDApICogazEwLCBjbGFtcCA/IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHgpKSA6IHgpKTtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0MCA9IHRyYW5zZm9ybSh4MCA9ICtfWzBdKSwgdDEgPSB0cmFuc2Zvcm0oeDEgPSArX1sxXSksIGsxMCA9IHQwID09PSB0MSA/IDAgOiAxIC8gKHQxIC0gdDApLCBzY2FsZSkgOiBbeDAsIHgxXTtcbiAgfTtcblxuICBzY2FsZS5jbGFtcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjbGFtcCA9ICEhXywgc2NhbGUpIDogY2xhbXA7XG4gIH07XG5cbiAgc2NhbGUuaW50ZXJwb2xhdG9yID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGludGVycG9sYXRvciA9IF8sIHNjYWxlKSA6IGludGVycG9sYXRvcjtcbiAgfTtcblxuICBzY2FsZS51bmtub3duID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHVua25vd24gPSBfLCBzY2FsZSkgOiB1bmtub3duO1xuICB9O1xuXG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdHJhbnNmb3JtID0gdCwgdDAgPSB0KHgwKSwgdDEgPSB0KHgxKSwgazEwID0gdDAgPT09IHQxID8gMCA6IDEgLyAodDEgLSB0MCk7XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29weShzb3VyY2UsIHRhcmdldCkge1xuICByZXR1cm4gdGFyZ2V0XG4gICAgICAuZG9tYWluKHNvdXJjZS5kb21haW4oKSlcbiAgICAgIC5pbnRlcnBvbGF0b3Ioc291cmNlLmludGVycG9sYXRvcigpKVxuICAgICAgLmNsYW1wKHNvdXJjZS5jbGFtcCgpKVxuICAgICAgLnVua25vd24oc291cmNlLnVua25vd24oKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNlcXVlbnRpYWwoKSB7XG4gIHZhciBzY2FsZSA9IGxpbmVhcmlzaCh0cmFuc2Zvcm1lcigpKGlkZW50aXR5KSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBzZXF1ZW50aWFsKCkpO1xuICB9O1xuXG4gIHJldHVybiBpbml0SW50ZXJwb2xhdG9yLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VxdWVudGlhbExvZygpIHtcbiAgdmFyIHNjYWxlID0gbG9nZ2lzaCh0cmFuc2Zvcm1lcigpKS5kb21haW4oWzEsIDEwXSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBzZXF1ZW50aWFsTG9nKCkpLmJhc2Uoc2NhbGUuYmFzZSgpKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdEludGVycG9sYXRvci5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlcXVlbnRpYWxTeW1sb2coKSB7XG4gIHZhciBzY2FsZSA9IHN5bWxvZ2lzaCh0cmFuc2Zvcm1lcigpKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIHNlcXVlbnRpYWxTeW1sb2coKSkuY29uc3RhbnQoc2NhbGUuY29uc3RhbnQoKSk7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRJbnRlcnBvbGF0b3IuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXF1ZW50aWFsUG93KCkge1xuICB2YXIgc2NhbGUgPSBwb3dpc2godHJhbnNmb3JtZXIoKSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBzZXF1ZW50aWFsUG93KCkpLmV4cG9uZW50KHNjYWxlLmV4cG9uZW50KCkpO1xuICB9O1xuXG4gIHJldHVybiBpbml0SW50ZXJwb2xhdG9yLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VxdWVudGlhbFNxcnQoKSB7XG4gIHJldHVybiBzZXF1ZW50aWFsUG93LmFwcGx5KG51bGwsIGFyZ3VtZW50cykuZXhwb25lbnQoMC41KTtcbn1cbiIsImltcG9ydCB7YXNjZW5kaW5nLCBiaXNlY3R9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHtpZGVudGl0eX0gZnJvbSBcIi4vY29udGludW91c1wiO1xuaW1wb3J0IHtpbml0SW50ZXJwb2xhdG9yfSBmcm9tIFwiLi9pbml0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNlcXVlbnRpYWxRdWFudGlsZSgpIHtcbiAgdmFyIGRvbWFpbiA9IFtdLFxuICAgICAgaW50ZXJwb2xhdG9yID0gaWRlbnRpdHk7XG5cbiAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgIGlmICghaXNOYU4oeCA9ICt4KSkgcmV0dXJuIGludGVycG9sYXRvcigoYmlzZWN0KGRvbWFpbiwgeCkgLSAxKSAvIChkb21haW4ubGVuZ3RoIC0gMSkpO1xuICB9XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbi5zbGljZSgpO1xuICAgIGRvbWFpbiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gXy5sZW5ndGgsIGQ7IGkgPCBuOyArK2kpIGlmIChkID0gX1tpXSwgZCAhPSBudWxsICYmICFpc05hTihkID0gK2QpKSBkb21haW4ucHVzaChkKTtcbiAgICBkb21haW4uc29ydChhc2NlbmRpbmcpO1xuICAgIHJldHVybiBzY2FsZTtcbiAgfTtcblxuICBzY2FsZS5pbnRlcnBvbGF0b3IgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaW50ZXJwb2xhdG9yID0gXywgc2NhbGUpIDogaW50ZXJwb2xhdG9yO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2VxdWVudGlhbFF1YW50aWxlKGludGVycG9sYXRvcikuZG9tYWluKGRvbWFpbik7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRJbnRlcnBvbGF0b3IuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG4iLCJpbXBvcnQge2lkZW50aXR5fSBmcm9tIFwiLi9jb250aW51b3VzXCI7XG5pbXBvcnQge2luaXRJbnRlcnBvbGF0b3J9IGZyb20gXCIuL2luaXRcIjtcbmltcG9ydCB7bGluZWFyaXNofSBmcm9tIFwiLi9saW5lYXJcIjtcbmltcG9ydCB7bG9nZ2lzaH0gZnJvbSBcIi4vbG9nXCI7XG5pbXBvcnQge2NvcHl9IGZyb20gXCIuL3NlcXVlbnRpYWxcIjtcbmltcG9ydCB7c3ltbG9naXNofSBmcm9tIFwiLi9zeW1sb2dcIjtcbmltcG9ydCB7cG93aXNofSBmcm9tIFwiLi9wb3dcIjtcblxuZnVuY3Rpb24gdHJhbnNmb3JtZXIoKSB7XG4gIHZhciB4MCA9IDAsXG4gICAgICB4MSA9IDAuNSxcbiAgICAgIHgyID0gMSxcbiAgICAgIHQwLFxuICAgICAgdDEsXG4gICAgICB0MixcbiAgICAgIGsxMCxcbiAgICAgIGsyMSxcbiAgICAgIGludGVycG9sYXRvciA9IGlkZW50aXR5LFxuICAgICAgdHJhbnNmb3JtLFxuICAgICAgY2xhbXAgPSBmYWxzZSxcbiAgICAgIHVua25vd247XG5cbiAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgIHJldHVybiBpc05hTih4ID0gK3gpID8gdW5rbm93biA6ICh4ID0gMC41ICsgKCh4ID0gK3RyYW5zZm9ybSh4KSkgLSB0MSkgKiAoeCA8IHQxID8gazEwIDogazIxKSwgaW50ZXJwb2xhdG9yKGNsYW1wID8gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgeCkpIDogeCkpO1xuICB9XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHQwID0gdHJhbnNmb3JtKHgwID0gK19bMF0pLCB0MSA9IHRyYW5zZm9ybSh4MSA9ICtfWzFdKSwgdDIgPSB0cmFuc2Zvcm0oeDIgPSArX1syXSksIGsxMCA9IHQwID09PSB0MSA/IDAgOiAwLjUgLyAodDEgLSB0MCksIGsyMSA9IHQxID09PSB0MiA/IDAgOiAwLjUgLyAodDIgLSB0MSksIHNjYWxlKSA6IFt4MCwgeDEsIHgyXTtcbiAgfTtcblxuICBzY2FsZS5jbGFtcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjbGFtcCA9ICEhXywgc2NhbGUpIDogY2xhbXA7XG4gIH07XG5cbiAgc2NhbGUuaW50ZXJwb2xhdG9yID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGludGVycG9sYXRvciA9IF8sIHNjYWxlKSA6IGludGVycG9sYXRvcjtcbiAgfTtcblxuICBzY2FsZS51bmtub3duID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHVua25vd24gPSBfLCBzY2FsZSkgOiB1bmtub3duO1xuICB9O1xuXG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdHJhbnNmb3JtID0gdCwgdDAgPSB0KHgwKSwgdDEgPSB0KHgxKSwgdDIgPSB0KHgyKSwgazEwID0gdDAgPT09IHQxID8gMCA6IDAuNSAvICh0MSAtIHQwKSwgazIxID0gdDEgPT09IHQyID8gMCA6IDAuNSAvICh0MiAtIHQxKTtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRpdmVyZ2luZygpIHtcbiAgdmFyIHNjYWxlID0gbGluZWFyaXNoKHRyYW5zZm9ybWVyKCkoaWRlbnRpdHkpKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIGRpdmVyZ2luZygpKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdEludGVycG9sYXRvci5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpdmVyZ2luZ0xvZygpIHtcbiAgdmFyIHNjYWxlID0gbG9nZ2lzaCh0cmFuc2Zvcm1lcigpKS5kb21haW4oWzAuMSwgMSwgMTBdKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIGRpdmVyZ2luZ0xvZygpKS5iYXNlKHNjYWxlLmJhc2UoKSk7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRJbnRlcnBvbGF0b3IuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXZlcmdpbmdTeW1sb2coKSB7XG4gIHZhciBzY2FsZSA9IHN5bWxvZ2lzaCh0cmFuc2Zvcm1lcigpKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIGRpdmVyZ2luZ1N5bWxvZygpKS5jb25zdGFudChzY2FsZS5jb25zdGFudCgpKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdEludGVycG9sYXRvci5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpdmVyZ2luZ1BvdygpIHtcbiAgdmFyIHNjYWxlID0gcG93aXNoKHRyYW5zZm9ybWVyKCkpO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgZGl2ZXJnaW5nUG93KCkpLmV4cG9uZW50KHNjYWxlLmV4cG9uZW50KCkpO1xuICB9O1xuXG4gIHJldHVybiBpbml0SW50ZXJwb2xhdG9yLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGl2ZXJnaW5nU3FydCgpIHtcbiAgcmV0dXJuIGRpdmVyZ2luZ1Bvdy5hcHBseShudWxsLCBhcmd1bWVudHMpLmV4cG9uZW50KDAuNSk7XG59XG4iLCJleHBvcnQge1xuICBkZWZhdWx0IGFzIHNjYWxlQmFuZCxcbiAgcG9pbnQgYXMgc2NhbGVQb2ludFxufSBmcm9tIFwiLi9iYW5kXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgc2NhbGVJZGVudGl0eVxufSBmcm9tIFwiLi9pZGVudGl0eVwiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIHNjYWxlTGluZWFyXG59IGZyb20gXCIuL2xpbmVhclwiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIHNjYWxlTG9nXG59IGZyb20gXCIuL2xvZ1wiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIHNjYWxlU3ltbG9nXG59IGZyb20gXCIuL3N5bWxvZ1wiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIHNjYWxlT3JkaW5hbCxcbiAgaW1wbGljaXQgYXMgc2NhbGVJbXBsaWNpdFxufSBmcm9tIFwiLi9vcmRpbmFsXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgc2NhbGVQb3csXG4gIHNxcnQgYXMgc2NhbGVTcXJ0XG59IGZyb20gXCIuL3Bvd1wiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIHNjYWxlUXVhbnRpbGVcbn0gZnJvbSBcIi4vcXVhbnRpbGVcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyBzY2FsZVF1YW50aXplXG59IGZyb20gXCIuL3F1YW50aXplXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgc2NhbGVUaHJlc2hvbGRcbn0gZnJvbSBcIi4vdGhyZXNob2xkXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgc2NhbGVUaW1lXG59IGZyb20gXCIuL3RpbWVcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyBzY2FsZVV0Y1xufSBmcm9tIFwiLi91dGNUaW1lXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgc2NhbGVTZXF1ZW50aWFsLFxuICBzZXF1ZW50aWFsTG9nIGFzIHNjYWxlU2VxdWVudGlhbExvZyxcbiAgc2VxdWVudGlhbFBvdyBhcyBzY2FsZVNlcXVlbnRpYWxQb3csXG4gIHNlcXVlbnRpYWxTcXJ0IGFzIHNjYWxlU2VxdWVudGlhbFNxcnQsXG4gIHNlcXVlbnRpYWxTeW1sb2cgYXMgc2NhbGVTZXF1ZW50aWFsU3ltbG9nXG59IGZyb20gXCIuL3NlcXVlbnRpYWxcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyBzY2FsZVNlcXVlbnRpYWxRdWFudGlsZVxufSBmcm9tIFwiLi9zZXF1ZW50aWFsUXVhbnRpbGVcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyBzY2FsZURpdmVyZ2luZyxcbiAgZGl2ZXJnaW5nTG9nIGFzIHNjYWxlRGl2ZXJnaW5nTG9nLFxuICBkaXZlcmdpbmdQb3cgYXMgc2NhbGVEaXZlcmdpbmdQb3csXG4gIGRpdmVyZ2luZ1NxcnQgYXMgc2NhbGVEaXZlcmdpbmdTcXJ0LFxuICBkaXZlcmdpbmdTeW1sb2cgYXMgc2NhbGVEaXZlcmdpbmdTeW1sb2dcbn0gZnJvbSBcIi4vZGl2ZXJnaW5nXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgdGlja0Zvcm1hdFxufSBmcm9tIFwiLi90aWNrRm9ybWF0XCI7XG4iLCJpbXBvcnQgeyBzY2FsZUJhbmQsIHNjYWxlUG9pbnQsIHNjYWxlTGluZWFyLCBzY2FsZVRpbWUsIHNjYWxlVXRjLCBzY2FsZUxvZywgc2NhbGVQb3csIHNjYWxlT3JkaW5hbCwgc2NhbGVRdWFudGl6ZSwgc2NhbGVRdWFudGlsZSwgc2NhbGVUaHJlc2hvbGQgfSBmcm9tICdkMy1zY2FsZSc7XG5cbnZhciBiYW5kID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciByYW5nZSA9IF9yZWYucmFuZ2UsXG4gICAgICByYW5nZVJvdW5kID0gX3JlZi5yYW5nZVJvdW5kLFxuICAgICAgZG9tYWluID0gX3JlZi5kb21haW4sXG4gICAgICBwYWRkaW5nID0gX3JlZi5wYWRkaW5nLFxuICAgICAgcGFkZGluZ0lubmVyID0gX3JlZi5wYWRkaW5nSW5uZXIsXG4gICAgICBwYWRkaW5nT3V0ZXIgPSBfcmVmLnBhZGRpbmdPdXRlcixcbiAgICAgIGFsaWduID0gX3JlZi5hbGlnbixcbiAgICAgIHRpY2tGb3JtYXQgPSBfcmVmLnRpY2tGb3JtYXQ7XG5cbiAgdmFyIHNjYWxlID0gc2NhbGVCYW5kKCk7XG5cbiAgaWYgKHJhbmdlKSBzY2FsZS5yYW5nZShyYW5nZSk7XG4gIGlmIChyYW5nZVJvdW5kKSBzY2FsZS5yYW5nZVJvdW5kKHJhbmdlUm91bmQpO1xuICBpZiAoZG9tYWluKSBzY2FsZS5kb21haW4oZG9tYWluKTtcbiAgaWYgKHBhZGRpbmcpIHNjYWxlLnBhZGRpbmcocGFkZGluZyk7XG4gIGlmIChwYWRkaW5nSW5uZXIpIHNjYWxlLnBhZGRpbmdJbm5lcihwYWRkaW5nSW5uZXIpO1xuICBpZiAocGFkZGluZ091dGVyKSBzY2FsZS5wYWRkaW5nT3V0ZXIocGFkZGluZ091dGVyKTtcbiAgaWYgKGFsaWduKSBzY2FsZS5hbGlnbihhbGlnbik7XG4gIGlmICh0aWNrRm9ybWF0KSBzY2FsZS50aWNrRm9ybWF0ID0gdGlja0Zvcm1hdDtcblxuICByZXR1cm4gc2NhbGU7XG59KTtcblxudmFyIHBvaW50ID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciByYW5nZSA9IF9yZWYucmFuZ2UsXG4gICAgICByYW5nZVJvdW5kID0gX3JlZi5yYW5nZVJvdW5kLFxuICAgICAgZG9tYWluID0gX3JlZi5kb21haW4sXG4gICAgICBwYWRkaW5nID0gX3JlZi5wYWRkaW5nLFxuICAgICAgYWxpZ24gPSBfcmVmLmFsaWduLFxuICAgICAgX3JlZiRuaWNlID0gX3JlZi5uaWNlLFxuICAgICAgbmljZSA9IF9yZWYkbmljZSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJG5pY2U7XG5cbiAgdmFyIHNjYWxlID0gc2NhbGVQb2ludCgpO1xuXG4gIGlmIChyYW5nZSkgc2NhbGUucmFuZ2UocmFuZ2UpO1xuICBpZiAocmFuZ2VSb3VuZCkgc2NhbGUucmFuZ2VSb3VuZChyYW5nZVJvdW5kKTtcbiAgaWYgKGRvbWFpbikgc2NhbGUuZG9tYWluKGRvbWFpbik7XG4gIGlmIChuaWNlKSBzY2FsZS5uaWNlKCk7XG4gIGlmIChwYWRkaW5nKSBzY2FsZS5wYWRkaW5nKHBhZGRpbmcpO1xuICBpZiAoYWxpZ24pIHNjYWxlLmFsaWduKGFsaWduKTtcblxuICByZXR1cm4gc2NhbGU7XG59KTtcblxudmFyIGxpbmVhciA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgcmFuZ2UgPSBfcmVmLnJhbmdlLFxuICAgICAgcmFuZ2VSb3VuZCA9IF9yZWYucmFuZ2VSb3VuZCxcbiAgICAgIGRvbWFpbiA9IF9yZWYuZG9tYWluLFxuICAgICAgX3JlZiRuaWNlID0gX3JlZi5uaWNlLFxuICAgICAgbmljZSA9IF9yZWYkbmljZSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJG5pY2UsXG4gICAgICBfcmVmJGNsYW1wID0gX3JlZi5jbGFtcCxcbiAgICAgIGNsYW1wID0gX3JlZiRjbGFtcCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJGNsYW1wO1xuXG4gIHZhciBzY2FsZSA9IHNjYWxlTGluZWFyKCk7XG5cbiAgaWYgKHJhbmdlKSBzY2FsZS5yYW5nZShyYW5nZSk7XG4gIGlmIChyYW5nZVJvdW5kKSBzY2FsZS5yYW5nZVJvdW5kKHJhbmdlUm91bmQpO1xuICBpZiAoZG9tYWluKSBzY2FsZS5kb21haW4oZG9tYWluKTtcbiAgaWYgKG5pY2UpIHNjYWxlLm5pY2UoKTtcbiAgaWYgKGNsYW1wKSBzY2FsZS5jbGFtcCh0cnVlKTtcblxuICByZXR1cm4gc2NhbGU7XG59KTtcblxudmFyIHRpbWUgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHJhbmdlID0gX3JlZi5yYW5nZSxcbiAgICAgIHJhbmdlUm91bmQgPSBfcmVmLnJhbmdlUm91bmQsXG4gICAgICBkb21haW4gPSBfcmVmLmRvbWFpbixcbiAgICAgIF9yZWYkbmljZSA9IF9yZWYubmljZSxcbiAgICAgIG5pY2UgPSBfcmVmJG5pY2UgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiRuaWNlLFxuICAgICAgX3JlZiRjbGFtcCA9IF9yZWYuY2xhbXAsXG4gICAgICBjbGFtcCA9IF9yZWYkY2xhbXAgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiRjbGFtcDtcblxuICB2YXIgc2NhbGUgPSBzY2FsZVRpbWUoKTtcblxuICBpZiAocmFuZ2UpIHNjYWxlLnJhbmdlKHJhbmdlKTtcbiAgaWYgKHJhbmdlUm91bmQpIHNjYWxlLnJhbmdlUm91bmQocmFuZ2VSb3VuZCk7XG4gIGlmIChkb21haW4pIHNjYWxlLmRvbWFpbihkb21haW4pO1xuICBpZiAobmljZSkgc2NhbGUubmljZSgpO1xuICBpZiAoY2xhbXApIHNjYWxlLmNsYW1wKHRydWUpO1xuXG4gIHJldHVybiBzY2FsZTtcbn0pO1xuXG52YXIgdXRjID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciByYW5nZSA9IF9yZWYucmFuZ2UsXG4gICAgICByYW5nZVJvdW5kID0gX3JlZi5yYW5nZVJvdW5kLFxuICAgICAgZG9tYWluID0gX3JlZi5kb21haW4sXG4gICAgICBfcmVmJG5pY2UgPSBfcmVmLm5pY2UsXG4gICAgICBuaWNlID0gX3JlZiRuaWNlID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkbmljZSxcbiAgICAgIF9yZWYkY2xhbXAgPSBfcmVmLmNsYW1wLFxuICAgICAgY2xhbXAgPSBfcmVmJGNsYW1wID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkY2xhbXA7XG5cbiAgdmFyIHNjYWxlID0gc2NhbGVVdGMoKTtcblxuICBpZiAocmFuZ2UpIHNjYWxlLnJhbmdlKHJhbmdlKTtcbiAgaWYgKHJhbmdlUm91bmQpIHNjYWxlLnJhbmdlUm91bmQocmFuZ2VSb3VuZCk7XG4gIGlmIChkb21haW4pIHNjYWxlLmRvbWFpbihkb21haW4pO1xuICBpZiAobmljZSkgc2NhbGUubmljZSgpO1xuICBpZiAoY2xhbXApIHNjYWxlLmNsYW1wKHRydWUpO1xuXG4gIHJldHVybiBzY2FsZTtcbn0pO1xuXG52YXIgbG9nID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciByYW5nZSA9IF9yZWYucmFuZ2UsXG4gICAgICByYW5nZVJvdW5kID0gX3JlZi5yYW5nZVJvdW5kLFxuICAgICAgZG9tYWluID0gX3JlZi5kb21haW4sXG4gICAgICBiYXNlID0gX3JlZi5iYXNlLFxuICAgICAgX3JlZiRuaWNlID0gX3JlZi5uaWNlLFxuICAgICAgbmljZSA9IF9yZWYkbmljZSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJG5pY2UsXG4gICAgICBfcmVmJGNsYW1wID0gX3JlZi5jbGFtcCxcbiAgICAgIGNsYW1wID0gX3JlZiRjbGFtcCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJGNsYW1wO1xuXG4gIHZhciBzY2FsZSA9IHNjYWxlTG9nKCk7XG5cbiAgaWYgKHJhbmdlKSBzY2FsZS5yYW5nZShyYW5nZSk7XG4gIGlmIChyYW5nZVJvdW5kKSBzY2FsZS5yYW5nZVJvdW5kKHJhbmdlUm91bmQpO1xuICBpZiAoZG9tYWluKSBzY2FsZS5kb21haW4oZG9tYWluKTtcbiAgaWYgKG5pY2UpIHNjYWxlLm5pY2UoKTtcbiAgaWYgKGNsYW1wKSBzY2FsZS5jbGFtcCh0cnVlKTtcbiAgaWYgKGJhc2UpIHNjYWxlLmJhc2UoYmFzZSk7XG5cbiAgcmV0dXJuIHNjYWxlO1xufSk7XG5cbnZhciBwb3dlciA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgcmFuZ2UgPSBfcmVmLnJhbmdlLFxuICAgICAgcmFuZ2VSb3VuZCA9IF9yZWYucmFuZ2VSb3VuZCxcbiAgICAgIGRvbWFpbiA9IF9yZWYuZG9tYWluLFxuICAgICAgZXhwb25lbnQgPSBfcmVmLmV4cG9uZW50LFxuICAgICAgX3JlZiRuaWNlID0gX3JlZi5uaWNlLFxuICAgICAgbmljZSA9IF9yZWYkbmljZSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJG5pY2UsXG4gICAgICBfcmVmJGNsYW1wID0gX3JlZi5jbGFtcCxcbiAgICAgIGNsYW1wID0gX3JlZiRjbGFtcCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJGNsYW1wO1xuXG4gIHZhciBzY2FsZSA9IHNjYWxlUG93KCk7XG5cbiAgaWYgKHJhbmdlKSBzY2FsZS5yYW5nZShyYW5nZSk7XG4gIGlmIChyYW5nZVJvdW5kKSBzY2FsZS5yYW5nZVJvdW5kKHJhbmdlUm91bmQpO1xuICBpZiAoZG9tYWluKSBzY2FsZS5kb21haW4oZG9tYWluKTtcbiAgaWYgKG5pY2UpIHNjYWxlLm5pY2UoKTtcbiAgaWYgKGNsYW1wKSBzY2FsZS5jbGFtcCh0cnVlKTtcbiAgaWYgKGV4cG9uZW50KSBzY2FsZS5leHBvbmVudChleHBvbmVudCk7XG5cbiAgcmV0dXJuIHNjYWxlO1xufSk7XG5cbnZhciBvcmRpbmFsID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciByYW5nZSA9IF9yZWYucmFuZ2UsXG4gICAgICBkb21haW4gPSBfcmVmLmRvbWFpbixcbiAgICAgIHVua25vd24gPSBfcmVmLnVua25vd247XG5cbiAgdmFyIHNjYWxlID0gc2NhbGVPcmRpbmFsKCk7XG5cbiAgaWYgKHJhbmdlKSBzY2FsZS5yYW5nZShyYW5nZSk7XG4gIGlmIChkb21haW4pIHNjYWxlLmRvbWFpbihkb21haW4pO1xuICBpZiAodW5rbm93bikgc2NhbGUudW5rbm93bih1bmtub3duKTtcblxuICByZXR1cm4gc2NhbGU7XG59KTtcblxudmFyIHF1YW50aXplID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciByYW5nZSA9IF9yZWYucmFuZ2UsXG4gICAgICBkb21haW4gPSBfcmVmLmRvbWFpbixcbiAgICAgIHRpY2tzID0gX3JlZi50aWNrcyxcbiAgICAgIHRpY2tGb3JtYXQgPSBfcmVmLnRpY2tGb3JtYXQsXG4gICAgICBfcmVmJG5pY2UgPSBfcmVmLm5pY2UsXG4gICAgICBuaWNlID0gX3JlZiRuaWNlID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkbmljZTtcblxuICB2YXIgc2NhbGUgPSBzY2FsZVF1YW50aXplKCk7XG5cbiAgaWYgKHJhbmdlKSBzY2FsZS5yYW5nZShyYW5nZSk7XG4gIGlmIChkb21haW4pIHNjYWxlLmRvbWFpbihkb21haW4pO1xuICBpZiAobmljZSkgc2NhbGUubmljZSgpO1xuICBpZiAodGlja3MpIHNjYWxlLnRpY2tzKHRpY2tzKTtcbiAgaWYgKHRpY2tGb3JtYXQpIHNjYWxlLnRpY2tGb3JtYXQodGlja0Zvcm1hdCk7XG5cbiAgcmV0dXJuIHNjYWxlO1xufSk7XG5cbnZhciBxdWFudGlsZSA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgcmFuZ2UgPSBfcmVmLnJhbmdlLFxuICAgICAgZG9tYWluID0gX3JlZi5kb21haW47XG5cbiAgdmFyIHNjYWxlID0gc2NhbGVRdWFudGlsZSgpO1xuXG4gIGlmIChyYW5nZSkgc2NhbGUucmFuZ2UocmFuZ2UpO1xuICBpZiAoZG9tYWluKSBzY2FsZS5kb21haW4oZG9tYWluKTtcblxuICByZXR1cm4gc2NhbGU7XG59KTtcblxudmFyIHRocmVzaG9sZCA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgcmFuZ2UgPSBfcmVmLnJhbmdlLFxuICAgICAgZG9tYWluID0gX3JlZi5kb21haW47XG5cbiAgdmFyIHNjYWxlID0gc2NhbGVUaHJlc2hvbGQoKTtcblxuICBpZiAocmFuZ2UpIHNjYWxlLnJhbmdlKHJhbmdlKTtcbiAgaWYgKGRvbWFpbikgc2NhbGUuZG9tYWluKGRvbWFpbik7XG5cbiAgcmV0dXJuIHNjYWxlO1xufSk7XG5cbnZhciBvYmplY3RXaXRob3V0UHJvcGVydGllcyA9IGZ1bmN0aW9uIChvYmosIGtleXMpIHtcbiAgdmFyIHRhcmdldCA9IHt9O1xuXG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTtcbiAgICB0YXJnZXRbaV0gPSBvYmpbaV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuZnVuY3Rpb24gdXBkYXRlU2NhbGUoc2NhbGUsIF9yZWYpIHtcbiAgdmFyIGFyZ3MgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbXSk7XG5cbiAgdmFyIG5leHRTY2FsZSA9IHNjYWxlLmNvcHkoKTtcbiAgT2JqZWN0LmtleXMoYXJncykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKG5leHRTY2FsZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSBuZXh0U2NhbGVba2V5XShhcmdzW2tleV0pO1xuICB9KTtcbiAgcmV0dXJuIG5leHRTY2FsZTtcbn1cblxuZXhwb3J0IHsgYmFuZCBhcyBzY2FsZUJhbmQsIHBvaW50IGFzIHNjYWxlUG9pbnQsIGxpbmVhciBhcyBzY2FsZUxpbmVhciwgdGltZSBhcyBzY2FsZVRpbWUsIHV0YyBhcyBzY2FsZVV0YywgbG9nIGFzIHNjYWxlTG9nLCBwb3dlciBhcyBzY2FsZVBvd2VyLCBvcmRpbmFsIGFzIHNjYWxlT3JkaW5hbCwgcXVhbnRpemUgYXMgc2NhbGVRdWFudGl6ZSwgcXVhbnRpbGUgYXMgc2NhbGVRdWFudGlsZSwgdGhyZXNob2xkIGFzIHNjYWxlVGhyZXNob2xkLCB1cGRhdGVTY2FsZSB9O1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IHsgR3JvdXAgfSBmcm9tICdAdngvZ3JvdXAnO1xuaW1wb3J0IHsgc2NhbGVMaW5lYXIgfSBmcm9tICdAdngvc2NhbGUnO1xuaW1wb3J0IHsgbGluZSwgY3VydmVDYXJkaW5hbCB9IGZyb20gJ2QzLXNoYXBlJztcblxuZnVuY3Rpb24gY2FsbE9yVmFsdWUobWF5YmVGbiwgZGF0YSkge1xuICBpZiAodHlwZW9mIG1heWJlRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVGbihkYXRhKTtcbiAgfVxuICByZXR1cm4gbWF5YmVGbjtcbn1cblxuZnVuY3Rpb24gYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcywgZGF0YSkge1xuICByZXR1cm4gT2JqZWN0LmtleXMocmVzdFByb3BzKS5yZWR1Y2UoZnVuY3Rpb24gKHJldCwgY3VyKSB7XG4gICAgcmV0W2N1cl0gPSBjYWxsT3JWYWx1ZShyZXN0UHJvcHNbY3VyXSwgZGF0YSk7XG4gICAgcmV0dXJuIHJldDtcbiAgfSwge30pO1xufVxuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxudmFyIG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG9iaiwga2V5cykge1xuICB2YXIgdGFyZ2V0ID0ge307XG5cbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlO1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlO1xuICAgIHRhcmdldFtpXSA9IG9ialtpXTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG52YXIgc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHtcbiAgICB2YXIgX2FyciA9IFtdO1xuICAgIHZhciBfbiA9IHRydWU7XG4gICAgdmFyIF9kID0gZmFsc2U7XG4gICAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfZCA9IHRydWU7XG4gICAgICBfZSA9IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9hcnI7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgIHJldHVybiBhcnI7XG4gICAgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHtcbiAgICAgIHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xuICAgIH1cbiAgfTtcbn0oKTtcblxudmFyIHRvQ29uc3VtYWJsZUFycmF5ID0gZnVuY3Rpb24gKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICAgIHJldHVybiBhcnIyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGFycik7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHZlcnRpY2FsVG9Ib3Jpem9udGFsKF9yZWYpIHtcbiAgdmFyIF9yZWYyID0gc2xpY2VkVG9BcnJheShfcmVmLCA0KSxcbiAgICAgIHgxID0gX3JlZjJbMF0sXG4gICAgICB5MSA9IF9yZWYyWzFdLFxuICAgICAgeDIgPSBfcmVmMlsyXSxcbiAgICAgIHkyID0gX3JlZjJbM107XG5cbiAgcmV0dXJuIFt5MSwgeDEsIHkyLCB4Ml07XG59XG5cbmZ1bmN0aW9uIEJveFBsb3QoX3JlZjMpIHtcbiAgdmFyIF9yZWYzJGxlZnQgPSBfcmVmMy5sZWZ0LFxuICAgICAgbGVmdCA9IF9yZWYzJGxlZnQgPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmMyRsZWZ0LFxuICAgICAgX3JlZjMkdG9wID0gX3JlZjMudG9wLFxuICAgICAgdG9wID0gX3JlZjMkdG9wID09PSB1bmRlZmluZWQgPyAwIDogX3JlZjMkdG9wLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZjMuY2xhc3NOYW1lLFxuICAgICAgZGF0YSA9IF9yZWYzLmRhdGEsXG4gICAgICBtYXggPSBfcmVmMy5tYXgsXG4gICAgICBtaW4gPSBfcmVmMy5taW4sXG4gICAgICBmaXJzdFF1YXJ0aWxlID0gX3JlZjMuZmlyc3RRdWFydGlsZSxcbiAgICAgIHRoaXJkUXVhcnRpbGUgPSBfcmVmMy50aGlyZFF1YXJ0aWxlLFxuICAgICAgbWVkaWFuID0gX3JlZjMubWVkaWFuLFxuICAgICAgYm94V2lkdGggPSBfcmVmMy5ib3hXaWR0aCxcbiAgICAgIGZpbGwgPSBfcmVmMy5maWxsLFxuICAgICAgZmlsbE9wYWNpdHkgPSBfcmVmMy5maWxsT3BhY2l0eSxcbiAgICAgIHN0cm9rZSA9IF9yZWYzLnN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoID0gX3JlZjMuc3Ryb2tlV2lkdGgsXG4gICAgICBfcmVmMyRyeCA9IF9yZWYzLnJ4LFxuICAgICAgcnggPSBfcmVmMyRyeCA9PT0gdW5kZWZpbmVkID8gMiA6IF9yZWYzJHJ4LFxuICAgICAgX3JlZjMkcnkgPSBfcmVmMy5yeSxcbiAgICAgIHJ5ID0gX3JlZjMkcnkgPT09IHVuZGVmaW5lZCA/IDIgOiBfcmVmMyRyeSxcbiAgICAgIHZhbHVlU2NhbGUgPSBfcmVmMy52YWx1ZVNjYWxlLFxuICAgICAgb3V0bGllcnMgPSBfcmVmMy5vdXRsaWVycyxcbiAgICAgIGhvcml6b250YWwgPSBfcmVmMy5ob3Jpem9udGFsLFxuICAgICAgX3JlZjMkbWVkaWFuUHJvcHMgPSBfcmVmMy5tZWRpYW5Qcm9wcyxcbiAgICAgIG1lZGlhblByb3BzID0gX3JlZjMkbWVkaWFuUHJvcHMgPT09IHVuZGVmaW5lZCA/IHt9IDogX3JlZjMkbWVkaWFuUHJvcHMsXG4gICAgICBfcmVmMyRtYXhQcm9wcyA9IF9yZWYzLm1heFByb3BzLFxuICAgICAgbWF4UHJvcHMgPSBfcmVmMyRtYXhQcm9wcyA9PT0gdW5kZWZpbmVkID8ge30gOiBfcmVmMyRtYXhQcm9wcyxcbiAgICAgIF9yZWYzJG1pblByb3BzID0gX3JlZjMubWluUHJvcHMsXG4gICAgICBtaW5Qcm9wcyA9IF9yZWYzJG1pblByb3BzID09PSB1bmRlZmluZWQgPyB7fSA6IF9yZWYzJG1pblByb3BzLFxuICAgICAgX3JlZjMkYm94UHJvcHMgPSBfcmVmMy5ib3hQcm9wcyxcbiAgICAgIGJveFByb3BzID0gX3JlZjMkYm94UHJvcHMgPT09IHVuZGVmaW5lZCA/IHt9IDogX3JlZjMkYm94UHJvcHMsXG4gICAgICBfcmVmMyRvdXRsaWVyUHJvcHMgPSBfcmVmMy5vdXRsaWVyUHJvcHMsXG4gICAgICBvdXRsaWVyUHJvcHMgPSBfcmVmMyRvdXRsaWVyUHJvcHMgPT09IHVuZGVmaW5lZCA/IHt9IDogX3JlZjMkb3V0bGllclByb3BzLFxuICAgICAgX3JlZjMkY29udGFpbmVyID0gX3JlZjMuY29udGFpbmVyLFxuICAgICAgY29udGFpbmVyID0gX3JlZjMkY29udGFpbmVyID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYzJGNvbnRhaW5lcixcbiAgICAgIF9yZWYzJGNvbnRhaW5lclByb3BzID0gX3JlZjMuY29udGFpbmVyUHJvcHMsXG4gICAgICBjb250YWluZXJQcm9wcyA9IF9yZWYzJGNvbnRhaW5lclByb3BzID09PSB1bmRlZmluZWQgPyB7fSA6IF9yZWYzJGNvbnRhaW5lclByb3BzLFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjMsIFsnbGVmdCcsICd0b3AnLCAnY2xhc3NOYW1lJywgJ2RhdGEnLCAnbWF4JywgJ21pbicsICdmaXJzdFF1YXJ0aWxlJywgJ3RoaXJkUXVhcnRpbGUnLCAnbWVkaWFuJywgJ2JveFdpZHRoJywgJ2ZpbGwnLCAnZmlsbE9wYWNpdHknLCAnc3Ryb2tlJywgJ3N0cm9rZVdpZHRoJywgJ3J4JywgJ3J5JywgJ3ZhbHVlU2NhbGUnLCAnb3V0bGllcnMnLCAnaG9yaXpvbnRhbCcsICdtZWRpYW5Qcm9wcycsICdtYXhQcm9wcycsICdtaW5Qcm9wcycsICdib3hQcm9wcycsICdvdXRsaWVyUHJvcHMnLCAnY29udGFpbmVyJywgJ2NvbnRhaW5lclByb3BzJ10pO1xuXG4gIHZhciBvZmZzZXQgPSBob3Jpem9udGFsID8gdG9wIDogbGVmdDtcbiAgdmFyIGNlbnRlciA9IG9mZnNldCArIGJveFdpZHRoIC8gMjtcblxuICB2YXIgbWF4TGluZVBvcyA9IEFycmF5KDQpLmZpbGwoMCk7XG4gIHZhciBtYXhUb0JveExpbmVQb3MgPSBBcnJheSg0KS5maWxsKDApO1xuICB2YXIgYm94UG9zID0gQXJyYXkoNCkuZmlsbCgwKTtcbiAgdmFyIG1lZGlhbkxpbmVQb3MgPSBBcnJheSg0KS5maWxsKDApO1xuICB2YXIgbWluVG9Cb3hMaW5lUG9zID0gQXJyYXkoNCkuZmlsbCgwKTtcbiAgdmFyIG1pbkxpbmVQb3MgPSBBcnJheSg0KS5maWxsKDApO1xuICB2YXIgY29udGFpbmVyUG9zID0gQXJyYXkoNCkuZmlsbCgwKTtcblxuICAvLyBhbGwgb2YgdGhlc2UgYXJlIFt4MCwgeTAsIHgxLCB5MV1cbiAgbWF4TGluZVBvc1swXSA9IGNlbnRlciAtIGJveFdpZHRoIC8gNDtcbiAgbWF4TGluZVBvc1sxXSA9IHZhbHVlU2NhbGUobWF4KTtcbiAgbWF4TGluZVBvc1syXSA9IGNlbnRlciArIGJveFdpZHRoIC8gNDtcbiAgbWF4TGluZVBvc1szXSA9IHZhbHVlU2NhbGUobWF4KTtcblxuICBtYXhUb0JveExpbmVQb3NbMF0gPSBjZW50ZXI7XG4gIG1heFRvQm94TGluZVBvc1sxXSA9IHZhbHVlU2NhbGUobWF4KTtcbiAgbWF4VG9Cb3hMaW5lUG9zWzJdID0gY2VudGVyO1xuICBtYXhUb0JveExpbmVQb3NbM10gPSB2YWx1ZVNjYWxlKHRoaXJkUXVhcnRpbGUpO1xuXG4gIGJveFBvc1swXSA9IG9mZnNldDtcbiAgYm94UG9zWzFdID0gdmFsdWVTY2FsZSh0aGlyZFF1YXJ0aWxlKTtcbiAgYm94UG9zWzJdID0gYm94V2lkdGg7XG4gIGJveFBvc1szXSA9IE1hdGguYWJzKHZhbHVlU2NhbGUodGhpcmRRdWFydGlsZSkgLSB2YWx1ZVNjYWxlKGZpcnN0UXVhcnRpbGUpKTtcblxuICBtZWRpYW5MaW5lUG9zWzBdID0gb2Zmc2V0O1xuICBtZWRpYW5MaW5lUG9zWzFdID0gdmFsdWVTY2FsZShtZWRpYW4pO1xuICBtZWRpYW5MaW5lUG9zWzJdID0gb2Zmc2V0ICsgYm94V2lkdGg7XG4gIG1lZGlhbkxpbmVQb3NbM10gPSB2YWx1ZVNjYWxlKG1lZGlhbik7XG5cbiAgbWluVG9Cb3hMaW5lUG9zWzBdID0gY2VudGVyO1xuICBtaW5Ub0JveExpbmVQb3NbMV0gPSB2YWx1ZVNjYWxlKGZpcnN0UXVhcnRpbGUpO1xuICBtaW5Ub0JveExpbmVQb3NbMl0gPSBjZW50ZXI7XG4gIG1pblRvQm94TGluZVBvc1szXSA9IHZhbHVlU2NhbGUobWluKTtcblxuICBtaW5MaW5lUG9zWzBdID0gY2VudGVyIC0gYm94V2lkdGggLyA0O1xuICBtaW5MaW5lUG9zWzFdID0gdmFsdWVTY2FsZShtaW4pO1xuICBtaW5MaW5lUG9zWzJdID0gY2VudGVyICsgYm94V2lkdGggLyA0O1xuICBtaW5MaW5lUG9zWzNdID0gdmFsdWVTY2FsZShtaW4pO1xuXG4gIHZhciB2YWx1ZVJhbmdlID0gdmFsdWVTY2FsZS5yYW5nZSgpO1xuICBjb250YWluZXJQb3NbMF0gPSBib3hQb3NbMF07XG4gIGNvbnRhaW5lclBvc1sxXSA9IE1hdGgubWluLmFwcGx5KE1hdGgsIHRvQ29uc3VtYWJsZUFycmF5KHZhbHVlUmFuZ2UpKTtcbiAgY29udGFpbmVyUG9zWzJdID0gYm94UG9zWzJdO1xuICBjb250YWluZXJQb3NbM10gPSBNYXRoLmFicyh2YWx1ZVJhbmdlWzBdIC0gdmFsdWVSYW5nZVsxXSk7XG5cbiAgaWYgKGhvcml6b250YWwpIHtcbiAgICBtYXhMaW5lUG9zID0gdmVydGljYWxUb0hvcml6b250YWwobWF4TGluZVBvcyk7XG4gICAgbWF4VG9Cb3hMaW5lUG9zID0gdmVydGljYWxUb0hvcml6b250YWwobWF4VG9Cb3hMaW5lUG9zKTtcbiAgICBib3hQb3MgPSB2ZXJ0aWNhbFRvSG9yaXpvbnRhbChib3hQb3MpO1xuICAgIGJveFBvc1swXSA9IHZhbHVlU2NhbGUoZmlyc3RRdWFydGlsZSk7XG4gICAgbWVkaWFuTGluZVBvcyA9IHZlcnRpY2FsVG9Ib3Jpem9udGFsKG1lZGlhbkxpbmVQb3MpO1xuICAgIG1pblRvQm94TGluZVBvcyA9IHZlcnRpY2FsVG9Ib3Jpem9udGFsKG1pblRvQm94TGluZVBvcyk7XG4gICAgbWluTGluZVBvcyA9IHZlcnRpY2FsVG9Ib3Jpem9udGFsKG1pbkxpbmVQb3MpO1xuICAgIGNvbnRhaW5lclBvcyA9IHZlcnRpY2FsVG9Ib3Jpem9udGFsKGNvbnRhaW5lclBvcyk7XG4gICAgY29udGFpbmVyUG9zWzBdID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgdG9Db25zdW1hYmxlQXJyYXkodmFsdWVSYW5nZSkpO1xuICB9XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIEdyb3VwLFxuICAgIHsgY2xhc3NOYW1lOiBjbGFzc25hbWVzKCd2eC1ib3hwbG90JywgY2xhc3NOYW1lKSB9LFxuICAgIG91dGxpZXJzLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgdmFyIGN4ID0gaG9yaXpvbnRhbCA/IHZhbHVlU2NhbGUoZCkgOiBjZW50ZXI7XG4gICAgICB2YXIgY3kgPSBob3Jpem9udGFsID8gY2VudGVyIDogdmFsdWVTY2FsZShkKTtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdjaXJjbGUnLCBfZXh0ZW5kcyh7XG4gICAgICAgIGtleTogaSxcbiAgICAgICAgY2xhc3NOYW1lOiAndngtYm94cGxvdC1vdXRsaWVyJyxcbiAgICAgICAgY3g6IGN4LFxuICAgICAgICBjeTogY3ksXG4gICAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgZmlsbDogZmlsbCxcbiAgICAgICAgZmlsbE9wYWNpdHk6IGZpbGxPcGFjaXR5LFxuICAgICAgICByOiAnNCdcbiAgICAgIH0sIGFkZGl0aW9uYWxQcm9wcyhvdXRsaWVyUHJvcHMsIHtcbiAgICAgICAgZGF0YTogZCxcbiAgICAgICAgY3g6IGN4LFxuICAgICAgICBjeTogY3lcbiAgICAgIH0pKSk7XG4gICAgfSksXG4gICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnbGluZScsIF9leHRlbmRzKHtcbiAgICAgIGNsYXNzTmFtZTogJ3Z4LWJveHBsb3QtbWF4JyxcbiAgICAgIHgxOiBtYXhMaW5lUG9zWzBdLFxuICAgICAgeTE6IG1heExpbmVQb3NbMV0sXG4gICAgICB4MjogbWF4TGluZVBvc1syXSxcbiAgICAgIHkyOiBtYXhMaW5lUG9zWzNdLFxuICAgICAgc3Ryb2tlOiBzdHJva2UsXG4gICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGhcbiAgICB9LCBhZGRpdGlvbmFsUHJvcHMobWF4UHJvcHMsIHtcbiAgICAgIGRhdGE6IGRhdGEsXG4gICAgICBtYXg6IG1heCxcbiAgICAgIHgxOiBtYXhMaW5lUG9zWzBdLFxuICAgICAgeDI6IG1heExpbmVQb3NbMl0sXG4gICAgICB5MTogbWF4TGluZVBvc1sxXSxcbiAgICAgIHkyOiBtYXhMaW5lUG9zWzNdXG4gICAgfSkpKSxcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdsaW5lJywge1xuICAgICAgeDE6IG1heFRvQm94TGluZVBvc1swXSxcbiAgICAgIHkxOiBtYXhUb0JveExpbmVQb3NbMV0sXG4gICAgICB4MjogbWF4VG9Cb3hMaW5lUG9zWzJdLFxuICAgICAgeTI6IG1heFRvQm94TGluZVBvc1szXSxcbiAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoXG4gICAgfSksXG4gICAgUmVhY3QuY3JlYXRlRWxlbWVudCgncmVjdCcsIF9leHRlbmRzKHtcbiAgICAgIGNsYXNzTmFtZTogJ3Z4LWJveHBsb3QtYm94JyxcbiAgICAgIHg6IGJveFBvc1swXSxcbiAgICAgIHk6IGJveFBvc1sxXSxcbiAgICAgIHdpZHRoOiBib3hQb3NbMl0sXG4gICAgICBoZWlnaHQ6IGJveFBvc1szXSxcbiAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgICAgZmlsbDogZmlsbCxcbiAgICAgIGZpbGxPcGFjaXR5OiBmaWxsT3BhY2l0eSxcbiAgICAgIHJ4OiByeCxcbiAgICAgIHJ5OiByeVxuICAgIH0sIGFkZGl0aW9uYWxQcm9wcyhib3hQcm9wcywge1xuICAgICAgZGF0YTogZGF0YSxcbiAgICAgIGhlaWdodDogYm94UG9zWzNdLFxuICAgICAgbWVkaWFuOiBtZWRpYW4sXG4gICAgICBmaXJzdFF1YXJ0aWxlOiBmaXJzdFF1YXJ0aWxlLFxuICAgICAgdGhpcmRRdWFydGlsZTogdGhpcmRRdWFydGlsZSxcbiAgICAgIG1pbjogbWluLFxuICAgICAgbWF4OiBtYXgsXG4gICAgICB4MTogYm94UG9zWzBdLFxuICAgICAgeDI6IGJveFBvc1swXSArIGJveFBvc1syXSxcbiAgICAgIHkxOiBib3hQb3NbMV0sXG4gICAgICB5MjogYm94UG9zWzFdICsgYm94UG9zWzNdXG4gICAgfSkpKSxcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdsaW5lJywgX2V4dGVuZHMoe1xuICAgICAgY2xhc3NOYW1lOiAndngtYm94cGxvdC1tZWRpYW4nLFxuICAgICAgeDE6IG1lZGlhbkxpbmVQb3NbMF0sXG4gICAgICB5MTogbWVkaWFuTGluZVBvc1sxXSxcbiAgICAgIHgyOiBtZWRpYW5MaW5lUG9zWzJdLFxuICAgICAgeTI6IG1lZGlhbkxpbmVQb3NbM10sXG4gICAgICBzdHJva2U6IHN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aFxuICAgIH0sIGFkZGl0aW9uYWxQcm9wcyhtZWRpYW5Qcm9wcywge1xuICAgICAgZGF0YTogZGF0YSxcbiAgICAgIG1lZGlhbjogbWVkaWFuLFxuICAgICAgeDE6IG1lZGlhbkxpbmVQb3NbMF0sXG4gICAgICB4MjogbWVkaWFuTGluZVBvc1syXSxcbiAgICAgIHkxOiBtZWRpYW5MaW5lUG9zWzFdLFxuICAgICAgeTI6IG1lZGlhbkxpbmVQb3NbM11cbiAgICB9KSkpLFxuICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2xpbmUnLCB7XG4gICAgICB4MTogbWluVG9Cb3hMaW5lUG9zWzBdLFxuICAgICAgeTE6IG1pblRvQm94TGluZVBvc1sxXSxcbiAgICAgIHgyOiBtaW5Ub0JveExpbmVQb3NbMl0sXG4gICAgICB5MjogbWluVG9Cb3hMaW5lUG9zWzNdLFxuICAgICAgc3Ryb2tlOiBzdHJva2UsXG4gICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGhcbiAgICB9KSxcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdsaW5lJywgX2V4dGVuZHMoe1xuICAgICAgY2xhc3NOYW1lOiAndngtYm94cGxvdC1taW4nLFxuICAgICAgeDE6IG1pbkxpbmVQb3NbMF0sXG4gICAgICB5MTogbWluTGluZVBvc1sxXSxcbiAgICAgIHgyOiBtaW5MaW5lUG9zWzJdLFxuICAgICAgeTI6IG1pbkxpbmVQb3NbM10sXG4gICAgICBzdHJva2U6IHN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aFxuICAgIH0sIGFkZGl0aW9uYWxQcm9wcyhtaW5Qcm9wcywge1xuICAgICAgZGF0YTogZGF0YSxcbiAgICAgIG1pbjogbWluLFxuICAgICAgeDE6IG1pbkxpbmVQb3NbMF0sXG4gICAgICB4MjogbWluTGluZVBvc1syXSxcbiAgICAgIHkxOiBtaW5MaW5lUG9zWzFdLFxuICAgICAgeTI6IG1pbkxpbmVQb3NbM11cbiAgICB9KSkpLFxuICAgIGNvbnRhaW5lciAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KCdyZWN0JywgX2V4dGVuZHMoe1xuICAgICAgeDogY29udGFpbmVyUG9zWzBdLFxuICAgICAgeTogY29udGFpbmVyUG9zWzFdLFxuICAgICAgd2lkdGg6IGNvbnRhaW5lclBvc1syXSxcbiAgICAgIGhlaWdodDogY29udGFpbmVyUG9zWzNdLFxuICAgICAgZmlsbE9wYWNpdHk6ICcwJ1xuICAgIH0sIGFkZGl0aW9uYWxQcm9wcyhjb250YWluZXJQcm9wcywge1xuICAgICAgZGF0YTogZGF0YSxcbiAgICAgIHgxOiBjb250YWluZXJQb3NbMF0sXG4gICAgICB4MjogY29udGFpbmVyUG9zWzBdICsgY29udGFpbmVyUG9zWzJdLFxuICAgICAgeTE6IGNvbnRhaW5lclBvc1sxXSxcbiAgICAgIHkyOiBjb250YWluZXJQb3NbMV0gKyBjb250YWluZXJQb3NbM10sXG4gICAgICBtZWRpYW46IG1lZGlhbixcbiAgICAgIG1heDogbWF4LFxuICAgICAgbWluOiBtaW4sXG4gICAgICB0aGlyZFF1YXJ0aWxlOiB0aGlyZFF1YXJ0aWxlLFxuICAgICAgZmlyc3RRdWFydGlsZTogZmlyc3RRdWFydGlsZVxuICAgIH0pKSlcbiAgKTtcbn1cblxuZnVuY3Rpb24gVmlvbGluUGxvdChfcmVmKSB7XG4gIHZhciBfcmVmJGxlZnQgPSBfcmVmLmxlZnQsXG4gICAgICBsZWZ0ID0gX3JlZiRsZWZ0ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiRsZWZ0LFxuICAgICAgX3JlZiR0b3AgPSBfcmVmLnRvcCxcbiAgICAgIHRvcCA9IF9yZWYkdG9wID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiR0b3AsXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIGJpbkRhdGEgPSBfcmVmLmJpbkRhdGEsXG4gICAgICBfcmVmJHN0cm9rZSA9IF9yZWYuc3Ryb2tlLFxuICAgICAgc3Ryb2tlID0gX3JlZiRzdHJva2UgPT09IHVuZGVmaW5lZCA/ICdibGFjaycgOiBfcmVmJHN0cm9rZSxcbiAgICAgIF9yZWYkZmlsbCA9IF9yZWYuZmlsbCxcbiAgICAgIGZpbGwgPSBfcmVmJGZpbGwgPT09IHVuZGVmaW5lZCA/ICdyZ2JhKDAsMCwwLDAuMyknIDogX3JlZiRmaWxsLFxuICAgICAgb3BhY2l0eSA9IF9yZWYub3BhY2l0eSxcbiAgICAgIHN0cm9rZVdpZHRoID0gX3JlZi5zdHJva2VXaWR0aCxcbiAgICAgIHdpZHRoID0gX3JlZi53aWR0aCxcbiAgICAgIHZhbHVlU2NhbGUgPSBfcmVmLnZhbHVlU2NhbGUsXG4gICAgICBzdHJva2VEYXNoYXJyYXkgPSBfcmVmLnN0cm9rZURhc2hhcnJheSxcbiAgICAgIGhvcml6b250YWwgPSBfcmVmLmhvcml6b250YWwsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2xlZnQnLCAndG9wJywgJ2NsYXNzTmFtZScsICdiaW5EYXRhJywgJ3N0cm9rZScsICdmaWxsJywgJ29wYWNpdHknLCAnc3Ryb2tlV2lkdGgnLCAnd2lkdGgnLCAndmFsdWVTY2FsZScsICdzdHJva2VEYXNoYXJyYXknLCAnaG9yaXpvbnRhbCddKTtcblxuICB2YXIgY2VudGVyID0gKGhvcml6b250YWwgPyB0b3AgOiBsZWZ0KSArIHdpZHRoIC8gMjtcbiAgdmFyIGJpbkNvdW50cyA9IGJpbkRhdGEubWFwKGZ1bmN0aW9uIChiaW4pIHtcbiAgICByZXR1cm4gYmluLmNvdW50O1xuICB9KTtcbiAgdmFyIHdpZHRoU2NhbGUgPSBzY2FsZUxpbmVhcih7XG4gICAgcmFuZ2VSb3VuZDogWzAsIHdpZHRoIC8gMl0sXG4gICAgZG9tYWluOiBbMCwgTWF0aC5tYXguYXBwbHkoTWF0aCwgdG9Db25zdW1hYmxlQXJyYXkoYmluQ291bnRzKSldXG4gIH0pO1xuXG4gIHZhciBwYXRoID0gJyc7XG4gIGlmIChob3Jpem9udGFsKSB7XG4gICAgdmFyIHRvcEN1cnZlID0gbGluZSgpLngoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiB2YWx1ZVNjYWxlKGQudmFsdWUpO1xuICAgIH0pLnkoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBjZW50ZXIgLSB3aWR0aFNjYWxlKGQuY291bnQpO1xuICAgIH0pLmN1cnZlKGN1cnZlQ2FyZGluYWwpO1xuXG4gICAgdmFyIGJvdHRvbUN1cnZlID0gbGluZSgpLngoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiB2YWx1ZVNjYWxlKGQudmFsdWUpO1xuICAgIH0pLnkoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBjZW50ZXIgKyB3aWR0aFNjYWxlKGQuY291bnQpO1xuICAgIH0pLmN1cnZlKGN1cnZlQ2FyZGluYWwpO1xuXG4gICAgdmFyIHRvcEN1cnZlUGF0aCA9IHRvcEN1cnZlKGJpbkRhdGEpO1xuICAgIHZhciBib3R0b21DdXJ2ZVBhdGggPSBib3R0b21DdXJ2ZShbXS5jb25jYXQodG9Db25zdW1hYmxlQXJyYXkoYmluRGF0YSkpLnJldmVyc2UoKSk7XG4gICAgcGF0aCA9IHRvcEN1cnZlUGF0aCArICcgJyArIGJvdHRvbUN1cnZlUGF0aC5yZXBsYWNlKCdNJywgJ0wnKSArICcgWic7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHJpZ2h0Q3VydmUgPSBsaW5lKCkueChmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIGNlbnRlciArIHdpZHRoU2NhbGUoZC5jb3VudCk7XG4gICAgfSkueShmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIHZhbHVlU2NhbGUoZC52YWx1ZSk7XG4gICAgfSkuY3VydmUoY3VydmVDYXJkaW5hbCk7XG5cbiAgICB2YXIgbGVmdEN1cnZlID0gbGluZSgpLngoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBjZW50ZXIgLSB3aWR0aFNjYWxlKGQuY291bnQpO1xuICAgIH0pLnkoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiB2YWx1ZVNjYWxlKGQudmFsdWUpO1xuICAgIH0pLmN1cnZlKGN1cnZlQ2FyZGluYWwpO1xuXG4gICAgdmFyIHJpZ2h0Q3VydmVQYXRoID0gcmlnaHRDdXJ2ZShiaW5EYXRhKTtcbiAgICB2YXIgbGVmdEN1cnZlUGF0aCA9IGxlZnRDdXJ2ZShbXS5jb25jYXQodG9Db25zdW1hYmxlQXJyYXkoYmluRGF0YSkpLnJldmVyc2UoKSk7XG4gICAgcGF0aCA9IHJpZ2h0Q3VydmVQYXRoICsgJyAnICsgbGVmdEN1cnZlUGF0aC5yZXBsYWNlKCdNJywgJ0wnKSArICcgWic7XG4gIH1cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgR3JvdXAsXG4gICAgeyBjbGFzc05hbWU6IGNsYXNzbmFtZXMoJ3Z4LXZpb2xpbicsIGNsYXNzTmFtZSkgfSxcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgICAgZDogcGF0aCxcbiAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlRGFzaGFycmF5OiBzdHJva2VEYXNoYXJyYXksXG4gICAgICBmaWxsOiBmaWxsLFxuICAgICAgZmlsbE9wYWNpdHk6IG9wYWNpdHlcbiAgICB9LCBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzLCBiaW5EYXRhKSkpXG4gICk7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVTdGF0cyAobnVtZXJpY2FsQXJyYXkpIHtcbiAgdmFyIHBvaW50cyA9IFtdLmNvbmNhdCh0b0NvbnN1bWFibGVBcnJheShudW1lcmljYWxBcnJheSkpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYSAtIGI7XG4gIH0pO1xuICB2YXIgc2FtcGxlU2l6ZSA9IHBvaW50cy5sZW5ndGg7XG4gIHZhciBmaXJzdFF1YXJ0aWxlID0gcG9pbnRzW01hdGgucm91bmQoc2FtcGxlU2l6ZSAvIDQpXTtcbiAgdmFyIHRoaXJkUXVhcnRpbGUgPSBwb2ludHNbTWF0aC5yb3VuZCgzICogc2FtcGxlU2l6ZSAvIDQpXTtcbiAgdmFyIElRUiA9IHRoaXJkUXVhcnRpbGUgLSBmaXJzdFF1YXJ0aWxlO1xuXG4gIHZhciBtaW4gPSBmaXJzdFF1YXJ0aWxlIC0gMS41ICogSVFSO1xuICB2YXIgbWF4ID0gdGhpcmRRdWFydGlsZSArIDEuNSAqIElRUjtcblxuICB2YXIgb3V0bGllcnMgPSBwb2ludHMuZmlsdGVyKGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIHAgPCBtaW4gfHwgcCA+IG1heDtcbiAgfSk7XG4gIHZhciBiaW5XaWR0aCA9IDIgKiBJUVIgKiBNYXRoLnBvdyhzYW1wbGVTaXplIC0gb3V0bGllcnMubGVuZ3RoLCAtMSAvIDMpO1xuICB2YXIgYmluTnVtID0gTWF0aC5yb3VuZCgobWF4IC0gbWluKSAvIGJpbldpZHRoKTtcbiAgdmFyIGFjdHVhbEJpbldpZHRoID0gKG1heCAtIG1pbikgLyBiaW5OdW07XG5cbiAgdmFyIGJpbnMgPSBBcnJheShiaW5OdW0gKyAyKS5maWxsKDApO1xuICB2YXIgdmFsdWVzID0gQXJyYXkoYmluTnVtICsgMikuZmlsbChtaW4pO1xuXG4gIGZvciAodmFyIGkgPSAxOyBpIDw9IGJpbk51bTsgaSArPSAxKSB7XG4gICAgdmFsdWVzW2ldICs9IGFjdHVhbEJpbldpZHRoICogKGkgLSAwLjUpO1xuICB9XG5cbiAgdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXSA9IG1heDtcblxuICBwb2ludHMuZmlsdGVyKGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIHAgPj0gbWluICYmIHAgPD0gbWF4O1xuICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgYmluc1tNYXRoLmZsb29yKChwIC0gbWluKSAvIGFjdHVhbEJpbldpZHRoKSArIDFdICs9IDE7XG4gIH0pO1xuXG4gIHZhciBiaW5EYXRhID0gdmFsdWVzLm1hcChmdW5jdGlvbiAodiwgaSkge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogdixcbiAgICAgIGNvdW50OiBiaW5zW2ldXG4gICAgfTtcbiAgfSk7XG5cbiAgdmFyIGJveFBsb3QgPSB7XG4gICAgbWluOiBtaW4sXG4gICAgZmlyc3RRdWFydGlsZTogZmlyc3RRdWFydGlsZSxcbiAgICBtZWRpYW46IHBvaW50c1tNYXRoLnJvdW5kKHNhbXBsZVNpemUgLyAyKV0sXG4gICAgdGhpcmRRdWFydGlsZTogdGhpcmRRdWFydGlsZSxcbiAgICBtYXg6IG1heCxcbiAgICBvdXRsaWVyczogb3V0bGllcnNcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGJveFBsb3Q6IGJveFBsb3QsXG4gICAgYmluRGF0YTogYmluRGF0YVxuICB9O1xufVxuXG5leHBvcnQgeyBCb3hQbG90LCBWaW9saW5QbG90LCBjb21wdXRlU3RhdHMgfTtcbiIsImZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5pbXBvcnQgeyBCb3hQbG90IH0gZnJvbSAnQHZ4L3N0YXRzJztcbmltcG9ydCB7IEZvY3VzQmx1ckhhbmRsZXIgfSBmcm9tICdAZGF0YS11aS9zaGFyZWQnO1xuaW1wb3J0IHsgR3JvdXAgfSBmcm9tICdAdngvZ3JvdXAnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjb2xvciBhcyB0aGVtZUNvbG9ycyB9IGZyb20gJ0BkYXRhLXVpL3RoZW1lJztcbmltcG9ydCB7IGNhbGxPclZhbHVlLCBpc0RlZmluZWQgfSBmcm9tICcuLi91dGlscy9jaGFydFV0aWxzJztcbmltcG9ydCB7IGJveFBsb3RTZXJpZXNEYXRhU2hhcGUgfSBmcm9tICcuLi91dGlscy9wcm9wU2hhcGVzJztcbmltcG9ydCBzaGFyZWRTZXJpZXNQcm9wcyBmcm9tICcuLi91dGlscy9zaGFyZWRTZXJpZXNQcm9wcyc7XG5cbnZhciBwcm9wVHlwZXMgPSBfZXh0ZW5kcyh7fSwgc2hhcmVkU2VyaWVzUHJvcHMsIHtcbiAgY29udGFpbmVyRXZlbnRzOiBQcm9wVHlwZXMuYm9vbCxcbiAgZGF0YTogYm94UGxvdFNlcmllc0RhdGFTaGFwZS5pc1JlcXVpcmVkLFxuICBmaWxsOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLnN0cmluZ10pLFxuICBob3Jpem9udGFsOiBQcm9wVHlwZXMuYm9vbCxcbiAgc3Ryb2tlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLnN0cmluZ10pLFxuICBzdHJva2VXaWR0aDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgZmlsbE9wYWNpdHk6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gIHdpZHRoUmF0aW86IFByb3BUeXBlcy5udW1iZXIsXG4gIGNvbnRhaW5lclByb3BzOiBQcm9wVHlwZXMub2JqZWN0LFxuICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlYWN0L2ZvcmJpZC1wcm9wLXR5cGVzXG4gIG91dGxpZXJQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcbiAgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZWFjdC9mb3JiaWQtcHJvcC10eXBlc1xuICBib3hQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcbiAgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZWFjdC9mb3JiaWQtcHJvcC10eXBlc1xuICBtaW5Qcm9wczogUHJvcFR5cGVzLm9iamVjdCxcbiAgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZWFjdC9mb3JiaWQtcHJvcC10eXBlc1xuICBtYXhQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcbiAgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZWFjdC9mb3JiaWQtcHJvcC10eXBlc1xuICBtZWRpYW5Qcm9wczogUHJvcFR5cGVzLm9iamVjdCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlYWN0L2ZvcmJpZC1wcm9wLXR5cGVzXG5cbn0pO1xuXG52YXIgZGVmYXVsdFByb3BzID0ge1xuICBjb250YWluZXJFdmVudHM6IHRydWUsXG4gIHN0cm9rZTogdGhlbWVDb2xvcnMuZGFya0dyYXksXG4gIHN0cm9rZVdpZHRoOiAyLFxuICBmaWxsOiB0aGVtZUNvbG9ycy5kZWZhdWx0LFxuICBmaWxsT3BhY2l0eTogMSxcbiAgaG9yaXpvbnRhbDogZmFsc2UsXG4gIHdpZHRoUmF0aW86IDEsXG4gIGNvbnRhaW5lclByb3BzOiBudWxsLFxuICBvdXRsaWVyUHJvcHM6IG51bGwsXG4gIGJveFByb3BzOiBudWxsLFxuICBtaW5Qcm9wczogbnVsbCxcbiAgbWF4UHJvcHM6IG51bGwsXG4gIG1lZGlhblByb3BzOiBudWxsXG59O1xudmFyIE1BWF9CT1hfV0lEVEggPSA1MDtcblxudmFyIHggPSBmdW5jdGlvbiB4KGQpIHtcbiAgcmV0dXJuIGQueDtcbn07XG5cbnZhciB5ID0gZnVuY3Rpb24geShkKSB7XG4gIHJldHVybiBkLnk7XG59O1xuXG52YXIgbWluID0gZnVuY3Rpb24gbWluKGQpIHtcbiAgcmV0dXJuIGQubWluO1xufTtcblxudmFyIG1heCA9IGZ1bmN0aW9uIG1heChkKSB7XG4gIHJldHVybiBkLm1heDtcbn07XG5cbnZhciBtZWRpYW4gPSBmdW5jdGlvbiBtZWRpYW4oZCkge1xuICByZXR1cm4gZC5tZWRpYW47XG59O1xuXG52YXIgZmlyc3RRdWFydGlsZSA9IGZ1bmN0aW9uIGZpcnN0UXVhcnRpbGUoZCkge1xuICByZXR1cm4gZC5maXJzdFF1YXJ0aWxlO1xufTtcblxudmFyIHRoaXJkUXVhcnRpbGUgPSBmdW5jdGlvbiB0aGlyZFF1YXJ0aWxlKGQpIHtcbiAgcmV0dXJuIGQudGhpcmRRdWFydGlsZTtcbn07XG5cbnZhciBvdXRsaWVycyA9IGZ1bmN0aW9uIG91dGxpZXJzKGQpIHtcbiAgcmV0dXJuIGQub3V0bGllcnMgfHwgW107XG59O1xuXG52YXIgQm94UGxvdFNlcmllcyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1JlYWN0JFB1cmVDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoQm94UGxvdFNlcmllcywgX1JlYWN0JFB1cmVDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIEJveFBsb3RTZXJpZXMoKSB7XG4gICAgcmV0dXJuIF9SZWFjdCRQdXJlQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBCb3hQbG90U2VyaWVzLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIGNvbnRhaW5lckV2ZW50cyA9IF90aGlzJHByb3BzLmNvbnRhaW5lckV2ZW50cyxcbiAgICAgICAgZGF0YSA9IF90aGlzJHByb3BzLmRhdGEsXG4gICAgICAgIGZpbGwgPSBfdGhpcyRwcm9wcy5maWxsLFxuICAgICAgICBzdHJva2UgPSBfdGhpcyRwcm9wcy5zdHJva2UsXG4gICAgICAgIHN0cm9rZVdpZHRoID0gX3RoaXMkcHJvcHMuc3Ryb2tlV2lkdGgsXG4gICAgICAgIHhTY2FsZSA9IF90aGlzJHByb3BzLnhTY2FsZSxcbiAgICAgICAgeVNjYWxlID0gX3RoaXMkcHJvcHMueVNjYWxlLFxuICAgICAgICBob3Jpem9udGFsID0gX3RoaXMkcHJvcHMuaG9yaXpvbnRhbCxcbiAgICAgICAgd2lkdGhSYXRpbyA9IF90aGlzJHByb3BzLndpZHRoUmF0aW8sXG4gICAgICAgIGZpbGxPcGFjaXR5ID0gX3RoaXMkcHJvcHMuZmlsbE9wYWNpdHksXG4gICAgICAgIGNvbnRhaW5lclByb3BzID0gX3RoaXMkcHJvcHMuY29udGFpbmVyUHJvcHMsXG4gICAgICAgIG91dGxpZXJQcm9wcyA9IF90aGlzJHByb3BzLm91dGxpZXJQcm9wcyxcbiAgICAgICAgYm94UHJvcHMgPSBfdGhpcyRwcm9wcy5ib3hQcm9wcyxcbiAgICAgICAgbWluUHJvcHMgPSBfdGhpcyRwcm9wcy5taW5Qcm9wcyxcbiAgICAgICAgbWF4UHJvcHMgPSBfdGhpcyRwcm9wcy5tYXhQcm9wcyxcbiAgICAgICAgbWVkaWFuUHJvcHMgPSBfdGhpcyRwcm9wcy5tZWRpYW5Qcm9wcyxcbiAgICAgICAgb25Nb3VzZU1vdmUgPSBfdGhpcyRwcm9wcy5vbk1vdXNlTW92ZSxcbiAgICAgICAgb25Nb3VzZUxlYXZlID0gX3RoaXMkcHJvcHMub25Nb3VzZUxlYXZlLFxuICAgICAgICBkaXNhYmxlTW91c2VFdmVudHMgPSBfdGhpcyRwcm9wcy5kaXNhYmxlTW91c2VFdmVudHMsXG4gICAgICAgIG9uQ2xpY2sgPSBfdGhpcyRwcm9wcy5vbkNsaWNrO1xuICAgIGlmICgheFNjYWxlIHx8ICF5U2NhbGUpIHJldHVybiBudWxsO1xuICAgIHZhciBvZmZzZXRTY2FsZSA9IGhvcml6b250YWwgPyB5U2NhbGUgOiB4U2NhbGU7XG4gICAgdmFyIG9mZnNldFZhbHVlID0gaG9yaXpvbnRhbCA/IHkgOiB4O1xuICAgIHZhciB2YWx1ZVNjYWxlID0gaG9yaXpvbnRhbCA/IHhTY2FsZSA6IHlTY2FsZTtcbiAgICB2YXIgYm94V2lkdGggPSBvZmZzZXRTY2FsZS5iYW5kd2lkdGgoKTtcbiAgICB2YXIgYWN0dWFsV2lkdGggPSBNYXRoLm1pbihNQVhfQk9YX1dJRFRILCBib3hXaWR0aCk7XG4gICAgdmFyIG9mZnNldCA9IChvZmZzZXRTY2FsZS5vZmZzZXQgfHwgMCkgLSAoYm94V2lkdGggLSBhY3R1YWxXaWR0aCkgLyAyO1xuICAgIHZhciBvZmZzZXRQcm9wTmFtZSA9IGhvcml6b250YWwgPyAndG9wJyA6ICdsZWZ0JztcblxuICAgIHZhciBvZmZzZXRQcm9wID0gZnVuY3Rpb24gb2Zmc2V0UHJvcChkKSB7XG4gICAgICB2YXIgX3JlZjtcblxuICAgICAgcmV0dXJuIF9yZWYgPSB7fSwgX3JlZltvZmZzZXRQcm9wTmFtZV0gPSBvZmZzZXRTY2FsZShvZmZzZXRWYWx1ZShkKSkgLSBvZmZzZXQgKyAoMSAtIHdpZHRoUmF0aW8pIC8gMiAqIGFjdHVhbFdpZHRoLCBfcmVmO1xuICAgIH07XG5cbiAgICB2YXIgbW91c2VFdmVudFByb3BzID0gZnVuY3Rpb24gbW91c2VFdmVudFByb3BzKGQsIGkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9uTW91c2VNb3ZlOiBkaXNhYmxlTW91c2VFdmVudHMgPyBudWxsIDogb25Nb3VzZU1vdmUgJiYgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIG9uTW91c2VNb3ZlKHtcbiAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICBkYXR1bTogZCxcbiAgICAgICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIG9uTW91c2VMZWF2ZTogZGlzYWJsZU1vdXNlRXZlbnRzID8gbnVsbCA6IG9uTW91c2VMZWF2ZSAmJiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIG9uTW91c2VMZWF2ZTtcbiAgICAgICAgfSxcbiAgICAgICAgb25DbGljazogZGlzYWJsZU1vdXNlRXZlbnRzID8gbnVsbCA6IG9uQ2xpY2sgJiYgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIG9uQ2xpY2soe1xuICAgICAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICAgIGRhdHVtOiBkLFxuICAgICAgICAgICAgICBpbmRleDogaVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoR3JvdXAsIG51bGwsIGRhdGEubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICB2YXIgbW91c2VFdmVudHMgPSBtb3VzZUV2ZW50UHJvcHMoZCwgaSk7XG4gICAgICByZXR1cm4gaXNEZWZpbmVkKG1pbihkKSkgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChGb2N1c0JsdXJIYW5kbGVyLCB7XG4gICAgICAgIGtleTogb2Zmc2V0VmFsdWUoZCksXG4gICAgICAgIHhsaW5rSHJlZjogXCIjXCIsXG4gICAgICAgIG9uQmx1cjogZGlzYWJsZU1vdXNlRXZlbnRzID8gbnVsbCA6IG9uTW91c2VMZWF2ZSxcbiAgICAgICAgb25Gb2N1czogZGlzYWJsZU1vdXNlRXZlbnRzID8gbnVsbCA6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIG9uTW91c2VNb3ZlKHtcbiAgICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICBkYXR1bTogZCxcbiAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQm94UGxvdCwgX2V4dGVuZHMoe1xuICAgICAgICBtaW46IG1pbihkKSxcbiAgICAgICAgbWF4OiBtYXgoZClcbiAgICAgIH0sIG9mZnNldFByb3AoZCksIHtcbiAgICAgICAgZmlyc3RRdWFydGlsZTogZmlyc3RRdWFydGlsZShkKSxcbiAgICAgICAgdGhpcmRRdWFydGlsZTogdGhpcmRRdWFydGlsZShkKSxcbiAgICAgICAgbWVkaWFuOiBtZWRpYW4oZCksXG4gICAgICAgIGJveFdpZHRoOiBhY3R1YWxXaWR0aCAqIHdpZHRoUmF0aW8sXG4gICAgICAgIG91dGxpZXJzOiBvdXRsaWVycyhkKSxcbiAgICAgICAgZmlsbDogZC5maWxsIHx8IGNhbGxPclZhbHVlKGZpbGwsIGQsIGkpLFxuICAgICAgICBzdHJva2U6IGQuc3Ryb2tlIHx8IGNhbGxPclZhbHVlKHN0cm9rZSwgZCwgaSksXG4gICAgICAgIHN0cm9rZVdpZHRoOiBkLnN0cm9rZVdpZHRoIHx8IGNhbGxPclZhbHVlKHN0cm9rZVdpZHRoLCBkLCBpKSxcbiAgICAgICAgZmlsbE9wYWNpdHk6IGQuZmlsbE9wYWNpdHkgfHwgY2FsbE9yVmFsdWUoZmlsbE9wYWNpdHksIGQsIGkpLFxuICAgICAgICB2YWx1ZVNjYWxlOiB2YWx1ZVNjYWxlLFxuICAgICAgICBob3Jpem9udGFsOiBob3Jpem9udGFsLFxuICAgICAgICBjb250YWluZXI6IGNvbnRhaW5lckV2ZW50cyxcbiAgICAgICAgY29udGFpbmVyUHJvcHM6IChjb250YWluZXJFdmVudHMgfHwgY29udGFpbmVyUHJvcHMgfHwgdW5kZWZpbmVkKSAmJiBfZXh0ZW5kcyh7fSwgY29udGFpbmVyUHJvcHMsIGNvbnRhaW5lckV2ZW50cyAmJiBtb3VzZUV2ZW50cyksXG4gICAgICAgIG91dGxpZXJQcm9wczogKCFjb250YWluZXJFdmVudHMgfHwgb3V0bGllclByb3BzIHx8IHVuZGVmaW5lZCkgJiYgX2V4dGVuZHMoe30sIG91dGxpZXJQcm9wcywgIWNvbnRhaW5lckV2ZW50cyAmJiBtb3VzZUV2ZW50cyksXG4gICAgICAgIGJveFByb3BzOiAoIWNvbnRhaW5lckV2ZW50cyB8fCBib3hQcm9wcyB8fCB1bmRlZmluZWQpICYmIF9leHRlbmRzKHt9LCBib3hQcm9wcywgIWNvbnRhaW5lckV2ZW50cyAmJiBtb3VzZUV2ZW50cyksXG4gICAgICAgIG1pblByb3BzOiAoIWNvbnRhaW5lckV2ZW50cyB8fCBtaW5Qcm9wcyB8fCB1bmRlZmluZWQpICYmIF9leHRlbmRzKHt9LCBtaW5Qcm9wcywgIWNvbnRhaW5lckV2ZW50cyAmJiBtb3VzZUV2ZW50cyksXG4gICAgICAgIG1heFByb3BzOiAoIWNvbnRhaW5lckV2ZW50cyB8fCBtYXhQcm9wcyB8fCB1bmRlZmluZWQpICYmIF9leHRlbmRzKHt9LCBtYXhQcm9wcywgIWNvbnRhaW5lckV2ZW50cyAmJiBtb3VzZUV2ZW50cyksXG4gICAgICAgIG1lZGlhblByb3BzOiAoIWNvbnRhaW5lckV2ZW50cyB8fCBtZWRpYW5Qcm9wcyB8fCB1bmRlZmluZWQpICYmIF9leHRlbmRzKHt9LCBtZWRpYW5Qcm9wcywgIWNvbnRhaW5lckV2ZW50cyAmJiBtb3VzZUV2ZW50cylcbiAgICAgIH0pKSk7XG4gICAgfSkpO1xuICB9O1xuXG4gIHJldHVybiBCb3hQbG90U2VyaWVzO1xufShSZWFjdC5QdXJlQ29tcG9uZW50KTtcblxuZXhwb3J0IHsgQm94UGxvdFNlcmllcyBhcyBkZWZhdWx0IH07XG5Cb3hQbG90U2VyaWVzLnByb3BUeXBlcyA9IHByb3BUeXBlcztcbkJveFBsb3RTZXJpZXMuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuQm94UGxvdFNlcmllcy5kaXNwbGF5TmFtZSA9ICdCb3hQbG90U2VyaWVzJzsiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgaXNEZWZpbmVkLCBUb29sdGlwRnJhbWUsIFRvb2x0aXBUYWJsZSB9IGZyb20gJ0BzdXBlcnNldC11aS9jb3JlJztcbmltcG9ydCB7IEJveFBsb3RFbmNvZGVyIH0gZnJvbSAnLi9FbmNvZGVyJztcbmltcG9ydCB7IEJveFBsb3REYXRhUm93IH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERlZmF1bHRUb29sdGlwUmVuZGVyZXIoe1xuICBkYXR1bSxcbiAgY29sb3IsXG4gIGVuY29kZXIsXG59OiB7XG4gIGRhdHVtOiBCb3hQbG90RGF0YVJvdztcbiAgY29sb3I6IHN0cmluZztcbiAgZW5jb2RlcjogQm94UGxvdEVuY29kZXI7XG59KSB7XG4gIGNvbnN0IHsgbGFiZWwsIG1pbiwgbWF4LCBtZWRpYW4sIGZpcnN0UXVhcnRpbGUsIHRoaXJkUXVhcnRpbGUsIG91dGxpZXJzIH0gPSBkYXR1bTtcbiAgY29uc3QgeyBjaGFubmVscyB9ID0gZW5jb2RlcjtcblxuICBjb25zdCB7IGZvcm1hdFZhbHVlIH0gPSBjaGFubmVscy55O1xuXG4gIGNvbnN0IGRhdGE6IHsga2V5OiBzdHJpbmc7IHZhbHVlQ29sdW1uOiBudW1iZXIgfCBzdHJpbmcgfVtdID0gW107XG4gIGlmIChpc0RlZmluZWQobWluKSkge1xuICAgIGRhdGEucHVzaCh7IGtleTogJ01pbicsIHZhbHVlQ29sdW1uOiBmb3JtYXRWYWx1ZShtaW4pIH0pO1xuICB9XG4gIGlmIChpc0RlZmluZWQobWF4KSkge1xuICAgIGRhdGEucHVzaCh7IGtleTogJ01heCcsIHZhbHVlQ29sdW1uOiBmb3JtYXRWYWx1ZShtYXgpIH0pO1xuICB9XG4gIGlmIChpc0RlZmluZWQobWVkaWFuKSkge1xuICAgIGRhdGEucHVzaCh7IGtleTogJ01lZGlhbicsIHZhbHVlQ29sdW1uOiBmb3JtYXRWYWx1ZShtZWRpYW4pIH0pO1xuICB9XG4gIGlmIChpc0RlZmluZWQoZmlyc3RRdWFydGlsZSkpIHtcbiAgICBkYXRhLnB1c2goeyBrZXk6ICcxc3QgUXVhcnRpbGUnLCB2YWx1ZUNvbHVtbjogZm9ybWF0VmFsdWUoZmlyc3RRdWFydGlsZSkgfSk7XG4gIH1cbiAgaWYgKGlzRGVmaW5lZCh0aGlyZFF1YXJ0aWxlKSkge1xuICAgIGRhdGEucHVzaCh7IGtleTogJzNyZCBRdWFydGlsZScsIHZhbHVlQ29sdW1uOiBmb3JtYXRWYWx1ZSh0aGlyZFF1YXJ0aWxlKSB9KTtcbiAgfVxuICBpZiAoaXNEZWZpbmVkKG91dGxpZXJzKSAmJiBvdXRsaWVycy5sZW5ndGggPiAwKSB7XG4gICAgZGF0YS5wdXNoKHsga2V5OiAnIyBPdXRsaWVycycsIHZhbHVlQ29sdW1uOiBvdXRsaWVycy5sZW5ndGggfSk7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxUb29sdGlwRnJhbWU+XG4gICAgICA8ZGl2PlxuICAgICAgICA8c3Ryb25nIHN0eWxlPXt7IGNvbG9yIH19PntsYWJlbH08L3N0cm9uZz5cbiAgICAgIDwvZGl2PlxuICAgICAge2RhdGEubGVuZ3RoID4gMCAmJiA8YnIgLz59XG4gICAgICA8VG9vbHRpcFRhYmxlIGRhdGE9e2RhdGF9IC8+XG4gICAgPC9Ub29sdGlwRnJhbWU+XG4gICk7XG59XG4iLCJpbXBvcnQgeyBjcmVhdGVFbmNvZGVyRmFjdG9yeSwgRW5jb2RlciwgRGVyaXZlRW5jb2RpbmcgfSBmcm9tICdlbmNvZGFibGUnO1xuXG5leHBvcnQgdHlwZSBCb3hQbG90RW5jb2RpbmdDb25maWcgPSB7XG4gIHg6IFsnWEJhbmQnLCBudW1iZXJdO1xuICB5OiBbJ1lCYW5kJywgbnVtYmVyXTtcbiAgY29sb3I6IFsnQ29sb3InLCBzdHJpbmddO1xufTtcblxuZXhwb3J0IGNvbnN0IGJveFBsb3RFbmNvZGVyRmFjdG9yeSA9IGNyZWF0ZUVuY29kZXJGYWN0b3J5PEJveFBsb3RFbmNvZGluZ0NvbmZpZz4oe1xuICBjaGFubmVsVHlwZXM6IHtcbiAgICB4OiAnWEJhbmQnLFxuICAgIHk6ICdZQmFuZCcsXG4gICAgY29sb3I6ICdDb2xvcicsXG4gIH0sXG4gIGRlZmF1bHRFbmNvZGluZzoge1xuICAgIHg6IHsgZmllbGQ6ICd4JywgdHlwZTogJ25vbWluYWwnIH0sXG4gICAgeTogeyBmaWVsZDogJ3knLCB0eXBlOiAncXVhbnRpdGF0aXZlJyB9LFxuICAgIGNvbG9yOiB7IHZhbHVlOiAnIzIyMicgfSxcbiAgfSxcbn0pO1xuXG5leHBvcnQgdHlwZSBCb3hQbG90RW5jb2RpbmcgPSBEZXJpdmVFbmNvZGluZzxCb3hQbG90RW5jb2RpbmdDb25maWc+O1xuXG5leHBvcnQgdHlwZSBCb3hQbG90RW5jb2RlciA9IEVuY29kZXI8Qm94UGxvdEVuY29kaW5nQ29uZmlnPjtcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBCb3hQbG90U2VyaWVzLCBYWUNoYXJ0IH0gZnJvbSAnQGRhdGEtdWkveHktY2hhcnQnO1xuaW1wb3J0IHsgY2hhcnRUaGVtZSwgQ2hhcnRUaGVtZSB9IGZyb20gJ0BkYXRhLXVpL3RoZW1lJztcbmltcG9ydCB7IFdpdGhMZWdlbmQsIE1hcmdpbiwgRGltZW5zaW9uIH0gZnJvbSAnQHN1cGVyc2V0LXVpL2NvcmUnO1xuaW1wb3J0IHsgRGF0YXNldCwgUGxhaW5PYmplY3QsIGlzRmllbGREZWYgfSBmcm9tICdlbmNvZGFibGUnO1xuaW1wb3J0IERlZmF1bHRUb29sdGlwUmVuZGVyZXIgZnJvbSAnLi9EZWZhdWx0VG9vbHRpcFJlbmRlcmVyJztcbmltcG9ydCB7XG4gIEJveFBsb3RFbmNvZGluZ0NvbmZpZyxcbiAgQm94UGxvdEVuY29kaW5nLFxuICBCb3hQbG90RW5jb2RlcixcbiAgYm94UGxvdEVuY29kZXJGYWN0b3J5LFxufSBmcm9tICcuL0VuY29kZXInO1xuaW1wb3J0IGNyZWF0ZU1hcmdpblNlbGVjdG9yLCB7IERFRkFVTFRfTUFSR0lOIH0gZnJvbSAnLi4vLi4vdXRpbHMvY3JlYXRlTWFyZ2luU2VsZWN0b3InO1xuaW1wb3J0IHsgQm94UGxvdERhdGFSb3cgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCBjb252ZXJ0U2NhbGVUb0RhdGFVSVNjYWxlIGZyb20gJy4uLy4uL3V0aWxzL2NvbnZlcnRTY2FsZVRvRGF0YVVJU2NhbGVTaGFwZSc7XG5pbXBvcnQgY3JlYXRlWFlDaGFydExheW91dFdpdGhUaGVtZSBmcm9tICcuLi8uLi91dGlscy9jcmVhdGVYWUNoYXJ0TGF5b3V0V2l0aFRoZW1lJztcbmltcG9ydCBjcmVhdGVSZW5kZXJMZWdlbmQgZnJvbSAnLi4vbGVnZW5kL2NyZWF0ZVJlbmRlckxlZ2VuZCc7XG5pbXBvcnQgeyBMZWdlbmRIb29rcyB9IGZyb20gJy4uL2xlZ2VuZC90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVG9vbHRpcFByb3BzIHtcbiAgZGF0dW06IEJveFBsb3REYXRhUm93O1xuICBjb2xvcjogc3RyaW5nO1xuICBlbmNvZGVyOiBCb3hQbG90RW5jb2Rlcjtcbn1cblxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBjbGFzc05hbWU6ICcnLFxuICBtYXJnaW46IERFRkFVTFRfTUFSR0lOLFxuICBlbmNvZGluZzoge30sXG4gIHRoZW1lOiBjaGFydFRoZW1lLFxuICBUb29sdGlwUmVuZGVyZXI6IERlZmF1bHRUb29sdGlwUmVuZGVyZXIsXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgdHlwZSBIb29rUHJvcHMgPSB7XG4gIFRvb2x0aXBSZW5kZXJlcj86IFJlYWN0LkNvbXBvbmVudFR5cGU8VG9vbHRpcFByb3BzPjtcbn0gJiBMZWdlbmRIb29rczxCb3hQbG90RW5jb2RpbmdDb25maWc+O1xuXG50eXBlIFByb3BzID0ge1xuICBjbGFzc05hbWU/OiBzdHJpbmc7XG4gIHdpZHRoOiBzdHJpbmcgfCBudW1iZXI7XG4gIGhlaWdodDogc3RyaW5nIHwgbnVtYmVyO1xuICBtYXJnaW4/OiBNYXJnaW47XG4gIGVuY29kaW5nPzogUGFydGlhbDxCb3hQbG90RW5jb2Rpbmc+O1xuICBkYXRhOiBEYXRhc2V0O1xuICB0aGVtZT86IENoYXJ0VGhlbWU7XG59ICYgSG9va1Byb3BzICZcbiAgUmVhZG9ubHk8dHlwZW9mIGRlZmF1bHRQcm9wcz47XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJveFBsb3QgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50PFByb3BzPiB7XG4gIHByaXZhdGUgY3JlYXRlRW5jb2RlciA9IGJveFBsb3RFbmNvZGVyRmFjdG9yeS5jcmVhdGVTZWxlY3RvcigpO1xuXG4gIHByaXZhdGUgY3JlYXRlTWFyZ2luID0gY3JlYXRlTWFyZ2luU2VsZWN0b3IoKTtcblxuICBzdGF0aWMgZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuXG4gIHJlbmRlckNoYXJ0ID0gKGRpbTogRGltZW5zaW9uKSA9PiB7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBkaW07XG4gICAgY29uc3QgeyBkYXRhLCBtYXJnaW4sIHRoZW1lLCBUb29sdGlwUmVuZGVyZXIsIGVuY29kaW5nIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGVuY29kZXIgPSB0aGlzLmNyZWF0ZUVuY29kZXIoZW5jb2RpbmcpO1xuICAgIGNvbnN0IHsgY2hhbm5lbHMgfSA9IGVuY29kZXI7XG5cbiAgICBjb25zdCBpc0hvcml6b250YWwgPVxuICAgICAgaXNGaWVsZERlZihjaGFubmVscy55LmRlZmluaXRpb24pICYmIGNoYW5uZWxzLnkuZGVmaW5pdGlvbi50eXBlID09PSAnbm9taW5hbCc7XG5cbiAgICBlbmNvZGVyLnNldERvbWFpbkZyb21EYXRhc2V0KGRhdGEpO1xuXG4gICAgY29uc3QgbGF5b3V0ID0gY3JlYXRlWFlDaGFydExheW91dFdpdGhUaGVtZSh7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIG1hcmdpbjogdGhpcy5jcmVhdGVNYXJnaW4obWFyZ2luKSxcbiAgICAgIHRoZW1lLFxuICAgICAgeEVuY29kZXI6IGNoYW5uZWxzLngsXG4gICAgICB5RW5jb2RlcjogY2hhbm5lbHMueSxcbiAgICB9KTtcblxuICAgIHJldHVybiBsYXlvdXQucmVuZGVyQ2hhcnRXaXRoRnJhbWUoKGNoYXJ0RGltOiBEaW1lbnNpb24pID0+IChcbiAgICAgIDxYWUNoYXJ0XG4gICAgICAgIHNob3dZR3JpZFxuICAgICAgICB3aWR0aD17Y2hhcnREaW0ud2lkdGh9XG4gICAgICAgIGhlaWdodD17Y2hhcnREaW0uaGVpZ2h0fVxuICAgICAgICBhcmlhTGFiZWw9XCJCb3hQbG90XCJcbiAgICAgICAgbWFyZ2luPXtsYXlvdXQubWFyZ2lufVxuICAgICAgICByZW5kZXJUb29sdGlwPXsoeyBkYXR1bSwgY29sb3IgfTogeyBkYXR1bTogQm94UGxvdERhdGFSb3c7IGNvbG9yOiBzdHJpbmcgfSkgPT4gKFxuICAgICAgICAgIDxUb29sdGlwUmVuZGVyZXIgZGF0dW09e2RhdHVtfSBjb2xvcj17Y29sb3J9IGVuY29kZXI9e2VuY29kZXJ9IC8+XG4gICAgICAgICl9XG4gICAgICAgIHRoZW1lPXt0aGVtZX1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgeFNjYWxlPXtjb252ZXJ0U2NhbGVUb0RhdGFVSVNjYWxlKGNoYW5uZWxzLnguZGVmaW5pdGlvbi5zY2FsZSBhcyBhbnkpfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICB5U2NhbGU9e2NvbnZlcnRTY2FsZVRvRGF0YVVJU2NhbGUoY2hhbm5lbHMueS5kZWZpbml0aW9uLnNjYWxlIGFzIGFueSl9XG4gICAgICA+XG4gICAgICAgIHtsYXlvdXQucmVuZGVyWEF4aXMoKX1cbiAgICAgICAge2xheW91dC5yZW5kZXJZQXhpcygpfVxuICAgICAgICA8Qm94UGxvdFNlcmllc1xuICAgICAgICAgIGtleT17aXNGaWVsZERlZihjaGFubmVscy54LmRlZmluaXRpb24pID8gY2hhbm5lbHMueC5kZWZpbml0aW9uLmZpZWxkIDogJyd9XG4gICAgICAgICAgYW5pbWF0ZWRcbiAgICAgICAgICBkYXRhPXtcbiAgICAgICAgICAgIGlzSG9yaXpvbnRhbFxuICAgICAgICAgICAgICA/IGRhdGEubWFwKHJvdyA9PiAoeyAuLi5yb3csIHk6IGNoYW5uZWxzLnkuZ2V0VmFsdWVGcm9tRGF0dW0ocm93KSB9KSlcbiAgICAgICAgICAgICAgOiBkYXRhLm1hcChyb3cgPT4gKHsgLi4ucm93LCB4OiBjaGFubmVscy54LmdldFZhbHVlRnJvbURhdHVtKHJvdykgfSkpXG4gICAgICAgICAgfVxuICAgICAgICAgIGZpbGw9eyhkYXR1bTogUGxhaW5PYmplY3QpID0+IGNoYW5uZWxzLmNvbG9yLmVuY29kZURhdHVtKGRhdHVtLCAnIzU1YWNlZScpfVxuICAgICAgICAgIGZpbGxPcGFjaXR5PXswLjR9XG4gICAgICAgICAgc3Ryb2tlPXsoZGF0dW06IFBsYWluT2JqZWN0KSA9PiBjaGFubmVscy5jb2xvci5lbmNvZGVEYXR1bShkYXR1bSl9XG4gICAgICAgICAgc3Ryb2tlV2lkdGg9ezF9XG4gICAgICAgICAgd2lkdGhSYXRpbz17MC42fVxuICAgICAgICAgIGhvcml6b250YWw9e2lzSG9yaXpvbnRhbH1cbiAgICAgICAgLz5cbiAgICAgIDwvWFlDaGFydD5cbiAgICApKTtcbiAgfTtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBjbGFzc05hbWUsIGRhdGEsIGVuY29kaW5nLCB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzLnByb3BzO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxXaXRoTGVnZW5kXG4gICAgICAgIGNsYXNzTmFtZT17YHN1cGVyc2V0LWNoYXJ0LWJveC1wbG90ICR7Y2xhc3NOYW1lfWB9XG4gICAgICAgIHdpZHRoPXt3aWR0aH1cbiAgICAgICAgaGVpZ2h0PXtoZWlnaHR9XG4gICAgICAgIHBvc2l0aW9uPVwidG9wXCJcbiAgICAgICAgcmVuZGVyTGVnZW5kPXtjcmVhdGVSZW5kZXJMZWdlbmQodGhpcy5jcmVhdGVFbmNvZGVyKGVuY29kaW5nKSwgZGF0YSwgdGhpcy5wcm9wcyl9XG4gICAgICAgIHJlbmRlckNoYXJ0PXt0aGlzLnJlbmRlckNoYXJ0fVxuICAgICAgLz5cbiAgICApO1xuICB9XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNuR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDSkE7QUFDQTtBQUNBOzs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZGQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUlBO0FBQ0E7QUFJQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFPQTtBQUNBO0FBR0E7QUFDQTtBQU9BO0FBQ0E7QUFHQTs7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDdE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25kQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hOQTtBQUNBO0FBSUE7QUFTQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFHQTs7Ozs7O0FDaERBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUVBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaUJBO0FBQUE7O0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBV0E7QUFnQkE7QUFkQTtBQUNBO0FBRUE7QUFVQTs7QUF4RUE7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2494\n')}}]);