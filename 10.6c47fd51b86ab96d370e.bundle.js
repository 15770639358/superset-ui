(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{1936:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return isValueDef; });\n/* unused harmony export isNonValueDef */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return isFieldDef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return isTypedFieldDef; });\n/* unused harmony export isScaleFieldDef */\n/* unused harmony export isPositionFieldDef */\nfunction isValueDef(channelDef) {\n  return channelDef && 'value' in channelDef;\n}\nfunction isNonValueDef(channelDef) {\n  return channelDef && !('value' in channelDef);\n}\nfunction isFieldDef(channelDef) {\n  return channelDef && 'field' in channelDef && !!channelDef.field;\n}\nfunction isTypedFieldDef(channelDef) {\n  return isFieldDef(channelDef) && 'type' in channelDef && !!channelDef.type;\n}\nfunction isScaleFieldDef(channelDef) {\n  return isTypedFieldDef(channelDef) && 'scale' in channelDef;\n}\nfunction isPositionFieldDef(channelDef) {\n  return isTypedFieldDef(channelDef) && 'axis' in channelDef;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkzNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vdHlwZUd1YXJkcy9DaGFubmVsRGVmLmpzPzg2NmQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGlzVmFsdWVEZWYoY2hhbm5lbERlZikge1xuICByZXR1cm4gY2hhbm5lbERlZiAmJiAndmFsdWUnIGluIGNoYW5uZWxEZWY7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNOb25WYWx1ZURlZihjaGFubmVsRGVmKSB7XG4gIHJldHVybiBjaGFubmVsRGVmICYmICEoJ3ZhbHVlJyBpbiBjaGFubmVsRGVmKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0ZpZWxkRGVmKGNoYW5uZWxEZWYpIHtcbiAgcmV0dXJuIGNoYW5uZWxEZWYgJiYgJ2ZpZWxkJyBpbiBjaGFubmVsRGVmICYmICEhY2hhbm5lbERlZi5maWVsZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1R5cGVkRmllbGREZWYoY2hhbm5lbERlZikge1xuICByZXR1cm4gaXNGaWVsZERlZihjaGFubmVsRGVmKSAmJiAndHlwZScgaW4gY2hhbm5lbERlZiAmJiAhIWNoYW5uZWxEZWYudHlwZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1NjYWxlRmllbGREZWYoY2hhbm5lbERlZikge1xuICByZXR1cm4gaXNUeXBlZEZpZWxkRGVmKGNoYW5uZWxEZWYpICYmICdzY2FsZScgaW4gY2hhbm5lbERlZjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1Bvc2l0aW9uRmllbGREZWYoY2hhbm5lbERlZikge1xuICByZXR1cm4gaXNUeXBlZEZpZWxkRGVmKGNoYW5uZWxEZWYpICYmICdheGlzJyBpbiBjaGFubmVsRGVmO1xufSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1936\n")},1951:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1945);\n\n\n/* harmony default export */ __webpack_exports__["a"] = ({\n  draw: function(context, size) {\n    var r = Math.sqrt(size / _math_js__WEBPACK_IMPORTED_MODULE_0__[/* pi */ "j"]);\n    context.moveTo(r, 0);\n    context.arc(0, 0, r, 0, _math_js__WEBPACK_IMPORTED_MODULE_0__[/* tau */ "m"]);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk1MS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvY2lyY2xlLmpzPzlkYWMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtwaSwgdGF1fSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUpIHtcbiAgICB2YXIgciA9IE1hdGguc3FydChzaXplIC8gcGkpO1xuICAgIGNvbnRleHQubW92ZVRvKHIsIDApO1xuICAgIGNvbnRleHQuYXJjKDAsIDAsIHIsIDAsIHRhdSk7XG4gIH1cbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1951\n')},1952:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony default export */ __webpack_exports__["a"] = ({\n  draw: function(context, size) {\n    var r = Math.sqrt(size / 5) / 2;\n    context.moveTo(-3 * r, -r);\n    context.lineTo(-r, -r);\n    context.lineTo(-r, -3 * r);\n    context.lineTo(r, -3 * r);\n    context.lineTo(r, -r);\n    context.lineTo(3 * r, -r);\n    context.lineTo(3 * r, r);\n    context.lineTo(r, r);\n    context.lineTo(r, 3 * r);\n    context.lineTo(-r, 3 * r);\n    context.lineTo(-r, r);\n    context.lineTo(-3 * r, r);\n    context.closePath();\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk1Mi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvY3Jvc3MuanM/NmY4NSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCB7XG4gIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUpIHtcbiAgICB2YXIgciA9IE1hdGguc3FydChzaXplIC8gNSkgLyAyO1xuICAgIGNvbnRleHQubW92ZVRvKC0zICogciwgLXIpO1xuICAgIGNvbnRleHQubGluZVRvKC1yLCAtcik7XG4gICAgY29udGV4dC5saW5lVG8oLXIsIC0zICogcik7XG4gICAgY29udGV4dC5saW5lVG8ociwgLTMgKiByKTtcbiAgICBjb250ZXh0LmxpbmVUbyhyLCAtcik7XG4gICAgY29udGV4dC5saW5lVG8oMyAqIHIsIC1yKTtcbiAgICBjb250ZXh0LmxpbmVUbygzICogciwgcik7XG4gICAgY29udGV4dC5saW5lVG8ociwgcik7XG4gICAgY29udGV4dC5saW5lVG8ociwgMyAqIHIpO1xuICAgIGNvbnRleHQubGluZVRvKC1yLCAzICogcik7XG4gICAgY29udGV4dC5saW5lVG8oLXIsIHIpO1xuICAgIGNvbnRleHQubGluZVRvKC0zICogciwgcik7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1952\n')},1953:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('var tan30 = Math.sqrt(1 / 3),\n    tan30_2 = tan30 * 2;\n\n/* harmony default export */ __webpack_exports__["a"] = ({\n  draw: function(context, size) {\n    var y = Math.sqrt(size / tan30_2),\n        x = y * tan30;\n    context.moveTo(0, -y);\n    context.lineTo(x, 0);\n    context.lineTo(0, y);\n    context.lineTo(-x, 0);\n    context.closePath();\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk1My5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvZGlhbW9uZC5qcz8wZjA0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciB0YW4zMCA9IE1hdGguc3FydCgxIC8gMyksXG4gICAgdGFuMzBfMiA9IHRhbjMwICogMjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplKSB7XG4gICAgdmFyIHkgPSBNYXRoLnNxcnQoc2l6ZSAvIHRhbjMwXzIpLFxuICAgICAgICB4ID0geSAqIHRhbjMwO1xuICAgIGNvbnRleHQubW92ZVRvKDAsIC15KTtcbiAgICBjb250ZXh0LmxpbmVUbyh4LCAwKTtcbiAgICBjb250ZXh0LmxpbmVUbygwLCB5KTtcbiAgICBjb250ZXh0LmxpbmVUbygteCwgMCk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1953\n')},1954:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony default export */ __webpack_exports__["a"] = ({\n  draw: function(context, size) {\n    var w = Math.sqrt(size),\n        x = -w / 2;\n    context.rect(x, x, w, w);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk1NC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvc3F1YXJlLmpzP2E5OWQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQge1xuICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplKSB7XG4gICAgdmFyIHcgPSBNYXRoLnNxcnQoc2l6ZSksXG4gICAgICAgIHggPSAtdyAvIDI7XG4gICAgY29udGV4dC5yZWN0KHgsIHgsIHcsIHcpO1xuICB9XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1954\n')},1955:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1945);\n\n\nvar ka = 0.89081309152928522810,\n    kr = Math.sin(_math_js__WEBPACK_IMPORTED_MODULE_0__[/* pi */ "j"] / 10) / Math.sin(7 * _math_js__WEBPACK_IMPORTED_MODULE_0__[/* pi */ "j"] / 10),\n    kx = Math.sin(_math_js__WEBPACK_IMPORTED_MODULE_0__[/* tau */ "m"] / 10) * kr,\n    ky = -Math.cos(_math_js__WEBPACK_IMPORTED_MODULE_0__[/* tau */ "m"] / 10) * kr;\n\n/* harmony default export */ __webpack_exports__["a"] = ({\n  draw: function(context, size) {\n    var r = Math.sqrt(size * ka),\n        x = kx * r,\n        y = ky * r;\n    context.moveTo(0, -r);\n    context.lineTo(x, y);\n    for (var i = 1; i < 5; ++i) {\n      var a = _math_js__WEBPACK_IMPORTED_MODULE_0__[/* tau */ "m"] * i / 5,\n          c = Math.cos(a),\n          s = Math.sin(a);\n      context.lineTo(s * r, -c * r);\n      context.lineTo(c * x - s * y, s * x + c * y);\n    }\n    context.closePath();\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk1NS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvc3Rhci5qcz9hNTA3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7cGksIHRhdX0gZnJvbSBcIi4uL21hdGguanNcIjtcblxudmFyIGthID0gMC44OTA4MTMwOTE1MjkyODUyMjgxMCxcbiAgICBrciA9IE1hdGguc2luKHBpIC8gMTApIC8gTWF0aC5zaW4oNyAqIHBpIC8gMTApLFxuICAgIGt4ID0gTWF0aC5zaW4odGF1IC8gMTApICoga3IsXG4gICAga3kgPSAtTWF0aC5jb3ModGF1IC8gMTApICoga3I7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSkge1xuICAgIHZhciByID0gTWF0aC5zcXJ0KHNpemUgKiBrYSksXG4gICAgICAgIHggPSBreCAqIHIsXG4gICAgICAgIHkgPSBreSAqIHI7XG4gICAgY29udGV4dC5tb3ZlVG8oMCwgLXIpO1xuICAgIGNvbnRleHQubGluZVRvKHgsIHkpO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgNTsgKytpKSB7XG4gICAgICB2YXIgYSA9IHRhdSAqIGkgLyA1LFxuICAgICAgICAgIGMgPSBNYXRoLmNvcyhhKSxcbiAgICAgICAgICBzID0gTWF0aC5zaW4oYSk7XG4gICAgICBjb250ZXh0LmxpbmVUbyhzICogciwgLWMgKiByKTtcbiAgICAgIGNvbnRleHQubGluZVRvKGMgKiB4IC0gcyAqIHksIHMgKiB4ICsgYyAqIHkpO1xuICAgIH1cbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1955\n')},1956:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('var sqrt3 = Math.sqrt(3);\n\n/* harmony default export */ __webpack_exports__["a"] = ({\n  draw: function(context, size) {\n    var y = -Math.sqrt(size / (sqrt3 * 3));\n    context.moveTo(0, y * 2);\n    context.lineTo(-sqrt3 * y, -y);\n    context.lineTo(sqrt3 * y, -y);\n    context.closePath();\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk1Ni5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvdHJpYW5nbGUuanM/ZmM4MyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgc3FydDMgPSBNYXRoLnNxcnQoMyk7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSkge1xuICAgIHZhciB5ID0gLU1hdGguc3FydChzaXplIC8gKHNxcnQzICogMykpO1xuICAgIGNvbnRleHQubW92ZVRvKDAsIHkgKiAyKTtcbiAgICBjb250ZXh0LmxpbmVUbygtc3FydDMgKiB5LCAteSk7XG4gICAgY29udGV4dC5saW5lVG8oc3FydDMgKiB5LCAteSk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1956\n')},1957:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('var c = -0.5,\n    s = Math.sqrt(3) / 2,\n    k = 1 / Math.sqrt(12),\n    a = (k / 2 + 1) * 3;\n\n/* harmony default export */ __webpack_exports__["a"] = ({\n  draw: function(context, size) {\n    var r = Math.sqrt(size / a),\n        x0 = r / 2,\n        y0 = r * k,\n        x1 = x0,\n        y1 = r * k + r,\n        x2 = -x1,\n        y2 = y1;\n    context.moveTo(x0, y0);\n    context.lineTo(x1, y1);\n    context.lineTo(x2, y2);\n    context.lineTo(c * x0 - s * y0, s * x0 + c * y0);\n    context.lineTo(c * x1 - s * y1, s * x1 + c * y1);\n    context.lineTo(c * x2 - s * y2, s * x2 + c * y2);\n    context.lineTo(c * x0 + s * y0, c * y0 - s * x0);\n    context.lineTo(c * x1 + s * y1, c * y1 - s * x1);\n    context.lineTo(c * x2 + s * y2, c * y2 - s * x2);\n    context.closePath();\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk1Ny5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvd3llLmpzPzIyNDciXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGMgPSAtMC41LFxuICAgIHMgPSBNYXRoLnNxcnQoMykgLyAyLFxuICAgIGsgPSAxIC8gTWF0aC5zcXJ0KDEyKSxcbiAgICBhID0gKGsgLyAyICsgMSkgKiAzO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUpIHtcbiAgICB2YXIgciA9IE1hdGguc3FydChzaXplIC8gYSksXG4gICAgICAgIHgwID0gciAvIDIsXG4gICAgICAgIHkwID0gciAqIGssXG4gICAgICAgIHgxID0geDAsXG4gICAgICAgIHkxID0gciAqIGsgKyByLFxuICAgICAgICB4MiA9IC14MSxcbiAgICAgICAgeTIgPSB5MTtcbiAgICBjb250ZXh0Lm1vdmVUbyh4MCwgeTApO1xuICAgIGNvbnRleHQubGluZVRvKHgxLCB5MSk7XG4gICAgY29udGV4dC5saW5lVG8oeDIsIHkyKTtcbiAgICBjb250ZXh0LmxpbmVUbyhjICogeDAgLSBzICogeTAsIHMgKiB4MCArIGMgKiB5MCk7XG4gICAgY29udGV4dC5saW5lVG8oYyAqIHgxIC0gcyAqIHkxLCBzICogeDEgKyBjICogeTEpO1xuICAgIGNvbnRleHQubGluZVRvKGMgKiB4MiAtIHMgKiB5MiwgcyAqIHgyICsgYyAqIHkyKTtcbiAgICBjb250ZXh0LmxpbmVUbyhjICogeDAgKyBzICogeTAsIGMgKiB5MCAtIHMgKiB4MCk7XG4gICAgY29udGV4dC5saW5lVG8oYyAqIHgxICsgcyAqIHkxLCBjICogeTEgLSBzICogeDEpO1xuICAgIGNvbnRleHQubGluZVRvKGMgKiB4MiArIHMgKiB5MiwgYyAqIHkyIC0gcyAqIHgyKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1957\n')},1975:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return symbols; });\n/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2368);\n/* harmony import */ var _symbol_circle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1951);\n/* harmony import */ var _symbol_cross_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1952);\n/* harmony import */ var _symbol_diamond_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1953);\n/* harmony import */ var _symbol_star_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1955);\n/* harmony import */ var _symbol_square_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(1954);\n/* harmony import */ var _symbol_triangle_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(1956);\n/* harmony import */ var _symbol_wye_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(1957);\n/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(1946);\n\n\n\n\n\n\n\n\n\n\nvar symbols = [\n  _symbol_circle_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"],\n  _symbol_cross_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"],\n  _symbol_diamond_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"],\n  _symbol_square_js__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"],\n  _symbol_star_js__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"],\n  _symbol_triangle_js__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"],\n  _symbol_wye_js__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"]\n];\n\n/* harmony default export */ __webpack_exports__["a"] = (function() {\n  var type = Object(_constant_js__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"])(_symbol_circle_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]),\n      size = Object(_constant_js__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"])(64),\n      context = null;\n\n  function symbol() {\n    var buffer;\n    if (!context) context = buffer = Object(d3_path__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])();\n    type.apply(this, arguments).draw(context, +size.apply(this, arguments));\n    if (buffer) return context = null, buffer + "" || null;\n  }\n\n  symbol.type = function(_) {\n    return arguments.length ? (type = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"])(_), symbol) : type;\n  };\n\n  symbol.size = function(_) {\n    return arguments.length ? (size = typeof _ === "function" ? _ : Object(_constant_js__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"])(+_), symbol) : size;\n  };\n\n  symbol.context = function(_) {\n    return arguments.length ? (context = _ == null ? null : _, symbol) : context;\n  };\n\n  return symbol;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk3NS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wuanM/Y2E2MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3BhdGh9IGZyb20gXCJkMy1wYXRoXCI7XG5pbXBvcnQgY2lyY2xlIGZyb20gXCIuL3N5bWJvbC9jaXJjbGUuanNcIjtcbmltcG9ydCBjcm9zcyBmcm9tIFwiLi9zeW1ib2wvY3Jvc3MuanNcIjtcbmltcG9ydCBkaWFtb25kIGZyb20gXCIuL3N5bWJvbC9kaWFtb25kLmpzXCI7XG5pbXBvcnQgc3RhciBmcm9tIFwiLi9zeW1ib2wvc3Rhci5qc1wiO1xuaW1wb3J0IHNxdWFyZSBmcm9tIFwiLi9zeW1ib2wvc3F1YXJlLmpzXCI7XG5pbXBvcnQgdHJpYW5nbGUgZnJvbSBcIi4vc3ltYm9sL3RyaWFuZ2xlLmpzXCI7XG5pbXBvcnQgd3llIGZyb20gXCIuL3N5bWJvbC93eWUuanNcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuXG5leHBvcnQgdmFyIHN5bWJvbHMgPSBbXG4gIGNpcmNsZSxcbiAgY3Jvc3MsXG4gIGRpYW1vbmQsXG4gIHNxdWFyZSxcbiAgc3RhcixcbiAgdHJpYW5nbGUsXG4gIHd5ZVxuXTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciB0eXBlID0gY29uc3RhbnQoY2lyY2xlKSxcbiAgICAgIHNpemUgPSBjb25zdGFudCg2NCksXG4gICAgICBjb250ZXh0ID0gbnVsbDtcblxuICBmdW5jdGlvbiBzeW1ib2woKSB7XG4gICAgdmFyIGJ1ZmZlcjtcbiAgICBpZiAoIWNvbnRleHQpIGNvbnRleHQgPSBidWZmZXIgPSBwYXRoKCk7XG4gICAgdHlwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLmRyYXcoY29udGV4dCwgK3NpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgaWYgKGJ1ZmZlcikgcmV0dXJuIGNvbnRleHQgPSBudWxsLCBidWZmZXIgKyBcIlwiIHx8IG51bGw7XG4gIH1cblxuICBzeW1ib2wudHlwZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0eXBlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChfKSwgc3ltYm9sKSA6IHR5cGU7XG4gIH07XG5cbiAgc3ltYm9sLnNpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc2l6ZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBzeW1ib2wpIDogc2l6ZTtcbiAgfTtcblxuICBzeW1ib2wuY29udGV4dCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjb250ZXh0ID0gXyA9PSBudWxsID8gbnVsbCA6IF8sIHN5bWJvbCkgOiBjb250ZXh0O1xuICB9O1xuXG4gIHJldHVybiBzeW1ib2w7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1975\n')},1978:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DEFAULT_MARGIN; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return createMarginSelector; });\n/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(181);\n\nconst DEFAULT_MARGIN = { bottom: 16, left: 16, right: 16, top: 16 };\nfunction createMarginSelector(defaultMargin = DEFAULT_MARGIN) {\n    return Object(reselect__WEBPACK_IMPORTED_MODULE_0__["createSelector"])((margin) => margin.bottom, margin => margin.left, margin => margin.right, margin => margin.top, (bottom = defaultMargin.bottom, left = defaultMargin.left, right = defaultMargin.right, top = defaultMargin.top) => ({\n        bottom,\n        left,\n        right,\n        top,\n    }));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk3OC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wcmVzZXQtY2hhcnQteHkvc3JjL3V0aWxzL2NyZWF0ZU1hcmdpblNlbGVjdG9yLnRzeD83NTU1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yIH0gZnJvbSAncmVzZWxlY3QnO1xuaW1wb3J0IHsgTWFyZ2luIH0gZnJvbSAnQHN1cGVyc2V0LXVpL2NvcmUnO1xuXG5leHBvcnQgY29uc3QgREVGQVVMVF9NQVJHSU4gPSB7IGJvdHRvbTogMTYsIGxlZnQ6IDE2LCByaWdodDogMTYsIHRvcDogMTYgfTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlTWFyZ2luU2VsZWN0b3IoZGVmYXVsdE1hcmdpbjogTWFyZ2luID0gREVGQVVMVF9NQVJHSU4pIHtcbiAgcmV0dXJuIGNyZWF0ZVNlbGVjdG9yKFxuICAgIChtYXJnaW46IFBhcnRpYWw8TWFyZ2luPikgPT4gbWFyZ2luLmJvdHRvbSxcbiAgICBtYXJnaW4gPT4gbWFyZ2luLmxlZnQsXG4gICAgbWFyZ2luID0+IG1hcmdpbi5yaWdodCxcbiAgICBtYXJnaW4gPT4gbWFyZ2luLnRvcCxcbiAgICAoXG4gICAgICBib3R0b20gPSBkZWZhdWx0TWFyZ2luLmJvdHRvbSxcbiAgICAgIGxlZnQgPSBkZWZhdWx0TWFyZ2luLmxlZnQsXG4gICAgICByaWdodCA9IGRlZmF1bHRNYXJnaW4ucmlnaHQsXG4gICAgICB0b3AgPSBkZWZhdWx0TWFyZ2luLnRvcCxcbiAgICApID0+ICh7XG4gICAgICBib3R0b20sXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHQsXG4gICAgICB0b3AsXG4gICAgfSksXG4gICk7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFFQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1978\n')},1979:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return convertScaleToDataUIScale; });\nfunction isCompatibleDomainOrRange(array) {\n    return (typeof array !== 'undefined' &&\n        array.length > 0 &&\n        (typeof array[0] === 'string' || typeof array[0] === 'number'));\n}\n/**\n * Convert encodeable scale object into @data-ui's scale config\n * @param scale\n */\nfunction convertScaleToDataUIScale(scale) {\n    const { type, domain, range } = scale;\n    let outputType;\n    if (type === 'linear' || type === 'time' || type === 'band') {\n        outputType = type;\n    }\n    else if (type === 'utc') {\n        outputType = 'timeUtc';\n    }\n    else {\n        throw new Error(`Unsupported scale type: ${type}`);\n    }\n    const output = { type: outputType };\n    if (isCompatibleDomainOrRange(domain)) {\n        output.domain = domain;\n    }\n    if (isCompatibleDomainOrRange(range)) {\n        output.range = range;\n    }\n    if ('nice' in scale && typeof scale.nice === 'boolean') {\n        output.nice = scale.nice;\n    }\n    if ('paddingInner' in scale && typeof scale.paddingInner !== 'undefined') {\n        output.paddingInner = scale.paddingInner;\n    }\n    if ('paddingOuter' in scale && typeof scale.paddingOuter !== 'undefined') {\n        output.paddingOuter = scale.paddingOuter;\n    }\n    return output;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk3OS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wcmVzZXQtY2hhcnQteHkvc3JjL3V0aWxzL2NvbnZlcnRTY2FsZVRvRGF0YVVJU2NhbGVTaGFwZS50cz8wNDdmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFZhbHVlLCBTY2FsZUNvbmZpZyB9IGZyb20gJ2VuY29kYWJsZSc7XG5cbnR5cGUgRGF0YVVJU2NhbGVUeXBlID0gJ3RpbWUnIHwgJ3RpbWVVdGMnIHwgJ2xpbmVhcicgfCAnYmFuZCc7XG5cbmludGVyZmFjZSBEYXRhVUlTY2FsZSB7XG4gIHR5cGU6IERhdGFVSVNjYWxlVHlwZTtcbiAgZG9tYWluPzogbnVtYmVyW10gfCBzdHJpbmdbXTtcbiAgaW5jbHVkZVplcm8/OiBib29sZWFuO1xuICBuaWNlPzogYm9vbGVhbjtcbiAgcGFkZGluZ0lubmVyPzogbnVtYmVyO1xuICBwYWRkaW5nT3V0ZXI/OiBudW1iZXI7XG4gIHJhbmdlPzogbnVtYmVyW10gfCBzdHJpbmdbXTtcbiAgcmFuZ2VSb3VuZD86IG51bWJlcltdIHwgc3RyaW5nW107XG59XG5cbmZ1bmN0aW9uIGlzQ29tcGF0aWJsZURvbWFpbk9yUmFuZ2UoXG4gIGFycmF5OiBTY2FsZUNvbmZpZ1snZG9tYWluJ10gfCBTY2FsZUNvbmZpZ1sncmFuZ2UnXSxcbik6IGFycmF5IGlzIG51bWJlcltdIHwgc3RyaW5nW10ge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBhcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICBhcnJheS5sZW5ndGggPiAwICYmXG4gICAgKHR5cGVvZiBhcnJheVswXSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGFycmF5WzBdID09PSAnbnVtYmVyJylcbiAgKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGVuY29kZWFibGUgc2NhbGUgb2JqZWN0IGludG8gQGRhdGEtdWkncyBzY2FsZSBjb25maWdcbiAqIEBwYXJhbSBzY2FsZVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb252ZXJ0U2NhbGVUb0RhdGFVSVNjYWxlPE91dHB1dCBleHRlbmRzIFZhbHVlPihcbiAgc2NhbGU6IFNjYWxlQ29uZmlnPE91dHB1dD4sXG4pIHtcbiAgY29uc3QgeyB0eXBlLCBkb21haW4sIHJhbmdlIH0gPSBzY2FsZTtcblxuICBsZXQgb3V0cHV0VHlwZTogRGF0YVVJU2NhbGVUeXBlO1xuXG4gIGlmICh0eXBlID09PSAnbGluZWFyJyB8fCB0eXBlID09PSAndGltZScgfHwgdHlwZSA9PT0gJ2JhbmQnKSB7XG4gICAgb3V0cHV0VHlwZSA9IHR5cGU7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3V0YycpIHtcbiAgICBvdXRwdXRUeXBlID0gJ3RpbWVVdGMnO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgc2NhbGUgdHlwZTogJHt0eXBlfWApO1xuICB9XG5cbiAgY29uc3Qgb3V0cHV0OiBEYXRhVUlTY2FsZSA9IHsgdHlwZTogb3V0cHV0VHlwZSB9O1xuICBpZiAoaXNDb21wYXRpYmxlRG9tYWluT3JSYW5nZShkb21haW4pKSB7XG4gICAgb3V0cHV0LmRvbWFpbiA9IGRvbWFpbjtcbiAgfVxuICBpZiAoaXNDb21wYXRpYmxlRG9tYWluT3JSYW5nZShyYW5nZSkpIHtcbiAgICBvdXRwdXQucmFuZ2UgPSByYW5nZTtcbiAgfVxuICBpZiAoJ25pY2UnIGluIHNjYWxlICYmIHR5cGVvZiBzY2FsZS5uaWNlID09PSAnYm9vbGVhbicpIHtcbiAgICBvdXRwdXQubmljZSA9IHNjYWxlLm5pY2U7XG4gIH1cbiAgaWYgKCdwYWRkaW5nSW5uZXInIGluIHNjYWxlICYmIHR5cGVvZiBzY2FsZS5wYWRkaW5nSW5uZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgb3V0cHV0LnBhZGRpbmdJbm5lciA9IHNjYWxlLnBhZGRpbmdJbm5lcjtcbiAgfVxuICBpZiAoJ3BhZGRpbmdPdXRlcicgaW4gc2NhbGUgJiYgdHlwZW9mIHNjYWxlLnBhZGRpbmdPdXRlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBvdXRwdXQucGFkZGluZ091dGVyID0gc2NhbGUucGFkZGluZ091dGVyO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBZUE7QUFBQTtBQUdBO0FBRUE7QUFDQTtBQUVBO0FBRUE7OztBQUdBO0FBQ0E7QUFHQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1979\n")},1980:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"a\", function() { return /* binding */ createXYChartLayoutWithTheme; });\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react/index.js\nvar react = __webpack_require__(0);\nvar react_default = /*#__PURE__*/__webpack_require__.n(react);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/axis/XAxis.js\nvar XAxis = __webpack_require__(2387);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/axis/YAxis.js\nvar YAxis = __webpack_require__(2388);\n\n// EXTERNAL MODULE: ../superset-ui-core/src/dimension/mergeMargin.ts\nvar mergeMargin = __webpack_require__(1055);\n\n// EXTERNAL MODULE: ../superset-ui-core/src/chart-composition/ChartFrame.tsx\nvar ChartFrame = __webpack_require__(1059);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/utils/createTickComponent.tsx\nvar __rest = (undefined && undefined.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n\nfunction createTickComponent({ axisWidth, labelAngle, labelFlush, labelOverlap, orient, tickLabels, tickLabelDimensions, tickTextAnchor = 'middle', }) {\n    if (labelOverlap === 'rotate' && labelAngle !== 0) {\n        let xOffset = labelAngle > 0 ? -6 : 6;\n        if (orient === 'top') {\n            xOffset = 0;\n        }\n        const yOffset = orient === 'top' ? -3 : 0;\n        return (_a) => {\n            var { x, y, formattedValue = '' } = _a, textStyle = __rest(_a, [\"x\", \"y\", \"formattedValue\"]);\n            return (react_default.a.createElement(\"g\", { transform: `translate(${x + xOffset}, ${y + yOffset})` },\n                react_default.a.createElement(\"text\", Object.assign({ transform: `rotate(${labelAngle})` }, textStyle, { textAnchor: tickTextAnchor }), formattedValue)));\n        };\n    }\n    if (labelFlush === true || typeof labelFlush === 'number') {\n        const labelToDimensionMap = new Map();\n        tickLabels.forEach((label, i) => {\n            labelToDimensionMap.set(label, tickLabelDimensions[i]);\n        });\n        return (_a) => {\n            var { x, y, formattedValue = '' } = _a, textStyle = __rest(_a, [\"x\", \"y\", \"formattedValue\"]);\n            const dimension = labelToDimensionMap.get(formattedValue);\n            const labelWidth = typeof dimension === 'undefined' ? 0 : dimension.width;\n            let textAnchor = tickTextAnchor;\n            let xOffset = 0;\n            if (x - labelWidth / 2 < 0) {\n                textAnchor = 'start';\n                if (typeof labelFlush === 'number') {\n                    xOffset -= labelFlush;\n                }\n            }\n            else if (x + labelWidth / 2 > axisWidth) {\n                textAnchor = 'end';\n                if (typeof labelFlush === 'number') {\n                    xOffset += labelFlush;\n                }\n            }\n            return (react_default.a.createElement(\"text\", Object.assign({ x: x + xOffset, y: y }, textStyle, { textAnchor: textAnchor }), formattedValue));\n        };\n    }\n    // This will render the tick as horizontal string.\n    return null;\n}\n\n// EXTERNAL MODULE: ../superset-ui-core/src/dimension/getTextDimension.ts\nvar getTextDimension = __webpack_require__(442);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/utils/computeAxisLayout.ts\n\nfunction computeAxisLayout(axis, { axisTitleHeight = 20, axisWidth, gapBetweenAxisLabelAndBorder = 4, gapBetweenTickAndTickLabel = 4, defaultTickSize = 8, tickTextStyle = {}, }) {\n    const tickLabels = axis.getTickLabels();\n    const tickLabelDimensions = tickLabels.map((text) => Object(getTextDimension[\"a\" /* default */])({\n        style: tickTextStyle,\n        text,\n    }));\n    const { labelAngle, labelFlush, labelOverlap, labelPadding, orient, tickSize = defaultTickSize, } = axis.config;\n    const maxWidth = Math.max(...tickLabelDimensions.map(d => d.width), 0);\n    // cheap heuristic, can improve\n    const widthPerTick = axisWidth / tickLabels.length;\n    const isLabelOverlap = maxWidth > widthPerTick;\n    const labelAngleIfOverlap = labelOverlap.strategy === 'rotate' ? labelOverlap.labelAngle : 0;\n    const labelAngleAfterOverlapCheck = isLabelOverlap ? labelAngleIfOverlap : 0;\n    const finalLabelAngle = labelAngle === 0 ? labelAngleAfterOverlapCheck : labelAngle;\n    const spaceForAxisTitle = axis.hasTitle() ? labelPadding + axisTitleHeight : 0;\n    let tickTextAnchor = 'middle';\n    let labelOffset = 0;\n    let requiredMargin = tickSize + gapBetweenTickAndTickLabel + spaceForAxisTitle + gapBetweenAxisLabelAndBorder;\n    if (axis.channelEncoder.isX()) {\n        if (finalLabelAngle === 0) {\n            const labelHeight = tickLabelDimensions.length > 0 ? tickLabelDimensions[0].height : 0;\n            labelOffset = labelHeight + labelPadding;\n            requiredMargin += labelHeight;\n        }\n        else {\n            const labelHeight = Math.ceil(Math.abs(maxWidth * Math.sin((finalLabelAngle * Math.PI) / 180)));\n            labelOffset = labelHeight + labelPadding;\n            requiredMargin += labelHeight;\n            tickTextAnchor =\n                (orient === 'top' && finalLabelAngle > 0) || (orient === 'bottom' && finalLabelAngle < 0)\n                    ? 'end'\n                    : 'start';\n        }\n        requiredMargin += 8;\n    }\n    else {\n        labelOffset = maxWidth + spaceForAxisTitle;\n        requiredMargin += maxWidth;\n    }\n    return {\n        axisWidth,\n        labelAngle: finalLabelAngle,\n        labelFlush,\n        labelOffset,\n        labelOverlap: isLabelOverlap ? labelOverlap.strategy : 'flat',\n        minMargin: {\n            [orient]: Math.ceil(requiredMargin),\n        },\n        orient,\n        tickLabelDimensions,\n        tickLabels,\n        tickTextAnchor,\n    };\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/utils/XYChartLayout.tsx\n\n\n\n\n\nconst DEFAULT_LABEL_ANGLE = 40;\n// Additional margin to avoid content hidden behind scroll bar\nconst OVERFLOW_MARGIN = 8;\nclass XYChartLayout_XYChartLayout {\n    constructor(config) {\n        const { width, height, minContentWidth = 0, minContentHeight = 0, margin, xEncoder, xTickSize, xTickTextStyle, autoAdjustXMargin = true, yEncoder, yTickSize, yTickTextStyle, autoAdjustYMargin = true, } = config;\n        this.xEncoder = xEncoder;\n        this.yEncoder = yEncoder;\n        if (typeof yEncoder.axis !== 'undefined') {\n            this.yLayout = computeAxisLayout(yEncoder.axis, {\n                axisWidth: Math.max(height - margin.top - margin.bottom),\n                defaultTickSize: yTickSize,\n                tickTextStyle: yTickTextStyle,\n            });\n        }\n        const secondMargin = this.yLayout && autoAdjustYMargin ? Object(mergeMargin[\"a\" /* default */])(margin, this.yLayout.minMargin) : margin;\n        const innerWidth = Math.max(width - secondMargin.left - secondMargin.right, minContentWidth);\n        if (typeof xEncoder.axis !== 'undefined') {\n            this.xLayout = computeAxisLayout(xEncoder.axis, {\n                axisWidth: innerWidth,\n                defaultTickSize: xTickSize,\n                tickTextStyle: xTickTextStyle,\n            });\n        }\n        const finalMargin = this.xLayout && autoAdjustXMargin\n            ? Object(mergeMargin[\"a\" /* default */])(secondMargin, this.xLayout.minMargin)\n            : secondMargin;\n        const innerHeight = Math.max(height - finalMargin.top - finalMargin.bottom, minContentHeight);\n        const chartWidth = Math.round(innerWidth + finalMargin.left + finalMargin.right);\n        const chartHeight = Math.round(innerHeight + finalMargin.top + finalMargin.bottom);\n        const isOverFlowX = chartWidth > width;\n        const isOverFlowY = chartHeight > height;\n        if (isOverFlowX) {\n            finalMargin.bottom += OVERFLOW_MARGIN;\n        }\n        if (isOverFlowY) {\n            finalMargin.right += OVERFLOW_MARGIN;\n        }\n        this.chartWidth = isOverFlowX ? chartWidth + OVERFLOW_MARGIN : chartWidth;\n        this.chartHeight = isOverFlowY ? chartHeight + OVERFLOW_MARGIN : chartHeight;\n        this.containerWidth = width;\n        this.containerHeight = height;\n        this.margin = finalMargin;\n    }\n    renderChartWithFrame(renderChart) {\n        return (react_default.a.createElement(ChartFrame[\"a\" /* default */], { width: this.containerWidth, height: this.containerHeight, contentWidth: this.chartWidth, contentHeight: this.chartHeight, renderContent: renderChart }));\n    }\n    renderXAxis(props) {\n        const { axis } = this.xEncoder;\n        return axis && this.xLayout ? (react_default.a.createElement(XAxis[\"a\" /* default */], Object.assign({ label: axis.getTitle(), labelOffset: this.xLayout.labelOffset, numTicks: axis.config.tickCount, orientation: axis.config.orient, tickComponent: createTickComponent(this.xLayout), tickFormat: axis.formatValue }, props))) : null;\n    }\n    renderYAxis(props) {\n        const { axis } = this.yEncoder;\n        return axis && this.yLayout ? (react_default.a.createElement(YAxis[\"a\" /* default */], Object.assign({ label: axis.getTitle(), labelOffset: this.yLayout.labelOffset, numTicks: axis.config.tickCount, orientation: axis.config.orient, tickFormat: axis.formatValue }, props))) : null;\n    }\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/utils/createXYChartLayoutWithTheme.ts\nvar createXYChartLayoutWithTheme_rest = (undefined && undefined.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n\nfunction createXYChartLayoutWithTheme(config) {\n    const { theme } = config, rest = createXYChartLayoutWithTheme_rest(config, [\"theme\"]);\n    return new XYChartLayout_XYChartLayout(Object.assign(Object.assign({}, rest), { \n        // @ts-ignore\n        xTickSize: theme.xTickStyles.length || theme.xTickStyles.tickLength, xTickTextStyle: theme.xTickStyles.label.bottom || theme.xTickStyles.label.top, \n        // @ts-ignore\n        yTickSize: theme.yTickStyles.length || theme.yTickStyles.tickLength, yTickTextStyle: theme.yTickStyles.label.left || theme.yTickStyles.label.right }));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk4MC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wcmVzZXQtY2hhcnQteHkvc3JjL3V0aWxzL2NyZWF0ZVRpY2tDb21wb25lbnQudHN4P2UxOWQiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9wbHVnaW5zL3ByZXNldC1jaGFydC14eS9zcmMvdXRpbHMvY29tcHV0ZUF4aXNMYXlvdXQudHM/Yjk2ZCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvcHJlc2V0LWNoYXJ0LXh5L3NyYy91dGlscy9YWUNoYXJ0TGF5b3V0LnRzeD83YzZmIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wcmVzZXQtY2hhcnQteHkvc3JjL3V0aWxzL2NyZWF0ZVhZQ2hhcnRMYXlvdXRXaXRoVGhlbWUudHM/ZDI4OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgQ1NTUHJvcGVydGllcyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IERpbWVuc2lvbiB9IGZyb20gJ0BzdXBlcnNldC11aS9jb3JlJztcbmltcG9ydCB7IEF4aXNMYXlvdXQgfSBmcm9tICcuL2NvbXB1dGVBeGlzTGF5b3V0JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlVGlja0NvbXBvbmVudCh7XG4gIGF4aXNXaWR0aCxcbiAgbGFiZWxBbmdsZSxcbiAgbGFiZWxGbHVzaCxcbiAgbGFiZWxPdmVybGFwLFxuICBvcmllbnQsXG4gIHRpY2tMYWJlbHMsXG4gIHRpY2tMYWJlbERpbWVuc2lvbnMsXG4gIHRpY2tUZXh0QW5jaG9yID0gJ21pZGRsZScsXG59OiBBeGlzTGF5b3V0KSB7XG4gIGlmIChsYWJlbE92ZXJsYXAgPT09ICdyb3RhdGUnICYmIGxhYmVsQW5nbGUgIT09IDApIHtcbiAgICBsZXQgeE9mZnNldCA9IGxhYmVsQW5nbGUgPiAwID8gLTYgOiA2O1xuICAgIGlmIChvcmllbnQgPT09ICd0b3AnKSB7XG4gICAgICB4T2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgY29uc3QgeU9mZnNldCA9IG9yaWVudCA9PT0gJ3RvcCcgPyAtMyA6IDA7XG5cbiAgICByZXR1cm4gKHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgZm9ybWF0dGVkVmFsdWUgPSAnJyxcbiAgICAgIC4uLnRleHRTdHlsZVxuICAgIH06IHtcbiAgICAgIHg6IG51bWJlcjtcbiAgICAgIHk6IG51bWJlcjtcbiAgICAgIGR5PzogbnVtYmVyO1xuICAgICAgZm9ybWF0dGVkVmFsdWU6IHN0cmluZztcbiAgICAgIHRleHRTdHlsZTogQ1NTUHJvcGVydGllcztcbiAgICB9KSA9PiAoXG4gICAgICA8ZyB0cmFuc2Zvcm09e2B0cmFuc2xhdGUoJHt4ICsgeE9mZnNldH0sICR7eSArIHlPZmZzZXR9KWB9PlxuICAgICAgICA8dGV4dCB0cmFuc2Zvcm09e2Byb3RhdGUoJHtsYWJlbEFuZ2xlfSlgfSB7Li4udGV4dFN0eWxlfSB0ZXh0QW5jaG9yPXt0aWNrVGV4dEFuY2hvcn0+XG4gICAgICAgICAge2Zvcm1hdHRlZFZhbHVlfVxuICAgICAgICA8L3RleHQ+XG4gICAgICA8L2c+XG4gICAgKTtcbiAgfVxuXG4gIGlmIChsYWJlbEZsdXNoID09PSB0cnVlIHx8IHR5cGVvZiBsYWJlbEZsdXNoID09PSAnbnVtYmVyJykge1xuICAgIGNvbnN0IGxhYmVsVG9EaW1lbnNpb25NYXAgPSBuZXcgTWFwPHN0cmluZywgRGltZW5zaW9uPigpO1xuICAgIHRpY2tMYWJlbHMuZm9yRWFjaCgobGFiZWwsIGkpID0+IHtcbiAgICAgIGxhYmVsVG9EaW1lbnNpb25NYXAuc2V0KGxhYmVsLCB0aWNrTGFiZWxEaW1lbnNpb25zW2ldKTtcbiAgICB9KTtcblxuICAgIHJldHVybiAoe1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBmb3JtYXR0ZWRWYWx1ZSA9ICcnLFxuICAgICAgLi4udGV4dFN0eWxlXG4gICAgfToge1xuICAgICAgeDogbnVtYmVyO1xuICAgICAgeTogbnVtYmVyO1xuICAgICAgZHk/OiBudW1iZXI7XG4gICAgICBmb3JtYXR0ZWRWYWx1ZTogc3RyaW5nO1xuICAgICAgdGV4dFN0eWxlOiBDU1NQcm9wZXJ0aWVzO1xuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IGxhYmVsVG9EaW1lbnNpb25NYXAuZ2V0KGZvcm1hdHRlZFZhbHVlKTtcbiAgICAgIGNvbnN0IGxhYmVsV2lkdGggPSB0eXBlb2YgZGltZW5zaW9uID09PSAndW5kZWZpbmVkJyA/IDAgOiBkaW1lbnNpb24ud2lkdGg7XG4gICAgICBsZXQgdGV4dEFuY2hvciA9IHRpY2tUZXh0QW5jaG9yO1xuICAgICAgbGV0IHhPZmZzZXQgPSAwO1xuXG4gICAgICBpZiAoeCAtIGxhYmVsV2lkdGggLyAyIDwgMCkge1xuICAgICAgICB0ZXh0QW5jaG9yID0gJ3N0YXJ0JztcbiAgICAgICAgaWYgKHR5cGVvZiBsYWJlbEZsdXNoID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHhPZmZzZXQgLT0gbGFiZWxGbHVzaDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh4ICsgbGFiZWxXaWR0aCAvIDIgPiBheGlzV2lkdGgpIHtcbiAgICAgICAgdGV4dEFuY2hvciA9ICdlbmQnO1xuICAgICAgICBpZiAodHlwZW9mIGxhYmVsRmx1c2ggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgeE9mZnNldCArPSBsYWJlbEZsdXNoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgIDx0ZXh0IHg9e3ggKyB4T2Zmc2V0fSB5PXt5fSB7Li4udGV4dFN0eWxlfSB0ZXh0QW5jaG9yPXt0ZXh0QW5jaG9yfT5cbiAgICAgICAgICB7Zm9ybWF0dGVkVmFsdWV9XG4gICAgICAgIDwvdGV4dD5cbiAgICAgICk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIFRoaXMgd2lsbCByZW5kZXIgdGhlIHRpY2sgYXMgaG9yaXpvbnRhbCBzdHJpbmcuXG4gIHJldHVybiBudWxsO1xufVxuIiwiaW1wb3J0IHsgQ1NTUHJvcGVydGllcyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGdldFRleHREaW1lbnNpb24sIE1hcmdpbiwgRGltZW5zaW9uIH0gZnJvbSAnQHN1cGVyc2V0LXVpL2NvcmUnO1xuaW1wb3J0IHsgQXhpc09yaWVudCwgQ2hhbm5lbERlZiwgVmFsdWUgfSBmcm9tICdlbmNvZGFibGUnO1xuXG5pbXBvcnQgQ2hhbm5lbEVuY29kZXJBeGlzIGZyb20gJ2VuY29kYWJsZS9saWIvZW5jb2RlcnMvQ2hhbm5lbEVuY29kZXJBeGlzJztcblxuZXhwb3J0IGludGVyZmFjZSBBeGlzTGF5b3V0IHtcbiAgYXhpc1dpZHRoOiBudW1iZXI7XG4gIGxhYmVsQW5nbGU6IG51bWJlcjtcbiAgbGFiZWxGbHVzaDogbnVtYmVyIHwgYm9vbGVhbjtcbiAgbGFiZWxPZmZzZXQ6IG51bWJlcjtcbiAgbGFiZWxPdmVybGFwOiAnZmxhdCcgfCAncm90YXRlJztcbiAgbWluTWFyZ2luOiBQYXJ0aWFsPE1hcmdpbj47XG4gIG9yaWVudDogQXhpc09yaWVudDtcbiAgdGlja0xhYmVsRGltZW5zaW9uczogRGltZW5zaW9uW107XG4gIHRpY2tMYWJlbHM6IHN0cmluZ1tdO1xuICB0aWNrVGV4dEFuY2hvcj86IHN0cmluZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcHV0ZUF4aXNMYXlvdXQ8RGVmIGV4dGVuZHMgQ2hhbm5lbERlZjxPdXRwdXQ+LCBPdXRwdXQgZXh0ZW5kcyBWYWx1ZT4oXG4gIGF4aXM6IENoYW5uZWxFbmNvZGVyQXhpczxEZWYsIE91dHB1dD4sXG4gIHtcbiAgICBheGlzVGl0bGVIZWlnaHQgPSAyMCxcbiAgICBheGlzV2lkdGgsXG4gICAgZ2FwQmV0d2VlbkF4aXNMYWJlbEFuZEJvcmRlciA9IDQsXG4gICAgZ2FwQmV0d2VlblRpY2tBbmRUaWNrTGFiZWwgPSA0LFxuICAgIGRlZmF1bHRUaWNrU2l6ZSA9IDgsXG4gICAgdGlja1RleHRTdHlsZSA9IHt9LFxuICB9OiB7XG4gICAgYXhpc1RpdGxlSGVpZ2h0PzogbnVtYmVyO1xuICAgIGF4aXNXaWR0aDogbnVtYmVyO1xuICAgIGdhcEJldHdlZW5BeGlzTGFiZWxBbmRCb3JkZXI/OiBudW1iZXI7XG4gICAgZ2FwQmV0d2VlblRpY2tBbmRUaWNrTGFiZWw/OiBudW1iZXI7XG4gICAgZGVmYXVsdFRpY2tTaXplPzogbnVtYmVyO1xuICAgIHRpY2tUZXh0U3R5bGU/OiBDU1NQcm9wZXJ0aWVzO1xuICB9LFxuKTogQXhpc0xheW91dCB7XG4gIGNvbnN0IHRpY2tMYWJlbHMgPSBheGlzLmdldFRpY2tMYWJlbHMoKTtcbiAgY29uc3QgdGlja0xhYmVsRGltZW5zaW9ucyA9IHRpY2tMYWJlbHMubWFwKCh0ZXh0OiBzdHJpbmcpID0+XG4gICAgZ2V0VGV4dERpbWVuc2lvbih7XG4gICAgICBzdHlsZTogdGlja1RleHRTdHlsZSxcbiAgICAgIHRleHQsXG4gICAgfSksXG4gICk7XG5cbiAgY29uc3Qge1xuICAgIGxhYmVsQW5nbGUsXG4gICAgbGFiZWxGbHVzaCxcbiAgICBsYWJlbE92ZXJsYXAsXG4gICAgbGFiZWxQYWRkaW5nLFxuICAgIG9yaWVudCxcbiAgICB0aWNrU2l6ZSA9IGRlZmF1bHRUaWNrU2l6ZSxcbiAgfSA9IGF4aXMuY29uZmlnO1xuXG4gIGNvbnN0IG1heFdpZHRoID0gTWF0aC5tYXgoLi4udGlja0xhYmVsRGltZW5zaW9ucy5tYXAoZCA9PiBkLndpZHRoKSwgMCk7XG5cbiAgLy8gY2hlYXAgaGV1cmlzdGljLCBjYW4gaW1wcm92ZVxuICBjb25zdCB3aWR0aFBlclRpY2sgPSBheGlzV2lkdGggLyB0aWNrTGFiZWxzLmxlbmd0aDtcbiAgY29uc3QgaXNMYWJlbE92ZXJsYXAgPSBtYXhXaWR0aCA+IHdpZHRoUGVyVGljaztcbiAgY29uc3QgbGFiZWxBbmdsZUlmT3ZlcmxhcCA9IGxhYmVsT3ZlcmxhcC5zdHJhdGVneSA9PT0gJ3JvdGF0ZScgPyBsYWJlbE92ZXJsYXAubGFiZWxBbmdsZSA6IDA7XG4gIGNvbnN0IGxhYmVsQW5nbGVBZnRlck92ZXJsYXBDaGVjayA9IGlzTGFiZWxPdmVybGFwID8gbGFiZWxBbmdsZUlmT3ZlcmxhcCA6IDA7XG4gIGNvbnN0IGZpbmFsTGFiZWxBbmdsZSA9IGxhYmVsQW5nbGUgPT09IDAgPyBsYWJlbEFuZ2xlQWZ0ZXJPdmVybGFwQ2hlY2sgOiBsYWJlbEFuZ2xlO1xuXG4gIGNvbnN0IHNwYWNlRm9yQXhpc1RpdGxlID0gYXhpcy5oYXNUaXRsZSgpID8gbGFiZWxQYWRkaW5nICsgYXhpc1RpdGxlSGVpZ2h0IDogMDtcbiAgbGV0IHRpY2tUZXh0QW5jaG9yID0gJ21pZGRsZSc7XG4gIGxldCBsYWJlbE9mZnNldCA9IDA7XG4gIGxldCByZXF1aXJlZE1hcmdpbiA9XG4gICAgdGlja1NpemUgKyBnYXBCZXR3ZWVuVGlja0FuZFRpY2tMYWJlbCArIHNwYWNlRm9yQXhpc1RpdGxlICsgZ2FwQmV0d2VlbkF4aXNMYWJlbEFuZEJvcmRlcjtcblxuICBpZiAoYXhpcy5jaGFubmVsRW5jb2Rlci5pc1goKSkge1xuICAgIGlmIChmaW5hbExhYmVsQW5nbGUgPT09IDApIHtcbiAgICAgIGNvbnN0IGxhYmVsSGVpZ2h0ID0gdGlja0xhYmVsRGltZW5zaW9ucy5sZW5ndGggPiAwID8gdGlja0xhYmVsRGltZW5zaW9uc1swXS5oZWlnaHQgOiAwO1xuICAgICAgbGFiZWxPZmZzZXQgPSBsYWJlbEhlaWdodCArIGxhYmVsUGFkZGluZztcbiAgICAgIHJlcXVpcmVkTWFyZ2luICs9IGxhYmVsSGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsYWJlbEhlaWdodCA9IE1hdGguY2VpbChcbiAgICAgICAgTWF0aC5hYnMobWF4V2lkdGggKiBNYXRoLnNpbigoZmluYWxMYWJlbEFuZ2xlICogTWF0aC5QSSkgLyAxODApKSxcbiAgICAgICk7XG4gICAgICBsYWJlbE9mZnNldCA9IGxhYmVsSGVpZ2h0ICsgbGFiZWxQYWRkaW5nO1xuICAgICAgcmVxdWlyZWRNYXJnaW4gKz0gbGFiZWxIZWlnaHQ7XG4gICAgICB0aWNrVGV4dEFuY2hvciA9XG4gICAgICAgIChvcmllbnQgPT09ICd0b3AnICYmIGZpbmFsTGFiZWxBbmdsZSA+IDApIHx8IChvcmllbnQgPT09ICdib3R0b20nICYmIGZpbmFsTGFiZWxBbmdsZSA8IDApXG4gICAgICAgICAgPyAnZW5kJ1xuICAgICAgICAgIDogJ3N0YXJ0JztcbiAgICB9XG4gICAgcmVxdWlyZWRNYXJnaW4gKz0gODtcbiAgfSBlbHNlIHtcbiAgICBsYWJlbE9mZnNldCA9IG1heFdpZHRoICsgc3BhY2VGb3JBeGlzVGl0bGU7XG4gICAgcmVxdWlyZWRNYXJnaW4gKz0gbWF4V2lkdGg7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGF4aXNXaWR0aCxcbiAgICBsYWJlbEFuZ2xlOiBmaW5hbExhYmVsQW5nbGUsXG4gICAgbGFiZWxGbHVzaCxcbiAgICBsYWJlbE9mZnNldCxcbiAgICBsYWJlbE92ZXJsYXA6IGlzTGFiZWxPdmVybGFwID8gbGFiZWxPdmVybGFwLnN0cmF0ZWd5IDogJ2ZsYXQnLFxuICAgIG1pbk1hcmdpbjoge1xuICAgICAgW29yaWVudF06IE1hdGguY2VpbChyZXF1aXJlZE1hcmdpbiksXG4gICAgfSxcbiAgICBvcmllbnQsXG4gICAgdGlja0xhYmVsRGltZW5zaW9ucyxcbiAgICB0aWNrTGFiZWxzLFxuICAgIHRpY2tUZXh0QW5jaG9yLFxuICB9O1xufVxuIiwiaW1wb3J0IFJlYWN0LCB7IFJlYWN0Tm9kZSwgQ1NTUHJvcGVydGllcyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFhBeGlzLCBZQXhpcyB9IGZyb20gJ0BkYXRhLXVpL3h5LWNoYXJ0JztcbmltcG9ydCB7IENoYXJ0RnJhbWUsIE1hcmdpbiwgbWVyZ2VNYXJnaW4sIERpbWVuc2lvbiB9IGZyb20gJ0BzdXBlcnNldC11aS9jb3JlJztcbmltcG9ydCB7IENoYW5uZWxFbmNvZGVyLCBQbGFpbk9iamVjdCwgVmFsdWUsIFhGaWVsZERlZiwgWUZpZWxkRGVmIH0gZnJvbSAnZW5jb2RhYmxlJztcbmltcG9ydCBjcmVhdGVUaWNrQ29tcG9uZW50IGZyb20gJy4vY3JlYXRlVGlja0NvbXBvbmVudCc7XG5pbXBvcnQgY29tcHV0ZUF4aXNMYXlvdXQsIHsgQXhpc0xheW91dCB9IGZyb20gJy4vY29tcHV0ZUF4aXNMYXlvdXQnO1xuXG5leHBvcnQgY29uc3QgREVGQVVMVF9MQUJFTF9BTkdMRSA9IDQwO1xuXG4vLyBBZGRpdGlvbmFsIG1hcmdpbiB0byBhdm9pZCBjb250ZW50IGhpZGRlbiBiZWhpbmQgc2Nyb2xsIGJhclxuY29uc3QgT1ZFUkZMT1dfTUFSR0lOID0gODtcblxuZXhwb3J0IGludGVyZmFjZSBYWUNoYXJ0TGF5b3V0Q29uZmlnPFhPdXRwdXQgZXh0ZW5kcyBWYWx1ZSwgWU91dHB1dCBleHRlbmRzIFZhbHVlPiB7XG4gIHdpZHRoOiBudW1iZXI7XG4gIGhlaWdodDogbnVtYmVyO1xuICBtaW5Db250ZW50V2lkdGg/OiBudW1iZXI7XG4gIG1pbkNvbnRlbnRIZWlnaHQ/OiBudW1iZXI7XG4gIG1hcmdpbjogTWFyZ2luO1xuICB4RW5jb2RlcjogQ2hhbm5lbEVuY29kZXI8WEZpZWxkRGVmPFhPdXRwdXQ+LCBYT3V0cHV0PjtcbiAgeFRpY2tTaXplPzogbnVtYmVyO1xuICB4VGlja1RleHRTdHlsZT86IENTU1Byb3BlcnRpZXM7XG4gIGF1dG9BZGp1c3RYTWFyZ2luPzogYm9vbGVhbjtcbiAgeUVuY29kZXI6IENoYW5uZWxFbmNvZGVyPFlGaWVsZERlZjxZT3V0cHV0PiwgWU91dHB1dD47XG4gIHlUaWNrU2l6ZT86IG51bWJlcjtcbiAgeVRpY2tUZXh0U3R5bGU/OiBDU1NQcm9wZXJ0aWVzO1xuICBhdXRvQWRqdXN0WU1hcmdpbj86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFhZQ2hhcnRMYXlvdXQ8WE91dHB1dCBleHRlbmRzIFZhbHVlLCBZT3V0cHV0IGV4dGVuZHMgVmFsdWU+IHtcbiAgY2hhcnRXaWR0aDogbnVtYmVyO1xuXG4gIGNoYXJ0SGVpZ2h0OiBudW1iZXI7XG5cbiAgY29udGFpbmVyV2lkdGg6IG51bWJlcjtcblxuICBjb250YWluZXJIZWlnaHQ6IG51bWJlcjtcblxuICBtYXJnaW46IE1hcmdpbjtcblxuICB4RW5jb2RlcjogQ2hhbm5lbEVuY29kZXI8WEZpZWxkRGVmPFhPdXRwdXQ+LCBYT3V0cHV0PjtcblxuICB4TGF5b3V0PzogQXhpc0xheW91dDtcblxuICB5RW5jb2RlcjogQ2hhbm5lbEVuY29kZXI8WUZpZWxkRGVmPFlPdXRwdXQ+LCBZT3V0cHV0PjtcblxuICB5TGF5b3V0PzogQXhpc0xheW91dDtcblxuICBjb25zdHJ1Y3Rvcihjb25maWc6IFhZQ2hhcnRMYXlvdXRDb25maWc8WE91dHB1dCwgWU91dHB1dD4pIHtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIG1pbkNvbnRlbnRXaWR0aCA9IDAsXG4gICAgICBtaW5Db250ZW50SGVpZ2h0ID0gMCxcbiAgICAgIG1hcmdpbixcbiAgICAgIHhFbmNvZGVyLFxuICAgICAgeFRpY2tTaXplLFxuICAgICAgeFRpY2tUZXh0U3R5bGUsXG4gICAgICBhdXRvQWRqdXN0WE1hcmdpbiA9IHRydWUsXG4gICAgICB5RW5jb2RlcixcbiAgICAgIHlUaWNrU2l6ZSxcbiAgICAgIHlUaWNrVGV4dFN0eWxlLFxuICAgICAgYXV0b0FkanVzdFlNYXJnaW4gPSB0cnVlLFxuICAgIH0gPSBjb25maWc7XG5cbiAgICB0aGlzLnhFbmNvZGVyID0geEVuY29kZXI7XG4gICAgdGhpcy55RW5jb2RlciA9IHlFbmNvZGVyO1xuXG4gICAgaWYgKHR5cGVvZiB5RW5jb2Rlci5heGlzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy55TGF5b3V0ID0gY29tcHV0ZUF4aXNMYXlvdXQoeUVuY29kZXIuYXhpcywge1xuICAgICAgICBheGlzV2lkdGg6IE1hdGgubWF4KGhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tKSxcbiAgICAgICAgZGVmYXVsdFRpY2tTaXplOiB5VGlja1NpemUsXG4gICAgICAgIHRpY2tUZXh0U3R5bGU6IHlUaWNrVGV4dFN0eWxlLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2Vjb25kTWFyZ2luID1cbiAgICAgIHRoaXMueUxheW91dCAmJiBhdXRvQWRqdXN0WU1hcmdpbiA/IG1lcmdlTWFyZ2luKG1hcmdpbiwgdGhpcy55TGF5b3V0Lm1pbk1hcmdpbikgOiBtYXJnaW47XG4gICAgY29uc3QgaW5uZXJXaWR0aCA9IE1hdGgubWF4KHdpZHRoIC0gc2Vjb25kTWFyZ2luLmxlZnQgLSBzZWNvbmRNYXJnaW4ucmlnaHQsIG1pbkNvbnRlbnRXaWR0aCk7XG5cbiAgICBpZiAodHlwZW9mIHhFbmNvZGVyLmF4aXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLnhMYXlvdXQgPSBjb21wdXRlQXhpc0xheW91dCh4RW5jb2Rlci5heGlzLCB7XG4gICAgICAgIGF4aXNXaWR0aDogaW5uZXJXaWR0aCxcbiAgICAgICAgZGVmYXVsdFRpY2tTaXplOiB4VGlja1NpemUsXG4gICAgICAgIHRpY2tUZXh0U3R5bGU6IHhUaWNrVGV4dFN0eWxlLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgZmluYWxNYXJnaW4gPVxuICAgICAgdGhpcy54TGF5b3V0ICYmIGF1dG9BZGp1c3RYTWFyZ2luXG4gICAgICAgID8gbWVyZ2VNYXJnaW4oc2Vjb25kTWFyZ2luLCB0aGlzLnhMYXlvdXQubWluTWFyZ2luKVxuICAgICAgICA6IHNlY29uZE1hcmdpbjtcblxuICAgIGNvbnN0IGlubmVySGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0IC0gZmluYWxNYXJnaW4udG9wIC0gZmluYWxNYXJnaW4uYm90dG9tLCBtaW5Db250ZW50SGVpZ2h0KTtcblxuICAgIGNvbnN0IGNoYXJ0V2lkdGggPSBNYXRoLnJvdW5kKGlubmVyV2lkdGggKyBmaW5hbE1hcmdpbi5sZWZ0ICsgZmluYWxNYXJnaW4ucmlnaHQpO1xuICAgIGNvbnN0IGNoYXJ0SGVpZ2h0ID0gTWF0aC5yb3VuZChpbm5lckhlaWdodCArIGZpbmFsTWFyZ2luLnRvcCArIGZpbmFsTWFyZ2luLmJvdHRvbSk7XG5cbiAgICBjb25zdCBpc092ZXJGbG93WCA9IGNoYXJ0V2lkdGggPiB3aWR0aDtcbiAgICBjb25zdCBpc092ZXJGbG93WSA9IGNoYXJ0SGVpZ2h0ID4gaGVpZ2h0O1xuICAgIGlmIChpc092ZXJGbG93WCkge1xuICAgICAgZmluYWxNYXJnaW4uYm90dG9tICs9IE9WRVJGTE9XX01BUkdJTjtcbiAgICB9XG4gICAgaWYgKGlzT3ZlckZsb3dZKSB7XG4gICAgICBmaW5hbE1hcmdpbi5yaWdodCArPSBPVkVSRkxPV19NQVJHSU47XG4gICAgfVxuICAgIHRoaXMuY2hhcnRXaWR0aCA9IGlzT3ZlckZsb3dYID8gY2hhcnRXaWR0aCArIE9WRVJGTE9XX01BUkdJTiA6IGNoYXJ0V2lkdGg7XG4gICAgdGhpcy5jaGFydEhlaWdodCA9IGlzT3ZlckZsb3dZID8gY2hhcnRIZWlnaHQgKyBPVkVSRkxPV19NQVJHSU4gOiBjaGFydEhlaWdodDtcbiAgICB0aGlzLmNvbnRhaW5lcldpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5jb250YWluZXJIZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5tYXJnaW4gPSBmaW5hbE1hcmdpbjtcbiAgfVxuXG4gIHJlbmRlckNoYXJ0V2l0aEZyYW1lKHJlbmRlckNoYXJ0OiAoaW5wdXQ6IERpbWVuc2lvbikgPT4gUmVhY3ROb2RlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxDaGFydEZyYW1lXG4gICAgICAgIHdpZHRoPXt0aGlzLmNvbnRhaW5lcldpZHRofVxuICAgICAgICBoZWlnaHQ9e3RoaXMuY29udGFpbmVySGVpZ2h0fVxuICAgICAgICBjb250ZW50V2lkdGg9e3RoaXMuY2hhcnRXaWR0aH1cbiAgICAgICAgY29udGVudEhlaWdodD17dGhpcy5jaGFydEhlaWdodH1cbiAgICAgICAgcmVuZGVyQ29udGVudD17cmVuZGVyQ2hhcnR9XG4gICAgICAvPlxuICAgICk7XG4gIH1cblxuICByZW5kZXJYQXhpcyhwcm9wcz86IFBsYWluT2JqZWN0KSB7XG4gICAgY29uc3QgeyBheGlzIH0gPSB0aGlzLnhFbmNvZGVyO1xuXG4gICAgcmV0dXJuIGF4aXMgJiYgdGhpcy54TGF5b3V0ID8gKFxuICAgICAgPFhBeGlzXG4gICAgICAgIGxhYmVsPXtheGlzLmdldFRpdGxlKCl9XG4gICAgICAgIGxhYmVsT2Zmc2V0PXt0aGlzLnhMYXlvdXQubGFiZWxPZmZzZXR9XG4gICAgICAgIG51bVRpY2tzPXtheGlzLmNvbmZpZy50aWNrQ291bnR9XG4gICAgICAgIG9yaWVudGF0aW9uPXtheGlzLmNvbmZpZy5vcmllbnR9XG4gICAgICAgIHRpY2tDb21wb25lbnQ9e2NyZWF0ZVRpY2tDb21wb25lbnQodGhpcy54TGF5b3V0KX1cbiAgICAgICAgdGlja0Zvcm1hdD17YXhpcy5mb3JtYXRWYWx1ZX1cbiAgICAgICAgey4uLnByb3BzfVxuICAgICAgLz5cbiAgICApIDogbnVsbDtcbiAgfVxuXG4gIHJlbmRlcllBeGlzKHByb3BzPzogUGxhaW5PYmplY3QpIHtcbiAgICBjb25zdCB7IGF4aXMgfSA9IHRoaXMueUVuY29kZXI7XG5cbiAgICByZXR1cm4gYXhpcyAmJiB0aGlzLnlMYXlvdXQgPyAoXG4gICAgICA8WUF4aXNcbiAgICAgICAgbGFiZWw9e2F4aXMuZ2V0VGl0bGUoKX1cbiAgICAgICAgbGFiZWxPZmZzZXQ9e3RoaXMueUxheW91dC5sYWJlbE9mZnNldH1cbiAgICAgICAgbnVtVGlja3M9e2F4aXMuY29uZmlnLnRpY2tDb3VudH1cbiAgICAgICAgb3JpZW50YXRpb249e2F4aXMuY29uZmlnLm9yaWVudH1cbiAgICAgICAgdGlja0Zvcm1hdD17YXhpcy5mb3JtYXRWYWx1ZX1cbiAgICAgICAgey4uLnByb3BzfVxuICAgICAgLz5cbiAgICApIDogbnVsbDtcbiAgfVxufVxuIiwiaW1wb3J0IHsgQ2hhcnRUaGVtZSB9IGZyb20gJ0BkYXRhLXVpL3RoZW1lJztcbmltcG9ydCB7IFZhbHVlIH0gZnJvbSAnZW5jb2RhYmxlJztcbmltcG9ydCBYWUNoYXJ0TGF5b3V0LCB7IFhZQ2hhcnRMYXlvdXRDb25maWcgfSBmcm9tICcuL1hZQ2hhcnRMYXlvdXQnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVYWUNoYXJ0TGF5b3V0V2l0aFRoZW1lPFhPdXRwdXQgZXh0ZW5kcyBWYWx1ZSwgWU91dHB1dCBleHRlbmRzIFZhbHVlPihcbiAgY29uZmlnOiBYWUNoYXJ0TGF5b3V0Q29uZmlnPFhPdXRwdXQsIFlPdXRwdXQ+ICYge1xuICAgIHRoZW1lOiBDaGFydFRoZW1lO1xuICB9LFxuKSB7XG4gIGNvbnN0IHsgdGhlbWUsIC4uLnJlc3QgfSA9IGNvbmZpZztcblxuICByZXR1cm4gbmV3IFhZQ2hhcnRMYXlvdXQ8WE91dHB1dCwgWU91dHB1dD4oe1xuICAgIC4uLnJlc3QsXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHhUaWNrU2l6ZTogdGhlbWUueFRpY2tTdHlsZXMubGVuZ3RoIHx8IHRoZW1lLnhUaWNrU3R5bGVzLnRpY2tMZW5ndGgsXG4gICAgeFRpY2tUZXh0U3R5bGU6IHRoZW1lLnhUaWNrU3R5bGVzLmxhYmVsLmJvdHRvbSB8fCB0aGVtZS54VGlja1N0eWxlcy5sYWJlbC50b3AsXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHlUaWNrU2l6ZTogdGhlbWUueVRpY2tTdHlsZXMubGVuZ3RoIHx8IHRoZW1lLnlUaWNrU3R5bGVzLnRpY2tMZW5ndGgsXG4gICAgeVRpY2tUZXh0U3R5bGU6IHRoZW1lLnlUaWNrU3R5bGVzLmxhYmVsLmxlZnQgfHwgdGhlbWUueVRpY2tTdHlsZXMubGFiZWwucmlnaHQsXG4gIH0pO1xufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBSUE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBV0E7QUFFQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7Ozs7QUNyRkE7QUFrQkE7QUFrQkE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBU0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFrQkE7QUFtQkE7QUFDQTtBQWdCQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQVNBO0FBRUE7QUFDQTtBQUVBO0FBV0E7QUFFQTtBQUNBO0FBRUE7QUFVQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3hKQTtBQUVBO0FBS0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1980\n")},1981:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"a\", function() { return /* binding */ createRenderLegend; });\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react/index.js\nvar react = __webpack_require__(0);\nvar react_default = /*#__PURE__*/__webpack_require__.n(react);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/legend/esm/legends/Legend/LegendItem.js\nvar LegendItem = __webpack_require__(2254);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/legend/esm/legends/Legend/LegendLabel.js\nvar LegendLabel = __webpack_require__(2255);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/components/legend/DefaultLegendItem.tsx\n\n\nconst MARK_SIZE = 8;\nconst MARK_STYLE = { display: 'inline-block' };\nfunction DefaultLegendItem({ group, item, MarkRenderer, LabelRenderer, }) {\n    var _a, _b, _c, _d;\n    return (react_default.a.createElement(LegendItem[\"a\" /* default */], { key: `legend-item-${group.field}-${item.input}`, margin: \"0 5px\" },\n        typeof MarkRenderer === 'undefined' ? (react_default.a.createElement(\"svg\", { width: MARK_SIZE, height: MARK_SIZE, style: MARK_STYLE },\n            react_default.a.createElement(\"circle\", { fill: \n                // @ts-ignore\n                ((_c = (_b = (_a = item.output.color) !== null && _a !== void 0 ? _a : \n                // @ts-ignore\n                item.output.fill) !== null && _b !== void 0 ? _b : \n                // @ts-ignore\n                item.output.stroke) !== null && _c !== void 0 ? _c : '#ccc'), stroke: \n                // @ts-ignore\n                ((_d = item.output.stroke) !== null && _d !== void 0 ? _d : 'none'), r: MARK_SIZE / 2, cx: MARK_SIZE / 2, cy: MARK_SIZE / 2 }))) : (react_default.a.createElement(MarkRenderer, { group: group, item: item })),\n        typeof LabelRenderer === 'undefined' ? (react_default.a.createElement(LegendLabel[\"a\" /* default */], { align: \"left\", margin: \"0 0 0 4px\" }, item.input)) : (react_default.a.createElement(LabelRenderer, { group: group, item: item }))));\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/components/legend/DefaultLegendGroup.tsx\n\n\nconst LEGEND_GROUP_STYLE = {\n    display: 'flex',\n    flexBasis: 'auto',\n    flexDirection: 'row',\n    flexGrow: 1,\n    flexShrink: 1,\n    flexWrap: 'wrap',\n    fontSize: '0.8em',\n    justifyContent: 'flex-end',\n    padding: 8,\n};\nfunction DefaultLegendGroupRenderer({ group, ItemRenderer = DefaultLegendItem, ItemMarkRenderer, ItemLabelRenderer, style, }) {\n    const combinedStyle = typeof style === 'undefined' ? LEGEND_GROUP_STYLE : Object.assign(Object.assign({}, LEGEND_GROUP_STYLE), style);\n    return (react_default.a.createElement(\"div\", { style: combinedStyle }, 'items' in group &&\n        group.items.map(item => (react_default.a.createElement(ItemRenderer, { key: `legend-item-${group.field}-${item.input}`, group: group, item: item, MarkRenderer: ItemMarkRenderer, LabelRenderer: ItemLabelRenderer })))));\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/components/legend/DefaultLegend.tsx\n\n\nconst LEGEND_CONTAINER_STYLE = {\n    display: 'flex',\n    flexBasis: 'auto',\n    flexGrow: 1,\n    flexShrink: 1,\n    maxHeight: 100,\n    overflowY: 'auto',\n    position: 'relative',\n};\nclass DefaultLegend_DefaultLegend extends react[\"PureComponent\"] {\n    render() {\n        const { groups, LegendGroupRenderer = DefaultLegendGroupRenderer, LegendItemRenderer, LegendItemMarkRenderer, LegendItemLabelRenderer, style, } = this.props;\n        const combinedStyle = typeof style === 'undefined'\n            ? LEGEND_CONTAINER_STYLE\n            : Object.assign(Object.assign({}, LEGEND_CONTAINER_STYLE), style);\n        return (react_default.a.createElement(\"div\", { style: combinedStyle }, groups\n            .filter(group => 'items' in group && group.items.length > 0)\n            .map(group => (react_default.a.createElement(LegendGroupRenderer, { key: group.field, group: group, ItemRenderer: LegendItemRenderer, ItemMarkRenderer: LegendItemMarkRenderer, ItemLabelRenderer: LegendItemLabelRenderer })))));\n    }\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/components/legend/createRenderLegend.tsx\n\n\nfunction createRenderLegend(encoder, data, props) {\n    if (encoder.hasLegend()) {\n        const { LegendRenderer = DefaultLegend_DefaultLegend, LegendGroupRenderer, LegendItemRenderer, LegendItemLabelRenderer, LegendItemMarkRenderer, } = props;\n        return () => (react_default.a.createElement(LegendRenderer, { groups: encoder.getLegendInformation(data), LegendGroupRenderer: LegendGroupRenderer, LegendItemRenderer: LegendItemRenderer, LegendItemMarkRenderer: LegendItemMarkRenderer, LegendItemLabelRenderer: LegendItemLabelRenderer }));\n    }\n    return undefined;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk4MS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wcmVzZXQtY2hhcnQteHkvc3JjL2NvbXBvbmVudHMvbGVnZW5kL0RlZmF1bHRMZWdlbmRJdGVtLnRzeD9hMTZmIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wcmVzZXQtY2hhcnQteHkvc3JjL2NvbXBvbmVudHMvbGVnZW5kL0RlZmF1bHRMZWdlbmRHcm91cC50c3g/NWM4MSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvcHJlc2V0LWNoYXJ0LXh5L3NyYy9jb21wb25lbnRzL2xlZ2VuZC9EZWZhdWx0TGVnZW5kLnRzeD9jMzA1Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wcmVzZXQtY2hhcnQteHkvc3JjL2NvbXBvbmVudHMvbGVnZW5kL2NyZWF0ZVJlbmRlckxlZ2VuZC50c3g/YTk1NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgQ1NTUHJvcGVydGllcyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IExlZ2VuZEl0ZW0sIExlZ2VuZExhYmVsIH0gZnJvbSAnQHZ4L2xlZ2VuZCc7XG5pbXBvcnQgeyBFbmNvZGluZ0NvbmZpZyB9IGZyb20gJ2VuY29kYWJsZSc7XG5pbXBvcnQgeyBMZWdlbmRJdGVtUmVuZGVyZXJQcm9wcyB9IGZyb20gJy4vdHlwZXMnO1xuXG5jb25zdCBNQVJLX1NJWkUgPSA4O1xuXG5jb25zdCBNQVJLX1NUWUxFOiBDU1NQcm9wZXJ0aWVzID0geyBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyB9O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEZWZhdWx0TGVnZW5kSXRlbTxDb25maWcgZXh0ZW5kcyBFbmNvZGluZ0NvbmZpZz4oe1xuICBncm91cCxcbiAgaXRlbSxcbiAgTWFya1JlbmRlcmVyLFxuICBMYWJlbFJlbmRlcmVyLFxufTogTGVnZW5kSXRlbVJlbmRlcmVyUHJvcHM8Q29uZmlnPikge1xuICByZXR1cm4gKFxuICAgIDxMZWdlbmRJdGVtIGtleT17YGxlZ2VuZC1pdGVtLSR7Z3JvdXAuZmllbGR9LSR7aXRlbS5pbnB1dH1gfSBtYXJnaW49XCIwIDVweFwiPlxuICAgICAge3R5cGVvZiBNYXJrUmVuZGVyZXIgPT09ICd1bmRlZmluZWQnID8gKFxuICAgICAgICA8c3ZnIHdpZHRoPXtNQVJLX1NJWkV9IGhlaWdodD17TUFSS19TSVpFfSBzdHlsZT17TUFSS19TVFlMRX0+XG4gICAgICAgICAgPGNpcmNsZVxuICAgICAgICAgICAgZmlsbD17XG4gICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgKGl0ZW0ub3V0cHV0LmNvbG9yID8/XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGl0ZW0ub3V0cHV0LmZpbGwgPz9cbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgaXRlbS5vdXRwdXQuc3Ryb2tlID8/XG4gICAgICAgICAgICAgICAgJyNjY2MnKSBhcyBzdHJpbmdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cm9rZT17XG4gICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgKGl0ZW0ub3V0cHV0LnN0cm9rZSA/PyAnbm9uZScpIGFzIHN0cmluZ1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcj17TUFSS19TSVpFIC8gMn1cbiAgICAgICAgICAgIGN4PXtNQVJLX1NJWkUgLyAyfVxuICAgICAgICAgICAgY3k9e01BUktfU0laRSAvIDJ9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9zdmc+XG4gICAgICApIDogKFxuICAgICAgICA8TWFya1JlbmRlcmVyIGdyb3VwPXtncm91cH0gaXRlbT17aXRlbX0gLz5cbiAgICAgICl9XG4gICAgICB7dHlwZW9mIExhYmVsUmVuZGVyZXIgPT09ICd1bmRlZmluZWQnID8gKFxuICAgICAgICA8TGVnZW5kTGFiZWwgYWxpZ249XCJsZWZ0XCIgbWFyZ2luPVwiMCAwIDAgNHB4XCI+XG4gICAgICAgICAge2l0ZW0uaW5wdXR9XG4gICAgICAgIDwvTGVnZW5kTGFiZWw+XG4gICAgICApIDogKFxuICAgICAgICA8TGFiZWxSZW5kZXJlciBncm91cD17Z3JvdXB9IGl0ZW09e2l0ZW19IC8+XG4gICAgICApfVxuICAgIDwvTGVnZW5kSXRlbT5cbiAgKTtcbn1cbiIsImltcG9ydCBSZWFjdCwgeyBDU1NQcm9wZXJ0aWVzIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgRW5jb2RpbmdDb25maWcgfSBmcm9tICdlbmNvZGFibGUnO1xuaW1wb3J0IHsgTGVnZW5kR3JvdXBSZW5kZXJlclByb3BzIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgRGVmYXVsdExlZ2VuZEl0ZW0gZnJvbSAnLi9EZWZhdWx0TGVnZW5kSXRlbSc7XG5cbmNvbnN0IExFR0VORF9HUk9VUF9TVFlMRTogQ1NTUHJvcGVydGllcyA9IHtcbiAgZGlzcGxheTogJ2ZsZXgnLFxuICBmbGV4QmFzaXM6ICdhdXRvJyxcbiAgZmxleERpcmVjdGlvbjogJ3JvdycsXG4gIGZsZXhHcm93OiAxLFxuICBmbGV4U2hyaW5rOiAxLFxuICBmbGV4V3JhcDogJ3dyYXAnLFxuICBmb250U2l6ZTogJzAuOGVtJyxcbiAganVzdGlmeUNvbnRlbnQ6ICdmbGV4LWVuZCcsXG4gIHBhZGRpbmc6IDgsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEZWZhdWx0TGVnZW5kR3JvdXBSZW5kZXJlcjxDb25maWcgZXh0ZW5kcyBFbmNvZGluZ0NvbmZpZz4oe1xuICBncm91cCxcbiAgSXRlbVJlbmRlcmVyID0gRGVmYXVsdExlZ2VuZEl0ZW0sXG4gIEl0ZW1NYXJrUmVuZGVyZXIsXG4gIEl0ZW1MYWJlbFJlbmRlcmVyLFxuICBzdHlsZSxcbn06IExlZ2VuZEdyb3VwUmVuZGVyZXJQcm9wczxDb25maWc+KSB7XG4gIGNvbnN0IGNvbWJpbmVkU3R5bGUgPVxuICAgIHR5cGVvZiBzdHlsZSA9PT0gJ3VuZGVmaW5lZCcgPyBMRUdFTkRfR1JPVVBfU1RZTEUgOiB7IC4uLkxFR0VORF9HUk9VUF9TVFlMRSwgLi4uc3R5bGUgfTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgc3R5bGU9e2NvbWJpbmVkU3R5bGV9PlxuICAgICAgeydpdGVtcycgaW4gZ3JvdXAgJiZcbiAgICAgICAgZ3JvdXAuaXRlbXMubWFwKGl0ZW0gPT4gKFxuICAgICAgICAgIDxJdGVtUmVuZGVyZXJcbiAgICAgICAgICAgIGtleT17YGxlZ2VuZC1pdGVtLSR7Z3JvdXAuZmllbGR9LSR7aXRlbS5pbnB1dH1gfVxuICAgICAgICAgICAgZ3JvdXA9e2dyb3VwfVxuICAgICAgICAgICAgaXRlbT17aXRlbX1cbiAgICAgICAgICAgIE1hcmtSZW5kZXJlcj17SXRlbU1hcmtSZW5kZXJlcn1cbiAgICAgICAgICAgIExhYmVsUmVuZGVyZXI9e0l0ZW1MYWJlbFJlbmRlcmVyfVxuICAgICAgICAgIC8+XG4gICAgICAgICkpfVxuICAgIDwvZGl2PlxuICApO1xufVxuIiwiaW1wb3J0IFJlYWN0LCB7IENTU1Byb3BlcnRpZXMsIFB1cmVDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBFbmNvZGluZ0NvbmZpZyB9IGZyb20gJ2VuY29kYWJsZSc7XG5pbXBvcnQgeyBMZWdlbmRSZW5kZXJlclByb3BzIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgRGVmYXVsdExlZ2VuZEdyb3VwIGZyb20gJy4vRGVmYXVsdExlZ2VuZEdyb3VwJztcblxuY29uc3QgTEVHRU5EX0NPTlRBSU5FUl9TVFlMRTogQ1NTUHJvcGVydGllcyA9IHtcbiAgZGlzcGxheTogJ2ZsZXgnLFxuICBmbGV4QmFzaXM6ICdhdXRvJyxcbiAgZmxleEdyb3c6IDEsXG4gIGZsZXhTaHJpbms6IDEsXG4gIG1heEhlaWdodDogMTAwLFxuICBvdmVyZmxvd1k6ICdhdXRvJyxcbiAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG59O1xuXG5leHBvcnQgdHlwZSBQcm9wczxDb25maWcgZXh0ZW5kcyBFbmNvZGluZ0NvbmZpZz4gPSBMZWdlbmRSZW5kZXJlclByb3BzPENvbmZpZz47XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlZmF1bHRMZWdlbmQ8Q29uZmlnIGV4dGVuZHMgRW5jb2RpbmdDb25maWc+IGV4dGVuZHMgUHVyZUNvbXBvbmVudDxcbiAgUHJvcHM8Q29uZmlnPlxuPiB7XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBncm91cHMsXG4gICAgICBMZWdlbmRHcm91cFJlbmRlcmVyID0gRGVmYXVsdExlZ2VuZEdyb3VwLFxuICAgICAgTGVnZW5kSXRlbVJlbmRlcmVyLFxuICAgICAgTGVnZW5kSXRlbU1hcmtSZW5kZXJlcixcbiAgICAgIExlZ2VuZEl0ZW1MYWJlbFJlbmRlcmVyLFxuICAgICAgc3R5bGUsXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCBjb21iaW5lZFN0eWxlID1cbiAgICAgIHR5cGVvZiBzdHlsZSA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyBMRUdFTkRfQ09OVEFJTkVSX1NUWUxFXG4gICAgICAgIDogeyAuLi5MRUdFTkRfQ09OVEFJTkVSX1NUWUxFLCAuLi5zdHlsZSB9O1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgc3R5bGU9e2NvbWJpbmVkU3R5bGV9PlxuICAgICAgICB7Z3JvdXBzXG4gICAgICAgICAgLmZpbHRlcihncm91cCA9PiAnaXRlbXMnIGluIGdyb3VwICYmIGdyb3VwLml0ZW1zLmxlbmd0aCA+IDApXG4gICAgICAgICAgLm1hcChncm91cCA9PiAoXG4gICAgICAgICAgICA8TGVnZW5kR3JvdXBSZW5kZXJlclxuICAgICAgICAgICAgICBrZXk9e2dyb3VwLmZpZWxkfVxuICAgICAgICAgICAgICBncm91cD17Z3JvdXB9XG4gICAgICAgICAgICAgIEl0ZW1SZW5kZXJlcj17TGVnZW5kSXRlbVJlbmRlcmVyfVxuICAgICAgICAgICAgICBJdGVtTWFya1JlbmRlcmVyPXtMZWdlbmRJdGVtTWFya1JlbmRlcmVyfVxuICAgICAgICAgICAgICBJdGVtTGFiZWxSZW5kZXJlcj17TGVnZW5kSXRlbUxhYmVsUmVuZGVyZXJ9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICkpfVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEVuY29kZXIsIEVuY29kaW5nQ29uZmlnLCBEYXRhc2V0IH0gZnJvbSAnZW5jb2RhYmxlJztcbmltcG9ydCB7IExlZ2VuZEhvb2tzIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgRGVmYXVsdExlZ2VuZCBmcm9tICcuL0RlZmF1bHRMZWdlbmQnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVSZW5kZXJMZWdlbmQ8Q29uZmlnIGV4dGVuZHMgRW5jb2RpbmdDb25maWc+KFxuICBlbmNvZGVyOiBFbmNvZGVyPENvbmZpZz4sXG4gIGRhdGE6IERhdGFzZXQsXG4gIHByb3BzOiBMZWdlbmRIb29rczxDb25maWc+LFxuKSB7XG4gIGlmIChlbmNvZGVyLmhhc0xlZ2VuZCgpKSB7XG4gICAgY29uc3Qge1xuICAgICAgTGVnZW5kUmVuZGVyZXIgPSBEZWZhdWx0TGVnZW5kLFxuICAgICAgTGVnZW5kR3JvdXBSZW5kZXJlcixcbiAgICAgIExlZ2VuZEl0ZW1SZW5kZXJlcixcbiAgICAgIExlZ2VuZEl0ZW1MYWJlbFJlbmRlcmVyLFxuICAgICAgTGVnZW5kSXRlbU1hcmtSZW5kZXJlcixcbiAgICB9ID0gcHJvcHM7XG5cbiAgICByZXR1cm4gKCkgPT4gKFxuICAgICAgPExlZ2VuZFJlbmRlcmVyXG4gICAgICAgIGdyb3Vwcz17ZW5jb2Rlci5nZXRMZWdlbmRJbmZvcm1hdGlvbihkYXRhKX1cbiAgICAgICAgTGVnZW5kR3JvdXBSZW5kZXJlcj17TGVnZW5kR3JvdXBSZW5kZXJlcn1cbiAgICAgICAgTGVnZW5kSXRlbVJlbmRlcmVyPXtMZWdlbmRJdGVtUmVuZGVyZXJ9XG4gICAgICAgIExlZ2VuZEl0ZW1NYXJrUmVuZGVyZXI9e0xlZ2VuZEl0ZW1NYXJrUmVuZGVyZXJ9XG4gICAgICAgIExlZ2VuZEl0ZW1MYWJlbFJlbmRlcmVyPXtMZWdlbmRJdGVtTGFiZWxSZW5kZXJlcn1cbiAgICAgIC8+XG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFJQTtBQUVBO0FBRUE7O0FBTUE7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQVVBO0FBU0E7OztBQ2xEQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBT0E7QUFHQTtBQUdBO0FBV0E7OztBQ3pDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFHQTtBQUNBO0FBU0E7QUFFQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBV0E7QUFDQTs7O0FDbkRBO0FBR0E7QUFFQTtBQUtBO0FBQ0E7QUFRQTtBQVNBO0FBRUE7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1981\n")},2173:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* unused harmony export Glyph */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return GlyphDot; });\n/* unused harmony export GlyphCross */\n/* unused harmony export GlyphDiamond */\n/* unused harmony export GlyphStar */\n/* unused harmony export GlyphTriangle */\n/* unused harmony export GlyphWye */\n/* unused harmony export GlyphSquare */\n/* unused harmony export GlyphCircle */\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _vx_group__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1941);\n/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(76);\n/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1975);\n/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1952);\n/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(1953);\n/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(1955);\n/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(1956);\n/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(1957);\n/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(1954);\n/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(1951);\n\n\n\n\n\nfunction Glyph(_ref) {\n  var _ref$top = _ref.top,\n      top = _ref$top === undefined ? 0 : _ref$top,\n      _ref$left = _ref.left,\n      left = _ref$left === undefined ? 0 : _ref$left,\n      className = _ref.className,\n      children = _ref.children;\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n    _vx_group__WEBPACK_IMPORTED_MODULE_1__[/* Group */ \"a\"],\n    { className: classnames__WEBPACK_IMPORTED_MODULE_2___default()('vx-glyph', className), top: top, left: left },\n    children\n  );\n}\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nfunction GlyphDot(_ref) {\n  var _ref$top = _ref.top,\n      top = _ref$top === undefined ? 0 : _ref$top,\n      _ref$left = _ref.left,\n      left = _ref$left === undefined ? 0 : _ref$left,\n      className = _ref.className,\n      children = _ref.children,\n      cx$$1 = _ref.cx,\n      cy = _ref.cy,\n      r = _ref.r,\n      fill = _ref.fill,\n      stroke = _ref.stroke,\n      strokeWidth = _ref.strokeWidth,\n      strokeDasharray = _ref.strokeDasharray,\n      restProps = objectWithoutProperties(_ref, ['top', 'left', 'className', 'children', 'cx', 'cy', 'r', 'fill', 'stroke', 'strokeWidth', 'strokeDasharray']);\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n    Glyph,\n    { top: top, left: left },\n    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('circle', _extends({\n      className: classnames__WEBPACK_IMPORTED_MODULE_2___default()('vx-glyph-dot', className),\n      cx: cx$$1,\n      cy: cy,\n      r: r,\n      fill: fill,\n      stroke: stroke,\n      strokeWidth: strokeWidth,\n      strokeDasharray: strokeDasharray\n    }, restProps)),\n    children\n  );\n}\n\nfunction callOrValue(maybeFn, data) {\n  if (typeof maybeFn === 'function') {\n    return maybeFn(data);\n  }\n  return maybeFn;\n}\n\nfunction additionalProps(restProps, data) {\n  return Object.keys(restProps).reduce(function (ret, cur) {\n    ret[cur] = callOrValue(restProps[cur], data);\n    return ret;\n  }, {});\n}\n\nfunction GlyphCross(_ref) {\n  var children = _ref.children,\n      className = _ref.className,\n      top = _ref.top,\n      left = _ref.left,\n      size = _ref.size,\n      restProps = objectWithoutProperties(_ref, ['children', 'className', 'top', 'left', 'size']);\n\n  var path = Object(d3_shape__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])();\n  path.type(d3_shape__WEBPACK_IMPORTED_MODULE_4__[/* default */ \"a\"]);\n  if (size) path.size(size);\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n    Glyph,\n    { top: top, left: left },\n    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('path', _extends({\n      className: classnames__WEBPACK_IMPORTED_MODULE_2___default()('vx-glyph-cross', className),\n      d: path()\n    }, additionalProps(restProps))),\n    children\n  );\n}\n\nfunction GlyphDiamond(_ref) {\n  var children = _ref.children,\n      className = _ref.className,\n      top = _ref.top,\n      left = _ref.left,\n      size = _ref.size,\n      restProps = objectWithoutProperties(_ref, ['children', 'className', 'top', 'left', 'size']);\n\n  var path = Object(d3_shape__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])();\n  path.type(d3_shape__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"]);\n  if (size) path.size(size);\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n    Glyph,\n    { top: top, left: left },\n    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('path', _extends({\n      className: classnames__WEBPACK_IMPORTED_MODULE_2___default()('vx-glyph-diamond', className),\n      d: path()\n    }, additionalProps(restProps))),\n    children\n  );\n}\n\nfunction GlyphStar(_ref) {\n  var children = _ref.children,\n      className = _ref.className,\n      top = _ref.top,\n      left = _ref.left,\n      size = _ref.size,\n      restProps = objectWithoutProperties(_ref, ['children', 'className', 'top', 'left', 'size']);\n\n  var path = Object(d3_shape__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])();\n  path.type(d3_shape__WEBPACK_IMPORTED_MODULE_6__[/* default */ \"a\"]);\n  if (size) path.size(size);\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n    Glyph,\n    { top: top, left: left },\n    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('path', _extends({ className: classnames__WEBPACK_IMPORTED_MODULE_2___default()('vx-glyph-star', className), d: path() }, additionalProps(restProps))),\n    children\n  );\n}\n\nfunction GlyphTriangle(_ref) {\n  var children = _ref.children,\n      className = _ref.className,\n      top = _ref.top,\n      left = _ref.left,\n      size = _ref.size,\n      restProps = objectWithoutProperties(_ref, ['children', 'className', 'top', 'left', 'size']);\n\n  var path = Object(d3_shape__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])();\n  path.type(d3_shape__WEBPACK_IMPORTED_MODULE_7__[/* default */ \"a\"]);\n  if (size) path.size(size);\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n    Glyph,\n    { top: top, left: left },\n    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('path', _extends({\n      className: classnames__WEBPACK_IMPORTED_MODULE_2___default()('vx-glyph-triangle', className),\n      d: path()\n    }, additionalProps(restProps))),\n    children\n  );\n}\n\nfunction GlyphWye(_ref) {\n  var children = _ref.children,\n      className = _ref.className,\n      top = _ref.top,\n      left = _ref.left,\n      size = _ref.size,\n      restProps = objectWithoutProperties(_ref, ['children', 'className', 'top', 'left', 'size']);\n\n  var path = Object(d3_shape__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])();\n  path.type(d3_shape__WEBPACK_IMPORTED_MODULE_8__[/* default */ \"a\"]);\n  if (size) path.size(size);\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n    Glyph,\n    { top: top, left: left },\n    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('path', _extends({ className: classnames__WEBPACK_IMPORTED_MODULE_2___default()('vx-glyph-wye', className), d: path() }, additionalProps(restProps))),\n    children\n  );\n}\n\nfunction GlyphSquare(_ref) {\n  var children = _ref.children,\n      className = _ref.className,\n      top = _ref.top,\n      left = _ref.left,\n      size = _ref.size,\n      restProps = objectWithoutProperties(_ref, ['children', 'className', 'top', 'left', 'size']);\n\n  var path = Object(d3_shape__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])();\n  path.type(d3_shape__WEBPACK_IMPORTED_MODULE_9__[/* default */ \"a\"]);\n  if (size) path.size(size);\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n    Glyph,\n    { top: top, left: left },\n    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('path', _extends({\n      className: classnames__WEBPACK_IMPORTED_MODULE_2___default()('vx-glyph-square', className),\n      d: path()\n    }, additionalProps(restProps))),\n    children\n  );\n}\n\nfunction GlyphCircle(_ref) {\n  var children = _ref.children,\n      className = _ref.className,\n      top = _ref.top,\n      left = _ref.left,\n      size = _ref.size,\n      restProps = objectWithoutProperties(_ref, ['children', 'className', 'top', 'left', 'size']);\n\n  var path = Object(d3_shape__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])();\n  path.type(d3_shape__WEBPACK_IMPORTED_MODULE_10__[/* default */ \"a\"]);\n  if (size) path.size(size);\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n    Glyph,\n    { top: top, left: left },\n    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('path', _extends({\n      className: classnames__WEBPACK_IMPORTED_MODULE_2___default()('vx-glyph-circle', className),\n      d: path()\n    }, additionalProps(restProps))),\n    children\n  );\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjE3My5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL3h5LWNoYXJ0L25vZGVfbW9kdWxlcy9AdngvZ2x5cGgvZGlzdC92eC1nbHlwaC5lcy5qcz8yNTQ4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBHcm91cCB9IGZyb20gJ0B2eC9ncm91cCc7XG5pbXBvcnQgY3ggZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgeyBzeW1ib2wsIHN5bWJvbENyb3NzLCBzeW1ib2xEaWFtb25kLCBzeW1ib2xTdGFyLCBzeW1ib2xUcmlhbmdsZSwgc3ltYm9sV3llLCBzeW1ib2xTcXVhcmUsIHN5bWJvbENpcmNsZSB9IGZyb20gJ2QzLXNoYXBlJztcblxuZnVuY3Rpb24gR2x5cGgoX3JlZikge1xuICB2YXIgX3JlZiR0b3AgPSBfcmVmLnRvcCxcbiAgICAgIHRvcCA9IF9yZWYkdG9wID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiR0b3AsXG4gICAgICBfcmVmJGxlZnQgPSBfcmVmLmxlZnQsXG4gICAgICBsZWZ0ID0gX3JlZiRsZWZ0ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiRsZWZ0LFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW47XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgR3JvdXAsXG4gICAgeyBjbGFzc05hbWU6IGN4KCd2eC1nbHlwaCcsIGNsYXNzTmFtZSksIHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH0sXG4gICAgY2hpbGRyZW5cbiAgKTtcbn1cblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbnZhciBvYmplY3RXaXRob3V0UHJvcGVydGllcyA9IGZ1bmN0aW9uIChvYmosIGtleXMpIHtcbiAgdmFyIHRhcmdldCA9IHt9O1xuXG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTtcbiAgICB0YXJnZXRbaV0gPSBvYmpbaV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuZnVuY3Rpb24gR2x5cGhEb3QoX3JlZikge1xuICB2YXIgX3JlZiR0b3AgPSBfcmVmLnRvcCxcbiAgICAgIHRvcCA9IF9yZWYkdG9wID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiR0b3AsXG4gICAgICBfcmVmJGxlZnQgPSBfcmVmLmxlZnQsXG4gICAgICBsZWZ0ID0gX3JlZiRsZWZ0ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiRsZWZ0LFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBjeCQkMSA9IF9yZWYuY3gsXG4gICAgICBjeSA9IF9yZWYuY3ksXG4gICAgICByID0gX3JlZi5yLFxuICAgICAgZmlsbCA9IF9yZWYuZmlsbCxcbiAgICAgIHN0cm9rZSA9IF9yZWYuc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGggPSBfcmVmLnN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlRGFzaGFycmF5ID0gX3JlZi5zdHJva2VEYXNoYXJyYXksXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ3RvcCcsICdsZWZ0JywgJ2NsYXNzTmFtZScsICdjaGlsZHJlbicsICdjeCcsICdjeScsICdyJywgJ2ZpbGwnLCAnc3Ryb2tlJywgJ3N0cm9rZVdpZHRoJywgJ3N0cm9rZURhc2hhcnJheSddKTtcblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICBHbHlwaCxcbiAgICB7IHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH0sXG4gICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnY2lyY2xlJywgX2V4dGVuZHMoe1xuICAgICAgY2xhc3NOYW1lOiBjeCgndngtZ2x5cGgtZG90JywgY2xhc3NOYW1lKSxcbiAgICAgIGN4OiBjeCQkMSxcbiAgICAgIGN5OiBjeSxcbiAgICAgIHI6IHIsXG4gICAgICBmaWxsOiBmaWxsLFxuICAgICAgc3Ryb2tlOiBzdHJva2UsXG4gICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgICBzdHJva2VEYXNoYXJyYXk6IHN0cm9rZURhc2hhcnJheVxuICAgIH0sIHJlc3RQcm9wcykpLFxuICAgIGNoaWxkcmVuXG4gICk7XG59XG5cbmZ1bmN0aW9uIGNhbGxPclZhbHVlKG1heWJlRm4sIGRhdGEpIHtcbiAgaWYgKHR5cGVvZiBtYXliZUZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlRm4oZGF0YSk7XG4gIH1cbiAgcmV0dXJuIG1heWJlRm47XG59XG5cbmZ1bmN0aW9uIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHJlc3RQcm9wcykucmVkdWNlKGZ1bmN0aW9uIChyZXQsIGN1cikge1xuICAgIHJldFtjdXJdID0gY2FsbE9yVmFsdWUocmVzdFByb3BzW2N1cl0sIGRhdGEpO1xuICAgIHJldHVybiByZXQ7XG4gIH0sIHt9KTtcbn1cblxuZnVuY3Rpb24gR2x5cGhDcm9zcyhfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIHRvcCA9IF9yZWYudG9wLFxuICAgICAgbGVmdCA9IF9yZWYubGVmdCxcbiAgICAgIHNpemUgPSBfcmVmLnNpemUsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2NoaWxkcmVuJywgJ2NsYXNzTmFtZScsICd0b3AnLCAnbGVmdCcsICdzaXplJ10pO1xuXG4gIHZhciBwYXRoID0gc3ltYm9sKCk7XG4gIHBhdGgudHlwZShzeW1ib2xDcm9zcyk7XG4gIGlmIChzaXplKSBwYXRoLnNpemUoc2l6ZSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIEdseXBoLFxuICAgIHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfSxcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgICAgY2xhc3NOYW1lOiBjeCgndngtZ2x5cGgtY3Jvc3MnLCBjbGFzc05hbWUpLFxuICAgICAgZDogcGF0aCgpXG4gICAgfSwgYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcykpKSxcbiAgICBjaGlsZHJlblxuICApO1xufVxuXG5mdW5jdGlvbiBHbHlwaERpYW1vbmQoX3JlZikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICB0b3AgPSBfcmVmLnRvcCxcbiAgICAgIGxlZnQgPSBfcmVmLmxlZnQsXG4gICAgICBzaXplID0gX3JlZi5zaXplLFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgWydjaGlsZHJlbicsICdjbGFzc05hbWUnLCAndG9wJywgJ2xlZnQnLCAnc2l6ZSddKTtcblxuICB2YXIgcGF0aCA9IHN5bWJvbCgpO1xuICBwYXRoLnR5cGUoc3ltYm9sRGlhbW9uZCk7XG4gIGlmIChzaXplKSBwYXRoLnNpemUoc2l6ZSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIEdseXBoLFxuICAgIHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfSxcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgICAgY2xhc3NOYW1lOiBjeCgndngtZ2x5cGgtZGlhbW9uZCcsIGNsYXNzTmFtZSksXG4gICAgICBkOiBwYXRoKClcbiAgICB9LCBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzKSkpLFxuICAgIGNoaWxkcmVuXG4gICk7XG59XG5cbmZ1bmN0aW9uIEdseXBoU3RhcihfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIHRvcCA9IF9yZWYudG9wLFxuICAgICAgbGVmdCA9IF9yZWYubGVmdCxcbiAgICAgIHNpemUgPSBfcmVmLnNpemUsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2NoaWxkcmVuJywgJ2NsYXNzTmFtZScsICd0b3AnLCAnbGVmdCcsICdzaXplJ10pO1xuXG4gIHZhciBwYXRoID0gc3ltYm9sKCk7XG4gIHBhdGgudHlwZShzeW1ib2xTdGFyKTtcbiAgaWYgKHNpemUpIHBhdGguc2l6ZShzaXplKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgR2x5cGgsXG4gICAgeyB0b3A6IHRvcCwgbGVmdDogbGVmdCB9LFxuICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCBfZXh0ZW5kcyh7IGNsYXNzTmFtZTogY3goJ3Z4LWdseXBoLXN0YXInLCBjbGFzc05hbWUpLCBkOiBwYXRoKCkgfSwgYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcykpKSxcbiAgICBjaGlsZHJlblxuICApO1xufVxuXG5mdW5jdGlvbiBHbHlwaFRyaWFuZ2xlKF9yZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgdG9wID0gX3JlZi50b3AsXG4gICAgICBsZWZ0ID0gX3JlZi5sZWZ0LFxuICAgICAgc2l6ZSA9IF9yZWYuc2l6ZSxcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnY2hpbGRyZW4nLCAnY2xhc3NOYW1lJywgJ3RvcCcsICdsZWZ0JywgJ3NpemUnXSk7XG5cbiAgdmFyIHBhdGggPSBzeW1ib2woKTtcbiAgcGF0aC50eXBlKHN5bWJvbFRyaWFuZ2xlKTtcbiAgaWYgKHNpemUpIHBhdGguc2l6ZShzaXplKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgR2x5cGgsXG4gICAgeyB0b3A6IHRvcCwgbGVmdDogbGVmdCB9LFxuICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCBfZXh0ZW5kcyh7XG4gICAgICBjbGFzc05hbWU6IGN4KCd2eC1nbHlwaC10cmlhbmdsZScsIGNsYXNzTmFtZSksXG4gICAgICBkOiBwYXRoKClcbiAgICB9LCBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzKSkpLFxuICAgIGNoaWxkcmVuXG4gICk7XG59XG5cbmZ1bmN0aW9uIEdseXBoV3llKF9yZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgdG9wID0gX3JlZi50b3AsXG4gICAgICBsZWZ0ID0gX3JlZi5sZWZ0LFxuICAgICAgc2l6ZSA9IF9yZWYuc2l6ZSxcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnY2hpbGRyZW4nLCAnY2xhc3NOYW1lJywgJ3RvcCcsICdsZWZ0JywgJ3NpemUnXSk7XG5cbiAgdmFyIHBhdGggPSBzeW1ib2woKTtcbiAgcGF0aC50eXBlKHN5bWJvbFd5ZSk7XG4gIGlmIChzaXplKSBwYXRoLnNpemUoc2l6ZSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIEdseXBoLFxuICAgIHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfSxcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoeyBjbGFzc05hbWU6IGN4KCd2eC1nbHlwaC13eWUnLCBjbGFzc05hbWUpLCBkOiBwYXRoKCkgfSwgYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcykpKSxcbiAgICBjaGlsZHJlblxuICApO1xufVxuXG5mdW5jdGlvbiBHbHlwaFNxdWFyZShfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIHRvcCA9IF9yZWYudG9wLFxuICAgICAgbGVmdCA9IF9yZWYubGVmdCxcbiAgICAgIHNpemUgPSBfcmVmLnNpemUsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2NoaWxkcmVuJywgJ2NsYXNzTmFtZScsICd0b3AnLCAnbGVmdCcsICdzaXplJ10pO1xuXG4gIHZhciBwYXRoID0gc3ltYm9sKCk7XG4gIHBhdGgudHlwZShzeW1ib2xTcXVhcmUpO1xuICBpZiAoc2l6ZSkgcGF0aC5zaXplKHNpemUpO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICBHbHlwaCxcbiAgICB7IHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH0sXG4gICAgUmVhY3QuY3JlYXRlRWxlbWVudCgncGF0aCcsIF9leHRlbmRzKHtcbiAgICAgIGNsYXNzTmFtZTogY3goJ3Z4LWdseXBoLXNxdWFyZScsIGNsYXNzTmFtZSksXG4gICAgICBkOiBwYXRoKClcbiAgICB9LCBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzKSkpLFxuICAgIGNoaWxkcmVuXG4gICk7XG59XG5cbmZ1bmN0aW9uIEdseXBoQ2lyY2xlKF9yZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgdG9wID0gX3JlZi50b3AsXG4gICAgICBsZWZ0ID0gX3JlZi5sZWZ0LFxuICAgICAgc2l6ZSA9IF9yZWYuc2l6ZSxcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnY2hpbGRyZW4nLCAnY2xhc3NOYW1lJywgJ3RvcCcsICdsZWZ0JywgJ3NpemUnXSk7XG5cbiAgdmFyIHBhdGggPSBzeW1ib2woKTtcbiAgcGF0aC50eXBlKHN5bWJvbENpcmNsZSk7XG4gIGlmIChzaXplKSBwYXRoLnNpemUoc2l6ZSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIEdseXBoLFxuICAgIHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfSxcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgICAgY2xhc3NOYW1lOiBjeCgndngtZ2x5cGgtY2lyY2xlJywgY2xhc3NOYW1lKSxcbiAgICAgIGQ6IHBhdGgoKVxuICAgIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMpKSksXG4gICAgY2hpbGRyZW5cbiAgKTtcbn1cblxuZXhwb3J0IHsgR2x5cGgsIEdseXBoRG90LCBHbHlwaENyb3NzLCBHbHlwaERpYW1vbmQsIEdseXBoU3RhciwgR2x5cGhUcmlhbmdsZSwgR2x5cGhXeWUsIEdseXBoU3F1YXJlLCBHbHlwaENpcmNsZSB9O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2173\n")},2220:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"a\", function() { return /* binding */ createEncoderFactory; });\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/reselect/es/index.js\nvar es = __webpack_require__(181);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/typeGuards/ChannelDef.js\nvar ChannelDef = __webpack_require__(1936);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/typeGuards/Base.js\nfunction isArray(maybeArray) {\n  return Array.isArray(maybeArray);\n}\nfunction isNotArray(maybeArray) {\n  return !Array.isArray(maybeArray);\n}\nfunction isDefined(value) {\n  return typeof value !== 'undefined' && value !== null;\n}\nfunction isEveryElementDefined(array) {\n  return array.every(isDefined);\n}\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-array/src/extent.js\nvar src_extent = __webpack_require__(290);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/types/scale/ScaleType.js\n// Modified from vega-lite\n// because vega-lite uses namespace which has issues with babel and typescript\nconst ScaleType = {\n  // Continuous - Quantitative\n  LINEAR: 'linear',\n  LOG: 'log',\n  POW: 'pow',\n  SQRT: 'sqrt',\n  SYMLOG: 'symlog',\n  // Continuous - Time\n  TIME: 'time',\n  UTC: 'utc',\n  // Discretizing scales\n  QUANTILE: 'quantile',\n  QUANTIZE: 'quantize',\n  THRESHOLD: 'threshold',\n  BIN_ORDINAL: 'bin-ordinal',\n  // Discrete scales\n  ORDINAL: 'ordinal',\n  POINT: 'point',\n  BAND: 'band'\n};\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/typeGuards/Channel.js\nfunction isX(channelType) {\n  return channelType === 'X' || channelType === 'XBand';\n}\nfunction isY(channelType) {\n  return channelType === 'Y' || channelType === 'YBand';\n}\nfunction isXOrY(channelType) {\n  return isX(channelType) || isY(channelType);\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/utils/keys.js\n/**\n * This is a stricter version of Object.keys but with better types.\n * See https://github.com/Microsoft/TypeScript/pull/12253#issuecomment-263132208\n */\nconst keys = Object.keys;\n/* harmony default export */ var utils_keys = (keys);\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/dateTimeToTimestamp.js\n// Modified from vega-lite version\n// and remove unnecessary dependency\n\n/* eslint-disable no-param-reassign */\n\n/* eslint-disable no-negated-condition */\n\n/**\n * Internal Object for defining datetime expressions.\n * This is an expression version of DateTime.\n * If both month and quarter are provided, month has higher precedence.\n * `day` cannot be combined with other date.\n */\n\nfunction invalidTimeUnit(unitName, value) {\n  return \"Invalid \" + unitName + \": \" + String(value) + \".\";\n}\n/*\n * A designated year that starts on Sunday.\n */\n\n\nconst SUNDAY_YEAR = 2006;\nconst MONTHS = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december'];\nconst SHORT_MONTHS = MONTHS.map(m => m.slice(0, 3));\nconst DAYS = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];\nconst SHORT_DAYS = DAYS.map(d => d.slice(0, 3));\n\nfunction isNumber(x) {\n  return typeof x === 'number';\n}\n/**\n * Returns whether the passed in value is a valid number.\n */\n\n\nfunction isNumeric(value) {\n  if (isNumber(value)) {\n    return true;\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  return !isNaN(value) && !isNaN(parseFloat(value));\n}\n\nfunction normalizeQuarter(q) {\n  if (isNumeric(q)) {\n    q = Number(q);\n  }\n\n  if (isNumber(q)) {\n    if (q > 4) {\n      // eslint-disable-next-line no-console\n      console.warn(invalidTimeUnit('quarter', q));\n    } // We accept 1-based quarter, so need to readjust to 0-based quarter\n\n\n    return q - 1;\n  } // Invalid quarter\n\n\n  throw new Error(invalidTimeUnit('quarter', q));\n}\nfunction normalizeMonth(m) {\n  if (isNumeric(m)) {\n    m = Number(m);\n  }\n\n  if (isNumber(m)) {\n    // We accept 1-based month, so need to readjust to 0-based month\n    return m - 1;\n  }\n\n  const lowerM = m.toLowerCase();\n  const monthIndex = MONTHS.indexOf(lowerM);\n\n  if (monthIndex !== -1) {\n    return monthIndex; // 0 for january, ...\n  }\n\n  const shortM = lowerM.slice(0, 3);\n  const shortMonthIndex = SHORT_MONTHS.indexOf(shortM);\n\n  if (shortMonthIndex !== -1) {\n    return shortMonthIndex;\n  } // Invalid month\n\n\n  throw new Error(invalidTimeUnit('month', m));\n}\nfunction normalizeDay(d) {\n  if (isNumeric(d)) {\n    d = Number(d);\n  }\n\n  if (isNumber(d)) {\n    // mod so that this can be both 0-based where 0 = sunday\n    // and 1-based where 7=sunday\n    return d % 7;\n  }\n\n  const lowerD = d.toLowerCase();\n  const dayIndex = DAYS.indexOf(lowerD);\n\n  if (dayIndex !== -1) {\n    return dayIndex; // 0 for january, ...\n  }\n\n  const shortD = lowerD.slice(0, 3);\n  const shortDayIndex = SHORT_DAYS.indexOf(shortD);\n\n  if (shortDayIndex !== -1) {\n    return shortDayIndex;\n  } // Invalid day\n\n\n  throw new Error(invalidTimeUnit('day', d));\n}\n/**\n * @param d the date.\n * @param normalize whether to normalize quarter, month, day. This should probably be true if d is a DateTime.\n * @returns array of date time parts [year, month, day, hours, minutes, seconds, milliseconds]\n */\n\nfunction dateTimeParts(d, normalize) {\n  const parts = [];\n\n  if (normalize && d.day !== undefined) {\n    if (utils_keys(d).length > 1) {\n      d = { ...d\n      };\n      delete d.day;\n    }\n  }\n\n  if (d.year !== undefined) {\n    parts.push(d.year);\n  } else if (d.day !== undefined) {\n    // Set year to 2006 for working with day since January 1 2006 is a Sunday\n    parts.push(SUNDAY_YEAR);\n  } else {\n    parts.push(0);\n  }\n\n  if (d.month !== undefined) {\n    const month = normalize ? normalizeMonth(d.month) : d.month;\n    parts.push(month);\n  } else if (d.quarter !== undefined) {\n    const quarter = normalize ? normalizeQuarter(d.quarter) : d.quarter;\n    parts.push(isNumber(quarter) ? quarter * 3 : quarter + \"*3\");\n  } else {\n    parts.push(0); // months start at zero in JS\n  }\n\n  if (d.date !== undefined) {\n    parts.push(d.date);\n  } else if (d.day !== undefined) {\n    // HACK: Day only works as a standalone unit\n    // This is only correct because we always set year to 2006 for day\n    const day = normalize ? normalizeDay(d.day) : d.day;\n    parts.push(isNumber(day) ? day + 1 : day + \"+1\");\n  } else {\n    parts.push(1); // Date starts at 1 in JS\n  }\n\n  ['hours', 'minutes', 'seconds', 'milliseconds'].forEach(timeUnit => {\n    const unit = d[timeUnit];\n    parts.push(typeof unit === 'undefined' ? 0 : unit);\n  });\n  return parts;\n}\n/**\n * @param d the date time.\n * @returns the timestamp.\n */\n\nfunction dateTimeToTimestamp(d) {\n  const parts = dateTimeParts(d, true);\n\n  if (d.utc) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return Number(new Date(Date.UTC(...parts)));\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  return Number(new Date(...parts));\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/parseDateTime.js\n\nfunction parseDateTime(dateTime) {\n  if (typeof dateTime === 'number' || typeof dateTime === 'string') {\n    return new Date(dateTime);\n  }\n\n  return new Date(dateTimeToTimestamp(dateTime));\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/utils/inferElementTypeFromUnionOfArrayTypes.js\n/**\n * Type workaround for https://github.com/Microsoft/TypeScript/issues/7294#issuecomment-465794460\n * to avoid error \"Cannot invoke an expression whose type lacks a call signature\"\n * when using array.map\n */\nfunction inferElementTypeFromUnionOfArrayTypes(array) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return array;\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/typeGuards/DateTime.js\n// eslint-disable-next-line import/prefer-default-export\nfunction isDateTime(o) {\n  return !!o && !(o instanceof Date) && typeof o !== 'string' && typeof o !== 'boolean' && typeof o !== 'number' && ('year' in o && o.year != null || 'quarter' in o && o.quarter != null || 'month' in o && o.month != null || 'date' in o && o.date != null || 'day' in o && o.day != null || 'hours' in o && o.hours != null || 'minutes' in o && o.minutes != null || 'seconds' in o && o.seconds != null || 'milliseconds' in o && o.milliseconds != null);\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/format/fallbackFormatter.js\nfunction fallbackFormatter(v) {\n  return \"\" + v;\n}\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/options/Encodable.js\nvar Encodable = __webpack_require__(1207);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/format/createFormatter.js\n\n\nfunction createFormatter({\n  formatType,\n  format,\n  formatInLocalTime\n}) {\n  if (formatType === 'time') {\n    const formatter = Encodable[\"a\" /* default */].resolveTimeFormat({\n      format,\n      formatInLocalTime\n    });\n    return value => formatter(value);\n  }\n\n  if (formatType === 'number' || typeof format !== 'undefined' && format.length > 0) {\n    const formatter = Encodable[\"a\" /* default */].resolveNumberFormat(format);\n    return value => formatter(value);\n  }\n\n  return fallbackFormatter;\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/encoders/ChannelEncoderAxis.js\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\nclass ChannelEncoderAxis_ChannelEncoderAxis {\n  constructor(channelEncoder) {\n    _defineProperty(this, \"channelEncoder\", void 0);\n\n    _defineProperty(this, \"config\", void 0);\n\n    _defineProperty(this, \"formatValue\", void 0);\n\n    this.channelEncoder = channelEncoder;\n    this.config = channelEncoder.definition.axis;\n    this.formatValue = createFormatter(this.config);\n  }\n\n  getTitle() {\n    return this.config.title;\n  }\n\n  hasTitle() {\n    const {\n      title\n    } = this.config;\n    return title !== null && typeof title !== 'undefined' && title !== '';\n  }\n\n  getTickLabels() {\n    const {\n      tickCount,\n      values\n    } = this.config;\n\n    if (typeof values !== 'undefined') {\n      return inferElementTypeFromUnionOfArrayTypes(values).map(v => this.formatValue(isDateTime(v) ? parseDateTime(v) : v));\n    }\n\n    const {\n      scale\n    } = this.channelEncoder;\n\n    if (scale && 'domain' in scale) {\n      const ticks = 'ticks' in scale ? scale.ticks(tickCount) : scale.domain();\n      return ticks.map(this.formatValue);\n    }\n\n    return [];\n  }\n\n}\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/lodash.get/index.js\nvar lodash_get = __webpack_require__(1209);\nvar lodash_get_default = /*#__PURE__*/__webpack_require__.n(lodash_get);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/createGetterFromChannelDef.js\n\n\nfunction createGetterFromChannelDef(definition) {\n  if (Object(ChannelDef[\"c\" /* isValueDef */])(definition)) {\n    return () => definition.value;\n  }\n\n  if (typeof definition.field !== 'undefined') {\n    return x => lodash_get_default()(x, definition.field);\n  }\n\n  return () => undefined;\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/utils/isDisabled.js\nfunction isDisabled(config) {\n  return config === false || config === null;\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/utils/isEnabled.js\n\nfunction isEnabled(config) {\n  return !isDisabled(config);\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/fillers/expandLabelOverlapStrategy.js\n\nconst STRATEGY_FLAT = {\n  strategy: 'flat'\n};\nconst STRATEGY_ROTATE = {\n  labelAngle: 40,\n  strategy: 'rotate'\n};\nfunction expandLabelOverlapStrategy(channelType, labelOverlap = 'auto') {\n  let output;\n\n  switch (labelOverlap) {\n    case 'flat':\n      output = STRATEGY_FLAT;\n      break;\n\n    case 'rotate':\n      output = STRATEGY_ROTATE;\n      break;\n\n    case 'auto':\n      output = isX(channelType) ? STRATEGY_ROTATE : STRATEGY_FLAT;\n      break;\n\n    default:\n      output = labelOverlap;\n      break;\n  }\n\n  return { ...output\n  };\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/scaleCategories.js\n // Grouped by domain and range\n\nconst continuousToContinuousScaleTypes = [ScaleType.LINEAR, ScaleType.POW, ScaleType.SQRT, ScaleType.SYMLOG, ScaleType.LOG, ScaleType.TIME, ScaleType.UTC];\nconst continuousToContinuousScaleTypesSet = new Set(continuousToContinuousScaleTypes);\nconst continuousToDiscreteScaleTypes = [ScaleType.QUANTILE, ScaleType.QUANTIZE, ScaleType.THRESHOLD];\nconst continuousToDiscreteScaleTypesSet = new Set(continuousToDiscreteScaleTypes); // Grouped by Domain\n\nconst continuousDomainScaleTypes = continuousToContinuousScaleTypes.concat(continuousToDiscreteScaleTypes);\nconst continuousDomainScaleTypesSet = new Set(continuousDomainScaleTypes);\nconst discreteDomainScaleTypes = [ScaleType.ORDINAL, ScaleType.BIN_ORDINAL, ScaleType.POINT, ScaleType.BAND];\nconst discreteDomainScaleTypesSet = new Set(discreteDomainScaleTypes); // Three broad categories\n\nconst continuousScaleTypes = continuousToContinuousScaleTypes;\nconst continuousScaleTypesSet = continuousToContinuousScaleTypesSet;\nconst discreteScaleTypes = [ScaleType.BAND, ScaleType.POINT, ScaleType.ORDINAL];\nconst discreteScaleTypesSet = new Set(discreteScaleTypes);\nconst discretizingScaleTypes = [ScaleType.BIN_ORDINAL, ScaleType.QUANTILE, ScaleType.QUANTIZE, ScaleType.THRESHOLD];\nconst discretizingScaleTypesSet = new Set(discretizingScaleTypes); // Others\n\nconst timeScaleTypes = [ScaleType.TIME, ScaleType.UTC];\nconst timeScaleTypesSet = new Set(timeScaleTypes);\nconst allScaleTypes = [ScaleType.LINEAR, ScaleType.LOG, ScaleType.POW, ScaleType.SQRT, ScaleType.SYMLOG, ScaleType.TIME, ScaleType.UTC, ScaleType.QUANTILE, ScaleType.QUANTIZE, ScaleType.THRESHOLD, ScaleType.BIN_ORDINAL, ScaleType.ORDINAL, ScaleType.POINT, ScaleType.BAND];\nconst allScaleTypesSet = new Set(allScaleTypes);\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/fillers/completeAxisConfig.js\n\n\n\n\n\n\nfunction isChannelDefWithAxisSupport(channelType, channelDef) {\n  return Object(ChannelDef[\"b\" /* isTypedFieldDef */])(channelDef) && isXOrY(channelType);\n}\n\nfunction completeAxisConfig(channelType, channelDef) {\n  if (isChannelDefWithAxisSupport(channelType, channelDef) && isEnabled(channelDef.axis)) {\n    const axis = channelDef.axis === true || typeof channelDef.axis === 'undefined' ? {} : channelDef.axis;\n    const isXChannel = isX(channelType);\n    const {\n      format = channelDef.format,\n      formatType = channelDef.formatType,\n      formatInLocalTime = channelDef.formatInLocalTime,\n      labelAngle = 0,\n      labelFlush,\n      labelOverlap,\n      labelPadding = 4,\n      orient = isXChannel ? 'bottom' : 'left',\n      tickCount = 5,\n      ticks = true,\n      title = channelDef.title,\n      titlePadding = 4\n    } = axis;\n    const output = { ...axis,\n      format,\n      formatType,\n      labelAngle,\n      labelFlush: typeof labelFlush === 'undefined' ? channelDef.scale && typeof channelDef.scale.type !== 'undefined' && continuousToContinuousScaleTypesSet.has(channelDef.scale.type) : labelFlush,\n      labelOverlap: expandLabelOverlapStrategy(channelType, labelOverlap),\n      labelPadding,\n      orient,\n      tickCount,\n      ticks,\n      title,\n      titlePadding\n    };\n\n    if (typeof formatInLocalTime !== 'undefined') {\n      output.formatInLocalTime = formatInLocalTime;\n    }\n\n    return output;\n  }\n\n  return false;\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/fillers/completeFormatConfig.js\nfunction completeFormatConfig(config) {\n  const {\n    formatType,\n    formatInLocalTime,\n    format,\n    type,\n    scaleType\n  } = config;\n  let resolvedFormatType;\n\n  if (typeof formatType !== 'undefined') {\n    resolvedFormatType = formatType;\n  } else if (type === 'quantitative') {\n    resolvedFormatType = 'number';\n  } else if (type === 'temporal' || scaleType === 'time' || scaleType === 'utc') {\n    resolvedFormatType = 'time';\n  } else if (typeof format !== 'undefined' && format.length > 0) {\n    resolvedFormatType = 'number';\n  }\n\n  if (resolvedFormatType === 'time') {\n    return {\n      formatType: 'time',\n      formatInLocalTime: formatInLocalTime || typeof formatInLocalTime === 'undefined' && scaleType === 'time',\n      format\n    };\n  }\n\n  return {\n    formatType: resolvedFormatType,\n    format\n  };\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/fillers/completeLegendConfig.js\n\nfunction completeLegendConfig(channelType, channelDef) {\n  if ('legend' in channelDef && channelDef.legend !== undefined) {\n    return channelDef.legend;\n  }\n\n  return isXOrY(channelType) || channelType === 'Text' ? false : {};\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/fillers/inferScaleType.js\n\n/**\n * Sometimes scale type is not specified but can be inferred\n * from other fields.\n * See https://vega.github.io/vega-lite/docs/scale.html\n * @param channelType type of the channel\n * @param fieldType type of the field\n * @param bin is value binned\n */\n\nfunction inferScaleType(channelType, fieldType, bin = false) {\n  if (fieldType === 'nominal' || fieldType === 'ordinal') {\n    switch (channelType) {\n      // For positional (x and y) ordinal and ordinal fields,\n      // \"point\" is the default scale type for all marks\n      // except bar and rect marks, which use \"band\" scales.\n      // https://vega.github.io/vega-lite/docs/scale.html\n      case 'XBand':\n      case 'YBand':\n        return ScaleType.BAND;\n\n      case 'X':\n      case 'Y':\n      case 'Numeric':\n        return ScaleType.POINT;\n\n      case 'Color':\n      case 'Category':\n        return ScaleType.ORDINAL;\n\n      default:\n    }\n  } else if (fieldType === 'quantitative') {\n    switch (channelType) {\n      case 'XBand':\n      case 'YBand':\n      case 'X':\n      case 'Y':\n      case 'Numeric':\n        return ScaleType.LINEAR;\n\n      case 'Color':\n        return bin ? ScaleType.BIN_ORDINAL : ScaleType.LINEAR;\n\n      default:\n    }\n  } else if (fieldType === 'temporal') {\n    switch (channelType) {\n      case 'XBand':\n      case 'YBand':\n      case 'X':\n      case 'Y':\n      case 'Numeric':\n        return ScaleType.UTC;\n\n      case 'Color':\n        return ScaleType.LINEAR;\n\n      default:\n    }\n  }\n\n  return undefined;\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/isPropertySupportedByScaleType.js\n\n\nconst pointOrBand = [ScaleType.POINT, ScaleType.BAND];\nconst pointOrBandSet = new Set(pointOrBand);\nconst exceptPointOrBand = allScaleTypes.filter(type => !pointOrBandSet.has(type));\nconst exceptPointOrBandSet = new Set(exceptPointOrBand);\nconst continuousOrPointOrBandSet = new Set(continuousScaleTypes.concat(pointOrBand));\nconst zeroSet = new Set(continuousDomainScaleTypes); // log scale cannot have zero value\n\nzeroSet.delete(ScaleType.LOG); // zero is not meaningful for time\n\nzeroSet.delete(ScaleType.TIME);\nzeroSet.delete(ScaleType.UTC); // threshold requires custom domain so zero does not matter\n\nzeroSet.delete(ScaleType.THRESHOLD); // quantile depends on distribution so zero does not matter\n\nzeroSet.delete(ScaleType.QUANTILE);\nconst supportedScaleTypes = {\n  align: pointOrBandSet,\n  base: new Set([ScaleType.LOG]),\n  clamp: continuousScaleTypesSet,\n  constant: new Set([ScaleType.SYMLOG]),\n  domain: allScaleTypesSet,\n  exponent: new Set([ScaleType.POW]),\n  interpolate: exceptPointOrBandSet,\n  nice: new Set(continuousScaleTypes.concat([ScaleType.QUANTIZE, ScaleType.THRESHOLD])),\n  padding: continuousOrPointOrBandSet,\n  paddingInner: new Set([ScaleType.BAND]),\n  paddingOuter: pointOrBandSet,\n  range: allScaleTypesSet,\n  reverse: allScaleTypesSet,\n  round: continuousOrPointOrBandSet,\n  scheme: exceptPointOrBandSet,\n  type: allScaleTypesSet,\n  unknown: new Set([ScaleType.ORDINAL]),\n  zero: zeroSet\n};\nfunction isPropertySupportedByScaleType(property, scaleType) {\n  return supportedScaleTypes[property].has(scaleType);\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/typeGuards/ScaleConfig.js\n\n\nfunction isContinuousScaleConfig(config) {\n  return continuousScaleTypesSet.has(config.type);\n}\nfunction isDiscretizingScaleConfig(config) {\n  return discretizingScaleTypesSet.has(config.type);\n}\nfunction isDiscreteScaleConfig(config) {\n  return discreteScaleTypesSet.has(config.type);\n}\nfunction isScaleConfigWithZero(config) {\n  return isPropertySupportedByScaleType('zero', config.type);\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/fillers/completeScaleConfig.js\n\n\n\n\n\nfunction completeScaleConfig(channelType, channelDef) {\n  if (Object(ChannelDef[\"b\" /* isTypedFieldDef */])(channelDef) && isEnabled(channelDef.scale)) {\n    const {\n      scale = {},\n      type,\n      bin\n    } = channelDef;\n    const {\n      type: scaleType = inferScaleType(channelType, type, bin)\n    } = scale;\n\n    if (typeof scaleType === 'undefined') {\n      return false;\n    } // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n\n\n    const filledScale = { ...scale,\n      type: scaleType\n    };\n\n    if (isContinuousScaleConfig(filledScale)) {\n      if (typeof filledScale.nice === 'undefined') {\n        filledScale.nice = !timeScaleTypesSet.has(scaleType);\n      }\n\n      if (typeof filledScale.clamp === 'undefined') {\n        filledScale.clamp = true;\n      }\n    }\n\n    if (isScaleConfigWithZero(filledScale) && typeof filledScale.zero === 'undefined') {\n      filledScale.zero = true;\n    }\n\n    return filledScale;\n  }\n\n  return false;\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/fillers/inferFieldType.js\n\nconst temporalFieldNames = new Set(['time', 'date', 'datetime', 'timestamp']);\nfunction inferFieldType(channelType, field = '') {\n  if (isXOrY(channelType) || channelType === 'Numeric') {\n    return temporalFieldNames.has(field.toLowerCase()) ? 'temporal' : 'quantitative';\n  }\n\n  return 'nominal';\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/fillers/completeChannelDef.js\n\n\n\n\n\n\nfunction completeChannelDef(channelType, channelDef) {\n  var _channelDef$title;\n\n  if (Object(ChannelDef[\"c\" /* isValueDef */])(channelDef)) {\n    return { ...channelDef,\n      axis: false,\n      legend: false,\n      scale: false,\n      title: ''\n    };\n  } // Fill top-level properties\n\n\n  const copy = { ...channelDef,\n    title: Object(ChannelDef[\"a\" /* isFieldDef */])(channelDef) ? (_channelDef$title = channelDef.title) != null ? _channelDef$title : channelDef.field : '',\n    type: Object(ChannelDef[\"b\" /* isTypedFieldDef */])(channelDef) ? channelDef.type : inferFieldType(channelType, channelDef.field)\n  }; // Scale needs the top-level properties to be filled.\n\n  const scale = completeScaleConfig(channelType, copy); // Format needs scale.\n\n  const format = completeFormatConfig({ ...channelDef,\n    scaleType: scale ? scale.type : undefined\n  });\n  const copy2 = { ...copy,\n    ...format,\n    scale\n  }; // These need scale and format\n\n  const axis = completeAxisConfig(channelType, copy2);\n  const legend = completeLegendConfig(channelType, copy2);\n  return { ...copy2,\n    axis,\n    legend\n  };\n}\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-scale/src/linear.js\nvar linear = __webpack_require__(73);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-scale/src/log.js\nvar log = __webpack_require__(272);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-scale/src/pow.js\nvar pow = __webpack_require__(219);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-scale/src/time.js + 3 modules\nvar time = __webpack_require__(449);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-scale/src/utcTime.js + 3 modules\nvar utcTime = __webpack_require__(1113);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-scale/src/quantile.js\nvar quantile = __webpack_require__(1002);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-scale/src/quantize.js\nvar quantize = __webpack_require__(1003);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-scale/src/threshold.js\nvar threshold = __webpack_require__(1004);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-scale/src/ordinal.js\nvar ordinal = __webpack_require__(340);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-scale/src/band.js + 1 modules\nvar band = __webpack_require__(610);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-scale/src/symlog.js\nvar symlog = __webpack_require__(273);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/createScaleFromScaleType.js\n\n\nfunction createScaleFromScaleType(type) {\n  switch (type) {\n    case ScaleType.LINEAR:\n      return Object(linear[\"a\" /* default */])();\n\n    case ScaleType.LOG:\n      return Object(log[\"a\" /* default */])();\n\n    case ScaleType.POW:\n      return Object(pow[\"a\" /* default */])();\n\n    case ScaleType.SQRT:\n      return Object(pow[\"c\" /* sqrt */])();\n\n    case ScaleType.TIME:\n      return Object(time[\"b\" /* default */])();\n\n    case ScaleType.UTC:\n      return Object(utcTime[\"a\" /* default */])();\n\n    case ScaleType.QUANTILE:\n      return Object(quantile[\"a\" /* default */])();\n\n    case ScaleType.QUANTIZE:\n      return Object(quantize[\"a\" /* default */])();\n\n    case ScaleType.THRESHOLD:\n      return Object(threshold[\"a\" /* default */])();\n\n    case ScaleType.ORDINAL:\n      return Object(ordinal[\"a\" /* default */])();\n\n    case ScaleType.POINT:\n      return Object(band[\"b\" /* point */])();\n\n    case ScaleType.BAND:\n      return Object(band[\"a\" /* default */])();\n\n    case ScaleType.SYMLOG:\n      return Object(symlog[\"a\" /* default */])();\n\n    case ScaleType.BIN_ORDINAL:\n      // TODO: Pending scale.bins implementation\n      throw new Error(\"\\\"type = \" + type + \"\\\" is not supported yet.\");\n\n    default:\n      return Object(linear[\"a\" /* default */])();\n  }\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/applyAlign.js\nfunction applyAlign(config, scale) {\n  if ('align' in config && typeof config.align !== 'undefined' && 'align' in scale) {\n    scale.align(config.align);\n  }\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/applyBase.js\nfunction applyBase(config, scale) {\n  if ('base' in config && typeof config.base !== 'undefined' && 'base' in scale) {\n    scale.base(config.base);\n  }\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/applyClamp.js\nfunction applyClamp(config, scale) {\n  if ('clamp' in config && config.clamp === true && 'clamp' in scale) {\n    scale.clamp(config.clamp);\n  }\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/applyExponent.js\nfunction applyExponent(config, scale) {\n  if ('exponent' in config && typeof config.exponent !== 'undefined' && 'exponent' in scale) {\n    scale.exponent(config.exponent);\n  }\n}\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-time/src/day.js\nvar day = __webpack_require__(593);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-time/src/hour.js\nvar hour = __webpack_require__(592);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-time/src/minute.js\nvar minute = __webpack_require__(591);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-time/src/month.js\nvar month = __webpack_require__(594);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-time/src/second.js\nvar second = __webpack_require__(339);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-time/src/week.js\nvar week = __webpack_require__(81);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-time/src/year.js\nvar year = __webpack_require__(595);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-time/src/utcDay.js\nvar utcDay = __webpack_require__(598);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-time/src/utcHour.js\nvar utcHour = __webpack_require__(597);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-time/src/utcMinute.js\nvar utcMinute = __webpack_require__(596);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-time/src/utcMonth.js\nvar utcMonth = __webpack_require__(599);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-time/src/utcWeek.js\nvar utcWeek = __webpack_require__(82);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-time/src/utcYear.js\nvar utcYear = __webpack_require__(600);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/applyNice.js\n\n\nconst localTimeIntervals = {\n  day: day[\"b\" /* default */],\n  hour: hour[\"a\" /* default */],\n  minute: minute[\"a\" /* default */],\n  month: month[\"a\" /* default */],\n  second: second[\"a\" /* default */],\n  week: week[\"g\" /* sunday */],\n  year: year[\"a\" /* default */]\n};\nconst utcIntervals = {\n  day: utcDay[\"a\" /* default */],\n  hour: utcHour[\"a\" /* default */],\n  minute: utcMinute[\"a\" /* default */],\n  month: utcMonth[\"a\" /* default */],\n  second: second[\"a\" /* default */],\n  week: utcWeek[\"g\" /* utcSunday */],\n  year: utcYear[\"a\" /* default */]\n};\nfunction applyNice(config, scale) {\n  if ('nice' in config && typeof config.nice !== 'undefined' && 'nice' in scale) {\n    const {\n      nice\n    } = config;\n\n    if (typeof nice === 'boolean') {\n      if (nice) {\n        scale.nice();\n      }\n    } else if (typeof nice === 'number') {\n      scale.nice(nice);\n    } else {\n      const timeScale = scale;\n      const {\n        type\n      } = config;\n\n      if (typeof nice === 'string') {\n        timeScale.nice(type === ScaleType.UTC ? utcIntervals[nice] : localTimeIntervals[nice]);\n      } else {\n        const {\n          interval,\n          step\n        } = nice;\n        const parsedInterval = (type === ScaleType.UTC ? utcIntervals[interval] : localTimeIntervals[interval]).every(step);\n\n        if (parsedInterval !== null) {\n          timeScale.nice(parsedInterval);\n        }\n      }\n    }\n  }\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/typeGuards/Scale.js\n\nfunction isContinuousScale(scale, scaleType) {\n  return scale && continuousScaleTypesSet.has(scaleType);\n}\nfunction isDiscretizingScale(scale, scaleType) {\n  return scale && discretizingScaleTypesSet.has(scaleType);\n}\nfunction isDiscreteScale(scale, scaleType) {\n  return scale && discreteScaleTypesSet.has(scaleType);\n}\nfunction isTimeScale(scale, scaleType) {\n  return scale && timeScaleTypesSet.has(scaleType);\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/applyZero.js\n\nfunction applyZero(config, scale) {\n  if ('zero' in config && config.zero === true && isContinuousScale(scale, config.type)) {\n    const domain = scale.domain();\n    const [a, b] = domain;\n    const isDescending = b < a;\n    const [min, max] = isDescending ? [b, a] : [a, b];\n    const domainWithZero = [Math.min(0, min), Math.max(0, max)];\n    scale.domain(isDescending ? domainWithZero.reverse() : domainWithZero);\n  }\n}\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-interpolate/src/lab.js\nvar lab = __webpack_require__(1110);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-interpolate/src/hcl.js\nvar hcl = __webpack_require__(602);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-interpolate/src/hsl.js\nvar hsl = __webpack_require__(601);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-interpolate/src/cubehelix.js + 1 modules\nvar cubehelix = __webpack_require__(611);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-interpolate/src/rgb.js\nvar rgb = __webpack_require__(221);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/createColorInterpolator.js\n\nconst interpolatorMap = {\n  lab: lab[\"a\" /* default */],\n  hcl: hcl[\"a\" /* default */],\n  'hcl-long': hcl[\"b\" /* hclLong */],\n  hsl: hsl[\"a\" /* default */],\n  'hsl-long': hsl[\"b\" /* hslLong */],\n  cubehelix: cubehelix[\"b\" /* default */],\n  'cubehelix-long': cubehelix[\"a\" /* cubehelixLong */],\n  rgb: rgb[\"a\" /* default */]\n};\nfunction createColorInterpolator(interpolate) {\n  switch (interpolate) {\n    case 'lab':\n    case 'hcl':\n    case 'hcl-long':\n    case 'hsl':\n    case 'hsl-long':\n    case 'cubehelix':\n    case 'cubehelix-long':\n    case 'rgb':\n      return interpolatorMap[interpolate];\n\n    default:\n  }\n\n  const {\n    type,\n    gamma\n  } = interpolate;\n  const interpolator = interpolatorMap[type];\n  return typeof gamma === 'undefined' ? interpolator : interpolator.gamma(gamma);\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/applyInterpolate.js\n\nfunction applyInterpolate(config, scale) {\n  if ('interpolate' in config && typeof config.interpolate !== 'undefined' && 'interpolate' in scale) {\n    scale.interpolate(createColorInterpolator(config.interpolate));\n  }\n}\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-interpolate/src/round.js\nvar round = __webpack_require__(1109);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/applyRound.js\n\nfunction applyRound(config, scale) {\n  if ('round' in config && config.round === true) {\n    const roundableScale = scale;\n\n    if ('round' in roundableScale) {\n      roundableScale.round(config.round);\n    } else {\n      roundableScale.interpolate(round[\"a\" /* default */]);\n    }\n  }\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/domain/parseContinuousDomain.js\n\n/**\n * Convert each element in the array into\n * - Date (for time scales)\n * - number (for other continuous scales)\n * @param domain\n * @param scaleType\n */\n\nfunction parseContinuousDomain(domain, scaleType) {\n  if (timeScaleTypesSet.has(scaleType)) {\n    return domain.filter(d => typeof d !== 'boolean').map(d => typeof d === 'string' || typeof d === 'number' ? new Date(d) : d);\n  }\n\n  return domain.map(d => typeof d === 'string' || typeof d === 'boolean' ? Number(d) : d);\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/domain/parseDiscreteDomain.js\n/**\n * Discrete domains are converted into string[]\n * when using D3 scales\n * @param domain\n */\nfunction parseDiscreteDomain(domain) {\n  return domain.map(d => \"\" + d);\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/utils/combineCategories.js\n/**\n * Combine two arrays into a unique list\n * by keeping the order the fixedCategories\n * and append new categories at the end.\n * @param fixedCategories\n * @param inputCategories\n */\nfunction combineCategories(fixedCategories, inputCategories = []) {\n  if (fixedCategories.length === 0) {\n    return inputCategories;\n  }\n\n  const fixedSet = new Set(fixedCategories);\n  return fixedCategories.concat(inputCategories.filter(d => !fixedSet.has(d)));\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/utils/combineContinuousDomains.js\n\n/**\n * Combine two continuous domain and ensure that the output\n * does not go beyond fixedDomain\n * @param bounds\n * @param dataDomain\n */\n\nfunction combineContinuousDomains(bounds, dataDomain) {\n  if (bounds.length > 0 && isEveryElementDefined(bounds)) {\n    return bounds;\n  }\n\n  if (bounds.length === 2 && dataDomain.length === 2 && bounds.filter(isDefined).length > 0) {\n    const [boundMin, boundMax] = bounds;\n    const [dataMin, dataMax] = dataDomain;\n    let min = dataMin;\n\n    if (isDefined(boundMin)) {\n      min = boundMin.valueOf() > dataMin.valueOf() ? boundMin : dataMin;\n    }\n\n    let max = dataMax;\n\n    if (isDefined(boundMax)) {\n      max = boundMax.valueOf() < dataMax.valueOf() ? boundMax : dataMax;\n    }\n\n    return [min, max];\n  }\n\n  return dataDomain;\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/utils/removeUndefinedAndNull.js\nfunction removeUndefinedAndNull(array) {\n  return array.filter(x => typeof x !== 'undefined' && x !== null);\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/parseDateTimeIn.js\n\n\n/**\n * Only parse elements that are DateTime to Date.\n * Leave the rest alone.\n * @param array\n */\n\nfunction parseDateTimeIn(array) {\n  return array.map(d => !(d instanceof Date) && isDateTime(d) ? parseDateTime(d) : d);\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/applyDomain.js\n\n\n\n\n\n\n\n\n\nfunction createOrderFunction(reverse) {\n  return reverse ? array => array.concat().reverse() : array => array;\n}\n\nfunction isCompleteDomain(domain) {\n  return domain.length !== 2 || domain[0] != null && domain[1] != null;\n}\n\nfunction applyDomain(config, scale,\n/** domain from dataset */\ndataDomain) {\n  const {\n    reverse,\n    type\n  } = config;\n  const order = createOrderFunction(reverse);\n\n  if (isContinuousScale(scale, type) && isContinuousScaleConfig(config) || isDiscretizingScale(scale, type) && isDiscretizingScaleConfig(config)) {\n    // For continuous and discretizing scales\n    if (config.domain) {\n      // If config.domain is specified\n      if (isCompleteDomain(config.domain)) {\n        // If the config.domain is completed\n        // ignores the dataDomain\n        scale.domain(order(parseDateTimeIn(config.domain)));\n      } else if (dataDomain) {\n        // If it is incompleted, then try to combine\n        // with the dataDomain\n        scale.domain(order(combineContinuousDomains(parseContinuousDomain(parseDateTimeIn(config.domain), type), parseContinuousDomain(removeUndefinedAndNull(dataDomain), type))));\n      }\n    } else if (dataDomain) {\n      // If no config.domain then just use the dataDomain if any\n      scale.domain(order(parseContinuousDomain(removeUndefinedAndNull(dataDomain), type)));\n    }\n  } else if (isDiscreteScale(scale, type) && isDiscreteScaleConfig(config)) {\n    // For discrete scales\n    if (config.domain) {\n      const fixedDomain = parseDiscreteDomain(parseDateTimeIn(config.domain));\n      scale.domain(order(dataDomain ? combineCategories(fixedDomain, parseDiscreteDomain(dataDomain)) : fixedDomain));\n    } else if (dataDomain) {\n      // If no config.domain then just use the dataDomain if any\n      scale.domain(order(parseDiscreteDomain(dataDomain)));\n    }\n  }\n}\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@encodable/color/esm/scheme/wrappers/wrapColorScheme.js + 21 modules\nvar wrapColorScheme = __webpack_require__(446);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/typeGuards/SchemeParams.js\n// eslint-disable-next-line import/prefer-default-export\nfunction isSchemeParams(scheme) {\n  return Object.prototype.toString.call(scheme) !== '[object String]';\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/applyRange.js\n\n\n\n\nfunction applyRange(config, scale) {\n  const {\n    range,\n    domain\n  } = config;\n\n  if (typeof range === 'undefined') {\n    if ('scheme' in config && typeof config.scheme !== 'undefined') {\n      const {\n        scheme\n      } = config;\n      let name;\n      let count;\n\n      if (isContinuousScaleConfig(config) && domain) {\n        count = domain.length;\n      }\n\n      let extent;\n\n      if (isSchemeParams(scheme)) {\n        name = scheme.name;\n\n        if (scheme.count) {\n          count = scheme.count;\n        }\n\n        extent = scheme.extent;\n      } else {\n        name = scheme;\n      }\n\n      const schemeObject = Encodable[\"a\" /* default */].resolveColorScheme({\n        name,\n        type: 'sequential'\n      });\n\n      if (typeof schemeObject !== 'undefined' && schemeObject.type === 'sequential') {\n        const wrappedScheme = Object(wrapColorScheme[\"a\" /* default */])(schemeObject);\n        scale.range(wrappedScheme.getColors(count, extent));\n      }\n    }\n  } else {\n    // TODO: add type guard should fix this problem\n    // @ts-ignore\n    scale.range(range);\n  }\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/applyPadding.js\nfunction applyPadding(config, scale) {\n  if ('padding' in config && typeof config.padding !== 'undefined' && 'padding' in scale) {\n    scale.padding(config.padding);\n  }\n\n  if ('paddingInner' in config && typeof config.paddingInner !== 'undefined' && 'paddingInner' in scale) {\n    scale.paddingInner(config.paddingInner);\n  }\n\n  if ('paddingOuter' in config && typeof config.paddingOuter !== 'undefined' && 'paddingOuter' in scale) {\n    scale.paddingOuter(config.paddingOuter);\n  }\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/updateScale.js\n\n\n\n\n\n\n\n\n\n\n\nfunction updateScale(scale, config) {\n  // domain and range apply to all scales\n  applyDomain(config, scale);\n  applyRange(config, scale); // Sort other properties alphabetically.\n\n  applyAlign(config, scale);\n  applyBase(config, scale);\n  applyClamp(config, scale);\n  applyExponent(config, scale);\n  applyInterpolate(config, scale); // Nice depends on domain.\n\n  applyNice(config, scale);\n  applyPadding(config, scale);\n  applyRound(config, scale); // Zero depends on domain and nice.\n\n  applyZero(config, scale);\n  return scale;\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/createScale.js\n\n\n\n\n\n\n\nfunction createScale(config) {\n  const {\n    range\n  } = config; // Handle categorical color scales\n  // An ordinal scale without specified range\n  // is assumed to be a color scale.\n\n  if (config.type === ScaleType.ORDINAL && typeof range === 'undefined') {\n    const scheme = 'scheme' in config ? config.scheme : undefined;\n    const resolve = Encodable[\"a\" /* default */].getCategoricalColorScaleResolver();\n    let colorScale;\n\n    if (typeof scheme === 'undefined') {\n      colorScale = resolve({});\n    } else if (isSchemeParams(scheme)) {\n      colorScale = resolve(scheme);\n    } else {\n      colorScale = resolve({\n        name: scheme\n      });\n    }\n\n    const castedColorScale = colorScale;\n    applyDomain(config, castedColorScale);\n    return castedColorScale;\n  }\n\n  const scale = createScaleFromScaleType(config.type);\n  return updateScale(scale, config);\n}\n\n/* harmony default export */ var scale_createScale = (createScale);\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/utils/identity.js\nfunction identity(x) {\n  return x;\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/typeGuards/CompleteChannelDef.js\nfunction isCompleteValueDef(def) {\n  return 'value' in def;\n}\nfunction isCompleteFieldDef(def) {\n  return 'field' in def;\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/encoders/ChannelEncoder.js\nfunction ChannelEncoder_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass ChannelEncoder_ChannelEncoder {\n  constructor({\n    name,\n    channelType,\n    definition: originalDefinition\n  }) {\n    ChannelEncoder_defineProperty(this, \"name\", void 0);\n\n    ChannelEncoder_defineProperty(this, \"channelType\", void 0);\n\n    ChannelEncoder_defineProperty(this, \"originalDefinition\", void 0);\n\n    ChannelEncoder_defineProperty(this, \"definition\", void 0);\n\n    ChannelEncoder_defineProperty(this, \"scale\", void 0);\n\n    ChannelEncoder_defineProperty(this, \"axis\", void 0);\n\n    ChannelEncoder_defineProperty(this, \"getValue\", void 0);\n\n    ChannelEncoder_defineProperty(this, \"encodeFunc\", void 0);\n\n    ChannelEncoder_defineProperty(this, \"formatValue\", void 0);\n\n    ChannelEncoder_defineProperty(this, \"encodeValue\", (value, otherwise) => {\n      if (typeof otherwise !== 'undefined' && (value === null || typeof value === 'undefined')) {\n        return otherwise;\n      } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n      return this.encodeFunc(value);\n    });\n\n    ChannelEncoder_defineProperty(this, \"encodeDatum\", (datum, otherwise) => typeof otherwise === 'undefined' ? this.encodeValue(this.getValueFromDatum(datum)) : this.encodeValue(this.getValueFromDatum(datum), otherwise));\n\n    ChannelEncoder_defineProperty(this, \"formatDatum\", datum => this.formatValue(this.getValueFromDatum(datum)));\n\n    ChannelEncoder_defineProperty(this, \"getValueFromDatum\", (datum, otherwise) => {\n      const value = this.getValue(datum);\n      return otherwise !== undefined && (value === null || value === undefined) ? otherwise : value;\n    });\n\n    ChannelEncoder_defineProperty(this, \"getDomainFromDataset\", data => {\n      if (Object(ChannelDef[\"c\" /* isValueDef */])(this.definition)) {\n        const {\n          value\n        } = this.definition;\n        return [value];\n      }\n\n      const {\n        type\n      } = this.definition;\n\n      if (type === 'nominal' || type === 'ordinal') {\n        return Array.from(new Set(data.map(d => this.getValueFromDatum(d))));\n      }\n\n      if (type === 'quantitative') {\n        // Quantile scale needs all items\n        // because it treats domain as a discrete set of sample values\n        // for computing the quantiles\n        if (this.definition.scale && this.definition.scale.type === 'quantile') {\n          return data.map(d => this.getValueFromDatum(d));\n        }\n\n        const extent = Object(src_extent[\"a\" /* default */])(data, d => this.getValueFromDatum(d));\n        return typeof extent[0] === 'undefined' ? [0, 1] : extent;\n      }\n\n      if (type === 'temporal') {\n        const extent = Object(src_extent[\"a\" /* default */])(data, d => this.getValueFromDatum(d));\n        return typeof extent[0] === 'undefined' ? [0, 1] : extent;\n      }\n\n      return [];\n    });\n\n    this.name = name;\n    this.channelType = channelType;\n    this.originalDefinition = originalDefinition;\n    this.definition = completeChannelDef(this.channelType, originalDefinition);\n    this.getValue = createGetterFromChannelDef(this.definition);\n    this.formatValue = Object(ChannelDef[\"a\" /* isFieldDef */])(this.definition) ? createFormatter(this.definition) : fallbackFormatter;\n\n    if (this.definition.scale) {\n      const scale = scale_createScale(this.definition.scale); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n      this.encodeFunc = value => scale(value);\n\n      this.scale = scale;\n    } else {\n      const {\n        definition\n      } = this;\n      this.encodeFunc = isCompleteValueDef(definition) ? () => definition.value : identity;\n    }\n\n    if (this.definition.axis) {\n      this.axis = new ChannelEncoderAxis_ChannelEncoderAxis(this);\n    }\n  }\n\n  getDomain() {\n    if (this.scale && 'domain' in this.scale) {\n      return this.scale.domain();\n    }\n\n    return [];\n  }\n\n  setDomain(domain) {\n    if (this.definition.scale !== false && this.scale && !this.hasCategoricalColorScale() && 'domain' in this.scale) {\n      const config = this.definition.scale;\n      applyDomain(config, this.scale, domain);\n      applyRange(config, this.scale);\n      applyZero(config, this.scale);\n      applyNice(config, this.scale);\n    }\n\n    return this;\n  }\n\n  setDomainFromDataset(data) {\n    return this.scale && 'domain' in this.scale ? this.setDomain(this.getDomainFromDataset(data)) : this;\n  }\n\n  getTitle() {\n    return this.definition.title;\n  }\n\n  isGroupBy() {\n    if (Object(ChannelDef[\"b\" /* isTypedFieldDef */])(this.definition)) {\n      const {\n        type\n      } = this.definition;\n      return this.channelType === 'Category' || this.channelType === 'Text' || this.channelType === 'Color' && (type === 'nominal' || type === 'ordinal') || isXOrY(this.channelType) && (type === 'nominal' || type === 'ordinal');\n    }\n\n    return false;\n  }\n\n  isX() {\n    return isX(this.channelType);\n  }\n\n  isXOrY() {\n    return isXOrY(this.channelType);\n  }\n\n  isY() {\n    return isY(this.channelType);\n  }\n\n  hasCategoricalColorScale() {\n    const config = this.definition.scale; // Scale type is ordinal with not given range\n    // (may have optional scheme)\n    // will become a categorical scale\n    // of named color scheme.\n    // A color scale from named color scheme may be shared among multiple components\n    // in the same namespace by default, so changing its domain affect all components.\n    // (Sounds like a bad idea.)\n    // This function is currently only being used to check\n    // whether to apply domain from dataset or not.\n    // An ordinal scale with user-specified color scheme as range array\n    // will return false from this function and be excluded from it.\n\n    return this.scale && config && config.type === ScaleType.ORDINAL && typeof config.range === 'undefined';\n  }\n\n  hasLegend() {\n    return this.definition.legend !== false;\n  }\n\n  hasValueDefinition() {\n    return isCompleteValueDef(this.definition);\n  }\n\n  hasFieldDefinition() {\n    return isCompleteFieldDef(this.definition);\n  }\n\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/encoders/Encoder.js\nfunction Encoder_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\nclass Encoder_Encoder {\n  constructor({\n    channelTypes,\n    encoding\n  }) {\n    Encoder_defineProperty(this, \"encoding\", void 0);\n\n    Encoder_defineProperty(this, \"channelTypes\", void 0);\n\n    Encoder_defineProperty(this, \"channels\", void 0);\n\n    Encoder_defineProperty(this, \"legends\", void 0);\n\n    this.channelTypes = channelTypes;\n    this.encoding = encoding;\n    const channelNames = this.getChannelNames(); // Create channel encoders\n\n    const channels = {};\n    channelNames.forEach(name => {\n      const channelEncoding = encoding[name];\n\n      if (Array.isArray(channelEncoding)) {\n        const definitions = channelEncoding;\n        channels[name] = definitions.map((definition, i) => new ChannelEncoder_ChannelEncoder({\n          channelType: channelTypes[name],\n          definition,\n          name: name + \"[\" + i + \"]\"\n        }));\n      } else {\n        const definition = channelEncoding;\n        channels[name] = new ChannelEncoder_ChannelEncoder({\n          channelType: channelTypes[name],\n          definition,\n          name: name\n        });\n      }\n    });\n    this.channels = channels; // Group the channels that use the same field together\n    // so they can share the same legend.\n\n    this.legends = {};\n    channelNames.map(name => this.channels[name]).forEach(c => {\n      if (isNotArray(c) && c.hasLegend() && Object(ChannelDef[\"b\" /* isTypedFieldDef */])(c.definition)) {\n        const {\n          field\n        } = c.definition;\n        const channelEncoder = c;\n\n        if (this.legends[field]) {\n          this.legends[field].push(channelEncoder);\n        } else {\n          this.legends[field] = [channelEncoder];\n        }\n      }\n    });\n  }\n\n  getChannelNames() {\n    return Object.keys(this.channelTypes);\n  }\n\n  getChannelEncoders() {\n    return this.getChannelNames().flatMap(name => this.channels[name]);\n  }\n\n  getGroupBys() {\n    const fields = this.getChannelEncoders().filter(c => c.isGroupBy()).map(c => c.definition.field);\n    return Array.from(new Set(fields));\n  }\n\n  createLegendItemsFactory(field) {\n    const channelEncoders = this.getChannelEncoders().filter(e => isNotArray(e) && Object(ChannelDef[\"c\" /* isValueDef */])(e.definition)).flat().concat(this.legends[field]);\n    return domain => domain.map(input => ({\n      input,\n      output: channelEncoders.reduce((prev, curr) => {\n        const map = prev;\n        map[curr.name] = curr.encodeValue(input);\n        return map;\n      }, {})\n    }));\n  }\n\n  getLegendInformation(data = []) {\n    return Object.keys(this.legends) // for each field that was encoded\n    .map(field => {\n      // get all the channels that use this field\n      const channelEncoders = this.legends[field];\n      const firstEncoder = channelEncoders[0];\n      const definition = firstEncoder.definition;\n      const createLegendItems = this.createLegendItemsFactory(field);\n\n      if (definition.type === 'nominal') {\n        return {\n          channelEncoders,\n          createLegendItems,\n          field,\n          items: createLegendItems(firstEncoder.getDomainFromDataset(data)),\n          type: definition.type\n        };\n      }\n\n      return {\n        channelEncoders,\n        createLegendItems,\n        field,\n        type: definition.type\n      };\n    });\n  }\n\n  setDomainFromDataset(data) {\n    this.getChannelEncoders().forEach(channelEncoder => {\n      channelEncoder.setDomainFromDataset(data);\n    });\n    return this;\n  }\n\n  hasLegend() {\n    return Object.keys(this.legends).length > 0;\n  }\n\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/utils/mergeEncoding.js\nfunction mergeEncoding(defaultEncoding, encoding) {\n  return { ...defaultEncoding,\n    ...encoding\n  };\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/encoders/createEncoderFactory.js\n\n\n\nfunction createEncoderFactory(params) {\n  const {\n    channelTypes\n  } = params;\n  const completeEncoding = 'defaultEncoding' in params ? encoding => mergeEncoding(params.defaultEncoding, encoding) : params.completeEncoding;\n\n  const create = (encoding = {}) => new Encoder_Encoder({\n    channelTypes,\n    encoding: completeEncoding(encoding)\n  });\n\n  return {\n    channelTypes,\n    create,\n    createSelector: () => Object(es[\"createSelector\"])(encoding => encoding, create),\n    DEFAULT_ENCODING: completeEncoding({})\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIyMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vdHlwZUd1YXJkcy9CYXNlLmpzP2RmNzUiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS90eXBlcy9zY2FsZS9TY2FsZVR5cGUuanM/OTliMiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL3R5cGVHdWFyZHMvQ2hhbm5lbC5qcz9lODZiIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vdXRpbHMva2V5cy5qcz85YjY4Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vcGFyc2Vycy9kYXRlVGltZVRvVGltZXN0YW1wLmpzP2M3YWUiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS9wYXJzZXJzL3BhcnNlRGF0ZVRpbWUuanM/NmQyNyIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL3V0aWxzL2luZmVyRWxlbWVudFR5cGVGcm9tVW5pb25PZkFycmF5VHlwZXMuanM/MzhhMCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL3R5cGVHdWFyZHMvRGF0ZVRpbWUuanM/NDM0YiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL3BhcnNlcnMvZm9ybWF0L2ZhbGxiYWNrRm9ybWF0dGVyLmpzPzgzMDEiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS9wYXJzZXJzL2Zvcm1hdC9jcmVhdGVGb3JtYXR0ZXIuanM/NDIyNSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL2VuY29kZXJzL0NoYW5uZWxFbmNvZGVyQXhpcy5qcz8zZjA4Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vcGFyc2Vycy9jcmVhdGVHZXR0ZXJGcm9tQ2hhbm5lbERlZi5qcz8zM2JmIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vdXRpbHMvaXNEaXNhYmxlZC5qcz8yMGQzIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vdXRpbHMvaXNFbmFibGVkLmpzPzk0ZTgiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS9maWxsZXJzL2V4cGFuZExhYmVsT3ZlcmxhcFN0cmF0ZWd5LmpzP2Y1ODEiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS9wYXJzZXJzL3NjYWxlL3NjYWxlQ2F0ZWdvcmllcy5qcz82YWY5Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vZmlsbGVycy9jb21wbGV0ZUF4aXNDb25maWcuanM/ODU0ZiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL2ZpbGxlcnMvY29tcGxldGVGb3JtYXRDb25maWcuanM/NDQ3NyIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL2ZpbGxlcnMvY29tcGxldGVMZWdlbmRDb25maWcuanM/MWY2OCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL2ZpbGxlcnMvaW5mZXJTY2FsZVR5cGUuanM/NzY1MCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL3BhcnNlcnMvc2NhbGUvaXNQcm9wZXJ0eVN1cHBvcnRlZEJ5U2NhbGVUeXBlLmpzP2VhZTIiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS90eXBlR3VhcmRzL1NjYWxlQ29uZmlnLmpzP2U1MmUiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS9maWxsZXJzL2NvbXBsZXRlU2NhbGVDb25maWcuanM/NWI0MCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL2ZpbGxlcnMvaW5mZXJGaWVsZFR5cGUuanM/Nzg2OCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL2ZpbGxlcnMvY29tcGxldGVDaGFubmVsRGVmLmpzPzA5YzUiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS9wYXJzZXJzL3NjYWxlL2NyZWF0ZVNjYWxlRnJvbVNjYWxlVHlwZS5qcz9mNmNmIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vcGFyc2Vycy9zY2FsZS9hcHBseUFsaWduLmpzP2EwODEiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS9wYXJzZXJzL3NjYWxlL2FwcGx5QmFzZS5qcz9lMTgxIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vcGFyc2Vycy9zY2FsZS9hcHBseUNsYW1wLmpzPzQyYWIiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS9wYXJzZXJzL3NjYWxlL2FwcGx5RXhwb25lbnQuanM/MDQwYSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL3BhcnNlcnMvc2NhbGUvYXBwbHlOaWNlLmpzPzUxMDEiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS90eXBlR3VhcmRzL1NjYWxlLmpzP2FlYmMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS9wYXJzZXJzL3NjYWxlL2FwcGx5WmVyby5qcz8xN2I1Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vcGFyc2Vycy9zY2FsZS9jcmVhdGVDb2xvckludGVycG9sYXRvci5qcz83OGY4Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vcGFyc2Vycy9zY2FsZS9hcHBseUludGVycG9sYXRlLmpzPzQ1MzUiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS9wYXJzZXJzL3NjYWxlL2FwcGx5Um91bmQuanM/NDAxZCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL3BhcnNlcnMvZG9tYWluL3BhcnNlQ29udGludW91c0RvbWFpbi5qcz9mOWFhIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vcGFyc2Vycy9kb21haW4vcGFyc2VEaXNjcmV0ZURvbWFpbi5qcz82NDc3Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vdXRpbHMvY29tYmluZUNhdGVnb3JpZXMuanM/NGUxZSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL3V0aWxzL2NvbWJpbmVDb250aW51b3VzRG9tYWlucy5qcz9kYWU3Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vdXRpbHMvcmVtb3ZlVW5kZWZpbmVkQW5kTnVsbC5qcz80OTRmIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vcGFyc2Vycy9wYXJzZURhdGVUaW1lSW4uanM/ODA2YSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL3BhcnNlcnMvc2NhbGUvYXBwbHlEb21haW4uanM/NDMwZSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL3R5cGVHdWFyZHMvU2NoZW1lUGFyYW1zLmpzPzM5ZmYiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS9wYXJzZXJzL3NjYWxlL2FwcGx5UmFuZ2UuanM/MGNmNCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL3BhcnNlcnMvc2NhbGUvYXBwbHlQYWRkaW5nLmpzP2IyNmMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS9wYXJzZXJzL3NjYWxlL3VwZGF0ZVNjYWxlLmpzPzk4NjAiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS9wYXJzZXJzL3NjYWxlL2NyZWF0ZVNjYWxlLmpzP2Y0OGUiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS91dGlscy9pZGVudGl0eS5qcz9kM2FmIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vdHlwZUd1YXJkcy9Db21wbGV0ZUNoYW5uZWxEZWYuanM/MmJkOCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL2VuY29kZXJzL0NoYW5uZWxFbmNvZGVyLmpzPzVkMjAiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS9lbmNvZGVycy9FbmNvZGVyLmpzPzc1ZmUiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS91dGlscy9tZXJnZUVuY29kaW5nLmpzP2E2OWYiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS9lbmNvZGVycy9jcmVhdGVFbmNvZGVyRmFjdG9yeS5qcz8wZjRkIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBpc0FycmF5KG1heWJlQXJyYXkpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkobWF5YmVBcnJheSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNOb3RBcnJheShtYXliZUFycmF5KSB7XG4gIHJldHVybiAhQXJyYXkuaXNBcnJheShtYXliZUFycmF5KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0RlZmluZWQodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgIT09IG51bGw7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNFdmVyeUVsZW1lbnREZWZpbmVkKGFycmF5KSB7XG4gIHJldHVybiBhcnJheS5ldmVyeShpc0RlZmluZWQpO1xufSIsIi8vIE1vZGlmaWVkIGZyb20gdmVnYS1saXRlXG4vLyBiZWNhdXNlIHZlZ2EtbGl0ZSB1c2VzIG5hbWVzcGFjZSB3aGljaCBoYXMgaXNzdWVzIHdpdGggYmFiZWwgYW5kIHR5cGVzY3JpcHRcbmV4cG9ydCBjb25zdCBTY2FsZVR5cGUgPSB7XG4gIC8vIENvbnRpbnVvdXMgLSBRdWFudGl0YXRpdmVcbiAgTElORUFSOiAnbGluZWFyJyxcbiAgTE9HOiAnbG9nJyxcbiAgUE9XOiAncG93JyxcbiAgU1FSVDogJ3NxcnQnLFxuICBTWU1MT0c6ICdzeW1sb2cnLFxuICAvLyBDb250aW51b3VzIC0gVGltZVxuICBUSU1FOiAndGltZScsXG4gIFVUQzogJ3V0YycsXG4gIC8vIERpc2NyZXRpemluZyBzY2FsZXNcbiAgUVVBTlRJTEU6ICdxdWFudGlsZScsXG4gIFFVQU5USVpFOiAncXVhbnRpemUnLFxuICBUSFJFU0hPTEQ6ICd0aHJlc2hvbGQnLFxuICBCSU5fT1JESU5BTDogJ2Jpbi1vcmRpbmFsJyxcbiAgLy8gRGlzY3JldGUgc2NhbGVzXG4gIE9SRElOQUw6ICdvcmRpbmFsJyxcbiAgUE9JTlQ6ICdwb2ludCcsXG4gIEJBTkQ6ICdiYW5kJ1xufTsiLCJleHBvcnQgZnVuY3Rpb24gaXNYKGNoYW5uZWxUeXBlKSB7XG4gIHJldHVybiBjaGFubmVsVHlwZSA9PT0gJ1gnIHx8IGNoYW5uZWxUeXBlID09PSAnWEJhbmQnO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzWShjaGFubmVsVHlwZSkge1xuICByZXR1cm4gY2hhbm5lbFR5cGUgPT09ICdZJyB8fCBjaGFubmVsVHlwZSA9PT0gJ1lCYW5kJztcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1hPclkoY2hhbm5lbFR5cGUpIHtcbiAgcmV0dXJuIGlzWChjaGFubmVsVHlwZSkgfHwgaXNZKGNoYW5uZWxUeXBlKTtcbn0iLCIvKipcbiAqIFRoaXMgaXMgYSBzdHJpY3RlciB2ZXJzaW9uIG9mIE9iamVjdC5rZXlzIGJ1dCB3aXRoIGJldHRlciB0eXBlcy5cbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvcHVsbC8xMjI1MyNpc3N1ZWNvbW1lbnQtMjYzMTMyMjA4XG4gKi9cbmNvbnN0IGtleXMgPSBPYmplY3Qua2V5cztcbmV4cG9ydCBkZWZhdWx0IGtleXM7IiwiLy8gTW9kaWZpZWQgZnJvbSB2ZWdhLWxpdGUgdmVyc2lvblxuLy8gYW5kIHJlbW92ZSB1bm5lY2Vzc2FyeSBkZXBlbmRlbmN5XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLW5lZ2F0ZWQtY29uZGl0aW9uICovXG5pbXBvcnQga2V5cyBmcm9tICcuLi91dGlscy9rZXlzJztcbi8qKlxuICogSW50ZXJuYWwgT2JqZWN0IGZvciBkZWZpbmluZyBkYXRldGltZSBleHByZXNzaW9ucy5cbiAqIFRoaXMgaXMgYW4gZXhwcmVzc2lvbiB2ZXJzaW9uIG9mIERhdGVUaW1lLlxuICogSWYgYm90aCBtb250aCBhbmQgcXVhcnRlciBhcmUgcHJvdmlkZWQsIG1vbnRoIGhhcyBoaWdoZXIgcHJlY2VkZW5jZS5cbiAqIGBkYXlgIGNhbm5vdCBiZSBjb21iaW5lZCB3aXRoIG90aGVyIGRhdGUuXG4gKi9cblxuZnVuY3Rpb24gaW52YWxpZFRpbWVVbml0KHVuaXROYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gXCJJbnZhbGlkIFwiICsgdW5pdE5hbWUgKyBcIjogXCIgKyBTdHJpbmcodmFsdWUpICsgXCIuXCI7XG59XG4vKlxuICogQSBkZXNpZ25hdGVkIHllYXIgdGhhdCBzdGFydHMgb24gU3VuZGF5LlxuICovXG5cblxuY29uc3QgU1VOREFZX1lFQVIgPSAyMDA2O1xuY29uc3QgTU9OVEhTID0gWydqYW51YXJ5JywgJ2ZlYnJ1YXJ5JywgJ21hcmNoJywgJ2FwcmlsJywgJ21heScsICdqdW5lJywgJ2p1bHknLCAnYXVndXN0JywgJ3NlcHRlbWJlcicsICdvY3RvYmVyJywgJ25vdmVtYmVyJywgJ2RlY2VtYmVyJ107XG5jb25zdCBTSE9SVF9NT05USFMgPSBNT05USFMubWFwKG0gPT4gbS5zbGljZSgwLCAzKSk7XG5jb25zdCBEQVlTID0gWydzdW5kYXknLCAnbW9uZGF5JywgJ3R1ZXNkYXknLCAnd2VkbmVzZGF5JywgJ3RodXJzZGF5JywgJ2ZyaWRheScsICdzYXR1cmRheSddO1xuY29uc3QgU0hPUlRfREFZUyA9IERBWVMubWFwKGQgPT4gZC5zbGljZSgwLCAzKSk7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSAnbnVtYmVyJztcbn1cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIHRoZSBwYXNzZWQgaW4gdmFsdWUgaXMgYSB2YWxpZCBudW1iZXIuXG4gKi9cblxuXG5mdW5jdGlvbiBpc051bWVyaWModmFsdWUpIHtcbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cblxuICByZXR1cm4gIWlzTmFOKHZhbHVlKSAmJiAhaXNOYU4ocGFyc2VGbG9hdCh2YWx1ZSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplUXVhcnRlcihxKSB7XG4gIGlmIChpc051bWVyaWMocSkpIHtcbiAgICBxID0gTnVtYmVyKHEpO1xuICB9XG5cbiAgaWYgKGlzTnVtYmVyKHEpKSB7XG4gICAgaWYgKHEgPiA0KSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS53YXJuKGludmFsaWRUaW1lVW5pdCgncXVhcnRlcicsIHEpKTtcbiAgICB9IC8vIFdlIGFjY2VwdCAxLWJhc2VkIHF1YXJ0ZXIsIHNvIG5lZWQgdG8gcmVhZGp1c3QgdG8gMC1iYXNlZCBxdWFydGVyXG5cblxuICAgIHJldHVybiBxIC0gMTtcbiAgfSAvLyBJbnZhbGlkIHF1YXJ0ZXJcblxuXG4gIHRocm93IG5ldyBFcnJvcihpbnZhbGlkVGltZVVuaXQoJ3F1YXJ0ZXInLCBxKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplTW9udGgobSkge1xuICBpZiAoaXNOdW1lcmljKG0pKSB7XG4gICAgbSA9IE51bWJlcihtKTtcbiAgfVxuXG4gIGlmIChpc051bWJlcihtKSkge1xuICAgIC8vIFdlIGFjY2VwdCAxLWJhc2VkIG1vbnRoLCBzbyBuZWVkIHRvIHJlYWRqdXN0IHRvIDAtYmFzZWQgbW9udGhcbiAgICByZXR1cm4gbSAtIDE7XG4gIH1cblxuICBjb25zdCBsb3dlck0gPSBtLnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IG1vbnRoSW5kZXggPSBNT05USFMuaW5kZXhPZihsb3dlck0pO1xuXG4gIGlmIChtb250aEluZGV4ICE9PSAtMSkge1xuICAgIHJldHVybiBtb250aEluZGV4OyAvLyAwIGZvciBqYW51YXJ5LCAuLi5cbiAgfVxuXG4gIGNvbnN0IHNob3J0TSA9IGxvd2VyTS5zbGljZSgwLCAzKTtcbiAgY29uc3Qgc2hvcnRNb250aEluZGV4ID0gU0hPUlRfTU9OVEhTLmluZGV4T2Yoc2hvcnRNKTtcblxuICBpZiAoc2hvcnRNb250aEluZGV4ICE9PSAtMSkge1xuICAgIHJldHVybiBzaG9ydE1vbnRoSW5kZXg7XG4gIH0gLy8gSW52YWxpZCBtb250aFxuXG5cbiAgdGhyb3cgbmV3IEVycm9yKGludmFsaWRUaW1lVW5pdCgnbW9udGgnLCBtKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplRGF5KGQpIHtcbiAgaWYgKGlzTnVtZXJpYyhkKSkge1xuICAgIGQgPSBOdW1iZXIoZCk7XG4gIH1cblxuICBpZiAoaXNOdW1iZXIoZCkpIHtcbiAgICAvLyBtb2Qgc28gdGhhdCB0aGlzIGNhbiBiZSBib3RoIDAtYmFzZWQgd2hlcmUgMCA9IHN1bmRheVxuICAgIC8vIGFuZCAxLWJhc2VkIHdoZXJlIDc9c3VuZGF5XG4gICAgcmV0dXJuIGQgJSA3O1xuICB9XG5cbiAgY29uc3QgbG93ZXJEID0gZC50b0xvd2VyQ2FzZSgpO1xuICBjb25zdCBkYXlJbmRleCA9IERBWVMuaW5kZXhPZihsb3dlckQpO1xuXG4gIGlmIChkYXlJbmRleCAhPT0gLTEpIHtcbiAgICByZXR1cm4gZGF5SW5kZXg7IC8vIDAgZm9yIGphbnVhcnksIC4uLlxuICB9XG5cbiAgY29uc3Qgc2hvcnREID0gbG93ZXJELnNsaWNlKDAsIDMpO1xuICBjb25zdCBzaG9ydERheUluZGV4ID0gU0hPUlRfREFZUy5pbmRleE9mKHNob3J0RCk7XG5cbiAgaWYgKHNob3J0RGF5SW5kZXggIT09IC0xKSB7XG4gICAgcmV0dXJuIHNob3J0RGF5SW5kZXg7XG4gIH0gLy8gSW52YWxpZCBkYXlcblxuXG4gIHRocm93IG5ldyBFcnJvcihpbnZhbGlkVGltZVVuaXQoJ2RheScsIGQpKTtcbn1cbi8qKlxuICogQHBhcmFtIGQgdGhlIGRhdGUuXG4gKiBAcGFyYW0gbm9ybWFsaXplIHdoZXRoZXIgdG8gbm9ybWFsaXplIHF1YXJ0ZXIsIG1vbnRoLCBkYXkuIFRoaXMgc2hvdWxkIHByb2JhYmx5IGJlIHRydWUgaWYgZCBpcyBhIERhdGVUaW1lLlxuICogQHJldHVybnMgYXJyYXkgb2YgZGF0ZSB0aW1lIHBhcnRzIFt5ZWFyLCBtb250aCwgZGF5LCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzXVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkYXRlVGltZVBhcnRzKGQsIG5vcm1hbGl6ZSkge1xuICBjb25zdCBwYXJ0cyA9IFtdO1xuXG4gIGlmIChub3JtYWxpemUgJiYgZC5kYXkgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChrZXlzKGQpLmxlbmd0aCA+IDEpIHtcbiAgICAgIGQgPSB7IC4uLmRcbiAgICAgIH07XG4gICAgICBkZWxldGUgZC5kYXk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGQueWVhciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcGFydHMucHVzaChkLnllYXIpO1xuICB9IGVsc2UgaWYgKGQuZGF5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBTZXQgeWVhciB0byAyMDA2IGZvciB3b3JraW5nIHdpdGggZGF5IHNpbmNlIEphbnVhcnkgMSAyMDA2IGlzIGEgU3VuZGF5XG4gICAgcGFydHMucHVzaChTVU5EQVlfWUVBUik7XG4gIH0gZWxzZSB7XG4gICAgcGFydHMucHVzaCgwKTtcbiAgfVxuXG4gIGlmIChkLm1vbnRoICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBtb250aCA9IG5vcm1hbGl6ZSA/IG5vcm1hbGl6ZU1vbnRoKGQubW9udGgpIDogZC5tb250aDtcbiAgICBwYXJ0cy5wdXNoKG1vbnRoKTtcbiAgfSBlbHNlIGlmIChkLnF1YXJ0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IHF1YXJ0ZXIgPSBub3JtYWxpemUgPyBub3JtYWxpemVRdWFydGVyKGQucXVhcnRlcikgOiBkLnF1YXJ0ZXI7XG4gICAgcGFydHMucHVzaChpc051bWJlcihxdWFydGVyKSA/IHF1YXJ0ZXIgKiAzIDogcXVhcnRlciArIFwiKjNcIik7XG4gIH0gZWxzZSB7XG4gICAgcGFydHMucHVzaCgwKTsgLy8gbW9udGhzIHN0YXJ0IGF0IHplcm8gaW4gSlNcbiAgfVxuXG4gIGlmIChkLmRhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgIHBhcnRzLnB1c2goZC5kYXRlKTtcbiAgfSBlbHNlIGlmIChkLmRheSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gSEFDSzogRGF5IG9ubHkgd29ya3MgYXMgYSBzdGFuZGFsb25lIHVuaXRcbiAgICAvLyBUaGlzIGlzIG9ubHkgY29ycmVjdCBiZWNhdXNlIHdlIGFsd2F5cyBzZXQgeWVhciB0byAyMDA2IGZvciBkYXlcbiAgICBjb25zdCBkYXkgPSBub3JtYWxpemUgPyBub3JtYWxpemVEYXkoZC5kYXkpIDogZC5kYXk7XG4gICAgcGFydHMucHVzaChpc051bWJlcihkYXkpID8gZGF5ICsgMSA6IGRheSArIFwiKzFcIik7XG4gIH0gZWxzZSB7XG4gICAgcGFydHMucHVzaCgxKTsgLy8gRGF0ZSBzdGFydHMgYXQgMSBpbiBKU1xuICB9XG5cbiAgWydob3VycycsICdtaW51dGVzJywgJ3NlY29uZHMnLCAnbWlsbGlzZWNvbmRzJ10uZm9yRWFjaCh0aW1lVW5pdCA9PiB7XG4gICAgY29uc3QgdW5pdCA9IGRbdGltZVVuaXRdO1xuICAgIHBhcnRzLnB1c2godHlwZW9mIHVuaXQgPT09ICd1bmRlZmluZWQnID8gMCA6IHVuaXQpO1xuICB9KTtcbiAgcmV0dXJuIHBhcnRzO1xufVxuLyoqXG4gKiBAcGFyYW0gZCB0aGUgZGF0ZSB0aW1lLlxuICogQHJldHVybnMgdGhlIHRpbWVzdGFtcC5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkYXRlVGltZVRvVGltZXN0YW1wKGQpIHtcbiAgY29uc3QgcGFydHMgPSBkYXRlVGltZVBhcnRzKGQsIHRydWUpO1xuXG4gIGlmIChkLnV0Yykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgcmV0dXJuIE51bWJlcihuZXcgRGF0ZShEYXRlLlVUQyguLi5wYXJ0cykpKTtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG5cbiAgcmV0dXJuIE51bWJlcihuZXcgRGF0ZSguLi5wYXJ0cykpO1xufSIsImltcG9ydCBkYXRlVGltZVRvVGltZXN0YW1wIGZyb20gJy4vZGF0ZVRpbWVUb1RpbWVzdGFtcCc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwYXJzZURhdGVUaW1lKGRhdGVUaW1lKSB7XG4gIGlmICh0eXBlb2YgZGF0ZVRpbWUgPT09ICdudW1iZXInIHx8IHR5cGVvZiBkYXRlVGltZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoZGF0ZVRpbWUpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBEYXRlKGRhdGVUaW1lVG9UaW1lc3RhbXAoZGF0ZVRpbWUpKTtcbn0iLCIvKipcbiAqIFR5cGUgd29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy83Mjk0I2lzc3VlY29tbWVudC00NjU3OTQ0NjBcbiAqIHRvIGF2b2lkIGVycm9yIFwiQ2Fubm90IGludm9rZSBhbiBleHByZXNzaW9uIHdob3NlIHR5cGUgbGFja3MgYSBjYWxsIHNpZ25hdHVyZVwiXG4gKiB3aGVuIHVzaW5nIGFycmF5Lm1hcFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbmZlckVsZW1lbnRUeXBlRnJvbVVuaW9uT2ZBcnJheVR5cGVzKGFycmF5KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIHJldHVybiBhcnJheTtcbn0iLCIvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L3ByZWZlci1kZWZhdWx0LWV4cG9ydFxuZXhwb3J0IGZ1bmN0aW9uIGlzRGF0ZVRpbWUobykge1xuICByZXR1cm4gISFvICYmICEobyBpbnN0YW5jZW9mIERhdGUpICYmIHR5cGVvZiBvICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgbyAhPT0gJ2Jvb2xlYW4nICYmIHR5cGVvZiBvICE9PSAnbnVtYmVyJyAmJiAoJ3llYXInIGluIG8gJiYgby55ZWFyICE9IG51bGwgfHwgJ3F1YXJ0ZXInIGluIG8gJiYgby5xdWFydGVyICE9IG51bGwgfHwgJ21vbnRoJyBpbiBvICYmIG8ubW9udGggIT0gbnVsbCB8fCAnZGF0ZScgaW4gbyAmJiBvLmRhdGUgIT0gbnVsbCB8fCAnZGF5JyBpbiBvICYmIG8uZGF5ICE9IG51bGwgfHwgJ2hvdXJzJyBpbiBvICYmIG8uaG91cnMgIT0gbnVsbCB8fCAnbWludXRlcycgaW4gbyAmJiBvLm1pbnV0ZXMgIT0gbnVsbCB8fCAnc2Vjb25kcycgaW4gbyAmJiBvLnNlY29uZHMgIT0gbnVsbCB8fCAnbWlsbGlzZWNvbmRzJyBpbiBvICYmIG8ubWlsbGlzZWNvbmRzICE9IG51bGwpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZhbGxiYWNrRm9ybWF0dGVyKHYpIHtcbiAgcmV0dXJuIFwiXCIgKyB2O1xufSIsImltcG9ydCBmYWxsYmFja0Zvcm1hdHRlciBmcm9tICcuL2ZhbGxiYWNrRm9ybWF0dGVyJztcbmltcG9ydCBFbmNvZGFibGUgZnJvbSAnLi4vLi4vb3B0aW9ucy9FbmNvZGFibGUnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlRm9ybWF0dGVyKHtcbiAgZm9ybWF0VHlwZSxcbiAgZm9ybWF0LFxuICBmb3JtYXRJbkxvY2FsVGltZVxufSkge1xuICBpZiAoZm9ybWF0VHlwZSA9PT0gJ3RpbWUnKSB7XG4gICAgY29uc3QgZm9ybWF0dGVyID0gRW5jb2RhYmxlLnJlc29sdmVUaW1lRm9ybWF0KHtcbiAgICAgIGZvcm1hdCxcbiAgICAgIGZvcm1hdEluTG9jYWxUaW1lXG4gICAgfSk7XG4gICAgcmV0dXJuIHZhbHVlID0+IGZvcm1hdHRlcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoZm9ybWF0VHlwZSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGZvcm1hdCAhPT0gJ3VuZGVmaW5lZCcgJiYgZm9ybWF0Lmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBmb3JtYXR0ZXIgPSBFbmNvZGFibGUucmVzb2x2ZU51bWJlckZvcm1hdChmb3JtYXQpO1xuICAgIHJldHVybiB2YWx1ZSA9PiBmb3JtYXR0ZXIodmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIGZhbGxiYWNrRm9ybWF0dGVyO1xufSIsImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmltcG9ydCBwYXJzZURhdGVUaW1lIGZyb20gJy4uL3BhcnNlcnMvcGFyc2VEYXRlVGltZSc7XG5pbXBvcnQgaW5mZXJFbGVtZW50VHlwZUZyb21Vbmlvbk9mQXJyYXlUeXBlcyBmcm9tICcuLi91dGlscy9pbmZlckVsZW1lbnRUeXBlRnJvbVVuaW9uT2ZBcnJheVR5cGVzJztcbmltcG9ydCB7IGlzRGF0ZVRpbWUgfSBmcm9tICcuLi90eXBlR3VhcmRzL0RhdGVUaW1lJztcbmltcG9ydCBjcmVhdGVGb3JtYXR0ZXIgZnJvbSAnLi4vcGFyc2Vycy9mb3JtYXQvY3JlYXRlRm9ybWF0dGVyJztcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENoYW5uZWxFbmNvZGVyQXhpcyB7XG4gIGNvbnN0cnVjdG9yKGNoYW5uZWxFbmNvZGVyKSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY2hhbm5lbEVuY29kZXJcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbmZpZ1wiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZm9ybWF0VmFsdWVcIiwgdm9pZCAwKTtcblxuICAgIHRoaXMuY2hhbm5lbEVuY29kZXIgPSBjaGFubmVsRW5jb2RlcjtcbiAgICB0aGlzLmNvbmZpZyA9IGNoYW5uZWxFbmNvZGVyLmRlZmluaXRpb24uYXhpcztcbiAgICB0aGlzLmZvcm1hdFZhbHVlID0gY3JlYXRlRm9ybWF0dGVyKHRoaXMuY29uZmlnKTtcbiAgfVxuXG4gIGdldFRpdGxlKCkge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy50aXRsZTtcbiAgfVxuXG4gIGhhc1RpdGxlKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHRpdGxlXG4gICAgfSA9IHRoaXMuY29uZmlnO1xuICAgIHJldHVybiB0aXRsZSAhPT0gbnVsbCAmJiB0eXBlb2YgdGl0bGUgIT09ICd1bmRlZmluZWQnICYmIHRpdGxlICE9PSAnJztcbiAgfVxuXG4gIGdldFRpY2tMYWJlbHMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgdGlja0NvdW50LFxuICAgICAgdmFsdWVzXG4gICAgfSA9IHRoaXMuY29uZmlnO1xuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gaW5mZXJFbGVtZW50VHlwZUZyb21Vbmlvbk9mQXJyYXlUeXBlcyh2YWx1ZXMpLm1hcCh2ID0+IHRoaXMuZm9ybWF0VmFsdWUoaXNEYXRlVGltZSh2KSA/IHBhcnNlRGF0ZVRpbWUodikgOiB2KSk7XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgc2NhbGVcbiAgICB9ID0gdGhpcy5jaGFubmVsRW5jb2RlcjtcblxuICAgIGlmIChzY2FsZSAmJiAnZG9tYWluJyBpbiBzY2FsZSkge1xuICAgICAgY29uc3QgdGlja3MgPSAndGlja3MnIGluIHNjYWxlID8gc2NhbGUudGlja3ModGlja0NvdW50KSA6IHNjYWxlLmRvbWFpbigpO1xuICAgICAgcmV0dXJuIHRpY2tzLm1hcCh0aGlzLmZvcm1hdFZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW107XG4gIH1cblxufSIsImltcG9ydCBnZXQgZnJvbSAnbG9kYXNoLmdldCc7XG5pbXBvcnQgeyBpc1ZhbHVlRGVmIH0gZnJvbSAnLi4vdHlwZUd1YXJkcy9DaGFubmVsRGVmJztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZUdldHRlckZyb21DaGFubmVsRGVmKGRlZmluaXRpb24pIHtcbiAgaWYgKGlzVmFsdWVEZWYoZGVmaW5pdGlvbikpIHtcbiAgICByZXR1cm4gKCkgPT4gZGVmaW5pdGlvbi52YWx1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZGVmaW5pdGlvbi5maWVsZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4geCA9PiBnZXQoeCwgZGVmaW5pdGlvbi5maWVsZCk7XG4gIH1cblxuICByZXR1cm4gKCkgPT4gdW5kZWZpbmVkO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzRGlzYWJsZWQoY29uZmlnKSB7XG4gIHJldHVybiBjb25maWcgPT09IGZhbHNlIHx8IGNvbmZpZyA9PT0gbnVsbDtcbn0iLCJpbXBvcnQgaXNEaXNhYmxlZCBmcm9tICcuL2lzRGlzYWJsZWQnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNFbmFibGVkKGNvbmZpZykge1xuICByZXR1cm4gIWlzRGlzYWJsZWQoY29uZmlnKTtcbn0iLCJpbXBvcnQgeyBpc1ggfSBmcm9tICcuLi90eXBlR3VhcmRzL0NoYW5uZWwnO1xuZXhwb3J0IGNvbnN0IFNUUkFURUdZX0ZMQVQgPSB7XG4gIHN0cmF0ZWd5OiAnZmxhdCdcbn07XG5jb25zdCBTVFJBVEVHWV9ST1RBVEUgPSB7XG4gIGxhYmVsQW5nbGU6IDQwLFxuICBzdHJhdGVneTogJ3JvdGF0ZSdcbn07XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBleHBhbmRMYWJlbE92ZXJsYXBTdHJhdGVneShjaGFubmVsVHlwZSwgbGFiZWxPdmVybGFwID0gJ2F1dG8nKSB7XG4gIGxldCBvdXRwdXQ7XG5cbiAgc3dpdGNoIChsYWJlbE92ZXJsYXApIHtcbiAgICBjYXNlICdmbGF0JzpcbiAgICAgIG91dHB1dCA9IFNUUkFURUdZX0ZMQVQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3JvdGF0ZSc6XG4gICAgICBvdXRwdXQgPSBTVFJBVEVHWV9ST1RBVEU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2F1dG8nOlxuICAgICAgb3V0cHV0ID0gaXNYKGNoYW5uZWxUeXBlKSA/IFNUUkFURUdZX1JPVEFURSA6IFNUUkFURUdZX0ZMQVQ7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBvdXRwdXQgPSBsYWJlbE92ZXJsYXA7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiB7IC4uLm91dHB1dFxuICB9O1xufSIsImltcG9ydCB7IFNjYWxlVHlwZSB9IGZyb20gJy4uLy4uL3R5cGVzJzsgLy8gR3JvdXBlZCBieSBkb21haW4gYW5kIHJhbmdlXG5cbmV4cG9ydCBjb25zdCBjb250aW51b3VzVG9Db250aW51b3VzU2NhbGVUeXBlcyA9IFtTY2FsZVR5cGUuTElORUFSLCBTY2FsZVR5cGUuUE9XLCBTY2FsZVR5cGUuU1FSVCwgU2NhbGVUeXBlLlNZTUxPRywgU2NhbGVUeXBlLkxPRywgU2NhbGVUeXBlLlRJTUUsIFNjYWxlVHlwZS5VVENdO1xuZXhwb3J0IGNvbnN0IGNvbnRpbnVvdXNUb0NvbnRpbnVvdXNTY2FsZVR5cGVzU2V0ID0gbmV3IFNldChjb250aW51b3VzVG9Db250aW51b3VzU2NhbGVUeXBlcyk7XG5leHBvcnQgY29uc3QgY29udGludW91c1RvRGlzY3JldGVTY2FsZVR5cGVzID0gW1NjYWxlVHlwZS5RVUFOVElMRSwgU2NhbGVUeXBlLlFVQU5USVpFLCBTY2FsZVR5cGUuVEhSRVNIT0xEXTtcbmV4cG9ydCBjb25zdCBjb250aW51b3VzVG9EaXNjcmV0ZVNjYWxlVHlwZXNTZXQgPSBuZXcgU2V0KGNvbnRpbnVvdXNUb0Rpc2NyZXRlU2NhbGVUeXBlcyk7IC8vIEdyb3VwZWQgYnkgRG9tYWluXG5cbmV4cG9ydCBjb25zdCBjb250aW51b3VzRG9tYWluU2NhbGVUeXBlcyA9IGNvbnRpbnVvdXNUb0NvbnRpbnVvdXNTY2FsZVR5cGVzLmNvbmNhdChjb250aW51b3VzVG9EaXNjcmV0ZVNjYWxlVHlwZXMpO1xuZXhwb3J0IGNvbnN0IGNvbnRpbnVvdXNEb21haW5TY2FsZVR5cGVzU2V0ID0gbmV3IFNldChjb250aW51b3VzRG9tYWluU2NhbGVUeXBlcyk7XG5leHBvcnQgY29uc3QgZGlzY3JldGVEb21haW5TY2FsZVR5cGVzID0gW1NjYWxlVHlwZS5PUkRJTkFMLCBTY2FsZVR5cGUuQklOX09SRElOQUwsIFNjYWxlVHlwZS5QT0lOVCwgU2NhbGVUeXBlLkJBTkRdO1xuZXhwb3J0IGNvbnN0IGRpc2NyZXRlRG9tYWluU2NhbGVUeXBlc1NldCA9IG5ldyBTZXQoZGlzY3JldGVEb21haW5TY2FsZVR5cGVzKTsgLy8gVGhyZWUgYnJvYWQgY2F0ZWdvcmllc1xuXG5leHBvcnQgY29uc3QgY29udGludW91c1NjYWxlVHlwZXMgPSBjb250aW51b3VzVG9Db250aW51b3VzU2NhbGVUeXBlcztcbmV4cG9ydCBjb25zdCBjb250aW51b3VzU2NhbGVUeXBlc1NldCA9IGNvbnRpbnVvdXNUb0NvbnRpbnVvdXNTY2FsZVR5cGVzU2V0O1xuZXhwb3J0IGNvbnN0IGRpc2NyZXRlU2NhbGVUeXBlcyA9IFtTY2FsZVR5cGUuQkFORCwgU2NhbGVUeXBlLlBPSU5ULCBTY2FsZVR5cGUuT1JESU5BTF07XG5leHBvcnQgY29uc3QgZGlzY3JldGVTY2FsZVR5cGVzU2V0ID0gbmV3IFNldChkaXNjcmV0ZVNjYWxlVHlwZXMpO1xuZXhwb3J0IGNvbnN0IGRpc2NyZXRpemluZ1NjYWxlVHlwZXMgPSBbU2NhbGVUeXBlLkJJTl9PUkRJTkFMLCBTY2FsZVR5cGUuUVVBTlRJTEUsIFNjYWxlVHlwZS5RVUFOVElaRSwgU2NhbGVUeXBlLlRIUkVTSE9MRF07XG5leHBvcnQgY29uc3QgZGlzY3JldGl6aW5nU2NhbGVUeXBlc1NldCA9IG5ldyBTZXQoZGlzY3JldGl6aW5nU2NhbGVUeXBlcyk7IC8vIE90aGVyc1xuXG5leHBvcnQgY29uc3QgdGltZVNjYWxlVHlwZXMgPSBbU2NhbGVUeXBlLlRJTUUsIFNjYWxlVHlwZS5VVENdO1xuZXhwb3J0IGNvbnN0IHRpbWVTY2FsZVR5cGVzU2V0ID0gbmV3IFNldCh0aW1lU2NhbGVUeXBlcyk7XG5leHBvcnQgY29uc3QgYWxsU2NhbGVUeXBlcyA9IFtTY2FsZVR5cGUuTElORUFSLCBTY2FsZVR5cGUuTE9HLCBTY2FsZVR5cGUuUE9XLCBTY2FsZVR5cGUuU1FSVCwgU2NhbGVUeXBlLlNZTUxPRywgU2NhbGVUeXBlLlRJTUUsIFNjYWxlVHlwZS5VVEMsIFNjYWxlVHlwZS5RVUFOVElMRSwgU2NhbGVUeXBlLlFVQU5USVpFLCBTY2FsZVR5cGUuVEhSRVNIT0xELCBTY2FsZVR5cGUuQklOX09SRElOQUwsIFNjYWxlVHlwZS5PUkRJTkFMLCBTY2FsZVR5cGUuUE9JTlQsIFNjYWxlVHlwZS5CQU5EXTtcbmV4cG9ydCBjb25zdCBhbGxTY2FsZVR5cGVzU2V0ID0gbmV3IFNldChhbGxTY2FsZVR5cGVzKTsiLCJpbXBvcnQgaXNFbmFibGVkIGZyb20gJy4uL3V0aWxzL2lzRW5hYmxlZCc7XG5pbXBvcnQgeyBpc1hPclksIGlzWCB9IGZyb20gJy4uL3R5cGVHdWFyZHMvQ2hhbm5lbCc7XG5pbXBvcnQgeyBpc1R5cGVkRmllbGREZWYgfSBmcm9tICcuLi90eXBlR3VhcmRzL0NoYW5uZWxEZWYnO1xuaW1wb3J0IGV4cGFuZExhYmVsT3ZlcmxhcFN0cmF0ZWd5IGZyb20gJy4vZXhwYW5kTGFiZWxPdmVybGFwU3RyYXRlZ3knO1xuaW1wb3J0IHsgY29udGludW91c1RvQ29udGludW91c1NjYWxlVHlwZXNTZXQgfSBmcm9tICcuLi9wYXJzZXJzL3NjYWxlL3NjYWxlQ2F0ZWdvcmllcyc7XG5cbmZ1bmN0aW9uIGlzQ2hhbm5lbERlZldpdGhBeGlzU3VwcG9ydChjaGFubmVsVHlwZSwgY2hhbm5lbERlZikge1xuICByZXR1cm4gaXNUeXBlZEZpZWxkRGVmKGNoYW5uZWxEZWYpICYmIGlzWE9yWShjaGFubmVsVHlwZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXBsZXRlQXhpc0NvbmZpZyhjaGFubmVsVHlwZSwgY2hhbm5lbERlZikge1xuICBpZiAoaXNDaGFubmVsRGVmV2l0aEF4aXNTdXBwb3J0KGNoYW5uZWxUeXBlLCBjaGFubmVsRGVmKSAmJiBpc0VuYWJsZWQoY2hhbm5lbERlZi5heGlzKSkge1xuICAgIGNvbnN0IGF4aXMgPSBjaGFubmVsRGVmLmF4aXMgPT09IHRydWUgfHwgdHlwZW9mIGNoYW5uZWxEZWYuYXhpcyA9PT0gJ3VuZGVmaW5lZCcgPyB7fSA6IGNoYW5uZWxEZWYuYXhpcztcbiAgICBjb25zdCBpc1hDaGFubmVsID0gaXNYKGNoYW5uZWxUeXBlKTtcbiAgICBjb25zdCB7XG4gICAgICBmb3JtYXQgPSBjaGFubmVsRGVmLmZvcm1hdCxcbiAgICAgIGZvcm1hdFR5cGUgPSBjaGFubmVsRGVmLmZvcm1hdFR5cGUsXG4gICAgICBmb3JtYXRJbkxvY2FsVGltZSA9IGNoYW5uZWxEZWYuZm9ybWF0SW5Mb2NhbFRpbWUsXG4gICAgICBsYWJlbEFuZ2xlID0gMCxcbiAgICAgIGxhYmVsRmx1c2gsXG4gICAgICBsYWJlbE92ZXJsYXAsXG4gICAgICBsYWJlbFBhZGRpbmcgPSA0LFxuICAgICAgb3JpZW50ID0gaXNYQ2hhbm5lbCA/ICdib3R0b20nIDogJ2xlZnQnLFxuICAgICAgdGlja0NvdW50ID0gNSxcbiAgICAgIHRpY2tzID0gdHJ1ZSxcbiAgICAgIHRpdGxlID0gY2hhbm5lbERlZi50aXRsZSxcbiAgICAgIHRpdGxlUGFkZGluZyA9IDRcbiAgICB9ID0gYXhpcztcbiAgICBjb25zdCBvdXRwdXQgPSB7IC4uLmF4aXMsXG4gICAgICBmb3JtYXQsXG4gICAgICBmb3JtYXRUeXBlLFxuICAgICAgbGFiZWxBbmdsZSxcbiAgICAgIGxhYmVsRmx1c2g6IHR5cGVvZiBsYWJlbEZsdXNoID09PSAndW5kZWZpbmVkJyA/IGNoYW5uZWxEZWYuc2NhbGUgJiYgdHlwZW9mIGNoYW5uZWxEZWYuc2NhbGUudHlwZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29udGludW91c1RvQ29udGludW91c1NjYWxlVHlwZXNTZXQuaGFzKGNoYW5uZWxEZWYuc2NhbGUudHlwZSkgOiBsYWJlbEZsdXNoLFxuICAgICAgbGFiZWxPdmVybGFwOiBleHBhbmRMYWJlbE92ZXJsYXBTdHJhdGVneShjaGFubmVsVHlwZSwgbGFiZWxPdmVybGFwKSxcbiAgICAgIGxhYmVsUGFkZGluZyxcbiAgICAgIG9yaWVudCxcbiAgICAgIHRpY2tDb3VudCxcbiAgICAgIHRpY2tzLFxuICAgICAgdGl0bGUsXG4gICAgICB0aXRsZVBhZGRpbmdcbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiBmb3JtYXRJbkxvY2FsVGltZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG91dHB1dC5mb3JtYXRJbkxvY2FsVGltZSA9IGZvcm1hdEluTG9jYWxUaW1lO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcGxldGVGb3JtYXRDb25maWcoY29uZmlnKSB7XG4gIGNvbnN0IHtcbiAgICBmb3JtYXRUeXBlLFxuICAgIGZvcm1hdEluTG9jYWxUaW1lLFxuICAgIGZvcm1hdCxcbiAgICB0eXBlLFxuICAgIHNjYWxlVHlwZVxuICB9ID0gY29uZmlnO1xuICBsZXQgcmVzb2x2ZWRGb3JtYXRUeXBlO1xuXG4gIGlmICh0eXBlb2YgZm9ybWF0VHlwZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXNvbHZlZEZvcm1hdFR5cGUgPSBmb3JtYXRUeXBlO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdxdWFudGl0YXRpdmUnKSB7XG4gICAgcmVzb2x2ZWRGb3JtYXRUeXBlID0gJ251bWJlcic7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3RlbXBvcmFsJyB8fCBzY2FsZVR5cGUgPT09ICd0aW1lJyB8fCBzY2FsZVR5cGUgPT09ICd1dGMnKSB7XG4gICAgcmVzb2x2ZWRGb3JtYXRUeXBlID0gJ3RpbWUnO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBmb3JtYXQgIT09ICd1bmRlZmluZWQnICYmIGZvcm1hdC5sZW5ndGggPiAwKSB7XG4gICAgcmVzb2x2ZWRGb3JtYXRUeXBlID0gJ251bWJlcic7XG4gIH1cblxuICBpZiAocmVzb2x2ZWRGb3JtYXRUeXBlID09PSAndGltZScpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZm9ybWF0VHlwZTogJ3RpbWUnLFxuICAgICAgZm9ybWF0SW5Mb2NhbFRpbWU6IGZvcm1hdEluTG9jYWxUaW1lIHx8IHR5cGVvZiBmb3JtYXRJbkxvY2FsVGltZSA9PT0gJ3VuZGVmaW5lZCcgJiYgc2NhbGVUeXBlID09PSAndGltZScsXG4gICAgICBmb3JtYXRcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBmb3JtYXRUeXBlOiByZXNvbHZlZEZvcm1hdFR5cGUsXG4gICAgZm9ybWF0XG4gIH07XG59IiwiaW1wb3J0IHsgaXNYT3JZIH0gZnJvbSAnLi4vdHlwZUd1YXJkcy9DaGFubmVsJztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXBsZXRlTGVnZW5kQ29uZmlnKGNoYW5uZWxUeXBlLCBjaGFubmVsRGVmKSB7XG4gIGlmICgnbGVnZW5kJyBpbiBjaGFubmVsRGVmICYmIGNoYW5uZWxEZWYubGVnZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gY2hhbm5lbERlZi5sZWdlbmQ7XG4gIH1cblxuICByZXR1cm4gaXNYT3JZKGNoYW5uZWxUeXBlKSB8fCBjaGFubmVsVHlwZSA9PT0gJ1RleHQnID8gZmFsc2UgOiB7fTtcbn0iLCJpbXBvcnQgeyBTY2FsZVR5cGUgfSBmcm9tICcuLi90eXBlcyc7XG4vKipcbiAqIFNvbWV0aW1lcyBzY2FsZSB0eXBlIGlzIG5vdCBzcGVjaWZpZWQgYnV0IGNhbiBiZSBpbmZlcnJlZFxuICogZnJvbSBvdGhlciBmaWVsZHMuXG4gKiBTZWUgaHR0cHM6Ly92ZWdhLmdpdGh1Yi5pby92ZWdhLWxpdGUvZG9jcy9zY2FsZS5odG1sXG4gKiBAcGFyYW0gY2hhbm5lbFR5cGUgdHlwZSBvZiB0aGUgY2hhbm5lbFxuICogQHBhcmFtIGZpZWxkVHlwZSB0eXBlIG9mIHRoZSBmaWVsZFxuICogQHBhcmFtIGJpbiBpcyB2YWx1ZSBiaW5uZWRcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbmZlclNjYWxlVHlwZShjaGFubmVsVHlwZSwgZmllbGRUeXBlLCBiaW4gPSBmYWxzZSkge1xuICBpZiAoZmllbGRUeXBlID09PSAnbm9taW5hbCcgfHwgZmllbGRUeXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICBzd2l0Y2ggKGNoYW5uZWxUeXBlKSB7XG4gICAgICAvLyBGb3IgcG9zaXRpb25hbCAoeCBhbmQgeSkgb3JkaW5hbCBhbmQgb3JkaW5hbCBmaWVsZHMsXG4gICAgICAvLyBcInBvaW50XCIgaXMgdGhlIGRlZmF1bHQgc2NhbGUgdHlwZSBmb3IgYWxsIG1hcmtzXG4gICAgICAvLyBleGNlcHQgYmFyIGFuZCByZWN0IG1hcmtzLCB3aGljaCB1c2UgXCJiYW5kXCIgc2NhbGVzLlxuICAgICAgLy8gaHR0cHM6Ly92ZWdhLmdpdGh1Yi5pby92ZWdhLWxpdGUvZG9jcy9zY2FsZS5odG1sXG4gICAgICBjYXNlICdYQmFuZCc6XG4gICAgICBjYXNlICdZQmFuZCc6XG4gICAgICAgIHJldHVybiBTY2FsZVR5cGUuQkFORDtcblxuICAgICAgY2FzZSAnWCc6XG4gICAgICBjYXNlICdZJzpcbiAgICAgIGNhc2UgJ051bWVyaWMnOlxuICAgICAgICByZXR1cm4gU2NhbGVUeXBlLlBPSU5UO1xuXG4gICAgICBjYXNlICdDb2xvcic6XG4gICAgICBjYXNlICdDYXRlZ29yeSc6XG4gICAgICAgIHJldHVybiBTY2FsZVR5cGUuT1JESU5BTDtcblxuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gIH0gZWxzZSBpZiAoZmllbGRUeXBlID09PSAncXVhbnRpdGF0aXZlJykge1xuICAgIHN3aXRjaCAoY2hhbm5lbFR5cGUpIHtcbiAgICAgIGNhc2UgJ1hCYW5kJzpcbiAgICAgIGNhc2UgJ1lCYW5kJzpcbiAgICAgIGNhc2UgJ1gnOlxuICAgICAgY2FzZSAnWSc6XG4gICAgICBjYXNlICdOdW1lcmljJzpcbiAgICAgICAgcmV0dXJuIFNjYWxlVHlwZS5MSU5FQVI7XG5cbiAgICAgIGNhc2UgJ0NvbG9yJzpcbiAgICAgICAgcmV0dXJuIGJpbiA/IFNjYWxlVHlwZS5CSU5fT1JESU5BTCA6IFNjYWxlVHlwZS5MSU5FQVI7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuICB9IGVsc2UgaWYgKGZpZWxkVHlwZSA9PT0gJ3RlbXBvcmFsJykge1xuICAgIHN3aXRjaCAoY2hhbm5lbFR5cGUpIHtcbiAgICAgIGNhc2UgJ1hCYW5kJzpcbiAgICAgIGNhc2UgJ1lCYW5kJzpcbiAgICAgIGNhc2UgJ1gnOlxuICAgICAgY2FzZSAnWSc6XG4gICAgICBjYXNlICdOdW1lcmljJzpcbiAgICAgICAgcmV0dXJuIFNjYWxlVHlwZS5VVEM7XG5cbiAgICAgIGNhc2UgJ0NvbG9yJzpcbiAgICAgICAgcmV0dXJuIFNjYWxlVHlwZS5MSU5FQVI7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn0iLCJpbXBvcnQgeyBTY2FsZVR5cGUgfSBmcm9tICcuLi8uLi90eXBlcyc7XG5pbXBvcnQgeyBhbGxTY2FsZVR5cGVzU2V0LCBhbGxTY2FsZVR5cGVzLCBjb250aW51b3VzRG9tYWluU2NhbGVUeXBlcywgY29udGludW91c1NjYWxlVHlwZXMsIGNvbnRpbnVvdXNTY2FsZVR5cGVzU2V0IH0gZnJvbSAnLi9zY2FsZUNhdGVnb3JpZXMnO1xuY29uc3QgcG9pbnRPckJhbmQgPSBbU2NhbGVUeXBlLlBPSU5ULCBTY2FsZVR5cGUuQkFORF07XG5jb25zdCBwb2ludE9yQmFuZFNldCA9IG5ldyBTZXQocG9pbnRPckJhbmQpO1xuY29uc3QgZXhjZXB0UG9pbnRPckJhbmQgPSBhbGxTY2FsZVR5cGVzLmZpbHRlcih0eXBlID0+ICFwb2ludE9yQmFuZFNldC5oYXModHlwZSkpO1xuY29uc3QgZXhjZXB0UG9pbnRPckJhbmRTZXQgPSBuZXcgU2V0KGV4Y2VwdFBvaW50T3JCYW5kKTtcbmNvbnN0IGNvbnRpbnVvdXNPclBvaW50T3JCYW5kU2V0ID0gbmV3IFNldChjb250aW51b3VzU2NhbGVUeXBlcy5jb25jYXQocG9pbnRPckJhbmQpKTtcbmNvbnN0IHplcm9TZXQgPSBuZXcgU2V0KGNvbnRpbnVvdXNEb21haW5TY2FsZVR5cGVzKTsgLy8gbG9nIHNjYWxlIGNhbm5vdCBoYXZlIHplcm8gdmFsdWVcblxuemVyb1NldC5kZWxldGUoU2NhbGVUeXBlLkxPRyk7IC8vIHplcm8gaXMgbm90IG1lYW5pbmdmdWwgZm9yIHRpbWVcblxuemVyb1NldC5kZWxldGUoU2NhbGVUeXBlLlRJTUUpO1xuemVyb1NldC5kZWxldGUoU2NhbGVUeXBlLlVUQyk7IC8vIHRocmVzaG9sZCByZXF1aXJlcyBjdXN0b20gZG9tYWluIHNvIHplcm8gZG9lcyBub3QgbWF0dGVyXG5cbnplcm9TZXQuZGVsZXRlKFNjYWxlVHlwZS5USFJFU0hPTEQpOyAvLyBxdWFudGlsZSBkZXBlbmRzIG9uIGRpc3RyaWJ1dGlvbiBzbyB6ZXJvIGRvZXMgbm90IG1hdHRlclxuXG56ZXJvU2V0LmRlbGV0ZShTY2FsZVR5cGUuUVVBTlRJTEUpO1xuY29uc3Qgc3VwcG9ydGVkU2NhbGVUeXBlcyA9IHtcbiAgYWxpZ246IHBvaW50T3JCYW5kU2V0LFxuICBiYXNlOiBuZXcgU2V0KFtTY2FsZVR5cGUuTE9HXSksXG4gIGNsYW1wOiBjb250aW51b3VzU2NhbGVUeXBlc1NldCxcbiAgY29uc3RhbnQ6IG5ldyBTZXQoW1NjYWxlVHlwZS5TWU1MT0ddKSxcbiAgZG9tYWluOiBhbGxTY2FsZVR5cGVzU2V0LFxuICBleHBvbmVudDogbmV3IFNldChbU2NhbGVUeXBlLlBPV10pLFxuICBpbnRlcnBvbGF0ZTogZXhjZXB0UG9pbnRPckJhbmRTZXQsXG4gIG5pY2U6IG5ldyBTZXQoY29udGludW91c1NjYWxlVHlwZXMuY29uY2F0KFtTY2FsZVR5cGUuUVVBTlRJWkUsIFNjYWxlVHlwZS5USFJFU0hPTERdKSksXG4gIHBhZGRpbmc6IGNvbnRpbnVvdXNPclBvaW50T3JCYW5kU2V0LFxuICBwYWRkaW5nSW5uZXI6IG5ldyBTZXQoW1NjYWxlVHlwZS5CQU5EXSksXG4gIHBhZGRpbmdPdXRlcjogcG9pbnRPckJhbmRTZXQsXG4gIHJhbmdlOiBhbGxTY2FsZVR5cGVzU2V0LFxuICByZXZlcnNlOiBhbGxTY2FsZVR5cGVzU2V0LFxuICByb3VuZDogY29udGludW91c09yUG9pbnRPckJhbmRTZXQsXG4gIHNjaGVtZTogZXhjZXB0UG9pbnRPckJhbmRTZXQsXG4gIHR5cGU6IGFsbFNjYWxlVHlwZXNTZXQsXG4gIHVua25vd246IG5ldyBTZXQoW1NjYWxlVHlwZS5PUkRJTkFMXSksXG4gIHplcm86IHplcm9TZXRcbn07XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc1Byb3BlcnR5U3VwcG9ydGVkQnlTY2FsZVR5cGUocHJvcGVydHksIHNjYWxlVHlwZSkge1xuICByZXR1cm4gc3VwcG9ydGVkU2NhbGVUeXBlc1twcm9wZXJ0eV0uaGFzKHNjYWxlVHlwZSk7XG59IiwiaW1wb3J0IGlzUHJvcGVydHlTdXBwb3J0ZWRCeVNjYWxlVHlwZSBmcm9tICcuLi9wYXJzZXJzL3NjYWxlL2lzUHJvcGVydHlTdXBwb3J0ZWRCeVNjYWxlVHlwZSc7XG5pbXBvcnQgeyBjb250aW51b3VzU2NhbGVUeXBlc1NldCwgZGlzY3JldGl6aW5nU2NhbGVUeXBlc1NldCwgZGlzY3JldGVTY2FsZVR5cGVzU2V0IH0gZnJvbSAnLi4vcGFyc2Vycy9zY2FsZS9zY2FsZUNhdGVnb3JpZXMnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ29udGludW91c1NjYWxlQ29uZmlnKGNvbmZpZykge1xuICByZXR1cm4gY29udGludW91c1NjYWxlVHlwZXNTZXQuaGFzKGNvbmZpZy50eXBlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0Rpc2NyZXRpemluZ1NjYWxlQ29uZmlnKGNvbmZpZykge1xuICByZXR1cm4gZGlzY3JldGl6aW5nU2NhbGVUeXBlc1NldC5oYXMoY29uZmlnLnR5cGUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzRGlzY3JldGVTY2FsZUNvbmZpZyhjb25maWcpIHtcbiAgcmV0dXJuIGRpc2NyZXRlU2NhbGVUeXBlc1NldC5oYXMoY29uZmlnLnR5cGUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzU2NhbGVDb25maWdXaXRoWmVybyhjb25maWcpIHtcbiAgcmV0dXJuIGlzUHJvcGVydHlTdXBwb3J0ZWRCeVNjYWxlVHlwZSgnemVybycsIGNvbmZpZy50eXBlKTtcbn0iLCJpbXBvcnQgaW5mZXJTY2FsZVR5cGUgZnJvbSAnLi9pbmZlclNjYWxlVHlwZSc7XG5pbXBvcnQgeyBpc1R5cGVkRmllbGREZWYgfSBmcm9tICcuLi90eXBlR3VhcmRzL0NoYW5uZWxEZWYnO1xuaW1wb3J0IHsgaXNDb250aW51b3VzU2NhbGVDb25maWcsIGlzU2NhbGVDb25maWdXaXRoWmVybyB9IGZyb20gJy4uL3R5cGVHdWFyZHMvU2NhbGVDb25maWcnO1xuaW1wb3J0IGlzRW5hYmxlZCBmcm9tICcuLi91dGlscy9pc0VuYWJsZWQnO1xuaW1wb3J0IHsgdGltZVNjYWxlVHlwZXNTZXQgfSBmcm9tICcuLi9wYXJzZXJzL3NjYWxlL3NjYWxlQ2F0ZWdvcmllcyc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wbGV0ZVNjYWxlQ29uZmlnKGNoYW5uZWxUeXBlLCBjaGFubmVsRGVmKSB7XG4gIGlmIChpc1R5cGVkRmllbGREZWYoY2hhbm5lbERlZikgJiYgaXNFbmFibGVkKGNoYW5uZWxEZWYuc2NhbGUpKSB7XG4gICAgY29uc3Qge1xuICAgICAgc2NhbGUgPSB7fSxcbiAgICAgIHR5cGUsXG4gICAgICBiaW5cbiAgICB9ID0gY2hhbm5lbERlZjtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlOiBzY2FsZVR5cGUgPSBpbmZlclNjYWxlVHlwZShjaGFubmVsVHlwZSwgdHlwZSwgYmluKVxuICAgIH0gPSBzY2FsZTtcblxuICAgIGlmICh0eXBlb2Ygc2NhbGVUeXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9jb25zaXN0ZW50LXR5cGUtYXNzZXJ0aW9uc1xuXG5cbiAgICBjb25zdCBmaWxsZWRTY2FsZSA9IHsgLi4uc2NhbGUsXG4gICAgICB0eXBlOiBzY2FsZVR5cGVcbiAgICB9O1xuXG4gICAgaWYgKGlzQ29udGludW91c1NjYWxlQ29uZmlnKGZpbGxlZFNjYWxlKSkge1xuICAgICAgaWYgKHR5cGVvZiBmaWxsZWRTY2FsZS5uaWNlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBmaWxsZWRTY2FsZS5uaWNlID0gIXRpbWVTY2FsZVR5cGVzU2V0LmhhcyhzY2FsZVR5cGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGZpbGxlZFNjYWxlLmNsYW1wID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBmaWxsZWRTY2FsZS5jbGFtcCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzU2NhbGVDb25maWdXaXRoWmVybyhmaWxsZWRTY2FsZSkgJiYgdHlwZW9mIGZpbGxlZFNjYWxlLnplcm8gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBmaWxsZWRTY2FsZS56ZXJvID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmlsbGVkU2NhbGU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59IiwiaW1wb3J0IHsgaXNYT3JZIH0gZnJvbSAnLi4vdHlwZUd1YXJkcy9DaGFubmVsJztcbmNvbnN0IHRlbXBvcmFsRmllbGROYW1lcyA9IG5ldyBTZXQoWyd0aW1lJywgJ2RhdGUnLCAnZGF0ZXRpbWUnLCAndGltZXN0YW1wJ10pO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaW5mZXJGaWVsZFR5cGUoY2hhbm5lbFR5cGUsIGZpZWxkID0gJycpIHtcbiAgaWYgKGlzWE9yWShjaGFubmVsVHlwZSkgfHwgY2hhbm5lbFR5cGUgPT09ICdOdW1lcmljJykge1xuICAgIHJldHVybiB0ZW1wb3JhbEZpZWxkTmFtZXMuaGFzKGZpZWxkLnRvTG93ZXJDYXNlKCkpID8gJ3RlbXBvcmFsJyA6ICdxdWFudGl0YXRpdmUnO1xuICB9XG5cbiAgcmV0dXJuICdub21pbmFsJztcbn0iLCJpbXBvcnQgeyBpc0ZpZWxkRGVmLCBpc1ZhbHVlRGVmLCBpc1R5cGVkRmllbGREZWYgfSBmcm9tICcuLi90eXBlR3VhcmRzL0NoYW5uZWxEZWYnO1xuaW1wb3J0IGNvbXBsZXRlQXhpc0NvbmZpZyBmcm9tICcuL2NvbXBsZXRlQXhpc0NvbmZpZyc7XG5pbXBvcnQgY29tcGxldGVGb3JtYXRDb25maWcgZnJvbSAnLi9jb21wbGV0ZUZvcm1hdENvbmZpZyc7XG5pbXBvcnQgY29tcGxldGVMZWdlbmRDb25maWcgZnJvbSAnLi9jb21wbGV0ZUxlZ2VuZENvbmZpZyc7XG5pbXBvcnQgY29tcGxldGVTY2FsZUNvbmZpZyBmcm9tICcuL2NvbXBsZXRlU2NhbGVDb25maWcnO1xuaW1wb3J0IGluZmVyRmllbGRUeXBlIGZyb20gJy4vaW5mZXJGaWVsZFR5cGUnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcGxldGVDaGFubmVsRGVmKGNoYW5uZWxUeXBlLCBjaGFubmVsRGVmKSB7XG4gIHZhciBfY2hhbm5lbERlZiR0aXRsZTtcblxuICBpZiAoaXNWYWx1ZURlZihjaGFubmVsRGVmKSkge1xuICAgIHJldHVybiB7IC4uLmNoYW5uZWxEZWYsXG4gICAgICBheGlzOiBmYWxzZSxcbiAgICAgIGxlZ2VuZDogZmFsc2UsXG4gICAgICBzY2FsZTogZmFsc2UsXG4gICAgICB0aXRsZTogJydcbiAgICB9O1xuICB9IC8vIEZpbGwgdG9wLWxldmVsIHByb3BlcnRpZXNcblxuXG4gIGNvbnN0IGNvcHkgPSB7IC4uLmNoYW5uZWxEZWYsXG4gICAgdGl0bGU6IGlzRmllbGREZWYoY2hhbm5lbERlZikgPyAoX2NoYW5uZWxEZWYkdGl0bGUgPSBjaGFubmVsRGVmLnRpdGxlKSAhPSBudWxsID8gX2NoYW5uZWxEZWYkdGl0bGUgOiBjaGFubmVsRGVmLmZpZWxkIDogJycsXG4gICAgdHlwZTogaXNUeXBlZEZpZWxkRGVmKGNoYW5uZWxEZWYpID8gY2hhbm5lbERlZi50eXBlIDogaW5mZXJGaWVsZFR5cGUoY2hhbm5lbFR5cGUsIGNoYW5uZWxEZWYuZmllbGQpXG4gIH07IC8vIFNjYWxlIG5lZWRzIHRoZSB0b3AtbGV2ZWwgcHJvcGVydGllcyB0byBiZSBmaWxsZWQuXG5cbiAgY29uc3Qgc2NhbGUgPSBjb21wbGV0ZVNjYWxlQ29uZmlnKGNoYW5uZWxUeXBlLCBjb3B5KTsgLy8gRm9ybWF0IG5lZWRzIHNjYWxlLlxuXG4gIGNvbnN0IGZvcm1hdCA9IGNvbXBsZXRlRm9ybWF0Q29uZmlnKHsgLi4uY2hhbm5lbERlZixcbiAgICBzY2FsZVR5cGU6IHNjYWxlID8gc2NhbGUudHlwZSA6IHVuZGVmaW5lZFxuICB9KTtcbiAgY29uc3QgY29weTIgPSB7IC4uLmNvcHksXG4gICAgLi4uZm9ybWF0LFxuICAgIHNjYWxlXG4gIH07IC8vIFRoZXNlIG5lZWQgc2NhbGUgYW5kIGZvcm1hdFxuXG4gIGNvbnN0IGF4aXMgPSBjb21wbGV0ZUF4aXNDb25maWcoY2hhbm5lbFR5cGUsIGNvcHkyKTtcbiAgY29uc3QgbGVnZW5kID0gY29tcGxldGVMZWdlbmRDb25maWcoY2hhbm5lbFR5cGUsIGNvcHkyKTtcbiAgcmV0dXJuIHsgLi4uY29weTIsXG4gICAgYXhpcyxcbiAgICBsZWdlbmRcbiAgfTtcbn0iLCJpbXBvcnQgeyBzY2FsZUxpbmVhciwgc2NhbGVMb2csIHNjYWxlUG93LCBzY2FsZVNxcnQsIHNjYWxlVGltZSwgc2NhbGVVdGMsIHNjYWxlUXVhbnRpbGUsIHNjYWxlUXVhbnRpemUsIHNjYWxlVGhyZXNob2xkLCBzY2FsZU9yZGluYWwsIHNjYWxlUG9pbnQsIHNjYWxlQmFuZCwgc2NhbGVTeW1sb2cgfSBmcm9tICdkMy1zY2FsZSc7XG5pbXBvcnQgeyBTY2FsZVR5cGUgfSBmcm9tICcuLi8uLi90eXBlcyc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVTY2FsZUZyb21TY2FsZVR5cGUodHlwZSkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFNjYWxlVHlwZS5MSU5FQVI6XG4gICAgICByZXR1cm4gc2NhbGVMaW5lYXIoKTtcblxuICAgIGNhc2UgU2NhbGVUeXBlLkxPRzpcbiAgICAgIHJldHVybiBzY2FsZUxvZygpO1xuXG4gICAgY2FzZSBTY2FsZVR5cGUuUE9XOlxuICAgICAgcmV0dXJuIHNjYWxlUG93KCk7XG5cbiAgICBjYXNlIFNjYWxlVHlwZS5TUVJUOlxuICAgICAgcmV0dXJuIHNjYWxlU3FydCgpO1xuXG4gICAgY2FzZSBTY2FsZVR5cGUuVElNRTpcbiAgICAgIHJldHVybiBzY2FsZVRpbWUoKTtcblxuICAgIGNhc2UgU2NhbGVUeXBlLlVUQzpcbiAgICAgIHJldHVybiBzY2FsZVV0YygpO1xuXG4gICAgY2FzZSBTY2FsZVR5cGUuUVVBTlRJTEU6XG4gICAgICByZXR1cm4gc2NhbGVRdWFudGlsZSgpO1xuXG4gICAgY2FzZSBTY2FsZVR5cGUuUVVBTlRJWkU6XG4gICAgICByZXR1cm4gc2NhbGVRdWFudGl6ZSgpO1xuXG4gICAgY2FzZSBTY2FsZVR5cGUuVEhSRVNIT0xEOlxuICAgICAgcmV0dXJuIHNjYWxlVGhyZXNob2xkKCk7XG5cbiAgICBjYXNlIFNjYWxlVHlwZS5PUkRJTkFMOlxuICAgICAgcmV0dXJuIHNjYWxlT3JkaW5hbCgpO1xuXG4gICAgY2FzZSBTY2FsZVR5cGUuUE9JTlQ6XG4gICAgICByZXR1cm4gc2NhbGVQb2ludCgpO1xuXG4gICAgY2FzZSBTY2FsZVR5cGUuQkFORDpcbiAgICAgIHJldHVybiBzY2FsZUJhbmQoKTtcblxuICAgIGNhc2UgU2NhbGVUeXBlLlNZTUxPRzpcbiAgICAgIHJldHVybiBzY2FsZVN5bWxvZygpO1xuXG4gICAgY2FzZSBTY2FsZVR5cGUuQklOX09SRElOQUw6XG4gICAgICAvLyBUT0RPOiBQZW5kaW5nIHNjYWxlLmJpbnMgaW1wbGVtZW50YXRpb25cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlxcXCJ0eXBlID0gXCIgKyB0eXBlICsgXCJcXFwiIGlzIG5vdCBzdXBwb3J0ZWQgeWV0LlwiKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc2NhbGVMaW5lYXIoKTtcbiAgfVxufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFwcGx5QWxpZ24oY29uZmlnLCBzY2FsZSkge1xuICBpZiAoJ2FsaWduJyBpbiBjb25maWcgJiYgdHlwZW9mIGNvbmZpZy5hbGlnbiAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2FsaWduJyBpbiBzY2FsZSkge1xuICAgIHNjYWxlLmFsaWduKGNvbmZpZy5hbGlnbik7XG4gIH1cbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhcHBseUJhc2UoY29uZmlnLCBzY2FsZSkge1xuICBpZiAoJ2Jhc2UnIGluIGNvbmZpZyAmJiB0eXBlb2YgY29uZmlnLmJhc2UgIT09ICd1bmRlZmluZWQnICYmICdiYXNlJyBpbiBzY2FsZSkge1xuICAgIHNjYWxlLmJhc2UoY29uZmlnLmJhc2UpO1xuICB9XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXBwbHlDbGFtcChjb25maWcsIHNjYWxlKSB7XG4gIGlmICgnY2xhbXAnIGluIGNvbmZpZyAmJiBjb25maWcuY2xhbXAgPT09IHRydWUgJiYgJ2NsYW1wJyBpbiBzY2FsZSkge1xuICAgIHNjYWxlLmNsYW1wKGNvbmZpZy5jbGFtcCk7XG4gIH1cbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhcHBseUV4cG9uZW50KGNvbmZpZywgc2NhbGUpIHtcbiAgaWYgKCdleHBvbmVudCcgaW4gY29uZmlnICYmIHR5cGVvZiBjb25maWcuZXhwb25lbnQgIT09ICd1bmRlZmluZWQnICYmICdleHBvbmVudCcgaW4gc2NhbGUpIHtcbiAgICBzY2FsZS5leHBvbmVudChjb25maWcuZXhwb25lbnQpO1xuICB9XG59IiwiaW1wb3J0IHsgdGltZVNlY29uZCwgdGltZU1pbnV0ZSwgdGltZUhvdXIsIHRpbWVEYXksIHRpbWVZZWFyLCB0aW1lTW9udGgsIHRpbWVXZWVrLCB1dGNTZWNvbmQsIHV0Y01pbnV0ZSwgdXRjSG91ciwgdXRjRGF5LCB1dGNXZWVrLCB1dGNNb250aCwgdXRjWWVhciB9IGZyb20gJ2QzLXRpbWUnO1xuaW1wb3J0IHsgU2NhbGVUeXBlIH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuY29uc3QgbG9jYWxUaW1lSW50ZXJ2YWxzID0ge1xuICBkYXk6IHRpbWVEYXksXG4gIGhvdXI6IHRpbWVIb3VyLFxuICBtaW51dGU6IHRpbWVNaW51dGUsXG4gIG1vbnRoOiB0aW1lTW9udGgsXG4gIHNlY29uZDogdGltZVNlY29uZCxcbiAgd2VlazogdGltZVdlZWssXG4gIHllYXI6IHRpbWVZZWFyXG59O1xuY29uc3QgdXRjSW50ZXJ2YWxzID0ge1xuICBkYXk6IHV0Y0RheSxcbiAgaG91cjogdXRjSG91cixcbiAgbWludXRlOiB1dGNNaW51dGUsXG4gIG1vbnRoOiB1dGNNb250aCxcbiAgc2Vjb25kOiB1dGNTZWNvbmQsXG4gIHdlZWs6IHV0Y1dlZWssXG4gIHllYXI6IHV0Y1llYXJcbn07XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhcHBseU5pY2UoY29uZmlnLCBzY2FsZSkge1xuICBpZiAoJ25pY2UnIGluIGNvbmZpZyAmJiB0eXBlb2YgY29uZmlnLm5pY2UgIT09ICd1bmRlZmluZWQnICYmICduaWNlJyBpbiBzY2FsZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIG5pY2VcbiAgICB9ID0gY29uZmlnO1xuXG4gICAgaWYgKHR5cGVvZiBuaWNlID09PSAnYm9vbGVhbicpIHtcbiAgICAgIGlmIChuaWNlKSB7XG4gICAgICAgIHNjYWxlLm5pY2UoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBuaWNlID09PSAnbnVtYmVyJykge1xuICAgICAgc2NhbGUubmljZShuaWNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdGltZVNjYWxlID0gc2NhbGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHR5cGVcbiAgICAgIH0gPSBjb25maWc7XG5cbiAgICAgIGlmICh0eXBlb2YgbmljZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGltZVNjYWxlLm5pY2UodHlwZSA9PT0gU2NhbGVUeXBlLlVUQyA/IHV0Y0ludGVydmFsc1tuaWNlXSA6IGxvY2FsVGltZUludGVydmFsc1tuaWNlXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaW50ZXJ2YWwsXG4gICAgICAgICAgc3RlcFxuICAgICAgICB9ID0gbmljZTtcbiAgICAgICAgY29uc3QgcGFyc2VkSW50ZXJ2YWwgPSAodHlwZSA9PT0gU2NhbGVUeXBlLlVUQyA/IHV0Y0ludGVydmFsc1tpbnRlcnZhbF0gOiBsb2NhbFRpbWVJbnRlcnZhbHNbaW50ZXJ2YWxdKS5ldmVyeShzdGVwKTtcblxuICAgICAgICBpZiAocGFyc2VkSW50ZXJ2YWwgIT09IG51bGwpIHtcbiAgICAgICAgICB0aW1lU2NhbGUubmljZShwYXJzZWRJbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn0iLCJpbXBvcnQgeyB0aW1lU2NhbGVUeXBlc1NldCwgY29udGludW91c1NjYWxlVHlwZXNTZXQsIGRpc2NyZXRpemluZ1NjYWxlVHlwZXNTZXQsIGRpc2NyZXRlU2NhbGVUeXBlc1NldCB9IGZyb20gJy4uL3BhcnNlcnMvc2NhbGUvc2NhbGVDYXRlZ29yaWVzJztcbmV4cG9ydCBmdW5jdGlvbiBpc0NvbnRpbnVvdXNTY2FsZShzY2FsZSwgc2NhbGVUeXBlKSB7XG4gIHJldHVybiBzY2FsZSAmJiBjb250aW51b3VzU2NhbGVUeXBlc1NldC5oYXMoc2NhbGVUeXBlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0Rpc2NyZXRpemluZ1NjYWxlKHNjYWxlLCBzY2FsZVR5cGUpIHtcbiAgcmV0dXJuIHNjYWxlICYmIGRpc2NyZXRpemluZ1NjYWxlVHlwZXNTZXQuaGFzKHNjYWxlVHlwZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNEaXNjcmV0ZVNjYWxlKHNjYWxlLCBzY2FsZVR5cGUpIHtcbiAgcmV0dXJuIHNjYWxlICYmIGRpc2NyZXRlU2NhbGVUeXBlc1NldC5oYXMoc2NhbGVUeXBlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1RpbWVTY2FsZShzY2FsZSwgc2NhbGVUeXBlKSB7XG4gIHJldHVybiBzY2FsZSAmJiB0aW1lU2NhbGVUeXBlc1NldC5oYXMoc2NhbGVUeXBlKTtcbn0iLCJpbXBvcnQgeyBpc0NvbnRpbnVvdXNTY2FsZSB9IGZyb20gJy4uLy4uL3R5cGVHdWFyZHMvU2NhbGUnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXBwbHlaZXJvKGNvbmZpZywgc2NhbGUpIHtcbiAgaWYgKCd6ZXJvJyBpbiBjb25maWcgJiYgY29uZmlnLnplcm8gPT09IHRydWUgJiYgaXNDb250aW51b3VzU2NhbGUoc2NhbGUsIGNvbmZpZy50eXBlKSkge1xuICAgIGNvbnN0IGRvbWFpbiA9IHNjYWxlLmRvbWFpbigpO1xuICAgIGNvbnN0IFthLCBiXSA9IGRvbWFpbjtcbiAgICBjb25zdCBpc0Rlc2NlbmRpbmcgPSBiIDwgYTtcbiAgICBjb25zdCBbbWluLCBtYXhdID0gaXNEZXNjZW5kaW5nID8gW2IsIGFdIDogW2EsIGJdO1xuICAgIGNvbnN0IGRvbWFpbldpdGhaZXJvID0gW01hdGgubWluKDAsIG1pbiksIE1hdGgubWF4KDAsIG1heCldO1xuICAgIHNjYWxlLmRvbWFpbihpc0Rlc2NlbmRpbmcgPyBkb21haW5XaXRoWmVyby5yZXZlcnNlKCkgOiBkb21haW5XaXRoWmVybyk7XG4gIH1cbn0iLCJpbXBvcnQgeyBpbnRlcnBvbGF0ZVJnYiwgaW50ZXJwb2xhdGVMYWIsIGludGVycG9sYXRlSGNsLCBpbnRlcnBvbGF0ZUhjbExvbmcsIGludGVycG9sYXRlSHNsLCBpbnRlcnBvbGF0ZUhzbExvbmcsIGludGVycG9sYXRlQ3ViZWhlbGl4LCBpbnRlcnBvbGF0ZUN1YmVoZWxpeExvbmcgfSBmcm9tICdkMy1pbnRlcnBvbGF0ZSc7XG5jb25zdCBpbnRlcnBvbGF0b3JNYXAgPSB7XG4gIGxhYjogaW50ZXJwb2xhdGVMYWIsXG4gIGhjbDogaW50ZXJwb2xhdGVIY2wsXG4gICdoY2wtbG9uZyc6IGludGVycG9sYXRlSGNsTG9uZyxcbiAgaHNsOiBpbnRlcnBvbGF0ZUhzbCxcbiAgJ2hzbC1sb25nJzogaW50ZXJwb2xhdGVIc2xMb25nLFxuICBjdWJlaGVsaXg6IGludGVycG9sYXRlQ3ViZWhlbGl4LFxuICAnY3ViZWhlbGl4LWxvbmcnOiBpbnRlcnBvbGF0ZUN1YmVoZWxpeExvbmcsXG4gIHJnYjogaW50ZXJwb2xhdGVSZ2Jcbn07XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVDb2xvckludGVycG9sYXRvcihpbnRlcnBvbGF0ZSkge1xuICBzd2l0Y2ggKGludGVycG9sYXRlKSB7XG4gICAgY2FzZSAnbGFiJzpcbiAgICBjYXNlICdoY2wnOlxuICAgIGNhc2UgJ2hjbC1sb25nJzpcbiAgICBjYXNlICdoc2wnOlxuICAgIGNhc2UgJ2hzbC1sb25nJzpcbiAgICBjYXNlICdjdWJlaGVsaXgnOlxuICAgIGNhc2UgJ2N1YmVoZWxpeC1sb25nJzpcbiAgICBjYXNlICdyZ2InOlxuICAgICAgcmV0dXJuIGludGVycG9sYXRvck1hcFtpbnRlcnBvbGF0ZV07XG5cbiAgICBkZWZhdWx0OlxuICB9XG5cbiAgY29uc3Qge1xuICAgIHR5cGUsXG4gICAgZ2FtbWFcbiAgfSA9IGludGVycG9sYXRlO1xuICBjb25zdCBpbnRlcnBvbGF0b3IgPSBpbnRlcnBvbGF0b3JNYXBbdHlwZV07XG4gIHJldHVybiB0eXBlb2YgZ2FtbWEgPT09ICd1bmRlZmluZWQnID8gaW50ZXJwb2xhdG9yIDogaW50ZXJwb2xhdG9yLmdhbW1hKGdhbW1hKTtcbn0iLCJpbXBvcnQgY3JlYXRlQ29sb3JJbnRlcnBvbGF0b3IgZnJvbSAnLi9jcmVhdGVDb2xvckludGVycG9sYXRvcic7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhcHBseUludGVycG9sYXRlKGNvbmZpZywgc2NhbGUpIHtcbiAgaWYgKCdpbnRlcnBvbGF0ZScgaW4gY29uZmlnICYmIHR5cGVvZiBjb25maWcuaW50ZXJwb2xhdGUgIT09ICd1bmRlZmluZWQnICYmICdpbnRlcnBvbGF0ZScgaW4gc2NhbGUpIHtcbiAgICBzY2FsZS5pbnRlcnBvbGF0ZShjcmVhdGVDb2xvckludGVycG9sYXRvcihjb25maWcuaW50ZXJwb2xhdGUpKTtcbiAgfVxufSIsImltcG9ydCB7IGludGVycG9sYXRlUm91bmQgfSBmcm9tICdkMy1pbnRlcnBvbGF0ZSc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhcHBseVJvdW5kKGNvbmZpZywgc2NhbGUpIHtcbiAgaWYgKCdyb3VuZCcgaW4gY29uZmlnICYmIGNvbmZpZy5yb3VuZCA9PT0gdHJ1ZSkge1xuICAgIGNvbnN0IHJvdW5kYWJsZVNjYWxlID0gc2NhbGU7XG5cbiAgICBpZiAoJ3JvdW5kJyBpbiByb3VuZGFibGVTY2FsZSkge1xuICAgICAgcm91bmRhYmxlU2NhbGUucm91bmQoY29uZmlnLnJvdW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm91bmRhYmxlU2NhbGUuaW50ZXJwb2xhdGUoaW50ZXJwb2xhdGVSb3VuZCk7XG4gICAgfVxuICB9XG59IiwiaW1wb3J0IHsgdGltZVNjYWxlVHlwZXNTZXQgfSBmcm9tICcuLi9zY2FsZS9zY2FsZUNhdGVnb3JpZXMnO1xuLyoqXG4gKiBDb252ZXJ0IGVhY2ggZWxlbWVudCBpbiB0aGUgYXJyYXkgaW50b1xuICogLSBEYXRlIChmb3IgdGltZSBzY2FsZXMpXG4gKiAtIG51bWJlciAoZm9yIG90aGVyIGNvbnRpbnVvdXMgc2NhbGVzKVxuICogQHBhcmFtIGRvbWFpblxuICogQHBhcmFtIHNjYWxlVHlwZVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHBhcnNlQ29udGludW91c0RvbWFpbihkb21haW4sIHNjYWxlVHlwZSkge1xuICBpZiAodGltZVNjYWxlVHlwZXNTZXQuaGFzKHNjYWxlVHlwZSkpIHtcbiAgICByZXR1cm4gZG9tYWluLmZpbHRlcihkID0+IHR5cGVvZiBkICE9PSAnYm9vbGVhbicpLm1hcChkID0+IHR5cGVvZiBkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgZCA9PT0gJ251bWJlcicgPyBuZXcgRGF0ZShkKSA6IGQpO1xuICB9XG5cbiAgcmV0dXJuIGRvbWFpbi5tYXAoZCA9PiB0eXBlb2YgZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGQgPT09ICdib29sZWFuJyA/IE51bWJlcihkKSA6IGQpO1xufSIsIi8qKlxuICogRGlzY3JldGUgZG9tYWlucyBhcmUgY29udmVydGVkIGludG8gc3RyaW5nW11cbiAqIHdoZW4gdXNpbmcgRDMgc2NhbGVzXG4gKiBAcGFyYW0gZG9tYWluXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHBhcnNlRGlzY3JldGVEb21haW4oZG9tYWluKSB7XG4gIHJldHVybiBkb21haW4ubWFwKGQgPT4gXCJcIiArIGQpO1xufSIsIi8qKlxuICogQ29tYmluZSB0d28gYXJyYXlzIGludG8gYSB1bmlxdWUgbGlzdFxuICogYnkga2VlcGluZyB0aGUgb3JkZXIgdGhlIGZpeGVkQ2F0ZWdvcmllc1xuICogYW5kIGFwcGVuZCBuZXcgY2F0ZWdvcmllcyBhdCB0aGUgZW5kLlxuICogQHBhcmFtIGZpeGVkQ2F0ZWdvcmllc1xuICogQHBhcmFtIGlucHV0Q2F0ZWdvcmllc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21iaW5lQ2F0ZWdvcmllcyhmaXhlZENhdGVnb3JpZXMsIGlucHV0Q2F0ZWdvcmllcyA9IFtdKSB7XG4gIGlmIChmaXhlZENhdGVnb3JpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGlucHV0Q2F0ZWdvcmllcztcbiAgfVxuXG4gIGNvbnN0IGZpeGVkU2V0ID0gbmV3IFNldChmaXhlZENhdGVnb3JpZXMpO1xuICByZXR1cm4gZml4ZWRDYXRlZ29yaWVzLmNvbmNhdChpbnB1dENhdGVnb3JpZXMuZmlsdGVyKGQgPT4gIWZpeGVkU2V0LmhhcyhkKSkpO1xufSIsImltcG9ydCB7IGlzRXZlcnlFbGVtZW50RGVmaW5lZCwgaXNEZWZpbmVkIH0gZnJvbSAnLi4vdHlwZUd1YXJkcy9CYXNlJztcbi8qKlxuICogQ29tYmluZSB0d28gY29udGludW91cyBkb21haW4gYW5kIGVuc3VyZSB0aGF0IHRoZSBvdXRwdXRcbiAqIGRvZXMgbm90IGdvIGJleW9uZCBmaXhlZERvbWFpblxuICogQHBhcmFtIGJvdW5kc1xuICogQHBhcmFtIGRhdGFEb21haW5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21iaW5lQ29udGludW91c0RvbWFpbnMoYm91bmRzLCBkYXRhRG9tYWluKSB7XG4gIGlmIChib3VuZHMubGVuZ3RoID4gMCAmJiBpc0V2ZXJ5RWxlbWVudERlZmluZWQoYm91bmRzKSkge1xuICAgIHJldHVybiBib3VuZHM7XG4gIH1cblxuICBpZiAoYm91bmRzLmxlbmd0aCA9PT0gMiAmJiBkYXRhRG9tYWluLmxlbmd0aCA9PT0gMiAmJiBib3VuZHMuZmlsdGVyKGlzRGVmaW5lZCkubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IFtib3VuZE1pbiwgYm91bmRNYXhdID0gYm91bmRzO1xuICAgIGNvbnN0IFtkYXRhTWluLCBkYXRhTWF4XSA9IGRhdGFEb21haW47XG4gICAgbGV0IG1pbiA9IGRhdGFNaW47XG5cbiAgICBpZiAoaXNEZWZpbmVkKGJvdW5kTWluKSkge1xuICAgICAgbWluID0gYm91bmRNaW4udmFsdWVPZigpID4gZGF0YU1pbi52YWx1ZU9mKCkgPyBib3VuZE1pbiA6IGRhdGFNaW47XG4gICAgfVxuXG4gICAgbGV0IG1heCA9IGRhdGFNYXg7XG5cbiAgICBpZiAoaXNEZWZpbmVkKGJvdW5kTWF4KSkge1xuICAgICAgbWF4ID0gYm91bmRNYXgudmFsdWVPZigpIDwgZGF0YU1heC52YWx1ZU9mKCkgPyBib3VuZE1heCA6IGRhdGFNYXg7XG4gICAgfVxuXG4gICAgcmV0dXJuIFttaW4sIG1heF07XG4gIH1cblxuICByZXR1cm4gZGF0YURvbWFpbjtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZW1vdmVVbmRlZmluZWRBbmROdWxsKGFycmF5KSB7XG4gIHJldHVybiBhcnJheS5maWx0ZXIoeCA9PiB0eXBlb2YgeCAhPT0gJ3VuZGVmaW5lZCcgJiYgeCAhPT0gbnVsbCk7XG59IiwiaW1wb3J0IHsgaXNEYXRlVGltZSB9IGZyb20gJy4uL3R5cGVHdWFyZHMvRGF0ZVRpbWUnO1xuaW1wb3J0IHBhcnNlRGF0ZVRpbWUgZnJvbSAnLi9wYXJzZURhdGVUaW1lJztcbi8qKlxuICogT25seSBwYXJzZSBlbGVtZW50cyB0aGF0IGFyZSBEYXRlVGltZSB0byBEYXRlLlxuICogTGVhdmUgdGhlIHJlc3QgYWxvbmUuXG4gKiBAcGFyYW0gYXJyYXlcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwYXJzZURhdGVUaW1lSW4oYXJyYXkpIHtcbiAgcmV0dXJuIGFycmF5Lm1hcChkID0+ICEoZCBpbnN0YW5jZW9mIERhdGUpICYmIGlzRGF0ZVRpbWUoZCkgPyBwYXJzZURhdGVUaW1lKGQpIDogZCk7XG59IiwiaW1wb3J0IHsgaXNDb250aW51b3VzU2NhbGUsIGlzRGlzY3JldGl6aW5nU2NhbGUsIGlzRGlzY3JldGVTY2FsZSB9IGZyb20gJy4uLy4uL3R5cGVHdWFyZHMvU2NhbGUnO1xuaW1wb3J0IHsgaXNDb250aW51b3VzU2NhbGVDb25maWcsIGlzRGlzY3JldGl6aW5nU2NhbGVDb25maWcsIGlzRGlzY3JldGVTY2FsZUNvbmZpZyB9IGZyb20gJy4uLy4uL3R5cGVHdWFyZHMvU2NhbGVDb25maWcnO1xuaW1wb3J0IHBhcnNlQ29udGludW91c0RvbWFpbiBmcm9tICcuLi9kb21haW4vcGFyc2VDb250aW51b3VzRG9tYWluJztcbmltcG9ydCBwYXJzZURpc2NyZXRlRG9tYWluIGZyb20gJy4uL2RvbWFpbi9wYXJzZURpc2NyZXRlRG9tYWluJztcbmltcG9ydCBjb21iaW5lQ2F0ZWdvcmllcyBmcm9tICcuLi8uLi91dGlscy9jb21iaW5lQ2F0ZWdvcmllcyc7XG5pbXBvcnQgY29tYmluZUNvbnRpbnVvdXNEb21haW5zIGZyb20gJy4uLy4uL3V0aWxzL2NvbWJpbmVDb250aW51b3VzRG9tYWlucyc7XG5pbXBvcnQgcmVtb3ZlVW5kZWZpbmVkQW5kTnVsbCBmcm9tICcuLi8uLi91dGlscy9yZW1vdmVVbmRlZmluZWRBbmROdWxsJztcbmltcG9ydCBwYXJzZURhdGVUaW1lSW4gZnJvbSAnLi4vcGFyc2VEYXRlVGltZUluJztcblxuZnVuY3Rpb24gY3JlYXRlT3JkZXJGdW5jdGlvbihyZXZlcnNlKSB7XG4gIHJldHVybiByZXZlcnNlID8gYXJyYXkgPT4gYXJyYXkuY29uY2F0KCkucmV2ZXJzZSgpIDogYXJyYXkgPT4gYXJyYXk7XG59XG5cbmZ1bmN0aW9uIGlzQ29tcGxldGVEb21haW4oZG9tYWluKSB7XG4gIHJldHVybiBkb21haW4ubGVuZ3RoICE9PSAyIHx8IGRvbWFpblswXSAhPSBudWxsICYmIGRvbWFpblsxXSAhPSBudWxsO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhcHBseURvbWFpbihjb25maWcsIHNjYWxlLFxuLyoqIGRvbWFpbiBmcm9tIGRhdGFzZXQgKi9cbmRhdGFEb21haW4pIHtcbiAgY29uc3Qge1xuICAgIHJldmVyc2UsXG4gICAgdHlwZVxuICB9ID0gY29uZmlnO1xuICBjb25zdCBvcmRlciA9IGNyZWF0ZU9yZGVyRnVuY3Rpb24ocmV2ZXJzZSk7XG5cbiAgaWYgKGlzQ29udGludW91c1NjYWxlKHNjYWxlLCB0eXBlKSAmJiBpc0NvbnRpbnVvdXNTY2FsZUNvbmZpZyhjb25maWcpIHx8IGlzRGlzY3JldGl6aW5nU2NhbGUoc2NhbGUsIHR5cGUpICYmIGlzRGlzY3JldGl6aW5nU2NhbGVDb25maWcoY29uZmlnKSkge1xuICAgIC8vIEZvciBjb250aW51b3VzIGFuZCBkaXNjcmV0aXppbmcgc2NhbGVzXG4gICAgaWYgKGNvbmZpZy5kb21haW4pIHtcbiAgICAgIC8vIElmIGNvbmZpZy5kb21haW4gaXMgc3BlY2lmaWVkXG4gICAgICBpZiAoaXNDb21wbGV0ZURvbWFpbihjb25maWcuZG9tYWluKSkge1xuICAgICAgICAvLyBJZiB0aGUgY29uZmlnLmRvbWFpbiBpcyBjb21wbGV0ZWRcbiAgICAgICAgLy8gaWdub3JlcyB0aGUgZGF0YURvbWFpblxuICAgICAgICBzY2FsZS5kb21haW4ob3JkZXIocGFyc2VEYXRlVGltZUluKGNvbmZpZy5kb21haW4pKSk7XG4gICAgICB9IGVsc2UgaWYgKGRhdGFEb21haW4pIHtcbiAgICAgICAgLy8gSWYgaXQgaXMgaW5jb21wbGV0ZWQsIHRoZW4gdHJ5IHRvIGNvbWJpbmVcbiAgICAgICAgLy8gd2l0aCB0aGUgZGF0YURvbWFpblxuICAgICAgICBzY2FsZS5kb21haW4ob3JkZXIoY29tYmluZUNvbnRpbnVvdXNEb21haW5zKHBhcnNlQ29udGludW91c0RvbWFpbihwYXJzZURhdGVUaW1lSW4oY29uZmlnLmRvbWFpbiksIHR5cGUpLCBwYXJzZUNvbnRpbnVvdXNEb21haW4ocmVtb3ZlVW5kZWZpbmVkQW5kTnVsbChkYXRhRG9tYWluKSwgdHlwZSkpKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkYXRhRG9tYWluKSB7XG4gICAgICAvLyBJZiBubyBjb25maWcuZG9tYWluIHRoZW4ganVzdCB1c2UgdGhlIGRhdGFEb21haW4gaWYgYW55XG4gICAgICBzY2FsZS5kb21haW4ob3JkZXIocGFyc2VDb250aW51b3VzRG9tYWluKHJlbW92ZVVuZGVmaW5lZEFuZE51bGwoZGF0YURvbWFpbiksIHR5cGUpKSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRGlzY3JldGVTY2FsZShzY2FsZSwgdHlwZSkgJiYgaXNEaXNjcmV0ZVNjYWxlQ29uZmlnKGNvbmZpZykpIHtcbiAgICAvLyBGb3IgZGlzY3JldGUgc2NhbGVzXG4gICAgaWYgKGNvbmZpZy5kb21haW4pIHtcbiAgICAgIGNvbnN0IGZpeGVkRG9tYWluID0gcGFyc2VEaXNjcmV0ZURvbWFpbihwYXJzZURhdGVUaW1lSW4oY29uZmlnLmRvbWFpbikpO1xuICAgICAgc2NhbGUuZG9tYWluKG9yZGVyKGRhdGFEb21haW4gPyBjb21iaW5lQ2F0ZWdvcmllcyhmaXhlZERvbWFpbiwgcGFyc2VEaXNjcmV0ZURvbWFpbihkYXRhRG9tYWluKSkgOiBmaXhlZERvbWFpbikpO1xuICAgIH0gZWxzZSBpZiAoZGF0YURvbWFpbikge1xuICAgICAgLy8gSWYgbm8gY29uZmlnLmRvbWFpbiB0aGVuIGp1c3QgdXNlIHRoZSBkYXRhRG9tYWluIGlmIGFueVxuICAgICAgc2NhbGUuZG9tYWluKG9yZGVyKHBhcnNlRGlzY3JldGVEb21haW4oZGF0YURvbWFpbikpKTtcbiAgICB9XG4gIH1cbn0iLCIvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L3ByZWZlci1kZWZhdWx0LWV4cG9ydFxuZXhwb3J0IGZ1bmN0aW9uIGlzU2NoZW1lUGFyYW1zKHNjaGVtZSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHNjaGVtZSkgIT09ICdbb2JqZWN0IFN0cmluZ10nO1xufSIsImltcG9ydCB7IHdyYXBDb2xvclNjaGVtZSB9IGZyb20gJ0BlbmNvZGFibGUvY29sb3InO1xuaW1wb3J0IEVuY29kYWJsZSBmcm9tICcuLi8uLi9vcHRpb25zL0VuY29kYWJsZSc7XG5pbXBvcnQgeyBpc0NvbnRpbnVvdXNTY2FsZUNvbmZpZyB9IGZyb20gJy4uLy4uL3R5cGVHdWFyZHMvU2NhbGVDb25maWcnO1xuaW1wb3J0IHsgaXNTY2hlbWVQYXJhbXMgfSBmcm9tICcuLi8uLi90eXBlR3VhcmRzL1NjaGVtZVBhcmFtcyc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhcHBseVJhbmdlKGNvbmZpZywgc2NhbGUpIHtcbiAgY29uc3Qge1xuICAgIHJhbmdlLFxuICAgIGRvbWFpblxuICB9ID0gY29uZmlnO1xuXG4gIGlmICh0eXBlb2YgcmFuZ2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKCdzY2hlbWUnIGluIGNvbmZpZyAmJiB0eXBlb2YgY29uZmlnLnNjaGVtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2NoZW1lXG4gICAgICB9ID0gY29uZmlnO1xuICAgICAgbGV0IG5hbWU7XG4gICAgICBsZXQgY291bnQ7XG5cbiAgICAgIGlmIChpc0NvbnRpbnVvdXNTY2FsZUNvbmZpZyhjb25maWcpICYmIGRvbWFpbikge1xuICAgICAgICBjb3VudCA9IGRvbWFpbi5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGxldCBleHRlbnQ7XG5cbiAgICAgIGlmIChpc1NjaGVtZVBhcmFtcyhzY2hlbWUpKSB7XG4gICAgICAgIG5hbWUgPSBzY2hlbWUubmFtZTtcblxuICAgICAgICBpZiAoc2NoZW1lLmNvdW50KSB7XG4gICAgICAgICAgY291bnQgPSBzY2hlbWUuY291bnQ7XG4gICAgICAgIH1cblxuICAgICAgICBleHRlbnQgPSBzY2hlbWUuZXh0ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmFtZSA9IHNjaGVtZTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2NoZW1lT2JqZWN0ID0gRW5jb2RhYmxlLnJlc29sdmVDb2xvclNjaGVtZSh7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHR5cGU6ICdzZXF1ZW50aWFsJ1xuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2Ygc2NoZW1lT2JqZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBzY2hlbWVPYmplY3QudHlwZSA9PT0gJ3NlcXVlbnRpYWwnKSB7XG4gICAgICAgIGNvbnN0IHdyYXBwZWRTY2hlbWUgPSB3cmFwQ29sb3JTY2hlbWUoc2NoZW1lT2JqZWN0KTtcbiAgICAgICAgc2NhbGUucmFuZ2Uod3JhcHBlZFNjaGVtZS5nZXRDb2xvcnMoY291bnQsIGV4dGVudCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBUT0RPOiBhZGQgdHlwZSBndWFyZCBzaG91bGQgZml4IHRoaXMgcHJvYmxlbVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBzY2FsZS5yYW5nZShyYW5nZSk7XG4gIH1cbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhcHBseVBhZGRpbmcoY29uZmlnLCBzY2FsZSkge1xuICBpZiAoJ3BhZGRpbmcnIGluIGNvbmZpZyAmJiB0eXBlb2YgY29uZmlnLnBhZGRpbmcgIT09ICd1bmRlZmluZWQnICYmICdwYWRkaW5nJyBpbiBzY2FsZSkge1xuICAgIHNjYWxlLnBhZGRpbmcoY29uZmlnLnBhZGRpbmcpO1xuICB9XG5cbiAgaWYgKCdwYWRkaW5nSW5uZXInIGluIGNvbmZpZyAmJiB0eXBlb2YgY29uZmlnLnBhZGRpbmdJbm5lciAhPT0gJ3VuZGVmaW5lZCcgJiYgJ3BhZGRpbmdJbm5lcicgaW4gc2NhbGUpIHtcbiAgICBzY2FsZS5wYWRkaW5nSW5uZXIoY29uZmlnLnBhZGRpbmdJbm5lcik7XG4gIH1cblxuICBpZiAoJ3BhZGRpbmdPdXRlcicgaW4gY29uZmlnICYmIHR5cGVvZiBjb25maWcucGFkZGluZ091dGVyICE9PSAndW5kZWZpbmVkJyAmJiAncGFkZGluZ091dGVyJyBpbiBzY2FsZSkge1xuICAgIHNjYWxlLnBhZGRpbmdPdXRlcihjb25maWcucGFkZGluZ091dGVyKTtcbiAgfVxufSIsImltcG9ydCBhcHBseUFsaWduIGZyb20gJy4vYXBwbHlBbGlnbic7XG5pbXBvcnQgYXBwbHlCYXNlIGZyb20gJy4vYXBwbHlCYXNlJztcbmltcG9ydCBhcHBseUNsYW1wIGZyb20gJy4vYXBwbHlDbGFtcCc7XG5pbXBvcnQgYXBwbHlFeHBvbmVudCBmcm9tICcuL2FwcGx5RXhwb25lbnQnO1xuaW1wb3J0IGFwcGx5TmljZSBmcm9tICcuL2FwcGx5TmljZSc7XG5pbXBvcnQgYXBwbHlaZXJvIGZyb20gJy4vYXBwbHlaZXJvJztcbmltcG9ydCBhcHBseUludGVycG9sYXRlIGZyb20gJy4vYXBwbHlJbnRlcnBvbGF0ZSc7XG5pbXBvcnQgYXBwbHlSb3VuZCBmcm9tICcuL2FwcGx5Um91bmQnO1xuaW1wb3J0IGFwcGx5RG9tYWluIGZyb20gJy4vYXBwbHlEb21haW4nO1xuaW1wb3J0IGFwcGx5UmFuZ2UgZnJvbSAnLi9hcHBseVJhbmdlJztcbmltcG9ydCBhcHBseVBhZGRpbmcgZnJvbSAnLi9hcHBseVBhZGRpbmcnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXBkYXRlU2NhbGUoc2NhbGUsIGNvbmZpZykge1xuICAvLyBkb21haW4gYW5kIHJhbmdlIGFwcGx5IHRvIGFsbCBzY2FsZXNcbiAgYXBwbHlEb21haW4oY29uZmlnLCBzY2FsZSk7XG4gIGFwcGx5UmFuZ2UoY29uZmlnLCBzY2FsZSk7IC8vIFNvcnQgb3RoZXIgcHJvcGVydGllcyBhbHBoYWJldGljYWxseS5cblxuICBhcHBseUFsaWduKGNvbmZpZywgc2NhbGUpO1xuICBhcHBseUJhc2UoY29uZmlnLCBzY2FsZSk7XG4gIGFwcGx5Q2xhbXAoY29uZmlnLCBzY2FsZSk7XG4gIGFwcGx5RXhwb25lbnQoY29uZmlnLCBzY2FsZSk7XG4gIGFwcGx5SW50ZXJwb2xhdGUoY29uZmlnLCBzY2FsZSk7IC8vIE5pY2UgZGVwZW5kcyBvbiBkb21haW4uXG5cbiAgYXBwbHlOaWNlKGNvbmZpZywgc2NhbGUpO1xuICBhcHBseVBhZGRpbmcoY29uZmlnLCBzY2FsZSk7XG4gIGFwcGx5Um91bmQoY29uZmlnLCBzY2FsZSk7IC8vIFplcm8gZGVwZW5kcyBvbiBkb21haW4gYW5kIG5pY2UuXG5cbiAgYXBwbHlaZXJvKGNvbmZpZywgc2NhbGUpO1xuICByZXR1cm4gc2NhbGU7XG59IiwiaW1wb3J0IHsgU2NhbGVUeXBlIH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuaW1wb3J0IGNyZWF0ZVNjYWxlRnJvbVNjYWxlVHlwZSBmcm9tICcuL2NyZWF0ZVNjYWxlRnJvbVNjYWxlVHlwZSc7XG5pbXBvcnQgdXBkYXRlU2NhbGUgZnJvbSAnLi91cGRhdGVTY2FsZSc7XG5pbXBvcnQgRW5jb2RhYmxlIGZyb20gJy4uLy4uL29wdGlvbnMvRW5jb2RhYmxlJztcbmltcG9ydCB7IGlzU2NoZW1lUGFyYW1zIH0gZnJvbSAnLi4vLi4vdHlwZUd1YXJkcy9TY2hlbWVQYXJhbXMnO1xuaW1wb3J0IGFwcGx5RG9tYWluIGZyb20gJy4vYXBwbHlEb21haW4nO1xuXG5mdW5jdGlvbiBjcmVhdGVTY2FsZShjb25maWcpIHtcbiAgY29uc3Qge1xuICAgIHJhbmdlXG4gIH0gPSBjb25maWc7IC8vIEhhbmRsZSBjYXRlZ29yaWNhbCBjb2xvciBzY2FsZXNcbiAgLy8gQW4gb3JkaW5hbCBzY2FsZSB3aXRob3V0IHNwZWNpZmllZCByYW5nZVxuICAvLyBpcyBhc3N1bWVkIHRvIGJlIGEgY29sb3Igc2NhbGUuXG5cbiAgaWYgKGNvbmZpZy50eXBlID09PSBTY2FsZVR5cGUuT1JESU5BTCAmJiB0eXBlb2YgcmFuZ2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc3Qgc2NoZW1lID0gJ3NjaGVtZScgaW4gY29uZmlnID8gY29uZmlnLnNjaGVtZSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCByZXNvbHZlID0gRW5jb2RhYmxlLmdldENhdGVnb3JpY2FsQ29sb3JTY2FsZVJlc29sdmVyKCk7XG4gICAgbGV0IGNvbG9yU2NhbGU7XG5cbiAgICBpZiAodHlwZW9mIHNjaGVtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbG9yU2NhbGUgPSByZXNvbHZlKHt9KTtcbiAgICB9IGVsc2UgaWYgKGlzU2NoZW1lUGFyYW1zKHNjaGVtZSkpIHtcbiAgICAgIGNvbG9yU2NhbGUgPSByZXNvbHZlKHNjaGVtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbG9yU2NhbGUgPSByZXNvbHZlKHtcbiAgICAgICAgbmFtZTogc2NoZW1lXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBjYXN0ZWRDb2xvclNjYWxlID0gY29sb3JTY2FsZTtcbiAgICBhcHBseURvbWFpbihjb25maWcsIGNhc3RlZENvbG9yU2NhbGUpO1xuICAgIHJldHVybiBjYXN0ZWRDb2xvclNjYWxlO1xuICB9XG5cbiAgY29uc3Qgc2NhbGUgPSBjcmVhdGVTY2FsZUZyb21TY2FsZVR5cGUoY29uZmlnLnR5cGUpO1xuICByZXR1cm4gdXBkYXRlU2NhbGUoc2NhbGUsIGNvbmZpZyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZVNjYWxlOyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlkZW50aXR5KHgpIHtcbiAgcmV0dXJuIHg7XG59IiwiZXhwb3J0IGZ1bmN0aW9uIGlzQ29tcGxldGVWYWx1ZURlZihkZWYpIHtcbiAgcmV0dXJuICd2YWx1ZScgaW4gZGVmO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQ29tcGxldGVGaWVsZERlZihkZWYpIHtcbiAgcmV0dXJuICdmaWVsZCcgaW4gZGVmO1xufSIsImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmltcG9ydCB7IGV4dGVudCBhcyBkM0V4dGVudCB9IGZyb20gJ2QzLWFycmF5JztcbmltcG9ydCB7IFNjYWxlVHlwZSB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGlzVHlwZWRGaWVsZERlZiwgaXNWYWx1ZURlZiwgaXNGaWVsZERlZiB9IGZyb20gJy4uL3R5cGVHdWFyZHMvQ2hhbm5lbERlZic7XG5pbXBvcnQgeyBpc1gsIGlzWSwgaXNYT3JZIH0gZnJvbSAnLi4vdHlwZUd1YXJkcy9DaGFubmVsJztcbmltcG9ydCBDaGFubmVsRW5jb2RlckF4aXMgZnJvbSAnLi9DaGFubmVsRW5jb2RlckF4aXMnO1xuaW1wb3J0IGNyZWF0ZUdldHRlckZyb21DaGFubmVsRGVmIGZyb20gJy4uL3BhcnNlcnMvY3JlYXRlR2V0dGVyRnJvbUNoYW5uZWxEZWYnO1xuaW1wb3J0IGNvbXBsZXRlQ2hhbm5lbERlZiBmcm9tICcuLi9maWxsZXJzL2NvbXBsZXRlQ2hhbm5lbERlZic7XG5pbXBvcnQgY3JlYXRlU2NhbGUgZnJvbSAnLi4vcGFyc2Vycy9zY2FsZS9jcmVhdGVTY2FsZSc7XG5pbXBvcnQgaWRlbnRpdHkgZnJvbSAnLi4vdXRpbHMvaWRlbnRpdHknO1xuaW1wb3J0IGFwcGx5RG9tYWluIGZyb20gJy4uL3BhcnNlcnMvc2NhbGUvYXBwbHlEb21haW4nO1xuaW1wb3J0IGFwcGx5UmFuZ2UgZnJvbSAnLi4vcGFyc2Vycy9zY2FsZS9hcHBseVJhbmdlJztcbmltcG9ydCBhcHBseVplcm8gZnJvbSAnLi4vcGFyc2Vycy9zY2FsZS9hcHBseVplcm8nO1xuaW1wb3J0IGFwcGx5TmljZSBmcm9tICcuLi9wYXJzZXJzL3NjYWxlL2FwcGx5TmljZSc7XG5pbXBvcnQgeyBpc0NvbXBsZXRlVmFsdWVEZWYsIGlzQ29tcGxldGVGaWVsZERlZiB9IGZyb20gJy4uL3R5cGVHdWFyZHMvQ29tcGxldGVDaGFubmVsRGVmJztcbmltcG9ydCBmYWxsYmFja0Zvcm1hdHRlciBmcm9tICcuLi9wYXJzZXJzL2Zvcm1hdC9mYWxsYmFja0Zvcm1hdHRlcic7XG5pbXBvcnQgY3JlYXRlRm9ybWF0dGVyIGZyb20gJy4uL3BhcnNlcnMvZm9ybWF0L2NyZWF0ZUZvcm1hdHRlcic7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaGFubmVsRW5jb2RlciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBuYW1lLFxuICAgIGNoYW5uZWxUeXBlLFxuICAgIGRlZmluaXRpb246IG9yaWdpbmFsRGVmaW5pdGlvblxuICB9KSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY2hhbm5lbFR5cGVcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9yaWdpbmFsRGVmaW5pdGlvblwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZGVmaW5pdGlvblwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic2NhbGVcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImF4aXNcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdldFZhbHVlXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJlbmNvZGVGdW5jXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJmb3JtYXRWYWx1ZVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZW5jb2RlVmFsdWVcIiwgKHZhbHVlLCBvdGhlcndpc2UpID0+IHtcbiAgICAgIGlmICh0eXBlb2Ygb3RoZXJ3aXNlICE9PSAndW5kZWZpbmVkJyAmJiAodmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyd2lzZTtcbiAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuXG4gICAgICByZXR1cm4gdGhpcy5lbmNvZGVGdW5jKHZhbHVlKTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVuY29kZURhdHVtXCIsIChkYXR1bSwgb3RoZXJ3aXNlKSA9PiB0eXBlb2Ygb3RoZXJ3aXNlID09PSAndW5kZWZpbmVkJyA/IHRoaXMuZW5jb2RlVmFsdWUodGhpcy5nZXRWYWx1ZUZyb21EYXR1bShkYXR1bSkpIDogdGhpcy5lbmNvZGVWYWx1ZSh0aGlzLmdldFZhbHVlRnJvbURhdHVtKGRhdHVtKSwgb3RoZXJ3aXNlKSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJmb3JtYXREYXR1bVwiLCBkYXR1bSA9PiB0aGlzLmZvcm1hdFZhbHVlKHRoaXMuZ2V0VmFsdWVGcm9tRGF0dW0oZGF0dW0pKSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJnZXRWYWx1ZUZyb21EYXR1bVwiLCAoZGF0dW0sIG90aGVyd2lzZSkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldFZhbHVlKGRhdHVtKTtcbiAgICAgIHJldHVybiBvdGhlcndpc2UgIT09IHVuZGVmaW5lZCAmJiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBvdGhlcndpc2UgOiB2YWx1ZTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdldERvbWFpbkZyb21EYXRhc2V0XCIsIGRhdGEgPT4ge1xuICAgICAgaWYgKGlzVmFsdWVEZWYodGhpcy5kZWZpbml0aW9uKSkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSA9IHRoaXMuZGVmaW5pdGlvbjtcbiAgICAgICAgcmV0dXJuIFt2YWx1ZV07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdHlwZVxuICAgICAgfSA9IHRoaXMuZGVmaW5pdGlvbjtcblxuICAgICAgaWYgKHR5cGUgPT09ICdub21pbmFsJyB8fCB0eXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChkYXRhLm1hcChkID0+IHRoaXMuZ2V0VmFsdWVGcm9tRGF0dW0oZCkpKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlID09PSAncXVhbnRpdGF0aXZlJykge1xuICAgICAgICAvLyBRdWFudGlsZSBzY2FsZSBuZWVkcyBhbGwgaXRlbXNcbiAgICAgICAgLy8gYmVjYXVzZSBpdCB0cmVhdHMgZG9tYWluIGFzIGEgZGlzY3JldGUgc2V0IG9mIHNhbXBsZSB2YWx1ZXNcbiAgICAgICAgLy8gZm9yIGNvbXB1dGluZyB0aGUgcXVhbnRpbGVzXG4gICAgICAgIGlmICh0aGlzLmRlZmluaXRpb24uc2NhbGUgJiYgdGhpcy5kZWZpbml0aW9uLnNjYWxlLnR5cGUgPT09ICdxdWFudGlsZScpIHtcbiAgICAgICAgICByZXR1cm4gZGF0YS5tYXAoZCA9PiB0aGlzLmdldFZhbHVlRnJvbURhdHVtKGQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGV4dGVudCA9IGQzRXh0ZW50KGRhdGEsIGQgPT4gdGhpcy5nZXRWYWx1ZUZyb21EYXR1bShkKSk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZXh0ZW50WzBdID09PSAndW5kZWZpbmVkJyA/IFswLCAxXSA6IGV4dGVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09ICd0ZW1wb3JhbCcpIHtcbiAgICAgICAgY29uc3QgZXh0ZW50ID0gZDNFeHRlbnQoZGF0YSwgZCA9PiB0aGlzLmdldFZhbHVlRnJvbURhdHVtKGQpKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBleHRlbnRbMF0gPT09ICd1bmRlZmluZWQnID8gWzAsIDFdIDogZXh0ZW50O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW107XG4gICAgfSk7XG5cbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuY2hhbm5lbFR5cGUgPSBjaGFubmVsVHlwZTtcbiAgICB0aGlzLm9yaWdpbmFsRGVmaW5pdGlvbiA9IG9yaWdpbmFsRGVmaW5pdGlvbjtcbiAgICB0aGlzLmRlZmluaXRpb24gPSBjb21wbGV0ZUNoYW5uZWxEZWYodGhpcy5jaGFubmVsVHlwZSwgb3JpZ2luYWxEZWZpbml0aW9uKTtcbiAgICB0aGlzLmdldFZhbHVlID0gY3JlYXRlR2V0dGVyRnJvbUNoYW5uZWxEZWYodGhpcy5kZWZpbml0aW9uKTtcbiAgICB0aGlzLmZvcm1hdFZhbHVlID0gaXNGaWVsZERlZih0aGlzLmRlZmluaXRpb24pID8gY3JlYXRlRm9ybWF0dGVyKHRoaXMuZGVmaW5pdGlvbikgOiBmYWxsYmFja0Zvcm1hdHRlcjtcblxuICAgIGlmICh0aGlzLmRlZmluaXRpb24uc2NhbGUpIHtcbiAgICAgIGNvbnN0IHNjYWxlID0gY3JlYXRlU2NhbGUodGhpcy5kZWZpbml0aW9uLnNjYWxlKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuICAgICAgdGhpcy5lbmNvZGVGdW5jID0gdmFsdWUgPT4gc2NhbGUodmFsdWUpO1xuXG4gICAgICB0aGlzLnNjYWxlID0gc2NhbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGVmaW5pdGlvblxuICAgICAgfSA9IHRoaXM7XG4gICAgICB0aGlzLmVuY29kZUZ1bmMgPSBpc0NvbXBsZXRlVmFsdWVEZWYoZGVmaW5pdGlvbikgPyAoKSA9PiBkZWZpbml0aW9uLnZhbHVlIDogaWRlbnRpdHk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZGVmaW5pdGlvbi5heGlzKSB7XG4gICAgICB0aGlzLmF4aXMgPSBuZXcgQ2hhbm5lbEVuY29kZXJBeGlzKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIGdldERvbWFpbigpIHtcbiAgICBpZiAodGhpcy5zY2FsZSAmJiAnZG9tYWluJyBpbiB0aGlzLnNjYWxlKSB7XG4gICAgICByZXR1cm4gdGhpcy5zY2FsZS5kb21haW4oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW107XG4gIH1cblxuICBzZXREb21haW4oZG9tYWluKSB7XG4gICAgaWYgKHRoaXMuZGVmaW5pdGlvbi5zY2FsZSAhPT0gZmFsc2UgJiYgdGhpcy5zY2FsZSAmJiAhdGhpcy5oYXNDYXRlZ29yaWNhbENvbG9yU2NhbGUoKSAmJiAnZG9tYWluJyBpbiB0aGlzLnNjYWxlKSB7XG4gICAgICBjb25zdCBjb25maWcgPSB0aGlzLmRlZmluaXRpb24uc2NhbGU7XG4gICAgICBhcHBseURvbWFpbihjb25maWcsIHRoaXMuc2NhbGUsIGRvbWFpbik7XG4gICAgICBhcHBseVJhbmdlKGNvbmZpZywgdGhpcy5zY2FsZSk7XG4gICAgICBhcHBseVplcm8oY29uZmlnLCB0aGlzLnNjYWxlKTtcbiAgICAgIGFwcGx5TmljZShjb25maWcsIHRoaXMuc2NhbGUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0RG9tYWluRnJvbURhdGFzZXQoZGF0YSkge1xuICAgIHJldHVybiB0aGlzLnNjYWxlICYmICdkb21haW4nIGluIHRoaXMuc2NhbGUgPyB0aGlzLnNldERvbWFpbih0aGlzLmdldERvbWFpbkZyb21EYXRhc2V0KGRhdGEpKSA6IHRoaXM7XG4gIH1cblxuICBnZXRUaXRsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZpbml0aW9uLnRpdGxlO1xuICB9XG5cbiAgaXNHcm91cEJ5KCkge1xuICAgIGlmIChpc1R5cGVkRmllbGREZWYodGhpcy5kZWZpbml0aW9uKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB0eXBlXG4gICAgICB9ID0gdGhpcy5kZWZpbml0aW9uO1xuICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbFR5cGUgPT09ICdDYXRlZ29yeScgfHwgdGhpcy5jaGFubmVsVHlwZSA9PT0gJ1RleHQnIHx8IHRoaXMuY2hhbm5lbFR5cGUgPT09ICdDb2xvcicgJiYgKHR5cGUgPT09ICdub21pbmFsJyB8fCB0eXBlID09PSAnb3JkaW5hbCcpIHx8IGlzWE9yWSh0aGlzLmNoYW5uZWxUeXBlKSAmJiAodHlwZSA9PT0gJ25vbWluYWwnIHx8IHR5cGUgPT09ICdvcmRpbmFsJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaXNYKCkge1xuICAgIHJldHVybiBpc1godGhpcy5jaGFubmVsVHlwZSk7XG4gIH1cblxuICBpc1hPclkoKSB7XG4gICAgcmV0dXJuIGlzWE9yWSh0aGlzLmNoYW5uZWxUeXBlKTtcbiAgfVxuXG4gIGlzWSgpIHtcbiAgICByZXR1cm4gaXNZKHRoaXMuY2hhbm5lbFR5cGUpO1xuICB9XG5cbiAgaGFzQ2F0ZWdvcmljYWxDb2xvclNjYWxlKCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuZGVmaW5pdGlvbi5zY2FsZTsgLy8gU2NhbGUgdHlwZSBpcyBvcmRpbmFsIHdpdGggbm90IGdpdmVuIHJhbmdlXG4gICAgLy8gKG1heSBoYXZlIG9wdGlvbmFsIHNjaGVtZSlcbiAgICAvLyB3aWxsIGJlY29tZSBhIGNhdGVnb3JpY2FsIHNjYWxlXG4gICAgLy8gb2YgbmFtZWQgY29sb3Igc2NoZW1lLlxuICAgIC8vIEEgY29sb3Igc2NhbGUgZnJvbSBuYW1lZCBjb2xvciBzY2hlbWUgbWF5IGJlIHNoYXJlZCBhbW9uZyBtdWx0aXBsZSBjb21wb25lbnRzXG4gICAgLy8gaW4gdGhlIHNhbWUgbmFtZXNwYWNlIGJ5IGRlZmF1bHQsIHNvIGNoYW5naW5nIGl0cyBkb21haW4gYWZmZWN0IGFsbCBjb21wb25lbnRzLlxuICAgIC8vIChTb3VuZHMgbGlrZSBhIGJhZCBpZGVhLilcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGN1cnJlbnRseSBvbmx5IGJlaW5nIHVzZWQgdG8gY2hlY2tcbiAgICAvLyB3aGV0aGVyIHRvIGFwcGx5IGRvbWFpbiBmcm9tIGRhdGFzZXQgb3Igbm90LlxuICAgIC8vIEFuIG9yZGluYWwgc2NhbGUgd2l0aCB1c2VyLXNwZWNpZmllZCBjb2xvciBzY2hlbWUgYXMgcmFuZ2UgYXJyYXlcbiAgICAvLyB3aWxsIHJldHVybiBmYWxzZSBmcm9tIHRoaXMgZnVuY3Rpb24gYW5kIGJlIGV4Y2x1ZGVkIGZyb20gaXQuXG5cbiAgICByZXR1cm4gdGhpcy5zY2FsZSAmJiBjb25maWcgJiYgY29uZmlnLnR5cGUgPT09IFNjYWxlVHlwZS5PUkRJTkFMICYmIHR5cGVvZiBjb25maWcucmFuZ2UgPT09ICd1bmRlZmluZWQnO1xuICB9XG5cbiAgaGFzTGVnZW5kKCkge1xuICAgIHJldHVybiB0aGlzLmRlZmluaXRpb24ubGVnZW5kICE9PSBmYWxzZTtcbiAgfVxuXG4gIGhhc1ZhbHVlRGVmaW5pdGlvbigpIHtcbiAgICByZXR1cm4gaXNDb21wbGV0ZVZhbHVlRGVmKHRoaXMuZGVmaW5pdGlvbik7XG4gIH1cblxuICBoYXNGaWVsZERlZmluaXRpb24oKSB7XG4gICAgcmV0dXJuIGlzQ29tcGxldGVGaWVsZERlZih0aGlzLmRlZmluaXRpb24pO1xuICB9XG5cbn0iLCJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5pbXBvcnQgeyBpc1R5cGVkRmllbGREZWYsIGlzVmFsdWVEZWYgfSBmcm9tICcuLi90eXBlR3VhcmRzL0NoYW5uZWxEZWYnO1xuaW1wb3J0IHsgaXNOb3RBcnJheSB9IGZyb20gJy4uL3R5cGVHdWFyZHMvQmFzZSc7XG5pbXBvcnQgQ2hhbm5lbEVuY29kZXIgZnJvbSAnLi9DaGFubmVsRW5jb2Rlcic7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbmNvZGVyIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGNoYW5uZWxUeXBlcyxcbiAgICBlbmNvZGluZ1xuICB9KSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZW5jb2RpbmdcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNoYW5uZWxUeXBlc1wiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY2hhbm5lbHNcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxlZ2VuZHNcIiwgdm9pZCAwKTtcblxuICAgIHRoaXMuY2hhbm5lbFR5cGVzID0gY2hhbm5lbFR5cGVzO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgICBjb25zdCBjaGFubmVsTmFtZXMgPSB0aGlzLmdldENoYW5uZWxOYW1lcygpOyAvLyBDcmVhdGUgY2hhbm5lbCBlbmNvZGVyc1xuXG4gICAgY29uc3QgY2hhbm5lbHMgPSB7fTtcbiAgICBjaGFubmVsTmFtZXMuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgIGNvbnN0IGNoYW5uZWxFbmNvZGluZyA9IGVuY29kaW5nW25hbWVdO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGFubmVsRW5jb2RpbmcpKSB7XG4gICAgICAgIGNvbnN0IGRlZmluaXRpb25zID0gY2hhbm5lbEVuY29kaW5nO1xuICAgICAgICBjaGFubmVsc1tuYW1lXSA9IGRlZmluaXRpb25zLm1hcCgoZGVmaW5pdGlvbiwgaSkgPT4gbmV3IENoYW5uZWxFbmNvZGVyKHtcbiAgICAgICAgICBjaGFubmVsVHlwZTogY2hhbm5lbFR5cGVzW25hbWVdLFxuICAgICAgICAgIGRlZmluaXRpb24sXG4gICAgICAgICAgbmFtZTogbmFtZSArIFwiW1wiICsgaSArIFwiXVwiXG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSBjaGFubmVsRW5jb2Rpbmc7XG4gICAgICAgIGNoYW5uZWxzW25hbWVdID0gbmV3IENoYW5uZWxFbmNvZGVyKHtcbiAgICAgICAgICBjaGFubmVsVHlwZTogY2hhbm5lbFR5cGVzW25hbWVdLFxuICAgICAgICAgIGRlZmluaXRpb24sXG4gICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmNoYW5uZWxzID0gY2hhbm5lbHM7IC8vIEdyb3VwIHRoZSBjaGFubmVscyB0aGF0IHVzZSB0aGUgc2FtZSBmaWVsZCB0b2dldGhlclxuICAgIC8vIHNvIHRoZXkgY2FuIHNoYXJlIHRoZSBzYW1lIGxlZ2VuZC5cblxuICAgIHRoaXMubGVnZW5kcyA9IHt9O1xuICAgIGNoYW5uZWxOYW1lcy5tYXAobmFtZSA9PiB0aGlzLmNoYW5uZWxzW25hbWVdKS5mb3JFYWNoKGMgPT4ge1xuICAgICAgaWYgKGlzTm90QXJyYXkoYykgJiYgYy5oYXNMZWdlbmQoKSAmJiBpc1R5cGVkRmllbGREZWYoYy5kZWZpbml0aW9uKSkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZmllbGRcbiAgICAgICAgfSA9IGMuZGVmaW5pdGlvbjtcbiAgICAgICAgY29uc3QgY2hhbm5lbEVuY29kZXIgPSBjO1xuXG4gICAgICAgIGlmICh0aGlzLmxlZ2VuZHNbZmllbGRdKSB7XG4gICAgICAgICAgdGhpcy5sZWdlbmRzW2ZpZWxkXS5wdXNoKGNoYW5uZWxFbmNvZGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxlZ2VuZHNbZmllbGRdID0gW2NoYW5uZWxFbmNvZGVyXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZ2V0Q2hhbm5lbE5hbWVzKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmNoYW5uZWxUeXBlcyk7XG4gIH1cblxuICBnZXRDaGFubmVsRW5jb2RlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q2hhbm5lbE5hbWVzKCkuZmxhdE1hcChuYW1lID0+IHRoaXMuY2hhbm5lbHNbbmFtZV0pO1xuICB9XG5cbiAgZ2V0R3JvdXBCeXMoKSB7XG4gICAgY29uc3QgZmllbGRzID0gdGhpcy5nZXRDaGFubmVsRW5jb2RlcnMoKS5maWx0ZXIoYyA9PiBjLmlzR3JvdXBCeSgpKS5tYXAoYyA9PiBjLmRlZmluaXRpb24uZmllbGQpO1xuICAgIHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQoZmllbGRzKSk7XG4gIH1cblxuICBjcmVhdGVMZWdlbmRJdGVtc0ZhY3RvcnkoZmllbGQpIHtcbiAgICBjb25zdCBjaGFubmVsRW5jb2RlcnMgPSB0aGlzLmdldENoYW5uZWxFbmNvZGVycygpLmZpbHRlcihlID0+IGlzTm90QXJyYXkoZSkgJiYgaXNWYWx1ZURlZihlLmRlZmluaXRpb24pKS5mbGF0KCkuY29uY2F0KHRoaXMubGVnZW5kc1tmaWVsZF0pO1xuICAgIHJldHVybiBkb21haW4gPT4gZG9tYWluLm1hcChpbnB1dCA9PiAoe1xuICAgICAgaW5wdXQsXG4gICAgICBvdXRwdXQ6IGNoYW5uZWxFbmNvZGVycy5yZWR1Y2UoKHByZXYsIGN1cnIpID0+IHtcbiAgICAgICAgY29uc3QgbWFwID0gcHJldjtcbiAgICAgICAgbWFwW2N1cnIubmFtZV0gPSBjdXJyLmVuY29kZVZhbHVlKGlucHV0KTtcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgIH0sIHt9KVxuICAgIH0pKTtcbiAgfVxuXG4gIGdldExlZ2VuZEluZm9ybWF0aW9uKGRhdGEgPSBbXSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmxlZ2VuZHMpIC8vIGZvciBlYWNoIGZpZWxkIHRoYXQgd2FzIGVuY29kZWRcbiAgICAubWFwKGZpZWxkID0+IHtcbiAgICAgIC8vIGdldCBhbGwgdGhlIGNoYW5uZWxzIHRoYXQgdXNlIHRoaXMgZmllbGRcbiAgICAgIGNvbnN0IGNoYW5uZWxFbmNvZGVycyA9IHRoaXMubGVnZW5kc1tmaWVsZF07XG4gICAgICBjb25zdCBmaXJzdEVuY29kZXIgPSBjaGFubmVsRW5jb2RlcnNbMF07XG4gICAgICBjb25zdCBkZWZpbml0aW9uID0gZmlyc3RFbmNvZGVyLmRlZmluaXRpb247XG4gICAgICBjb25zdCBjcmVhdGVMZWdlbmRJdGVtcyA9IHRoaXMuY3JlYXRlTGVnZW5kSXRlbXNGYWN0b3J5KGZpZWxkKTtcblxuICAgICAgaWYgKGRlZmluaXRpb24udHlwZSA9PT0gJ25vbWluYWwnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2hhbm5lbEVuY29kZXJzLFxuICAgICAgICAgIGNyZWF0ZUxlZ2VuZEl0ZW1zLFxuICAgICAgICAgIGZpZWxkLFxuICAgICAgICAgIGl0ZW1zOiBjcmVhdGVMZWdlbmRJdGVtcyhmaXJzdEVuY29kZXIuZ2V0RG9tYWluRnJvbURhdGFzZXQoZGF0YSkpLFxuICAgICAgICAgIHR5cGU6IGRlZmluaXRpb24udHlwZVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjaGFubmVsRW5jb2RlcnMsXG4gICAgICAgIGNyZWF0ZUxlZ2VuZEl0ZW1zLFxuICAgICAgICBmaWVsZCxcbiAgICAgICAgdHlwZTogZGVmaW5pdGlvbi50eXBlXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgc2V0RG9tYWluRnJvbURhdGFzZXQoZGF0YSkge1xuICAgIHRoaXMuZ2V0Q2hhbm5lbEVuY29kZXJzKCkuZm9yRWFjaChjaGFubmVsRW5jb2RlciA9PiB7XG4gICAgICBjaGFubmVsRW5jb2Rlci5zZXREb21haW5Gcm9tRGF0YXNldChkYXRhKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGhhc0xlZ2VuZCgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5sZWdlbmRzKS5sZW5ndGggPiAwO1xuICB9XG5cbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtZXJnZUVuY29kaW5nKGRlZmF1bHRFbmNvZGluZywgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHsgLi4uZGVmYXVsdEVuY29kaW5nLFxuICAgIC4uLmVuY29kaW5nXG4gIH07XG59IiwiaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3IgfSBmcm9tICdyZXNlbGVjdCc7XG5pbXBvcnQgRW5jb2RlciBmcm9tICcuL0VuY29kZXInO1xuaW1wb3J0IG1lcmdlRW5jb2RpbmcgZnJvbSAnLi4vdXRpbHMvbWVyZ2VFbmNvZGluZyc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVFbmNvZGVyRmFjdG9yeShwYXJhbXMpIHtcbiAgY29uc3Qge1xuICAgIGNoYW5uZWxUeXBlc1xuICB9ID0gcGFyYW1zO1xuICBjb25zdCBjb21wbGV0ZUVuY29kaW5nID0gJ2RlZmF1bHRFbmNvZGluZycgaW4gcGFyYW1zID8gZW5jb2RpbmcgPT4gbWVyZ2VFbmNvZGluZyhwYXJhbXMuZGVmYXVsdEVuY29kaW5nLCBlbmNvZGluZykgOiBwYXJhbXMuY29tcGxldGVFbmNvZGluZztcblxuICBjb25zdCBjcmVhdGUgPSAoZW5jb2RpbmcgPSB7fSkgPT4gbmV3IEVuY29kZXIoe1xuICAgIGNoYW5uZWxUeXBlcyxcbiAgICBlbmNvZGluZzogY29tcGxldGVFbmNvZGluZyhlbmNvZGluZylcbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBjaGFubmVsVHlwZXMsXG4gICAgY3JlYXRlLFxuICAgIGNyZWF0ZVNlbGVjdG9yOiAoKSA9PiBjcmVhdGVTZWxlY3RvcihlbmNvZGluZyA9PiBlbmNvZGluZywgY3JlYXRlKSxcbiAgICBERUZBVUxUX0VOQ09ESU5HOiBjb21wbGV0ZUVuY29kaW5nKHt9KVxuICB9O1xufSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2220\n")},2397:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, "default", function() { return /* binding */ ScatterPlot_ScatterPlot; });\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react/index.js\nvar react = __webpack_require__(0);\nvar react_default = /*#__PURE__*/__webpack_require__.n(react);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/chart/XYChart.js + 51 modules\nvar XYChart = __webpack_require__(2390);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/theme/esm/svgLabel.js + 1 modules\nvar svgLabel = __webpack_require__(2349);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/theme/esm/color.js\nvar color = __webpack_require__(1988);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/shared/esm/components/FocusBlurHandler.js\nvar FocusBlurHandler = __webpack_require__(2377);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/node_modules/@vx/group/dist/vx-group.es.js\nvar vx_group_es = __webpack_require__(1941);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/prop-types/index.js\nvar prop_types = __webpack_require__(55);\nvar prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/reduce-css-calc/index.js\nvar reduce_css_calc = __webpack_require__(2152);\nvar reduce_css_calc_default = /*#__PURE__*/__webpack_require__.n(reduce_css_calc);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/lodash/memoize.js\nvar memoize = __webpack_require__(1212);\nvar memoize_default = /*#__PURE__*/__webpack_require__.n(memoize);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/node_modules/@vx/text/esm/util/getStringWidth.js\n\nvar MEASUREMENT_ELEMENT_ID = \'__react_svg_text_measurement_id\';\n\nfunction getStringWidth(str, style) {\n  try {\n    // Calculate length of each word to be used to determine number of words per line\n    var textEl = document.getElementById(MEASUREMENT_ELEMENT_ID);\n\n    if (!textEl) {\n      var svg = document.createElementNS(\'http://www.w3.org/2000/svg\', \'svg\');\n      svg.style.width = 0;\n      svg.style.height = 0;\n      svg.style.position = \'absolute\';\n      svg.style.top = \'-100%\';\n      svg.style.left = \'-100%\';\n      textEl = document.createElementNS(\'http://www.w3.org/2000/svg\', \'text\');\n      textEl.setAttribute(\'id\', MEASUREMENT_ELEMENT_ID);\n      svg.appendChild(textEl);\n      document.body.appendChild(svg);\n    }\n\n    Object.assign(textEl.style, style);\n    textEl.textContent = str;\n    return textEl.getComputedTextLength();\n  } catch (e) {\n    return null;\n  }\n}\n\n/* harmony default export */ var util_getStringWidth = (memoize_default()(getStringWidth, function (str, style) {\n  return str + "_" + JSON.stringify(style);\n}));\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/node_modules/@vx/text/esm/Text.js\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\n\n\n\n\nvar propTypes = {\n  scaleToFit: prop_types_default.a.bool,\n  angle: prop_types_default.a.number,\n  textAnchor: prop_types_default.a.oneOf([\'start\', \'middle\', \'end\', \'inherit\']),\n  verticalAnchor: prop_types_default.a.oneOf([\'start\', \'middle\', \'end\']),\n  style: prop_types_default.a.object,\n  innerRef: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.object]),\n  x: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),\n  y: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),\n  dx: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),\n  dy: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),\n  lineHeight: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),\n  capHeight: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),\n  children: prop_types_default.a.any,\n  width: prop_types_default.a.number\n};\nvar defaultProps = {\n  x: 0,\n  y: 0,\n  dx: 0,\n  dy: 0,\n  lineHeight: \'1em\',\n  capHeight: \'0.71em\',\n  // Magic number from d3\n  scaleToFit: false,\n  textAnchor: \'start\',\n  verticalAnchor: \'end\' // default SVG behavior\n\n};\n\nvar Text_Text =\n/*#__PURE__*/\nfunction (_Component) {\n  _inheritsLoose(Text, _Component);\n\n  function Text(props) {\n    var _this;\n\n    _this = _Component.call(this, props) || this;\n    _this.state = {\n      wordsByLines: []\n    };\n    return _this;\n  } // eslint-disable-next-line camelcase\n\n\n  var _proto = Text.prototype;\n\n  _proto.UNSAFE_componentWillMount = function UNSAFE_componentWillMount() {\n    this.updateWordsByLines(this.props, true);\n  } // eslint-disable-next-line camelcase\n  ;\n\n  _proto.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(nextProps) {\n    var needCalculate = this.props.children !== nextProps.children || this.props.style !== nextProps.style;\n    this.updateWordsByLines(nextProps, needCalculate);\n  };\n\n  _proto.updateWordsByLines = function updateWordsByLines(props, needCalculate) {\n    // Only perform calculations if using features that require them (multiline, scaleToFit)\n    if (props.width || props.scaleToFit) {\n      if (needCalculate) {\n        var words = props.children ? props.children.toString().split(/(?:(?!\\u00A0+)\\s+)/) : [];\n        this.wordsWithComputedWidth = words.map(function (word) {\n          return {\n            word: word,\n            width: util_getStringWidth(word, props.style)\n          };\n        });\n        this.spaceWidth = util_getStringWidth("\\xA0", props.style);\n      }\n\n      var wordsByLines = this.calculateWordsByLines(this.wordsWithComputedWidth, this.spaceWidth, props.width);\n      this.setState({\n        wordsByLines: wordsByLines\n      });\n    } else {\n      this.updateWordsWithoutCalculate(props);\n    }\n  };\n\n  _proto.updateWordsWithoutCalculate = function updateWordsWithoutCalculate(props) {\n    var words = props.children ? props.children.toString().split(/(?:(?!\\u00A0+)\\s+)/) : [];\n    this.setState({\n      wordsByLines: [{\n        words: words\n      }]\n    });\n  };\n\n  _proto.calculateWordsByLines = function calculateWordsByLines(wordsWithComputedWidth, spaceWidth, lineWidth) {\n    var scaleToFit = this.props.scaleToFit;\n    return wordsWithComputedWidth.reduce(function (result, _ref) {\n      var word = _ref.word,\n          width = _ref.width;\n      var currentLine = result[result.length - 1];\n\n      if (currentLine && (lineWidth == null || scaleToFit || currentLine.width + width + spaceWidth < lineWidth)) {\n        // Word can be added to an existing line\n        currentLine.words.push(word);\n        currentLine.width += width + spaceWidth;\n      } else {\n        // Add first word to line or word is too long to scaleToFit on existing line\n        var newLine = {\n          words: [word],\n          width: width\n        };\n        result.push(newLine);\n      }\n\n      return result;\n    }, []);\n  };\n\n  _proto.render = function render() {\n    var _this$props = this.props,\n        dx = _this$props.dx,\n        dy = _this$props.dy,\n        textAnchor = _this$props.textAnchor,\n        verticalAnchor = _this$props.verticalAnchor,\n        scaleToFit = _this$props.scaleToFit,\n        angle = _this$props.angle,\n        lineHeight = _this$props.lineHeight,\n        capHeight = _this$props.capHeight,\n        innerRef = _this$props.innerRef,\n        textProps = _objectWithoutPropertiesLoose(_this$props, ["dx", "dy", "textAnchor", "verticalAnchor", "scaleToFit", "angle", "lineHeight", "capHeight", "innerRef"]);\n\n    var wordsByLines = this.state.wordsByLines;\n    var x = textProps.x,\n        y = textProps.y;\n    var startDy;\n\n    switch (verticalAnchor) {\n      case \'start\':\n        startDy = reduce_css_calc_default()("calc(" + capHeight + ")");\n        break;\n\n      case \'middle\':\n        startDy = reduce_css_calc_default()("calc(" + (wordsByLines.length - 1) / 2 + " * -" + lineHeight + " + (" + capHeight + " / 2))");\n        break;\n\n      default:\n        startDy = reduce_css_calc_default()("calc(" + (wordsByLines.length - 1) + " * -" + lineHeight + ")");\n        break;\n    }\n\n    var transforms = [];\n\n    if (scaleToFit && wordsByLines.length > 0) {\n      var lineWidth = wordsByLines[0].width;\n      var sx = this.props.width / lineWidth;\n      var sy = sx;\n      var originX = x - sx * x;\n      var originY = y - sy * y;\n      transforms.push("matrix(" + sx + ", 0, 0, " + sy + ", " + originX + ", " + originY + ")");\n    }\n\n    if (angle) {\n      transforms.push("rotate(" + angle + ", " + x + ", " + y + ")");\n    }\n\n    if (transforms.length > 0) {\n      textProps.transform = transforms.join(\' \');\n    }\n\n    return react_default.a.createElement("svg", {\n      ref: innerRef,\n      x: dx,\n      y: dy,\n      fontSize: textProps.fontSize,\n      style: {\n        overflow: \'visible\'\n      }\n    }, react_default.a.createElement("text", _extends({}, textProps, {\n      textAnchor: textAnchor\n    }), wordsByLines.map(function (line, index) {\n      return react_default.a.createElement("tspan", {\n        x: x,\n        dy: index === 0 ? startDy : lineHeight,\n        key: index\n      }, line.words.join(\' \'));\n    })));\n  };\n\n  return Text;\n}(react["Component"]);\n\nText_Text.propTypes = propTypes;\nText_Text.defaultProps = defaultProps;\n/* harmony default export */ var esm_Text = (Text_Text);\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/utils/chartUtils.js\nvar chartUtils = __webpack_require__(1939);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/node_modules/@vx/glyph/dist/vx-glyph.es.js\nvar vx_glyph_es = __webpack_require__(2173);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/utils/propShapes.js\nvar propShapes = __webpack_require__(1943);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/glyph/GlyphDotComponent.js\nfunction GlyphDotComponent_extends() { GlyphDotComponent_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return GlyphDotComponent_extends.apply(this, arguments); }\n\n/* eslint react/default-props-match-prop-types: \'off\' */\n\n\n\nvar defaultPropTypes = {\n  onMouseMove: null,\n  onMouseLeave: null,\n  strokeDasharray: null\n};\nfunction GlyphDotComponent(_ref) {\n  var x = _ref.x,\n      y = _ref.y,\n      size = _ref.size,\n      fill = _ref.fill,\n      fillOpacity = _ref.fillOpacity,\n      stroke = _ref.stroke,\n      strokeWidth = _ref.strokeWidth,\n      strokeDasharray = _ref.strokeDasharray,\n      onClick = _ref.onClick,\n      onMouseMove = _ref.onMouseMove,\n      onMouseLeave = _ref.onMouseLeave,\n      data = _ref.data,\n      datum = _ref.datum;\n  return react_default.a.createElement(vx_glyph_es["a" /* GlyphDot */], {\n    cx: x,\n    cy: y,\n    r: size,\n    fill: fill,\n    fillOpacity: fillOpacity,\n    stroke: stroke,\n    strokeWidth: strokeWidth,\n    strokeDasharray: strokeDasharray,\n    onClick: onClick && function (event) {\n      onClick({\n        event: event,\n        data: data,\n        datum: datum,\n        color: fill\n      });\n    },\n    onMouseMove: onMouseMove && function (event) {\n      onMouseMove({\n        event: event,\n        data: data,\n        datum: datum,\n        color: fill\n      });\n    },\n    onMouseLeave: onMouseLeave\n  });\n}\nGlyphDotComponent.propTypes = GlyphDotComponent_extends({}, propShapes["g" /* pointComponentPropTypes */]);\nGlyphDotComponent.defaultProps = defaultPropTypes;\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/utils/sharedSeriesProps.js\nvar sharedSeriesProps = __webpack_require__(1968);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/series/PointSeries.js\nfunction PointSeries_inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nfunction PointSeries_extends() { PointSeries_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return PointSeries_extends.apply(this, arguments); }\n\n\n\n\n\n\n\n\n\n\n\nvar PointSeries_propTypes = PointSeries_extends({}, sharedSeriesProps["a" /* default */], {\n  data: propShapes["h" /* pointSeriesDataShape */].isRequired,\n  defaultLabelProps: prop_types_default.a.object,\n  // eslint-disable-line react/forbid-prop-types\n  pointComponent: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.element]),\n  fill: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.string]),\n  fillOpacity: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  renderLabel: prop_types_default.a.func,\n  stroke: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.string]),\n  strokeWidth: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  strokeDasharray: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.string]),\n  size: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number])\n});\nvar baseLabel = svgLabel["b" /* default */].baseLabel;\nvar defaultLabelProps = PointSeries_extends({}, baseLabel, {\n  textAnchor: \'start\',\n  verticalAnchor: \'start\',\n  dx: \'0.25em\',\n  dy: \'0.25em\',\n  pointerEvents: \'none\',\n  stroke: \'#fff\',\n  strokeWidth: 2,\n  paintOrder: \'stroke\',\n  fontSize: 12\n});\nvar PointSeries_defaultProps = {\n  defaultLabelProps: defaultLabelProps,\n\n  /* eslint-disable react/prop-types */\n  renderLabel: function renderLabel(_ref) {\n    var datum = _ref.datum,\n        labelProps = _ref.labelProps;\n    return datum.label ? react_default.a.createElement(esm_Text, labelProps, datum.label) : null;\n  },\n\n  /* eslint-enable react/prop-types */\n  pointComponent: GlyphDotComponent,\n  size: 4,\n  fill: color["a" /* default */].default,\n  fillOpacity: 0.8,\n  stroke: \'#FFFFFF\',\n  strokeDasharray: null,\n  strokeWidth: 1\n};\nvar noEventsStyles = {\n  pointerEvents: \'none\'\n};\n\nvar PointSeries_PointSeries =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  PointSeries_inheritsLoose(PointSeries, _React$PureComponent);\n\n  function PointSeries() {\n    return _React$PureComponent.apply(this, arguments) || this;\n  }\n\n  var _proto = PointSeries.prototype;\n\n  _proto.render = function render() {\n    var _this$props = this.props,\n        data = _this$props.data,\n        labelProps = _this$props.defaultLabelProps,\n        disableMouseEvents = _this$props.disableMouseEvents,\n        fill = _this$props.fill,\n        fillOpacity = _this$props.fillOpacity,\n        renderLabel = _this$props.renderLabel,\n        size = _this$props.size,\n        stroke = _this$props.stroke,\n        strokeWidth = _this$props.strokeWidth,\n        strokeDasharray = _this$props.strokeDasharray,\n        xScale = _this$props.xScale,\n        yScale = _this$props.yScale,\n        onClick = _this$props.onClick,\n        onMouseMove = _this$props.onMouseMove,\n        onMouseLeave = _this$props.onMouseLeave,\n        pointComponent = _this$props.pointComponent;\n    if (!xScale || !yScale) return null;\n    var Labels = [];\n    return react_default.a.createElement(vx_group_es["a" /* Group */], {\n      style: disableMouseEvents ? noEventsStyles : null\n    }, data.map(function (d, i) {\n      var xVal = d.x;\n      var yVal = d.y;\n      var defined = Object(chartUtils["j" /* isDefined */])(xVal) && Object(chartUtils["j" /* isDefined */])(yVal);\n      var x = xScale(xVal);\n      var y = yScale(yVal);\n      var computedFill = d.fill || Object(chartUtils["b" /* callOrValue */])(fill, d, i);\n      var key = d.x + "-" + i;\n      var computedSize = d.size || Object(chartUtils["b" /* callOrValue */])(size, d, i);\n      var computedFillOpacity = d.fillOpacity || Object(chartUtils["b" /* callOrValue */])(fillOpacity, d, i);\n      var computedStroke = d.stroke || Object(chartUtils["b" /* callOrValue */])(stroke, d, i);\n      var computedStrokeWidth = d.strokeWidth || Object(chartUtils["b" /* callOrValue */])(strokeWidth, d, i);\n      var computedStrokeDasharray = d.strokeDasharray || Object(chartUtils["b" /* callOrValue */])(strokeDasharray, d, i);\n\n      if (defined && renderLabel) {\n        var Label = renderLabel({\n          datum: d,\n          index: i,\n          labelProps: PointSeries_extends({\n            key: key\n          }, labelProps, {\n            x: x,\n            y: y\n          })\n        });\n        if (Label) Labels.push(Label);\n      }\n\n      var props = {\n        x: x,\n        y: y,\n        size: computedSize,\n        fill: computedFill,\n        fillOpacity: computedFillOpacity,\n        stroke: computedStroke,\n        strokeWidth: computedStrokeWidth,\n        strokeDasharray: computedStrokeDasharray,\n        onClick: disableMouseEvents ? null : onClick,\n        onMouseMove: disableMouseEvents ? null : onMouseMove,\n        onMouseLeave: disableMouseEvents ? null : onMouseLeave,\n        data: data,\n        datum: d\n      };\n      return defined && react_default.a.createElement(FocusBlurHandler["a" /* default */], {\n        key: key,\n        xlinkHref: "#",\n        onBlur: disableMouseEvents ? null : props.onMouseLeave,\n        onFocus: disableMouseEvents ? null : function (event) {\n          onMouseMove({\n            event: event,\n            data: data,\n            datum: d,\n            color: computedFill,\n            index: i\n          });\n        }\n      }, react_default.a.createElement(pointComponent, props));\n    }), Labels.map(function (Label) {\n      return Label;\n    }));\n  };\n\n  return PointSeries;\n}(react_default.a.PureComponent);\n\n\nPointSeries_PointSeries.propTypes = PointSeries_propTypes;\nPointSeries_PointSeries.defaultProps = PointSeries_defaultProps;\nPointSeries_PointSeries.displayName = \'PointSeries\';\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/theme/esm/chartTheme.js + 2 modules\nvar chartTheme = __webpack_require__(2408);\n\n// EXTERNAL MODULE: ../superset-ui-core/src/chart-composition/legend/WithLegend.tsx\nvar WithLegend = __webpack_require__(1060);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/typeGuards/ChannelDef.js\nvar ChannelDef = __webpack_require__(1936);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/encoders/createEncoderFactory.js + 53 modules\nvar createEncoderFactory = __webpack_require__(2220);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/components/ScatterPlot/Encoder.ts\n\nconst scatterPlotEncoderFactory = Object(createEncoderFactory["a" /* default */])({\n    channelTypes: {\n        x: \'X\',\n        y: \'Y\',\n        fill: \'Color\',\n        group: \'Category\',\n        size: \'Numeric\',\n        stroke: \'Color\',\n        tooltip: \'Text\',\n    },\n    defaultEncoding: {\n        x: { field: \'x\', type: \'quantitative\' },\n        y: { field: \'y\', type: \'quantitative\' },\n        fill: { value: \'#222\' },\n        group: [],\n        size: { value: 5 },\n        stroke: { value: \'none\' },\n        tooltip: [],\n    },\n});\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/utils/createMarginSelector.tsx\nvar createMarginSelector = __webpack_require__(1978);\n\n// EXTERNAL MODULE: ../superset-ui-core/src/chart-composition/tooltip/TooltipFrame.tsx\nvar TooltipFrame = __webpack_require__(1061);\n\n// EXTERNAL MODULE: ../superset-ui-core/src/chart-composition/tooltip/TooltipTable.tsx\nvar TooltipTable = __webpack_require__(1062);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/components/ScatterPlot/DefaultTooltipRenderer.tsx\n\n\n\nfunction DefaultTooltipRenderer({ datum, encoder }) {\n    const { channels } = encoder;\n    const { x, y, size, fill, stroke } = channels;\n    const tooltipRows = [\n        { key: \'x\', keyColumn: x.getTitle(), valueColumn: x.formatDatum(datum) },\n        { key: \'y\', keyColumn: y.getTitle(), valueColumn: y.formatDatum(datum) },\n    ];\n    if (Object(ChannelDef["a" /* isFieldDef */])(fill.definition)) {\n        tooltipRows.push({\n            key: \'fill\',\n            keyColumn: fill.getTitle(),\n            valueColumn: fill.formatDatum(datum),\n        });\n    }\n    if (Object(ChannelDef["a" /* isFieldDef */])(stroke.definition)) {\n        tooltipRows.push({\n            key: \'stroke\',\n            keyColumn: stroke.getTitle(),\n            valueColumn: stroke.formatDatum(datum),\n        });\n    }\n    if (Object(ChannelDef["a" /* isFieldDef */])(size.definition)) {\n        tooltipRows.push({\n            key: \'size\',\n            keyColumn: size.getTitle(),\n            valueColumn: size.formatDatum(datum),\n        });\n    }\n    channels.group.forEach(g => {\n        tooltipRows.push({\n            key: `${g.name}`,\n            keyColumn: g.getTitle(),\n            valueColumn: g.formatDatum(datum),\n        });\n    });\n    channels.tooltip.forEach(g => {\n        tooltipRows.push({\n            key: `${g.name}`,\n            keyColumn: g.getTitle(),\n            valueColumn: g.formatDatum(datum),\n        });\n    });\n    return (react_default.a.createElement(TooltipFrame["a" /* default */], null,\n        react_default.a.createElement(TooltipTable["a" /* default */], { data: tooltipRows })));\n}\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/utils/convertScaleToDataUIScaleShape.ts\nvar convertScaleToDataUIScaleShape = __webpack_require__(1979);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/utils/createXYChartLayoutWithTheme.ts + 3 modules\nvar createXYChartLayoutWithTheme = __webpack_require__(1980);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/components/legend/createRenderLegend.tsx + 3 modules\nvar createRenderLegend = __webpack_require__(1981);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/components/ScatterPlot/ScatterPlot.tsx\n\n\n\n\n\n\n\n\n\n\n\nconst ScatterPlot_defaultProps = {\n    className: \'\',\n    margin: createMarginSelector["a" /* DEFAULT_MARGIN */],\n    encoding: {},\n    theme: chartTheme["a" /* default */],\n    TooltipRenderer: DefaultTooltipRenderer,\n};\nclass ScatterPlot_ScatterPlot extends react["PureComponent"] {\n    constructor() {\n        super(...arguments);\n        this.createEncoder = scatterPlotEncoderFactory.createSelector();\n        this.createMargin = Object(createMarginSelector["b" /* default */])();\n        this.renderChart = (dim) => {\n            const { width, height } = dim;\n            const { data, margin, theme, TooltipRenderer, encoding } = this.props;\n            const encoder = this.createEncoder(encoding);\n            const { channels } = encoder;\n            encoder.setDomainFromDataset(data);\n            const encodedData = data.map(d => (Object.assign({ x: channels.x.getValueFromDatum(d), y: channels.y.getValueFromDatum(d) }, d)));\n            const layout = Object(createXYChartLayoutWithTheme["a" /* default */])({\n                width,\n                height,\n                margin: this.createMargin(margin),\n                theme,\n                xEncoder: channels.x,\n                yEncoder: channels.y,\n            });\n            return layout.renderChartWithFrame((chartDim) => (react_default.a.createElement(XYChart["a" /* default */], { showYGrid: true, width: chartDim.width, height: chartDim.height, ariaLabel: "ScatterPlot", margin: layout.margin, renderTooltip: ({ datum }) => (react_default.a.createElement(TooltipRenderer, { datum: datum, encoder: encoder })), theme: theme, \n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                xScale: Object(convertScaleToDataUIScaleShape["a" /* default */])(channels.x.definition.scale), \n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                yScale: Object(convertScaleToDataUIScaleShape["a" /* default */])(channels.y.definition.scale) },\n                layout.renderXAxis(),\n                layout.renderYAxis(),\n                react_default.a.createElement(PointSeries_PointSeries, { key: Object(ChannelDef["a" /* isFieldDef */])(channels.x.definition) ? channels.x.definition.field : \'\', data: encodedData, fill: (d) => channels.fill.encodeDatum(d), fillOpacity: 0.5, stroke: (d) => channels.stroke.encodeDatum(d), size: (d) => channels.size.encodeDatum(d) }))));\n        };\n    }\n    render() {\n        const { className, data, width, height, encoding } = this.props;\n        return (react_default.a.createElement(WithLegend["a" /* default */], { className: `superset-chart-scatter-plot ${className}`, width: width, height: height, position: "top", renderLegend: Object(createRenderLegend["a" /* default */])(this.createEncoder(encoding), data, this.props), renderChart: this.renderChart }));\n    }\n}\nScatterPlot_ScatterPlot.defaultProps = ScatterPlot_defaultProps;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjM5Ny5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL3h5LWNoYXJ0L25vZGVfbW9kdWxlcy9AdngvdGV4dC9lc20vdXRpbC9nZXRTdHJpbmdXaWR0aC5qcz84Njk3Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL3h5LWNoYXJ0L25vZGVfbW9kdWxlcy9AdngvdGV4dC9lc20vVGV4dC5qcz80YTJiIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL3h5LWNoYXJ0L2VzbS9nbHlwaC9HbHlwaERvdENvbXBvbmVudC5qcz84MWZkIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL3h5LWNoYXJ0L2VzbS9zZXJpZXMvUG9pbnRTZXJpZXMuanM/MDQ1NSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvcHJlc2V0LWNoYXJ0LXh5L3NyYy9jb21wb25lbnRzL1NjYXR0ZXJQbG90L0VuY29kZXIudHM/NzFiNSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvcHJlc2V0LWNoYXJ0LXh5L3NyYy9jb21wb25lbnRzL1NjYXR0ZXJQbG90L0RlZmF1bHRUb29sdGlwUmVuZGVyZXIudHN4PzkyY2QiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9wbHVnaW5zL3ByZXNldC1jaGFydC14eS9zcmMvY29tcG9uZW50cy9TY2F0dGVyUGxvdC9TY2F0dGVyUGxvdC50c3g/ZWIwNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbWVtb2l6ZSBmcm9tICdsb2Rhc2gvbWVtb2l6ZSc7XG52YXIgTUVBU1VSRU1FTlRfRUxFTUVOVF9JRCA9ICdfX3JlYWN0X3N2Z190ZXh0X21lYXN1cmVtZW50X2lkJztcblxuZnVuY3Rpb24gZ2V0U3RyaW5nV2lkdGgoc3RyLCBzdHlsZSkge1xuICB0cnkge1xuICAgIC8vIENhbGN1bGF0ZSBsZW5ndGggb2YgZWFjaCB3b3JkIHRvIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIG51bWJlciBvZiB3b3JkcyBwZXIgbGluZVxuICAgIHZhciB0ZXh0RWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChNRUFTVVJFTUVOVF9FTEVNRU5UX0lEKTtcblxuICAgIGlmICghdGV4dEVsKSB7XG4gICAgICB2YXIgc3ZnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdzdmcnKTtcbiAgICAgIHN2Zy5zdHlsZS53aWR0aCA9IDA7XG4gICAgICBzdmcuc3R5bGUuaGVpZ2h0ID0gMDtcbiAgICAgIHN2Zy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICBzdmcuc3R5bGUudG9wID0gJy0xMDAlJztcbiAgICAgIHN2Zy5zdHlsZS5sZWZ0ID0gJy0xMDAlJztcbiAgICAgIHRleHRFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAndGV4dCcpO1xuICAgICAgdGV4dEVsLnNldEF0dHJpYnV0ZSgnaWQnLCBNRUFTVVJFTUVOVF9FTEVNRU5UX0lEKTtcbiAgICAgIHN2Zy5hcHBlbmRDaGlsZCh0ZXh0RWwpO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzdmcpO1xuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24odGV4dEVsLnN0eWxlLCBzdHlsZSk7XG4gICAgdGV4dEVsLnRleHRDb250ZW50ID0gc3RyO1xuICAgIHJldHVybiB0ZXh0RWwuZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBtZW1vaXplKGdldFN0cmluZ1dpZHRoLCBmdW5jdGlvbiAoc3RyLCBzdHlsZSkge1xuICByZXR1cm4gc3RyICsgXCJfXCIgKyBKU09OLnN0cmluZ2lmeShzdHlsZSk7XG59KTsiLCJmdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCByZWR1Y2VDU1NDYWxjIGZyb20gJ3JlZHVjZS1jc3MtY2FsYyc7XG5pbXBvcnQgZ2V0U3RyaW5nV2lkdGggZnJvbSAnLi91dGlsL2dldFN0cmluZ1dpZHRoJztcbnZhciBwcm9wVHlwZXMgPSB7XG4gIHNjYWxlVG9GaXQ6IFByb3BUeXBlcy5ib29sLFxuICBhbmdsZTogUHJvcFR5cGVzLm51bWJlcixcbiAgdGV4dEFuY2hvcjogUHJvcFR5cGVzLm9uZU9mKFsnc3RhcnQnLCAnbWlkZGxlJywgJ2VuZCcsICdpbmhlcml0J10pLFxuICB2ZXJ0aWNhbEFuY2hvcjogUHJvcFR5cGVzLm9uZU9mKFsnc3RhcnQnLCAnbWlkZGxlJywgJ2VuZCddKSxcbiAgc3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG4gIGlubmVyUmVmOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm9iamVjdF0pLFxuICB4OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG4gIHk6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgZHg6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgZHk6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgbGluZUhlaWdodDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxuICBjYXBIZWlnaHQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5hbnksXG4gIHdpZHRoOiBQcm9wVHlwZXMubnVtYmVyXG59O1xudmFyIGRlZmF1bHRQcm9wcyA9IHtcbiAgeDogMCxcbiAgeTogMCxcbiAgZHg6IDAsXG4gIGR5OiAwLFxuICBsaW5lSGVpZ2h0OiAnMWVtJyxcbiAgY2FwSGVpZ2h0OiAnMC43MWVtJyxcbiAgLy8gTWFnaWMgbnVtYmVyIGZyb20gZDNcbiAgc2NhbGVUb0ZpdDogZmFsc2UsXG4gIHRleHRBbmNob3I6ICdzdGFydCcsXG4gIHZlcnRpY2FsQW5jaG9yOiAnZW5kJyAvLyBkZWZhdWx0IFNWRyBiZWhhdmlvclxuXG59O1xuXG52YXIgVGV4dCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShUZXh0LCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBUZXh0KHByb3BzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XG4gICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICB3b3Jkc0J5TGluZXM6IFtdXG4gICAgfTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNhbWVsY2FzZVxuXG5cbiAgdmFyIF9wcm90byA9IFRleHQucHJvdG90eXBlO1xuXG4gIF9wcm90by5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID0gZnVuY3Rpb24gVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICB0aGlzLnVwZGF0ZVdvcmRzQnlMaW5lcyh0aGlzLnByb3BzLCB0cnVlKTtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FtZWxjYXNlXG4gIDtcblxuICBfcHJvdG8uVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICB2YXIgbmVlZENhbGN1bGF0ZSA9IHRoaXMucHJvcHMuY2hpbGRyZW4gIT09IG5leHRQcm9wcy5jaGlsZHJlbiB8fCB0aGlzLnByb3BzLnN0eWxlICE9PSBuZXh0UHJvcHMuc3R5bGU7XG4gICAgdGhpcy51cGRhdGVXb3Jkc0J5TGluZXMobmV4dFByb3BzLCBuZWVkQ2FsY3VsYXRlKTtcbiAgfTtcblxuICBfcHJvdG8udXBkYXRlV29yZHNCeUxpbmVzID0gZnVuY3Rpb24gdXBkYXRlV29yZHNCeUxpbmVzKHByb3BzLCBuZWVkQ2FsY3VsYXRlKSB7XG4gICAgLy8gT25seSBwZXJmb3JtIGNhbGN1bGF0aW9ucyBpZiB1c2luZyBmZWF0dXJlcyB0aGF0IHJlcXVpcmUgdGhlbSAobXVsdGlsaW5lLCBzY2FsZVRvRml0KVxuICAgIGlmIChwcm9wcy53aWR0aCB8fCBwcm9wcy5zY2FsZVRvRml0KSB7XG4gICAgICBpZiAobmVlZENhbGN1bGF0ZSkge1xuICAgICAgICB2YXIgd29yZHMgPSBwcm9wcy5jaGlsZHJlbiA/IHByb3BzLmNoaWxkcmVuLnRvU3RyaW5nKCkuc3BsaXQoLyg/Oig/IVxcdTAwQTArKVxccyspLykgOiBbXTtcbiAgICAgICAgdGhpcy53b3Jkc1dpdGhDb21wdXRlZFdpZHRoID0gd29yZHMubWFwKGZ1bmN0aW9uICh3b3JkKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdvcmQ6IHdvcmQsXG4gICAgICAgICAgICB3aWR0aDogZ2V0U3RyaW5nV2lkdGgod29yZCwgcHJvcHMuc3R5bGUpXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3BhY2VXaWR0aCA9IGdldFN0cmluZ1dpZHRoKFwiXFx4QTBcIiwgcHJvcHMuc3R5bGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgd29yZHNCeUxpbmVzID0gdGhpcy5jYWxjdWxhdGVXb3Jkc0J5TGluZXModGhpcy53b3Jkc1dpdGhDb21wdXRlZFdpZHRoLCB0aGlzLnNwYWNlV2lkdGgsIHByb3BzLndpZHRoKTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICB3b3Jkc0J5TGluZXM6IHdvcmRzQnlMaW5lc1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXBkYXRlV29yZHNXaXRob3V0Q2FsY3VsYXRlKHByb3BzKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnVwZGF0ZVdvcmRzV2l0aG91dENhbGN1bGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZVdvcmRzV2l0aG91dENhbGN1bGF0ZShwcm9wcykge1xuICAgIHZhciB3b3JkcyA9IHByb3BzLmNoaWxkcmVuID8gcHJvcHMuY2hpbGRyZW4udG9TdHJpbmcoKS5zcGxpdCgvKD86KD8hXFx1MDBBMCspXFxzKykvKSA6IFtdO1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgd29yZHNCeUxpbmVzOiBbe1xuICAgICAgICB3b3Jkczogd29yZHNcbiAgICAgIH1dXG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmNhbGN1bGF0ZVdvcmRzQnlMaW5lcyA9IGZ1bmN0aW9uIGNhbGN1bGF0ZVdvcmRzQnlMaW5lcyh3b3Jkc1dpdGhDb21wdXRlZFdpZHRoLCBzcGFjZVdpZHRoLCBsaW5lV2lkdGgpIHtcbiAgICB2YXIgc2NhbGVUb0ZpdCA9IHRoaXMucHJvcHMuc2NhbGVUb0ZpdDtcbiAgICByZXR1cm4gd29yZHNXaXRoQ29tcHV0ZWRXaWR0aC5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgX3JlZikge1xuICAgICAgdmFyIHdvcmQgPSBfcmVmLndvcmQsXG4gICAgICAgICAgd2lkdGggPSBfcmVmLndpZHRoO1xuICAgICAgdmFyIGN1cnJlbnRMaW5lID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXTtcblxuICAgICAgaWYgKGN1cnJlbnRMaW5lICYmIChsaW5lV2lkdGggPT0gbnVsbCB8fCBzY2FsZVRvRml0IHx8IGN1cnJlbnRMaW5lLndpZHRoICsgd2lkdGggKyBzcGFjZVdpZHRoIDwgbGluZVdpZHRoKSkge1xuICAgICAgICAvLyBXb3JkIGNhbiBiZSBhZGRlZCB0byBhbiBleGlzdGluZyBsaW5lXG4gICAgICAgIGN1cnJlbnRMaW5lLndvcmRzLnB1c2god29yZCk7XG4gICAgICAgIGN1cnJlbnRMaW5lLndpZHRoICs9IHdpZHRoICsgc3BhY2VXaWR0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFkZCBmaXJzdCB3b3JkIHRvIGxpbmUgb3Igd29yZCBpcyB0b28gbG9uZyB0byBzY2FsZVRvRml0IG9uIGV4aXN0aW5nIGxpbmVcbiAgICAgICAgdmFyIG5ld0xpbmUgPSB7XG4gICAgICAgICAgd29yZHM6IFt3b3JkXSxcbiAgICAgICAgICB3aWR0aDogd2lkdGhcbiAgICAgICAgfTtcbiAgICAgICAgcmVzdWx0LnB1c2gobmV3TGluZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwgW10pO1xuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgZHggPSBfdGhpcyRwcm9wcy5keCxcbiAgICAgICAgZHkgPSBfdGhpcyRwcm9wcy5keSxcbiAgICAgICAgdGV4dEFuY2hvciA9IF90aGlzJHByb3BzLnRleHRBbmNob3IsXG4gICAgICAgIHZlcnRpY2FsQW5jaG9yID0gX3RoaXMkcHJvcHMudmVydGljYWxBbmNob3IsXG4gICAgICAgIHNjYWxlVG9GaXQgPSBfdGhpcyRwcm9wcy5zY2FsZVRvRml0LFxuICAgICAgICBhbmdsZSA9IF90aGlzJHByb3BzLmFuZ2xlLFxuICAgICAgICBsaW5lSGVpZ2h0ID0gX3RoaXMkcHJvcHMubGluZUhlaWdodCxcbiAgICAgICAgY2FwSGVpZ2h0ID0gX3RoaXMkcHJvcHMuY2FwSGVpZ2h0LFxuICAgICAgICBpbm5lclJlZiA9IF90aGlzJHByb3BzLmlubmVyUmVmLFxuICAgICAgICB0ZXh0UHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfdGhpcyRwcm9wcywgW1wiZHhcIiwgXCJkeVwiLCBcInRleHRBbmNob3JcIiwgXCJ2ZXJ0aWNhbEFuY2hvclwiLCBcInNjYWxlVG9GaXRcIiwgXCJhbmdsZVwiLCBcImxpbmVIZWlnaHRcIiwgXCJjYXBIZWlnaHRcIiwgXCJpbm5lclJlZlwiXSk7XG5cbiAgICB2YXIgd29yZHNCeUxpbmVzID0gdGhpcy5zdGF0ZS53b3Jkc0J5TGluZXM7XG4gICAgdmFyIHggPSB0ZXh0UHJvcHMueCxcbiAgICAgICAgeSA9IHRleHRQcm9wcy55O1xuICAgIHZhciBzdGFydER5O1xuXG4gICAgc3dpdGNoICh2ZXJ0aWNhbEFuY2hvcikge1xuICAgICAgY2FzZSAnc3RhcnQnOlxuICAgICAgICBzdGFydER5ID0gcmVkdWNlQ1NTQ2FsYyhcImNhbGMoXCIgKyBjYXBIZWlnaHQgKyBcIilcIik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICBzdGFydER5ID0gcmVkdWNlQ1NTQ2FsYyhcImNhbGMoXCIgKyAod29yZHNCeUxpbmVzLmxlbmd0aCAtIDEpIC8gMiArIFwiICogLVwiICsgbGluZUhlaWdodCArIFwiICsgKFwiICsgY2FwSGVpZ2h0ICsgXCIgLyAyKSlcIik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzdGFydER5ID0gcmVkdWNlQ1NTQ2FsYyhcImNhbGMoXCIgKyAod29yZHNCeUxpbmVzLmxlbmd0aCAtIDEpICsgXCIgKiAtXCIgKyBsaW5lSGVpZ2h0ICsgXCIpXCIpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgdHJhbnNmb3JtcyA9IFtdO1xuXG4gICAgaWYgKHNjYWxlVG9GaXQgJiYgd29yZHNCeUxpbmVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBsaW5lV2lkdGggPSB3b3Jkc0J5TGluZXNbMF0ud2lkdGg7XG4gICAgICB2YXIgc3ggPSB0aGlzLnByb3BzLndpZHRoIC8gbGluZVdpZHRoO1xuICAgICAgdmFyIHN5ID0gc3g7XG4gICAgICB2YXIgb3JpZ2luWCA9IHggLSBzeCAqIHg7XG4gICAgICB2YXIgb3JpZ2luWSA9IHkgLSBzeSAqIHk7XG4gICAgICB0cmFuc2Zvcm1zLnB1c2goXCJtYXRyaXgoXCIgKyBzeCArIFwiLCAwLCAwLCBcIiArIHN5ICsgXCIsIFwiICsgb3JpZ2luWCArIFwiLCBcIiArIG9yaWdpblkgKyBcIilcIik7XG4gICAgfVxuXG4gICAgaWYgKGFuZ2xlKSB7XG4gICAgICB0cmFuc2Zvcm1zLnB1c2goXCJyb3RhdGUoXCIgKyBhbmdsZSArIFwiLCBcIiArIHggKyBcIiwgXCIgKyB5ICsgXCIpXCIpO1xuICAgIH1cblxuICAgIGlmICh0cmFuc2Zvcm1zLmxlbmd0aCA+IDApIHtcbiAgICAgIHRleHRQcm9wcy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1zLmpvaW4oJyAnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7XG4gICAgICByZWY6IGlubmVyUmVmLFxuICAgICAgeDogZHgsXG4gICAgICB5OiBkeSxcbiAgICAgIGZvbnRTaXplOiB0ZXh0UHJvcHMuZm9udFNpemUsXG4gICAgICBzdHlsZToge1xuICAgICAgICBvdmVyZmxvdzogJ3Zpc2libGUnXG4gICAgICB9XG4gICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInRleHRcIiwgX2V4dGVuZHMoe30sIHRleHRQcm9wcywge1xuICAgICAgdGV4dEFuY2hvcjogdGV4dEFuY2hvclxuICAgIH0pLCB3b3Jkc0J5TGluZXMubWFwKGZ1bmN0aW9uIChsaW5lLCBpbmRleCkge1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0c3BhblwiLCB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIGR5OiBpbmRleCA9PT0gMCA/IHN0YXJ0RHkgOiBsaW5lSGVpZ2h0LFxuICAgICAgICBrZXk6IGluZGV4XG4gICAgICB9LCBsaW5lLndvcmRzLmpvaW4oJyAnKSk7XG4gICAgfSkpKTtcbiAgfTtcblxuICByZXR1cm4gVGV4dDtcbn0oQ29tcG9uZW50KTtcblxuVGV4dC5wcm9wVHlwZXMgPSBwcm9wVHlwZXM7XG5UZXh0LmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbmV4cG9ydCBkZWZhdWx0IFRleHQ7IiwiZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuLyogZXNsaW50IHJlYWN0L2RlZmF1bHQtcHJvcHMtbWF0Y2gtcHJvcC10eXBlczogJ29mZicgKi9cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBHbHlwaERvdCB9IGZyb20gJ0B2eC9nbHlwaCc7XG5pbXBvcnQgeyBwb2ludENvbXBvbmVudFByb3BUeXBlcyB9IGZyb20gJy4uL3V0aWxzL3Byb3BTaGFwZXMnO1xudmFyIGRlZmF1bHRQcm9wVHlwZXMgPSB7XG4gIG9uTW91c2VNb3ZlOiBudWxsLFxuICBvbk1vdXNlTGVhdmU6IG51bGwsXG4gIHN0cm9rZURhc2hhcnJheTogbnVsbFxufTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEdseXBoRG90Q29tcG9uZW50KF9yZWYpIHtcbiAgdmFyIHggPSBfcmVmLngsXG4gICAgICB5ID0gX3JlZi55LFxuICAgICAgc2l6ZSA9IF9yZWYuc2l6ZSxcbiAgICAgIGZpbGwgPSBfcmVmLmZpbGwsXG4gICAgICBmaWxsT3BhY2l0eSA9IF9yZWYuZmlsbE9wYWNpdHksXG4gICAgICBzdHJva2UgPSBfcmVmLnN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoID0gX3JlZi5zdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZURhc2hhcnJheSA9IF9yZWYuc3Ryb2tlRGFzaGFycmF5LFxuICAgICAgb25DbGljayA9IF9yZWYub25DbGljayxcbiAgICAgIG9uTW91c2VNb3ZlID0gX3JlZi5vbk1vdXNlTW92ZSxcbiAgICAgIG9uTW91c2VMZWF2ZSA9IF9yZWYub25Nb3VzZUxlYXZlLFxuICAgICAgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgIGRhdHVtID0gX3JlZi5kYXR1bTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoR2x5cGhEb3QsIHtcbiAgICBjeDogeCxcbiAgICBjeTogeSxcbiAgICByOiBzaXplLFxuICAgIGZpbGw6IGZpbGwsXG4gICAgZmlsbE9wYWNpdHk6IGZpbGxPcGFjaXR5LFxuICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICBzdHJva2VEYXNoYXJyYXk6IHN0cm9rZURhc2hhcnJheSxcbiAgICBvbkNsaWNrOiBvbkNsaWNrICYmIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgb25DbGljayh7XG4gICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgZGF0dW06IGRhdHVtLFxuICAgICAgICBjb2xvcjogZmlsbFxuICAgICAgfSk7XG4gICAgfSxcbiAgICBvbk1vdXNlTW92ZTogb25Nb3VzZU1vdmUgJiYgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBvbk1vdXNlTW92ZSh7XG4gICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgZGF0dW06IGRhdHVtLFxuICAgICAgICBjb2xvcjogZmlsbFxuICAgICAgfSk7XG4gICAgfSxcbiAgICBvbk1vdXNlTGVhdmU6IG9uTW91c2VMZWF2ZVxuICB9KTtcbn1cbkdseXBoRG90Q29tcG9uZW50LnByb3BUeXBlcyA9IF9leHRlbmRzKHt9LCBwb2ludENvbXBvbmVudFByb3BUeXBlcyk7XG5HbHlwaERvdENvbXBvbmVudC5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcFR5cGVzOyIsImZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5pbXBvcnQgeyBzdmdMYWJlbCwgY29sb3IgfSBmcm9tICdAZGF0YS11aS90aGVtZSc7XG5pbXBvcnQgeyBGb2N1c0JsdXJIYW5kbGVyIH0gZnJvbSAnQGRhdGEtdWkvc2hhcmVkJztcbmltcG9ydCB7IEdyb3VwIH0gZnJvbSAnQHZ4L2dyb3VwJztcbmltcG9ydCB7IFRleHQgfSBmcm9tICdAdngvdGV4dCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNhbGxPclZhbHVlLCBpc0RlZmluZWQgfSBmcm9tICcuLi91dGlscy9jaGFydFV0aWxzJztcbmltcG9ydCBHbHlwaERvdENvbXBvbmVudCBmcm9tICcuLi9nbHlwaC9HbHlwaERvdENvbXBvbmVudCc7XG5pbXBvcnQgeyBwb2ludFNlcmllc0RhdGFTaGFwZSB9IGZyb20gJy4uL3V0aWxzL3Byb3BTaGFwZXMnO1xuaW1wb3J0IHNoYXJlZFNlcmllc1Byb3BzIGZyb20gJy4uL3V0aWxzL3NoYXJlZFNlcmllc1Byb3BzJztcbmV4cG9ydCB2YXIgcHJvcFR5cGVzID0gX2V4dGVuZHMoe30sIHNoYXJlZFNlcmllc1Byb3BzLCB7XG4gIGRhdGE6IHBvaW50U2VyaWVzRGF0YVNoYXBlLmlzUmVxdWlyZWQsXG4gIGRlZmF1bHRMYWJlbFByb3BzOiBQcm9wVHlwZXMub2JqZWN0LFxuICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlYWN0L2ZvcmJpZC1wcm9wLXR5cGVzXG4gIHBvaW50Q29tcG9uZW50OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLmVsZW1lbnRdKSxcbiAgZmlsbDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgZmlsbE9wYWNpdHk6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gIHJlbmRlckxhYmVsOiBQcm9wVHlwZXMuZnVuYyxcbiAgc3Ryb2tlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLnN0cmluZ10pLFxuICBzdHJva2VXaWR0aDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgc3Ryb2tlRGFzaGFycmF5OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLnN0cmluZ10pLFxuICBzaXplOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm51bWJlcl0pXG59KTtcbnZhciBiYXNlTGFiZWwgPSBzdmdMYWJlbC5iYXNlTGFiZWw7XG5leHBvcnQgdmFyIGRlZmF1bHRMYWJlbFByb3BzID0gX2V4dGVuZHMoe30sIGJhc2VMYWJlbCwge1xuICB0ZXh0QW5jaG9yOiAnc3RhcnQnLFxuICB2ZXJ0aWNhbEFuY2hvcjogJ3N0YXJ0JyxcbiAgZHg6ICcwLjI1ZW0nLFxuICBkeTogJzAuMjVlbScsXG4gIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgc3Ryb2tlOiAnI2ZmZicsXG4gIHN0cm9rZVdpZHRoOiAyLFxuICBwYWludE9yZGVyOiAnc3Ryb2tlJyxcbiAgZm9udFNpemU6IDEyXG59KTtcbmV4cG9ydCB2YXIgZGVmYXVsdFByb3BzID0ge1xuICBkZWZhdWx0TGFiZWxQcm9wczogZGVmYXVsdExhYmVsUHJvcHMsXG5cbiAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QvcHJvcC10eXBlcyAqL1xuICByZW5kZXJMYWJlbDogZnVuY3Rpb24gcmVuZGVyTGFiZWwoX3JlZikge1xuICAgIHZhciBkYXR1bSA9IF9yZWYuZGF0dW0sXG4gICAgICAgIGxhYmVsUHJvcHMgPSBfcmVmLmxhYmVsUHJvcHM7XG4gICAgcmV0dXJuIGRhdHVtLmxhYmVsID8gUmVhY3QuY3JlYXRlRWxlbWVudChUZXh0LCBsYWJlbFByb3BzLCBkYXR1bS5sYWJlbCkgOiBudWxsO1xuICB9LFxuXG4gIC8qIGVzbGludC1lbmFibGUgcmVhY3QvcHJvcC10eXBlcyAqL1xuICBwb2ludENvbXBvbmVudDogR2x5cGhEb3RDb21wb25lbnQsXG4gIHNpemU6IDQsXG4gIGZpbGw6IGNvbG9yLmRlZmF1bHQsXG4gIGZpbGxPcGFjaXR5OiAwLjgsXG4gIHN0cm9rZTogJyNGRkZGRkYnLFxuICBzdHJva2VEYXNoYXJyYXk6IG51bGwsXG4gIHN0cm9rZVdpZHRoOiAxXG59O1xudmFyIG5vRXZlbnRzU3R5bGVzID0ge1xuICBwb2ludGVyRXZlbnRzOiAnbm9uZSdcbn07XG5cbnZhciBQb2ludFNlcmllcyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1JlYWN0JFB1cmVDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoUG9pbnRTZXJpZXMsIF9SZWFjdCRQdXJlQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBQb2ludFNlcmllcygpIHtcbiAgICByZXR1cm4gX1JlYWN0JFB1cmVDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFBvaW50U2VyaWVzLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIGRhdGEgPSBfdGhpcyRwcm9wcy5kYXRhLFxuICAgICAgICBsYWJlbFByb3BzID0gX3RoaXMkcHJvcHMuZGVmYXVsdExhYmVsUHJvcHMsXG4gICAgICAgIGRpc2FibGVNb3VzZUV2ZW50cyA9IF90aGlzJHByb3BzLmRpc2FibGVNb3VzZUV2ZW50cyxcbiAgICAgICAgZmlsbCA9IF90aGlzJHByb3BzLmZpbGwsXG4gICAgICAgIGZpbGxPcGFjaXR5ID0gX3RoaXMkcHJvcHMuZmlsbE9wYWNpdHksXG4gICAgICAgIHJlbmRlckxhYmVsID0gX3RoaXMkcHJvcHMucmVuZGVyTGFiZWwsXG4gICAgICAgIHNpemUgPSBfdGhpcyRwcm9wcy5zaXplLFxuICAgICAgICBzdHJva2UgPSBfdGhpcyRwcm9wcy5zdHJva2UsXG4gICAgICAgIHN0cm9rZVdpZHRoID0gX3RoaXMkcHJvcHMuc3Ryb2tlV2lkdGgsXG4gICAgICAgIHN0cm9rZURhc2hhcnJheSA9IF90aGlzJHByb3BzLnN0cm9rZURhc2hhcnJheSxcbiAgICAgICAgeFNjYWxlID0gX3RoaXMkcHJvcHMueFNjYWxlLFxuICAgICAgICB5U2NhbGUgPSBfdGhpcyRwcm9wcy55U2NhbGUsXG4gICAgICAgIG9uQ2xpY2sgPSBfdGhpcyRwcm9wcy5vbkNsaWNrLFxuICAgICAgICBvbk1vdXNlTW92ZSA9IF90aGlzJHByb3BzLm9uTW91c2VNb3ZlLFxuICAgICAgICBvbk1vdXNlTGVhdmUgPSBfdGhpcyRwcm9wcy5vbk1vdXNlTGVhdmUsXG4gICAgICAgIHBvaW50Q29tcG9uZW50ID0gX3RoaXMkcHJvcHMucG9pbnRDb21wb25lbnQ7XG4gICAgaWYgKCF4U2NhbGUgfHwgIXlTY2FsZSkgcmV0dXJuIG51bGw7XG4gICAgdmFyIExhYmVscyA9IFtdO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEdyb3VwLCB7XG4gICAgICBzdHlsZTogZGlzYWJsZU1vdXNlRXZlbnRzID8gbm9FdmVudHNTdHlsZXMgOiBudWxsXG4gICAgfSwgZGF0YS5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgIHZhciB4VmFsID0gZC54O1xuICAgICAgdmFyIHlWYWwgPSBkLnk7XG4gICAgICB2YXIgZGVmaW5lZCA9IGlzRGVmaW5lZCh4VmFsKSAmJiBpc0RlZmluZWQoeVZhbCk7XG4gICAgICB2YXIgeCA9IHhTY2FsZSh4VmFsKTtcbiAgICAgIHZhciB5ID0geVNjYWxlKHlWYWwpO1xuICAgICAgdmFyIGNvbXB1dGVkRmlsbCA9IGQuZmlsbCB8fCBjYWxsT3JWYWx1ZShmaWxsLCBkLCBpKTtcbiAgICAgIHZhciBrZXkgPSBkLnggKyBcIi1cIiArIGk7XG4gICAgICB2YXIgY29tcHV0ZWRTaXplID0gZC5zaXplIHx8IGNhbGxPclZhbHVlKHNpemUsIGQsIGkpO1xuICAgICAgdmFyIGNvbXB1dGVkRmlsbE9wYWNpdHkgPSBkLmZpbGxPcGFjaXR5IHx8IGNhbGxPclZhbHVlKGZpbGxPcGFjaXR5LCBkLCBpKTtcbiAgICAgIHZhciBjb21wdXRlZFN0cm9rZSA9IGQuc3Ryb2tlIHx8IGNhbGxPclZhbHVlKHN0cm9rZSwgZCwgaSk7XG4gICAgICB2YXIgY29tcHV0ZWRTdHJva2VXaWR0aCA9IGQuc3Ryb2tlV2lkdGggfHwgY2FsbE9yVmFsdWUoc3Ryb2tlV2lkdGgsIGQsIGkpO1xuICAgICAgdmFyIGNvbXB1dGVkU3Ryb2tlRGFzaGFycmF5ID0gZC5zdHJva2VEYXNoYXJyYXkgfHwgY2FsbE9yVmFsdWUoc3Ryb2tlRGFzaGFycmF5LCBkLCBpKTtcblxuICAgICAgaWYgKGRlZmluZWQgJiYgcmVuZGVyTGFiZWwpIHtcbiAgICAgICAgdmFyIExhYmVsID0gcmVuZGVyTGFiZWwoe1xuICAgICAgICAgIGRhdHVtOiBkLFxuICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgIGxhYmVsUHJvcHM6IF9leHRlbmRzKHtcbiAgICAgICAgICAgIGtleToga2V5XG4gICAgICAgICAgfSwgbGFiZWxQcm9wcywge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHlcbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKExhYmVsKSBMYWJlbHMucHVzaChMYWJlbCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeSxcbiAgICAgICAgc2l6ZTogY29tcHV0ZWRTaXplLFxuICAgICAgICBmaWxsOiBjb21wdXRlZEZpbGwsXG4gICAgICAgIGZpbGxPcGFjaXR5OiBjb21wdXRlZEZpbGxPcGFjaXR5LFxuICAgICAgICBzdHJva2U6IGNvbXB1dGVkU3Ryb2tlLFxuICAgICAgICBzdHJva2VXaWR0aDogY29tcHV0ZWRTdHJva2VXaWR0aCxcbiAgICAgICAgc3Ryb2tlRGFzaGFycmF5OiBjb21wdXRlZFN0cm9rZURhc2hhcnJheSxcbiAgICAgICAgb25DbGljazogZGlzYWJsZU1vdXNlRXZlbnRzID8gbnVsbCA6IG9uQ2xpY2ssXG4gICAgICAgIG9uTW91c2VNb3ZlOiBkaXNhYmxlTW91c2VFdmVudHMgPyBudWxsIDogb25Nb3VzZU1vdmUsXG4gICAgICAgIG9uTW91c2VMZWF2ZTogZGlzYWJsZU1vdXNlRXZlbnRzID8gbnVsbCA6IG9uTW91c2VMZWF2ZSxcbiAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgZGF0dW06IGRcbiAgICAgIH07XG4gICAgICByZXR1cm4gZGVmaW5lZCAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KEZvY3VzQmx1ckhhbmRsZXIsIHtcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHhsaW5rSHJlZjogXCIjXCIsXG4gICAgICAgIG9uQmx1cjogZGlzYWJsZU1vdXNlRXZlbnRzID8gbnVsbCA6IHByb3BzLm9uTW91c2VMZWF2ZSxcbiAgICAgICAgb25Gb2N1czogZGlzYWJsZU1vdXNlRXZlbnRzID8gbnVsbCA6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIG9uTW91c2VNb3ZlKHtcbiAgICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICBkYXR1bTogZCxcbiAgICAgICAgICAgIGNvbG9yOiBjb21wdXRlZEZpbGwsXG4gICAgICAgICAgICBpbmRleDogaVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KHBvaW50Q29tcG9uZW50LCBwcm9wcykpO1xuICAgIH0pLCBMYWJlbHMubWFwKGZ1bmN0aW9uIChMYWJlbCkge1xuICAgICAgcmV0dXJuIExhYmVsO1xuICAgIH0pKTtcbiAgfTtcblxuICByZXR1cm4gUG9pbnRTZXJpZXM7XG59KFJlYWN0LlB1cmVDb21wb25lbnQpO1xuXG5leHBvcnQgeyBQb2ludFNlcmllcyBhcyBkZWZhdWx0IH07XG5Qb2ludFNlcmllcy5wcm9wVHlwZXMgPSBwcm9wVHlwZXM7XG5Qb2ludFNlcmllcy5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5Qb2ludFNlcmllcy5kaXNwbGF5TmFtZSA9ICdQb2ludFNlcmllcyc7IiwiaW1wb3J0IHsgY3JlYXRlRW5jb2RlckZhY3RvcnksIEVuY29kZXIsIERlcml2ZUVuY29kaW5nLCBEZXJpdmVDaGFubmVsT3V0cHV0cyB9IGZyb20gJ2VuY29kYWJsZSc7XG5cbmV4cG9ydCB0eXBlIFNjYXR0ZXJQbG90RW5jb2RpbmdDb25maWcgPSB7XG4gIHg6IFsnWCcsIG51bWJlcl07XG4gIHk6IFsnWScsIG51bWJlcl07XG4gIGZpbGw6IFsnQ29sb3InLCBzdHJpbmddO1xuICBncm91cDogWydDYXRlZ29yeScsIHN0cmluZywgJ211bHRpcGxlJ107XG4gIHNpemU6IFsnTnVtZXJpYycsIG51bWJlcl07XG4gIHN0cm9rZTogWydDb2xvcicsIHN0cmluZ107XG4gIHRvb2x0aXA6IFsnVGV4dCcsIHN0cmluZywgJ211bHRpcGxlJ107XG59O1xuXG5leHBvcnQgY29uc3Qgc2NhdHRlclBsb3RFbmNvZGVyRmFjdG9yeSA9IGNyZWF0ZUVuY29kZXJGYWN0b3J5PFNjYXR0ZXJQbG90RW5jb2RpbmdDb25maWc+KHtcbiAgY2hhbm5lbFR5cGVzOiB7XG4gICAgeDogJ1gnLFxuICAgIHk6ICdZJyxcbiAgICBmaWxsOiAnQ29sb3InLFxuICAgIGdyb3VwOiAnQ2F0ZWdvcnknLFxuICAgIHNpemU6ICdOdW1lcmljJyxcbiAgICBzdHJva2U6ICdDb2xvcicsXG4gICAgdG9vbHRpcDogJ1RleHQnLFxuICB9LFxuICBkZWZhdWx0RW5jb2Rpbmc6IHtcbiAgICB4OiB7IGZpZWxkOiAneCcsIHR5cGU6ICdxdWFudGl0YXRpdmUnIH0sXG4gICAgeTogeyBmaWVsZDogJ3knLCB0eXBlOiAncXVhbnRpdGF0aXZlJyB9LFxuICAgIGZpbGw6IHsgdmFsdWU6ICcjMjIyJyB9LFxuICAgIGdyb3VwOiBbXSxcbiAgICBzaXplOiB7IHZhbHVlOiA1IH0sXG4gICAgc3Ryb2tlOiB7IHZhbHVlOiAnbm9uZScgfSxcbiAgICB0b29sdGlwOiBbXSxcbiAgfSxcbn0pO1xuXG5leHBvcnQgdHlwZSBTY2F0dGVyUGxvdEVuY29kaW5nID0gRGVyaXZlRW5jb2Rpbmc8U2NhdHRlclBsb3RFbmNvZGluZ0NvbmZpZz47XG5cbmV4cG9ydCB0eXBlIFNjYXR0ZXJQbG90RW5jb2RlciA9IEVuY29kZXI8U2NhdHRlclBsb3RFbmNvZGluZ0NvbmZpZz47XG5cbmV4cG9ydCB0eXBlIFNjYXR0ZXJQbG90Q2hhbm5lbE91dHB1dHMgPSBEZXJpdmVDaGFubmVsT3V0cHV0czxTY2F0dGVyUGxvdEVuY29kaW5nQ29uZmlnPjtcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBUb29sdGlwRnJhbWUsIFRvb2x0aXBUYWJsZSB9IGZyb20gJ0BzdXBlcnNldC11aS9jb3JlJztcbmltcG9ydCB7IGlzRmllbGREZWYgfSBmcm9tICdlbmNvZGFibGUnO1xuaW1wb3J0IHsgVG9vbHRpcFByb3BzIH0gZnJvbSAnLi9TY2F0dGVyUGxvdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERlZmF1bHRUb29sdGlwUmVuZGVyZXIoeyBkYXR1bSwgZW5jb2RlciB9OiBUb29sdGlwUHJvcHMpIHtcbiAgY29uc3QgeyBjaGFubmVscyB9ID0gZW5jb2RlcjtcbiAgY29uc3QgeyB4LCB5LCBzaXplLCBmaWxsLCBzdHJva2UgfSA9IGNoYW5uZWxzO1xuXG4gIGNvbnN0IHRvb2x0aXBSb3dzID0gW1xuICAgIHsga2V5OiAneCcsIGtleUNvbHVtbjogeC5nZXRUaXRsZSgpLCB2YWx1ZUNvbHVtbjogeC5mb3JtYXREYXR1bShkYXR1bSkgfSxcbiAgICB7IGtleTogJ3knLCBrZXlDb2x1bW46IHkuZ2V0VGl0bGUoKSwgdmFsdWVDb2x1bW46IHkuZm9ybWF0RGF0dW0oZGF0dW0pIH0sXG4gIF07XG5cbiAgaWYgKGlzRmllbGREZWYoZmlsbC5kZWZpbml0aW9uKSkge1xuICAgIHRvb2x0aXBSb3dzLnB1c2goe1xuICAgICAga2V5OiAnZmlsbCcsXG4gICAgICBrZXlDb2x1bW46IGZpbGwuZ2V0VGl0bGUoKSxcbiAgICAgIHZhbHVlQ29sdW1uOiBmaWxsLmZvcm1hdERhdHVtKGRhdHVtKSxcbiAgICB9KTtcbiAgfVxuICBpZiAoaXNGaWVsZERlZihzdHJva2UuZGVmaW5pdGlvbikpIHtcbiAgICB0b29sdGlwUm93cy5wdXNoKHtcbiAgICAgIGtleTogJ3N0cm9rZScsXG4gICAgICBrZXlDb2x1bW46IHN0cm9rZS5nZXRUaXRsZSgpLFxuICAgICAgdmFsdWVDb2x1bW46IHN0cm9rZS5mb3JtYXREYXR1bShkYXR1bSksXG4gICAgfSk7XG4gIH1cbiAgaWYgKGlzRmllbGREZWYoc2l6ZS5kZWZpbml0aW9uKSkge1xuICAgIHRvb2x0aXBSb3dzLnB1c2goe1xuICAgICAga2V5OiAnc2l6ZScsXG4gICAgICBrZXlDb2x1bW46IHNpemUuZ2V0VGl0bGUoKSxcbiAgICAgIHZhbHVlQ29sdW1uOiBzaXplLmZvcm1hdERhdHVtKGRhdHVtKSxcbiAgICB9KTtcbiAgfVxuICBjaGFubmVscy5ncm91cC5mb3JFYWNoKGcgPT4ge1xuICAgIHRvb2x0aXBSb3dzLnB1c2goe1xuICAgICAga2V5OiBgJHtnLm5hbWV9YCxcbiAgICAgIGtleUNvbHVtbjogZy5nZXRUaXRsZSgpLFxuICAgICAgdmFsdWVDb2x1bW46IGcuZm9ybWF0RGF0dW0oZGF0dW0pLFxuICAgIH0pO1xuICB9KTtcbiAgY2hhbm5lbHMudG9vbHRpcC5mb3JFYWNoKGcgPT4ge1xuICAgIHRvb2x0aXBSb3dzLnB1c2goe1xuICAgICAga2V5OiBgJHtnLm5hbWV9YCxcbiAgICAgIGtleUNvbHVtbjogZy5nZXRUaXRsZSgpLFxuICAgICAgdmFsdWVDb2x1bW46IGcuZm9ybWF0RGF0dW0oZGF0dW0pLFxuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gKFxuICAgIDxUb29sdGlwRnJhbWU+XG4gICAgICA8VG9vbHRpcFRhYmxlIGRhdGE9e3Rvb2x0aXBSb3dzfSAvPlxuICAgIDwvVG9vbHRpcEZyYW1lPlxuICApO1xufVxuIiwiaW1wb3J0IFJlYWN0LCB7IFB1cmVDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBYWUNoYXJ0LCBQb2ludFNlcmllcyB9IGZyb20gJ0BkYXRhLXVpL3h5LWNoYXJ0JztcbmltcG9ydCB7IGNoYXJ0VGhlbWUsIENoYXJ0VGhlbWUgfSBmcm9tICdAZGF0YS11aS90aGVtZSc7XG5pbXBvcnQgeyBXaXRoTGVnZW5kLCBNYXJnaW4sIERpbWVuc2lvbiB9IGZyb20gJ0BzdXBlcnNldC11aS9jb3JlJztcbmltcG9ydCB7IGlzRmllbGREZWYsIERhdGFzZXQsIFBsYWluT2JqZWN0IH0gZnJvbSAnZW5jb2RhYmxlJztcblxuaW1wb3J0IHtcbiAgc2NhdHRlclBsb3RFbmNvZGVyRmFjdG9yeSxcbiAgU2NhdHRlclBsb3RFbmNvZGVyLFxuICBTY2F0dGVyUGxvdEVuY29kaW5nQ29uZmlnLFxuICBTY2F0dGVyUGxvdEVuY29kaW5nLFxufSBmcm9tICcuL0VuY29kZXInO1xuaW1wb3J0IGNyZWF0ZU1hcmdpblNlbGVjdG9yLCB7IERFRkFVTFRfTUFSR0lOIH0gZnJvbSAnLi4vLi4vdXRpbHMvY3JlYXRlTWFyZ2luU2VsZWN0b3InO1xuaW1wb3J0IERlZmF1bHRUb29sdGlwUmVuZGVyZXIgZnJvbSAnLi9EZWZhdWx0VG9vbHRpcFJlbmRlcmVyJztcbmltcG9ydCBjb252ZXJ0U2NhbGVUb0RhdGFVSVNjYWxlIGZyb20gJy4uLy4uL3V0aWxzL2NvbnZlcnRTY2FsZVRvRGF0YVVJU2NhbGVTaGFwZSc7XG5pbXBvcnQgY3JlYXRlWFlDaGFydExheW91dFdpdGhUaGVtZSBmcm9tICcuLi8uLi91dGlscy9jcmVhdGVYWUNoYXJ0TGF5b3V0V2l0aFRoZW1lJztcbmltcG9ydCBjcmVhdGVSZW5kZXJMZWdlbmQgZnJvbSAnLi4vbGVnZW5kL2NyZWF0ZVJlbmRlckxlZ2VuZCc7XG5pbXBvcnQgeyBMZWdlbmRIb29rcyB9IGZyb20gJy4uL2xlZ2VuZC90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVG9vbHRpcFByb3BzIHtcbiAgZGF0dW06IFBsYWluT2JqZWN0O1xuICBlbmNvZGVyOiBTY2F0dGVyUGxvdEVuY29kZXI7XG59XG5cbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgY2xhc3NOYW1lOiAnJyxcbiAgbWFyZ2luOiBERUZBVUxUX01BUkdJTixcbiAgZW5jb2Rpbmc6IHt9LFxuICB0aGVtZTogY2hhcnRUaGVtZSxcbiAgVG9vbHRpcFJlbmRlcmVyOiBEZWZhdWx0VG9vbHRpcFJlbmRlcmVyLFxufSBhcyBjb25zdDtcblxuZXhwb3J0IHR5cGUgSG9va1Byb3BzID0ge1xuICBUb29sdGlwUmVuZGVyZXI/OiBSZWFjdC5Db21wb25lbnRUeXBlPFRvb2x0aXBQcm9wcz47XG59ICYgTGVnZW5kSG9va3M8U2NhdHRlclBsb3RFbmNvZGluZ0NvbmZpZz47XG5cbnR5cGUgUHJvcHMgPSB7XG4gIGNsYXNzTmFtZT86IHN0cmluZztcbiAgd2lkdGg6IHN0cmluZyB8IG51bWJlcjtcbiAgaGVpZ2h0OiBzdHJpbmcgfCBudW1iZXI7XG4gIG1hcmdpbj86IE1hcmdpbjtcbiAgZGF0YTogRGF0YXNldDtcbiAgZW5jb2Rpbmc/OiBQYXJ0aWFsPFNjYXR0ZXJQbG90RW5jb2Rpbmc+O1xuICB0aGVtZT86IENoYXJ0VGhlbWU7XG59ICYgSG9va1Byb3BzICZcbiAgUmVhZG9ubHk8dHlwZW9mIGRlZmF1bHRQcm9wcz47XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjYXR0ZXJQbG90IGV4dGVuZHMgUHVyZUNvbXBvbmVudDxQcm9wcz4ge1xuICBwcml2YXRlIGNyZWF0ZUVuY29kZXIgPSBzY2F0dGVyUGxvdEVuY29kZXJGYWN0b3J5LmNyZWF0ZVNlbGVjdG9yKCk7XG5cbiAgcHJpdmF0ZSBjcmVhdGVNYXJnaW4gPSBjcmVhdGVNYXJnaW5TZWxlY3RvcigpO1xuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5cbiAgcmVuZGVyQ2hhcnQgPSAoZGltOiBEaW1lbnNpb24pID0+IHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGRpbTtcbiAgICBjb25zdCB7IGRhdGEsIG1hcmdpbiwgdGhlbWUsIFRvb2x0aXBSZW5kZXJlciwgZW5jb2RpbmcgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgZW5jb2RlciA9IHRoaXMuY3JlYXRlRW5jb2RlcihlbmNvZGluZyk7XG4gICAgY29uc3QgeyBjaGFubmVscyB9ID0gZW5jb2RlcjtcblxuICAgIGVuY29kZXIuc2V0RG9tYWluRnJvbURhdGFzZXQoZGF0YSk7XG5cbiAgICBjb25zdCBlbmNvZGVkRGF0YSA9IGRhdGEubWFwKGQgPT4gKHtcbiAgICAgIHg6IGNoYW5uZWxzLnguZ2V0VmFsdWVGcm9tRGF0dW0oZCksXG4gICAgICB5OiBjaGFubmVscy55LmdldFZhbHVlRnJvbURhdHVtKGQpLFxuICAgICAgLi4uZCxcbiAgICB9KSk7XG5cbiAgICBjb25zdCBsYXlvdXQgPSBjcmVhdGVYWUNoYXJ0TGF5b3V0V2l0aFRoZW1lKHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgbWFyZ2luOiB0aGlzLmNyZWF0ZU1hcmdpbihtYXJnaW4pLFxuICAgICAgdGhlbWUsXG4gICAgICB4RW5jb2RlcjogY2hhbm5lbHMueCxcbiAgICAgIHlFbmNvZGVyOiBjaGFubmVscy55LFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGxheW91dC5yZW5kZXJDaGFydFdpdGhGcmFtZSgoY2hhcnREaW06IERpbWVuc2lvbikgPT4gKFxuICAgICAgPFhZQ2hhcnRcbiAgICAgICAgc2hvd1lHcmlkXG4gICAgICAgIHdpZHRoPXtjaGFydERpbS53aWR0aH1cbiAgICAgICAgaGVpZ2h0PXtjaGFydERpbS5oZWlnaHR9XG4gICAgICAgIGFyaWFMYWJlbD1cIlNjYXR0ZXJQbG90XCJcbiAgICAgICAgbWFyZ2luPXtsYXlvdXQubWFyZ2lufVxuICAgICAgICByZW5kZXJUb29sdGlwPXsoeyBkYXR1bSB9OiB7IGRhdHVtOiBQbGFpbk9iamVjdCB9KSA9PiAoXG4gICAgICAgICAgPFRvb2x0aXBSZW5kZXJlciBkYXR1bT17ZGF0dW19IGVuY29kZXI9e2VuY29kZXJ9IC8+XG4gICAgICAgICl9XG4gICAgICAgIHRoZW1lPXt0aGVtZX1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgeFNjYWxlPXtjb252ZXJ0U2NhbGVUb0RhdGFVSVNjYWxlKGNoYW5uZWxzLnguZGVmaW5pdGlvbi5zY2FsZSBhcyBhbnkpfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICB5U2NhbGU9e2NvbnZlcnRTY2FsZVRvRGF0YVVJU2NhbGUoY2hhbm5lbHMueS5kZWZpbml0aW9uLnNjYWxlIGFzIGFueSl9XG4gICAgICA+XG4gICAgICAgIHtsYXlvdXQucmVuZGVyWEF4aXMoKX1cbiAgICAgICAge2xheW91dC5yZW5kZXJZQXhpcygpfVxuICAgICAgICA8UG9pbnRTZXJpZXNcbiAgICAgICAgICBrZXk9e2lzRmllbGREZWYoY2hhbm5lbHMueC5kZWZpbml0aW9uKSA/IGNoYW5uZWxzLnguZGVmaW5pdGlvbi5maWVsZCA6ICcnfVxuICAgICAgICAgIGRhdGE9e2VuY29kZWREYXRhfVxuICAgICAgICAgIGZpbGw9eyhkOiBQbGFpbk9iamVjdCkgPT4gY2hhbm5lbHMuZmlsbC5lbmNvZGVEYXR1bShkKX1cbiAgICAgICAgICBmaWxsT3BhY2l0eT17MC41fVxuICAgICAgICAgIHN0cm9rZT17KGQ6IFBsYWluT2JqZWN0KSA9PiBjaGFubmVscy5zdHJva2UuZW5jb2RlRGF0dW0oZCl9XG4gICAgICAgICAgc2l6ZT17KGQ6IFBsYWluT2JqZWN0KSA9PiBjaGFubmVscy5zaXplLmVuY29kZURhdHVtKGQpfVxuICAgICAgICAvPlxuICAgICAgPC9YWUNoYXJ0PlxuICAgICkpO1xuICB9O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGNsYXNzTmFtZSwgZGF0YSwgd2lkdGgsIGhlaWdodCwgZW5jb2RpbmcgfSA9IHRoaXMucHJvcHM7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPFdpdGhMZWdlbmRcbiAgICAgICAgY2xhc3NOYW1lPXtgc3VwZXJzZXQtY2hhcnQtc2NhdHRlci1wbG90ICR7Y2xhc3NOYW1lfWB9XG4gICAgICAgIHdpZHRoPXt3aWR0aH1cbiAgICAgICAgaGVpZ2h0PXtoZWlnaHR9XG4gICAgICAgIHBvc2l0aW9uPVwidG9wXCJcbiAgICAgICAgcmVuZGVyTGVnZW5kPXtjcmVhdGVSZW5kZXJMZWdlbmQodGhpcy5jcmVhdGVFbmNvZGVyKGVuY29kaW5nKSwgZGF0YSwgdGhpcy5wcm9wcyl9XG4gICAgICAgIHJlbmRlckNoYXJ0PXt0aGlzLnJlbmRlckNoYXJ0fVxuICAgICAgLz5cbiAgICApO1xuICB9XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN2TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDbktBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDL0JBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFHQTs7Ozs7Ozs7Ozs7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWlCQTtBQUFBOztBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBVUE7QUFnQkE7QUFkQTtBQUNBO0FBRUE7QUFVQTs7QUFwRUE7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2397\n')}}]);