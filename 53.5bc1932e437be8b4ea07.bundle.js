(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{2484:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react/index.js\nvar react = __webpack_require__(0);\nvar react_default = /*#__PURE__*/__webpack_require__.n(react);\n\n// EXTERNAL MODULE: ../superset-ui-core/src/translation/TranslatorSingleton.ts + 1 modules\nvar TranslatorSingleton = __webpack_require__(13);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/zoom/esm/Zoom.js + 6 modules\nvar Zoom = __webpack_require__(2474);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-choropleth-map/node_modules/@vx/event/esm/localPoint.js + 4 modules\nvar localPoint = __webpack_require__(2479);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/clip-path/esm/clip-paths/RectClipPath.js + 1 modules\nvar RectClipPath = __webpack_require__(2503);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-choropleth-map/node_modules/@vx/tooltip/esm/enhancers/withTooltip.js + 1 modules\nvar withTooltip = __webpack_require__(2504);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/lodash/lodash.js\nvar lodash = __webpack_require__(112);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-geo/src/path/index.js + 5 modules\nvar src_path = __webpack_require__(2476);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-choropleth-map/src/chart/loadMap.ts + 2 modules\nvar loadMap = __webpack_require__(1076);\n\n// EXTERNAL MODULE: ../superset-ui-core/src/style/index.ts\nvar style = __webpack_require__(442);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-choropleth-map/src/chart/components.ts\n\nconst PADDING = style["e" /* supersetTheme */].gridUnit * 4;\nconst RelativeDiv = style["d" /* styled */].div `\n  position: relative;\n`;\nconst ZoomControls = style["d" /* styled */].div `\n  position: absolute;\n  top: ${PADDING}px;\n  right: ${PADDING}px;\n  display: flex;\n  flex-direction: column;\n  align-items: flex-end;\n`;\nconst MiniMapControl = style["d" /* styled */].div `\n  position: absolute;\n  bottom: ${PADDING + 6}px;\n  right: ${PADDING + 1}px;\n`;\nconst IconButton = style["d" /* styled */].button `\n  width: ${({ theme }) => theme.gridUnit * 6}px;\n  font-size: ${({ theme }) => theme.typography.sizes.xl}px;\n  text-align: center;\n  color: #222;\n  margin: 0px;\n  margin-bottom: 2px;\n  background: #f5f8fb;\n  padding: 0px ${({ theme }) => theme.gridUnit}px;\n  border-radius: ${({ theme }) => theme.borderRadius}px;\n  border: none;\n`;\nconst TextButton = style["d" /* styled */].button `\n  text-align: center;\n  font-size: ${({ theme }) => theme.typography.sizes.s}px;\n  color: #222;\n  margin: 0px;\n  background: #f5f8fb;\n  padding: ${({ theme }) => theme.gridUnit / 2}px ${({ theme }) => theme.gridUnit * 1.5}px;\n  border-radius: ${({ theme }) => theme.borderRadius}px;\n  border: none;\n`;\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/encoders/createEncoderFactory.js + 52 modules\nvar createEncoderFactory = __webpack_require__(2465);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-choropleth-map/src/chart/Encoder.ts\n\nconst DefaultChannelOutputs = {\n    key: \'\',\n    fill: \'#f0f0f0\',\n    opacity: 1,\n    stroke: \'#ccc\',\n    strokeWidth: 1,\n};\nconst choroplethMapEncoderFactory = Object(createEncoderFactory["a" /* default */])({\n    channelTypes: {\n        key: \'Text\',\n        fill: \'Color\',\n        opacity: \'Numeric\',\n        stroke: \'Color\',\n        strokeWidth: \'Numeric\',\n        tooltip: \'Text\',\n    },\n    defaultEncoding: {\n        key: { field: \'key\', title: \'Location\' },\n        fill: { value: DefaultChannelOutputs.fill },\n        opacity: { value: DefaultChannelOutputs.opacity },\n        stroke: { value: DefaultChannelOutputs.stroke },\n        strokeWidth: { value: DefaultChannelOutputs.strokeWidth },\n        tooltip: [],\n    },\n});\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/typeGuards/CompleteChannelDef.js\nvar CompleteChannelDef = __webpack_require__(2404);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-choropleth-map/node_modules/@vx/tooltip/esm/tooltips/Tooltip.js\nvar Tooltip = __webpack_require__(2457);\n\n// EXTERNAL MODULE: ../superset-ui-core/src/chart-composition/tooltip/TooltipFrame.tsx\nvar TooltipFrame = __webpack_require__(1024);\n\n// EXTERNAL MODULE: ../superset-ui-core/src/chart-composition/tooltip/TooltipTable.tsx\nvar TooltipTable = __webpack_require__(1025);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-choropleth-map/src/chart/MapTooltip.tsx\n\n\n\n\n\nfunction MapTooltip({ encoder, left, top, tooltipData }) {\n    if (!tooltipData) {\n        return null;\n    }\n    const { channels } = encoder;\n    const { key, fill, stroke, strokeWidth, opacity, tooltip } = channels;\n    const { datum } = tooltipData;\n    const tooltipRows = [\n        { key: \'key\', keyColumn: key.getTitle(), valueColumn: key.formatDatum(datum) },\n    ];\n    [fill, stroke, opacity, strokeWidth].forEach(channel => {\n        if (Object(CompleteChannelDef["a" /* isCompleteFieldDef */])(channel.definition)) {\n            tooltipRows.push({\n                key: channel.name,\n                keyColumn: channel.getTitle(),\n                valueColumn: channel.formatDatum(datum),\n            });\n        }\n    });\n    tooltip.forEach(g => {\n        tooltipRows.push({\n            key: `${g.name}`,\n            keyColumn: g.getTitle(),\n            valueColumn: g.formatDatum(datum),\n        });\n    });\n    return (react_default.a.createElement(Tooltip["a" /* default */], { top: top, left: left },\n        react_default.a.createElement(TooltipFrame["a" /* default */], null,\n            react_default.a.createElement(TooltipTable["a" /* default */], { data: Object(lodash["uniqBy"])(tooltipRows, row => row.keyColumn) }))));\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-choropleth-map/src/chart/ChoroplethMap.tsx\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\n\n\n\n\n\n\n\n\n\n\nconst INITIAL_TRANSFORM = {\n    scaleX: 1,\n    scaleY: 1,\n    translateX: 0,\n    translateY: 0,\n    skewX: 0,\n    skewY: 0,\n};\nconst defaultProps = {\n    data: [],\n    encoding: {},\n    map: \'world\',\n};\nconst missingItem = DefaultChannelOutputs;\nclass ChoroplethMap_ChoroplethMap extends react_default.a.PureComponent {\n    constructor(props) {\n        super(props);\n        this.createEncoder = choroplethMapEncoderFactory.createSelector();\n        this.handleMouseOver = (event, datum) => {\n            const coords = Object(localPoint["a" /* default */])(event);\n            this.props.showTooltip({\n                tooltipLeft: coords === null || coords === void 0 ? void 0 : coords.x,\n                tooltipTop: coords === null || coords === void 0 ? void 0 : coords.y,\n                tooltipData: datum,\n            });\n        };\n        this.toggleMiniMap = () => {\n            const { showMiniMap } = this.state;\n            this.setState({\n                showMiniMap: !showMiniMap,\n            });\n        };\n        this.state = {\n            mapData: {},\n            mapShape: undefined,\n            showMiniMap: true,\n        };\n    }\n    componentDidMount() {\n        this.loadMap();\n        this.processData();\n    }\n    componentDidUpdate(prevProps) {\n        if (prevProps.map !== this.props.map) {\n            this.loadMap();\n        }\n        if (prevProps.data !== this.props.data || prevProps.encoding !== this.props.encoding) {\n            this.processData();\n        }\n    }\n    processData() {\n        const { data, encoding } = this.props;\n        const encoder = this.createEncoder(encoding);\n        const { key, fill, opacity, stroke, strokeWidth } = encoder.channels;\n        encoder.setDomainFromDataset(data);\n        const mapData = Object(lodash["keyBy"])(data.map(d => ({\n            key: key.getValueFromDatum(d, DefaultChannelOutputs.key),\n            fill: fill.encodeDatum(d, DefaultChannelOutputs.fill),\n            opacity: opacity.encodeDatum(d, DefaultChannelOutputs.opacity),\n            stroke: stroke.encodeDatum(d, DefaultChannelOutputs.stroke),\n            strokeWidth: strokeWidth.encodeDatum(d, DefaultChannelOutputs.strokeWidth),\n            datum: d,\n        })), d => d.key);\n        this.setState({ mapData });\n    }\n    loadMap() {\n        const { map } = this.props;\n        this.setState({ mapShape: undefined });\n        Object(loadMap["a" /* default */])(map).then(mapShape => {\n            this.setState({ mapShape });\n        });\n    }\n    renderMap() {\n        const { height, width, hideTooltip } = this.props;\n        const { mapShape, mapData } = this.state;\n        if (typeof mapShape !== \'undefined\') {\n            const { metadata, object } = mapShape;\n            const { keyAccessor } = metadata;\n            const projection = metadata.createProjection().fitExtent([\n                [PADDING, PADDING],\n                [width - PADDING * 2, height - PADDING * 2],\n            ], object);\n            const path = Object(src_path["a" /* default */])().projection(projection);\n            return object.features.map(f => {\n                const key = keyAccessor(f);\n                const encodedDatum = mapData[key] || missingItem;\n                const { stroke, fill, strokeWidth, opacity } = encodedDatum;\n                return (\n                // eslint-disable-next-line jsx-a11y/mouse-events-have-key-events\n                react_default.a.createElement("path", { key: key, vectorEffect: "non-scaling-stroke", stroke: stroke, strokeWidth: strokeWidth, fill: fill, opacity: opacity, d: path(f) || \'\', onMouseOver: event => this.handleMouseOver(event, encodedDatum), onMouseMove: event => this.handleMouseOver(event, encodedDatum), onMouseOut: hideTooltip, onBlur: hideTooltip }));\n            });\n        }\n        return null;\n    }\n    render() {\n        const { height, width, encoding, tooltipOpen, tooltipLeft, tooltipTop, tooltipData, } = this.props;\n        const { showMiniMap } = this.state;\n        const encoder = this.createEncoder(encoding);\n        const renderedMap = this.renderMap();\n        const miniMapTransform = `translate(${(width * 3) / 4 - PADDING}, ${(height * 3) / 4 - PADDING}) scale(0.25)`;\n        return (react_default.a.createElement(react_default.a.Fragment, null,\n            react_default.a.createElement(Zoom["a" /* default */], { style: { width, height }, width: width, height: height, scaleXMin: 0.75, scaleXMax: 8, scaleYMin: 0.75, scaleYMax: 8, transformMatrix: INITIAL_TRANSFORM }, zoom => (react_default.a.createElement(RelativeDiv, null,\n                react_default.a.createElement("svg", { width: width, height: height, style: { cursor: zoom.isDragging ? \'grabbing\' : \'grab\' } },\n                    react_default.a.createElement(RectClipPath["a" /* default */], { id: "zoom-clip", width: width, height: height }),\n                    react_default.a.createElement("g", { onWheel: zoom.handleWheel, \n                        // eslint-disable-next-line react/jsx-handler-names\n                        onMouseDown: zoom.dragStart, \n                        // eslint-disable-next-line react/jsx-handler-names\n                        onMouseMove: zoom.dragMove, \n                        // eslint-disable-next-line react/jsx-handler-names\n                        onMouseUp: zoom.dragEnd, onMouseLeave: () => {\n                            if (!zoom.isDragging)\n                                return;\n                            zoom.dragEnd();\n                        }, onDoubleClick: event => {\n                            const point = Object(localPoint["a" /* default */])(event) || undefined;\n                            zoom.scale({ scaleX: 1.1, scaleY: 1.1, point });\n                        } },\n                        react_default.a.createElement("rect", { width: width, height: height, fill: "transparent" }),\n                        react_default.a.createElement("g", { transform: zoom.toString() }, renderedMap)),\n                    showMiniMap && (react_default.a.createElement("g", { clipPath: "url(#zoom-clip)", transform: miniMapTransform },\n                        react_default.a.createElement("rect", { width: width, height: height, fill: "#fff", stroke: "#999" }),\n                        renderedMap,\n                        react_default.a.createElement("rect", { width: width, height: height, fill: "white", fillOpacity: 0.2, stroke: "#999", strokeWidth: 4, transform: zoom.toStringInvert() })))),\n                react_default.a.createElement(ZoomControls, null,\n                    react_default.a.createElement(IconButton, { type: "button", onClick: () => zoom.scale({ scaleX: 1.2, scaleY: 1.2 }) }, "+"),\n                    react_default.a.createElement(IconButton, { type: "button", onClick: () => zoom.scale({ scaleX: 0.8, scaleY: 0.8 }) }, "-"),\n                    react_default.a.createElement(TextButton, { type: "button", \n                        // eslint-disable-next-line react/jsx-handler-names\n                        onClick: zoom.clear }, "Reset")),\n                react_default.a.createElement(MiniMapControl, null,\n                    react_default.a.createElement(TextButton, { type: "button", \n                        // eslint-disable-next-line react/jsx-handler-names\n                        onClick: this.toggleMiniMap }, showMiniMap ? Object(TranslatorSingleton["e" /* t */])(\'Hide Mini Map\') : Object(TranslatorSingleton["e" /* t */])(\'Show Mini Map\')))))),\n            tooltipOpen && (react_default.a.createElement(MapTooltip, { encoder: encoder, top: tooltipTop, left: tooltipLeft, tooltipData: tooltipData }))));\n    }\n}\nChoroplethMap_ChoroplethMap.defaultProps = defaultProps;\n/* harmony default export */ var chart_ChoroplethMap = __webpack_exports__["default"] = (Object(withTooltip["a" /* default */])(ChoroplethMap_ChoroplethMap));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQ4NC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wbHVnaW4tY2hhcnQtY2hvcm9wbGV0aC1tYXAvc3JjL2NoYXJ0L2NvbXBvbmVudHMudHM/YTI0ZCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvcGx1Z2luLWNoYXJ0LWNob3JvcGxldGgtbWFwL3NyYy9jaGFydC9FbmNvZGVyLnRzP2IyYzYiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9wbHVnaW5zL3BsdWdpbi1jaGFydC1jaG9yb3BsZXRoLW1hcC9zcmMvY2hhcnQvTWFwVG9vbHRpcC50c3g/MGY4ZSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvcGx1Z2luLWNoYXJ0LWNob3JvcGxldGgtbWFwL3NyYy9jaGFydC9DaG9yb3BsZXRoTWFwLnRzeD9kYzgxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHN0eWxlZCwgc3VwZXJzZXRUaGVtZSB9IGZyb20gJ0BzdXBlcnNldC11aS9jb3JlJztcblxuZXhwb3J0IGNvbnN0IFBBRERJTkcgPSBzdXBlcnNldFRoZW1lLmdyaWRVbml0ICogNDtcblxuZXhwb3J0IGNvbnN0IFJlbGF0aXZlRGl2ID0gc3R5bGVkLmRpdmBcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuYDtcblxuZXhwb3J0IGNvbnN0IFpvb21Db250cm9scyA9IHN0eWxlZC5kaXZgXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgdG9wOiAke1BBRERJTkd9cHg7XG4gIHJpZ2h0OiAke1BBRERJTkd9cHg7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gIGFsaWduLWl0ZW1zOiBmbGV4LWVuZDtcbmA7XG5cbmV4cG9ydCBjb25zdCBNaW5pTWFwQ29udHJvbCA9IHN0eWxlZC5kaXZgXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgYm90dG9tOiAke1BBRERJTkcgKyA2fXB4O1xuICByaWdodDogJHtQQURESU5HICsgMX1weDtcbmA7XG5cbmV4cG9ydCBjb25zdCBJY29uQnV0dG9uID0gc3R5bGVkLmJ1dHRvbmBcbiAgd2lkdGg6ICR7KHsgdGhlbWUgfSkgPT4gdGhlbWUuZ3JpZFVuaXQgKiA2fXB4O1xuICBmb250LXNpemU6ICR7KHsgdGhlbWUgfSkgPT4gdGhlbWUudHlwb2dyYXBoeS5zaXplcy54bH1weDtcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xuICBjb2xvcjogIzIyMjtcbiAgbWFyZ2luOiAwcHg7XG4gIG1hcmdpbi1ib3R0b206IDJweDtcbiAgYmFja2dyb3VuZDogI2Y1ZjhmYjtcbiAgcGFkZGluZzogMHB4ICR7KHsgdGhlbWUgfSkgPT4gdGhlbWUuZ3JpZFVuaXR9cHg7XG4gIGJvcmRlci1yYWRpdXM6ICR7KHsgdGhlbWUgfSkgPT4gdGhlbWUuYm9yZGVyUmFkaXVzfXB4O1xuICBib3JkZXI6IG5vbmU7XG5gO1xuXG5leHBvcnQgY29uc3QgVGV4dEJ1dHRvbiA9IHN0eWxlZC5idXR0b25gXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgZm9udC1zaXplOiAkeyh7IHRoZW1lIH0pID0+IHRoZW1lLnR5cG9ncmFwaHkuc2l6ZXMuc31weDtcbiAgY29sb3I6ICMyMjI7XG4gIG1hcmdpbjogMHB4O1xuICBiYWNrZ3JvdW5kOiAjZjVmOGZiO1xuICBwYWRkaW5nOiAkeyh7IHRoZW1lIH0pID0+IHRoZW1lLmdyaWRVbml0IC8gMn1weCAkeyh7IHRoZW1lIH0pID0+IHRoZW1lLmdyaWRVbml0ICogMS41fXB4O1xuICBib3JkZXItcmFkaXVzOiAkeyh7IHRoZW1lIH0pID0+IHRoZW1lLmJvcmRlclJhZGl1c31weDtcbiAgYm9yZGVyOiBub25lO1xuYDtcbiIsImltcG9ydCB7IGNyZWF0ZUVuY29kZXJGYWN0b3J5LCBEZXJpdmVFbmNvZGluZywgRW5jb2RlciwgRGVyaXZlQ2hhbm5lbE91dHB1dHMgfSBmcm9tICdlbmNvZGFibGUnO1xuXG50eXBlIENob3JvcGxldGhNYXBFbmNvZGluZ0NvbmZpZyA9IHtcbiAga2V5OiBbJ1RleHQnLCBzdHJpbmddO1xuICBmaWxsOiBbJ0NvbG9yJywgc3RyaW5nXTtcbiAgb3BhY2l0eTogWydOdW1lcmljJywgbnVtYmVyXTtcbiAgc3Ryb2tlOiBbJ0NvbG9yJywgc3RyaW5nXTtcbiAgc3Ryb2tlV2lkdGg6IFsnTnVtZXJpYycsIG51bWJlcl07XG4gIHRvb2x0aXA6IFsnVGV4dCcsIHN0cmluZywgJ211bHRpcGxlJ107XG59O1xuXG5leHBvcnQgdHlwZSBDaG9yb3BsZXRoTWFwRW5jb2RpbmcgPSBEZXJpdmVFbmNvZGluZzxDaG9yb3BsZXRoTWFwRW5jb2RpbmdDb25maWc+O1xuXG5leHBvcnQgdHlwZSBDaG9yb3BsZXRoTWFwRW5jb2RlciA9IEVuY29kZXI8Q2hvcm9wbGV0aE1hcEVuY29kaW5nQ29uZmlnPjtcblxuZXhwb3J0IHR5cGUgQ2hvcm9wbGV0aE1hcENoYW5uZWxPdXRwdXRzID0gRGVyaXZlQ2hhbm5lbE91dHB1dHM8Q2hvcm9wbGV0aE1hcEVuY29kaW5nQ29uZmlnPjtcblxuZXhwb3J0IGNvbnN0IERlZmF1bHRDaGFubmVsT3V0cHV0cyA9IHtcbiAga2V5OiAnJyxcbiAgZmlsbDogJyNmMGYwZjAnLFxuICBvcGFjaXR5OiAxLFxuICBzdHJva2U6ICcjY2NjJyxcbiAgc3Ryb2tlV2lkdGg6IDEsXG59O1xuXG5leHBvcnQgY29uc3QgY2hvcm9wbGV0aE1hcEVuY29kZXJGYWN0b3J5ID0gY3JlYXRlRW5jb2RlckZhY3Rvcnk8Q2hvcm9wbGV0aE1hcEVuY29kaW5nQ29uZmlnPih7XG4gIGNoYW5uZWxUeXBlczoge1xuICAgIGtleTogJ1RleHQnLFxuICAgIGZpbGw6ICdDb2xvcicsXG4gICAgb3BhY2l0eTogJ051bWVyaWMnLFxuICAgIHN0cm9rZTogJ0NvbG9yJyxcbiAgICBzdHJva2VXaWR0aDogJ051bWVyaWMnLFxuICAgIHRvb2x0aXA6ICdUZXh0JyxcbiAgfSxcbiAgZGVmYXVsdEVuY29kaW5nOiB7XG4gICAga2V5OiB7IGZpZWxkOiAna2V5JywgdGl0bGU6ICdMb2NhdGlvbicgfSxcbiAgICBmaWxsOiB7IHZhbHVlOiBEZWZhdWx0Q2hhbm5lbE91dHB1dHMuZmlsbCB9LFxuICAgIG9wYWNpdHk6IHsgdmFsdWU6IERlZmF1bHRDaGFubmVsT3V0cHV0cy5vcGFjaXR5IH0sXG4gICAgc3Ryb2tlOiB7IHZhbHVlOiBEZWZhdWx0Q2hhbm5lbE91dHB1dHMuc3Ryb2tlIH0sXG4gICAgc3Ryb2tlV2lkdGg6IHsgdmFsdWU6IERlZmF1bHRDaGFubmVsT3V0cHV0cy5zdHJva2VXaWR0aCB9LFxuICAgIHRvb2x0aXA6IFtdLFxuICB9LFxufSk7XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgaXNDb21wbGV0ZUZpZWxkRGVmIH0gZnJvbSAnZW5jb2RhYmxlJztcbmltcG9ydCB7IHVuaXFCeSB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBUb29sdGlwIH0gZnJvbSAnQHZ4L3Rvb2x0aXAnO1xuaW1wb3J0IHsgVG9vbHRpcEZyYW1lLCBUb29sdGlwVGFibGUgfSBmcm9tICdAc3VwZXJzZXQtdWkvY29yZSc7XG5pbXBvcnQgeyBDaG9yb3BsZXRoTWFwQ2hhbm5lbE91dHB1dHMsIENob3JvcGxldGhNYXBFbmNvZGVyIH0gZnJvbSAnLi9FbmNvZGVyJztcblxuZXhwb3J0IHR5cGUgTWFwRGF0YVBvaW50ID0gT21pdDxDaG9yb3BsZXRoTWFwQ2hhbm5lbE91dHB1dHMsICd0b29sdGlwJz4gJiB7XG4gIGRhdHVtOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbn07XG5cbmV4cG9ydCB0eXBlIE1hcFRvb2x0aXBQcm9wcyA9IHtcbiAgdG9wPzogbnVtYmVyO1xuICBsZWZ0PzogbnVtYmVyO1xuICBlbmNvZGVyOiBDaG9yb3BsZXRoTWFwRW5jb2RlcjtcbiAgdG9vbHRpcERhdGE/OiBNYXBEYXRhUG9pbnQ7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNYXBUb29sdGlwKHsgZW5jb2RlciwgbGVmdCwgdG9wLCB0b29sdGlwRGF0YSB9OiBNYXBUb29sdGlwUHJvcHMpIHtcbiAgaWYgKCF0b29sdGlwRGF0YSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgeyBjaGFubmVscyB9ID0gZW5jb2RlcjtcbiAgY29uc3QgeyBrZXksIGZpbGwsIHN0cm9rZSwgc3Ryb2tlV2lkdGgsIG9wYWNpdHksIHRvb2x0aXAgfSA9IGNoYW5uZWxzO1xuICBjb25zdCB7IGRhdHVtIH0gPSB0b29sdGlwRGF0YTtcblxuICBjb25zdCB0b29sdGlwUm93cyA9IFtcbiAgICB7IGtleTogJ2tleScsIGtleUNvbHVtbjoga2V5LmdldFRpdGxlKCksIHZhbHVlQ29sdW1uOiBrZXkuZm9ybWF0RGF0dW0oZGF0dW0pIH0sXG4gIF07XG5cbiAgW2ZpbGwsIHN0cm9rZSwgb3BhY2l0eSwgc3Ryb2tlV2lkdGhdLmZvckVhY2goY2hhbm5lbCA9PiB7XG4gICAgaWYgKGlzQ29tcGxldGVGaWVsZERlZjxzdHJpbmcgfCBudW1iZXI+KGNoYW5uZWwuZGVmaW5pdGlvbikpIHtcbiAgICAgIHRvb2x0aXBSb3dzLnB1c2goe1xuICAgICAgICBrZXk6IGNoYW5uZWwubmFtZSBhcyBzdHJpbmcsXG4gICAgICAgIGtleUNvbHVtbjogY2hhbm5lbC5nZXRUaXRsZSgpLFxuICAgICAgICB2YWx1ZUNvbHVtbjogY2hhbm5lbC5mb3JtYXREYXR1bShkYXR1bSksXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIHRvb2x0aXAuZm9yRWFjaChnID0+IHtcbiAgICB0b29sdGlwUm93cy5wdXNoKHtcbiAgICAgIGtleTogYCR7Zy5uYW1lfWAsXG4gICAgICBrZXlDb2x1bW46IGcuZ2V0VGl0bGUoKSxcbiAgICAgIHZhbHVlQ29sdW1uOiBnLmZvcm1hdERhdHVtKGRhdHVtKSxcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIChcbiAgICA8VG9vbHRpcCB0b3A9e3RvcH0gbGVmdD17bGVmdH0+XG4gICAgICA8VG9vbHRpcEZyYW1lPlxuICAgICAgICA8VG9vbHRpcFRhYmxlIGRhdGE9e3VuaXFCeSh0b29sdGlwUm93cywgcm93ID0+IHJvdy5rZXlDb2x1bW4pfSAvPlxuICAgICAgPC9Ub29sdGlwRnJhbWU+XG4gICAgPC9Ub29sdGlwPlxuICApO1xufVxuIiwiLyoqXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHQgfSBmcm9tICdAc3VwZXJzZXQtdWkvY29yZSc7XG5pbXBvcnQgeyBab29tIH0gZnJvbSAnQHZ4L3pvb20nO1xuaW1wb3J0IHsgbG9jYWxQb2ludCB9IGZyb20gJ0B2eC9ldmVudCc7XG5pbXBvcnQgeyBSZWN0Q2xpcFBhdGggfSBmcm9tICdAdngvY2xpcC1wYXRoJztcbmltcG9ydCB7IHdpdGhUb29sdGlwIH0gZnJvbSAnQHZ4L3Rvb2x0aXAnO1xuaW1wb3J0IHsga2V5QnkgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgZ2VvUGF0aCB9IGZyb20gJ2QzLWdlbyc7XG5pbXBvcnQgdHlwZSB7IEZlYXR1cmVDb2xsZWN0aW9uIH0gZnJvbSAnZ2VvanNvbic7XG5pbXBvcnQgeyBXaXRoVG9vbHRpcFByb3ZpZGVkUHJvcHMgfSBmcm9tICdAdngvdG9vbHRpcC9saWIvZW5oYW5jZXJzL3dpdGhUb29sdGlwJztcbmltcG9ydCBsb2FkTWFwIGZyb20gJy4vbG9hZE1hcCc7XG5pbXBvcnQgTWFwTWV0YWRhdGEgZnJvbSAnLi9NYXBNZXRhZGF0YSc7XG5pbXBvcnQge1xuICBQQURESU5HLFxuICBSZWxhdGl2ZURpdixcbiAgSWNvbkJ1dHRvbixcbiAgVGV4dEJ1dHRvbixcbiAgWm9vbUNvbnRyb2xzLFxuICBNaW5pTWFwQ29udHJvbCxcbn0gZnJvbSAnLi9jb21wb25lbnRzJztcbmltcG9ydCB7XG4gIENob3JvcGxldGhNYXBFbmNvZGluZyxcbiAgY2hvcm9wbGV0aE1hcEVuY29kZXJGYWN0b3J5LFxuICBEZWZhdWx0Q2hhbm5lbE91dHB1dHMsXG59IGZyb20gJy4vRW5jb2Rlcic7XG5pbXBvcnQgTWFwVG9vbHRpcCwgeyBNYXBEYXRhUG9pbnQgfSBmcm9tICcuL01hcFRvb2x0aXAnO1xuXG5jb25zdCBJTklUSUFMX1RSQU5TRk9STSA9IHtcbiAgc2NhbGVYOiAxLFxuICBzY2FsZVk6IDEsXG4gIHRyYW5zbGF0ZVg6IDAsXG4gIHRyYW5zbGF0ZVk6IDAsXG4gIHNrZXdYOiAwLFxuICBza2V3WTogMCxcbn07XG5cbi8qKlxuICogVGhlc2UgcHJvcHMgc2hvdWxkIGJlIHN0b3JlZCB3aGVuIHNhdmluZyB0aGUgY2hhcnQuXG4gKi9cbmV4cG9ydCB0eXBlIENob3JvcGxldGhNYXBWaXN1YWxQcm9wcyA9IHtcbiAgZW5jb2Rpbmc/OiBQYXJ0aWFsPENob3JvcGxldGhNYXBFbmNvZGluZz47XG4gIG1hcD86IHN0cmluZztcbn07XG5cbmV4cG9ydCB0eXBlIENob3JvcGxldGhNYXBQcm9wcyA9IENob3JvcGxldGhNYXBWaXN1YWxQcm9wcyAmXG4gIFdpdGhUb29sdGlwUHJvdmlkZWRQcm9wczxNYXBEYXRhUG9pbnQ+ICYge1xuICAgIGRhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+W107XG4gICAgaGVpZ2h0OiBudW1iZXI7XG4gICAgd2lkdGg6IG51bWJlcjtcbiAgfTtcblxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBkYXRhOiBbXSxcbiAgZW5jb2Rpbmc6IHt9LFxuICBtYXA6ICd3b3JsZCcsXG59O1xuXG5jb25zdCBtaXNzaW5nSXRlbSA9IERlZmF1bHRDaGFubmVsT3V0cHV0cztcblxuY2xhc3MgQ2hvcm9wbGV0aE1hcCBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQ8XG4gIENob3JvcGxldGhNYXBQcm9wcyAmIHR5cGVvZiBkZWZhdWx0UHJvcHMsXG4gIHtcbiAgICBtYXBTaGFwZT86IHtcbiAgICAgIG1ldGFkYXRhOiBNYXBNZXRhZGF0YTtcbiAgICAgIG9iamVjdDogRmVhdHVyZUNvbGxlY3Rpb247XG4gICAgfTtcbiAgICBtYXBEYXRhOiB7XG4gICAgICBba2V5OiBzdHJpbmddOiBNYXBEYXRhUG9pbnQ7XG4gICAgfTtcbiAgICBzaG93TWluaU1hcDogYm9vbGVhbjtcbiAgfVxuPiB7XG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5cbiAgY3JlYXRlRW5jb2RlciA9IGNob3JvcGxldGhNYXBFbmNvZGVyRmFjdG9yeS5jcmVhdGVTZWxlY3RvcigpO1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBDaG9yb3BsZXRoTWFwUHJvcHMgJiB0eXBlb2YgZGVmYXVsdFByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIG1hcERhdGE6IHt9LFxuICAgICAgbWFwU2hhcGU6IHVuZGVmaW5lZCxcbiAgICAgIHNob3dNaW5pTWFwOiB0cnVlLFxuICAgIH07XG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLmxvYWRNYXAoKTtcbiAgICB0aGlzLnByb2Nlc3NEYXRhKCk7XG4gIH1cblxuICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzOiBDaG9yb3BsZXRoTWFwUHJvcHMpIHtcbiAgICBpZiAocHJldlByb3BzLm1hcCAhPT0gdGhpcy5wcm9wcy5tYXApIHtcbiAgICAgIHRoaXMubG9hZE1hcCgpO1xuICAgIH1cbiAgICBpZiAocHJldlByb3BzLmRhdGEgIT09IHRoaXMucHJvcHMuZGF0YSB8fCBwcmV2UHJvcHMuZW5jb2RpbmcgIT09IHRoaXMucHJvcHMuZW5jb2RpbmcpIHtcbiAgICAgIHRoaXMucHJvY2Vzc0RhdGEoKTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVNb3VzZU92ZXIgPSAoZXZlbnQ6IFJlYWN0Lk1vdXNlRXZlbnQ8U1ZHUGF0aEVsZW1lbnQ+LCBkYXR1bT86IE1hcERhdGFQb2ludCkgPT4ge1xuICAgIGNvbnN0IGNvb3JkcyA9IGxvY2FsUG9pbnQoZXZlbnQpO1xuICAgIHRoaXMucHJvcHMuc2hvd1Rvb2x0aXAoe1xuICAgICAgdG9vbHRpcExlZnQ6IGNvb3Jkcz8ueCxcbiAgICAgIHRvb2x0aXBUb3A6IGNvb3Jkcz8ueSxcbiAgICAgIHRvb2x0aXBEYXRhOiBkYXR1bSxcbiAgICB9KTtcbiAgfTtcblxuICB0b2dnbGVNaW5pTWFwID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgc2hvd01pbmlNYXAgfSA9IHRoaXMuc3RhdGU7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBzaG93TWluaU1hcDogIXNob3dNaW5pTWFwLFxuICAgIH0pO1xuICB9O1xuXG4gIHByb2Nlc3NEYXRhKCkge1xuICAgIGNvbnN0IHsgZGF0YSwgZW5jb2RpbmcgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgZW5jb2RlciA9IHRoaXMuY3JlYXRlRW5jb2RlcihlbmNvZGluZyk7XG4gICAgY29uc3QgeyBrZXksIGZpbGwsIG9wYWNpdHksIHN0cm9rZSwgc3Ryb2tlV2lkdGggfSA9IGVuY29kZXIuY2hhbm5lbHM7XG5cbiAgICBlbmNvZGVyLnNldERvbWFpbkZyb21EYXRhc2V0KGRhdGEpO1xuXG4gICAgY29uc3QgbWFwRGF0YSA9IGtleUJ5KFxuICAgICAgZGF0YS5tYXAoZCA9PiAoe1xuICAgICAgICBrZXk6IGtleS5nZXRWYWx1ZUZyb21EYXR1bTxzdHJpbmc+KGQsIERlZmF1bHRDaGFubmVsT3V0cHV0cy5rZXkpLFxuICAgICAgICBmaWxsOiBmaWxsLmVuY29kZURhdHVtKGQsIERlZmF1bHRDaGFubmVsT3V0cHV0cy5maWxsKSxcbiAgICAgICAgb3BhY2l0eTogb3BhY2l0eS5lbmNvZGVEYXR1bShkLCBEZWZhdWx0Q2hhbm5lbE91dHB1dHMub3BhY2l0eSksXG4gICAgICAgIHN0cm9rZTogc3Ryb2tlLmVuY29kZURhdHVtKGQsIERlZmF1bHRDaGFubmVsT3V0cHV0cy5zdHJva2UpLFxuICAgICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGguZW5jb2RlRGF0dW0oZCwgRGVmYXVsdENoYW5uZWxPdXRwdXRzLnN0cm9rZVdpZHRoKSxcbiAgICAgICAgZGF0dW06IGQsXG4gICAgICB9KSksXG4gICAgICBkID0+IGQua2V5LFxuICAgICk7XG5cbiAgICB0aGlzLnNldFN0YXRlKHsgbWFwRGF0YSB9KTtcbiAgfVxuXG4gIGxvYWRNYXAoKSB7XG4gICAgY29uc3QgeyBtYXAgfSA9IHRoaXMucHJvcHM7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IG1hcFNoYXBlOiB1bmRlZmluZWQgfSk7XG4gICAgbG9hZE1hcChtYXApLnRoZW4obWFwU2hhcGUgPT4ge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IG1hcFNoYXBlIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcmVuZGVyTWFwKCkge1xuICAgIGNvbnN0IHsgaGVpZ2h0LCB3aWR0aCwgaGlkZVRvb2x0aXAgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgeyBtYXBTaGFwZSwgbWFwRGF0YSB9ID0gdGhpcy5zdGF0ZTtcblxuICAgIGlmICh0eXBlb2YgbWFwU2hhcGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zdCB7IG1ldGFkYXRhLCBvYmplY3QgfSA9IG1hcFNoYXBlO1xuICAgICAgY29uc3QgeyBrZXlBY2Nlc3NvciB9ID0gbWV0YWRhdGE7XG4gICAgICBjb25zdCBwcm9qZWN0aW9uID0gbWV0YWRhdGEuY3JlYXRlUHJvamVjdGlvbigpLmZpdEV4dGVudChcbiAgICAgICAgW1xuICAgICAgICAgIFtQQURESU5HLCBQQURESU5HXSxcbiAgICAgICAgICBbd2lkdGggLSBQQURESU5HICogMiwgaGVpZ2h0IC0gUEFERElORyAqIDJdLFxuICAgICAgICBdLFxuICAgICAgICBvYmplY3QsXG4gICAgICApO1xuICAgICAgY29uc3QgcGF0aCA9IGdlb1BhdGgoKS5wcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuXG4gICAgICByZXR1cm4gb2JqZWN0LmZlYXR1cmVzLm1hcChmID0+IHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5QWNjZXNzb3IoZik7XG4gICAgICAgIGNvbnN0IGVuY29kZWREYXR1bSA9IG1hcERhdGFba2V5XSB8fCBtaXNzaW5nSXRlbTtcbiAgICAgICAgY29uc3QgeyBzdHJva2UsIGZpbGwsIHN0cm9rZVdpZHRoLCBvcGFjaXR5IH0gPSBlbmNvZGVkRGF0dW07XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganN4LWExMXkvbW91c2UtZXZlbnRzLWhhdmUta2V5LWV2ZW50c1xuICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICBrZXk9e2tleX1cbiAgICAgICAgICAgIHZlY3RvckVmZmVjdD1cIm5vbi1zY2FsaW5nLXN0cm9rZVwiXG4gICAgICAgICAgICBzdHJva2U9e3N0cm9rZX1cbiAgICAgICAgICAgIHN0cm9rZVdpZHRoPXtzdHJva2VXaWR0aH1cbiAgICAgICAgICAgIGZpbGw9e2ZpbGx9XG4gICAgICAgICAgICBvcGFjaXR5PXtvcGFjaXR5fVxuICAgICAgICAgICAgZD17cGF0aChmKSB8fCAnJ31cbiAgICAgICAgICAgIG9uTW91c2VPdmVyPXtldmVudCA9PiB0aGlzLmhhbmRsZU1vdXNlT3ZlcihldmVudCwgZW5jb2RlZERhdHVtKX1cbiAgICAgICAgICAgIG9uTW91c2VNb3ZlPXtldmVudCA9PiB0aGlzLmhhbmRsZU1vdXNlT3ZlcihldmVudCwgZW5jb2RlZERhdHVtKX1cbiAgICAgICAgICAgIG9uTW91c2VPdXQ9e2hpZGVUb29sdGlwfVxuICAgICAgICAgICAgb25CbHVyPXtoaWRlVG9vbHRpcH1cbiAgICAgICAgICAvPlxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGVpZ2h0LFxuICAgICAgd2lkdGgsXG4gICAgICBlbmNvZGluZyxcbiAgICAgIHRvb2x0aXBPcGVuLFxuICAgICAgdG9vbHRpcExlZnQsXG4gICAgICB0b29sdGlwVG9wLFxuICAgICAgdG9vbHRpcERhdGEsXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgeyBzaG93TWluaU1hcCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBlbmNvZGVyID0gdGhpcy5jcmVhdGVFbmNvZGVyKGVuY29kaW5nKTtcblxuICAgIGNvbnN0IHJlbmRlcmVkTWFwID0gdGhpcy5yZW5kZXJNYXAoKTtcbiAgICBjb25zdCBtaW5pTWFwVHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgkeyh3aWR0aCAqIDMpIC8gNCAtIFBBRERJTkd9LCAke1xuICAgICAgKGhlaWdodCAqIDMpIC8gNCAtIFBBRERJTkdcbiAgICB9KSBzY2FsZSgwLjI1KWA7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPD5cbiAgICAgICAgPFpvb21cbiAgICAgICAgICBzdHlsZT17eyB3aWR0aCwgaGVpZ2h0IH19XG4gICAgICAgICAgd2lkdGg9e3dpZHRofVxuICAgICAgICAgIGhlaWdodD17aGVpZ2h0fVxuICAgICAgICAgIHNjYWxlWE1pbj17MC43NX1cbiAgICAgICAgICBzY2FsZVhNYXg9ezh9XG4gICAgICAgICAgc2NhbGVZTWluPXswLjc1fVxuICAgICAgICAgIHNjYWxlWU1heD17OH1cbiAgICAgICAgICB0cmFuc2Zvcm1NYXRyaXg9e0lOSVRJQUxfVFJBTlNGT1JNfVxuICAgICAgICA+XG4gICAgICAgICAge3pvb20gPT4gKFxuICAgICAgICAgICAgPFJlbGF0aXZlRGl2PlxuICAgICAgICAgICAgICA8c3ZnXG4gICAgICAgICAgICAgICAgd2lkdGg9e3dpZHRofVxuICAgICAgICAgICAgICAgIGhlaWdodD17aGVpZ2h0fVxuICAgICAgICAgICAgICAgIHN0eWxlPXt7IGN1cnNvcjogem9vbS5pc0RyYWdnaW5nID8gJ2dyYWJiaW5nJyA6ICdncmFiJyB9fVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPFJlY3RDbGlwUGF0aCBpZD1cInpvb20tY2xpcFwiIHdpZHRoPXt3aWR0aH0gaGVpZ2h0PXtoZWlnaHR9IC8+XG4gICAgICAgICAgICAgICAgPGdcbiAgICAgICAgICAgICAgICAgIG9uV2hlZWw9e3pvb20uaGFuZGxlV2hlZWx9XG4gICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvanN4LWhhbmRsZXItbmFtZXNcbiAgICAgICAgICAgICAgICAgIG9uTW91c2VEb3duPXt6b29tLmRyYWdTdGFydH1cbiAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9qc3gtaGFuZGxlci1uYW1lc1xuICAgICAgICAgICAgICAgICAgb25Nb3VzZU1vdmU9e3pvb20uZHJhZ01vdmV9XG4gICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvanN4LWhhbmRsZXItbmFtZXNcbiAgICAgICAgICAgICAgICAgIG9uTW91c2VVcD17em9vbS5kcmFnRW5kfVxuICAgICAgICAgICAgICAgICAgb25Nb3VzZUxlYXZlPXsoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghem9vbS5pc0RyYWdnaW5nKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHpvb20uZHJhZ0VuZCgpO1xuICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgIG9uRG91YmxlQ2xpY2s9e2V2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBsb2NhbFBvaW50KGV2ZW50KSB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHpvb20uc2NhbGUoeyBzY2FsZVg6IDEuMSwgc2NhbGVZOiAxLjEsIHBvaW50IH0pO1xuICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICA8cmVjdCB3aWR0aD17d2lkdGh9IGhlaWdodD17aGVpZ2h0fSBmaWxsPVwidHJhbnNwYXJlbnRcIiAvPlxuICAgICAgICAgICAgICAgICAgPGcgdHJhbnNmb3JtPXt6b29tLnRvU3RyaW5nKCl9PntyZW5kZXJlZE1hcH08L2c+XG4gICAgICAgICAgICAgICAgPC9nPlxuICAgICAgICAgICAgICAgIHtzaG93TWluaU1hcCAmJiAoXG4gICAgICAgICAgICAgICAgICA8ZyBjbGlwUGF0aD1cInVybCgjem9vbS1jbGlwKVwiIHRyYW5zZm9ybT17bWluaU1hcFRyYW5zZm9ybX0+XG4gICAgICAgICAgICAgICAgICAgIDxyZWN0IHdpZHRoPXt3aWR0aH0gaGVpZ2h0PXtoZWlnaHR9IGZpbGw9XCIjZmZmXCIgc3Ryb2tlPVwiIzk5OVwiIC8+XG4gICAgICAgICAgICAgICAgICAgIHtyZW5kZXJlZE1hcH1cbiAgICAgICAgICAgICAgICAgICAgPHJlY3RcbiAgICAgICAgICAgICAgICAgICAgICB3aWR0aD17d2lkdGh9XG4gICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0PXtoZWlnaHR9XG4gICAgICAgICAgICAgICAgICAgICAgZmlsbD1cIndoaXRlXCJcbiAgICAgICAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eT17MC4yfVxuICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZT1cIiM5OTlcIlxuICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoPXs0fVxuICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybT17em9vbS50b1N0cmluZ0ludmVydCgpfVxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgPC9nPlxuICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgICAgICA8Wm9vbUNvbnRyb2xzPlxuICAgICAgICAgICAgICAgIDxJY29uQnV0dG9uIHR5cGU9XCJidXR0b25cIiBvbkNsaWNrPXsoKSA9PiB6b29tLnNjYWxlKHsgc2NhbGVYOiAxLjIsIHNjYWxlWTogMS4yIH0pfT5cbiAgICAgICAgICAgICAgICAgICtcbiAgICAgICAgICAgICAgICA8L0ljb25CdXR0b24+XG4gICAgICAgICAgICAgICAgPEljb25CdXR0b24gdHlwZT1cImJ1dHRvblwiIG9uQ2xpY2s9eygpID0+IHpvb20uc2NhbGUoeyBzY2FsZVg6IDAuOCwgc2NhbGVZOiAwLjggfSl9PlxuICAgICAgICAgICAgICAgICAgLVxuICAgICAgICAgICAgICAgIDwvSWNvbkJ1dHRvbj5cbiAgICAgICAgICAgICAgICA8VGV4dEJ1dHRvblxuICAgICAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvanN4LWhhbmRsZXItbmFtZXNcbiAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3pvb20uY2xlYXJ9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgUmVzZXRcbiAgICAgICAgICAgICAgICA8L1RleHRCdXR0b24+XG4gICAgICAgICAgICAgIDwvWm9vbUNvbnRyb2xzPlxuICAgICAgICAgICAgICA8TWluaU1hcENvbnRyb2w+XG4gICAgICAgICAgICAgICAgPFRleHRCdXR0b25cbiAgICAgICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2pzeC1oYW5kbGVyLW5hbWVzXG4gICAgICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLnRvZ2dsZU1pbmlNYXB9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAge3Nob3dNaW5pTWFwID8gdCgnSGlkZSBNaW5pIE1hcCcpIDogdCgnU2hvdyBNaW5pIE1hcCcpfVxuICAgICAgICAgICAgICAgIDwvVGV4dEJ1dHRvbj5cbiAgICAgICAgICAgICAgPC9NaW5pTWFwQ29udHJvbD5cbiAgICAgICAgICAgIDwvUmVsYXRpdmVEaXY+XG4gICAgICAgICAgKX1cbiAgICAgICAgPC9ab29tPlxuICAgICAgICB7dG9vbHRpcE9wZW4gJiYgKFxuICAgICAgICAgIDxNYXBUb29sdGlwXG4gICAgICAgICAgICBlbmNvZGVyPXtlbmNvZGVyfVxuICAgICAgICAgICAgdG9wPXt0b29sdGlwVG9wfVxuICAgICAgICAgICAgbGVmdD17dG9vbHRpcExlZnR9XG4gICAgICAgICAgICB0b29sdGlwRGF0YT17dG9vbHRpcERhdGF9XG4gICAgICAgICAgLz5cbiAgICAgICAgKX1cbiAgICAgIDwvPlxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgd2l0aFRvb2x0aXAoQ2hvcm9wbGV0aE1hcCk7XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFFQTtBQUVBOztBQUVBO0FBRUE7O0FBRUE7QUFDQTs7OztBQUlBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBOztBQUVBO0FBRUE7O0FBRUE7Ozs7QUFJQTtBQUNBOztBQUVBOzs7Ozs7QUM3Q0E7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUlBOzs7QUN4REE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFRQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQWlCQTtBQUNBO0FBSEE7QUEwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW5DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFjQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFTQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBRUE7QUFZQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQVlBO0FBQ0E7QUFHQTtBQUdBO0FBRUE7QUFDQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBUUE7QUFVQTs7QUFwT0E7QUF1T0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2484\n')}}]);