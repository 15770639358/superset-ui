(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{2347:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, "default", function() { return /* binding */ TableChart; });\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react/index.js\nvar react = __webpack_require__(0);\nvar react_default = /*#__PURE__*/__webpack_require__.n(react);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-array/src/max.js\nvar max = __webpack_require__(224);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-array/src/extent.js\nvar extent = __webpack_require__(290);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react-icons/fa/index.esm.js + 4 modules\nvar index_esm = __webpack_require__(2307);\n\n// EXTERNAL MODULE: ../superset-ui-translation/src/TranslatorSingleton.ts + 1 modules\nvar TranslatorSingleton = __webpack_require__(2);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/types.ts\nvar types = __webpack_require__(145);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react-table/index.js\nvar react_table = __webpack_require__(1727);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/match-sorter/dist/match-sorter.esm.js\nvar match_sorter_esm = __webpack_require__(2300);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/regenerator-runtime/runtime.js\nvar runtime = __webpack_require__(311);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/DataTable/utils/useAsyncState.ts\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\n// useAsyncDebounce in dist build of `react-table` requires regeneratorRuntime\n\n/**\n * Hook useState to allow always return latest initialValue\n */\nfunction useAsyncState(initialValue, callback, wait = 200) {\n    const [value, setValue] = Object(react["useState"])(initialValue);\n    const valueRef = Object(react["useRef"])(initialValue);\n    const onChange = Object(react_table["useAsyncDebounce"])(callback, wait);\n    // sync updated initialValue\n    if (valueRef.current !== initialValue) {\n        valueRef.current = initialValue;\n        if (value !== initialValue) {\n            setValue(initialValue);\n        }\n    }\n    const setBoth = (newValue) => {\n        setValue(newValue);\n        onChange(newValue);\n    };\n    return [value, setBoth];\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/DataTable/components/GlobalFilter.tsx\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\nfunction DefaultSearchInput({ count, value, onChange }) {\n    return (react_default.a.createElement("span", { className: "dt-global-filter" },\n        "Search",\n        \' \',\n        react_default.a.createElement("input", { className: "form-control input-sm", placeholder: `${count} records...`, value: value, onChange: onChange })));\n}\n/* harmony default export */ var components_GlobalFilter = (react_default.a.memo(function GlobalFilter({ preGlobalFilteredRows, filterValue = \'\', searchInput, setGlobalFilter, }) {\n    const count = preGlobalFilteredRows.length;\n    const [value, setValue] = useAsyncState(filterValue, (newValue) => {\n        setGlobalFilter(newValue || undefined);\n    }, 200);\n    const SearchInput = searchInput || DefaultSearchInput;\n    return (react_default.a.createElement(SearchInput, { count: count, value: value, onChange: e => {\n            const target = e.target;\n            e.preventDefault();\n            setValue(target.value);\n        } }));\n}));\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/DataTable/components/SelectPageSize.tsx\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nfunction getOptionValue(x) {\n    return Array.isArray(x) ? x[0] : x;\n}\n/* harmony default export */ var components_SelectPageSize = (react_default.a.memo(function SelectPageSize({ total, sizeOptions, currentSize, onChange, }) {\n    const sizeOptionValues = sizeOptions.map(getOptionValue);\n    let options = [...sizeOptions];\n    // insert current size to list\n    if (currentSize !== undefined &&\n        (currentSize !== total || !sizeOptionValues.includes(0)) &&\n        !sizeOptionValues.includes(currentSize)) {\n        options = [...sizeOptions];\n        options.splice(sizeOptionValues.findIndex(x => x > currentSize), 0, currentSize);\n    }\n    const current = currentSize === undefined ? sizeOptionValues[0] : currentSize;\n    return (react_default.a.createElement("span", { className: "dt-select-page-size form-inline" },\n        "Show",\n        \' \',\n        react_default.a.createElement("select", { className: "form-control input-sm", value: current, onBlur: () => { }, onChange: e => {\n                onChange(Number(e.target.value));\n            } }, options.map(option => {\n            const [size, text] = Array.isArray(option) ? option : [option, option];\n            return (react_default.a.createElement("option", { key: size, value: size }, text));\n        })),\n        \' \',\n        "entries"));\n}));\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/DataTable/components/Pagination.tsx\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n// first, ..., prev, current, next, ..., last\nconst MINIMAL_PAGE_ITEM_COUNT = 7;\n/**\n * Generate numeric page items around current page.\n *   - Always include first and last page\n *   - Add ellipsis if needed\n */\nfunction generatePageItems(total, current, width) {\n    if (width < MINIMAL_PAGE_ITEM_COUNT) {\n        throw new Error(`Must allow at least ${MINIMAL_PAGE_ITEM_COUNT} page items`);\n    }\n    if (width % 2 === 0) {\n        throw new Error(`Must allow odd number of page items`);\n    }\n    if (total < width) {\n        return [...new Array(total).keys()];\n    }\n    const left = Math.max(0, Math.min(total - width, current - Math.floor(width / 2)));\n    const items = new Array(width);\n    for (let i = 0; i < width; i += 1) {\n        items[i] = i + left;\n    }\n    // replace non-ending items with placeholders\n    if (items[0] > 0) {\n        items[0] = 0;\n        items[1] = \'prev-more\';\n    }\n    if (items[items.length - 1] < total - 1) {\n        items[items.length - 1] = total - 1;\n        items[items.length - 2] = \'next-more\';\n    }\n    return items;\n}\n/* harmony default export */ var components_Pagination = (react_default.a.memo(react_default.a.forwardRef(function Pagination({ style, pageCount, currentPage = 0, maxPageItemCount = 9, onPageChange }, ref) {\n    const pageItems = generatePageItems(pageCount, currentPage, maxPageItemCount);\n    return (react_default.a.createElement("div", { ref: ref, className: "dt-pagination", style: style },\n        react_default.a.createElement("ul", { className: "pagination pagination-sm" }, pageItems.map((item, i) => typeof item === \'number\' ? (\n        // actual page number\n        react_default.a.createElement("li", { key: item, className: currentPage === item ? \'active\' : undefined },\n            react_default.a.createElement("a", { href: `#page-${item}`, role: "button", onClick: e => {\n                    e.preventDefault();\n                    onPageChange(item);\n                } }, item + 1))) : (react_default.a.createElement("li", { key: item, className: "dt-pagination-ellipsis" },\n            react_default.a.createElement("span", null, "\\u2026")))))));\n})));\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/DataTable/utils/getScrollBarSize.ts\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nlet cached;\nconst css = (x) => x.join(\'\\n\');\nfunction getScrollBarSize(forceRefresh = false) {\n    if (typeof document === \'undefined\') {\n        return 0;\n    }\n    if (cached === undefined || forceRefresh) {\n        const inner = document.createElement(\'div\');\n        const outer = document.createElement(\'div\');\n        inner.style.cssText = css `\n      width: auto;\n      height: 100%;\n      overflow: scroll;\n    `;\n        outer.style.cssText = css `\n      position: absolute;\n      visibility: hidden;\n      overflow: hidden;\n      width: 100px;\n      height: 50px;\n    `;\n        outer.append(inner);\n        document.body.append(outer);\n        cached = outer.clientWidth - inner.clientWidth;\n        outer.remove();\n    }\n    return cached;\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/DataTable/utils/needScrollBar.ts\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/**\n * Whether a container need scroll bars when in another container.\n */\nfunction needScrollBar({ width, height, innerHeight, innerWidth, scrollBarSize, }) {\n    const hasVerticalScroll = innerHeight > height;\n    const hasHorizontalScroll = innerWidth > width - (hasVerticalScroll ? scrollBarSize : 0);\n    return [hasVerticalScroll, hasHorizontalScroll];\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/DataTable/utils/useMountedMemo.ts\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n/**\n * Execute a memoized callback only when mounted. Execute again when factory updated.\n * Returns undefined if not mounted yet.\n */\nfunction useMountedMemo(factory, deps) {\n    const mounted = Object(react["useRef"])();\n    Object(react["useLayoutEffect"])(() => {\n        mounted.current = factory;\n    });\n    return Object(react["useMemo"])(() => {\n        if (mounted.current) {\n            return factory();\n        }\n        return undefined;\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [mounted.current, mounted.current === factory, ...(deps || [])]);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/DataTable/hooks/useSticky.tsx\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\n\n\nvar ReducerActions;\n(function (ReducerActions) {\n    ReducerActions["init"] = "init";\n    ReducerActions["setStickyState"] = "setStickyState";\n})(ReducerActions || (ReducerActions = {}));\nconst sum = (a, b) => a + b;\nconst mergeStyleProp = (node, style) => ({\n    style: Object.assign(Object.assign({}, node.props.style), style),\n});\n/**\n * An HOC for generating sticky header and fixed-height scrollable area\n */\nfunction StickyWrap({ sticky = {}, width: maxWidth, height: maxHeight, children: table, setStickyState, }) {\n    if (!table || table.type !== \'table\') {\n        throw new Error(\'<StickyWrap> must have only one <table> element as child\');\n    }\n    let thead;\n    let tbody;\n    let colgroup;\n    react_default.a.Children.forEach(table.props.children, node => {\n        if (node.type === \'thead\') {\n            thead = node;\n        }\n        else if (node.type === \'tbody\') {\n            tbody = node;\n        }\n        else if (node.type === \'colgroup\') {\n            colgroup = node;\n        }\n    });\n    if (!thead || !tbody) {\n        throw new Error(\'<table> in <StickyWrap> must contain both thead and tbody.\');\n    }\n    const columnCount = Object(react["useMemo"])(() => {\n        const headerRows = react_default.a.Children.toArray(thead === null || thead === void 0 ? void 0 : thead.props.children).pop();\n        return headerRows.props.children.length;\n    }, [thead]);\n    const theadRef = Object(react["useRef"])(null); // original thead for layout computation\n    const scrollHeaderRef = Object(react["useRef"])(null); // fixed header\n    const scrollBodyRef = Object(react["useRef"])(null); // main body\n    const { bodyHeight, columnWidths } = sticky;\n    const needSizer = !columnWidths ||\n        sticky.width !== maxWidth ||\n        sticky.height !== maxHeight ||\n        sticky.setStickyState !== setStickyState;\n    const scrollBarSize = getScrollBarSize();\n    // update scrollable area and header column sizes when mounted\n    Object(react["useLayoutEffect"])(() => {\n        if (theadRef.current) {\n            const bodyThead = theadRef.current;\n            const theadHeight = bodyThead.clientHeight;\n            if (!theadHeight) {\n                return;\n            }\n            const fullTableHeight = bodyThead.parentNode.clientHeight;\n            const ths = bodyThead.childNodes[0].childNodes;\n            const widths = Array.from(ths).map(th => th.clientWidth);\n            const [hasVerticalScroll, hasHorizontalScroll] = needScrollBar({\n                width: maxWidth,\n                height: maxHeight - theadHeight,\n                innerHeight: fullTableHeight,\n                innerWidth: widths.reduce(sum),\n                scrollBarSize,\n            });\n            // real container height, include table header and space for\n            // horizontal scroll bar\n            const realHeight = Math.min(maxHeight, hasHorizontalScroll ? fullTableHeight + scrollBarSize : fullTableHeight);\n            setStickyState({\n                hasVerticalScroll,\n                hasHorizontalScroll,\n                setStickyState,\n                width: maxWidth,\n                height: maxHeight,\n                realHeight,\n                tableHeight: fullTableHeight,\n                bodyHeight: realHeight - theadHeight,\n                columnWidths: widths,\n            });\n        }\n    }, [maxWidth, maxHeight, setStickyState, scrollBarSize]);\n    let sizerTable;\n    let headerTable;\n    let bodyTable;\n    if (needSizer) {\n        const theadWithRef = react_default.a.cloneElement(thead, { ref: theadRef });\n        sizerTable = (react_default.a.createElement("div", { key: "sizer", style: {\n                height: maxHeight,\n                overflow: \'auto\',\n                visibility: \'hidden\',\n            } }, react_default.a.cloneElement(table, {}, colgroup, theadWithRef, tbody)));\n    }\n    // reuse previously column widths, will be updated by `useLayoutEffect` above\n    const colWidths = columnWidths === null || columnWidths === void 0 ? void 0 : columnWidths.slice(0, columnCount);\n    if (colWidths && bodyHeight) {\n        const tableStyle = { tableLayout: \'fixed\' };\n        const bodyCols = colWidths.map((w, i) => (\n        // eslint-disable-next-line react/no-array-index-key\n        react_default.a.createElement("col", { key: i, width: w })));\n        const bodyColgroup = react_default.a.createElement("colgroup", null, bodyCols);\n        // header columns do not have vertical scroll bars,\n        // so we add scroll bar size to the last column\n        const headerColgroup = sticky.hasVerticalScroll && scrollBarSize ? (react_default.a.createElement("colgroup", null, colWidths.map((x, i) => (\n        // eslint-disable-next-line react/no-array-index-key\n        react_default.a.createElement("col", { key: i, width: x + (i === colWidths.length - 1 ? scrollBarSize : 0) }))))) : (bodyColgroup);\n        headerTable = (react_default.a.createElement("div", { key: "header", ref: scrollHeaderRef, style: {\n                overflow: \'hidden\',\n            } },\n            react_default.a.cloneElement(table, mergeStyleProp(table, tableStyle), headerColgroup, thead),\n            headerTable));\n        const onScroll = e => {\n            if (scrollHeaderRef.current) {\n                scrollHeaderRef.current.scrollLeft = e.currentTarget.scrollLeft;\n            }\n        };\n        bodyTable = (react_default.a.createElement("div", { key: "body", ref: scrollBodyRef, style: {\n                height: bodyHeight,\n                overflow: \'auto\',\n            }, onScroll: sticky.hasHorizontalScroll ? onScroll : undefined }, react_default.a.cloneElement(table, mergeStyleProp(table, tableStyle), bodyColgroup, tbody)));\n    }\n    return (react_default.a.createElement("div", { style: {\n            width: maxWidth,\n            height: sticky.realHeight || maxHeight,\n            overflow: \'hidden\',\n        } },\n        headerTable,\n        bodyTable,\n        sizerTable));\n}\nfunction useInstance(instance) {\n    const { dispatch, state: { sticky }, data, page, rows, getTableSize = () => undefined, } = instance;\n    const setStickyState = Object(react["useCallback"])((size) => {\n        dispatch({\n            type: ReducerActions.setStickyState,\n            size,\n        });\n    }, \n    // turning pages would also trigger a resize\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [dispatch, getTableSize, page, rows]);\n    const useStickyWrap = (renderer) => {\n        const { width, height } = useMountedMemo(getTableSize, [getTableSize]) || sticky;\n        // only change of data should trigger re-render\n        const table = Object(react["useMemo"])(renderer, [page, rows]);\n        Object(react["useLayoutEffect"])(() => {\n            if (!width || !height) {\n                setStickyState();\n            }\n        }, [width, height]);\n        if (!width || !height) {\n            return null;\n        }\n        if (data.length === 0) {\n            return table;\n        }\n        return (react_default.a.createElement(StickyWrap, { width: width, height: height, sticky: sticky, setStickyState: setStickyState }, table));\n    };\n    Object.assign(instance, {\n        setStickyState,\n        wrapStickyTable: useStickyWrap,\n    });\n}\nfunction useSticky(hooks) {\n    hooks.useInstance.push(useInstance);\n    hooks.stateReducers.push((newState, action_, previousState, instance) => {\n        const action = action_;\n        if (action.type === ReducerActions.init) {\n            return Object.assign(Object.assign({}, newState), { sticky: newState.sticky || {} });\n        }\n        if (action.type === ReducerActions.setStickyState) {\n            const { size } = action;\n            if (!size) {\n                return Object.assign({}, newState);\n            }\n            return Object.assign(Object.assign({}, newState), { sticky: Object.assign(Object.assign({}, newState.sticky), action.size) });\n        }\n        return newState;\n    });\n}\nuseSticky.pluginName = \'useSticky\';\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/DataTable/hooks/useColumnCellProps.ts\n/**\n * Configure cell props in column options.\n */\nfunction useColumnCellProps(hooks) {\n    hooks.getCellProps.push((props, { cell }) => {\n        const column = cell.column;\n        return (column.cellProps && column.cellProps(cell, props)) || [];\n    });\n}\nuseColumnCellProps.pluginName = \'useColumnCellProps\';\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/DataTable/DataTable.tsx\nvar __rest = (undefined && undefined.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === "function")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\n\n\n\n\n\n\n// Be sure to pass our updateMyData and the skipReset option\nfunction DataTable(_a) {\n    var { tableClassName, columns, data, width: initialWidth = \'100%\', height: initialHeight = 300, pageSize: initialPageSize = 0, initialState: initialState_ = {}, pageSizeOptions = [10, 25, 50, 100, 200], maxPageItemCount = 9, sticky: doSticky, searchInput = true, noResultsText = \'No data found\', hooks, wrapperRef: userWrapperRef } = _a, moreUseTableOptions = __rest(_a, ["tableClassName", "columns", "data", "width", "height", "pageSize", "initialState", "pageSizeOptions", "maxPageItemCount", "sticky", "searchInput", "noResultsText", "hooks", "wrapperRef"]);\n    const tableHooks = [\n        react_table["useGlobalFilter"],\n        react_table["useSortBy"],\n        react_table["usePagination"],\n        useColumnCellProps,\n        doSticky ? useSticky : [],\n        hooks || [],\n    ].flat();\n    const sortByRef = Object(react["useRef"])([]); // cache initial `sortby` so sorting doesn\'t trigger page reset\n    const pageSizeRef = Object(react["useRef"])([initialPageSize, data.length]);\n    const hasPagination = initialPageSize > 0 && data.length > 0; // pageSize == 0 means no pagination\n    const hasGlobalControl = hasPagination || !!searchInput;\n    const initialState = Object.assign(Object.assign({}, initialState_), { \n        // zero length means all pages, the `usePagination` plugin does not\n        // understand pageSize = 0\n        sortBy: sortByRef.current, pageSize: initialPageSize > 0 ? initialPageSize : data.length || 10 });\n    const defaultWrapperRef = Object(react["useRef"])(null);\n    const globalControlRef = Object(react["useRef"])(null);\n    const paginationRef = Object(react["useRef"])(null);\n    const wrapperRef = userWrapperRef || defaultWrapperRef;\n    const defaultGetTableSize = Object(react["useCallback"])(() => {\n        var _a, _b;\n        if (wrapperRef.current) {\n            // `initialWidth` and `initialHeight` could be also parameters like `100%`\n            // `Number` reaturns `NaN` on them, then we fallback to computed size\n            const width = Number(initialWidth) || wrapperRef.current.clientWidth;\n            const height = (Number(initialHeight) || wrapperRef.current.clientHeight) -\n                (((_a = globalControlRef.current) === null || _a === void 0 ? void 0 : _a.clientHeight) || 0) -\n                (((_b = paginationRef.current) === null || _b === void 0 ? void 0 : _b.clientHeight) || 0);\n            return { width, height };\n        }\n        return undefined;\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [initialHeight, initialWidth, wrapperRef, hasPagination, hasGlobalControl]);\n    const defaultGlobalFilter = Object(react["useCallback"])((rows, columnIds, filterValue) => {\n        // allow searching by "col1 col2"\n        const joinedString = (row) => {\n            return columnIds.map(x => row.values[x]).join(\' \');\n        };\n        return Object(match_sorter_esm["a" /* default */])(rows, filterValue, {\n            keys: [...columnIds, joinedString],\n            threshold: match_sorter_esm["a" /* default */].rankings.ACRONYM,\n        });\n    }, []);\n    const { getTableProps, getTableBodyProps, prepareRow, headerGroups, page, pageCount, gotoPage, preGlobalFilteredRows, setGlobalFilter, setPageSize: setPageSize_, wrapStickyTable, state: { pageIndex, pageSize, globalFilter: filterValue, sticky = {} }, } = Object(react_table["useTable"])(Object.assign({ columns,\n        data,\n        initialState, getTableSize: defaultGetTableSize, globalFilter: defaultGlobalFilter }, moreUseTableOptions), ...tableHooks);\n    // make setPageSize accept 0\n    const setPageSize = (size) => {\n        // keep the original size if data is empty\n        if (size || data.length !== 0) {\n            setPageSize_(size === 0 ? data.length : size);\n        }\n    };\n    const renderTable = () => (react_default.a.createElement("table", Object.assign({}, getTableProps({ className: tableClassName })),\n        react_default.a.createElement("thead", null, headerGroups.map(headerGroup => {\n            const _a = headerGroup.getHeaderGroupProps(), { key: headerGroupKey } = _a, headerGroupProps = __rest(_a, ["key"]);\n            return (react_default.a.createElement("tr", Object.assign({ key: headerGroupKey || headerGroup.id }, headerGroupProps), headerGroup.headers.map(column => {\n                const _a = column.getHeaderProps(column.getSortByToggleProps()), { key: headerKey, className } = _a, props = __rest(_a, ["key", "className"]);\n                return (react_default.a.createElement("th", Object.assign({ key: headerKey || column.id, className: column.isSorted ? `${className || \'\'} is-sorted` : className }, props),\n                    column.render(\'Header\'),\n                    column.render(\'SortIcon\')));\n            })));\n        })),\n        react_default.a.createElement("tbody", Object.assign({}, getTableBodyProps()), page && page.length > 0 ? (page.map(row => {\n            prepareRow(row);\n            const _a = row.getRowProps(), { key: rowKey } = _a, rowProps = __rest(_a, ["key"]);\n            return (react_default.a.createElement("tr", Object.assign({ key: rowKey || row.id }, rowProps), row.cells.map(cell => {\n                const cellProps = cell.getCellProps();\n                const { key: cellKey, cellContent } = cellProps, restProps = __rest(cellProps, ["key", "cellContent"]);\n                const key = cellKey || cell.column.id;\n                if (cellProps.dangerouslySetInnerHTML) {\n                    return react_default.a.createElement("td", Object.assign({ key: key }, restProps));\n                }\n                // If cellProps renderes textContent already, then we don\'t have to\n                // render `Cell`. This saves some time for large tables.\n                return (react_default.a.createElement("td", Object.assign({ key: key }, restProps), cellContent || cell.render(\'Cell\')));\n            })));\n        })) : (react_default.a.createElement("tr", null,\n            react_default.a.createElement("td", { className: "dt-no-results", colSpan: columns.length }, typeof noResultsText === \'function\'\n                ? noResultsText(filterValue)\n                : noResultsText))))));\n    // force upate the pageSize when it\'s been update from the initial state\n    if (pageSizeRef.current[0] !== initialPageSize ||\n        // when initialPageSize stays as zero, but total number of records changed,\n        // we\'d also need to update page size\n        (initialPageSize === 0 && pageSizeRef.current[1] !== data.length)) {\n        pageSizeRef.current = [initialPageSize, data.length];\n        setPageSize(initialPageSize);\n    }\n    return (react_default.a.createElement("div", { ref: wrapperRef, style: { width: initialWidth, height: initialHeight } },\n        hasGlobalControl ? (react_default.a.createElement("div", { ref: globalControlRef, className: "form-inline dt-controls" },\n            react_default.a.createElement("div", { className: "row" },\n                react_default.a.createElement("div", { className: "col-sm-6" }, hasPagination ? (react_default.a.createElement(components_SelectPageSize, { total: data.length, sizeOptions: pageSizeOptions, currentSize: pageSize, onChange: setPageSize })) : null),\n                searchInput ? (react_default.a.createElement("div", { className: "col-sm-6" },\n                    react_default.a.createElement(components_GlobalFilter, { searchInput: typeof searchInput === \'boolean\' ? undefined : searchInput, preGlobalFilteredRows: preGlobalFilteredRows, setGlobalFilter: setGlobalFilter, filterValue: filterValue }))) : null))) : null,\n        wrapStickyTable ? wrapStickyTable(renderTable) : renderTable(),\n        hasPagination ? (react_default.a.createElement(components_Pagination, { ref: paginationRef, style: sticky.height ? undefined : { visibility: \'hidden\' }, maxPageItemCount: maxPageItemCount, pageCount: pageCount, currentPage: pageIndex, onPageChange: gotoPage })) : null));\n}\n\n// EXTERNAL MODULE: ../superset-ui-style/src/index.ts\nvar src = __webpack_require__(150);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/Styles.tsx\n\n/* harmony default export */ var Styles = (src["a" /* default */].div `\n  table {\n    width: 100%;\n    min-width: auto;\n    max-width: none;\n    margin: 0;\n  }\n\n  th,\n  td {\n    min-width: 4.3em;\n  }\n\n  thead > tr > th {\n    padding-right: 1.4em;\n    position: relative;\n    background: #fff;\n  }\n  th svg {\n    color: #ccc;\n    position: absolute;\n    bottom: 0.6em;\n    right: 0.2em;\n  }\n  th.is-sorted svg {\n    color: #a8a8a8;\n  }\n  .table > tbody > tr:first-of-type > td,\n  .table > tbody > tr:first-of-type > th {\n    border-top: 0;\n  }\n\n  .dt-controls {\n    padding-bottom: 0.65em;\n  }\n  .dt-metric {\n    text-align: right;\n  }\n  td.dt-is-filter {\n    cursor: pointer;\n  }\n  td.dt-is-filter:hover {\n    background-color: linen;\n  }\n  td.dt-is-active-filter,\n  td.dt-is-active-filter:hover {\n    background-color: lightcyan;\n  }\n\n  .dt-global-filter {\n    float: right;\n  }\n\n  .dt-pagination {\n    text-align: right;\n    /* use padding instead of margin so clientHeight can capture it */\n    padding-top: 0.5em;\n  }\n  .dt-pagination .pagination {\n    margin: 0;\n  }\n\n  .pagination > li > span.dt-pagination-ellipsis:focus,\n  .pagination > li > span.dt-pagination-ellipsis:hover {\n    background: #fff;\n  }\n\n  .dt-no-results {\n    text-align: center;\n    padding: 1em 0.6em;\n  }\n`);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/xss/lib/index.js\nvar lib = __webpack_require__(2295);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/utils/formatValue.ts\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nconst xss = new lib["FilterXSS"]({\n    whiteList: Object.assign(Object.assign({}, Object(lib["getDefaultWhiteList"])()), { span: [\'style\', \'class\', \'title\'], div: [\'style\', \'class\'], a: [\'style\', \'class\', \'href\', \'title\', \'target\'], img: [\'style\', \'class\', \'src\', \'alt\', \'title\', \'width\', \'height\'] }),\n    stripIgnoreTag: true,\n    css: false,\n});\nfunction isProbablyHTML(text) {\n    return /<[^>]+>/.test(text);\n}\n/**\n * Format text for cell value\n */\nfunction formatValue({ formatter }, value) {\n    if (value === null) {\n        return [false, \'N/A\'];\n    }\n    if (formatter) {\n        // in case percent metric can specify percent format in the future\n        return [false, formatter(value)];\n    }\n    if (typeof value === \'string\') {\n        return isProbablyHTML(value) ? [true, xss.process(value)] : [false, value];\n    }\n    return [false, value.toString()];\n}\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/controlPanel.tsx\nvar controlPanel = __webpack_require__(559);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/TableChart.tsx\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\n\n\n\n\n\n\n\n/**\n * Return sortType based on data type\n */\nfunction getSortTypeByDataType(dataType) {\n    if (dataType === types["a" /* DataType */].DateTime) {\n        return \'datetime\';\n    }\n    if (dataType === types["a" /* DataType */].String) {\n        return \'alphanumeric\';\n    }\n    return \'basic\';\n}\n/**\n * Cell background to render columns as horizontal bar chart\n */\nfunction cellBar({ value, valueRange, colorPositiveNegative = false, alignPositiveNegative, }) {\n    const [minValue, maxValue] = valueRange;\n    const r = colorPositiveNegative && value < 0 ? 150 : 0;\n    if (alignPositiveNegative) {\n        const perc = Math.abs(Math.round((value / maxValue) * 100));\n        // The 0.01 to 0.001 is a workaround for what appears to be a\n        // CSS rendering bug on flat, transparent colors\n        return (`linear-gradient(to right, rgba(${r},0,0,0.2), rgba(${r},0,0,0.2) ${perc}%, ` +\n            `rgba(0,0,0,0.01) ${perc}%, rgba(0,0,0,0.001) 100%)`);\n    }\n    const posExtent = Math.abs(Math.max(maxValue, 0));\n    const negExtent = Math.abs(Math.min(minValue, 0));\n    const tot = posExtent + negExtent;\n    const perc1 = Math.round((Math.min(negExtent + value, negExtent) / tot) * 100);\n    const perc2 = Math.round((Math.abs(value) / tot) * 100);\n    // The 0.01 to 0.001 is a workaround for what appears to be a\n    // CSS rendering bug on flat, transparent colors\n    return (`linear-gradient(to right, rgba(0,0,0,0.01), rgba(0,0,0,0.001) ${perc1}%, ` +\n        `rgba(${r},0,0,0.2) ${perc1}%, rgba(${r},0,0,0.2) ${perc1 + perc2}%, ` +\n        `rgba(0,0,0,0.01) ${perc1 + perc2}%, rgba(0,0,0,0.001) 100%)`);\n}\nfunction SortIcon({ column }) {\n    const { isSorted, isSortedDesc } = column;\n    let sortIcon = react_default.a.createElement(index_esm["a" /* FaSort */], null);\n    if (isSorted) {\n        sortIcon = isSortedDesc ? react_default.a.createElement(index_esm["b" /* FaSortDown */], null) : react_default.a.createElement(index_esm["c" /* FaSortUp */], null);\n    }\n    return sortIcon;\n}\nfunction TableChart_SearchInput({ count, value, onChange }) {\n    return (react_default.a.createElement("span", { className: "dt-global-filter" },\n        Object(TranslatorSingleton["b" /* t */])(\'Search\'),\n        \' \',\n        react_default.a.createElement("input", { className: "form-control input-sm", placeholder: Object(TranslatorSingleton["b" /* t */])(\'%s records...\', count), value: value, onChange: onChange })));\n}\nfunction TableChart(props) {\n    const { height, width, data, columns: columnsMeta, alignPositiveNegative = false, colorPositiveNegative = false, includeSearch = false, pageSize = 0, showCellBars = true, emitFilter = false, sortDesc = false, onChangeFilter, filters: initialFilters, sticky = true, } = props;\n    const [filters, setFilters] = Object(react["useState"])(initialFilters);\n    // only take relevant page size options\n    const pageSizeOptions = Object(react["useMemo"])(() => controlPanel["a" /* PAGE_SIZE_OPTIONS */].filter(([n, _]) => n <= 2 * data.length), [data.length]);\n    const getValueRange = Object(react["useCallback"])(function getValueRange(key) {\n        var _a;\n        if (typeof ((_a = data === null || data === void 0 ? void 0 : data[0]) === null || _a === void 0 ? void 0 : _a[key]) === \'number\') {\n            const nums = data.map(row => row[key]);\n            return (alignPositiveNegative\n                ? [0, Object(max["a" /* default */])(nums.map(Math.abs))]\n                : Object(extent["a" /* default */])(nums));\n        }\n        return null;\n    }, [alignPositiveNegative, data]);\n    const isActiveFilterValue = Object(react["useCallback"])(function isActiveFilterValue(key, val) {\n        var _a;\n        return !!filters && ((_a = filters[key]) === null || _a === void 0 ? void 0 : _a.includes(val));\n    }, [filters]);\n    const toggleFilter = Object(react["useCallback"])(function toggleFilter(key, val) {\n        const updatedFilters = Object.assign({}, (filters || {}));\n        if (filters && isActiveFilterValue(key, val)) {\n            updatedFilters[key] = filters[key].filter((x) => x !== val);\n        }\n        else {\n            updatedFilters[key] = [...((filters === null || filters === void 0 ? void 0 : filters[key]) || []), val];\n        }\n        setFilters(updatedFilters);\n        if (onChangeFilter) {\n            onChangeFilter(updatedFilters);\n        }\n    }, [filters, isActiveFilterValue, onChangeFilter]);\n    const getColumnConfigs = Object(react["useCallback"])((column, i) => {\n        const { key, label, dataType } = column;\n        const valueRange = showCellBars && getValueRange(key);\n        const cellProps = ({ value: value_ }, sharedCellProps) => {\n            let className = \'\';\n            const value = value_;\n            if (dataType === types["a" /* DataType */].Number) {\n                className += \' dt-metric\';\n            }\n            else if (emitFilter) {\n                className += \' dt-is-filter\';\n                if (isActiveFilterValue(key, value)) {\n                    className += \' dt-is-active-filter\';\n                }\n            }\n            const [isHtml, text] = formatValue(column, value);\n            const style = Object.assign(Object.assign({}, sharedCellProps.style), { background: valueRange\n                    ? cellBar({\n                        value: value,\n                        valueRange,\n                        alignPositiveNegative,\n                        colorPositiveNegative,\n                    })\n                    : undefined });\n            return {\n                // show raw number in title in case of numeric values\n                title: typeof value === \'number\' ? String(value) : undefined,\n                dangerouslySetInnerHTML: isHtml ? { __html: text } : undefined,\n                cellContent: text,\n                onClick: emitFilter && !valueRange ? () => toggleFilter(key, value) : undefined,\n                className,\n                style,\n            };\n        };\n        return {\n            id: String(i),\n            // must use custom accessor to allow `.` in column names\n            // typing is incorrect in current version of `@types/react-table`\n            // so we ask TS not to check.\n            accessor: ((datum) => datum[key]),\n            Header: label,\n            SortIcon,\n            sortDescFirst: sortDesc,\n            sortType: getSortTypeByDataType(dataType),\n            cellProps,\n        };\n    }, [\n        alignPositiveNegative,\n        colorPositiveNegative,\n        emitFilter,\n        getValueRange,\n        isActiveFilterValue,\n        showCellBars,\n        sortDesc,\n        toggleFilter,\n    ]);\n    const columns = Object(react["useMemo"])(() => {\n        return columnsMeta.map(getColumnConfigs);\n    }, [columnsMeta, getColumnConfigs]);\n    return (react_default.a.createElement(Styles, null,\n        react_default.a.createElement(DataTable, { columns: columns, data: data, tableClassName: "table table-striped table-condensed", searchInput: includeSearch && TableChart_SearchInput, pageSize: pageSize, pageSizeOptions: pageSizeOptions, width: width, height: height, \n            // 9 page items in > 340px works well even for 100+ pages\n            maxPageItemCount: width > 340 ? 9 : 7, noResultsText: (filter) => Object(TranslatorSingleton["b" /* t */])(filter ? \'No matching records found\' : \'No records found\'), \n            // not in use in Superset, but needed for unit tests\n            sticky: sticky })));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjM0Ny5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wbHVnaW4tY2hhcnQtdGFibGUvc3JjL0RhdGFUYWJsZS91dGlscy91c2VBc3luY1N0YXRlLnRzP2Q0MmUiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9wbHVnaW5zL3BsdWdpbi1jaGFydC10YWJsZS9zcmMvRGF0YVRhYmxlL2NvbXBvbmVudHMvR2xvYmFsRmlsdGVyLnRzeD82NmM3Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wbHVnaW4tY2hhcnQtdGFibGUvc3JjL0RhdGFUYWJsZS9jb21wb25lbnRzL1NlbGVjdFBhZ2VTaXplLnRzeD80MWU4Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wbHVnaW4tY2hhcnQtdGFibGUvc3JjL0RhdGFUYWJsZS9jb21wb25lbnRzL1BhZ2luYXRpb24udHN4PzlhOTIiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9wbHVnaW5zL3BsdWdpbi1jaGFydC10YWJsZS9zcmMvRGF0YVRhYmxlL3V0aWxzL2dldFNjcm9sbEJhclNpemUudHM/NDI0OCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvcGx1Z2luLWNoYXJ0LXRhYmxlL3NyYy9EYXRhVGFibGUvdXRpbHMvbmVlZFNjcm9sbEJhci50cz8xNzUzIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wbHVnaW4tY2hhcnQtdGFibGUvc3JjL0RhdGFUYWJsZS91dGlscy91c2VNb3VudGVkTWVtby50cz85YzI5Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wbHVnaW4tY2hhcnQtdGFibGUvc3JjL0RhdGFUYWJsZS9ob29rcy91c2VTdGlja3kudHN4P2YwNGUiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9wbHVnaW5zL3BsdWdpbi1jaGFydC10YWJsZS9zcmMvRGF0YVRhYmxlL2hvb2tzL3VzZUNvbHVtbkNlbGxQcm9wcy50cz8zOGM3Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wbHVnaW4tY2hhcnQtdGFibGUvc3JjL0RhdGFUYWJsZS9EYXRhVGFibGUudHN4PzM4NjQiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9wbHVnaW5zL3BsdWdpbi1jaGFydC10YWJsZS9zcmMvU3R5bGVzLnRzeD8zYzJmIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wbHVnaW4tY2hhcnQtdGFibGUvc3JjL3V0aWxzL2Zvcm1hdFZhbHVlLnRzPzAxNTQiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9wbHVnaW5zL3BsdWdpbi1jaGFydC10YWJsZS9zcmMvVGFibGVDaGFydC50c3g/MjgyNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlQXN5bmNEZWJvdW5jZSB9IGZyb20gJ3JlYWN0LXRhYmxlJztcblxuLy8gdXNlQXN5bmNEZWJvdW5jZSBpbiBkaXN0IGJ1aWxkIG9mIGByZWFjdC10YWJsZWAgcmVxdWlyZXMgcmVnZW5lcmF0b3JSdW50aW1lXG5pbXBvcnQgJ3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZSc7XG5cbi8qKlxuICogSG9vayB1c2VTdGF0ZSB0byBhbGxvdyBhbHdheXMgcmV0dXJuIGxhdGVzdCBpbml0aWFsVmFsdWVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXNlQXN5bmNTdGF0ZTxULCBGIGV4dGVuZHMgKG5ld1ZhbHVlOiBUKSA9PiB1bmtub3duPihcbiAgaW5pdGlhbFZhbHVlOiBULFxuICBjYWxsYmFjazogRixcbiAgd2FpdDogbnVtYmVyID0gMjAwLFxuKSB7XG4gIGNvbnN0IFt2YWx1ZSwgc2V0VmFsdWVdID0gdXNlU3RhdGUoaW5pdGlhbFZhbHVlKTtcbiAgY29uc3QgdmFsdWVSZWYgPSB1c2VSZWYoaW5pdGlhbFZhbHVlKTtcbiAgY29uc3Qgb25DaGFuZ2UgPSB1c2VBc3luY0RlYm91bmNlKGNhbGxiYWNrLCB3YWl0KTtcblxuICAvLyBzeW5jIHVwZGF0ZWQgaW5pdGlhbFZhbHVlXG4gIGlmICh2YWx1ZVJlZi5jdXJyZW50ICE9PSBpbml0aWFsVmFsdWUpIHtcbiAgICB2YWx1ZVJlZi5jdXJyZW50ID0gaW5pdGlhbFZhbHVlO1xuICAgIGlmICh2YWx1ZSAhPT0gaW5pdGlhbFZhbHVlKSB7XG4gICAgICBzZXRWYWx1ZShpbml0aWFsVmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHNldEJvdGggPSAobmV3VmFsdWU6IFQpID0+IHtcbiAgICBzZXRWYWx1ZShuZXdWYWx1ZSk7XG4gICAgb25DaGFuZ2UobmV3VmFsdWUpO1xuICB9O1xuXG4gIHJldHVybiBbdmFsdWUsIHNldEJvdGhdIGFzIFt0eXBlb2YgdmFsdWUsIHR5cGVvZiBzZXRWYWx1ZV07XG59XG4iLCIvKipcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50VHlwZSwgQ2hhbmdlRXZlbnRIYW5kbGVyIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUm93LCBGaWx0ZXJWYWx1ZSB9IGZyb20gJ3JlYWN0LXRhYmxlJztcbmltcG9ydCB1c2VBc3luY1N0YXRlIGZyb20gJy4uL3V0aWxzL3VzZUFzeW5jU3RhdGUnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNlYXJjaElucHV0UHJvcHMge1xuICBjb3VudDogbnVtYmVyO1xuICB2YWx1ZTogc3RyaW5nO1xuICBvbkNoYW5nZTogQ2hhbmdlRXZlbnRIYW5kbGVyPEhUTUxJbnB1dEVsZW1lbnQ+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdsb2JhbEZpbHRlclByb3BzPEQgZXh0ZW5kcyBvYmplY3Q+IHtcbiAgcHJlR2xvYmFsRmlsdGVyZWRSb3dzOiBSb3c8RD5bXTtcbiAgLy8gZmlsdGVyIHZhbHVlIGNhbm5vdCBiZSBgdW5kZWZpbmVkYCBvdGhlcndpc2UgUmVhY3Qgd2lsbCByZXBvcnQgY29tcG9uZW50XG4gIC8vIGNvbnRyb2wgdHlwZSB1bmRlZmluZWQgZXJyb3JcbiAgZmlsdGVyVmFsdWU6IHN0cmluZztcbiAgc2V0R2xvYmFsRmlsdGVyOiAoZmlsdGVyVmFsdWU6IEZpbHRlclZhbHVlKSA9PiB2b2lkO1xuICBzZWFyY2hJbnB1dD86IENvbXBvbmVudFR5cGU8U2VhcmNoSW5wdXRQcm9wcz47XG59XG5cbmZ1bmN0aW9uIERlZmF1bHRTZWFyY2hJbnB1dCh7IGNvdW50LCB2YWx1ZSwgb25DaGFuZ2UgfTogU2VhcmNoSW5wdXRQcm9wcykge1xuICByZXR1cm4gKFxuICAgIDxzcGFuIGNsYXNzTmFtZT1cImR0LWdsb2JhbC1maWx0ZXJcIj5cbiAgICAgIFNlYXJjaHsnICd9XG4gICAgICA8aW5wdXRcbiAgICAgICAgY2xhc3NOYW1lPVwiZm9ybS1jb250cm9sIGlucHV0LXNtXCJcbiAgICAgICAgcGxhY2Vob2xkZXI9e2Ake2NvdW50fSByZWNvcmRzLi4uYH1cbiAgICAgICAgdmFsdWU9e3ZhbHVlfVxuICAgICAgICBvbkNoYW5nZT17b25DaGFuZ2V9XG4gICAgICAvPlxuICAgIDwvc3Bhbj5cbiAgKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgKFJlYWN0Lm1lbW8gYXMgPFQ+KGZuOiBUKSA9PiBUKShmdW5jdGlvbiBHbG9iYWxGaWx0ZXI8RCBleHRlbmRzIG9iamVjdD4oe1xuICBwcmVHbG9iYWxGaWx0ZXJlZFJvd3MsXG4gIGZpbHRlclZhbHVlID0gJycsXG4gIHNlYXJjaElucHV0LFxuICBzZXRHbG9iYWxGaWx0ZXIsXG59OiBHbG9iYWxGaWx0ZXJQcm9wczxEPikge1xuICBjb25zdCBjb3VudCA9IHByZUdsb2JhbEZpbHRlcmVkUm93cy5sZW5ndGg7XG4gIGNvbnN0IFt2YWx1ZSwgc2V0VmFsdWVdID0gdXNlQXN5bmNTdGF0ZShcbiAgICBmaWx0ZXJWYWx1ZSxcbiAgICAobmV3VmFsdWU6IHN0cmluZykgPT4ge1xuICAgICAgc2V0R2xvYmFsRmlsdGVyKG5ld1ZhbHVlIHx8IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICAyMDAsXG4gICk7XG5cbiAgY29uc3QgU2VhcmNoSW5wdXQgPSBzZWFyY2hJbnB1dCB8fCBEZWZhdWx0U2VhcmNoSW5wdXQ7XG5cbiAgcmV0dXJuIChcbiAgICA8U2VhcmNoSW5wdXRcbiAgICAgIGNvdW50PXtjb3VudH1cbiAgICAgIHZhbHVlPXt2YWx1ZX1cbiAgICAgIG9uQ2hhbmdlPXtlID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudDtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBzZXRWYWx1ZSh0YXJnZXQudmFsdWUpO1xuICAgICAgfX1cbiAgICAvPlxuICApO1xufSk7XG4iLCIvKipcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5leHBvcnQgdHlwZSBTaXplT3B0aW9uID0gbnVtYmVyIHwgW251bWJlciwgc3RyaW5nXTtcblxuZXhwb3J0IGludGVyZmFjZSBTZWxlY3RQYWdlU2l6ZVByb3BzIHtcbiAgc2l6ZU9wdGlvbnM6IFNpemVPcHRpb25bXTtcbiAgY3VycmVudFNpemU/OiBudW1iZXI7XG4gIHRvdGFsPzogbnVtYmVyO1xuICBvbkNoYW5nZTogKHBhZ2VTaXplOiBudW1iZXIpID0+IHZvaWQ7XG59XG5cbmZ1bmN0aW9uIGdldE9wdGlvblZhbHVlKHg6IFNpemVPcHRpb24pIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoeCkgPyB4WzBdIDogeDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVhY3QubWVtbyhmdW5jdGlvbiBTZWxlY3RQYWdlU2l6ZSh7XG4gIHRvdGFsLFxuICBzaXplT3B0aW9ucyxcbiAgY3VycmVudFNpemUsXG4gIG9uQ2hhbmdlLFxufTogU2VsZWN0UGFnZVNpemVQcm9wcykge1xuICBjb25zdCBzaXplT3B0aW9uVmFsdWVzID0gc2l6ZU9wdGlvbnMubWFwKGdldE9wdGlvblZhbHVlKTtcbiAgbGV0IG9wdGlvbnMgPSBbLi4uc2l6ZU9wdGlvbnNdO1xuICAvLyBpbnNlcnQgY3VycmVudCBzaXplIHRvIGxpc3RcbiAgaWYgKFxuICAgIGN1cnJlbnRTaXplICE9PSB1bmRlZmluZWQgJiZcbiAgICAoY3VycmVudFNpemUgIT09IHRvdGFsIHx8ICFzaXplT3B0aW9uVmFsdWVzLmluY2x1ZGVzKDApKSAmJlxuICAgICFzaXplT3B0aW9uVmFsdWVzLmluY2x1ZGVzKGN1cnJlbnRTaXplKVxuICApIHtcbiAgICBvcHRpb25zID0gWy4uLnNpemVPcHRpb25zXTtcbiAgICBvcHRpb25zLnNwbGljZShcbiAgICAgIHNpemVPcHRpb25WYWx1ZXMuZmluZEluZGV4KHggPT4geCA+IGN1cnJlbnRTaXplKSxcbiAgICAgIDAsXG4gICAgICBjdXJyZW50U2l6ZSxcbiAgICApO1xuICB9XG4gIGNvbnN0IGN1cnJlbnQgPSBjdXJyZW50U2l6ZSA9PT0gdW5kZWZpbmVkID8gc2l6ZU9wdGlvblZhbHVlc1swXSA6IGN1cnJlbnRTaXplO1xuICByZXR1cm4gKFxuICAgIDxzcGFuIGNsYXNzTmFtZT1cImR0LXNlbGVjdC1wYWdlLXNpemUgZm9ybS1pbmxpbmVcIj5cbiAgICAgIFNob3d7JyAnfVxuICAgICAgPHNlbGVjdFxuICAgICAgICBjbGFzc05hbWU9XCJmb3JtLWNvbnRyb2wgaW5wdXQtc21cIlxuICAgICAgICB2YWx1ZT17Y3VycmVudH1cbiAgICAgICAgb25CbHVyPXsoKSA9PiB7fX1cbiAgICAgICAgb25DaGFuZ2U9e2UgPT4ge1xuICAgICAgICAgIG9uQ2hhbmdlKE51bWJlcigoZS50YXJnZXQgYXMgSFRNTFNlbGVjdEVsZW1lbnQpLnZhbHVlKSk7XG4gICAgICAgIH19XG4gICAgICA+XG4gICAgICAgIHtvcHRpb25zLm1hcChvcHRpb24gPT4ge1xuICAgICAgICAgIGNvbnN0IFtzaXplLCB0ZXh0XSA9IEFycmF5LmlzQXJyYXkob3B0aW9uKSA/IG9wdGlvbiA6IFtvcHRpb24sIG9wdGlvbl07XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxvcHRpb24ga2V5PXtzaXplfSB2YWx1ZT17c2l6ZX0+XG4gICAgICAgICAgICAgIHt0ZXh0fVxuICAgICAgICAgICAgPC9vcHRpb24+XG4gICAgICAgICAgKTtcbiAgICAgICAgfSl9XG4gICAgICA8L3NlbGVjdD57JyAnfVxuICAgICAgZW50cmllc1xuICAgIDwvc3Bhbj5cbiAgKTtcbn0pO1xuIiwiLyoqXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IFJlYWN0LCB7IENTU1Byb3BlcnRpZXMgfSBmcm9tICdyZWFjdCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFnaW5hdGlvblByb3BzIHtcbiAgcGFnZUNvdW50OiBudW1iZXI7IC8vIG51bWJlciBvZiBwYWdlc1xuICBjdXJyZW50UGFnZT86IG51bWJlcjsgLy8gaW5kZXggb2YgY3VycmVudCBwYWdlLCB6ZXJvLWJhc2VkXG4gIG1heFBhZ2VJdGVtQ291bnQ/OiBudW1iZXI7XG4gIGVsbGlwc2lzPzogc3RyaW5nOyAvLyBjb250ZW50IGZvciBlbGxpcHNpcyBpdGVtXG4gIG9uUGFnZUNoYW5nZTogKHBhZ2U6IG51bWJlcikgPT4gdm9pZDsgLy8gYHBhZ2VgIGlzIHplcm8tYmFzZWRcbiAgc3R5bGU/OiBDU1NQcm9wZXJ0aWVzO1xufVxuXG4vLyBmaXJzdCwgLi4uLCBwcmV2LCBjdXJyZW50LCBuZXh0LCAuLi4sIGxhc3RcbmNvbnN0IE1JTklNQUxfUEFHRV9JVEVNX0NPVU5UID0gNztcblxuLyoqXG4gKiBHZW5lcmF0ZSBudW1lcmljIHBhZ2UgaXRlbXMgYXJvdW5kIGN1cnJlbnQgcGFnZS5cbiAqICAgLSBBbHdheXMgaW5jbHVkZSBmaXJzdCBhbmQgbGFzdCBwYWdlXG4gKiAgIC0gQWRkIGVsbGlwc2lzIGlmIG5lZWRlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVQYWdlSXRlbXModG90YWw6IG51bWJlciwgY3VycmVudDogbnVtYmVyLCB3aWR0aDogbnVtYmVyKSB7XG4gIGlmICh3aWR0aCA8IE1JTklNQUxfUEFHRV9JVEVNX0NPVU5UKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBNdXN0IGFsbG93IGF0IGxlYXN0ICR7TUlOSU1BTF9QQUdFX0lURU1fQ09VTlR9IHBhZ2UgaXRlbXNgKTtcbiAgfVxuICBpZiAod2lkdGggJSAyID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBNdXN0IGFsbG93IG9kZCBudW1iZXIgb2YgcGFnZSBpdGVtc2ApO1xuICB9XG4gIGlmICh0b3RhbCA8IHdpZHRoKSB7XG4gICAgcmV0dXJuIFsuLi5uZXcgQXJyYXkodG90YWwpLmtleXMoKV07XG4gIH1cbiAgY29uc3QgbGVmdCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRvdGFsIC0gd2lkdGgsIGN1cnJlbnQgLSBNYXRoLmZsb29yKHdpZHRoIC8gMikpKTtcbiAgY29uc3QgaXRlbXM6IChzdHJpbmcgfCBudW1iZXIpW10gPSBuZXcgQXJyYXkod2lkdGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHdpZHRoOyBpICs9IDEpIHtcbiAgICBpdGVtc1tpXSA9IGkgKyBsZWZ0O1xuICB9XG4gIC8vIHJlcGxhY2Ugbm9uLWVuZGluZyBpdGVtcyB3aXRoIHBsYWNlaG9sZGVyc1xuICBpZiAoaXRlbXNbMF0gPiAwKSB7XG4gICAgaXRlbXNbMF0gPSAwO1xuICAgIGl0ZW1zWzFdID0gJ3ByZXYtbW9yZSc7XG4gIH1cbiAgaWYgKGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdIDwgdG90YWwgLSAxKSB7XG4gICAgaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV0gPSB0b3RhbCAtIDE7XG4gICAgaXRlbXNbaXRlbXMubGVuZ3RoIC0gMl0gPSAnbmV4dC1tb3JlJztcbiAgfVxuICByZXR1cm4gaXRlbXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJlYWN0Lm1lbW8oXG4gIFJlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gUGFnaW5hdGlvbihcbiAgICB7IHN0eWxlLCBwYWdlQ291bnQsIGN1cnJlbnRQYWdlID0gMCwgbWF4UGFnZUl0ZW1Db3VudCA9IDksIG9uUGFnZUNoYW5nZSB9OiBQYWdpbmF0aW9uUHJvcHMsXG4gICAgcmVmOiBSZWFjdC5SZWY8SFRNTERpdkVsZW1lbnQ+LFxuICApIHtcbiAgICBjb25zdCBwYWdlSXRlbXMgPSBnZW5lcmF0ZVBhZ2VJdGVtcyhwYWdlQ291bnQsIGN1cnJlbnRQYWdlLCBtYXhQYWdlSXRlbUNvdW50KTtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiByZWY9e3JlZn0gY2xhc3NOYW1lPVwiZHQtcGFnaW5hdGlvblwiIHN0eWxlPXtzdHlsZX0+XG4gICAgICAgIDx1bCBjbGFzc05hbWU9XCJwYWdpbmF0aW9uIHBhZ2luYXRpb24tc21cIj5cbiAgICAgICAgICB7cGFnZUl0ZW1zLm1hcCgoaXRlbSwgaSkgPT5cbiAgICAgICAgICAgIHR5cGVvZiBpdGVtID09PSAnbnVtYmVyJyA/IChcbiAgICAgICAgICAgICAgLy8gYWN0dWFsIHBhZ2UgbnVtYmVyXG4gICAgICAgICAgICAgIDxsaSBrZXk9e2l0ZW19IGNsYXNzTmFtZT17Y3VycmVudFBhZ2UgPT09IGl0ZW0gPyAnYWN0aXZlJyA6IHVuZGVmaW5lZH0+XG4gICAgICAgICAgICAgICAgPGFcbiAgICAgICAgICAgICAgICAgIGhyZWY9e2AjcGFnZS0ke2l0ZW19YH1cbiAgICAgICAgICAgICAgICAgIHJvbGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICAgICAgb25DbGljaz17ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgb25QYWdlQ2hhbmdlKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICB7aXRlbSArIDF9XG4gICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgPGxpIGtleT17aXRlbX0gY2xhc3NOYW1lPVwiZHQtcGFnaW5hdGlvbi1lbGxpcHNpc1wiPlxuICAgICAgICAgICAgICAgIDxzcGFuPuKApjwvc3Bhbj5cbiAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgICksXG4gICAgICAgICAgKX1cbiAgICAgICAgPC91bD5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH0pLFxuKTtcbiIsIi8qKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmxldCBjYWNoZWQ6IG51bWJlciB8IHVuZGVmaW5lZDtcblxuY29uc3QgY3NzID0gKHg6IFRlbXBsYXRlU3RyaW5nc0FycmF5KSA9PiB4LmpvaW4oJ1xcbicpO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRTY3JvbGxCYXJTaXplKGZvcmNlUmVmcmVzaCA9IGZhbHNlKSB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKGNhY2hlZCA9PT0gdW5kZWZpbmVkIHx8IGZvcmNlUmVmcmVzaCkge1xuICAgIGNvbnN0IGlubmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29uc3Qgb3V0ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBpbm5lci5zdHlsZS5jc3NUZXh0ID0gY3NzYFxuICAgICAgd2lkdGg6IGF1dG87XG4gICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICBvdmVyZmxvdzogc2Nyb2xsO1xuICAgIGA7XG4gICAgb3V0ZXIuc3R5bGUuY3NzVGV4dCA9IGNzc2BcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICB3aWR0aDogMTAwcHg7XG4gICAgICBoZWlnaHQ6IDUwcHg7XG4gICAgYDtcbiAgICBvdXRlci5hcHBlbmQoaW5uZXIpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKG91dGVyKTtcbiAgICBjYWNoZWQgPSBvdXRlci5jbGllbnRXaWR0aCAtIGlubmVyLmNsaWVudFdpZHRoO1xuICAgIG91dGVyLnJlbW92ZSgpO1xuICB9XG4gIHJldHVybiBjYWNoZWQ7XG59XG4iLCIvKipcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFdoZXRoZXIgYSBjb250YWluZXIgbmVlZCBzY3JvbGwgYmFycyB3aGVuIGluIGFub3RoZXIgY29udGFpbmVyLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBuZWVkU2Nyb2xsQmFyKHtcbiAgd2lkdGgsXG4gIGhlaWdodCxcbiAgaW5uZXJIZWlnaHQsXG4gIGlubmVyV2lkdGgsXG4gIHNjcm9sbEJhclNpemUsXG59OiB7XG4gIHdpZHRoOiBudW1iZXI7XG4gIGhlaWdodDogbnVtYmVyO1xuICBpbm5lckhlaWdodDogbnVtYmVyO1xuICBzY3JvbGxCYXJTaXplOiBudW1iZXI7XG4gIGlubmVyV2lkdGg6IG51bWJlcjtcbn0pOiBbYm9vbGVhbiwgYm9vbGVhbl0ge1xuICBjb25zdCBoYXNWZXJ0aWNhbFNjcm9sbCA9IGlubmVySGVpZ2h0ID4gaGVpZ2h0O1xuICBjb25zdCBoYXNIb3Jpem9udGFsU2Nyb2xsID0gaW5uZXJXaWR0aCA+IHdpZHRoIC0gKGhhc1ZlcnRpY2FsU2Nyb2xsID8gc2Nyb2xsQmFyU2l6ZSA6IDApO1xuICByZXR1cm4gW2hhc1ZlcnRpY2FsU2Nyb2xsLCBoYXNIb3Jpem9udGFsU2Nyb2xsXTtcbn1cbiIsIi8qKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCwgdXNlUmVmLCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIEV4ZWN1dGUgYSBtZW1vaXplZCBjYWxsYmFjayBvbmx5IHdoZW4gbW91bnRlZC4gRXhlY3V0ZSBhZ2FpbiB3aGVuIGZhY3RvcnkgdXBkYXRlZC5cbiAqIFJldHVybnMgdW5kZWZpbmVkIGlmIG5vdCBtb3VudGVkIHlldC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXNlTW91bnRlZE1lbW88VD4oZmFjdG9yeTogKCkgPT4gVCwgZGVwcz86IHVua25vd25bXSk6IFQgfCB1bmRlZmluZWQge1xuICBjb25zdCBtb3VudGVkID0gdXNlUmVmPHR5cGVvZiBmYWN0b3J5PigpO1xuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIG1vdW50ZWQuY3VycmVudCA9IGZhY3Rvcnk7XG4gIH0pO1xuICByZXR1cm4gdXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKG1vdW50ZWQuY3VycmVudCkge1xuICAgICAgcmV0dXJuIGZhY3RvcnkoKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFttb3VudGVkLmN1cnJlbnQsIG1vdW50ZWQuY3VycmVudCA9PT0gZmFjdG9yeSwgLi4uKGRlcHMgfHwgW10pXSk7XG59XG4iLCIvKipcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgUmVhY3QsIHtcbiAgdXNlUmVmLFxuICB1c2VNZW1vLFxuICB1c2VMYXlvdXRFZmZlY3QsXG4gIHVzZUNhbGxiYWNrLFxuICBSZWFjdE5vZGUsXG4gIFJlYWN0RWxlbWVudCxcbiAgQ29tcG9uZW50UHJvcHNXaXRoUmVmLFxuICBDU1NQcm9wZXJ0aWVzLFxuICBVSUV2ZW50SGFuZGxlcixcbn0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgVGFibGVJbnN0YW5jZSwgSG9va3MgfSBmcm9tICdyZWFjdC10YWJsZSc7XG5pbXBvcnQgZ2V0U2Nyb2xsQmFyU2l6ZSBmcm9tICcuLi91dGlscy9nZXRTY3JvbGxCYXJTaXplJztcbmltcG9ydCBuZWVkU2Nyb2xsQmFyIGZyb20gJy4uL3V0aWxzL25lZWRTY3JvbGxCYXInO1xuaW1wb3J0IHVzZU1vdW50ZWRNZW1vIGZyb20gJy4uL3V0aWxzL3VzZU1vdW50ZWRNZW1vJztcblxudHlwZSBSZWFjdEVsZW1lbnRXaXRoQ2hpbGRyZW48XG4gIFQgZXh0ZW5kcyBrZXlvZiBKU1guSW50cmluc2ljRWxlbWVudHMsXG4gIEMgZXh0ZW5kcyBSZWFjdE5vZGUgPSBSZWFjdE5vZGVcbj4gPSBSZWFjdEVsZW1lbnQ8Q29tcG9uZW50UHJvcHNXaXRoUmVmPFQ+ICYgeyBjaGlsZHJlbjogQyB9LCBUPjtcblxudHlwZSBUaCA9IFJlYWN0RWxlbWVudFdpdGhDaGlsZHJlbjwndGgnPjtcbnR5cGUgVGQgPSBSZWFjdEVsZW1lbnRXaXRoQ2hpbGRyZW48J3RkJz47XG50eXBlIFRyV2l0aFRoID0gUmVhY3RFbGVtZW50V2l0aENoaWxkcmVuPCd0cicsIFRoW10+O1xudHlwZSBUcldpdGhUZCA9IFJlYWN0RWxlbWVudFdpdGhDaGlsZHJlbjwndHInLCBUZFtdPjtcbnR5cGUgVGhlYWQgPSBSZWFjdEVsZW1lbnRXaXRoQ2hpbGRyZW48J3RoZWFkJywgVHJXaXRoVGg+O1xudHlwZSBUYm9keSA9IFJlYWN0RWxlbWVudFdpdGhDaGlsZHJlbjwndGJvZHknLCBUcldpdGhUZD47XG50eXBlIENvbCA9IFJlYWN0RWxlbWVudFdpdGhDaGlsZHJlbjwnY29sJywgbnVsbD47XG50eXBlIENvbEdyb3VwID0gUmVhY3RFbGVtZW50V2l0aENoaWxkcmVuPCdjb2xncm91cCcsIENvbD47XG5cbmV4cG9ydCB0eXBlIFRhYmxlID0gUmVhY3RFbGVtZW50V2l0aENoaWxkcmVuPCd0YWJsZScsIChUaGVhZCB8IFRib2R5IHwgQ29sR3JvdXApW10+O1xuZXhwb3J0IHR5cGUgVGFibGVSZW5kZXJlciA9ICgpID0+IFRhYmxlO1xuZXhwb3J0IHR5cGUgR2V0VGFibGVTaXplID0gKCkgPT4gUGFydGlhbDxTdGlja3lTdGF0ZT4gfCB1bmRlZmluZWQ7XG5leHBvcnQgdHlwZSBTZXRTdGlja3lTdGF0ZSA9IChzaXplPzogU3RpY2t5U3RhdGUpID0+IHZvaWQ7XG5cbmV4cG9ydCBlbnVtIFJlZHVjZXJBY3Rpb25zIHtcbiAgaW5pdCA9ICdpbml0JywgLy8gdGhpcyBpcyBmcm9tIGdsb2JhbCByZWR1Y2VyXG4gIHNldFN0aWNreVN0YXRlID0gJ3NldFN0aWNreVN0YXRlJyxcbn1cblxuZXhwb3J0IHR5cGUgUmVkdWNlckFjdGlvbjxUIGV4dGVuZHMgc3RyaW5nLCBQIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4+ID0gUCAmIHsgdHlwZTogVCB9O1xuXG5leHBvcnQgdHlwZSBDb2x1bW5XaWR0aHMgPSBudW1iZXJbXTtcblxuZXhwb3J0IGludGVyZmFjZSBTdGlja3lTdGF0ZSB7XG4gIHdpZHRoPzogbnVtYmVyOyAvLyBtYXhpbXVtIGZ1bGwgdGFibGUgd2lkdGhcbiAgaGVpZ2h0PzogbnVtYmVyOyAvLyBtYXhpbXVtIGZ1bGwgdGFibGUgaGVpZ2h0XG4gIHJlYWxIZWlnaHQ/OiBudW1iZXI7IC8vIGFjdHVhbCB0YWJsZSB2aWV3cG9ydCBoZWlnaHQgKGhlYWRlciArIHNjcm9sbGFibGUgYXJlYSlcbiAgYm9keUhlaWdodD86IG51bWJlcjsgLy8gc2Nyb2xsYWJsZSBhcmVhIGhlaWdodFxuICB0YWJsZUhlaWdodD86IG51bWJlcjsgLy8gdGhlIGZ1bGwgdGFibGUgaGVpZ2h0XG4gIGNvbHVtbldpZHRocz86IENvbHVtbldpZHRocztcbiAgaGFzSG9yaXpvbnRhbFNjcm9sbD86IGJvb2xlYW47XG4gIGhhc1ZlcnRpY2FsU2Nyb2xsPzogYm9vbGVhbjtcbiAgcmVuZGVyaW5nPzogYm9vbGVhbjtcbiAgc2V0U3RpY2t5U3RhdGU/OiBTZXRTdGlja3lTdGF0ZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VTdGlja3lUYWJsZU9wdGlvbnMge1xuICBnZXRUYWJsZVNpemU/OiBHZXRUYWJsZVNpemU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU3RpY2t5SW5zdGFuY2VQcm9wcyB7XG4gIC8vIG1hbmlwdWxhdGUgRE9NcyBpbiA8dGFibGU+IHRvIG1ha2UgdGhlIGhlYWRlciBzdGlja3lcbiAgd3JhcFN0aWNreVRhYmxlOiAocmVuZGVyZXI6IFRhYmxlUmVuZGVyZXIpID0+IFJlYWN0Tm9kZTtcbiAgLy8gdXBkYXRlIG9yIHJlY29tcHV0ZSB0aGUgc3RpY2t5IHRhYmxlIHNpemVcbiAgc2V0U3RpY2t5U3RhdGU6IFNldFN0aWNreVN0YXRlO1xufVxuXG5leHBvcnQgdHlwZSBVc2VTdGlja3lTdGF0ZSA9IHtcbiAgc3RpY2t5OiBTdGlja3lTdGF0ZTtcbn07XG5cbmNvbnN0IHN1bSA9IChhOiBudW1iZXIsIGI6IG51bWJlcikgPT4gYSArIGI7XG5jb25zdCBtZXJnZVN0eWxlUHJvcCA9IChub2RlOiBSZWFjdEVsZW1lbnQ8eyBzdHlsZT86IENTU1Byb3BlcnRpZXMgfT4sIHN0eWxlOiBDU1NQcm9wZXJ0aWVzKSA9PiAoe1xuICBzdHlsZToge1xuICAgIC4uLm5vZGUucHJvcHMuc3R5bGUsXG4gICAgLi4uc3R5bGUsXG4gIH0sXG59KTtcblxuLyoqXG4gKiBBbiBIT0MgZm9yIGdlbmVyYXRpbmcgc3RpY2t5IGhlYWRlciBhbmQgZml4ZWQtaGVpZ2h0IHNjcm9sbGFibGUgYXJlYVxuICovXG5mdW5jdGlvbiBTdGlja3lXcmFwKHtcbiAgc3RpY2t5ID0ge30sXG4gIHdpZHRoOiBtYXhXaWR0aCxcbiAgaGVpZ2h0OiBtYXhIZWlnaHQsXG4gIGNoaWxkcmVuOiB0YWJsZSxcbiAgc2V0U3RpY2t5U3RhdGUsXG59OiB7XG4gIHdpZHRoOiBudW1iZXI7XG4gIGhlaWdodDogbnVtYmVyO1xuICBzZXRTdGlja3lTdGF0ZTogU2V0U3RpY2t5U3RhdGU7XG4gIGNoaWxkcmVuOiBUYWJsZTtcbiAgc3RpY2t5PzogU3RpY2t5U3RhdGU7IC8vIGN1cnJlbnQgc3RpY2t5IGVsZW1lbnQgc2l6ZXNcbn0pIHtcbiAgaWYgKCF0YWJsZSB8fCB0YWJsZS50eXBlICE9PSAndGFibGUnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCc8U3RpY2t5V3JhcD4gbXVzdCBoYXZlIG9ubHkgb25lIDx0YWJsZT4gZWxlbWVudCBhcyBjaGlsZCcpO1xuICB9XG4gIGxldCB0aGVhZDogVGhlYWQgfCB1bmRlZmluZWQ7XG4gIGxldCB0Ym9keTogVGJvZHkgfCB1bmRlZmluZWQ7XG4gIGxldCBjb2xncm91cDogQ29sR3JvdXAgfCB1bmRlZmluZWQ7XG4gIFJlYWN0LkNoaWxkcmVuLmZvckVhY2godGFibGUucHJvcHMuY2hpbGRyZW4sIG5vZGUgPT4ge1xuICAgIGlmIChub2RlLnR5cGUgPT09ICd0aGVhZCcpIHtcbiAgICAgIHRoZWFkID0gbm9kZTtcbiAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ3Rib2R5Jykge1xuICAgICAgdGJvZHkgPSBub2RlO1xuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAnY29sZ3JvdXAnKSB7XG4gICAgICBjb2xncm91cCA9IG5vZGU7XG4gICAgfVxuICB9KTtcbiAgaWYgKCF0aGVhZCB8fCAhdGJvZHkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJzx0YWJsZT4gaW4gPFN0aWNreVdyYXA+IG11c3QgY29udGFpbiBib3RoIHRoZWFkIGFuZCB0Ym9keS4nKTtcbiAgfVxuICBjb25zdCBjb2x1bW5Db3VudCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IGhlYWRlclJvd3MgPSBSZWFjdC5DaGlsZHJlbi50b0FycmF5KHRoZWFkPy5wcm9wcy5jaGlsZHJlbikucG9wKCkgYXMgVHJXaXRoVGg7XG4gICAgcmV0dXJuIGhlYWRlclJvd3MucHJvcHMuY2hpbGRyZW4ubGVuZ3RoO1xuICB9LCBbdGhlYWRdKTtcblxuICBjb25zdCB0aGVhZFJlZiA9IHVzZVJlZjxIVE1MVGFibGVTZWN0aW9uRWxlbWVudD4obnVsbCk7IC8vIG9yaWdpbmFsIHRoZWFkIGZvciBsYXlvdXQgY29tcHV0YXRpb25cbiAgY29uc3Qgc2Nyb2xsSGVhZGVyUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTsgLy8gZml4ZWQgaGVhZGVyXG4gIGNvbnN0IHNjcm9sbEJvZHlSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpOyAvLyBtYWluIGJvZHlcblxuICBjb25zdCB7IGJvZHlIZWlnaHQsIGNvbHVtbldpZHRocyB9ID0gc3RpY2t5O1xuICBjb25zdCBuZWVkU2l6ZXIgPVxuICAgICFjb2x1bW5XaWR0aHMgfHxcbiAgICBzdGlja3kud2lkdGggIT09IG1heFdpZHRoIHx8XG4gICAgc3RpY2t5LmhlaWdodCAhPT0gbWF4SGVpZ2h0IHx8XG4gICAgc3RpY2t5LnNldFN0aWNreVN0YXRlICE9PSBzZXRTdGlja3lTdGF0ZTtcbiAgY29uc3Qgc2Nyb2xsQmFyU2l6ZSA9IGdldFNjcm9sbEJhclNpemUoKTtcblxuICAvLyB1cGRhdGUgc2Nyb2xsYWJsZSBhcmVhIGFuZCBoZWFkZXIgY29sdW1uIHNpemVzIHdoZW4gbW91bnRlZFxuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0aGVhZFJlZi5jdXJyZW50KSB7XG4gICAgICBjb25zdCBib2R5VGhlYWQgPSB0aGVhZFJlZi5jdXJyZW50O1xuICAgICAgY29uc3QgdGhlYWRIZWlnaHQgPSBib2R5VGhlYWQuY2xpZW50SGVpZ2h0O1xuICAgICAgaWYgKCF0aGVhZEhlaWdodCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBmdWxsVGFibGVIZWlnaHQgPSAoYm9keVRoZWFkLnBhcmVudE5vZGUgYXMgSFRNTFRhYmxlRWxlbWVudCkuY2xpZW50SGVpZ2h0O1xuICAgICAgY29uc3QgdGhzID0gYm9keVRoZWFkLmNoaWxkTm9kZXNbMF0uY2hpbGROb2RlcyBhcyBOb2RlTGlzdE9mPEhUTUxUYWJsZUhlYWRlckNlbGxFbGVtZW50PjtcbiAgICAgIGNvbnN0IHdpZHRocyA9IEFycmF5LmZyb20odGhzKS5tYXAodGggPT4gdGguY2xpZW50V2lkdGgpO1xuICAgICAgY29uc3QgW2hhc1ZlcnRpY2FsU2Nyb2xsLCBoYXNIb3Jpem9udGFsU2Nyb2xsXSA9IG5lZWRTY3JvbGxCYXIoe1xuICAgICAgICB3aWR0aDogbWF4V2lkdGgsXG4gICAgICAgIGhlaWdodDogbWF4SGVpZ2h0IC0gdGhlYWRIZWlnaHQsXG4gICAgICAgIGlubmVySGVpZ2h0OiBmdWxsVGFibGVIZWlnaHQsXG4gICAgICAgIGlubmVyV2lkdGg6IHdpZHRocy5yZWR1Y2Uoc3VtKSxcbiAgICAgICAgc2Nyb2xsQmFyU2l6ZSxcbiAgICAgIH0pO1xuICAgICAgLy8gcmVhbCBjb250YWluZXIgaGVpZ2h0LCBpbmNsdWRlIHRhYmxlIGhlYWRlciBhbmQgc3BhY2UgZm9yXG4gICAgICAvLyBob3Jpem9udGFsIHNjcm9sbCBiYXJcbiAgICAgIGNvbnN0IHJlYWxIZWlnaHQgPSBNYXRoLm1pbihcbiAgICAgICAgbWF4SGVpZ2h0LFxuICAgICAgICBoYXNIb3Jpem9udGFsU2Nyb2xsID8gZnVsbFRhYmxlSGVpZ2h0ICsgc2Nyb2xsQmFyU2l6ZSA6IGZ1bGxUYWJsZUhlaWdodCxcbiAgICAgICk7XG4gICAgICBzZXRTdGlja3lTdGF0ZSh7XG4gICAgICAgIGhhc1ZlcnRpY2FsU2Nyb2xsLFxuICAgICAgICBoYXNIb3Jpem9udGFsU2Nyb2xsLFxuICAgICAgICBzZXRTdGlja3lTdGF0ZSxcbiAgICAgICAgd2lkdGg6IG1heFdpZHRoLFxuICAgICAgICBoZWlnaHQ6IG1heEhlaWdodCxcbiAgICAgICAgcmVhbEhlaWdodCxcbiAgICAgICAgdGFibGVIZWlnaHQ6IGZ1bGxUYWJsZUhlaWdodCxcbiAgICAgICAgYm9keUhlaWdodDogcmVhbEhlaWdodCAtIHRoZWFkSGVpZ2h0LFxuICAgICAgICBjb2x1bW5XaWR0aHM6IHdpZHRocyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW21heFdpZHRoLCBtYXhIZWlnaHQsIHNldFN0aWNreVN0YXRlLCBzY3JvbGxCYXJTaXplXSk7XG5cbiAgbGV0IHNpemVyVGFibGU6IFJlYWN0RWxlbWVudCB8IHVuZGVmaW5lZDtcbiAgbGV0IGhlYWRlclRhYmxlOiBSZWFjdEVsZW1lbnQgfCB1bmRlZmluZWQ7XG4gIGxldCBib2R5VGFibGU6IFJlYWN0RWxlbWVudCB8IHVuZGVmaW5lZDtcbiAgaWYgKG5lZWRTaXplcikge1xuICAgIGNvbnN0IHRoZWFkV2l0aFJlZiA9IFJlYWN0LmNsb25lRWxlbWVudCh0aGVhZCwgeyByZWY6IHRoZWFkUmVmIH0pO1xuICAgIHNpemVyVGFibGUgPSAoXG4gICAgICA8ZGl2XG4gICAgICAgIGtleT1cInNpemVyXCJcbiAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICBoZWlnaHQ6IG1heEhlaWdodCxcbiAgICAgICAgICBvdmVyZmxvdzogJ2F1dG8nLFxuICAgICAgICAgIHZpc2liaWxpdHk6ICdoaWRkZW4nLFxuICAgICAgICB9fVxuICAgICAgPlxuICAgICAgICB7UmVhY3QuY2xvbmVFbGVtZW50KHRhYmxlLCB7fSwgY29sZ3JvdXAsIHRoZWFkV2l0aFJlZiwgdGJvZHkpfVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIC8vIHJldXNlIHByZXZpb3VzbHkgY29sdW1uIHdpZHRocywgd2lsbCBiZSB1cGRhdGVkIGJ5IGB1c2VMYXlvdXRFZmZlY3RgIGFib3ZlXG4gIGNvbnN0IGNvbFdpZHRocyA9IGNvbHVtbldpZHRocz8uc2xpY2UoMCwgY29sdW1uQ291bnQpO1xuICBpZiAoY29sV2lkdGhzICYmIGJvZHlIZWlnaHQpIHtcbiAgICBjb25zdCB0YWJsZVN0eWxlOiBDU1NQcm9wZXJ0aWVzID0geyB0YWJsZUxheW91dDogJ2ZpeGVkJyB9O1xuXG4gICAgY29uc3QgYm9keUNvbHMgPSBjb2xXaWR0aHMubWFwKCh3LCBpKSA9PiAoXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tYXJyYXktaW5kZXgta2V5XG4gICAgICA8Y29sIGtleT17aX0gd2lkdGg9e3d9IC8+XG4gICAgKSk7XG4gICAgY29uc3QgYm9keUNvbGdyb3VwID0gPGNvbGdyb3VwPntib2R5Q29sc308L2NvbGdyb3VwPjtcblxuICAgIC8vIGhlYWRlciBjb2x1bW5zIGRvIG5vdCBoYXZlIHZlcnRpY2FsIHNjcm9sbCBiYXJzLFxuICAgIC8vIHNvIHdlIGFkZCBzY3JvbGwgYmFyIHNpemUgdG8gdGhlIGxhc3QgY29sdW1uXG4gICAgY29uc3QgaGVhZGVyQ29sZ3JvdXAgPVxuICAgICAgc3RpY2t5Lmhhc1ZlcnRpY2FsU2Nyb2xsICYmIHNjcm9sbEJhclNpemUgPyAoXG4gICAgICAgIDxjb2xncm91cD5cbiAgICAgICAgICB7Y29sV2lkdGhzLm1hcCgoeCwgaSkgPT4gKFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L25vLWFycmF5LWluZGV4LWtleVxuICAgICAgICAgICAgPGNvbCBrZXk9e2l9IHdpZHRoPXt4ICsgKGkgPT09IGNvbFdpZHRocy5sZW5ndGggLSAxID8gc2Nyb2xsQmFyU2l6ZSA6IDApfSAvPlxuICAgICAgICAgICkpfVxuICAgICAgICA8L2NvbGdyb3VwPlxuICAgICAgKSA6IChcbiAgICAgICAgYm9keUNvbGdyb3VwXG4gICAgICApO1xuXG4gICAgaGVhZGVyVGFibGUgPSAoXG4gICAgICA8ZGl2XG4gICAgICAgIGtleT1cImhlYWRlclwiXG4gICAgICAgIHJlZj17c2Nyb2xsSGVhZGVyUmVmfVxuICAgICAgICBzdHlsZT17e1xuICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgICAgfX1cbiAgICAgID5cbiAgICAgICAge1JlYWN0LmNsb25lRWxlbWVudCh0YWJsZSwgbWVyZ2VTdHlsZVByb3AodGFibGUsIHRhYmxlU3R5bGUpLCBoZWFkZXJDb2xncm91cCwgdGhlYWQpfVxuICAgICAgICB7aGVhZGVyVGFibGV9XG4gICAgICA8L2Rpdj5cbiAgICApO1xuXG4gICAgY29uc3Qgb25TY3JvbGw6IFVJRXZlbnRIYW5kbGVyPEhUTUxEaXZFbGVtZW50PiA9IGUgPT4ge1xuICAgICAgaWYgKHNjcm9sbEhlYWRlclJlZi5jdXJyZW50KSB7XG4gICAgICAgIHNjcm9sbEhlYWRlclJlZi5jdXJyZW50LnNjcm9sbExlZnQgPSBlLmN1cnJlbnRUYXJnZXQuc2Nyb2xsTGVmdDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGJvZHlUYWJsZSA9IChcbiAgICAgIDxkaXZcbiAgICAgICAga2V5PVwiYm9keVwiXG4gICAgICAgIHJlZj17c2Nyb2xsQm9keVJlZn1cbiAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICBoZWlnaHQ6IGJvZHlIZWlnaHQsXG4gICAgICAgICAgb3ZlcmZsb3c6ICdhdXRvJyxcbiAgICAgICAgfX1cbiAgICAgICAgb25TY3JvbGw9e3N0aWNreS5oYXNIb3Jpem9udGFsU2Nyb2xsID8gb25TY3JvbGwgOiB1bmRlZmluZWR9XG4gICAgICA+XG4gICAgICAgIHtSZWFjdC5jbG9uZUVsZW1lbnQodGFibGUsIG1lcmdlU3R5bGVQcm9wKHRhYmxlLCB0YWJsZVN0eWxlKSwgYm9keUNvbGdyb3VwLCB0Ym9keSl9XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICBzdHlsZT17e1xuICAgICAgICB3aWR0aDogbWF4V2lkdGgsXG4gICAgICAgIGhlaWdodDogc3RpY2t5LnJlYWxIZWlnaHQgfHwgbWF4SGVpZ2h0LFxuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICB9fVxuICAgID5cbiAgICAgIHtoZWFkZXJUYWJsZX1cbiAgICAgIHtib2R5VGFibGV9XG4gICAgICB7c2l6ZXJUYWJsZX1cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuZnVuY3Rpb24gdXNlSW5zdGFuY2U8RCBleHRlbmRzIG9iamVjdD4oaW5zdGFuY2U6IFRhYmxlSW5zdGFuY2U8RD4pIHtcbiAgY29uc3Qge1xuICAgIGRpc3BhdGNoLFxuICAgIHN0YXRlOiB7IHN0aWNreSB9LFxuICAgIGRhdGEsXG4gICAgcGFnZSxcbiAgICByb3dzLFxuICAgIGdldFRhYmxlU2l6ZSA9ICgpID0+IHVuZGVmaW5lZCxcbiAgfSA9IGluc3RhbmNlO1xuXG4gIGNvbnN0IHNldFN0aWNreVN0YXRlID0gdXNlQ2FsbGJhY2soXG4gICAgKHNpemU/OiBQYXJ0aWFsPFN0aWNreVN0YXRlPikgPT4ge1xuICAgICAgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBSZWR1Y2VyQWN0aW9ucy5zZXRTdGlja3lTdGF0ZSxcbiAgICAgICAgc2l6ZSxcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgLy8gdHVybmluZyBwYWdlcyB3b3VsZCBhbHNvIHRyaWdnZXIgYSByZXNpemVcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgW2Rpc3BhdGNoLCBnZXRUYWJsZVNpemUsIHBhZ2UsIHJvd3NdLFxuICApO1xuXG4gIGNvbnN0IHVzZVN0aWNreVdyYXAgPSAocmVuZGVyZXI6IFRhYmxlUmVuZGVyZXIpID0+IHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHVzZU1vdW50ZWRNZW1vKGdldFRhYmxlU2l6ZSwgW2dldFRhYmxlU2l6ZV0pIHx8IHN0aWNreTtcbiAgICAvLyBvbmx5IGNoYW5nZSBvZiBkYXRhIHNob3VsZCB0cmlnZ2VyIHJlLXJlbmRlclxuICAgIGNvbnN0IHRhYmxlID0gdXNlTWVtbyhyZW5kZXJlciwgW3BhZ2UsIHJvd3NdKTtcblxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICBpZiAoIXdpZHRoIHx8ICFoZWlnaHQpIHtcbiAgICAgICAgc2V0U3RpY2t5U3RhdGUoKTtcbiAgICAgIH1cbiAgICB9LCBbd2lkdGgsIGhlaWdodF0pO1xuXG4gICAgaWYgKCF3aWR0aCB8fCAhaGVpZ2h0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGFibGU7XG4gICAgfVxuICAgIHJldHVybiAoXG4gICAgICA8U3RpY2t5V3JhcCB3aWR0aD17d2lkdGh9IGhlaWdodD17aGVpZ2h0fSBzdGlja3k9e3N0aWNreX0gc2V0U3RpY2t5U3RhdGU9e3NldFN0aWNreVN0YXRlfT5cbiAgICAgICAge3RhYmxlfVxuICAgICAgPC9TdGlja3lXcmFwPlxuICAgICk7XG4gIH07XG5cbiAgT2JqZWN0LmFzc2lnbihpbnN0YW5jZSwge1xuICAgIHNldFN0aWNreVN0YXRlLFxuICAgIHdyYXBTdGlja3lUYWJsZTogdXNlU3RpY2t5V3JhcCxcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVzZVN0aWNreTxEIGV4dGVuZHMgb2JqZWN0Pihob29rczogSG9va3M8RD4pIHtcbiAgaG9va3MudXNlSW5zdGFuY2UucHVzaCh1c2VJbnN0YW5jZSk7XG4gIGhvb2tzLnN0YXRlUmVkdWNlcnMucHVzaCgobmV3U3RhdGUsIGFjdGlvbl8sIHByZXZpb3VzU3RhdGUsIGluc3RhbmNlKSA9PiB7XG4gICAgY29uc3QgYWN0aW9uID0gYWN0aW9uXyBhcyBSZWR1Y2VyQWN0aW9uPFJlZHVjZXJBY3Rpb25zLCB7IHNpemU6IFN0aWNreVN0YXRlIH0+O1xuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gUmVkdWNlckFjdGlvbnMuaW5pdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubmV3U3RhdGUsXG4gICAgICAgIHN0aWNreTogbmV3U3RhdGUuc3RpY2t5IHx8IHt9LFxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBSZWR1Y2VyQWN0aW9ucy5zZXRTdGlja3lTdGF0ZSkge1xuICAgICAgY29uc3QgeyBzaXplIH0gPSBhY3Rpb247XG4gICAgICBpZiAoIXNpemUpIHtcbiAgICAgICAgcmV0dXJuIHsgLi4ubmV3U3RhdGUgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm5ld1N0YXRlLFxuICAgICAgICBzdGlja3k6IHtcbiAgICAgICAgICAuLi5uZXdTdGF0ZS5zdGlja3ksXG4gICAgICAgICAgLi4uYWN0aW9uLnNpemUsXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbmV3U3RhdGU7XG4gIH0pO1xufVxudXNlU3RpY2t5LnBsdWdpbk5hbWUgPSAndXNlU3RpY2t5JztcbiIsIi8qKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IEhUTUxQcm9wcyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEhvb2tzLCBDZWxsLCBUYWJsZUNlbGxQcm9wcywgQ29sdW1uSW5zdGFuY2UgfSBmcm9tICdyZWFjdC10YWJsZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ29sdW1uQ2VsbFByb3BzQ29sdW1uT3B0aW9uPEQgZXh0ZW5kcyBvYmplY3QsIFYgPSB1bmtub3duPiB7XG4gIGNlbGxQcm9wcz86IChcbiAgICBjZWxsOiBDZWxsPEQsIFY+LFxuICAgIHByb3BzOiBQYXJ0aWFsPFRhYmxlQ2VsbFByb3BzPixcbiAgKSA9PiBQYXJ0aWFsPEhUTUxQcm9wczxIVE1MVGFibGVEYXRhQ2VsbEVsZW1lbnQ+PiB8IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBDb25maWd1cmUgY2VsbCBwcm9wcyBpbiBjb2x1bW4gb3B0aW9ucy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXNlQ29sdW1uQ2VsbFByb3BzPEQgZXh0ZW5kcyBvYmplY3Q+KGhvb2tzOiBIb29rczxEPikge1xuICBob29rcy5nZXRDZWxsUHJvcHMucHVzaCgocHJvcHMsIHsgY2VsbCB9KSA9PiB7XG4gICAgY29uc3QgY29sdW1uID0gY2VsbC5jb2x1bW4gYXMgQ29sdW1uSW5zdGFuY2U8RD47XG4gICAgcmV0dXJuIChjb2x1bW4uY2VsbFByb3BzICYmIGNvbHVtbi5jZWxsUHJvcHMoY2VsbCwgcHJvcHMpKSB8fCBbXTtcbiAgfSk7XG59XG51c2VDb2x1bW5DZWxsUHJvcHMucGx1Z2luTmFtZSA9ICd1c2VDb2x1bW5DZWxsUHJvcHMnO1xuIiwiLyoqXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IFJlYWN0LCB7IHVzZUNhbGxiYWNrLCB1c2VSZWYsIFJlYWN0Tm9kZSwgSFRNTFByb3BzLCBNdXRhYmxlUmVmT2JqZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHtcbiAgdXNlVGFibGUsXG4gIHVzZVBhZ2luYXRpb24sXG4gIHVzZVNvcnRCeSxcbiAgdXNlR2xvYmFsRmlsdGVyLFxuICBQbHVnaW5Ib29rLFxuICBUYWJsZUNlbGxQcm9wcyxcbiAgVGFibGVPcHRpb25zLFxuICBGaWx0ZXJUeXBlLFxuICBJZFR5cGUsXG4gIFJvdyxcbn0gZnJvbSAncmVhY3QtdGFibGUnO1xuaW1wb3J0IG1hdGNoU29ydGVyIGZyb20gJ21hdGNoLXNvcnRlcic7XG5pbXBvcnQgR2xvYmFsRmlsdGVyLCB7IEdsb2JhbEZpbHRlclByb3BzIH0gZnJvbSAnLi9jb21wb25lbnRzL0dsb2JhbEZpbHRlcic7XG5pbXBvcnQgU2VsZWN0UGFnZVNpemUsIHsgU2l6ZU9wdGlvbiB9IGZyb20gJy4vY29tcG9uZW50cy9TZWxlY3RQYWdlU2l6ZSc7XG5pbXBvcnQgU2ltcGxlUGFnaW5hdGlvbiBmcm9tICcuL2NvbXBvbmVudHMvUGFnaW5hdGlvbic7XG5pbXBvcnQgdXNlU3RpY2t5IGZyb20gJy4vaG9va3MvdXNlU3RpY2t5JztcbmltcG9ydCB1c2VDb2x1bW5DZWxsUHJvcHMgZnJvbSAnLi9ob29rcy91c2VDb2x1bW5DZWxsUHJvcHMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIERhdGFUYWJsZVByb3BzPEQgZXh0ZW5kcyBvYmplY3Q+IGV4dGVuZHMgVGFibGVPcHRpb25zPEQ+IHtcbiAgdGFibGVDbGFzc05hbWU/OiBzdHJpbmc7XG4gIHNlYXJjaElucHV0PzogYm9vbGVhbiB8IEdsb2JhbEZpbHRlclByb3BzPEQ+WydzZWFyY2hJbnB1dCddO1xuICBwYWdlU2l6ZU9wdGlvbnM/OiBTaXplT3B0aW9uW107IC8vIGF2YWlsYWJsZSBwYWdlIHNpemUgb3B0aW9uc1xuICBtYXhQYWdlSXRlbUNvdW50PzogbnVtYmVyO1xuICBob29rcz86IFBsdWdpbkhvb2s8RD5bXTsgLy8gYW55IGFkZGl0aW9uYWwgaG9va3NcbiAgd2lkdGg/OiBzdHJpbmcgfCBudW1iZXI7XG4gIGhlaWdodD86IHN0cmluZyB8IG51bWJlcjtcbiAgcGFnZVNpemU/OiBudW1iZXI7XG4gIG5vUmVzdWx0c1RleHQ/OiBzdHJpbmcgfCAoKGZpbHRlclN0cmluZzogc3RyaW5nKSA9PiBSZWFjdE5vZGUpO1xuICBzdGlja3k/OiBib29sZWFuO1xuICB3cmFwcGVyUmVmPzogTXV0YWJsZVJlZk9iamVjdDxIVE1MRGl2RWxlbWVudD47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVuZGVySFRNTENlbGxQcm9wcyBleHRlbmRzIEhUTUxQcm9wczxIVE1MVGFibGVDZWxsRWxlbWVudD4ge1xuICBjZWxsQ29udGVudDogUmVhY3ROb2RlO1xufVxuXG4vLyBCZSBzdXJlIHRvIHBhc3Mgb3VyIHVwZGF0ZU15RGF0YSBhbmQgdGhlIHNraXBSZXNldCBvcHRpb25cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERhdGFUYWJsZTxEIGV4dGVuZHMgb2JqZWN0Pih7XG4gIHRhYmxlQ2xhc3NOYW1lLFxuICBjb2x1bW5zLFxuICBkYXRhLFxuICB3aWR0aDogaW5pdGlhbFdpZHRoID0gJzEwMCUnLFxuICBoZWlnaHQ6IGluaXRpYWxIZWlnaHQgPSAzMDAsXG4gIHBhZ2VTaXplOiBpbml0aWFsUGFnZVNpemUgPSAwLFxuICBpbml0aWFsU3RhdGU6IGluaXRpYWxTdGF0ZV8gPSB7fSxcbiAgcGFnZVNpemVPcHRpb25zID0gWzEwLCAyNSwgNTAsIDEwMCwgMjAwXSxcbiAgbWF4UGFnZUl0ZW1Db3VudCA9IDksXG4gIHN0aWNreTogZG9TdGlja3ksXG4gIHNlYXJjaElucHV0ID0gdHJ1ZSxcbiAgbm9SZXN1bHRzVGV4dCA9ICdObyBkYXRhIGZvdW5kJyxcbiAgaG9va3MsXG4gIHdyYXBwZXJSZWY6IHVzZXJXcmFwcGVyUmVmLFxuICAuLi5tb3JlVXNlVGFibGVPcHRpb25zXG59OiBEYXRhVGFibGVQcm9wczxEPikge1xuICBjb25zdCB0YWJsZUhvb2tzOiBQbHVnaW5Ib29rPEQ+W10gPSBbXG4gICAgdXNlR2xvYmFsRmlsdGVyLFxuICAgIHVzZVNvcnRCeSxcbiAgICB1c2VQYWdpbmF0aW9uLFxuICAgIHVzZUNvbHVtbkNlbGxQcm9wcyxcbiAgICBkb1N0aWNreSA/IHVzZVN0aWNreSA6IFtdLFxuICAgIGhvb2tzIHx8IFtdLFxuICBdLmZsYXQoKTtcbiAgY29uc3Qgc29ydEJ5UmVmID0gdXNlUmVmKFtdKTsgLy8gY2FjaGUgaW5pdGlhbCBgc29ydGJ5YCBzbyBzb3J0aW5nIGRvZXNuJ3QgdHJpZ2dlciBwYWdlIHJlc2V0XG4gIGNvbnN0IHBhZ2VTaXplUmVmID0gdXNlUmVmKFtpbml0aWFsUGFnZVNpemUsIGRhdGEubGVuZ3RoXSk7XG4gIGNvbnN0IGhhc1BhZ2luYXRpb24gPSBpbml0aWFsUGFnZVNpemUgPiAwICYmIGRhdGEubGVuZ3RoID4gMDsgLy8gcGFnZVNpemUgPT0gMCBtZWFucyBubyBwYWdpbmF0aW9uXG4gIGNvbnN0IGhhc0dsb2JhbENvbnRyb2wgPSBoYXNQYWdpbmF0aW9uIHx8ICEhc2VhcmNoSW5wdXQ7XG4gIGNvbnN0IGluaXRpYWxTdGF0ZSA9IHtcbiAgICAuLi5pbml0aWFsU3RhdGVfLFxuICAgIC8vIHplcm8gbGVuZ3RoIG1lYW5zIGFsbCBwYWdlcywgdGhlIGB1c2VQYWdpbmF0aW9uYCBwbHVnaW4gZG9lcyBub3RcbiAgICAvLyB1bmRlcnN0YW5kIHBhZ2VTaXplID0gMFxuICAgIHNvcnRCeTogc29ydEJ5UmVmLmN1cnJlbnQsXG4gICAgcGFnZVNpemU6IGluaXRpYWxQYWdlU2l6ZSA+IDAgPyBpbml0aWFsUGFnZVNpemUgOiBkYXRhLmxlbmd0aCB8fCAxMCxcbiAgfTtcblxuICBjb25zdCBkZWZhdWx0V3JhcHBlclJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCk7XG4gIGNvbnN0IGdsb2JhbENvbnRyb2xSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpO1xuICBjb25zdCBwYWdpbmF0aW9uUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTtcbiAgY29uc3Qgd3JhcHBlclJlZiA9IHVzZXJXcmFwcGVyUmVmIHx8IGRlZmF1bHRXcmFwcGVyUmVmO1xuXG4gIGNvbnN0IGRlZmF1bHRHZXRUYWJsZVNpemUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKHdyYXBwZXJSZWYuY3VycmVudCkge1xuICAgICAgLy8gYGluaXRpYWxXaWR0aGAgYW5kIGBpbml0aWFsSGVpZ2h0YCBjb3VsZCBiZSBhbHNvIHBhcmFtZXRlcnMgbGlrZSBgMTAwJWBcbiAgICAgIC8vIGBOdW1iZXJgIHJlYXR1cm5zIGBOYU5gIG9uIHRoZW0sIHRoZW4gd2UgZmFsbGJhY2sgdG8gY29tcHV0ZWQgc2l6ZVxuICAgICAgY29uc3Qgd2lkdGggPSBOdW1iZXIoaW5pdGlhbFdpZHRoKSB8fCB3cmFwcGVyUmVmLmN1cnJlbnQuY2xpZW50V2lkdGg7XG4gICAgICBjb25zdCBoZWlnaHQgPVxuICAgICAgICAoTnVtYmVyKGluaXRpYWxIZWlnaHQpIHx8IHdyYXBwZXJSZWYuY3VycmVudC5jbGllbnRIZWlnaHQpIC1cbiAgICAgICAgKGdsb2JhbENvbnRyb2xSZWYuY3VycmVudD8uY2xpZW50SGVpZ2h0IHx8IDApIC1cbiAgICAgICAgKHBhZ2luYXRpb25SZWYuY3VycmVudD8uY2xpZW50SGVpZ2h0IHx8IDApO1xuICAgICAgcmV0dXJuIHsgd2lkdGgsIGhlaWdodCB9O1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW2luaXRpYWxIZWlnaHQsIGluaXRpYWxXaWR0aCwgd3JhcHBlclJlZiwgaGFzUGFnaW5hdGlvbiwgaGFzR2xvYmFsQ29udHJvbF0pO1xuXG4gIGNvbnN0IGRlZmF1bHRHbG9iYWxGaWx0ZXI6IEZpbHRlclR5cGU8RD4gPSB1c2VDYWxsYmFjayhcbiAgICAocm93czogUm93PEQ+W10sIGNvbHVtbklkczogSWRUeXBlPEQ+W10sIGZpbHRlclZhbHVlOiBzdHJpbmcpID0+IHtcbiAgICAgIC8vIGFsbG93IHNlYXJjaGluZyBieSBcImNvbDEgY29sMlwiXG4gICAgICBjb25zdCBqb2luZWRTdHJpbmcgPSAocm93OiBSb3c8RD4pID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbHVtbklkcy5tYXAoeCA9PiByb3cudmFsdWVzW3hdKS5qb2luKCcgJyk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIG1hdGNoU29ydGVyKHJvd3MsIGZpbHRlclZhbHVlLCB7XG4gICAgICAgIGtleXM6IFsuLi5jb2x1bW5JZHMsIGpvaW5lZFN0cmluZ10sXG4gICAgICAgIHRocmVzaG9sZDogbWF0Y2hTb3J0ZXIucmFua2luZ3MuQUNST05ZTSxcbiAgICAgIH0pIGFzIHR5cGVvZiByb3dzO1xuICAgIH0sXG4gICAgW10sXG4gICk7XG5cbiAgY29uc3Qge1xuICAgIGdldFRhYmxlUHJvcHMsXG4gICAgZ2V0VGFibGVCb2R5UHJvcHMsXG4gICAgcHJlcGFyZVJvdyxcbiAgICBoZWFkZXJHcm91cHMsXG4gICAgcGFnZSxcbiAgICBwYWdlQ291bnQsXG4gICAgZ290b1BhZ2UsXG4gICAgcHJlR2xvYmFsRmlsdGVyZWRSb3dzLFxuICAgIHNldEdsb2JhbEZpbHRlcixcbiAgICBzZXRQYWdlU2l6ZTogc2V0UGFnZVNpemVfLFxuICAgIHdyYXBTdGlja3lUYWJsZSxcbiAgICBzdGF0ZTogeyBwYWdlSW5kZXgsIHBhZ2VTaXplLCBnbG9iYWxGaWx0ZXI6IGZpbHRlclZhbHVlLCBzdGlja3kgPSB7fSB9LFxuICB9ID0gdXNlVGFibGU8RD4oXG4gICAge1xuICAgICAgY29sdW1ucyxcbiAgICAgIGRhdGEsXG4gICAgICBpbml0aWFsU3RhdGUsXG4gICAgICBnZXRUYWJsZVNpemU6IGRlZmF1bHRHZXRUYWJsZVNpemUsXG4gICAgICBnbG9iYWxGaWx0ZXI6IGRlZmF1bHRHbG9iYWxGaWx0ZXIsXG4gICAgICAuLi5tb3JlVXNlVGFibGVPcHRpb25zLFxuICAgIH0sXG4gICAgLi4udGFibGVIb29rcyxcbiAgKTtcbiAgLy8gbWFrZSBzZXRQYWdlU2l6ZSBhY2NlcHQgMFxuICBjb25zdCBzZXRQYWdlU2l6ZSA9IChzaXplOiBudW1iZXIpID0+IHtcbiAgICAvLyBrZWVwIHRoZSBvcmlnaW5hbCBzaXplIGlmIGRhdGEgaXMgZW1wdHlcbiAgICBpZiAoc2l6ZSB8fCBkYXRhLmxlbmd0aCAhPT0gMCkge1xuICAgICAgc2V0UGFnZVNpemVfKHNpemUgPT09IDAgPyBkYXRhLmxlbmd0aCA6IHNpemUpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCByZW5kZXJUYWJsZSA9ICgpID0+IChcbiAgICA8dGFibGUgey4uLmdldFRhYmxlUHJvcHMoeyBjbGFzc05hbWU6IHRhYmxlQ2xhc3NOYW1lIH0pfT5cbiAgICAgIDx0aGVhZD5cbiAgICAgICAge2hlYWRlckdyb3Vwcy5tYXAoaGVhZGVyR3JvdXAgPT4ge1xuICAgICAgICAgIGNvbnN0IHsga2V5OiBoZWFkZXJHcm91cEtleSwgLi4uaGVhZGVyR3JvdXBQcm9wcyB9ID0gaGVhZGVyR3JvdXAuZ2V0SGVhZGVyR3JvdXBQcm9wcygpO1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8dHIga2V5PXtoZWFkZXJHcm91cEtleSB8fCBoZWFkZXJHcm91cC5pZH0gey4uLmhlYWRlckdyb3VwUHJvcHN9PlxuICAgICAgICAgICAgICB7aGVhZGVyR3JvdXAuaGVhZGVycy5tYXAoY29sdW1uID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGtleTogaGVhZGVyS2V5LCBjbGFzc05hbWUsIC4uLnByb3BzIH0gPSBjb2x1bW4uZ2V0SGVhZGVyUHJvcHMoXG4gICAgICAgICAgICAgICAgICBjb2x1bW4uZ2V0U29ydEJ5VG9nZ2xlUHJvcHMoKSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICA8dGhcbiAgICAgICAgICAgICAgICAgICAga2V5PXtoZWFkZXJLZXkgfHwgY29sdW1uLmlkfVxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2NvbHVtbi5pc1NvcnRlZCA/IGAke2NsYXNzTmFtZSB8fCAnJ30gaXMtc29ydGVkYCA6IGNsYXNzTmFtZX1cbiAgICAgICAgICAgICAgICAgICAgey4uLnByb3BzfVxuICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICB7Y29sdW1uLnJlbmRlcignSGVhZGVyJyl9XG4gICAgICAgICAgICAgICAgICAgIHtjb2x1bW4ucmVuZGVyKCdTb3J0SWNvbicpfVxuICAgICAgICAgICAgICAgICAgPC90aD5cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgKTtcbiAgICAgICAgfSl9XG4gICAgICA8L3RoZWFkPlxuICAgICAgPHRib2R5IHsuLi5nZXRUYWJsZUJvZHlQcm9wcygpfT5cbiAgICAgICAge3BhZ2UgJiYgcGFnZS5sZW5ndGggPiAwID8gKFxuICAgICAgICAgIHBhZ2UubWFwKHJvdyA9PiB7XG4gICAgICAgICAgICBwcmVwYXJlUm93KHJvdyk7XG4gICAgICAgICAgICBjb25zdCB7IGtleTogcm93S2V5LCAuLi5yb3dQcm9wcyB9ID0gcm93LmdldFJvd1Byb3BzKCk7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICA8dHIga2V5PXtyb3dLZXkgfHwgcm93LmlkfSB7Li4ucm93UHJvcHN9PlxuICAgICAgICAgICAgICAgIHtyb3cuY2VsbHMubWFwKGNlbGwgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3QgY2VsbFByb3BzID0gY2VsbC5nZXRDZWxsUHJvcHMoKSBhcyBUYWJsZUNlbGxQcm9wcyAmIFJlbmRlckhUTUxDZWxsUHJvcHM7XG4gICAgICAgICAgICAgICAgICBjb25zdCB7IGtleTogY2VsbEtleSwgY2VsbENvbnRlbnQsIC4uLnJlc3RQcm9wcyB9ID0gY2VsbFByb3BzO1xuICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gY2VsbEtleSB8fCBjZWxsLmNvbHVtbi5pZDtcbiAgICAgICAgICAgICAgICAgIGlmIChjZWxsUHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDx0ZCBrZXk9e2tleX0gey4uLnJlc3RQcm9wc30gLz47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBJZiBjZWxsUHJvcHMgcmVuZGVyZXMgdGV4dENvbnRlbnQgYWxyZWFkeSwgdGhlbiB3ZSBkb24ndCBoYXZlIHRvXG4gICAgICAgICAgICAgICAgICAvLyByZW5kZXIgYENlbGxgLiBUaGlzIHNhdmVzIHNvbWUgdGltZSBmb3IgbGFyZ2UgdGFibGVzLlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgPHRkIGtleT17a2V5fSB7Li4ucmVzdFByb3BzfT5cbiAgICAgICAgICAgICAgICAgICAgICB7Y2VsbENvbnRlbnQgfHwgY2VsbC5yZW5kZXIoJ0NlbGwnKX1cbiAgICAgICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSl9XG4gICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pXG4gICAgICAgICkgOiAoXG4gICAgICAgICAgPHRyPlxuICAgICAgICAgICAgPHRkIGNsYXNzTmFtZT1cImR0LW5vLXJlc3VsdHNcIiBjb2xTcGFuPXtjb2x1bW5zLmxlbmd0aH0+XG4gICAgICAgICAgICAgIHt0eXBlb2Ygbm9SZXN1bHRzVGV4dCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgID8gbm9SZXN1bHRzVGV4dChmaWx0ZXJWYWx1ZSBhcyBzdHJpbmcpXG4gICAgICAgICAgICAgICAgOiBub1Jlc3VsdHNUZXh0fVxuICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICA8L3RyPlxuICAgICAgICApfVxuICAgICAgPC90Ym9keT5cbiAgICA8L3RhYmxlPlxuICApO1xuXG4gIC8vIGZvcmNlIHVwYXRlIHRoZSBwYWdlU2l6ZSB3aGVuIGl0J3MgYmVlbiB1cGRhdGUgZnJvbSB0aGUgaW5pdGlhbCBzdGF0ZVxuICBpZiAoXG4gICAgcGFnZVNpemVSZWYuY3VycmVudFswXSAhPT0gaW5pdGlhbFBhZ2VTaXplIHx8XG4gICAgLy8gd2hlbiBpbml0aWFsUGFnZVNpemUgc3RheXMgYXMgemVybywgYnV0IHRvdGFsIG51bWJlciBvZiByZWNvcmRzIGNoYW5nZWQsXG4gICAgLy8gd2UnZCBhbHNvIG5lZWQgdG8gdXBkYXRlIHBhZ2Ugc2l6ZVxuICAgIChpbml0aWFsUGFnZVNpemUgPT09IDAgJiYgcGFnZVNpemVSZWYuY3VycmVudFsxXSAhPT0gZGF0YS5sZW5ndGgpXG4gICkge1xuICAgIHBhZ2VTaXplUmVmLmN1cnJlbnQgPSBbaW5pdGlhbFBhZ2VTaXplLCBkYXRhLmxlbmd0aF07XG4gICAgc2V0UGFnZVNpemUoaW5pdGlhbFBhZ2VTaXplKTtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPGRpdiByZWY9e3dyYXBwZXJSZWZ9IHN0eWxlPXt7IHdpZHRoOiBpbml0aWFsV2lkdGgsIGhlaWdodDogaW5pdGlhbEhlaWdodCB9fT5cbiAgICAgIHtoYXNHbG9iYWxDb250cm9sID8gKFxuICAgICAgICA8ZGl2IHJlZj17Z2xvYmFsQ29udHJvbFJlZn0gY2xhc3NOYW1lPVwiZm9ybS1pbmxpbmUgZHQtY29udHJvbHNcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInJvd1wiPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb2wtc20tNlwiPlxuICAgICAgICAgICAgICB7aGFzUGFnaW5hdGlvbiA/IChcbiAgICAgICAgICAgICAgICA8U2VsZWN0UGFnZVNpemVcbiAgICAgICAgICAgICAgICAgIHRvdGFsPXtkYXRhLmxlbmd0aH1cbiAgICAgICAgICAgICAgICAgIHNpemVPcHRpb25zPXtwYWdlU2l6ZU9wdGlvbnN9XG4gICAgICAgICAgICAgICAgICBjdXJyZW50U2l6ZT17cGFnZVNpemV9XG4gICAgICAgICAgICAgICAgICBvbkNoYW5nZT17c2V0UGFnZVNpemV9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgKSA6IG51bGx9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIHtzZWFyY2hJbnB1dCA/IChcbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb2wtc20tNlwiPlxuICAgICAgICAgICAgICAgIDxHbG9iYWxGaWx0ZXI8RD5cbiAgICAgICAgICAgICAgICAgIHNlYXJjaElucHV0PXt0eXBlb2Ygc2VhcmNoSW5wdXQgPT09ICdib29sZWFuJyA/IHVuZGVmaW5lZCA6IHNlYXJjaElucHV0fVxuICAgICAgICAgICAgICAgICAgcHJlR2xvYmFsRmlsdGVyZWRSb3dzPXtwcmVHbG9iYWxGaWx0ZXJlZFJvd3N9XG4gICAgICAgICAgICAgICAgICBzZXRHbG9iYWxGaWx0ZXI9e3NldEdsb2JhbEZpbHRlcn1cbiAgICAgICAgICAgICAgICAgIGZpbHRlclZhbHVlPXtmaWx0ZXJWYWx1ZX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICkgOiBudWxsfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICkgOiBudWxsfVxuICAgICAge3dyYXBTdGlja3lUYWJsZSA/IHdyYXBTdGlja3lUYWJsZShyZW5kZXJUYWJsZSkgOiByZW5kZXJUYWJsZSgpfVxuICAgICAge2hhc1BhZ2luYXRpb24gPyAoXG4gICAgICAgIDxTaW1wbGVQYWdpbmF0aW9uXG4gICAgICAgICAgcmVmPXtwYWdpbmF0aW9uUmVmfVxuICAgICAgICAgIHN0eWxlPXtzdGlja3kuaGVpZ2h0ID8gdW5kZWZpbmVkIDogeyB2aXNpYmlsaXR5OiAnaGlkZGVuJyB9fVxuICAgICAgICAgIG1heFBhZ2VJdGVtQ291bnQ9e21heFBhZ2VJdGVtQ291bnR9XG4gICAgICAgICAgcGFnZUNvdW50PXtwYWdlQ291bnR9XG4gICAgICAgICAgY3VycmVudFBhZ2U9e3BhZ2VJbmRleH1cbiAgICAgICAgICBvblBhZ2VDaGFuZ2U9e2dvdG9QYWdlfVxuICAgICAgICAvPlxuICAgICAgKSA6IG51bGx9XG4gICAgPC9kaXY+XG4gICk7XG59XG4iLCJpbXBvcnQgc3R5bGVkIGZyb20gJ0BzdXBlcnNldC11aS9zdHlsZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHN0eWxlZC5kaXZgXG4gIHRhYmxlIHtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBtaW4td2lkdGg6IGF1dG87XG4gICAgbWF4LXdpZHRoOiBub25lO1xuICAgIG1hcmdpbjogMDtcbiAgfVxuXG4gIHRoLFxuICB0ZCB7XG4gICAgbWluLXdpZHRoOiA0LjNlbTtcbiAgfVxuXG4gIHRoZWFkID4gdHIgPiB0aCB7XG4gICAgcGFkZGluZy1yaWdodDogMS40ZW07XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIGJhY2tncm91bmQ6ICNmZmY7XG4gIH1cbiAgdGggc3ZnIHtcbiAgICBjb2xvcjogI2NjYztcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgYm90dG9tOiAwLjZlbTtcbiAgICByaWdodDogMC4yZW07XG4gIH1cbiAgdGguaXMtc29ydGVkIHN2ZyB7XG4gICAgY29sb3I6ICNhOGE4YTg7XG4gIH1cbiAgLnRhYmxlID4gdGJvZHkgPiB0cjpmaXJzdC1vZi10eXBlID4gdGQsXG4gIC50YWJsZSA+IHRib2R5ID4gdHI6Zmlyc3Qtb2YtdHlwZSA+IHRoIHtcbiAgICBib3JkZXItdG9wOiAwO1xuICB9XG5cbiAgLmR0LWNvbnRyb2xzIHtcbiAgICBwYWRkaW5nLWJvdHRvbTogMC42NWVtO1xuICB9XG4gIC5kdC1tZXRyaWMge1xuICAgIHRleHQtYWxpZ246IHJpZ2h0O1xuICB9XG4gIHRkLmR0LWlzLWZpbHRlciB7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICB9XG4gIHRkLmR0LWlzLWZpbHRlcjpob3ZlciB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogbGluZW47XG4gIH1cbiAgdGQuZHQtaXMtYWN0aXZlLWZpbHRlcixcbiAgdGQuZHQtaXMtYWN0aXZlLWZpbHRlcjpob3ZlciB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogbGlnaHRjeWFuO1xuICB9XG5cbiAgLmR0LWdsb2JhbC1maWx0ZXIge1xuICAgIGZsb2F0OiByaWdodDtcbiAgfVxuXG4gIC5kdC1wYWdpbmF0aW9uIHtcbiAgICB0ZXh0LWFsaWduOiByaWdodDtcbiAgICAvKiB1c2UgcGFkZGluZyBpbnN0ZWFkIG9mIG1hcmdpbiBzbyBjbGllbnRIZWlnaHQgY2FuIGNhcHR1cmUgaXQgKi9cbiAgICBwYWRkaW5nLXRvcDogMC41ZW07XG4gIH1cbiAgLmR0LXBhZ2luYXRpb24gLnBhZ2luYXRpb24ge1xuICAgIG1hcmdpbjogMDtcbiAgfVxuXG4gIC5wYWdpbmF0aW9uID4gbGkgPiBzcGFuLmR0LXBhZ2luYXRpb24tZWxsaXBzaXM6Zm9jdXMsXG4gIC5wYWdpbmF0aW9uID4gbGkgPiBzcGFuLmR0LXBhZ2luYXRpb24tZWxsaXBzaXM6aG92ZXIge1xuICAgIGJhY2tncm91bmQ6ICNmZmY7XG4gIH1cblxuICAuZHQtbm8tcmVzdWx0cyB7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIHBhZGRpbmc6IDFlbSAwLjZlbTtcbiAgfVxuYDtcbiIsIi8qKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IEZpbHRlclhTUywgZ2V0RGVmYXVsdFdoaXRlTGlzdCB9IGZyb20gJ3hzcyc7XG5pbXBvcnQgeyBEYXRhUmVjb3JkVmFsdWUgfSBmcm9tICdAc3VwZXJzZXQtdWkvY2hhcnQnO1xuaW1wb3J0IHsgRGF0YUNvbHVtbk1ldGEgfSBmcm9tICcuLi90eXBlcyc7XG5cbmNvbnN0IHhzcyA9IG5ldyBGaWx0ZXJYU1Moe1xuICB3aGl0ZUxpc3Q6IHtcbiAgICAuLi5nZXREZWZhdWx0V2hpdGVMaXN0KCksXG4gICAgc3BhbjogWydzdHlsZScsICdjbGFzcycsICd0aXRsZSddLFxuICAgIGRpdjogWydzdHlsZScsICdjbGFzcyddLFxuICAgIGE6IFsnc3R5bGUnLCAnY2xhc3MnLCAnaHJlZicsICd0aXRsZScsICd0YXJnZXQnXSxcbiAgICBpbWc6IFsnc3R5bGUnLCAnY2xhc3MnLCAnc3JjJywgJ2FsdCcsICd0aXRsZScsICd3aWR0aCcsICdoZWlnaHQnXSxcbiAgfSxcbiAgc3RyaXBJZ25vcmVUYWc6IHRydWUsXG4gIGNzczogZmFsc2UsXG59KTtcblxuZnVuY3Rpb24gaXNQcm9iYWJseUhUTUwodGV4dDogc3RyaW5nKSB7XG4gIHJldHVybiAvPFtePl0rPi8udGVzdCh0ZXh0KTtcbn1cbi8qKlxuICogRm9ybWF0IHRleHQgZm9yIGNlbGwgdmFsdWVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZm9ybWF0VmFsdWUoXG4gIHsgZm9ybWF0dGVyIH06IERhdGFDb2x1bW5NZXRhLFxuICB2YWx1ZTogRGF0YVJlY29yZFZhbHVlLFxuKTogW2Jvb2xlYW4sIHN0cmluZ10ge1xuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gW2ZhbHNlLCAnTi9BJ107XG4gIH1cbiAgaWYgKGZvcm1hdHRlcikge1xuICAgIC8vIGluIGNhc2UgcGVyY2VudCBtZXRyaWMgY2FuIHNwZWNpZnkgcGVyY2VudCBmb3JtYXQgaW4gdGhlIGZ1dHVyZVxuICAgIHJldHVybiBbZmFsc2UsIGZvcm1hdHRlcih2YWx1ZSBhcyBudW1iZXIpXTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBpc1Byb2JhYmx5SFRNTCh2YWx1ZSkgPyBbdHJ1ZSwgeHNzLnByb2Nlc3ModmFsdWUpXSA6IFtmYWxzZSwgdmFsdWVdO1xuICB9XG4gIHJldHVybiBbZmFsc2UsIHZhbHVlLnRvU3RyaW5nKCldO1xufVxuIiwiLyoqXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlLCB1c2VNZW1vLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IENvbHVtbkluc3RhbmNlLCBDb2x1bW4sIERlZmF1bHRTb3J0VHlwZXMgfSBmcm9tICdyZWFjdC10YWJsZSc7XG5pbXBvcnQgeyBleHRlbnQgYXMgZDNFeHRlbnQsIG1heCBhcyBkM01heCB9IGZyb20gJ2QzLWFycmF5JztcbmltcG9ydCB7IEZhU29ydCwgRmFTb3J0VXAgYXMgRmFTb3J0QXNjLCBGYVNvcnREb3duIGFzIEZhU29ydERlc2MgfSBmcm9tICdyZWFjdC1pY29ucy9mYSc7XG5pbXBvcnQgeyB0IH0gZnJvbSAnQHN1cGVyc2V0LXVpL3RyYW5zbGF0aW9uJztcbmltcG9ydCB7IERhdGFSZWNvcmRWYWx1ZSwgRGF0YVJlY29yZCB9IGZyb20gJ0BzdXBlcnNldC11aS9jaGFydCc7XG5cbmltcG9ydCB7IFRhYmxlQ2hhcnRUcmFuc2Zvcm1lZFByb3BzLCBEYXRhVHlwZSwgRGF0YUNvbHVtbk1ldGEgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCBEYXRhVGFibGUsIHsgRGF0YVRhYmxlUHJvcHMsIFNlYXJjaElucHV0UHJvcHMsIFNpemVPcHRpb24gfSBmcm9tICcuL0RhdGFUYWJsZSc7XG5pbXBvcnQgU3R5bGVzIGZyb20gJy4vU3R5bGVzJztcbmltcG9ydCBmb3JtYXRWYWx1ZSBmcm9tICcuL3V0aWxzL2Zvcm1hdFZhbHVlJztcbmltcG9ydCB7IFBBR0VfU0laRV9PUFRJT05TIH0gZnJvbSAnLi9jb250cm9sUGFuZWwnO1xuXG50eXBlIFZhbHVlUmFuZ2UgPSBbbnVtYmVyLCBudW1iZXJdO1xuXG4vKipcbiAqIFJldHVybiBzb3J0VHlwZSBiYXNlZCBvbiBkYXRhIHR5cGVcbiAqL1xuZnVuY3Rpb24gZ2V0U29ydFR5cGVCeURhdGFUeXBlKGRhdGFUeXBlOiBEYXRhVHlwZSk6IERlZmF1bHRTb3J0VHlwZXMge1xuICBpZiAoZGF0YVR5cGUgPT09IERhdGFUeXBlLkRhdGVUaW1lKSB7XG4gICAgcmV0dXJuICdkYXRldGltZSc7XG4gIH1cbiAgaWYgKGRhdGFUeXBlID09PSBEYXRhVHlwZS5TdHJpbmcpIHtcbiAgICByZXR1cm4gJ2FscGhhbnVtZXJpYyc7XG4gIH1cbiAgcmV0dXJuICdiYXNpYyc7XG59XG5cbi8qKlxuICogQ2VsbCBiYWNrZ3JvdW5kIHRvIHJlbmRlciBjb2x1bW5zIGFzIGhvcml6b250YWwgYmFyIGNoYXJ0XG4gKi9cbmZ1bmN0aW9uIGNlbGxCYXIoe1xuICB2YWx1ZSxcbiAgdmFsdWVSYW5nZSxcbiAgY29sb3JQb3NpdGl2ZU5lZ2F0aXZlID0gZmFsc2UsXG4gIGFsaWduUG9zaXRpdmVOZWdhdGl2ZSxcbn06IHtcbiAgdmFsdWU6IG51bWJlcjtcbiAgdmFsdWVSYW5nZTogVmFsdWVSYW5nZTtcbiAgY29sb3JQb3NpdGl2ZU5lZ2F0aXZlOiBib29sZWFuO1xuICBhbGlnblBvc2l0aXZlTmVnYXRpdmU6IGJvb2xlYW47XG59KSB7XG4gIGNvbnN0IFttaW5WYWx1ZSwgbWF4VmFsdWVdID0gdmFsdWVSYW5nZTtcbiAgY29uc3QgciA9IGNvbG9yUG9zaXRpdmVOZWdhdGl2ZSAmJiB2YWx1ZSA8IDAgPyAxNTAgOiAwO1xuICBpZiAoYWxpZ25Qb3NpdGl2ZU5lZ2F0aXZlKSB7XG4gICAgY29uc3QgcGVyYyA9IE1hdGguYWJzKE1hdGgucm91bmQoKHZhbHVlIC8gbWF4VmFsdWUpICogMTAwKSk7XG4gICAgLy8gVGhlIDAuMDEgdG8gMC4wMDEgaXMgYSB3b3JrYXJvdW5kIGZvciB3aGF0IGFwcGVhcnMgdG8gYmUgYVxuICAgIC8vIENTUyByZW5kZXJpbmcgYnVnIG9uIGZsYXQsIHRyYW5zcGFyZW50IGNvbG9yc1xuICAgIHJldHVybiAoXG4gICAgICBgbGluZWFyLWdyYWRpZW50KHRvIHJpZ2h0LCByZ2JhKCR7cn0sMCwwLDAuMiksIHJnYmEoJHtyfSwwLDAsMC4yKSAke3BlcmN9JSwgYCArXG4gICAgICBgcmdiYSgwLDAsMCwwLjAxKSAke3BlcmN9JSwgcmdiYSgwLDAsMCwwLjAwMSkgMTAwJSlgXG4gICAgKTtcbiAgfVxuICBjb25zdCBwb3NFeHRlbnQgPSBNYXRoLmFicyhNYXRoLm1heChtYXhWYWx1ZSwgMCkpO1xuICBjb25zdCBuZWdFeHRlbnQgPSBNYXRoLmFicyhNYXRoLm1pbihtaW5WYWx1ZSwgMCkpO1xuICBjb25zdCB0b3QgPSBwb3NFeHRlbnQgKyBuZWdFeHRlbnQ7XG4gIGNvbnN0IHBlcmMxID0gTWF0aC5yb3VuZCgoTWF0aC5taW4obmVnRXh0ZW50ICsgdmFsdWUsIG5lZ0V4dGVudCkgLyB0b3QpICogMTAwKTtcbiAgY29uc3QgcGVyYzIgPSBNYXRoLnJvdW5kKChNYXRoLmFicyh2YWx1ZSkgLyB0b3QpICogMTAwKTtcbiAgLy8gVGhlIDAuMDEgdG8gMC4wMDEgaXMgYSB3b3JrYXJvdW5kIGZvciB3aGF0IGFwcGVhcnMgdG8gYmUgYVxuICAvLyBDU1MgcmVuZGVyaW5nIGJ1ZyBvbiBmbGF0LCB0cmFuc3BhcmVudCBjb2xvcnNcbiAgcmV0dXJuIChcbiAgICBgbGluZWFyLWdyYWRpZW50KHRvIHJpZ2h0LCByZ2JhKDAsMCwwLDAuMDEpLCByZ2JhKDAsMCwwLDAuMDAxKSAke3BlcmMxfSUsIGAgK1xuICAgIGByZ2JhKCR7cn0sMCwwLDAuMikgJHtwZXJjMX0lLCByZ2JhKCR7cn0sMCwwLDAuMikgJHtwZXJjMSArIHBlcmMyfSUsIGAgK1xuICAgIGByZ2JhKDAsMCwwLDAuMDEpICR7cGVyYzEgKyBwZXJjMn0lLCByZ2JhKDAsMCwwLDAuMDAxKSAxMDAlKWBcbiAgKTtcbn1cblxuZnVuY3Rpb24gU29ydEljb24oeyBjb2x1bW4gfTogeyBjb2x1bW46IENvbHVtbkluc3RhbmNlIH0pIHtcbiAgY29uc3QgeyBpc1NvcnRlZCwgaXNTb3J0ZWREZXNjIH0gPSBjb2x1bW47XG4gIGxldCBzb3J0SWNvbiA9IDxGYVNvcnQgLz47XG4gIGlmIChpc1NvcnRlZCkge1xuICAgIHNvcnRJY29uID0gaXNTb3J0ZWREZXNjID8gPEZhU29ydERlc2MgLz4gOiA8RmFTb3J0QXNjIC8+O1xuICB9XG4gIHJldHVybiBzb3J0SWNvbjtcbn1cblxuZnVuY3Rpb24gU2VhcmNoSW5wdXQoeyBjb3VudCwgdmFsdWUsIG9uQ2hhbmdlIH06IFNlYXJjaElucHV0UHJvcHMpIHtcbiAgcmV0dXJuIChcbiAgICA8c3BhbiBjbGFzc05hbWU9XCJkdC1nbG9iYWwtZmlsdGVyXCI+XG4gICAgICB7dCgnU2VhcmNoJyl9eycgJ31cbiAgICAgIDxpbnB1dFxuICAgICAgICBjbGFzc05hbWU9XCJmb3JtLWNvbnRyb2wgaW5wdXQtc21cIlxuICAgICAgICBwbGFjZWhvbGRlcj17dCgnJXMgcmVjb3Jkcy4uLicsIGNvdW50KX1cbiAgICAgICAgdmFsdWU9e3ZhbHVlfVxuICAgICAgICBvbkNoYW5nZT17b25DaGFuZ2V9XG4gICAgICAvPlxuICAgIDwvc3Bhbj5cbiAgKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gVGFibGVDaGFydDxEIGV4dGVuZHMgRGF0YVJlY29yZCA9IERhdGFSZWNvcmQ+KFxuICBwcm9wczogVGFibGVDaGFydFRyYW5zZm9ybWVkUHJvcHM8RD4gJiB7XG4gICAgc3RpY2t5PzogRGF0YVRhYmxlUHJvcHM8RD5bJ3N0aWNreSddO1xuICB9LFxuKSB7XG4gIGNvbnN0IHtcbiAgICBoZWlnaHQsXG4gICAgd2lkdGgsXG4gICAgZGF0YSxcbiAgICBjb2x1bW5zOiBjb2x1bW5zTWV0YSxcbiAgICBhbGlnblBvc2l0aXZlTmVnYXRpdmUgPSBmYWxzZSxcbiAgICBjb2xvclBvc2l0aXZlTmVnYXRpdmUgPSBmYWxzZSxcbiAgICBpbmNsdWRlU2VhcmNoID0gZmFsc2UsXG4gICAgcGFnZVNpemUgPSAwLFxuICAgIHNob3dDZWxsQmFycyA9IHRydWUsXG4gICAgZW1pdEZpbHRlciA9IGZhbHNlLFxuICAgIHNvcnREZXNjID0gZmFsc2UsXG4gICAgb25DaGFuZ2VGaWx0ZXIsXG4gICAgZmlsdGVyczogaW5pdGlhbEZpbHRlcnMsXG4gICAgc3RpY2t5ID0gdHJ1ZSwgLy8gd2hldGhlciB0byB1c2Ugc3RpY2t5IGhlYWRlclxuICB9ID0gcHJvcHM7XG5cbiAgY29uc3QgW2ZpbHRlcnMsIHNldEZpbHRlcnNdID0gdXNlU3RhdGUoaW5pdGlhbEZpbHRlcnMpO1xuXG4gIC8vIG9ubHkgdGFrZSByZWxldmFudCBwYWdlIHNpemUgb3B0aW9uc1xuICBjb25zdCBwYWdlU2l6ZU9wdGlvbnMgPSB1c2VNZW1vKFxuICAgICgpID0+IFBBR0VfU0laRV9PUFRJT05TLmZpbHRlcigoW24sIF9dKSA9PiBuIDw9IDIgKiBkYXRhLmxlbmd0aCkgYXMgU2l6ZU9wdGlvbltdLFxuICAgIFtkYXRhLmxlbmd0aF0sXG4gICk7XG5cbiAgY29uc3QgZ2V0VmFsdWVSYW5nZSA9IHVzZUNhbGxiYWNrKFxuICAgIGZ1bmN0aW9uIGdldFZhbHVlUmFuZ2Uoa2V5OiBzdHJpbmcpIHtcbiAgICAgIGlmICh0eXBlb2YgZGF0YT8uWzBdPy5ba2V5XSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgY29uc3QgbnVtcyA9IGRhdGEubWFwKHJvdyA9PiByb3dba2V5XSkgYXMgbnVtYmVyW107XG4gICAgICAgIHJldHVybiAoYWxpZ25Qb3NpdGl2ZU5lZ2F0aXZlXG4gICAgICAgICAgPyBbMCwgZDNNYXgobnVtcy5tYXAoTWF0aC5hYnMpKV1cbiAgICAgICAgICA6IGQzRXh0ZW50KG51bXMpKSBhcyBWYWx1ZVJhbmdlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBbYWxpZ25Qb3NpdGl2ZU5lZ2F0aXZlLCBkYXRhXSxcbiAgKTtcblxuICBjb25zdCBpc0FjdGl2ZUZpbHRlclZhbHVlID0gdXNlQ2FsbGJhY2soXG4gICAgZnVuY3Rpb24gaXNBY3RpdmVGaWx0ZXJWYWx1ZShrZXk6IHN0cmluZywgdmFsOiBEYXRhUmVjb3JkVmFsdWUpIHtcbiAgICAgIHJldHVybiAhIWZpbHRlcnMgJiYgZmlsdGVyc1trZXldPy5pbmNsdWRlcyh2YWwpO1xuICAgIH0sXG4gICAgW2ZpbHRlcnNdLFxuICApO1xuXG4gIGNvbnN0IHRvZ2dsZUZpbHRlciA9IHVzZUNhbGxiYWNrKFxuICAgIGZ1bmN0aW9uIHRvZ2dsZUZpbHRlcihrZXk6IHN0cmluZywgdmFsOiBEYXRhUmVjb3JkVmFsdWUpIHtcbiAgICAgIGNvbnN0IHVwZGF0ZWRGaWx0ZXJzID0geyAuLi4oZmlsdGVycyB8fCB7fSkgfTtcbiAgICAgIGlmIChmaWx0ZXJzICYmIGlzQWN0aXZlRmlsdGVyVmFsdWUoa2V5LCB2YWwpKSB7XG4gICAgICAgIHVwZGF0ZWRGaWx0ZXJzW2tleV0gPSBmaWx0ZXJzW2tleV0uZmlsdGVyKCh4OiBEYXRhUmVjb3JkVmFsdWUpID0+IHggIT09IHZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cGRhdGVkRmlsdGVyc1trZXldID0gWy4uLihmaWx0ZXJzPy5ba2V5XSB8fCBbXSksIHZhbF07XG4gICAgICB9XG4gICAgICBzZXRGaWx0ZXJzKHVwZGF0ZWRGaWx0ZXJzKTtcbiAgICAgIGlmIChvbkNoYW5nZUZpbHRlcikge1xuICAgICAgICBvbkNoYW5nZUZpbHRlcih1cGRhdGVkRmlsdGVycyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbZmlsdGVycywgaXNBY3RpdmVGaWx0ZXJWYWx1ZSwgb25DaGFuZ2VGaWx0ZXJdLFxuICApO1xuXG4gIGNvbnN0IGdldENvbHVtbkNvbmZpZ3MgPSB1c2VDYWxsYmFjayhcbiAgICAoY29sdW1uOiBEYXRhQ29sdW1uTWV0YSwgaTogbnVtYmVyKTogQ29sdW1uPEQ+ID0+IHtcbiAgICAgIGNvbnN0IHsga2V5LCBsYWJlbCwgZGF0YVR5cGUgfSA9IGNvbHVtbjtcbiAgICAgIGNvbnN0IHZhbHVlUmFuZ2UgPSBzaG93Q2VsbEJhcnMgJiYgZ2V0VmFsdWVSYW5nZShrZXkpO1xuICAgICAgY29uc3QgY2VsbFByb3BzOiBDb2x1bW48RD5bJ2NlbGxQcm9wcyddID0gKHsgdmFsdWU6IHZhbHVlXyB9LCBzaGFyZWRDZWxsUHJvcHMpID0+IHtcbiAgICAgICAgbGV0IGNsYXNzTmFtZSA9ICcnO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlXyBhcyBEYXRhUmVjb3JkVmFsdWU7XG4gICAgICAgIGlmIChkYXRhVHlwZSA9PT0gRGF0YVR5cGUuTnVtYmVyKSB7XG4gICAgICAgICAgY2xhc3NOYW1lICs9ICcgZHQtbWV0cmljJztcbiAgICAgICAgfSBlbHNlIGlmIChlbWl0RmlsdGVyKSB7XG4gICAgICAgICAgY2xhc3NOYW1lICs9ICcgZHQtaXMtZmlsdGVyJztcbiAgICAgICAgICBpZiAoaXNBY3RpdmVGaWx0ZXJWYWx1ZShrZXksIHZhbHVlKSkge1xuICAgICAgICAgICAgY2xhc3NOYW1lICs9ICcgZHQtaXMtYWN0aXZlLWZpbHRlcic7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtpc0h0bWwsIHRleHRdID0gZm9ybWF0VmFsdWUoY29sdW1uLCB2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHN0eWxlID0ge1xuICAgICAgICAgIC4uLnNoYXJlZENlbGxQcm9wcy5zdHlsZSxcbiAgICAgICAgICBiYWNrZ3JvdW5kOiB2YWx1ZVJhbmdlXG4gICAgICAgICAgICA/IGNlbGxCYXIoe1xuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSBhcyBudW1iZXIsXG4gICAgICAgICAgICAgICAgdmFsdWVSYW5nZSxcbiAgICAgICAgICAgICAgICBhbGlnblBvc2l0aXZlTmVnYXRpdmUsXG4gICAgICAgICAgICAgICAgY29sb3JQb3NpdGl2ZU5lZ2F0aXZlLFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLy8gc2hvdyByYXcgbnVtYmVyIGluIHRpdGxlIGluIGNhc2Ugb2YgbnVtZXJpYyB2YWx1ZXNcbiAgICAgICAgICB0aXRsZTogdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyA/IFN0cmluZyh2YWx1ZSkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IGlzSHRtbCA/IHsgX19odG1sOiB0ZXh0IH0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgY2VsbENvbnRlbnQ6IHRleHQsXG4gICAgICAgICAgb25DbGljazogZW1pdEZpbHRlciAmJiAhdmFsdWVSYW5nZSA/ICgpID0+IHRvZ2dsZUZpbHRlcihrZXksIHZhbHVlKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBjbGFzc05hbWUsXG4gICAgICAgICAgc3R5bGUsXG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IFN0cmluZyhpKSwgLy8gdG8gYWxsb3cgZHVwbGljYXRlIGNvbHVtbiBrZXlzXG4gICAgICAgIC8vIG11c3QgdXNlIGN1c3RvbSBhY2Nlc3NvciB0byBhbGxvdyBgLmAgaW4gY29sdW1uIG5hbWVzXG4gICAgICAgIC8vIHR5cGluZyBpcyBpbmNvcnJlY3QgaW4gY3VycmVudCB2ZXJzaW9uIG9mIGBAdHlwZXMvcmVhY3QtdGFibGVgXG4gICAgICAgIC8vIHNvIHdlIGFzayBUUyBub3QgdG8gY2hlY2suXG4gICAgICAgIGFjY2Vzc29yOiAoKGRhdHVtOiBEKSA9PiBkYXR1bVtrZXldKSBhcyBuZXZlcixcbiAgICAgICAgSGVhZGVyOiBsYWJlbCxcbiAgICAgICAgU29ydEljb24sXG4gICAgICAgIHNvcnREZXNjRmlyc3Q6IHNvcnREZXNjLFxuICAgICAgICBzb3J0VHlwZTogZ2V0U29ydFR5cGVCeURhdGFUeXBlKGRhdGFUeXBlKSxcbiAgICAgICAgY2VsbFByb3BzLFxuICAgICAgfTtcbiAgICB9LFxuICAgIFtcbiAgICAgIGFsaWduUG9zaXRpdmVOZWdhdGl2ZSxcbiAgICAgIGNvbG9yUG9zaXRpdmVOZWdhdGl2ZSxcbiAgICAgIGVtaXRGaWx0ZXIsXG4gICAgICBnZXRWYWx1ZVJhbmdlLFxuICAgICAgaXNBY3RpdmVGaWx0ZXJWYWx1ZSxcbiAgICAgIHNob3dDZWxsQmFycyxcbiAgICAgIHNvcnREZXNjLFxuICAgICAgdG9nZ2xlRmlsdGVyLFxuICAgIF0sXG4gICk7XG5cbiAgY29uc3QgY29sdW1ucyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiBjb2x1bW5zTWV0YS5tYXAoZ2V0Q29sdW1uQ29uZmlncyk7XG4gIH0sIFtjb2x1bW5zTWV0YSwgZ2V0Q29sdW1uQ29uZmlnc10pO1xuXG4gIHJldHVybiAoXG4gICAgPFN0eWxlcz5cbiAgICAgIDxEYXRhVGFibGU8RD5cbiAgICAgICAgY29sdW1ucz17Y29sdW1uc31cbiAgICAgICAgZGF0YT17ZGF0YX1cbiAgICAgICAgdGFibGVDbGFzc05hbWU9XCJ0YWJsZSB0YWJsZS1zdHJpcGVkIHRhYmxlLWNvbmRlbnNlZFwiXG4gICAgICAgIHNlYXJjaElucHV0PXtpbmNsdWRlU2VhcmNoICYmIFNlYXJjaElucHV0fVxuICAgICAgICBwYWdlU2l6ZT17cGFnZVNpemV9XG4gICAgICAgIHBhZ2VTaXplT3B0aW9ucz17cGFnZVNpemVPcHRpb25zfVxuICAgICAgICB3aWR0aD17d2lkdGh9XG4gICAgICAgIGhlaWdodD17aGVpZ2h0fVxuICAgICAgICAvLyA5IHBhZ2UgaXRlbXMgaW4gPiAzNDBweCB3b3JrcyB3ZWxsIGV2ZW4gZm9yIDEwMCsgcGFnZXNcbiAgICAgICAgbWF4UGFnZUl0ZW1Db3VudD17d2lkdGggPiAzNDAgPyA5IDogN31cbiAgICAgICAgbm9SZXN1bHRzVGV4dD17KGZpbHRlcjogc3RyaW5nKSA9PlxuICAgICAgICAgIHQoZmlsdGVyID8gJ05vIG1hdGNoaW5nIHJlY29yZHMgZm91bmQnIDogJ05vIHJlY29yZHMgZm91bmQnKVxuICAgICAgICB9XG4gICAgICAgIC8vIG5vdCBpbiB1c2UgaW4gU3VwZXJzZXQsIGJ1dCBuZWVkZWQgZm9yIHVuaXQgdGVzdHNcbiAgICAgICAgc3RpY2t5PXtzdGlja3l9XG4gICAgICAvPlxuICAgIDwvU3R5bGVzPlxuICApO1xufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7QUNsREE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBO0FBQ0E7QUFFQTtBQWlCQTtBQUNBOztBQUVBO0FBQ0E7QUFRQTtBQUVBO0FBTUE7QUFDQTtBQUdBO0FBQ0E7QUFJQTtBQUVBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7O0FDL0VBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBRUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBS0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFLQTtBQUNBO0FBR0E7QUFDQTtBQUtBO0FBQ0E7QUFFQTtBQUVBOzs7QUM5RUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBO0FBQ0E7QUFXQTtBQUNBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQU9BO0FBT0E7OztBQ2pHQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9DQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFDQTs7QUFFQTtBQUNBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7OztBQ3JDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFDQTtBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBO0FBQ0E7QUFZQTtBQUNBO0FBQ0E7QUFxQkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQWtDQTtBQUNBO0FBQ0E7QUFJQTtBQUVBOztBQUVBO0FBQ0E7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQU9BO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFNQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFTQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDelVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDckNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTtBQUNBO0FBQ0E7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFvQkE7QUFDQTtBQUFBO0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBZ0JBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBR0E7QUFHQTtBQU1BO0FBQ0E7QUFHQTtBQUdBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUdBO0FBR0E7QUFFQTtBQUNBO0FBUUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBVUE7QUFFQTtBQVdBO0FBQ0E7QUFZQTs7Ozs7O0FDcFJBO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUVBOzs7Ozs7QUN6RUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBO0FBQ0E7QUFJQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDdkRBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQVFBO0FBRUE7QUFLQTtBQWlCQTtBQUVBO0FBQ0E7QUFLQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7O0FBRUE7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFTQTtBQUNBO0FBSUE7QUFDQTtBQUlBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2347\n')}}]);