(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{1936:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return isValueDef; });\n/* unused harmony export isNonValueDef */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return isFieldDef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return isTypedFieldDef; });\n/* unused harmony export isScaleFieldDef */\n/* unused harmony export isPositionFieldDef */\nfunction isValueDef(channelDef) {\n  return channelDef && 'value' in channelDef;\n}\nfunction isNonValueDef(channelDef) {\n  return channelDef && !('value' in channelDef);\n}\nfunction isFieldDef(channelDef) {\n  return channelDef && 'field' in channelDef && !!channelDef.field;\n}\nfunction isTypedFieldDef(channelDef) {\n  return isFieldDef(channelDef) && 'type' in channelDef && !!channelDef.type;\n}\nfunction isScaleFieldDef(channelDef) {\n  return isTypedFieldDef(channelDef) && 'scale' in channelDef;\n}\nfunction isPositionFieldDef(channelDef) {\n  return isTypedFieldDef(channelDef) && 'axis' in channelDef;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkzNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vdHlwZUd1YXJkcy9DaGFubmVsRGVmLmpzPzg2NmQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGlzVmFsdWVEZWYoY2hhbm5lbERlZikge1xuICByZXR1cm4gY2hhbm5lbERlZiAmJiAndmFsdWUnIGluIGNoYW5uZWxEZWY7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNOb25WYWx1ZURlZihjaGFubmVsRGVmKSB7XG4gIHJldHVybiBjaGFubmVsRGVmICYmICEoJ3ZhbHVlJyBpbiBjaGFubmVsRGVmKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0ZpZWxkRGVmKGNoYW5uZWxEZWYpIHtcbiAgcmV0dXJuIGNoYW5uZWxEZWYgJiYgJ2ZpZWxkJyBpbiBjaGFubmVsRGVmICYmICEhY2hhbm5lbERlZi5maWVsZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1R5cGVkRmllbGREZWYoY2hhbm5lbERlZikge1xuICByZXR1cm4gaXNGaWVsZERlZihjaGFubmVsRGVmKSAmJiAndHlwZScgaW4gY2hhbm5lbERlZiAmJiAhIWNoYW5uZWxEZWYudHlwZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1NjYWxlRmllbGREZWYoY2hhbm5lbERlZikge1xuICByZXR1cm4gaXNUeXBlZEZpZWxkRGVmKGNoYW5uZWxEZWYpICYmICdzY2FsZScgaW4gY2hhbm5lbERlZjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1Bvc2l0aW9uRmllbGREZWYoY2hhbm5lbERlZikge1xuICByZXR1cm4gaXNUeXBlZEZpZWxkRGVmKGNoYW5uZWxEZWYpICYmICdheGlzJyBpbiBjaGFubmVsRGVmO1xufSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1936\n")},1978:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DEFAULT_MARGIN; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return createMarginSelector; });\n/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(181);\n\nconst DEFAULT_MARGIN = { bottom: 16, left: 16, right: 16, top: 16 };\nfunction createMarginSelector(defaultMargin = DEFAULT_MARGIN) {\n    return Object(reselect__WEBPACK_IMPORTED_MODULE_0__["createSelector"])((margin) => margin.bottom, margin => margin.left, margin => margin.right, margin => margin.top, (bottom = defaultMargin.bottom, left = defaultMargin.left, right = defaultMargin.right, top = defaultMargin.top) => ({\n        bottom,\n        left,\n        right,\n        top,\n    }));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk3OC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wcmVzZXQtY2hhcnQteHkvc3JjL3V0aWxzL2NyZWF0ZU1hcmdpblNlbGVjdG9yLnRzeD83NTU1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yIH0gZnJvbSAncmVzZWxlY3QnO1xuaW1wb3J0IHsgTWFyZ2luIH0gZnJvbSAnQHN1cGVyc2V0LXVpL2NvcmUnO1xuXG5leHBvcnQgY29uc3QgREVGQVVMVF9NQVJHSU4gPSB7IGJvdHRvbTogMTYsIGxlZnQ6IDE2LCByaWdodDogMTYsIHRvcDogMTYgfTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlTWFyZ2luU2VsZWN0b3IoZGVmYXVsdE1hcmdpbjogTWFyZ2luID0gREVGQVVMVF9NQVJHSU4pIHtcbiAgcmV0dXJuIGNyZWF0ZVNlbGVjdG9yKFxuICAgIChtYXJnaW46IFBhcnRpYWw8TWFyZ2luPikgPT4gbWFyZ2luLmJvdHRvbSxcbiAgICBtYXJnaW4gPT4gbWFyZ2luLmxlZnQsXG4gICAgbWFyZ2luID0+IG1hcmdpbi5yaWdodCxcbiAgICBtYXJnaW4gPT4gbWFyZ2luLnRvcCxcbiAgICAoXG4gICAgICBib3R0b20gPSBkZWZhdWx0TWFyZ2luLmJvdHRvbSxcbiAgICAgIGxlZnQgPSBkZWZhdWx0TWFyZ2luLmxlZnQsXG4gICAgICByaWdodCA9IGRlZmF1bHRNYXJnaW4ucmlnaHQsXG4gICAgICB0b3AgPSBkZWZhdWx0TWFyZ2luLnRvcCxcbiAgICApID0+ICh7XG4gICAgICBib3R0b20sXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHQsXG4gICAgICB0b3AsXG4gICAgfSksXG4gICk7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFFQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1978\n')},1979:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return convertScaleToDataUIScale; });\nfunction isCompatibleDomainOrRange(array) {\n    return (typeof array !== 'undefined' &&\n        array.length > 0 &&\n        (typeof array[0] === 'string' || typeof array[0] === 'number'));\n}\n/**\n * Convert encodeable scale object into @data-ui's scale config\n * @param scale\n */\nfunction convertScaleToDataUIScale(scale) {\n    const { type, domain, range } = scale;\n    let outputType;\n    if (type === 'linear' || type === 'time' || type === 'band') {\n        outputType = type;\n    }\n    else if (type === 'utc') {\n        outputType = 'timeUtc';\n    }\n    else {\n        throw new Error(`Unsupported scale type: ${type}`);\n    }\n    const output = { type: outputType };\n    if (isCompatibleDomainOrRange(domain)) {\n        output.domain = domain;\n    }\n    if (isCompatibleDomainOrRange(range)) {\n        output.range = range;\n    }\n    if ('nice' in scale && typeof scale.nice === 'boolean') {\n        output.nice = scale.nice;\n    }\n    if ('paddingInner' in scale && typeof scale.paddingInner !== 'undefined') {\n        output.paddingInner = scale.paddingInner;\n    }\n    if ('paddingOuter' in scale && typeof scale.paddingOuter !== 'undefined') {\n        output.paddingOuter = scale.paddingOuter;\n    }\n    return output;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk3OS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wcmVzZXQtY2hhcnQteHkvc3JjL3V0aWxzL2NvbnZlcnRTY2FsZVRvRGF0YVVJU2NhbGVTaGFwZS50cz8wNDdmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFZhbHVlLCBTY2FsZUNvbmZpZyB9IGZyb20gJ2VuY29kYWJsZSc7XG5cbnR5cGUgRGF0YVVJU2NhbGVUeXBlID0gJ3RpbWUnIHwgJ3RpbWVVdGMnIHwgJ2xpbmVhcicgfCAnYmFuZCc7XG5cbmludGVyZmFjZSBEYXRhVUlTY2FsZSB7XG4gIHR5cGU6IERhdGFVSVNjYWxlVHlwZTtcbiAgZG9tYWluPzogbnVtYmVyW10gfCBzdHJpbmdbXTtcbiAgaW5jbHVkZVplcm8/OiBib29sZWFuO1xuICBuaWNlPzogYm9vbGVhbjtcbiAgcGFkZGluZ0lubmVyPzogbnVtYmVyO1xuICBwYWRkaW5nT3V0ZXI/OiBudW1iZXI7XG4gIHJhbmdlPzogbnVtYmVyW10gfCBzdHJpbmdbXTtcbiAgcmFuZ2VSb3VuZD86IG51bWJlcltdIHwgc3RyaW5nW107XG59XG5cbmZ1bmN0aW9uIGlzQ29tcGF0aWJsZURvbWFpbk9yUmFuZ2UoXG4gIGFycmF5OiBTY2FsZUNvbmZpZ1snZG9tYWluJ10gfCBTY2FsZUNvbmZpZ1sncmFuZ2UnXSxcbik6IGFycmF5IGlzIG51bWJlcltdIHwgc3RyaW5nW10ge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBhcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICBhcnJheS5sZW5ndGggPiAwICYmXG4gICAgKHR5cGVvZiBhcnJheVswXSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGFycmF5WzBdID09PSAnbnVtYmVyJylcbiAgKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGVuY29kZWFibGUgc2NhbGUgb2JqZWN0IGludG8gQGRhdGEtdWkncyBzY2FsZSBjb25maWdcbiAqIEBwYXJhbSBzY2FsZVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb252ZXJ0U2NhbGVUb0RhdGFVSVNjYWxlPE91dHB1dCBleHRlbmRzIFZhbHVlPihcbiAgc2NhbGU6IFNjYWxlQ29uZmlnPE91dHB1dD4sXG4pIHtcbiAgY29uc3QgeyB0eXBlLCBkb21haW4sIHJhbmdlIH0gPSBzY2FsZTtcblxuICBsZXQgb3V0cHV0VHlwZTogRGF0YVVJU2NhbGVUeXBlO1xuXG4gIGlmICh0eXBlID09PSAnbGluZWFyJyB8fCB0eXBlID09PSAndGltZScgfHwgdHlwZSA9PT0gJ2JhbmQnKSB7XG4gICAgb3V0cHV0VHlwZSA9IHR5cGU7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3V0YycpIHtcbiAgICBvdXRwdXRUeXBlID0gJ3RpbWVVdGMnO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgc2NhbGUgdHlwZTogJHt0eXBlfWApO1xuICB9XG5cbiAgY29uc3Qgb3V0cHV0OiBEYXRhVUlTY2FsZSA9IHsgdHlwZTogb3V0cHV0VHlwZSB9O1xuICBpZiAoaXNDb21wYXRpYmxlRG9tYWluT3JSYW5nZShkb21haW4pKSB7XG4gICAgb3V0cHV0LmRvbWFpbiA9IGRvbWFpbjtcbiAgfVxuICBpZiAoaXNDb21wYXRpYmxlRG9tYWluT3JSYW5nZShyYW5nZSkpIHtcbiAgICBvdXRwdXQucmFuZ2UgPSByYW5nZTtcbiAgfVxuICBpZiAoJ25pY2UnIGluIHNjYWxlICYmIHR5cGVvZiBzY2FsZS5uaWNlID09PSAnYm9vbGVhbicpIHtcbiAgICBvdXRwdXQubmljZSA9IHNjYWxlLm5pY2U7XG4gIH1cbiAgaWYgKCdwYWRkaW5nSW5uZXInIGluIHNjYWxlICYmIHR5cGVvZiBzY2FsZS5wYWRkaW5nSW5uZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgb3V0cHV0LnBhZGRpbmdJbm5lciA9IHNjYWxlLnBhZGRpbmdJbm5lcjtcbiAgfVxuICBpZiAoJ3BhZGRpbmdPdXRlcicgaW4gc2NhbGUgJiYgdHlwZW9mIHNjYWxlLnBhZGRpbmdPdXRlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBvdXRwdXQucGFkZGluZ091dGVyID0gc2NhbGUucGFkZGluZ091dGVyO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBZUE7QUFBQTtBQUdBO0FBRUE7QUFDQTtBQUVBO0FBRUE7OztBQUdBO0FBQ0E7QUFHQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1979\n")},1980:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"a\", function() { return /* binding */ createXYChartLayoutWithTheme; });\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react/index.js\nvar react = __webpack_require__(0);\nvar react_default = /*#__PURE__*/__webpack_require__.n(react);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/axis/XAxis.js\nvar XAxis = __webpack_require__(2387);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/axis/YAxis.js\nvar YAxis = __webpack_require__(2388);\n\n// EXTERNAL MODULE: ../superset-ui-core/src/dimension/mergeMargin.ts\nvar mergeMargin = __webpack_require__(1055);\n\n// EXTERNAL MODULE: ../superset-ui-core/src/chart-composition/ChartFrame.tsx\nvar ChartFrame = __webpack_require__(1059);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/utils/createTickComponent.tsx\nvar __rest = (undefined && undefined.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n\nfunction createTickComponent({ axisWidth, labelAngle, labelFlush, labelOverlap, orient, tickLabels, tickLabelDimensions, tickTextAnchor = 'middle', }) {\n    if (labelOverlap === 'rotate' && labelAngle !== 0) {\n        let xOffset = labelAngle > 0 ? -6 : 6;\n        if (orient === 'top') {\n            xOffset = 0;\n        }\n        const yOffset = orient === 'top' ? -3 : 0;\n        return (_a) => {\n            var { x, y, formattedValue = '' } = _a, textStyle = __rest(_a, [\"x\", \"y\", \"formattedValue\"]);\n            return (react_default.a.createElement(\"g\", { transform: `translate(${x + xOffset}, ${y + yOffset})` },\n                react_default.a.createElement(\"text\", Object.assign({ transform: `rotate(${labelAngle})` }, textStyle, { textAnchor: tickTextAnchor }), formattedValue)));\n        };\n    }\n    if (labelFlush === true || typeof labelFlush === 'number') {\n        const labelToDimensionMap = new Map();\n        tickLabels.forEach((label, i) => {\n            labelToDimensionMap.set(label, tickLabelDimensions[i]);\n        });\n        return (_a) => {\n            var { x, y, formattedValue = '' } = _a, textStyle = __rest(_a, [\"x\", \"y\", \"formattedValue\"]);\n            const dimension = labelToDimensionMap.get(formattedValue);\n            const labelWidth = typeof dimension === 'undefined' ? 0 : dimension.width;\n            let textAnchor = tickTextAnchor;\n            let xOffset = 0;\n            if (x - labelWidth / 2 < 0) {\n                textAnchor = 'start';\n                if (typeof labelFlush === 'number') {\n                    xOffset -= labelFlush;\n                }\n            }\n            else if (x + labelWidth / 2 > axisWidth) {\n                textAnchor = 'end';\n                if (typeof labelFlush === 'number') {\n                    xOffset += labelFlush;\n                }\n            }\n            return (react_default.a.createElement(\"text\", Object.assign({ x: x + xOffset, y: y }, textStyle, { textAnchor: textAnchor }), formattedValue));\n        };\n    }\n    // This will render the tick as horizontal string.\n    return null;\n}\n\n// EXTERNAL MODULE: ../superset-ui-core/src/dimension/getTextDimension.ts\nvar getTextDimension = __webpack_require__(442);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/utils/computeAxisLayout.ts\n\nfunction computeAxisLayout(axis, { axisTitleHeight = 20, axisWidth, gapBetweenAxisLabelAndBorder = 4, gapBetweenTickAndTickLabel = 4, defaultTickSize = 8, tickTextStyle = {}, }) {\n    const tickLabels = axis.getTickLabels();\n    const tickLabelDimensions = tickLabels.map((text) => Object(getTextDimension[\"a\" /* default */])({\n        style: tickTextStyle,\n        text,\n    }));\n    const { labelAngle, labelFlush, labelOverlap, labelPadding, orient, tickSize = defaultTickSize, } = axis.config;\n    const maxWidth = Math.max(...tickLabelDimensions.map(d => d.width), 0);\n    // cheap heuristic, can improve\n    const widthPerTick = axisWidth / tickLabels.length;\n    const isLabelOverlap = maxWidth > widthPerTick;\n    const labelAngleIfOverlap = labelOverlap.strategy === 'rotate' ? labelOverlap.labelAngle : 0;\n    const labelAngleAfterOverlapCheck = isLabelOverlap ? labelAngleIfOverlap : 0;\n    const finalLabelAngle = labelAngle === 0 ? labelAngleAfterOverlapCheck : labelAngle;\n    const spaceForAxisTitle = axis.hasTitle() ? labelPadding + axisTitleHeight : 0;\n    let tickTextAnchor = 'middle';\n    let labelOffset = 0;\n    let requiredMargin = tickSize + gapBetweenTickAndTickLabel + spaceForAxisTitle + gapBetweenAxisLabelAndBorder;\n    if (axis.channelEncoder.isX()) {\n        if (finalLabelAngle === 0) {\n            const labelHeight = tickLabelDimensions.length > 0 ? tickLabelDimensions[0].height : 0;\n            labelOffset = labelHeight + labelPadding;\n            requiredMargin += labelHeight;\n        }\n        else {\n            const labelHeight = Math.ceil(Math.abs(maxWidth * Math.sin((finalLabelAngle * Math.PI) / 180)));\n            labelOffset = labelHeight + labelPadding;\n            requiredMargin += labelHeight;\n            tickTextAnchor =\n                (orient === 'top' && finalLabelAngle > 0) || (orient === 'bottom' && finalLabelAngle < 0)\n                    ? 'end'\n                    : 'start';\n        }\n        requiredMargin += 8;\n    }\n    else {\n        labelOffset = maxWidth + spaceForAxisTitle;\n        requiredMargin += maxWidth;\n    }\n    return {\n        axisWidth,\n        labelAngle: finalLabelAngle,\n        labelFlush,\n        labelOffset,\n        labelOverlap: isLabelOverlap ? labelOverlap.strategy : 'flat',\n        minMargin: {\n            [orient]: Math.ceil(requiredMargin),\n        },\n        orient,\n        tickLabelDimensions,\n        tickLabels,\n        tickTextAnchor,\n    };\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/utils/XYChartLayout.tsx\n\n\n\n\n\nconst DEFAULT_LABEL_ANGLE = 40;\n// Additional margin to avoid content hidden behind scroll bar\nconst OVERFLOW_MARGIN = 8;\nclass XYChartLayout_XYChartLayout {\n    constructor(config) {\n        const { width, height, minContentWidth = 0, minContentHeight = 0, margin, xEncoder, xTickSize, xTickTextStyle, autoAdjustXMargin = true, yEncoder, yTickSize, yTickTextStyle, autoAdjustYMargin = true, } = config;\n        this.xEncoder = xEncoder;\n        this.yEncoder = yEncoder;\n        if (typeof yEncoder.axis !== 'undefined') {\n            this.yLayout = computeAxisLayout(yEncoder.axis, {\n                axisWidth: Math.max(height - margin.top - margin.bottom),\n                defaultTickSize: yTickSize,\n                tickTextStyle: yTickTextStyle,\n            });\n        }\n        const secondMargin = this.yLayout && autoAdjustYMargin ? Object(mergeMargin[\"a\" /* default */])(margin, this.yLayout.minMargin) : margin;\n        const innerWidth = Math.max(width - secondMargin.left - secondMargin.right, minContentWidth);\n        if (typeof xEncoder.axis !== 'undefined') {\n            this.xLayout = computeAxisLayout(xEncoder.axis, {\n                axisWidth: innerWidth,\n                defaultTickSize: xTickSize,\n                tickTextStyle: xTickTextStyle,\n            });\n        }\n        const finalMargin = this.xLayout && autoAdjustXMargin\n            ? Object(mergeMargin[\"a\" /* default */])(secondMargin, this.xLayout.minMargin)\n            : secondMargin;\n        const innerHeight = Math.max(height - finalMargin.top - finalMargin.bottom, minContentHeight);\n        const chartWidth = Math.round(innerWidth + finalMargin.left + finalMargin.right);\n        const chartHeight = Math.round(innerHeight + finalMargin.top + finalMargin.bottom);\n        const isOverFlowX = chartWidth > width;\n        const isOverFlowY = chartHeight > height;\n        if (isOverFlowX) {\n            finalMargin.bottom += OVERFLOW_MARGIN;\n        }\n        if (isOverFlowY) {\n            finalMargin.right += OVERFLOW_MARGIN;\n        }\n        this.chartWidth = isOverFlowX ? chartWidth + OVERFLOW_MARGIN : chartWidth;\n        this.chartHeight = isOverFlowY ? chartHeight + OVERFLOW_MARGIN : chartHeight;\n        this.containerWidth = width;\n        this.containerHeight = height;\n        this.margin = finalMargin;\n    }\n    renderChartWithFrame(renderChart) {\n        return (react_default.a.createElement(ChartFrame[\"a\" /* default */], { width: this.containerWidth, height: this.containerHeight, contentWidth: this.chartWidth, contentHeight: this.chartHeight, renderContent: renderChart }));\n    }\n    renderXAxis(props) {\n        const { axis } = this.xEncoder;\n        return axis && this.xLayout ? (react_default.a.createElement(XAxis[\"a\" /* default */], Object.assign({ label: axis.getTitle(), labelOffset: this.xLayout.labelOffset, numTicks: axis.config.tickCount, orientation: axis.config.orient, tickComponent: createTickComponent(this.xLayout), tickFormat: axis.formatValue }, props))) : null;\n    }\n    renderYAxis(props) {\n        const { axis } = this.yEncoder;\n        return axis && this.yLayout ? (react_default.a.createElement(YAxis[\"a\" /* default */], Object.assign({ label: axis.getTitle(), labelOffset: this.yLayout.labelOffset, numTicks: axis.config.tickCount, orientation: axis.config.orient, tickFormat: axis.formatValue }, props))) : null;\n    }\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/utils/createXYChartLayoutWithTheme.ts\nvar createXYChartLayoutWithTheme_rest = (undefined && undefined.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n\nfunction createXYChartLayoutWithTheme(config) {\n    const { theme } = config, rest = createXYChartLayoutWithTheme_rest(config, [\"theme\"]);\n    return new XYChartLayout_XYChartLayout(Object.assign(Object.assign({}, rest), { \n        // @ts-ignore\n        xTickSize: theme.xTickStyles.length || theme.xTickStyles.tickLength, xTickTextStyle: theme.xTickStyles.label.bottom || theme.xTickStyles.label.top, \n        // @ts-ignore\n        yTickSize: theme.yTickStyles.length || theme.yTickStyles.tickLength, yTickTextStyle: theme.yTickStyles.label.left || theme.yTickStyles.label.right }));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk4MC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wcmVzZXQtY2hhcnQteHkvc3JjL3V0aWxzL2NyZWF0ZVRpY2tDb21wb25lbnQudHN4P2UxOWQiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9wbHVnaW5zL3ByZXNldC1jaGFydC14eS9zcmMvdXRpbHMvY29tcHV0ZUF4aXNMYXlvdXQudHM/Yjk2ZCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvcHJlc2V0LWNoYXJ0LXh5L3NyYy91dGlscy9YWUNoYXJ0TGF5b3V0LnRzeD83YzZmIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wcmVzZXQtY2hhcnQteHkvc3JjL3V0aWxzL2NyZWF0ZVhZQ2hhcnRMYXlvdXRXaXRoVGhlbWUudHM/ZDI4OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgQ1NTUHJvcGVydGllcyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IERpbWVuc2lvbiB9IGZyb20gJ0BzdXBlcnNldC11aS9jb3JlJztcbmltcG9ydCB7IEF4aXNMYXlvdXQgfSBmcm9tICcuL2NvbXB1dGVBeGlzTGF5b3V0JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlVGlja0NvbXBvbmVudCh7XG4gIGF4aXNXaWR0aCxcbiAgbGFiZWxBbmdsZSxcbiAgbGFiZWxGbHVzaCxcbiAgbGFiZWxPdmVybGFwLFxuICBvcmllbnQsXG4gIHRpY2tMYWJlbHMsXG4gIHRpY2tMYWJlbERpbWVuc2lvbnMsXG4gIHRpY2tUZXh0QW5jaG9yID0gJ21pZGRsZScsXG59OiBBeGlzTGF5b3V0KSB7XG4gIGlmIChsYWJlbE92ZXJsYXAgPT09ICdyb3RhdGUnICYmIGxhYmVsQW5nbGUgIT09IDApIHtcbiAgICBsZXQgeE9mZnNldCA9IGxhYmVsQW5nbGUgPiAwID8gLTYgOiA2O1xuICAgIGlmIChvcmllbnQgPT09ICd0b3AnKSB7XG4gICAgICB4T2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgY29uc3QgeU9mZnNldCA9IG9yaWVudCA9PT0gJ3RvcCcgPyAtMyA6IDA7XG5cbiAgICByZXR1cm4gKHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgZm9ybWF0dGVkVmFsdWUgPSAnJyxcbiAgICAgIC4uLnRleHRTdHlsZVxuICAgIH06IHtcbiAgICAgIHg6IG51bWJlcjtcbiAgICAgIHk6IG51bWJlcjtcbiAgICAgIGR5PzogbnVtYmVyO1xuICAgICAgZm9ybWF0dGVkVmFsdWU6IHN0cmluZztcbiAgICAgIHRleHRTdHlsZTogQ1NTUHJvcGVydGllcztcbiAgICB9KSA9PiAoXG4gICAgICA8ZyB0cmFuc2Zvcm09e2B0cmFuc2xhdGUoJHt4ICsgeE9mZnNldH0sICR7eSArIHlPZmZzZXR9KWB9PlxuICAgICAgICA8dGV4dCB0cmFuc2Zvcm09e2Byb3RhdGUoJHtsYWJlbEFuZ2xlfSlgfSB7Li4udGV4dFN0eWxlfSB0ZXh0QW5jaG9yPXt0aWNrVGV4dEFuY2hvcn0+XG4gICAgICAgICAge2Zvcm1hdHRlZFZhbHVlfVxuICAgICAgICA8L3RleHQ+XG4gICAgICA8L2c+XG4gICAgKTtcbiAgfVxuXG4gIGlmIChsYWJlbEZsdXNoID09PSB0cnVlIHx8IHR5cGVvZiBsYWJlbEZsdXNoID09PSAnbnVtYmVyJykge1xuICAgIGNvbnN0IGxhYmVsVG9EaW1lbnNpb25NYXAgPSBuZXcgTWFwPHN0cmluZywgRGltZW5zaW9uPigpO1xuICAgIHRpY2tMYWJlbHMuZm9yRWFjaCgobGFiZWwsIGkpID0+IHtcbiAgICAgIGxhYmVsVG9EaW1lbnNpb25NYXAuc2V0KGxhYmVsLCB0aWNrTGFiZWxEaW1lbnNpb25zW2ldKTtcbiAgICB9KTtcblxuICAgIHJldHVybiAoe1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBmb3JtYXR0ZWRWYWx1ZSA9ICcnLFxuICAgICAgLi4udGV4dFN0eWxlXG4gICAgfToge1xuICAgICAgeDogbnVtYmVyO1xuICAgICAgeTogbnVtYmVyO1xuICAgICAgZHk/OiBudW1iZXI7XG4gICAgICBmb3JtYXR0ZWRWYWx1ZTogc3RyaW5nO1xuICAgICAgdGV4dFN0eWxlOiBDU1NQcm9wZXJ0aWVzO1xuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IGxhYmVsVG9EaW1lbnNpb25NYXAuZ2V0KGZvcm1hdHRlZFZhbHVlKTtcbiAgICAgIGNvbnN0IGxhYmVsV2lkdGggPSB0eXBlb2YgZGltZW5zaW9uID09PSAndW5kZWZpbmVkJyA/IDAgOiBkaW1lbnNpb24ud2lkdGg7XG4gICAgICBsZXQgdGV4dEFuY2hvciA9IHRpY2tUZXh0QW5jaG9yO1xuICAgICAgbGV0IHhPZmZzZXQgPSAwO1xuXG4gICAgICBpZiAoeCAtIGxhYmVsV2lkdGggLyAyIDwgMCkge1xuICAgICAgICB0ZXh0QW5jaG9yID0gJ3N0YXJ0JztcbiAgICAgICAgaWYgKHR5cGVvZiBsYWJlbEZsdXNoID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHhPZmZzZXQgLT0gbGFiZWxGbHVzaDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh4ICsgbGFiZWxXaWR0aCAvIDIgPiBheGlzV2lkdGgpIHtcbiAgICAgICAgdGV4dEFuY2hvciA9ICdlbmQnO1xuICAgICAgICBpZiAodHlwZW9mIGxhYmVsRmx1c2ggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgeE9mZnNldCArPSBsYWJlbEZsdXNoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgIDx0ZXh0IHg9e3ggKyB4T2Zmc2V0fSB5PXt5fSB7Li4udGV4dFN0eWxlfSB0ZXh0QW5jaG9yPXt0ZXh0QW5jaG9yfT5cbiAgICAgICAgICB7Zm9ybWF0dGVkVmFsdWV9XG4gICAgICAgIDwvdGV4dD5cbiAgICAgICk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIFRoaXMgd2lsbCByZW5kZXIgdGhlIHRpY2sgYXMgaG9yaXpvbnRhbCBzdHJpbmcuXG4gIHJldHVybiBudWxsO1xufVxuIiwiaW1wb3J0IHsgQ1NTUHJvcGVydGllcyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGdldFRleHREaW1lbnNpb24sIE1hcmdpbiwgRGltZW5zaW9uIH0gZnJvbSAnQHN1cGVyc2V0LXVpL2NvcmUnO1xuaW1wb3J0IHsgQXhpc09yaWVudCwgQ2hhbm5lbERlZiwgVmFsdWUgfSBmcm9tICdlbmNvZGFibGUnO1xuXG5pbXBvcnQgQ2hhbm5lbEVuY29kZXJBeGlzIGZyb20gJ2VuY29kYWJsZS9saWIvZW5jb2RlcnMvQ2hhbm5lbEVuY29kZXJBeGlzJztcblxuZXhwb3J0IGludGVyZmFjZSBBeGlzTGF5b3V0IHtcbiAgYXhpc1dpZHRoOiBudW1iZXI7XG4gIGxhYmVsQW5nbGU6IG51bWJlcjtcbiAgbGFiZWxGbHVzaDogbnVtYmVyIHwgYm9vbGVhbjtcbiAgbGFiZWxPZmZzZXQ6IG51bWJlcjtcbiAgbGFiZWxPdmVybGFwOiAnZmxhdCcgfCAncm90YXRlJztcbiAgbWluTWFyZ2luOiBQYXJ0aWFsPE1hcmdpbj47XG4gIG9yaWVudDogQXhpc09yaWVudDtcbiAgdGlja0xhYmVsRGltZW5zaW9uczogRGltZW5zaW9uW107XG4gIHRpY2tMYWJlbHM6IHN0cmluZ1tdO1xuICB0aWNrVGV4dEFuY2hvcj86IHN0cmluZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcHV0ZUF4aXNMYXlvdXQ8RGVmIGV4dGVuZHMgQ2hhbm5lbERlZjxPdXRwdXQ+LCBPdXRwdXQgZXh0ZW5kcyBWYWx1ZT4oXG4gIGF4aXM6IENoYW5uZWxFbmNvZGVyQXhpczxEZWYsIE91dHB1dD4sXG4gIHtcbiAgICBheGlzVGl0bGVIZWlnaHQgPSAyMCxcbiAgICBheGlzV2lkdGgsXG4gICAgZ2FwQmV0d2VlbkF4aXNMYWJlbEFuZEJvcmRlciA9IDQsXG4gICAgZ2FwQmV0d2VlblRpY2tBbmRUaWNrTGFiZWwgPSA0LFxuICAgIGRlZmF1bHRUaWNrU2l6ZSA9IDgsXG4gICAgdGlja1RleHRTdHlsZSA9IHt9LFxuICB9OiB7XG4gICAgYXhpc1RpdGxlSGVpZ2h0PzogbnVtYmVyO1xuICAgIGF4aXNXaWR0aDogbnVtYmVyO1xuICAgIGdhcEJldHdlZW5BeGlzTGFiZWxBbmRCb3JkZXI/OiBudW1iZXI7XG4gICAgZ2FwQmV0d2VlblRpY2tBbmRUaWNrTGFiZWw/OiBudW1iZXI7XG4gICAgZGVmYXVsdFRpY2tTaXplPzogbnVtYmVyO1xuICAgIHRpY2tUZXh0U3R5bGU/OiBDU1NQcm9wZXJ0aWVzO1xuICB9LFxuKTogQXhpc0xheW91dCB7XG4gIGNvbnN0IHRpY2tMYWJlbHMgPSBheGlzLmdldFRpY2tMYWJlbHMoKTtcbiAgY29uc3QgdGlja0xhYmVsRGltZW5zaW9ucyA9IHRpY2tMYWJlbHMubWFwKCh0ZXh0OiBzdHJpbmcpID0+XG4gICAgZ2V0VGV4dERpbWVuc2lvbih7XG4gICAgICBzdHlsZTogdGlja1RleHRTdHlsZSxcbiAgICAgIHRleHQsXG4gICAgfSksXG4gICk7XG5cbiAgY29uc3Qge1xuICAgIGxhYmVsQW5nbGUsXG4gICAgbGFiZWxGbHVzaCxcbiAgICBsYWJlbE92ZXJsYXAsXG4gICAgbGFiZWxQYWRkaW5nLFxuICAgIG9yaWVudCxcbiAgICB0aWNrU2l6ZSA9IGRlZmF1bHRUaWNrU2l6ZSxcbiAgfSA9IGF4aXMuY29uZmlnO1xuXG4gIGNvbnN0IG1heFdpZHRoID0gTWF0aC5tYXgoLi4udGlja0xhYmVsRGltZW5zaW9ucy5tYXAoZCA9PiBkLndpZHRoKSwgMCk7XG5cbiAgLy8gY2hlYXAgaGV1cmlzdGljLCBjYW4gaW1wcm92ZVxuICBjb25zdCB3aWR0aFBlclRpY2sgPSBheGlzV2lkdGggLyB0aWNrTGFiZWxzLmxlbmd0aDtcbiAgY29uc3QgaXNMYWJlbE92ZXJsYXAgPSBtYXhXaWR0aCA+IHdpZHRoUGVyVGljaztcbiAgY29uc3QgbGFiZWxBbmdsZUlmT3ZlcmxhcCA9IGxhYmVsT3ZlcmxhcC5zdHJhdGVneSA9PT0gJ3JvdGF0ZScgPyBsYWJlbE92ZXJsYXAubGFiZWxBbmdsZSA6IDA7XG4gIGNvbnN0IGxhYmVsQW5nbGVBZnRlck92ZXJsYXBDaGVjayA9IGlzTGFiZWxPdmVybGFwID8gbGFiZWxBbmdsZUlmT3ZlcmxhcCA6IDA7XG4gIGNvbnN0IGZpbmFsTGFiZWxBbmdsZSA9IGxhYmVsQW5nbGUgPT09IDAgPyBsYWJlbEFuZ2xlQWZ0ZXJPdmVybGFwQ2hlY2sgOiBsYWJlbEFuZ2xlO1xuXG4gIGNvbnN0IHNwYWNlRm9yQXhpc1RpdGxlID0gYXhpcy5oYXNUaXRsZSgpID8gbGFiZWxQYWRkaW5nICsgYXhpc1RpdGxlSGVpZ2h0IDogMDtcbiAgbGV0IHRpY2tUZXh0QW5jaG9yID0gJ21pZGRsZSc7XG4gIGxldCBsYWJlbE9mZnNldCA9IDA7XG4gIGxldCByZXF1aXJlZE1hcmdpbiA9XG4gICAgdGlja1NpemUgKyBnYXBCZXR3ZWVuVGlja0FuZFRpY2tMYWJlbCArIHNwYWNlRm9yQXhpc1RpdGxlICsgZ2FwQmV0d2VlbkF4aXNMYWJlbEFuZEJvcmRlcjtcblxuICBpZiAoYXhpcy5jaGFubmVsRW5jb2Rlci5pc1goKSkge1xuICAgIGlmIChmaW5hbExhYmVsQW5nbGUgPT09IDApIHtcbiAgICAgIGNvbnN0IGxhYmVsSGVpZ2h0ID0gdGlja0xhYmVsRGltZW5zaW9ucy5sZW5ndGggPiAwID8gdGlja0xhYmVsRGltZW5zaW9uc1swXS5oZWlnaHQgOiAwO1xuICAgICAgbGFiZWxPZmZzZXQgPSBsYWJlbEhlaWdodCArIGxhYmVsUGFkZGluZztcbiAgICAgIHJlcXVpcmVkTWFyZ2luICs9IGxhYmVsSGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsYWJlbEhlaWdodCA9IE1hdGguY2VpbChcbiAgICAgICAgTWF0aC5hYnMobWF4V2lkdGggKiBNYXRoLnNpbigoZmluYWxMYWJlbEFuZ2xlICogTWF0aC5QSSkgLyAxODApKSxcbiAgICAgICk7XG4gICAgICBsYWJlbE9mZnNldCA9IGxhYmVsSGVpZ2h0ICsgbGFiZWxQYWRkaW5nO1xuICAgICAgcmVxdWlyZWRNYXJnaW4gKz0gbGFiZWxIZWlnaHQ7XG4gICAgICB0aWNrVGV4dEFuY2hvciA9XG4gICAgICAgIChvcmllbnQgPT09ICd0b3AnICYmIGZpbmFsTGFiZWxBbmdsZSA+IDApIHx8IChvcmllbnQgPT09ICdib3R0b20nICYmIGZpbmFsTGFiZWxBbmdsZSA8IDApXG4gICAgICAgICAgPyAnZW5kJ1xuICAgICAgICAgIDogJ3N0YXJ0JztcbiAgICB9XG4gICAgcmVxdWlyZWRNYXJnaW4gKz0gODtcbiAgfSBlbHNlIHtcbiAgICBsYWJlbE9mZnNldCA9IG1heFdpZHRoICsgc3BhY2VGb3JBeGlzVGl0bGU7XG4gICAgcmVxdWlyZWRNYXJnaW4gKz0gbWF4V2lkdGg7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGF4aXNXaWR0aCxcbiAgICBsYWJlbEFuZ2xlOiBmaW5hbExhYmVsQW5nbGUsXG4gICAgbGFiZWxGbHVzaCxcbiAgICBsYWJlbE9mZnNldCxcbiAgICBsYWJlbE92ZXJsYXA6IGlzTGFiZWxPdmVybGFwID8gbGFiZWxPdmVybGFwLnN0cmF0ZWd5IDogJ2ZsYXQnLFxuICAgIG1pbk1hcmdpbjoge1xuICAgICAgW29yaWVudF06IE1hdGguY2VpbChyZXF1aXJlZE1hcmdpbiksXG4gICAgfSxcbiAgICBvcmllbnQsXG4gICAgdGlja0xhYmVsRGltZW5zaW9ucyxcbiAgICB0aWNrTGFiZWxzLFxuICAgIHRpY2tUZXh0QW5jaG9yLFxuICB9O1xufVxuIiwiaW1wb3J0IFJlYWN0LCB7IFJlYWN0Tm9kZSwgQ1NTUHJvcGVydGllcyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFhBeGlzLCBZQXhpcyB9IGZyb20gJ0BkYXRhLXVpL3h5LWNoYXJ0JztcbmltcG9ydCB7IENoYXJ0RnJhbWUsIE1hcmdpbiwgbWVyZ2VNYXJnaW4sIERpbWVuc2lvbiB9IGZyb20gJ0BzdXBlcnNldC11aS9jb3JlJztcbmltcG9ydCB7IENoYW5uZWxFbmNvZGVyLCBQbGFpbk9iamVjdCwgVmFsdWUsIFhGaWVsZERlZiwgWUZpZWxkRGVmIH0gZnJvbSAnZW5jb2RhYmxlJztcbmltcG9ydCBjcmVhdGVUaWNrQ29tcG9uZW50IGZyb20gJy4vY3JlYXRlVGlja0NvbXBvbmVudCc7XG5pbXBvcnQgY29tcHV0ZUF4aXNMYXlvdXQsIHsgQXhpc0xheW91dCB9IGZyb20gJy4vY29tcHV0ZUF4aXNMYXlvdXQnO1xuXG5leHBvcnQgY29uc3QgREVGQVVMVF9MQUJFTF9BTkdMRSA9IDQwO1xuXG4vLyBBZGRpdGlvbmFsIG1hcmdpbiB0byBhdm9pZCBjb250ZW50IGhpZGRlbiBiZWhpbmQgc2Nyb2xsIGJhclxuY29uc3QgT1ZFUkZMT1dfTUFSR0lOID0gODtcblxuZXhwb3J0IGludGVyZmFjZSBYWUNoYXJ0TGF5b3V0Q29uZmlnPFhPdXRwdXQgZXh0ZW5kcyBWYWx1ZSwgWU91dHB1dCBleHRlbmRzIFZhbHVlPiB7XG4gIHdpZHRoOiBudW1iZXI7XG4gIGhlaWdodDogbnVtYmVyO1xuICBtaW5Db250ZW50V2lkdGg/OiBudW1iZXI7XG4gIG1pbkNvbnRlbnRIZWlnaHQ/OiBudW1iZXI7XG4gIG1hcmdpbjogTWFyZ2luO1xuICB4RW5jb2RlcjogQ2hhbm5lbEVuY29kZXI8WEZpZWxkRGVmPFhPdXRwdXQ+LCBYT3V0cHV0PjtcbiAgeFRpY2tTaXplPzogbnVtYmVyO1xuICB4VGlja1RleHRTdHlsZT86IENTU1Byb3BlcnRpZXM7XG4gIGF1dG9BZGp1c3RYTWFyZ2luPzogYm9vbGVhbjtcbiAgeUVuY29kZXI6IENoYW5uZWxFbmNvZGVyPFlGaWVsZERlZjxZT3V0cHV0PiwgWU91dHB1dD47XG4gIHlUaWNrU2l6ZT86IG51bWJlcjtcbiAgeVRpY2tUZXh0U3R5bGU/OiBDU1NQcm9wZXJ0aWVzO1xuICBhdXRvQWRqdXN0WU1hcmdpbj86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFhZQ2hhcnRMYXlvdXQ8WE91dHB1dCBleHRlbmRzIFZhbHVlLCBZT3V0cHV0IGV4dGVuZHMgVmFsdWU+IHtcbiAgY2hhcnRXaWR0aDogbnVtYmVyO1xuXG4gIGNoYXJ0SGVpZ2h0OiBudW1iZXI7XG5cbiAgY29udGFpbmVyV2lkdGg6IG51bWJlcjtcblxuICBjb250YWluZXJIZWlnaHQ6IG51bWJlcjtcblxuICBtYXJnaW46IE1hcmdpbjtcblxuICB4RW5jb2RlcjogQ2hhbm5lbEVuY29kZXI8WEZpZWxkRGVmPFhPdXRwdXQ+LCBYT3V0cHV0PjtcblxuICB4TGF5b3V0PzogQXhpc0xheW91dDtcblxuICB5RW5jb2RlcjogQ2hhbm5lbEVuY29kZXI8WUZpZWxkRGVmPFlPdXRwdXQ+LCBZT3V0cHV0PjtcblxuICB5TGF5b3V0PzogQXhpc0xheW91dDtcblxuICBjb25zdHJ1Y3Rvcihjb25maWc6IFhZQ2hhcnRMYXlvdXRDb25maWc8WE91dHB1dCwgWU91dHB1dD4pIHtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIG1pbkNvbnRlbnRXaWR0aCA9IDAsXG4gICAgICBtaW5Db250ZW50SGVpZ2h0ID0gMCxcbiAgICAgIG1hcmdpbixcbiAgICAgIHhFbmNvZGVyLFxuICAgICAgeFRpY2tTaXplLFxuICAgICAgeFRpY2tUZXh0U3R5bGUsXG4gICAgICBhdXRvQWRqdXN0WE1hcmdpbiA9IHRydWUsXG4gICAgICB5RW5jb2RlcixcbiAgICAgIHlUaWNrU2l6ZSxcbiAgICAgIHlUaWNrVGV4dFN0eWxlLFxuICAgICAgYXV0b0FkanVzdFlNYXJnaW4gPSB0cnVlLFxuICAgIH0gPSBjb25maWc7XG5cbiAgICB0aGlzLnhFbmNvZGVyID0geEVuY29kZXI7XG4gICAgdGhpcy55RW5jb2RlciA9IHlFbmNvZGVyO1xuXG4gICAgaWYgKHR5cGVvZiB5RW5jb2Rlci5heGlzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy55TGF5b3V0ID0gY29tcHV0ZUF4aXNMYXlvdXQoeUVuY29kZXIuYXhpcywge1xuICAgICAgICBheGlzV2lkdGg6IE1hdGgubWF4KGhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tKSxcbiAgICAgICAgZGVmYXVsdFRpY2tTaXplOiB5VGlja1NpemUsXG4gICAgICAgIHRpY2tUZXh0U3R5bGU6IHlUaWNrVGV4dFN0eWxlLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2Vjb25kTWFyZ2luID1cbiAgICAgIHRoaXMueUxheW91dCAmJiBhdXRvQWRqdXN0WU1hcmdpbiA/IG1lcmdlTWFyZ2luKG1hcmdpbiwgdGhpcy55TGF5b3V0Lm1pbk1hcmdpbikgOiBtYXJnaW47XG4gICAgY29uc3QgaW5uZXJXaWR0aCA9IE1hdGgubWF4KHdpZHRoIC0gc2Vjb25kTWFyZ2luLmxlZnQgLSBzZWNvbmRNYXJnaW4ucmlnaHQsIG1pbkNvbnRlbnRXaWR0aCk7XG5cbiAgICBpZiAodHlwZW9mIHhFbmNvZGVyLmF4aXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLnhMYXlvdXQgPSBjb21wdXRlQXhpc0xheW91dCh4RW5jb2Rlci5heGlzLCB7XG4gICAgICAgIGF4aXNXaWR0aDogaW5uZXJXaWR0aCxcbiAgICAgICAgZGVmYXVsdFRpY2tTaXplOiB4VGlja1NpemUsXG4gICAgICAgIHRpY2tUZXh0U3R5bGU6IHhUaWNrVGV4dFN0eWxlLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgZmluYWxNYXJnaW4gPVxuICAgICAgdGhpcy54TGF5b3V0ICYmIGF1dG9BZGp1c3RYTWFyZ2luXG4gICAgICAgID8gbWVyZ2VNYXJnaW4oc2Vjb25kTWFyZ2luLCB0aGlzLnhMYXlvdXQubWluTWFyZ2luKVxuICAgICAgICA6IHNlY29uZE1hcmdpbjtcblxuICAgIGNvbnN0IGlubmVySGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0IC0gZmluYWxNYXJnaW4udG9wIC0gZmluYWxNYXJnaW4uYm90dG9tLCBtaW5Db250ZW50SGVpZ2h0KTtcblxuICAgIGNvbnN0IGNoYXJ0V2lkdGggPSBNYXRoLnJvdW5kKGlubmVyV2lkdGggKyBmaW5hbE1hcmdpbi5sZWZ0ICsgZmluYWxNYXJnaW4ucmlnaHQpO1xuICAgIGNvbnN0IGNoYXJ0SGVpZ2h0ID0gTWF0aC5yb3VuZChpbm5lckhlaWdodCArIGZpbmFsTWFyZ2luLnRvcCArIGZpbmFsTWFyZ2luLmJvdHRvbSk7XG5cbiAgICBjb25zdCBpc092ZXJGbG93WCA9IGNoYXJ0V2lkdGggPiB3aWR0aDtcbiAgICBjb25zdCBpc092ZXJGbG93WSA9IGNoYXJ0SGVpZ2h0ID4gaGVpZ2h0O1xuICAgIGlmIChpc092ZXJGbG93WCkge1xuICAgICAgZmluYWxNYXJnaW4uYm90dG9tICs9IE9WRVJGTE9XX01BUkdJTjtcbiAgICB9XG4gICAgaWYgKGlzT3ZlckZsb3dZKSB7XG4gICAgICBmaW5hbE1hcmdpbi5yaWdodCArPSBPVkVSRkxPV19NQVJHSU47XG4gICAgfVxuICAgIHRoaXMuY2hhcnRXaWR0aCA9IGlzT3ZlckZsb3dYID8gY2hhcnRXaWR0aCArIE9WRVJGTE9XX01BUkdJTiA6IGNoYXJ0V2lkdGg7XG4gICAgdGhpcy5jaGFydEhlaWdodCA9IGlzT3ZlckZsb3dZID8gY2hhcnRIZWlnaHQgKyBPVkVSRkxPV19NQVJHSU4gOiBjaGFydEhlaWdodDtcbiAgICB0aGlzLmNvbnRhaW5lcldpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5jb250YWluZXJIZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5tYXJnaW4gPSBmaW5hbE1hcmdpbjtcbiAgfVxuXG4gIHJlbmRlckNoYXJ0V2l0aEZyYW1lKHJlbmRlckNoYXJ0OiAoaW5wdXQ6IERpbWVuc2lvbikgPT4gUmVhY3ROb2RlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxDaGFydEZyYW1lXG4gICAgICAgIHdpZHRoPXt0aGlzLmNvbnRhaW5lcldpZHRofVxuICAgICAgICBoZWlnaHQ9e3RoaXMuY29udGFpbmVySGVpZ2h0fVxuICAgICAgICBjb250ZW50V2lkdGg9e3RoaXMuY2hhcnRXaWR0aH1cbiAgICAgICAgY29udGVudEhlaWdodD17dGhpcy5jaGFydEhlaWdodH1cbiAgICAgICAgcmVuZGVyQ29udGVudD17cmVuZGVyQ2hhcnR9XG4gICAgICAvPlxuICAgICk7XG4gIH1cblxuICByZW5kZXJYQXhpcyhwcm9wcz86IFBsYWluT2JqZWN0KSB7XG4gICAgY29uc3QgeyBheGlzIH0gPSB0aGlzLnhFbmNvZGVyO1xuXG4gICAgcmV0dXJuIGF4aXMgJiYgdGhpcy54TGF5b3V0ID8gKFxuICAgICAgPFhBeGlzXG4gICAgICAgIGxhYmVsPXtheGlzLmdldFRpdGxlKCl9XG4gICAgICAgIGxhYmVsT2Zmc2V0PXt0aGlzLnhMYXlvdXQubGFiZWxPZmZzZXR9XG4gICAgICAgIG51bVRpY2tzPXtheGlzLmNvbmZpZy50aWNrQ291bnR9XG4gICAgICAgIG9yaWVudGF0aW9uPXtheGlzLmNvbmZpZy5vcmllbnR9XG4gICAgICAgIHRpY2tDb21wb25lbnQ9e2NyZWF0ZVRpY2tDb21wb25lbnQodGhpcy54TGF5b3V0KX1cbiAgICAgICAgdGlja0Zvcm1hdD17YXhpcy5mb3JtYXRWYWx1ZX1cbiAgICAgICAgey4uLnByb3BzfVxuICAgICAgLz5cbiAgICApIDogbnVsbDtcbiAgfVxuXG4gIHJlbmRlcllBeGlzKHByb3BzPzogUGxhaW5PYmplY3QpIHtcbiAgICBjb25zdCB7IGF4aXMgfSA9IHRoaXMueUVuY29kZXI7XG5cbiAgICByZXR1cm4gYXhpcyAmJiB0aGlzLnlMYXlvdXQgPyAoXG4gICAgICA8WUF4aXNcbiAgICAgICAgbGFiZWw9e2F4aXMuZ2V0VGl0bGUoKX1cbiAgICAgICAgbGFiZWxPZmZzZXQ9e3RoaXMueUxheW91dC5sYWJlbE9mZnNldH1cbiAgICAgICAgbnVtVGlja3M9e2F4aXMuY29uZmlnLnRpY2tDb3VudH1cbiAgICAgICAgb3JpZW50YXRpb249e2F4aXMuY29uZmlnLm9yaWVudH1cbiAgICAgICAgdGlja0Zvcm1hdD17YXhpcy5mb3JtYXRWYWx1ZX1cbiAgICAgICAgey4uLnByb3BzfVxuICAgICAgLz5cbiAgICApIDogbnVsbDtcbiAgfVxufVxuIiwiaW1wb3J0IHsgQ2hhcnRUaGVtZSB9IGZyb20gJ0BkYXRhLXVpL3RoZW1lJztcbmltcG9ydCB7IFZhbHVlIH0gZnJvbSAnZW5jb2RhYmxlJztcbmltcG9ydCBYWUNoYXJ0TGF5b3V0LCB7IFhZQ2hhcnRMYXlvdXRDb25maWcgfSBmcm9tICcuL1hZQ2hhcnRMYXlvdXQnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVYWUNoYXJ0TGF5b3V0V2l0aFRoZW1lPFhPdXRwdXQgZXh0ZW5kcyBWYWx1ZSwgWU91dHB1dCBleHRlbmRzIFZhbHVlPihcbiAgY29uZmlnOiBYWUNoYXJ0TGF5b3V0Q29uZmlnPFhPdXRwdXQsIFlPdXRwdXQ+ICYge1xuICAgIHRoZW1lOiBDaGFydFRoZW1lO1xuICB9LFxuKSB7XG4gIGNvbnN0IHsgdGhlbWUsIC4uLnJlc3QgfSA9IGNvbmZpZztcblxuICByZXR1cm4gbmV3IFhZQ2hhcnRMYXlvdXQ8WE91dHB1dCwgWU91dHB1dD4oe1xuICAgIC4uLnJlc3QsXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHhUaWNrU2l6ZTogdGhlbWUueFRpY2tTdHlsZXMubGVuZ3RoIHx8IHRoZW1lLnhUaWNrU3R5bGVzLnRpY2tMZW5ndGgsXG4gICAgeFRpY2tUZXh0U3R5bGU6IHRoZW1lLnhUaWNrU3R5bGVzLmxhYmVsLmJvdHRvbSB8fCB0aGVtZS54VGlja1N0eWxlcy5sYWJlbC50b3AsXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHlUaWNrU2l6ZTogdGhlbWUueVRpY2tTdHlsZXMubGVuZ3RoIHx8IHRoZW1lLnlUaWNrU3R5bGVzLnRpY2tMZW5ndGgsXG4gICAgeVRpY2tUZXh0U3R5bGU6IHRoZW1lLnlUaWNrU3R5bGVzLmxhYmVsLmxlZnQgfHwgdGhlbWUueVRpY2tTdHlsZXMubGFiZWwucmlnaHQsXG4gIH0pO1xufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBSUE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBV0E7QUFFQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7Ozs7QUNyRkE7QUFrQkE7QUFrQkE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBU0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFrQkE7QUFtQkE7QUFDQTtBQWdCQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQVNBO0FBRUE7QUFDQTtBQUVBO0FBV0E7QUFFQTtBQUNBO0FBRUE7QUFVQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3hKQTtBQUVBO0FBS0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1980\n")},1981:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"a\", function() { return /* binding */ createRenderLegend; });\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react/index.js\nvar react = __webpack_require__(0);\nvar react_default = /*#__PURE__*/__webpack_require__.n(react);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/legend/esm/legends/Legend/LegendItem.js\nvar LegendItem = __webpack_require__(2254);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/legend/esm/legends/Legend/LegendLabel.js\nvar LegendLabel = __webpack_require__(2255);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/components/legend/DefaultLegendItem.tsx\n\n\nconst MARK_SIZE = 8;\nconst MARK_STYLE = { display: 'inline-block' };\nfunction DefaultLegendItem({ group, item, MarkRenderer, LabelRenderer, }) {\n    var _a, _b, _c, _d;\n    return (react_default.a.createElement(LegendItem[\"a\" /* default */], { key: `legend-item-${group.field}-${item.input}`, margin: \"0 5px\" },\n        typeof MarkRenderer === 'undefined' ? (react_default.a.createElement(\"svg\", { width: MARK_SIZE, height: MARK_SIZE, style: MARK_STYLE },\n            react_default.a.createElement(\"circle\", { fill: \n                // @ts-ignore\n                ((_c = (_b = (_a = item.output.color) !== null && _a !== void 0 ? _a : \n                // @ts-ignore\n                item.output.fill) !== null && _b !== void 0 ? _b : \n                // @ts-ignore\n                item.output.stroke) !== null && _c !== void 0 ? _c : '#ccc'), stroke: \n                // @ts-ignore\n                ((_d = item.output.stroke) !== null && _d !== void 0 ? _d : 'none'), r: MARK_SIZE / 2, cx: MARK_SIZE / 2, cy: MARK_SIZE / 2 }))) : (react_default.a.createElement(MarkRenderer, { group: group, item: item })),\n        typeof LabelRenderer === 'undefined' ? (react_default.a.createElement(LegendLabel[\"a\" /* default */], { align: \"left\", margin: \"0 0 0 4px\" }, item.input)) : (react_default.a.createElement(LabelRenderer, { group: group, item: item }))));\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/components/legend/DefaultLegendGroup.tsx\n\n\nconst LEGEND_GROUP_STYLE = {\n    display: 'flex',\n    flexBasis: 'auto',\n    flexDirection: 'row',\n    flexGrow: 1,\n    flexShrink: 1,\n    flexWrap: 'wrap',\n    fontSize: '0.8em',\n    justifyContent: 'flex-end',\n    padding: 8,\n};\nfunction DefaultLegendGroupRenderer({ group, ItemRenderer = DefaultLegendItem, ItemMarkRenderer, ItemLabelRenderer, style, }) {\n    const combinedStyle = typeof style === 'undefined' ? LEGEND_GROUP_STYLE : Object.assign(Object.assign({}, LEGEND_GROUP_STYLE), style);\n    return (react_default.a.createElement(\"div\", { style: combinedStyle }, 'items' in group &&\n        group.items.map(item => (react_default.a.createElement(ItemRenderer, { key: `legend-item-${group.field}-${item.input}`, group: group, item: item, MarkRenderer: ItemMarkRenderer, LabelRenderer: ItemLabelRenderer })))));\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/components/legend/DefaultLegend.tsx\n\n\nconst LEGEND_CONTAINER_STYLE = {\n    display: 'flex',\n    flexBasis: 'auto',\n    flexGrow: 1,\n    flexShrink: 1,\n    maxHeight: 100,\n    overflowY: 'auto',\n    position: 'relative',\n};\nclass DefaultLegend_DefaultLegend extends react[\"PureComponent\"] {\n    render() {\n        const { groups, LegendGroupRenderer = DefaultLegendGroupRenderer, LegendItemRenderer, LegendItemMarkRenderer, LegendItemLabelRenderer, style, } = this.props;\n        const combinedStyle = typeof style === 'undefined'\n            ? LEGEND_CONTAINER_STYLE\n            : Object.assign(Object.assign({}, LEGEND_CONTAINER_STYLE), style);\n        return (react_default.a.createElement(\"div\", { style: combinedStyle }, groups\n            .filter(group => 'items' in group && group.items.length > 0)\n            .map(group => (react_default.a.createElement(LegendGroupRenderer, { key: group.field, group: group, ItemRenderer: LegendItemRenderer, ItemMarkRenderer: LegendItemMarkRenderer, ItemLabelRenderer: LegendItemLabelRenderer })))));\n    }\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/components/legend/createRenderLegend.tsx\n\n\nfunction createRenderLegend(encoder, data, props) {\n    if (encoder.hasLegend()) {\n        const { LegendRenderer = DefaultLegend_DefaultLegend, LegendGroupRenderer, LegendItemRenderer, LegendItemLabelRenderer, LegendItemMarkRenderer, } = props;\n        return () => (react_default.a.createElement(LegendRenderer, { groups: encoder.getLegendInformation(data), LegendGroupRenderer: LegendGroupRenderer, LegendItemRenderer: LegendItemRenderer, LegendItemMarkRenderer: LegendItemMarkRenderer, LegendItemLabelRenderer: LegendItemLabelRenderer }));\n    }\n    return undefined;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk4MS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wcmVzZXQtY2hhcnQteHkvc3JjL2NvbXBvbmVudHMvbGVnZW5kL0RlZmF1bHRMZWdlbmRJdGVtLnRzeD9hMTZmIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wcmVzZXQtY2hhcnQteHkvc3JjL2NvbXBvbmVudHMvbGVnZW5kL0RlZmF1bHRMZWdlbmRHcm91cC50c3g/NWM4MSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvcHJlc2V0LWNoYXJ0LXh5L3NyYy9jb21wb25lbnRzL2xlZ2VuZC9EZWZhdWx0TGVnZW5kLnRzeD9jMzA1Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wcmVzZXQtY2hhcnQteHkvc3JjL2NvbXBvbmVudHMvbGVnZW5kL2NyZWF0ZVJlbmRlckxlZ2VuZC50c3g/YTk1NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgQ1NTUHJvcGVydGllcyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IExlZ2VuZEl0ZW0sIExlZ2VuZExhYmVsIH0gZnJvbSAnQHZ4L2xlZ2VuZCc7XG5pbXBvcnQgeyBFbmNvZGluZ0NvbmZpZyB9IGZyb20gJ2VuY29kYWJsZSc7XG5pbXBvcnQgeyBMZWdlbmRJdGVtUmVuZGVyZXJQcm9wcyB9IGZyb20gJy4vdHlwZXMnO1xuXG5jb25zdCBNQVJLX1NJWkUgPSA4O1xuXG5jb25zdCBNQVJLX1NUWUxFOiBDU1NQcm9wZXJ0aWVzID0geyBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyB9O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEZWZhdWx0TGVnZW5kSXRlbTxDb25maWcgZXh0ZW5kcyBFbmNvZGluZ0NvbmZpZz4oe1xuICBncm91cCxcbiAgaXRlbSxcbiAgTWFya1JlbmRlcmVyLFxuICBMYWJlbFJlbmRlcmVyLFxufTogTGVnZW5kSXRlbVJlbmRlcmVyUHJvcHM8Q29uZmlnPikge1xuICByZXR1cm4gKFxuICAgIDxMZWdlbmRJdGVtIGtleT17YGxlZ2VuZC1pdGVtLSR7Z3JvdXAuZmllbGR9LSR7aXRlbS5pbnB1dH1gfSBtYXJnaW49XCIwIDVweFwiPlxuICAgICAge3R5cGVvZiBNYXJrUmVuZGVyZXIgPT09ICd1bmRlZmluZWQnID8gKFxuICAgICAgICA8c3ZnIHdpZHRoPXtNQVJLX1NJWkV9IGhlaWdodD17TUFSS19TSVpFfSBzdHlsZT17TUFSS19TVFlMRX0+XG4gICAgICAgICAgPGNpcmNsZVxuICAgICAgICAgICAgZmlsbD17XG4gICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgKGl0ZW0ub3V0cHV0LmNvbG9yID8/XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGl0ZW0ub3V0cHV0LmZpbGwgPz9cbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgaXRlbS5vdXRwdXQuc3Ryb2tlID8/XG4gICAgICAgICAgICAgICAgJyNjY2MnKSBhcyBzdHJpbmdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cm9rZT17XG4gICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgKGl0ZW0ub3V0cHV0LnN0cm9rZSA/PyAnbm9uZScpIGFzIHN0cmluZ1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcj17TUFSS19TSVpFIC8gMn1cbiAgICAgICAgICAgIGN4PXtNQVJLX1NJWkUgLyAyfVxuICAgICAgICAgICAgY3k9e01BUktfU0laRSAvIDJ9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9zdmc+XG4gICAgICApIDogKFxuICAgICAgICA8TWFya1JlbmRlcmVyIGdyb3VwPXtncm91cH0gaXRlbT17aXRlbX0gLz5cbiAgICAgICl9XG4gICAgICB7dHlwZW9mIExhYmVsUmVuZGVyZXIgPT09ICd1bmRlZmluZWQnID8gKFxuICAgICAgICA8TGVnZW5kTGFiZWwgYWxpZ249XCJsZWZ0XCIgbWFyZ2luPVwiMCAwIDAgNHB4XCI+XG4gICAgICAgICAge2l0ZW0uaW5wdXR9XG4gICAgICAgIDwvTGVnZW5kTGFiZWw+XG4gICAgICApIDogKFxuICAgICAgICA8TGFiZWxSZW5kZXJlciBncm91cD17Z3JvdXB9IGl0ZW09e2l0ZW19IC8+XG4gICAgICApfVxuICAgIDwvTGVnZW5kSXRlbT5cbiAgKTtcbn1cbiIsImltcG9ydCBSZWFjdCwgeyBDU1NQcm9wZXJ0aWVzIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgRW5jb2RpbmdDb25maWcgfSBmcm9tICdlbmNvZGFibGUnO1xuaW1wb3J0IHsgTGVnZW5kR3JvdXBSZW5kZXJlclByb3BzIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgRGVmYXVsdExlZ2VuZEl0ZW0gZnJvbSAnLi9EZWZhdWx0TGVnZW5kSXRlbSc7XG5cbmNvbnN0IExFR0VORF9HUk9VUF9TVFlMRTogQ1NTUHJvcGVydGllcyA9IHtcbiAgZGlzcGxheTogJ2ZsZXgnLFxuICBmbGV4QmFzaXM6ICdhdXRvJyxcbiAgZmxleERpcmVjdGlvbjogJ3JvdycsXG4gIGZsZXhHcm93OiAxLFxuICBmbGV4U2hyaW5rOiAxLFxuICBmbGV4V3JhcDogJ3dyYXAnLFxuICBmb250U2l6ZTogJzAuOGVtJyxcbiAganVzdGlmeUNvbnRlbnQ6ICdmbGV4LWVuZCcsXG4gIHBhZGRpbmc6IDgsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEZWZhdWx0TGVnZW5kR3JvdXBSZW5kZXJlcjxDb25maWcgZXh0ZW5kcyBFbmNvZGluZ0NvbmZpZz4oe1xuICBncm91cCxcbiAgSXRlbVJlbmRlcmVyID0gRGVmYXVsdExlZ2VuZEl0ZW0sXG4gIEl0ZW1NYXJrUmVuZGVyZXIsXG4gIEl0ZW1MYWJlbFJlbmRlcmVyLFxuICBzdHlsZSxcbn06IExlZ2VuZEdyb3VwUmVuZGVyZXJQcm9wczxDb25maWc+KSB7XG4gIGNvbnN0IGNvbWJpbmVkU3R5bGUgPVxuICAgIHR5cGVvZiBzdHlsZSA9PT0gJ3VuZGVmaW5lZCcgPyBMRUdFTkRfR1JPVVBfU1RZTEUgOiB7IC4uLkxFR0VORF9HUk9VUF9TVFlMRSwgLi4uc3R5bGUgfTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgc3R5bGU9e2NvbWJpbmVkU3R5bGV9PlxuICAgICAgeydpdGVtcycgaW4gZ3JvdXAgJiZcbiAgICAgICAgZ3JvdXAuaXRlbXMubWFwKGl0ZW0gPT4gKFxuICAgICAgICAgIDxJdGVtUmVuZGVyZXJcbiAgICAgICAgICAgIGtleT17YGxlZ2VuZC1pdGVtLSR7Z3JvdXAuZmllbGR9LSR7aXRlbS5pbnB1dH1gfVxuICAgICAgICAgICAgZ3JvdXA9e2dyb3VwfVxuICAgICAgICAgICAgaXRlbT17aXRlbX1cbiAgICAgICAgICAgIE1hcmtSZW5kZXJlcj17SXRlbU1hcmtSZW5kZXJlcn1cbiAgICAgICAgICAgIExhYmVsUmVuZGVyZXI9e0l0ZW1MYWJlbFJlbmRlcmVyfVxuICAgICAgICAgIC8+XG4gICAgICAgICkpfVxuICAgIDwvZGl2PlxuICApO1xufVxuIiwiaW1wb3J0IFJlYWN0LCB7IENTU1Byb3BlcnRpZXMsIFB1cmVDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBFbmNvZGluZ0NvbmZpZyB9IGZyb20gJ2VuY29kYWJsZSc7XG5pbXBvcnQgeyBMZWdlbmRSZW5kZXJlclByb3BzIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgRGVmYXVsdExlZ2VuZEdyb3VwIGZyb20gJy4vRGVmYXVsdExlZ2VuZEdyb3VwJztcblxuY29uc3QgTEVHRU5EX0NPTlRBSU5FUl9TVFlMRTogQ1NTUHJvcGVydGllcyA9IHtcbiAgZGlzcGxheTogJ2ZsZXgnLFxuICBmbGV4QmFzaXM6ICdhdXRvJyxcbiAgZmxleEdyb3c6IDEsXG4gIGZsZXhTaHJpbms6IDEsXG4gIG1heEhlaWdodDogMTAwLFxuICBvdmVyZmxvd1k6ICdhdXRvJyxcbiAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG59O1xuXG5leHBvcnQgdHlwZSBQcm9wczxDb25maWcgZXh0ZW5kcyBFbmNvZGluZ0NvbmZpZz4gPSBMZWdlbmRSZW5kZXJlclByb3BzPENvbmZpZz47XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlZmF1bHRMZWdlbmQ8Q29uZmlnIGV4dGVuZHMgRW5jb2RpbmdDb25maWc+IGV4dGVuZHMgUHVyZUNvbXBvbmVudDxcbiAgUHJvcHM8Q29uZmlnPlxuPiB7XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBncm91cHMsXG4gICAgICBMZWdlbmRHcm91cFJlbmRlcmVyID0gRGVmYXVsdExlZ2VuZEdyb3VwLFxuICAgICAgTGVnZW5kSXRlbVJlbmRlcmVyLFxuICAgICAgTGVnZW5kSXRlbU1hcmtSZW5kZXJlcixcbiAgICAgIExlZ2VuZEl0ZW1MYWJlbFJlbmRlcmVyLFxuICAgICAgc3R5bGUsXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCBjb21iaW5lZFN0eWxlID1cbiAgICAgIHR5cGVvZiBzdHlsZSA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyBMRUdFTkRfQ09OVEFJTkVSX1NUWUxFXG4gICAgICAgIDogeyAuLi5MRUdFTkRfQ09OVEFJTkVSX1NUWUxFLCAuLi5zdHlsZSB9O1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgc3R5bGU9e2NvbWJpbmVkU3R5bGV9PlxuICAgICAgICB7Z3JvdXBzXG4gICAgICAgICAgLmZpbHRlcihncm91cCA9PiAnaXRlbXMnIGluIGdyb3VwICYmIGdyb3VwLml0ZW1zLmxlbmd0aCA+IDApXG4gICAgICAgICAgLm1hcChncm91cCA9PiAoXG4gICAgICAgICAgICA8TGVnZW5kR3JvdXBSZW5kZXJlclxuICAgICAgICAgICAgICBrZXk9e2dyb3VwLmZpZWxkfVxuICAgICAgICAgICAgICBncm91cD17Z3JvdXB9XG4gICAgICAgICAgICAgIEl0ZW1SZW5kZXJlcj17TGVnZW5kSXRlbVJlbmRlcmVyfVxuICAgICAgICAgICAgICBJdGVtTWFya1JlbmRlcmVyPXtMZWdlbmRJdGVtTWFya1JlbmRlcmVyfVxuICAgICAgICAgICAgICBJdGVtTGFiZWxSZW5kZXJlcj17TGVnZW5kSXRlbUxhYmVsUmVuZGVyZXJ9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICkpfVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEVuY29kZXIsIEVuY29kaW5nQ29uZmlnLCBEYXRhc2V0IH0gZnJvbSAnZW5jb2RhYmxlJztcbmltcG9ydCB7IExlZ2VuZEhvb2tzIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgRGVmYXVsdExlZ2VuZCBmcm9tICcuL0RlZmF1bHRMZWdlbmQnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVSZW5kZXJMZWdlbmQ8Q29uZmlnIGV4dGVuZHMgRW5jb2RpbmdDb25maWc+KFxuICBlbmNvZGVyOiBFbmNvZGVyPENvbmZpZz4sXG4gIGRhdGE6IERhdGFzZXQsXG4gIHByb3BzOiBMZWdlbmRIb29rczxDb25maWc+LFxuKSB7XG4gIGlmIChlbmNvZGVyLmhhc0xlZ2VuZCgpKSB7XG4gICAgY29uc3Qge1xuICAgICAgTGVnZW5kUmVuZGVyZXIgPSBEZWZhdWx0TGVnZW5kLFxuICAgICAgTGVnZW5kR3JvdXBSZW5kZXJlcixcbiAgICAgIExlZ2VuZEl0ZW1SZW5kZXJlcixcbiAgICAgIExlZ2VuZEl0ZW1MYWJlbFJlbmRlcmVyLFxuICAgICAgTGVnZW5kSXRlbU1hcmtSZW5kZXJlcixcbiAgICB9ID0gcHJvcHM7XG5cbiAgICByZXR1cm4gKCkgPT4gKFxuICAgICAgPExlZ2VuZFJlbmRlcmVyXG4gICAgICAgIGdyb3Vwcz17ZW5jb2Rlci5nZXRMZWdlbmRJbmZvcm1hdGlvbihkYXRhKX1cbiAgICAgICAgTGVnZW5kR3JvdXBSZW5kZXJlcj17TGVnZW5kR3JvdXBSZW5kZXJlcn1cbiAgICAgICAgTGVnZW5kSXRlbVJlbmRlcmVyPXtMZWdlbmRJdGVtUmVuZGVyZXJ9XG4gICAgICAgIExlZ2VuZEl0ZW1NYXJrUmVuZGVyZXI9e0xlZ2VuZEl0ZW1NYXJrUmVuZGVyZXJ9XG4gICAgICAgIExlZ2VuZEl0ZW1MYWJlbFJlbmRlcmVyPXtMZWdlbmRJdGVtTGFiZWxSZW5kZXJlcn1cbiAgICAgIC8+XG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFJQTtBQUVBO0FBRUE7O0FBTUE7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQVVBO0FBU0E7OztBQ2xEQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBT0E7QUFHQTtBQUdBO0FBV0E7OztBQ3pDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFHQTtBQUNBO0FBU0E7QUFFQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBV0E7QUFDQTs7O0FDbkRBO0FBR0E7QUFFQTtBQUtBO0FBQ0E7QUFRQTtBQVNBO0FBRUE7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1981\n")},2220:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"a\", function() { return /* binding */ createEncoderFactory; });\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/reselect/es/index.js\nvar es = __webpack_require__(181);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/typeGuards/ChannelDef.js\nvar ChannelDef = __webpack_require__(1936);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/typeGuards/Base.js\nfunction isArray(maybeArray) {\n  return Array.isArray(maybeArray);\n}\nfunction isNotArray(maybeArray) {\n  return !Array.isArray(maybeArray);\n}\nfunction isDefined(value) {\n  return typeof value !== 'undefined' && value !== null;\n}\nfunction isEveryElementDefined(array) {\n  return array.every(isDefined);\n}\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-array/src/extent.js\nvar src_extent = __webpack_require__(290);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/types/scale/ScaleType.js\n// Modified from vega-lite\n// because vega-lite uses namespace which has issues with babel and typescript\nconst ScaleType = {\n  // Continuous - Quantitative\n  LINEAR: 'linear',\n  LOG: 'log',\n  POW: 'pow',\n  SQRT: 'sqrt',\n  SYMLOG: 'symlog',\n  // Continuous - Time\n  TIME: 'time',\n  UTC: 'utc',\n  // Discretizing scales\n  QUANTILE: 'quantile',\n  QUANTIZE: 'quantize',\n  THRESHOLD: 'threshold',\n  BIN_ORDINAL: 'bin-ordinal',\n  // Discrete scales\n  ORDINAL: 'ordinal',\n  POINT: 'point',\n  BAND: 'band'\n};\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/typeGuards/Channel.js\nfunction isX(channelType) {\n  return channelType === 'X' || channelType === 'XBand';\n}\nfunction isY(channelType) {\n  return channelType === 'Y' || channelType === 'YBand';\n}\nfunction isXOrY(channelType) {\n  return isX(channelType) || isY(channelType);\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/utils/keys.js\n/**\n * This is a stricter version of Object.keys but with better types.\n * See https://github.com/Microsoft/TypeScript/pull/12253#issuecomment-263132208\n */\nconst keys = Object.keys;\n/* harmony default export */ var utils_keys = (keys);\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/dateTimeToTimestamp.js\n// Modified from vega-lite version\n// and remove unnecessary dependency\n\n/* eslint-disable no-param-reassign */\n\n/* eslint-disable no-negated-condition */\n\n/**\n * Internal Object for defining datetime expressions.\n * This is an expression version of DateTime.\n * If both month and quarter are provided, month has higher precedence.\n * `day` cannot be combined with other date.\n */\n\nfunction invalidTimeUnit(unitName, value) {\n  return \"Invalid \" + unitName + \": \" + String(value) + \".\";\n}\n/*\n * A designated year that starts on Sunday.\n */\n\n\nconst SUNDAY_YEAR = 2006;\nconst MONTHS = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december'];\nconst SHORT_MONTHS = MONTHS.map(m => m.slice(0, 3));\nconst DAYS = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];\nconst SHORT_DAYS = DAYS.map(d => d.slice(0, 3));\n\nfunction isNumber(x) {\n  return typeof x === 'number';\n}\n/**\n * Returns whether the passed in value is a valid number.\n */\n\n\nfunction isNumeric(value) {\n  if (isNumber(value)) {\n    return true;\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  return !isNaN(value) && !isNaN(parseFloat(value));\n}\n\nfunction normalizeQuarter(q) {\n  if (isNumeric(q)) {\n    q = Number(q);\n  }\n\n  if (isNumber(q)) {\n    if (q > 4) {\n      // eslint-disable-next-line no-console\n      console.warn(invalidTimeUnit('quarter', q));\n    } // We accept 1-based quarter, so need to readjust to 0-based quarter\n\n\n    return q - 1;\n  } // Invalid quarter\n\n\n  throw new Error(invalidTimeUnit('quarter', q));\n}\nfunction normalizeMonth(m) {\n  if (isNumeric(m)) {\n    m = Number(m);\n  }\n\n  if (isNumber(m)) {\n    // We accept 1-based month, so need to readjust to 0-based month\n    return m - 1;\n  }\n\n  const lowerM = m.toLowerCase();\n  const monthIndex = MONTHS.indexOf(lowerM);\n\n  if (monthIndex !== -1) {\n    return monthIndex; // 0 for january, ...\n  }\n\n  const shortM = lowerM.slice(0, 3);\n  const shortMonthIndex = SHORT_MONTHS.indexOf(shortM);\n\n  if (shortMonthIndex !== -1) {\n    return shortMonthIndex;\n  } // Invalid month\n\n\n  throw new Error(invalidTimeUnit('month', m));\n}\nfunction normalizeDay(d) {\n  if (isNumeric(d)) {\n    d = Number(d);\n  }\n\n  if (isNumber(d)) {\n    // mod so that this can be both 0-based where 0 = sunday\n    // and 1-based where 7=sunday\n    return d % 7;\n  }\n\n  const lowerD = d.toLowerCase();\n  const dayIndex = DAYS.indexOf(lowerD);\n\n  if (dayIndex !== -1) {\n    return dayIndex; // 0 for january, ...\n  }\n\n  const shortD = lowerD.slice(0, 3);\n  const shortDayIndex = SHORT_DAYS.indexOf(shortD);\n\n  if (shortDayIndex !== -1) {\n    return shortDayIndex;\n  } // Invalid day\n\n\n  throw new Error(invalidTimeUnit('day', d));\n}\n/**\n * @param d the date.\n * @param normalize whether to normalize quarter, month, day. This should probably be true if d is a DateTime.\n * @returns array of date time parts [year, month, day, hours, minutes, seconds, milliseconds]\n */\n\nfunction dateTimeParts(d, normalize) {\n  const parts = [];\n\n  if (normalize && d.day !== undefined) {\n    if (utils_keys(d).length > 1) {\n      d = { ...d\n      };\n      delete d.day;\n    }\n  }\n\n  if (d.year !== undefined) {\n    parts.push(d.year);\n  } else if (d.day !== undefined) {\n    // Set year to 2006 for working with day since January 1 2006 is a Sunday\n    parts.push(SUNDAY_YEAR);\n  } else {\n    parts.push(0);\n  }\n\n  if (d.month !== undefined) {\n    const month = normalize ? normalizeMonth(d.month) : d.month;\n    parts.push(month);\n  } else if (d.quarter !== undefined) {\n    const quarter = normalize ? normalizeQuarter(d.quarter) : d.quarter;\n    parts.push(isNumber(quarter) ? quarter * 3 : quarter + \"*3\");\n  } else {\n    parts.push(0); // months start at zero in JS\n  }\n\n  if (d.date !== undefined) {\n    parts.push(d.date);\n  } else if (d.day !== undefined) {\n    // HACK: Day only works as a standalone unit\n    // This is only correct because we always set year to 2006 for day\n    const day = normalize ? normalizeDay(d.day) : d.day;\n    parts.push(isNumber(day) ? day + 1 : day + \"+1\");\n  } else {\n    parts.push(1); // Date starts at 1 in JS\n  }\n\n  ['hours', 'minutes', 'seconds', 'milliseconds'].forEach(timeUnit => {\n    const unit = d[timeUnit];\n    parts.push(typeof unit === 'undefined' ? 0 : unit);\n  });\n  return parts;\n}\n/**\n * @param d the date time.\n * @returns the timestamp.\n */\n\nfunction dateTimeToTimestamp(d) {\n  const parts = dateTimeParts(d, true);\n\n  if (d.utc) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return Number(new Date(Date.UTC(...parts)));\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  return Number(new Date(...parts));\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/parseDateTime.js\n\nfunction parseDateTime(dateTime) {\n  if (typeof dateTime === 'number' || typeof dateTime === 'string') {\n    return new Date(dateTime);\n  }\n\n  return new Date(dateTimeToTimestamp(dateTime));\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/utils/inferElementTypeFromUnionOfArrayTypes.js\n/**\n * Type workaround for https://github.com/Microsoft/TypeScript/issues/7294#issuecomment-465794460\n * to avoid error \"Cannot invoke an expression whose type lacks a call signature\"\n * when using array.map\n */\nfunction inferElementTypeFromUnionOfArrayTypes(array) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return array;\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/typeGuards/DateTime.js\n// eslint-disable-next-line import/prefer-default-export\nfunction isDateTime(o) {\n  return !!o && !(o instanceof Date) && typeof o !== 'string' && typeof o !== 'boolean' && typeof o !== 'number' && ('year' in o && o.year != null || 'quarter' in o && o.quarter != null || 'month' in o && o.month != null || 'date' in o && o.date != null || 'day' in o && o.day != null || 'hours' in o && o.hours != null || 'minutes' in o && o.minutes != null || 'seconds' in o && o.seconds != null || 'milliseconds' in o && o.milliseconds != null);\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/format/fallbackFormatter.js\nfunction fallbackFormatter(v) {\n  return \"\" + v;\n}\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/options/Encodable.js\nvar Encodable = __webpack_require__(1207);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/format/createFormatter.js\n\n\nfunction createFormatter({\n  formatType,\n  format,\n  formatInLocalTime\n}) {\n  if (formatType === 'time') {\n    const formatter = Encodable[\"a\" /* default */].resolveTimeFormat({\n      format,\n      formatInLocalTime\n    });\n    return value => formatter(value);\n  }\n\n  if (formatType === 'number' || typeof format !== 'undefined' && format.length > 0) {\n    const formatter = Encodable[\"a\" /* default */].resolveNumberFormat(format);\n    return value => formatter(value);\n  }\n\n  return fallbackFormatter;\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/encoders/ChannelEncoderAxis.js\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\nclass ChannelEncoderAxis_ChannelEncoderAxis {\n  constructor(channelEncoder) {\n    _defineProperty(this, \"channelEncoder\", void 0);\n\n    _defineProperty(this, \"config\", void 0);\n\n    _defineProperty(this, \"formatValue\", void 0);\n\n    this.channelEncoder = channelEncoder;\n    this.config = channelEncoder.definition.axis;\n    this.formatValue = createFormatter(this.config);\n  }\n\n  getTitle() {\n    return this.config.title;\n  }\n\n  hasTitle() {\n    const {\n      title\n    } = this.config;\n    return title !== null && typeof title !== 'undefined' && title !== '';\n  }\n\n  getTickLabels() {\n    const {\n      tickCount,\n      values\n    } = this.config;\n\n    if (typeof values !== 'undefined') {\n      return inferElementTypeFromUnionOfArrayTypes(values).map(v => this.formatValue(isDateTime(v) ? parseDateTime(v) : v));\n    }\n\n    const {\n      scale\n    } = this.channelEncoder;\n\n    if (scale && 'domain' in scale) {\n      const ticks = 'ticks' in scale ? scale.ticks(tickCount) : scale.domain();\n      return ticks.map(this.formatValue);\n    }\n\n    return [];\n  }\n\n}\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/lodash.get/index.js\nvar lodash_get = __webpack_require__(1209);\nvar lodash_get_default = /*#__PURE__*/__webpack_require__.n(lodash_get);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/createGetterFromChannelDef.js\n\n\nfunction createGetterFromChannelDef(definition) {\n  if (Object(ChannelDef[\"c\" /* isValueDef */])(definition)) {\n    return () => definition.value;\n  }\n\n  if (typeof definition.field !== 'undefined') {\n    return x => lodash_get_default()(x, definition.field);\n  }\n\n  return () => undefined;\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/utils/isDisabled.js\nfunction isDisabled(config) {\n  return config === false || config === null;\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/utils/isEnabled.js\n\nfunction isEnabled(config) {\n  return !isDisabled(config);\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/fillers/expandLabelOverlapStrategy.js\n\nconst STRATEGY_FLAT = {\n  strategy: 'flat'\n};\nconst STRATEGY_ROTATE = {\n  labelAngle: 40,\n  strategy: 'rotate'\n};\nfunction expandLabelOverlapStrategy(channelType, labelOverlap = 'auto') {\n  let output;\n\n  switch (labelOverlap) {\n    case 'flat':\n      output = STRATEGY_FLAT;\n      break;\n\n    case 'rotate':\n      output = STRATEGY_ROTATE;\n      break;\n\n    case 'auto':\n      output = isX(channelType) ? STRATEGY_ROTATE : STRATEGY_FLAT;\n      break;\n\n    default:\n      output = labelOverlap;\n      break;\n  }\n\n  return { ...output\n  };\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/scaleCategories.js\n // Grouped by domain and range\n\nconst continuousToContinuousScaleTypes = [ScaleType.LINEAR, ScaleType.POW, ScaleType.SQRT, ScaleType.SYMLOG, ScaleType.LOG, ScaleType.TIME, ScaleType.UTC];\nconst continuousToContinuousScaleTypesSet = new Set(continuousToContinuousScaleTypes);\nconst continuousToDiscreteScaleTypes = [ScaleType.QUANTILE, ScaleType.QUANTIZE, ScaleType.THRESHOLD];\nconst continuousToDiscreteScaleTypesSet = new Set(continuousToDiscreteScaleTypes); // Grouped by Domain\n\nconst continuousDomainScaleTypes = continuousToContinuousScaleTypes.concat(continuousToDiscreteScaleTypes);\nconst continuousDomainScaleTypesSet = new Set(continuousDomainScaleTypes);\nconst discreteDomainScaleTypes = [ScaleType.ORDINAL, ScaleType.BIN_ORDINAL, ScaleType.POINT, ScaleType.BAND];\nconst discreteDomainScaleTypesSet = new Set(discreteDomainScaleTypes); // Three broad categories\n\nconst continuousScaleTypes = continuousToContinuousScaleTypes;\nconst continuousScaleTypesSet = continuousToContinuousScaleTypesSet;\nconst discreteScaleTypes = [ScaleType.BAND, ScaleType.POINT, ScaleType.ORDINAL];\nconst discreteScaleTypesSet = new Set(discreteScaleTypes);\nconst discretizingScaleTypes = [ScaleType.BIN_ORDINAL, ScaleType.QUANTILE, ScaleType.QUANTIZE, ScaleType.THRESHOLD];\nconst discretizingScaleTypesSet = new Set(discretizingScaleTypes); // Others\n\nconst timeScaleTypes = [ScaleType.TIME, ScaleType.UTC];\nconst timeScaleTypesSet = new Set(timeScaleTypes);\nconst allScaleTypes = [ScaleType.LINEAR, ScaleType.LOG, ScaleType.POW, ScaleType.SQRT, ScaleType.SYMLOG, ScaleType.TIME, ScaleType.UTC, ScaleType.QUANTILE, ScaleType.QUANTIZE, ScaleType.THRESHOLD, ScaleType.BIN_ORDINAL, ScaleType.ORDINAL, ScaleType.POINT, ScaleType.BAND];\nconst allScaleTypesSet = new Set(allScaleTypes);\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/fillers/completeAxisConfig.js\n\n\n\n\n\n\nfunction isChannelDefWithAxisSupport(channelType, channelDef) {\n  return Object(ChannelDef[\"b\" /* isTypedFieldDef */])(channelDef) && isXOrY(channelType);\n}\n\nfunction completeAxisConfig(channelType, channelDef) {\n  if (isChannelDefWithAxisSupport(channelType, channelDef) && isEnabled(channelDef.axis)) {\n    const axis = channelDef.axis === true || typeof channelDef.axis === 'undefined' ? {} : channelDef.axis;\n    const isXChannel = isX(channelType);\n    const {\n      format = channelDef.format,\n      formatType = channelDef.formatType,\n      formatInLocalTime = channelDef.formatInLocalTime,\n      labelAngle = 0,\n      labelFlush,\n      labelOverlap,\n      labelPadding = 4,\n      orient = isXChannel ? 'bottom' : 'left',\n      tickCount = 5,\n      ticks = true,\n      title = channelDef.title,\n      titlePadding = 4\n    } = axis;\n    const output = { ...axis,\n      format,\n      formatType,\n      labelAngle,\n      labelFlush: typeof labelFlush === 'undefined' ? channelDef.scale && typeof channelDef.scale.type !== 'undefined' && continuousToContinuousScaleTypesSet.has(channelDef.scale.type) : labelFlush,\n      labelOverlap: expandLabelOverlapStrategy(channelType, labelOverlap),\n      labelPadding,\n      orient,\n      tickCount,\n      ticks,\n      title,\n      titlePadding\n    };\n\n    if (typeof formatInLocalTime !== 'undefined') {\n      output.formatInLocalTime = formatInLocalTime;\n    }\n\n    return output;\n  }\n\n  return false;\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/fillers/completeFormatConfig.js\nfunction completeFormatConfig(config) {\n  const {\n    formatType,\n    formatInLocalTime,\n    format,\n    type,\n    scaleType\n  } = config;\n  let resolvedFormatType;\n\n  if (typeof formatType !== 'undefined') {\n    resolvedFormatType = formatType;\n  } else if (type === 'quantitative') {\n    resolvedFormatType = 'number';\n  } else if (type === 'temporal' || scaleType === 'time' || scaleType === 'utc') {\n    resolvedFormatType = 'time';\n  } else if (typeof format !== 'undefined' && format.length > 0) {\n    resolvedFormatType = 'number';\n  }\n\n  if (resolvedFormatType === 'time') {\n    return {\n      formatType: 'time',\n      formatInLocalTime: formatInLocalTime || typeof formatInLocalTime === 'undefined' && scaleType === 'time',\n      format\n    };\n  }\n\n  return {\n    formatType: resolvedFormatType,\n    format\n  };\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/fillers/completeLegendConfig.js\n\nfunction completeLegendConfig(channelType, channelDef) {\n  if ('legend' in channelDef && channelDef.legend !== undefined) {\n    return channelDef.legend;\n  }\n\n  return isXOrY(channelType) || channelType === 'Text' ? false : {};\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/fillers/inferScaleType.js\n\n/**\n * Sometimes scale type is not specified but can be inferred\n * from other fields.\n * See https://vega.github.io/vega-lite/docs/scale.html\n * @param channelType type of the channel\n * @param fieldType type of the field\n * @param bin is value binned\n */\n\nfunction inferScaleType(channelType, fieldType, bin = false) {\n  if (fieldType === 'nominal' || fieldType === 'ordinal') {\n    switch (channelType) {\n      // For positional (x and y) ordinal and ordinal fields,\n      // \"point\" is the default scale type for all marks\n      // except bar and rect marks, which use \"band\" scales.\n      // https://vega.github.io/vega-lite/docs/scale.html\n      case 'XBand':\n      case 'YBand':\n        return ScaleType.BAND;\n\n      case 'X':\n      case 'Y':\n      case 'Numeric':\n        return ScaleType.POINT;\n\n      case 'Color':\n      case 'Category':\n        return ScaleType.ORDINAL;\n\n      default:\n    }\n  } else if (fieldType === 'quantitative') {\n    switch (channelType) {\n      case 'XBand':\n      case 'YBand':\n      case 'X':\n      case 'Y':\n      case 'Numeric':\n        return ScaleType.LINEAR;\n\n      case 'Color':\n        return bin ? ScaleType.BIN_ORDINAL : ScaleType.LINEAR;\n\n      default:\n    }\n  } else if (fieldType === 'temporal') {\n    switch (channelType) {\n      case 'XBand':\n      case 'YBand':\n      case 'X':\n      case 'Y':\n      case 'Numeric':\n        return ScaleType.UTC;\n\n      case 'Color':\n        return ScaleType.LINEAR;\n\n      default:\n    }\n  }\n\n  return undefined;\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/isPropertySupportedByScaleType.js\n\n\nconst pointOrBand = [ScaleType.POINT, ScaleType.BAND];\nconst pointOrBandSet = new Set(pointOrBand);\nconst exceptPointOrBand = allScaleTypes.filter(type => !pointOrBandSet.has(type));\nconst exceptPointOrBandSet = new Set(exceptPointOrBand);\nconst continuousOrPointOrBandSet = new Set(continuousScaleTypes.concat(pointOrBand));\nconst zeroSet = new Set(continuousDomainScaleTypes); // log scale cannot have zero value\n\nzeroSet.delete(ScaleType.LOG); // zero is not meaningful for time\n\nzeroSet.delete(ScaleType.TIME);\nzeroSet.delete(ScaleType.UTC); // threshold requires custom domain so zero does not matter\n\nzeroSet.delete(ScaleType.THRESHOLD); // quantile depends on distribution so zero does not matter\n\nzeroSet.delete(ScaleType.QUANTILE);\nconst supportedScaleTypes = {\n  align: pointOrBandSet,\n  base: new Set([ScaleType.LOG]),\n  clamp: continuousScaleTypesSet,\n  constant: new Set([ScaleType.SYMLOG]),\n  domain: allScaleTypesSet,\n  exponent: new Set([ScaleType.POW]),\n  interpolate: exceptPointOrBandSet,\n  nice: new Set(continuousScaleTypes.concat([ScaleType.QUANTIZE, ScaleType.THRESHOLD])),\n  padding: continuousOrPointOrBandSet,\n  paddingInner: new Set([ScaleType.BAND]),\n  paddingOuter: pointOrBandSet,\n  range: allScaleTypesSet,\n  reverse: allScaleTypesSet,\n  round: continuousOrPointOrBandSet,\n  scheme: exceptPointOrBandSet,\n  type: allScaleTypesSet,\n  unknown: new Set([ScaleType.ORDINAL]),\n  zero: zeroSet\n};\nfunction isPropertySupportedByScaleType(property, scaleType) {\n  return supportedScaleTypes[property].has(scaleType);\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/typeGuards/ScaleConfig.js\n\n\nfunction isContinuousScaleConfig(config) {\n  return continuousScaleTypesSet.has(config.type);\n}\nfunction isDiscretizingScaleConfig(config) {\n  return discretizingScaleTypesSet.has(config.type);\n}\nfunction isDiscreteScaleConfig(config) {\n  return discreteScaleTypesSet.has(config.type);\n}\nfunction isScaleConfigWithZero(config) {\n  return isPropertySupportedByScaleType('zero', config.type);\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/fillers/completeScaleConfig.js\n\n\n\n\n\nfunction completeScaleConfig(channelType, channelDef) {\n  if (Object(ChannelDef[\"b\" /* isTypedFieldDef */])(channelDef) && isEnabled(channelDef.scale)) {\n    const {\n      scale = {},\n      type,\n      bin\n    } = channelDef;\n    const {\n      type: scaleType = inferScaleType(channelType, type, bin)\n    } = scale;\n\n    if (typeof scaleType === 'undefined') {\n      return false;\n    } // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n\n\n    const filledScale = { ...scale,\n      type: scaleType\n    };\n\n    if (isContinuousScaleConfig(filledScale)) {\n      if (typeof filledScale.nice === 'undefined') {\n        filledScale.nice = !timeScaleTypesSet.has(scaleType);\n      }\n\n      if (typeof filledScale.clamp === 'undefined') {\n        filledScale.clamp = true;\n      }\n    }\n\n    if (isScaleConfigWithZero(filledScale) && typeof filledScale.zero === 'undefined') {\n      filledScale.zero = true;\n    }\n\n    return filledScale;\n  }\n\n  return false;\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/fillers/inferFieldType.js\n\nconst temporalFieldNames = new Set(['time', 'date', 'datetime', 'timestamp']);\nfunction inferFieldType(channelType, field = '') {\n  if (isXOrY(channelType) || channelType === 'Numeric') {\n    return temporalFieldNames.has(field.toLowerCase()) ? 'temporal' : 'quantitative';\n  }\n\n  return 'nominal';\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/fillers/completeChannelDef.js\n\n\n\n\n\n\nfunction completeChannelDef(channelType, channelDef) {\n  var _channelDef$title;\n\n  if (Object(ChannelDef[\"c\" /* isValueDef */])(channelDef)) {\n    return { ...channelDef,\n      axis: false,\n      legend: false,\n      scale: false,\n      title: ''\n    };\n  } // Fill top-level properties\n\n\n  const copy = { ...channelDef,\n    title: Object(ChannelDef[\"a\" /* isFieldDef */])(channelDef) ? (_channelDef$title = channelDef.title) != null ? _channelDef$title : channelDef.field : '',\n    type: Object(ChannelDef[\"b\" /* isTypedFieldDef */])(channelDef) ? channelDef.type : inferFieldType(channelType, channelDef.field)\n  }; // Scale needs the top-level properties to be filled.\n\n  const scale = completeScaleConfig(channelType, copy); // Format needs scale.\n\n  const format = completeFormatConfig({ ...channelDef,\n    scaleType: scale ? scale.type : undefined\n  });\n  const copy2 = { ...copy,\n    ...format,\n    scale\n  }; // These need scale and format\n\n  const axis = completeAxisConfig(channelType, copy2);\n  const legend = completeLegendConfig(channelType, copy2);\n  return { ...copy2,\n    axis,\n    legend\n  };\n}\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-scale/src/linear.js\nvar linear = __webpack_require__(73);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-scale/src/log.js\nvar log = __webpack_require__(272);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-scale/src/pow.js\nvar pow = __webpack_require__(219);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-scale/src/time.js + 3 modules\nvar time = __webpack_require__(449);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-scale/src/utcTime.js + 3 modules\nvar utcTime = __webpack_require__(1113);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-scale/src/quantile.js\nvar quantile = __webpack_require__(1002);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-scale/src/quantize.js\nvar quantize = __webpack_require__(1003);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-scale/src/threshold.js\nvar threshold = __webpack_require__(1004);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-scale/src/ordinal.js\nvar ordinal = __webpack_require__(340);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-scale/src/band.js + 1 modules\nvar band = __webpack_require__(610);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-scale/src/symlog.js\nvar symlog = __webpack_require__(273);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/createScaleFromScaleType.js\n\n\nfunction createScaleFromScaleType(type) {\n  switch (type) {\n    case ScaleType.LINEAR:\n      return Object(linear[\"a\" /* default */])();\n\n    case ScaleType.LOG:\n      return Object(log[\"a\" /* default */])();\n\n    case ScaleType.POW:\n      return Object(pow[\"a\" /* default */])();\n\n    case ScaleType.SQRT:\n      return Object(pow[\"c\" /* sqrt */])();\n\n    case ScaleType.TIME:\n      return Object(time[\"b\" /* default */])();\n\n    case ScaleType.UTC:\n      return Object(utcTime[\"a\" /* default */])();\n\n    case ScaleType.QUANTILE:\n      return Object(quantile[\"a\" /* default */])();\n\n    case ScaleType.QUANTIZE:\n      return Object(quantize[\"a\" /* default */])();\n\n    case ScaleType.THRESHOLD:\n      return Object(threshold[\"a\" /* default */])();\n\n    case ScaleType.ORDINAL:\n      return Object(ordinal[\"a\" /* default */])();\n\n    case ScaleType.POINT:\n      return Object(band[\"b\" /* point */])();\n\n    case ScaleType.BAND:\n      return Object(band[\"a\" /* default */])();\n\n    case ScaleType.SYMLOG:\n      return Object(symlog[\"a\" /* default */])();\n\n    case ScaleType.BIN_ORDINAL:\n      // TODO: Pending scale.bins implementation\n      throw new Error(\"\\\"type = \" + type + \"\\\" is not supported yet.\");\n\n    default:\n      return Object(linear[\"a\" /* default */])();\n  }\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/applyAlign.js\nfunction applyAlign(config, scale) {\n  if ('align' in config && typeof config.align !== 'undefined' && 'align' in scale) {\n    scale.align(config.align);\n  }\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/applyBase.js\nfunction applyBase(config, scale) {\n  if ('base' in config && typeof config.base !== 'undefined' && 'base' in scale) {\n    scale.base(config.base);\n  }\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/applyClamp.js\nfunction applyClamp(config, scale) {\n  if ('clamp' in config && config.clamp === true && 'clamp' in scale) {\n    scale.clamp(config.clamp);\n  }\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/applyExponent.js\nfunction applyExponent(config, scale) {\n  if ('exponent' in config && typeof config.exponent !== 'undefined' && 'exponent' in scale) {\n    scale.exponent(config.exponent);\n  }\n}\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-time/src/day.js\nvar day = __webpack_require__(593);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-time/src/hour.js\nvar hour = __webpack_require__(592);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-time/src/minute.js\nvar minute = __webpack_require__(591);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-time/src/month.js\nvar month = __webpack_require__(594);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-time/src/second.js\nvar second = __webpack_require__(339);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-time/src/week.js\nvar week = __webpack_require__(81);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-time/src/year.js\nvar year = __webpack_require__(595);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-time/src/utcDay.js\nvar utcDay = __webpack_require__(598);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-time/src/utcHour.js\nvar utcHour = __webpack_require__(597);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-time/src/utcMinute.js\nvar utcMinute = __webpack_require__(596);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-time/src/utcMonth.js\nvar utcMonth = __webpack_require__(599);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-time/src/utcWeek.js\nvar utcWeek = __webpack_require__(82);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-time/src/utcYear.js\nvar utcYear = __webpack_require__(600);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/applyNice.js\n\n\nconst localTimeIntervals = {\n  day: day[\"b\" /* default */],\n  hour: hour[\"a\" /* default */],\n  minute: minute[\"a\" /* default */],\n  month: month[\"a\" /* default */],\n  second: second[\"a\" /* default */],\n  week: week[\"g\" /* sunday */],\n  year: year[\"a\" /* default */]\n};\nconst utcIntervals = {\n  day: utcDay[\"a\" /* default */],\n  hour: utcHour[\"a\" /* default */],\n  minute: utcMinute[\"a\" /* default */],\n  month: utcMonth[\"a\" /* default */],\n  second: second[\"a\" /* default */],\n  week: utcWeek[\"g\" /* utcSunday */],\n  year: utcYear[\"a\" /* default */]\n};\nfunction applyNice(config, scale) {\n  if ('nice' in config && typeof config.nice !== 'undefined' && 'nice' in scale) {\n    const {\n      nice\n    } = config;\n\n    if (typeof nice === 'boolean') {\n      if (nice) {\n        scale.nice();\n      }\n    } else if (typeof nice === 'number') {\n      scale.nice(nice);\n    } else {\n      const timeScale = scale;\n      const {\n        type\n      } = config;\n\n      if (typeof nice === 'string') {\n        timeScale.nice(type === ScaleType.UTC ? utcIntervals[nice] : localTimeIntervals[nice]);\n      } else {\n        const {\n          interval,\n          step\n        } = nice;\n        const parsedInterval = (type === ScaleType.UTC ? utcIntervals[interval] : localTimeIntervals[interval]).every(step);\n\n        if (parsedInterval !== null) {\n          timeScale.nice(parsedInterval);\n        }\n      }\n    }\n  }\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/typeGuards/Scale.js\n\nfunction isContinuousScale(scale, scaleType) {\n  return scale && continuousScaleTypesSet.has(scaleType);\n}\nfunction isDiscretizingScale(scale, scaleType) {\n  return scale && discretizingScaleTypesSet.has(scaleType);\n}\nfunction isDiscreteScale(scale, scaleType) {\n  return scale && discreteScaleTypesSet.has(scaleType);\n}\nfunction isTimeScale(scale, scaleType) {\n  return scale && timeScaleTypesSet.has(scaleType);\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/applyZero.js\n\nfunction applyZero(config, scale) {\n  if ('zero' in config && config.zero === true && isContinuousScale(scale, config.type)) {\n    const domain = scale.domain();\n    const [a, b] = domain;\n    const isDescending = b < a;\n    const [min, max] = isDescending ? [b, a] : [a, b];\n    const domainWithZero = [Math.min(0, min), Math.max(0, max)];\n    scale.domain(isDescending ? domainWithZero.reverse() : domainWithZero);\n  }\n}\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-interpolate/src/lab.js\nvar lab = __webpack_require__(1110);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-interpolate/src/hcl.js\nvar hcl = __webpack_require__(602);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-interpolate/src/hsl.js\nvar hsl = __webpack_require__(601);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-interpolate/src/cubehelix.js + 1 modules\nvar cubehelix = __webpack_require__(611);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-interpolate/src/rgb.js\nvar rgb = __webpack_require__(221);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/createColorInterpolator.js\n\nconst interpolatorMap = {\n  lab: lab[\"a\" /* default */],\n  hcl: hcl[\"a\" /* default */],\n  'hcl-long': hcl[\"b\" /* hclLong */],\n  hsl: hsl[\"a\" /* default */],\n  'hsl-long': hsl[\"b\" /* hslLong */],\n  cubehelix: cubehelix[\"b\" /* default */],\n  'cubehelix-long': cubehelix[\"a\" /* cubehelixLong */],\n  rgb: rgb[\"a\" /* default */]\n};\nfunction createColorInterpolator(interpolate) {\n  switch (interpolate) {\n    case 'lab':\n    case 'hcl':\n    case 'hcl-long':\n    case 'hsl':\n    case 'hsl-long':\n    case 'cubehelix':\n    case 'cubehelix-long':\n    case 'rgb':\n      return interpolatorMap[interpolate];\n\n    default:\n  }\n\n  const {\n    type,\n    gamma\n  } = interpolate;\n  const interpolator = interpolatorMap[type];\n  return typeof gamma === 'undefined' ? interpolator : interpolator.gamma(gamma);\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/applyInterpolate.js\n\nfunction applyInterpolate(config, scale) {\n  if ('interpolate' in config && typeof config.interpolate !== 'undefined' && 'interpolate' in scale) {\n    scale.interpolate(createColorInterpolator(config.interpolate));\n  }\n}\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/node_modules/d3-interpolate/src/round.js\nvar round = __webpack_require__(1109);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/applyRound.js\n\nfunction applyRound(config, scale) {\n  if ('round' in config && config.round === true) {\n    const roundableScale = scale;\n\n    if ('round' in roundableScale) {\n      roundableScale.round(config.round);\n    } else {\n      roundableScale.interpolate(round[\"a\" /* default */]);\n    }\n  }\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/domain/parseContinuousDomain.js\n\n/**\n * Convert each element in the array into\n * - Date (for time scales)\n * - number (for other continuous scales)\n * @param domain\n * @param scaleType\n */\n\nfunction parseContinuousDomain(domain, scaleType) {\n  if (timeScaleTypesSet.has(scaleType)) {\n    return domain.filter(d => typeof d !== 'boolean').map(d => typeof d === 'string' || typeof d === 'number' ? new Date(d) : d);\n  }\n\n  return domain.map(d => typeof d === 'string' || typeof d === 'boolean' ? Number(d) : d);\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/domain/parseDiscreteDomain.js\n/**\n * Discrete domains are converted into string[]\n * when using D3 scales\n * @param domain\n */\nfunction parseDiscreteDomain(domain) {\n  return domain.map(d => \"\" + d);\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/utils/combineCategories.js\n/**\n * Combine two arrays into a unique list\n * by keeping the order the fixedCategories\n * and append new categories at the end.\n * @param fixedCategories\n * @param inputCategories\n */\nfunction combineCategories(fixedCategories, inputCategories = []) {\n  if (fixedCategories.length === 0) {\n    return inputCategories;\n  }\n\n  const fixedSet = new Set(fixedCategories);\n  return fixedCategories.concat(inputCategories.filter(d => !fixedSet.has(d)));\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/utils/combineContinuousDomains.js\n\n/**\n * Combine two continuous domain and ensure that the output\n * does not go beyond fixedDomain\n * @param bounds\n * @param dataDomain\n */\n\nfunction combineContinuousDomains(bounds, dataDomain) {\n  if (bounds.length > 0 && isEveryElementDefined(bounds)) {\n    return bounds;\n  }\n\n  if (bounds.length === 2 && dataDomain.length === 2 && bounds.filter(isDefined).length > 0) {\n    const [boundMin, boundMax] = bounds;\n    const [dataMin, dataMax] = dataDomain;\n    let min = dataMin;\n\n    if (isDefined(boundMin)) {\n      min = boundMin.valueOf() > dataMin.valueOf() ? boundMin : dataMin;\n    }\n\n    let max = dataMax;\n\n    if (isDefined(boundMax)) {\n      max = boundMax.valueOf() < dataMax.valueOf() ? boundMax : dataMax;\n    }\n\n    return [min, max];\n  }\n\n  return dataDomain;\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/utils/removeUndefinedAndNull.js\nfunction removeUndefinedAndNull(array) {\n  return array.filter(x => typeof x !== 'undefined' && x !== null);\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/parseDateTimeIn.js\n\n\n/**\n * Only parse elements that are DateTime to Date.\n * Leave the rest alone.\n * @param array\n */\n\nfunction parseDateTimeIn(array) {\n  return array.map(d => !(d instanceof Date) && isDateTime(d) ? parseDateTime(d) : d);\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/applyDomain.js\n\n\n\n\n\n\n\n\n\nfunction createOrderFunction(reverse) {\n  return reverse ? array => array.concat().reverse() : array => array;\n}\n\nfunction isCompleteDomain(domain) {\n  return domain.length !== 2 || domain[0] != null && domain[1] != null;\n}\n\nfunction applyDomain(config, scale,\n/** domain from dataset */\ndataDomain) {\n  const {\n    reverse,\n    type\n  } = config;\n  const order = createOrderFunction(reverse);\n\n  if (isContinuousScale(scale, type) && isContinuousScaleConfig(config) || isDiscretizingScale(scale, type) && isDiscretizingScaleConfig(config)) {\n    // For continuous and discretizing scales\n    if (config.domain) {\n      // If config.domain is specified\n      if (isCompleteDomain(config.domain)) {\n        // If the config.domain is completed\n        // ignores the dataDomain\n        scale.domain(order(parseDateTimeIn(config.domain)));\n      } else if (dataDomain) {\n        // If it is incompleted, then try to combine\n        // with the dataDomain\n        scale.domain(order(combineContinuousDomains(parseContinuousDomain(parseDateTimeIn(config.domain), type), parseContinuousDomain(removeUndefinedAndNull(dataDomain), type))));\n      }\n    } else if (dataDomain) {\n      // If no config.domain then just use the dataDomain if any\n      scale.domain(order(parseContinuousDomain(removeUndefinedAndNull(dataDomain), type)));\n    }\n  } else if (isDiscreteScale(scale, type) && isDiscreteScaleConfig(config)) {\n    // For discrete scales\n    if (config.domain) {\n      const fixedDomain = parseDiscreteDomain(parseDateTimeIn(config.domain));\n      scale.domain(order(dataDomain ? combineCategories(fixedDomain, parseDiscreteDomain(dataDomain)) : fixedDomain));\n    } else if (dataDomain) {\n      // If no config.domain then just use the dataDomain if any\n      scale.domain(order(parseDiscreteDomain(dataDomain)));\n    }\n  }\n}\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@encodable/color/esm/scheme/wrappers/wrapColorScheme.js + 21 modules\nvar wrapColorScheme = __webpack_require__(446);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/typeGuards/SchemeParams.js\n// eslint-disable-next-line import/prefer-default-export\nfunction isSchemeParams(scheme) {\n  return Object.prototype.toString.call(scheme) !== '[object String]';\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/applyRange.js\n\n\n\n\nfunction applyRange(config, scale) {\n  const {\n    range,\n    domain\n  } = config;\n\n  if (typeof range === 'undefined') {\n    if ('scheme' in config && typeof config.scheme !== 'undefined') {\n      const {\n        scheme\n      } = config;\n      let name;\n      let count;\n\n      if (isContinuousScaleConfig(config) && domain) {\n        count = domain.length;\n      }\n\n      let extent;\n\n      if (isSchemeParams(scheme)) {\n        name = scheme.name;\n\n        if (scheme.count) {\n          count = scheme.count;\n        }\n\n        extent = scheme.extent;\n      } else {\n        name = scheme;\n      }\n\n      const schemeObject = Encodable[\"a\" /* default */].resolveColorScheme({\n        name,\n        type: 'sequential'\n      });\n\n      if (typeof schemeObject !== 'undefined' && schemeObject.type === 'sequential') {\n        const wrappedScheme = Object(wrapColorScheme[\"a\" /* default */])(schemeObject);\n        scale.range(wrappedScheme.getColors(count, extent));\n      }\n    }\n  } else {\n    // TODO: add type guard should fix this problem\n    // @ts-ignore\n    scale.range(range);\n  }\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/applyPadding.js\nfunction applyPadding(config, scale) {\n  if ('padding' in config && typeof config.padding !== 'undefined' && 'padding' in scale) {\n    scale.padding(config.padding);\n  }\n\n  if ('paddingInner' in config && typeof config.paddingInner !== 'undefined' && 'paddingInner' in scale) {\n    scale.paddingInner(config.paddingInner);\n  }\n\n  if ('paddingOuter' in config && typeof config.paddingOuter !== 'undefined' && 'paddingOuter' in scale) {\n    scale.paddingOuter(config.paddingOuter);\n  }\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/updateScale.js\n\n\n\n\n\n\n\n\n\n\n\nfunction updateScale(scale, config) {\n  // domain and range apply to all scales\n  applyDomain(config, scale);\n  applyRange(config, scale); // Sort other properties alphabetically.\n\n  applyAlign(config, scale);\n  applyBase(config, scale);\n  applyClamp(config, scale);\n  applyExponent(config, scale);\n  applyInterpolate(config, scale); // Nice depends on domain.\n\n  applyNice(config, scale);\n  applyPadding(config, scale);\n  applyRound(config, scale); // Zero depends on domain and nice.\n\n  applyZero(config, scale);\n  return scale;\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/parsers/scale/createScale.js\n\n\n\n\n\n\n\nfunction createScale(config) {\n  const {\n    range\n  } = config; // Handle categorical color scales\n  // An ordinal scale without specified range\n  // is assumed to be a color scale.\n\n  if (config.type === ScaleType.ORDINAL && typeof range === 'undefined') {\n    const scheme = 'scheme' in config ? config.scheme : undefined;\n    const resolve = Encodable[\"a\" /* default */].getCategoricalColorScaleResolver();\n    let colorScale;\n\n    if (typeof scheme === 'undefined') {\n      colorScale = resolve({});\n    } else if (isSchemeParams(scheme)) {\n      colorScale = resolve(scheme);\n    } else {\n      colorScale = resolve({\n        name: scheme\n      });\n    }\n\n    const castedColorScale = colorScale;\n    applyDomain(config, castedColorScale);\n    return castedColorScale;\n  }\n\n  const scale = createScaleFromScaleType(config.type);\n  return updateScale(scale, config);\n}\n\n/* harmony default export */ var scale_createScale = (createScale);\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/utils/identity.js\nfunction identity(x) {\n  return x;\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/typeGuards/CompleteChannelDef.js\nfunction isCompleteValueDef(def) {\n  return 'value' in def;\n}\nfunction isCompleteFieldDef(def) {\n  return 'field' in def;\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/encoders/ChannelEncoder.js\nfunction ChannelEncoder_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass ChannelEncoder_ChannelEncoder {\n  constructor({\n    name,\n    channelType,\n    definition: originalDefinition\n  }) {\n    ChannelEncoder_defineProperty(this, \"name\", void 0);\n\n    ChannelEncoder_defineProperty(this, \"channelType\", void 0);\n\n    ChannelEncoder_defineProperty(this, \"originalDefinition\", void 0);\n\n    ChannelEncoder_defineProperty(this, \"definition\", void 0);\n\n    ChannelEncoder_defineProperty(this, \"scale\", void 0);\n\n    ChannelEncoder_defineProperty(this, \"axis\", void 0);\n\n    ChannelEncoder_defineProperty(this, \"getValue\", void 0);\n\n    ChannelEncoder_defineProperty(this, \"encodeFunc\", void 0);\n\n    ChannelEncoder_defineProperty(this, \"formatValue\", void 0);\n\n    ChannelEncoder_defineProperty(this, \"encodeValue\", (value, otherwise) => {\n      if (typeof otherwise !== 'undefined' && (value === null || typeof value === 'undefined')) {\n        return otherwise;\n      } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n      return this.encodeFunc(value);\n    });\n\n    ChannelEncoder_defineProperty(this, \"encodeDatum\", (datum, otherwise) => typeof otherwise === 'undefined' ? this.encodeValue(this.getValueFromDatum(datum)) : this.encodeValue(this.getValueFromDatum(datum), otherwise));\n\n    ChannelEncoder_defineProperty(this, \"formatDatum\", datum => this.formatValue(this.getValueFromDatum(datum)));\n\n    ChannelEncoder_defineProperty(this, \"getValueFromDatum\", (datum, otherwise) => {\n      const value = this.getValue(datum);\n      return otherwise !== undefined && (value === null || value === undefined) ? otherwise : value;\n    });\n\n    ChannelEncoder_defineProperty(this, \"getDomainFromDataset\", data => {\n      if (Object(ChannelDef[\"c\" /* isValueDef */])(this.definition)) {\n        const {\n          value\n        } = this.definition;\n        return [value];\n      }\n\n      const {\n        type\n      } = this.definition;\n\n      if (type === 'nominal' || type === 'ordinal') {\n        return Array.from(new Set(data.map(d => this.getValueFromDatum(d))));\n      }\n\n      if (type === 'quantitative') {\n        // Quantile scale needs all items\n        // because it treats domain as a discrete set of sample values\n        // for computing the quantiles\n        if (this.definition.scale && this.definition.scale.type === 'quantile') {\n          return data.map(d => this.getValueFromDatum(d));\n        }\n\n        const extent = Object(src_extent[\"a\" /* default */])(data, d => this.getValueFromDatum(d));\n        return typeof extent[0] === 'undefined' ? [0, 1] : extent;\n      }\n\n      if (type === 'temporal') {\n        const extent = Object(src_extent[\"a\" /* default */])(data, d => this.getValueFromDatum(d));\n        return typeof extent[0] === 'undefined' ? [0, 1] : extent;\n      }\n\n      return [];\n    });\n\n    this.name = name;\n    this.channelType = channelType;\n    this.originalDefinition = originalDefinition;\n    this.definition = completeChannelDef(this.channelType, originalDefinition);\n    this.getValue = createGetterFromChannelDef(this.definition);\n    this.formatValue = Object(ChannelDef[\"a\" /* isFieldDef */])(this.definition) ? createFormatter(this.definition) : fallbackFormatter;\n\n    if (this.definition.scale) {\n      const scale = scale_createScale(this.definition.scale); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n      this.encodeFunc = value => scale(value);\n\n      this.scale = scale;\n    } else {\n      const {\n        definition\n      } = this;\n      this.encodeFunc = isCompleteValueDef(definition) ? () => definition.value : identity;\n    }\n\n    if (this.definition.axis) {\n      this.axis = new ChannelEncoderAxis_ChannelEncoderAxis(this);\n    }\n  }\n\n  getDomain() {\n    if (this.scale && 'domain' in this.scale) {\n      return this.scale.domain();\n    }\n\n    return [];\n  }\n\n  setDomain(domain) {\n    if (this.definition.scale !== false && this.scale && !this.hasCategoricalColorScale() && 'domain' in this.scale) {\n      const config = this.definition.scale;\n      applyDomain(config, this.scale, domain);\n      applyRange(config, this.scale);\n      applyZero(config, this.scale);\n      applyNice(config, this.scale);\n    }\n\n    return this;\n  }\n\n  setDomainFromDataset(data) {\n    return this.scale && 'domain' in this.scale ? this.setDomain(this.getDomainFromDataset(data)) : this;\n  }\n\n  getTitle() {\n    return this.definition.title;\n  }\n\n  isGroupBy() {\n    if (Object(ChannelDef[\"b\" /* isTypedFieldDef */])(this.definition)) {\n      const {\n        type\n      } = this.definition;\n      return this.channelType === 'Category' || this.channelType === 'Text' || this.channelType === 'Color' && (type === 'nominal' || type === 'ordinal') || isXOrY(this.channelType) && (type === 'nominal' || type === 'ordinal');\n    }\n\n    return false;\n  }\n\n  isX() {\n    return isX(this.channelType);\n  }\n\n  isXOrY() {\n    return isXOrY(this.channelType);\n  }\n\n  isY() {\n    return isY(this.channelType);\n  }\n\n  hasCategoricalColorScale() {\n    const config = this.definition.scale; // Scale type is ordinal with not given range\n    // (may have optional scheme)\n    // will become a categorical scale\n    // of named color scheme.\n    // A color scale from named color scheme may be shared among multiple components\n    // in the same namespace by default, so changing its domain affect all components.\n    // (Sounds like a bad idea.)\n    // This function is currently only being used to check\n    // whether to apply domain from dataset or not.\n    // An ordinal scale with user-specified color scheme as range array\n    // will return false from this function and be excluded from it.\n\n    return this.scale && config && config.type === ScaleType.ORDINAL && typeof config.range === 'undefined';\n  }\n\n  hasLegend() {\n    return this.definition.legend !== false;\n  }\n\n  hasValueDefinition() {\n    return isCompleteValueDef(this.definition);\n  }\n\n  hasFieldDefinition() {\n    return isCompleteFieldDef(this.definition);\n  }\n\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/encoders/Encoder.js\nfunction Encoder_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\nclass Encoder_Encoder {\n  constructor({\n    channelTypes,\n    encoding\n  }) {\n    Encoder_defineProperty(this, \"encoding\", void 0);\n\n    Encoder_defineProperty(this, \"channelTypes\", void 0);\n\n    Encoder_defineProperty(this, \"channels\", void 0);\n\n    Encoder_defineProperty(this, \"legends\", void 0);\n\n    this.channelTypes = channelTypes;\n    this.encoding = encoding;\n    const channelNames = this.getChannelNames(); // Create channel encoders\n\n    const channels = {};\n    channelNames.forEach(name => {\n      const channelEncoding = encoding[name];\n\n      if (Array.isArray(channelEncoding)) {\n        const definitions = channelEncoding;\n        channels[name] = definitions.map((definition, i) => new ChannelEncoder_ChannelEncoder({\n          channelType: channelTypes[name],\n          definition,\n          name: name + \"[\" + i + \"]\"\n        }));\n      } else {\n        const definition = channelEncoding;\n        channels[name] = new ChannelEncoder_ChannelEncoder({\n          channelType: channelTypes[name],\n          definition,\n          name: name\n        });\n      }\n    });\n    this.channels = channels; // Group the channels that use the same field together\n    // so they can share the same legend.\n\n    this.legends = {};\n    channelNames.map(name => this.channels[name]).forEach(c => {\n      if (isNotArray(c) && c.hasLegend() && Object(ChannelDef[\"b\" /* isTypedFieldDef */])(c.definition)) {\n        const {\n          field\n        } = c.definition;\n        const channelEncoder = c;\n\n        if (this.legends[field]) {\n          this.legends[field].push(channelEncoder);\n        } else {\n          this.legends[field] = [channelEncoder];\n        }\n      }\n    });\n  }\n\n  getChannelNames() {\n    return Object.keys(this.channelTypes);\n  }\n\n  getChannelEncoders() {\n    return this.getChannelNames().flatMap(name => this.channels[name]);\n  }\n\n  getGroupBys() {\n    const fields = this.getChannelEncoders().filter(c => c.isGroupBy()).map(c => c.definition.field);\n    return Array.from(new Set(fields));\n  }\n\n  createLegendItemsFactory(field) {\n    const channelEncoders = this.getChannelEncoders().filter(e => isNotArray(e) && Object(ChannelDef[\"c\" /* isValueDef */])(e.definition)).flat().concat(this.legends[field]);\n    return domain => domain.map(input => ({\n      input,\n      output: channelEncoders.reduce((prev, curr) => {\n        const map = prev;\n        map[curr.name] = curr.encodeValue(input);\n        return map;\n      }, {})\n    }));\n  }\n\n  getLegendInformation(data = []) {\n    return Object.keys(this.legends) // for each field that was encoded\n    .map(field => {\n      // get all the channels that use this field\n      const channelEncoders = this.legends[field];\n      const firstEncoder = channelEncoders[0];\n      const definition = firstEncoder.definition;\n      const createLegendItems = this.createLegendItemsFactory(field);\n\n      if (definition.type === 'nominal') {\n        return {\n          channelEncoders,\n          createLegendItems,\n          field,\n          items: createLegendItems(firstEncoder.getDomainFromDataset(data)),\n          type: definition.type\n        };\n      }\n\n      return {\n        channelEncoders,\n        createLegendItems,\n        field,\n        type: definition.type\n      };\n    });\n  }\n\n  setDomainFromDataset(data) {\n    this.getChannelEncoders().forEach(channelEncoder => {\n      channelEncoder.setDomainFromDataset(data);\n    });\n    return this;\n  }\n\n  hasLegend() {\n    return Object.keys(this.legends).length > 0;\n  }\n\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/utils/mergeEncoding.js\nfunction mergeEncoding(defaultEncoding, encoding) {\n  return { ...defaultEncoding,\n    ...encoding\n  };\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/encoders/createEncoderFactory.js\n\n\n\nfunction createEncoderFactory(params) {\n  const {\n    channelTypes\n  } = params;\n  const completeEncoding = 'defaultEncoding' in params ? encoding => mergeEncoding(params.defaultEncoding, encoding) : params.completeEncoding;\n\n  const create = (encoding = {}) => new Encoder_Encoder({\n    channelTypes,\n    encoding: completeEncoding(encoding)\n  });\n\n  return {\n    channelTypes,\n    create,\n    createSelector: () => Object(es[\"createSelector\"])(encoding => encoding, create),\n    DEFAULT_ENCODING: completeEncoding({})\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIyMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vdHlwZUd1YXJkcy9CYXNlLmpzP2RmNzUiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS90eXBlcy9zY2FsZS9TY2FsZVR5cGUuanM/OTliMiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL3R5cGVHdWFyZHMvQ2hhbm5lbC5qcz9lODZiIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vdXRpbHMva2V5cy5qcz85YjY4Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vcGFyc2Vycy9kYXRlVGltZVRvVGltZXN0YW1wLmpzP2M3YWUiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS9wYXJzZXJzL3BhcnNlRGF0ZVRpbWUuanM/NmQyNyIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL3V0aWxzL2luZmVyRWxlbWVudFR5cGVGcm9tVW5pb25PZkFycmF5VHlwZXMuanM/MzhhMCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL3R5cGVHdWFyZHMvRGF0ZVRpbWUuanM/NDM0YiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL3BhcnNlcnMvZm9ybWF0L2ZhbGxiYWNrRm9ybWF0dGVyLmpzPzgzMDEiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS9wYXJzZXJzL2Zvcm1hdC9jcmVhdGVGb3JtYXR0ZXIuanM/NDIyNSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL2VuY29kZXJzL0NoYW5uZWxFbmNvZGVyQXhpcy5qcz8zZjA4Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vcGFyc2Vycy9jcmVhdGVHZXR0ZXJGcm9tQ2hhbm5lbERlZi5qcz8zM2JmIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vdXRpbHMvaXNEaXNhYmxlZC5qcz8yMGQzIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vdXRpbHMvaXNFbmFibGVkLmpzPzk0ZTgiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS9maWxsZXJzL2V4cGFuZExhYmVsT3ZlcmxhcFN0cmF0ZWd5LmpzP2Y1ODEiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS9wYXJzZXJzL3NjYWxlL3NjYWxlQ2F0ZWdvcmllcy5qcz82YWY5Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vZmlsbGVycy9jb21wbGV0ZUF4aXNDb25maWcuanM/ODU0ZiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL2ZpbGxlcnMvY29tcGxldGVGb3JtYXRDb25maWcuanM/NDQ3NyIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL2ZpbGxlcnMvY29tcGxldGVMZWdlbmRDb25maWcuanM/MWY2OCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL2ZpbGxlcnMvaW5mZXJTY2FsZVR5cGUuanM/NzY1MCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL3BhcnNlcnMvc2NhbGUvaXNQcm9wZXJ0eVN1cHBvcnRlZEJ5U2NhbGVUeXBlLmpzP2VhZTIiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS90eXBlR3VhcmRzL1NjYWxlQ29uZmlnLmpzP2U1MmUiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS9maWxsZXJzL2NvbXBsZXRlU2NhbGVDb25maWcuanM/NWI0MCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL2ZpbGxlcnMvaW5mZXJGaWVsZFR5cGUuanM/Nzg2OCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL2ZpbGxlcnMvY29tcGxldGVDaGFubmVsRGVmLmpzPzA5YzUiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS9wYXJzZXJzL3NjYWxlL2NyZWF0ZVNjYWxlRnJvbVNjYWxlVHlwZS5qcz9mNmNmIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vcGFyc2Vycy9zY2FsZS9hcHBseUFsaWduLmpzP2EwODEiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS9wYXJzZXJzL3NjYWxlL2FwcGx5QmFzZS5qcz9lMTgxIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vcGFyc2Vycy9zY2FsZS9hcHBseUNsYW1wLmpzPzQyYWIiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS9wYXJzZXJzL3NjYWxlL2FwcGx5RXhwb25lbnQuanM/MDQwYSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL3BhcnNlcnMvc2NhbGUvYXBwbHlOaWNlLmpzPzUxMDEiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS90eXBlR3VhcmRzL1NjYWxlLmpzP2FlYmMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS9wYXJzZXJzL3NjYWxlL2FwcGx5WmVyby5qcz8xN2I1Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vcGFyc2Vycy9zY2FsZS9jcmVhdGVDb2xvckludGVycG9sYXRvci5qcz83OGY4Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vcGFyc2Vycy9zY2FsZS9hcHBseUludGVycG9sYXRlLmpzPzQ1MzUiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS9wYXJzZXJzL3NjYWxlL2FwcGx5Um91bmQuanM/NDAxZCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL3BhcnNlcnMvZG9tYWluL3BhcnNlQ29udGludW91c0RvbWFpbi5qcz9mOWFhIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vcGFyc2Vycy9kb21haW4vcGFyc2VEaXNjcmV0ZURvbWFpbi5qcz82NDc3Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vdXRpbHMvY29tYmluZUNhdGVnb3JpZXMuanM/NGUxZSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL3V0aWxzL2NvbWJpbmVDb250aW51b3VzRG9tYWlucy5qcz9kYWU3Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vdXRpbHMvcmVtb3ZlVW5kZWZpbmVkQW5kTnVsbC5qcz80OTRmIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vcGFyc2Vycy9wYXJzZURhdGVUaW1lSW4uanM/ODA2YSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL3BhcnNlcnMvc2NhbGUvYXBwbHlEb21haW4uanM/NDMwZSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL3R5cGVHdWFyZHMvU2NoZW1lUGFyYW1zLmpzPzM5ZmYiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS9wYXJzZXJzL3NjYWxlL2FwcGx5UmFuZ2UuanM/MGNmNCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL3BhcnNlcnMvc2NhbGUvYXBwbHlQYWRkaW5nLmpzP2IyNmMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS9wYXJzZXJzL3NjYWxlL3VwZGF0ZVNjYWxlLmpzPzk4NjAiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS9wYXJzZXJzL3NjYWxlL2NyZWF0ZVNjYWxlLmpzP2Y0OGUiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS91dGlscy9pZGVudGl0eS5qcz9kM2FmIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2VuY29kYWJsZS9lc20vdHlwZUd1YXJkcy9Db21wbGV0ZUNoYW5uZWxEZWYuanM/MmJkOCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9lbmNvZGFibGUvZXNtL2VuY29kZXJzL0NoYW5uZWxFbmNvZGVyLmpzPzVkMjAiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS9lbmNvZGVycy9FbmNvZGVyLmpzPzc1ZmUiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS91dGlscy9tZXJnZUVuY29kaW5nLmpzP2E2OWYiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvZW5jb2RhYmxlL2VzbS9lbmNvZGVycy9jcmVhdGVFbmNvZGVyRmFjdG9yeS5qcz8wZjRkIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBpc0FycmF5KG1heWJlQXJyYXkpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkobWF5YmVBcnJheSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNOb3RBcnJheShtYXliZUFycmF5KSB7XG4gIHJldHVybiAhQXJyYXkuaXNBcnJheShtYXliZUFycmF5KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0RlZmluZWQodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgIT09IG51bGw7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNFdmVyeUVsZW1lbnREZWZpbmVkKGFycmF5KSB7XG4gIHJldHVybiBhcnJheS5ldmVyeShpc0RlZmluZWQpO1xufSIsIi8vIE1vZGlmaWVkIGZyb20gdmVnYS1saXRlXG4vLyBiZWNhdXNlIHZlZ2EtbGl0ZSB1c2VzIG5hbWVzcGFjZSB3aGljaCBoYXMgaXNzdWVzIHdpdGggYmFiZWwgYW5kIHR5cGVzY3JpcHRcbmV4cG9ydCBjb25zdCBTY2FsZVR5cGUgPSB7XG4gIC8vIENvbnRpbnVvdXMgLSBRdWFudGl0YXRpdmVcbiAgTElORUFSOiAnbGluZWFyJyxcbiAgTE9HOiAnbG9nJyxcbiAgUE9XOiAncG93JyxcbiAgU1FSVDogJ3NxcnQnLFxuICBTWU1MT0c6ICdzeW1sb2cnLFxuICAvLyBDb250aW51b3VzIC0gVGltZVxuICBUSU1FOiAndGltZScsXG4gIFVUQzogJ3V0YycsXG4gIC8vIERpc2NyZXRpemluZyBzY2FsZXNcbiAgUVVBTlRJTEU6ICdxdWFudGlsZScsXG4gIFFVQU5USVpFOiAncXVhbnRpemUnLFxuICBUSFJFU0hPTEQ6ICd0aHJlc2hvbGQnLFxuICBCSU5fT1JESU5BTDogJ2Jpbi1vcmRpbmFsJyxcbiAgLy8gRGlzY3JldGUgc2NhbGVzXG4gIE9SRElOQUw6ICdvcmRpbmFsJyxcbiAgUE9JTlQ6ICdwb2ludCcsXG4gIEJBTkQ6ICdiYW5kJ1xufTsiLCJleHBvcnQgZnVuY3Rpb24gaXNYKGNoYW5uZWxUeXBlKSB7XG4gIHJldHVybiBjaGFubmVsVHlwZSA9PT0gJ1gnIHx8IGNoYW5uZWxUeXBlID09PSAnWEJhbmQnO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzWShjaGFubmVsVHlwZSkge1xuICByZXR1cm4gY2hhbm5lbFR5cGUgPT09ICdZJyB8fCBjaGFubmVsVHlwZSA9PT0gJ1lCYW5kJztcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1hPclkoY2hhbm5lbFR5cGUpIHtcbiAgcmV0dXJuIGlzWChjaGFubmVsVHlwZSkgfHwgaXNZKGNoYW5uZWxUeXBlKTtcbn0iLCIvKipcbiAqIFRoaXMgaXMgYSBzdHJpY3RlciB2ZXJzaW9uIG9mIE9iamVjdC5rZXlzIGJ1dCB3aXRoIGJldHRlciB0eXBlcy5cbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvcHVsbC8xMjI1MyNpc3N1ZWNvbW1lbnQtMjYzMTMyMjA4XG4gKi9cbmNvbnN0IGtleXMgPSBPYmplY3Qua2V5cztcbmV4cG9ydCBkZWZhdWx0IGtleXM7IiwiLy8gTW9kaWZpZWQgZnJvbSB2ZWdhLWxpdGUgdmVyc2lvblxuLy8gYW5kIHJlbW92ZSB1bm5lY2Vzc2FyeSBkZXBlbmRlbmN5XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLW5lZ2F0ZWQtY29uZGl0aW9uICovXG5pbXBvcnQga2V5cyBmcm9tICcuLi91dGlscy9rZXlzJztcbi8qKlxuICogSW50ZXJuYWwgT2JqZWN0IGZvciBkZWZpbmluZyBkYXRldGltZSBleHByZXNzaW9ucy5cbiAqIFRoaXMgaXMgYW4gZXhwcmVzc2lvbiB2ZXJzaW9uIG9mIERhdGVUaW1lLlxuICogSWYgYm90aCBtb250aCBhbmQgcXVhcnRlciBhcmUgcHJvdmlkZWQsIG1vbnRoIGhhcyBoaWdoZXIgcHJlY2VkZW5jZS5cbiAqIGBkYXlgIGNhbm5vdCBiZSBjb21iaW5lZCB3aXRoIG90aGVyIGRhdGUuXG4gKi9cblxuZnVuY3Rpb24gaW52YWxpZFRpbWVVbml0KHVuaXROYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gXCJJbnZhbGlkIFwiICsgdW5pdE5hbWUgKyBcIjogXCIgKyBTdHJpbmcodmFsdWUpICsgXCIuXCI7XG59XG4vKlxuICogQSBkZXNpZ25hdGVkIHllYXIgdGhhdCBzdGFydHMgb24gU3VuZGF5LlxuICovXG5cblxuY29uc3QgU1VOREFZX1lFQVIgPSAyMDA2O1xuY29uc3QgTU9OVEhTID0gWydqYW51YXJ5JywgJ2ZlYnJ1YXJ5JywgJ21hcmNoJywgJ2FwcmlsJywgJ21heScsICdqdW5lJywgJ2p1bHknLCAnYXVndXN0JywgJ3NlcHRlbWJlcicsICdvY3RvYmVyJywgJ25vdmVtYmVyJywgJ2RlY2VtYmVyJ107XG5jb25zdCBTSE9SVF9NT05USFMgPSBNT05USFMubWFwKG0gPT4gbS5zbGljZSgwLCAzKSk7XG5jb25zdCBEQVlTID0gWydzdW5kYXknLCAnbW9uZGF5JywgJ3R1ZXNkYXknLCAnd2VkbmVzZGF5JywgJ3RodXJzZGF5JywgJ2ZyaWRheScsICdzYXR1cmRheSddO1xuY29uc3QgU0hPUlRfREFZUyA9IERBWVMubWFwKGQgPT4gZC5zbGljZSgwLCAzKSk7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSAnbnVtYmVyJztcbn1cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIHRoZSBwYXNzZWQgaW4gdmFsdWUgaXMgYSB2YWxpZCBudW1iZXIuXG4gKi9cblxuXG5mdW5jdGlvbiBpc051bWVyaWModmFsdWUpIHtcbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cblxuICByZXR1cm4gIWlzTmFOKHZhbHVlKSAmJiAhaXNOYU4ocGFyc2VGbG9hdCh2YWx1ZSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplUXVhcnRlcihxKSB7XG4gIGlmIChpc051bWVyaWMocSkpIHtcbiAgICBxID0gTnVtYmVyKHEpO1xuICB9XG5cbiAgaWYgKGlzTnVtYmVyKHEpKSB7XG4gICAgaWYgKHEgPiA0KSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS53YXJuKGludmFsaWRUaW1lVW5pdCgncXVhcnRlcicsIHEpKTtcbiAgICB9IC8vIFdlIGFjY2VwdCAxLWJhc2VkIHF1YXJ0ZXIsIHNvIG5lZWQgdG8gcmVhZGp1c3QgdG8gMC1iYXNlZCBxdWFydGVyXG5cblxuICAgIHJldHVybiBxIC0gMTtcbiAgfSAvLyBJbnZhbGlkIHF1YXJ0ZXJcblxuXG4gIHRocm93IG5ldyBFcnJvcihpbnZhbGlkVGltZVVuaXQoJ3F1YXJ0ZXInLCBxKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplTW9udGgobSkge1xuICBpZiAoaXNOdW1lcmljKG0pKSB7XG4gICAgbSA9IE51bWJlcihtKTtcbiAgfVxuXG4gIGlmIChpc051bWJlcihtKSkge1xuICAgIC8vIFdlIGFjY2VwdCAxLWJhc2VkIG1vbnRoLCBzbyBuZWVkIHRvIHJlYWRqdXN0IHRvIDAtYmFzZWQgbW9udGhcbiAgICByZXR1cm4gbSAtIDE7XG4gIH1cblxuICBjb25zdCBsb3dlck0gPSBtLnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IG1vbnRoSW5kZXggPSBNT05USFMuaW5kZXhPZihsb3dlck0pO1xuXG4gIGlmIChtb250aEluZGV4ICE9PSAtMSkge1xuICAgIHJldHVybiBtb250aEluZGV4OyAvLyAwIGZvciBqYW51YXJ5LCAuLi5cbiAgfVxuXG4gIGNvbnN0IHNob3J0TSA9IGxvd2VyTS5zbGljZSgwLCAzKTtcbiAgY29uc3Qgc2hvcnRNb250aEluZGV4ID0gU0hPUlRfTU9OVEhTLmluZGV4T2Yoc2hvcnRNKTtcblxuICBpZiAoc2hvcnRNb250aEluZGV4ICE9PSAtMSkge1xuICAgIHJldHVybiBzaG9ydE1vbnRoSW5kZXg7XG4gIH0gLy8gSW52YWxpZCBtb250aFxuXG5cbiAgdGhyb3cgbmV3IEVycm9yKGludmFsaWRUaW1lVW5pdCgnbW9udGgnLCBtKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplRGF5KGQpIHtcbiAgaWYgKGlzTnVtZXJpYyhkKSkge1xuICAgIGQgPSBOdW1iZXIoZCk7XG4gIH1cblxuICBpZiAoaXNOdW1iZXIoZCkpIHtcbiAgICAvLyBtb2Qgc28gdGhhdCB0aGlzIGNhbiBiZSBib3RoIDAtYmFzZWQgd2hlcmUgMCA9IHN1bmRheVxuICAgIC8vIGFuZCAxLWJhc2VkIHdoZXJlIDc9c3VuZGF5XG4gICAgcmV0dXJuIGQgJSA3O1xuICB9XG5cbiAgY29uc3QgbG93ZXJEID0gZC50b0xvd2VyQ2FzZSgpO1xuICBjb25zdCBkYXlJbmRleCA9IERBWVMuaW5kZXhPZihsb3dlckQpO1xuXG4gIGlmIChkYXlJbmRleCAhPT0gLTEpIHtcbiAgICByZXR1cm4gZGF5SW5kZXg7IC8vIDAgZm9yIGphbnVhcnksIC4uLlxuICB9XG5cbiAgY29uc3Qgc2hvcnREID0gbG93ZXJELnNsaWNlKDAsIDMpO1xuICBjb25zdCBzaG9ydERheUluZGV4ID0gU0hPUlRfREFZUy5pbmRleE9mKHNob3J0RCk7XG5cbiAgaWYgKHNob3J0RGF5SW5kZXggIT09IC0xKSB7XG4gICAgcmV0dXJuIHNob3J0RGF5SW5kZXg7XG4gIH0gLy8gSW52YWxpZCBkYXlcblxuXG4gIHRocm93IG5ldyBFcnJvcihpbnZhbGlkVGltZVVuaXQoJ2RheScsIGQpKTtcbn1cbi8qKlxuICogQHBhcmFtIGQgdGhlIGRhdGUuXG4gKiBAcGFyYW0gbm9ybWFsaXplIHdoZXRoZXIgdG8gbm9ybWFsaXplIHF1YXJ0ZXIsIG1vbnRoLCBkYXkuIFRoaXMgc2hvdWxkIHByb2JhYmx5IGJlIHRydWUgaWYgZCBpcyBhIERhdGVUaW1lLlxuICogQHJldHVybnMgYXJyYXkgb2YgZGF0ZSB0aW1lIHBhcnRzIFt5ZWFyLCBtb250aCwgZGF5LCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzXVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkYXRlVGltZVBhcnRzKGQsIG5vcm1hbGl6ZSkge1xuICBjb25zdCBwYXJ0cyA9IFtdO1xuXG4gIGlmIChub3JtYWxpemUgJiYgZC5kYXkgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChrZXlzKGQpLmxlbmd0aCA+IDEpIHtcbiAgICAgIGQgPSB7IC4uLmRcbiAgICAgIH07XG4gICAgICBkZWxldGUgZC5kYXk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGQueWVhciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcGFydHMucHVzaChkLnllYXIpO1xuICB9IGVsc2UgaWYgKGQuZGF5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBTZXQgeWVhciB0byAyMDA2IGZvciB3b3JraW5nIHdpdGggZGF5IHNpbmNlIEphbnVhcnkgMSAyMDA2IGlzIGEgU3VuZGF5XG4gICAgcGFydHMucHVzaChTVU5EQVlfWUVBUik7XG4gIH0gZWxzZSB7XG4gICAgcGFydHMucHVzaCgwKTtcbiAgfVxuXG4gIGlmIChkLm1vbnRoICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBtb250aCA9IG5vcm1hbGl6ZSA/IG5vcm1hbGl6ZU1vbnRoKGQubW9udGgpIDogZC5tb250aDtcbiAgICBwYXJ0cy5wdXNoKG1vbnRoKTtcbiAgfSBlbHNlIGlmIChkLnF1YXJ0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IHF1YXJ0ZXIgPSBub3JtYWxpemUgPyBub3JtYWxpemVRdWFydGVyKGQucXVhcnRlcikgOiBkLnF1YXJ0ZXI7XG4gICAgcGFydHMucHVzaChpc051bWJlcihxdWFydGVyKSA/IHF1YXJ0ZXIgKiAzIDogcXVhcnRlciArIFwiKjNcIik7XG4gIH0gZWxzZSB7XG4gICAgcGFydHMucHVzaCgwKTsgLy8gbW9udGhzIHN0YXJ0IGF0IHplcm8gaW4gSlNcbiAgfVxuXG4gIGlmIChkLmRhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgIHBhcnRzLnB1c2goZC5kYXRlKTtcbiAgfSBlbHNlIGlmIChkLmRheSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gSEFDSzogRGF5IG9ubHkgd29ya3MgYXMgYSBzdGFuZGFsb25lIHVuaXRcbiAgICAvLyBUaGlzIGlzIG9ubHkgY29ycmVjdCBiZWNhdXNlIHdlIGFsd2F5cyBzZXQgeWVhciB0byAyMDA2IGZvciBkYXlcbiAgICBjb25zdCBkYXkgPSBub3JtYWxpemUgPyBub3JtYWxpemVEYXkoZC5kYXkpIDogZC5kYXk7XG4gICAgcGFydHMucHVzaChpc051bWJlcihkYXkpID8gZGF5ICsgMSA6IGRheSArIFwiKzFcIik7XG4gIH0gZWxzZSB7XG4gICAgcGFydHMucHVzaCgxKTsgLy8gRGF0ZSBzdGFydHMgYXQgMSBpbiBKU1xuICB9XG5cbiAgWydob3VycycsICdtaW51dGVzJywgJ3NlY29uZHMnLCAnbWlsbGlzZWNvbmRzJ10uZm9yRWFjaCh0aW1lVW5pdCA9PiB7XG4gICAgY29uc3QgdW5pdCA9IGRbdGltZVVuaXRdO1xuICAgIHBhcnRzLnB1c2godHlwZW9mIHVuaXQgPT09ICd1bmRlZmluZWQnID8gMCA6IHVuaXQpO1xuICB9KTtcbiAgcmV0dXJuIHBhcnRzO1xufVxuLyoqXG4gKiBAcGFyYW0gZCB0aGUgZGF0ZSB0aW1lLlxuICogQHJldHVybnMgdGhlIHRpbWVzdGFtcC5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkYXRlVGltZVRvVGltZXN0YW1wKGQpIHtcbiAgY29uc3QgcGFydHMgPSBkYXRlVGltZVBhcnRzKGQsIHRydWUpO1xuXG4gIGlmIChkLnV0Yykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgcmV0dXJuIE51bWJlcihuZXcgRGF0ZShEYXRlLlVUQyguLi5wYXJ0cykpKTtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG5cbiAgcmV0dXJuIE51bWJlcihuZXcgRGF0ZSguLi5wYXJ0cykpO1xufSIsImltcG9ydCBkYXRlVGltZVRvVGltZXN0YW1wIGZyb20gJy4vZGF0ZVRpbWVUb1RpbWVzdGFtcCc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwYXJzZURhdGVUaW1lKGRhdGVUaW1lKSB7XG4gIGlmICh0eXBlb2YgZGF0ZVRpbWUgPT09ICdudW1iZXInIHx8IHR5cGVvZiBkYXRlVGltZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoZGF0ZVRpbWUpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBEYXRlKGRhdGVUaW1lVG9UaW1lc3RhbXAoZGF0ZVRpbWUpKTtcbn0iLCIvKipcbiAqIFR5cGUgd29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy83Mjk0I2lzc3VlY29tbWVudC00NjU3OTQ0NjBcbiAqIHRvIGF2b2lkIGVycm9yIFwiQ2Fubm90IGludm9rZSBhbiBleHByZXNzaW9uIHdob3NlIHR5cGUgbGFja3MgYSBjYWxsIHNpZ25hdHVyZVwiXG4gKiB3aGVuIHVzaW5nIGFycmF5Lm1hcFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbmZlckVsZW1lbnRUeXBlRnJvbVVuaW9uT2ZBcnJheVR5cGVzKGFycmF5KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIHJldHVybiBhcnJheTtcbn0iLCIvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L3ByZWZlci1kZWZhdWx0LWV4cG9ydFxuZXhwb3J0IGZ1bmN0aW9uIGlzRGF0ZVRpbWUobykge1xuICByZXR1cm4gISFvICYmICEobyBpbnN0YW5jZW9mIERhdGUpICYmIHR5cGVvZiBvICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgbyAhPT0gJ2Jvb2xlYW4nICYmIHR5cGVvZiBvICE9PSAnbnVtYmVyJyAmJiAoJ3llYXInIGluIG8gJiYgby55ZWFyICE9IG51bGwgfHwgJ3F1YXJ0ZXInIGluIG8gJiYgby5xdWFydGVyICE9IG51bGwgfHwgJ21vbnRoJyBpbiBvICYmIG8ubW9udGggIT0gbnVsbCB8fCAnZGF0ZScgaW4gbyAmJiBvLmRhdGUgIT0gbnVsbCB8fCAnZGF5JyBpbiBvICYmIG8uZGF5ICE9IG51bGwgfHwgJ2hvdXJzJyBpbiBvICYmIG8uaG91cnMgIT0gbnVsbCB8fCAnbWludXRlcycgaW4gbyAmJiBvLm1pbnV0ZXMgIT0gbnVsbCB8fCAnc2Vjb25kcycgaW4gbyAmJiBvLnNlY29uZHMgIT0gbnVsbCB8fCAnbWlsbGlzZWNvbmRzJyBpbiBvICYmIG8ubWlsbGlzZWNvbmRzICE9IG51bGwpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZhbGxiYWNrRm9ybWF0dGVyKHYpIHtcbiAgcmV0dXJuIFwiXCIgKyB2O1xufSIsImltcG9ydCBmYWxsYmFja0Zvcm1hdHRlciBmcm9tICcuL2ZhbGxiYWNrRm9ybWF0dGVyJztcbmltcG9ydCBFbmNvZGFibGUgZnJvbSAnLi4vLi4vb3B0aW9ucy9FbmNvZGFibGUnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlRm9ybWF0dGVyKHtcbiAgZm9ybWF0VHlwZSxcbiAgZm9ybWF0LFxuICBmb3JtYXRJbkxvY2FsVGltZVxufSkge1xuICBpZiAoZm9ybWF0VHlwZSA9PT0gJ3RpbWUnKSB7XG4gICAgY29uc3QgZm9ybWF0dGVyID0gRW5jb2RhYmxlLnJlc29sdmVUaW1lRm9ybWF0KHtcbiAgICAgIGZvcm1hdCxcbiAgICAgIGZvcm1hdEluTG9jYWxUaW1lXG4gICAgfSk7XG4gICAgcmV0dXJuIHZhbHVlID0+IGZvcm1hdHRlcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoZm9ybWF0VHlwZSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGZvcm1hdCAhPT0gJ3VuZGVmaW5lZCcgJiYgZm9ybWF0Lmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBmb3JtYXR0ZXIgPSBFbmNvZGFibGUucmVzb2x2ZU51bWJlckZvcm1hdChmb3JtYXQpO1xuICAgIHJldHVybiB2YWx1ZSA9PiBmb3JtYXR0ZXIodmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIGZhbGxiYWNrRm9ybWF0dGVyO1xufSIsImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmltcG9ydCBwYXJzZURhdGVUaW1lIGZyb20gJy4uL3BhcnNlcnMvcGFyc2VEYXRlVGltZSc7XG5pbXBvcnQgaW5mZXJFbGVtZW50VHlwZUZyb21Vbmlvbk9mQXJyYXlUeXBlcyBmcm9tICcuLi91dGlscy9pbmZlckVsZW1lbnRUeXBlRnJvbVVuaW9uT2ZBcnJheVR5cGVzJztcbmltcG9ydCB7IGlzRGF0ZVRpbWUgfSBmcm9tICcuLi90eXBlR3VhcmRzL0RhdGVUaW1lJztcbmltcG9ydCBjcmVhdGVGb3JtYXR0ZXIgZnJvbSAnLi4vcGFyc2Vycy9mb3JtYXQvY3JlYXRlRm9ybWF0dGVyJztcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENoYW5uZWxFbmNvZGVyQXhpcyB7XG4gIGNvbnN0cnVjdG9yKGNoYW5uZWxFbmNvZGVyKSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY2hhbm5lbEVuY29kZXJcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbmZpZ1wiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZm9ybWF0VmFsdWVcIiwgdm9pZCAwKTtcblxuICAgIHRoaXMuY2hhbm5lbEVuY29kZXIgPSBjaGFubmVsRW5jb2RlcjtcbiAgICB0aGlzLmNvbmZpZyA9IGNoYW5uZWxFbmNvZGVyLmRlZmluaXRpb24uYXhpcztcbiAgICB0aGlzLmZvcm1hdFZhbHVlID0gY3JlYXRlRm9ybWF0dGVyKHRoaXMuY29uZmlnKTtcbiAgfVxuXG4gIGdldFRpdGxlKCkge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy50aXRsZTtcbiAgfVxuXG4gIGhhc1RpdGxlKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHRpdGxlXG4gICAgfSA9IHRoaXMuY29uZmlnO1xuICAgIHJldHVybiB0aXRsZSAhPT0gbnVsbCAmJiB0eXBlb2YgdGl0bGUgIT09ICd1bmRlZmluZWQnICYmIHRpdGxlICE9PSAnJztcbiAgfVxuXG4gIGdldFRpY2tMYWJlbHMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgdGlja0NvdW50LFxuICAgICAgdmFsdWVzXG4gICAgfSA9IHRoaXMuY29uZmlnO1xuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gaW5mZXJFbGVtZW50VHlwZUZyb21Vbmlvbk9mQXJyYXlUeXBlcyh2YWx1ZXMpLm1hcCh2ID0+IHRoaXMuZm9ybWF0VmFsdWUoaXNEYXRlVGltZSh2KSA/IHBhcnNlRGF0ZVRpbWUodikgOiB2KSk7XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgc2NhbGVcbiAgICB9ID0gdGhpcy5jaGFubmVsRW5jb2RlcjtcblxuICAgIGlmIChzY2FsZSAmJiAnZG9tYWluJyBpbiBzY2FsZSkge1xuICAgICAgY29uc3QgdGlja3MgPSAndGlja3MnIGluIHNjYWxlID8gc2NhbGUudGlja3ModGlja0NvdW50KSA6IHNjYWxlLmRvbWFpbigpO1xuICAgICAgcmV0dXJuIHRpY2tzLm1hcCh0aGlzLmZvcm1hdFZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW107XG4gIH1cblxufSIsImltcG9ydCBnZXQgZnJvbSAnbG9kYXNoLmdldCc7XG5pbXBvcnQgeyBpc1ZhbHVlRGVmIH0gZnJvbSAnLi4vdHlwZUd1YXJkcy9DaGFubmVsRGVmJztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZUdldHRlckZyb21DaGFubmVsRGVmKGRlZmluaXRpb24pIHtcbiAgaWYgKGlzVmFsdWVEZWYoZGVmaW5pdGlvbikpIHtcbiAgICByZXR1cm4gKCkgPT4gZGVmaW5pdGlvbi52YWx1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZGVmaW5pdGlvbi5maWVsZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4geCA9PiBnZXQoeCwgZGVmaW5pdGlvbi5maWVsZCk7XG4gIH1cblxuICByZXR1cm4gKCkgPT4gdW5kZWZpbmVkO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzRGlzYWJsZWQoY29uZmlnKSB7XG4gIHJldHVybiBjb25maWcgPT09IGZhbHNlIHx8IGNvbmZpZyA9PT0gbnVsbDtcbn0iLCJpbXBvcnQgaXNEaXNhYmxlZCBmcm9tICcuL2lzRGlzYWJsZWQnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNFbmFibGVkKGNvbmZpZykge1xuICByZXR1cm4gIWlzRGlzYWJsZWQoY29uZmlnKTtcbn0iLCJpbXBvcnQgeyBpc1ggfSBmcm9tICcuLi90eXBlR3VhcmRzL0NoYW5uZWwnO1xuZXhwb3J0IGNvbnN0IFNUUkFURUdZX0ZMQVQgPSB7XG4gIHN0cmF0ZWd5OiAnZmxhdCdcbn07XG5jb25zdCBTVFJBVEVHWV9ST1RBVEUgPSB7XG4gIGxhYmVsQW5nbGU6IDQwLFxuICBzdHJhdGVneTogJ3JvdGF0ZSdcbn07XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBleHBhbmRMYWJlbE92ZXJsYXBTdHJhdGVneShjaGFubmVsVHlwZSwgbGFiZWxPdmVybGFwID0gJ2F1dG8nKSB7XG4gIGxldCBvdXRwdXQ7XG5cbiAgc3dpdGNoIChsYWJlbE92ZXJsYXApIHtcbiAgICBjYXNlICdmbGF0JzpcbiAgICAgIG91dHB1dCA9IFNUUkFURUdZX0ZMQVQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3JvdGF0ZSc6XG4gICAgICBvdXRwdXQgPSBTVFJBVEVHWV9ST1RBVEU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2F1dG8nOlxuICAgICAgb3V0cHV0ID0gaXNYKGNoYW5uZWxUeXBlKSA/IFNUUkFURUdZX1JPVEFURSA6IFNUUkFURUdZX0ZMQVQ7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBvdXRwdXQgPSBsYWJlbE92ZXJsYXA7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiB7IC4uLm91dHB1dFxuICB9O1xufSIsImltcG9ydCB7IFNjYWxlVHlwZSB9IGZyb20gJy4uLy4uL3R5cGVzJzsgLy8gR3JvdXBlZCBieSBkb21haW4gYW5kIHJhbmdlXG5cbmV4cG9ydCBjb25zdCBjb250aW51b3VzVG9Db250aW51b3VzU2NhbGVUeXBlcyA9IFtTY2FsZVR5cGUuTElORUFSLCBTY2FsZVR5cGUuUE9XLCBTY2FsZVR5cGUuU1FSVCwgU2NhbGVUeXBlLlNZTUxPRywgU2NhbGVUeXBlLkxPRywgU2NhbGVUeXBlLlRJTUUsIFNjYWxlVHlwZS5VVENdO1xuZXhwb3J0IGNvbnN0IGNvbnRpbnVvdXNUb0NvbnRpbnVvdXNTY2FsZVR5cGVzU2V0ID0gbmV3IFNldChjb250aW51b3VzVG9Db250aW51b3VzU2NhbGVUeXBlcyk7XG5leHBvcnQgY29uc3QgY29udGludW91c1RvRGlzY3JldGVTY2FsZVR5cGVzID0gW1NjYWxlVHlwZS5RVUFOVElMRSwgU2NhbGVUeXBlLlFVQU5USVpFLCBTY2FsZVR5cGUuVEhSRVNIT0xEXTtcbmV4cG9ydCBjb25zdCBjb250aW51b3VzVG9EaXNjcmV0ZVNjYWxlVHlwZXNTZXQgPSBuZXcgU2V0KGNvbnRpbnVvdXNUb0Rpc2NyZXRlU2NhbGVUeXBlcyk7IC8vIEdyb3VwZWQgYnkgRG9tYWluXG5cbmV4cG9ydCBjb25zdCBjb250aW51b3VzRG9tYWluU2NhbGVUeXBlcyA9IGNvbnRpbnVvdXNUb0NvbnRpbnVvdXNTY2FsZVR5cGVzLmNvbmNhdChjb250aW51b3VzVG9EaXNjcmV0ZVNjYWxlVHlwZXMpO1xuZXhwb3J0IGNvbnN0IGNvbnRpbnVvdXNEb21haW5TY2FsZVR5cGVzU2V0ID0gbmV3IFNldChjb250aW51b3VzRG9tYWluU2NhbGVUeXBlcyk7XG5leHBvcnQgY29uc3QgZGlzY3JldGVEb21haW5TY2FsZVR5cGVzID0gW1NjYWxlVHlwZS5PUkRJTkFMLCBTY2FsZVR5cGUuQklOX09SRElOQUwsIFNjYWxlVHlwZS5QT0lOVCwgU2NhbGVUeXBlLkJBTkRdO1xuZXhwb3J0IGNvbnN0IGRpc2NyZXRlRG9tYWluU2NhbGVUeXBlc1NldCA9IG5ldyBTZXQoZGlzY3JldGVEb21haW5TY2FsZVR5cGVzKTsgLy8gVGhyZWUgYnJvYWQgY2F0ZWdvcmllc1xuXG5leHBvcnQgY29uc3QgY29udGludW91c1NjYWxlVHlwZXMgPSBjb250aW51b3VzVG9Db250aW51b3VzU2NhbGVUeXBlcztcbmV4cG9ydCBjb25zdCBjb250aW51b3VzU2NhbGVUeXBlc1NldCA9IGNvbnRpbnVvdXNUb0NvbnRpbnVvdXNTY2FsZVR5cGVzU2V0O1xuZXhwb3J0IGNvbnN0IGRpc2NyZXRlU2NhbGVUeXBlcyA9IFtTY2FsZVR5cGUuQkFORCwgU2NhbGVUeXBlLlBPSU5ULCBTY2FsZVR5cGUuT1JESU5BTF07XG5leHBvcnQgY29uc3QgZGlzY3JldGVTY2FsZVR5cGVzU2V0ID0gbmV3IFNldChkaXNjcmV0ZVNjYWxlVHlwZXMpO1xuZXhwb3J0IGNvbnN0IGRpc2NyZXRpemluZ1NjYWxlVHlwZXMgPSBbU2NhbGVUeXBlLkJJTl9PUkRJTkFMLCBTY2FsZVR5cGUuUVVBTlRJTEUsIFNjYWxlVHlwZS5RVUFOVElaRSwgU2NhbGVUeXBlLlRIUkVTSE9MRF07XG5leHBvcnQgY29uc3QgZGlzY3JldGl6aW5nU2NhbGVUeXBlc1NldCA9IG5ldyBTZXQoZGlzY3JldGl6aW5nU2NhbGVUeXBlcyk7IC8vIE90aGVyc1xuXG5leHBvcnQgY29uc3QgdGltZVNjYWxlVHlwZXMgPSBbU2NhbGVUeXBlLlRJTUUsIFNjYWxlVHlwZS5VVENdO1xuZXhwb3J0IGNvbnN0IHRpbWVTY2FsZVR5cGVzU2V0ID0gbmV3IFNldCh0aW1lU2NhbGVUeXBlcyk7XG5leHBvcnQgY29uc3QgYWxsU2NhbGVUeXBlcyA9IFtTY2FsZVR5cGUuTElORUFSLCBTY2FsZVR5cGUuTE9HLCBTY2FsZVR5cGUuUE9XLCBTY2FsZVR5cGUuU1FSVCwgU2NhbGVUeXBlLlNZTUxPRywgU2NhbGVUeXBlLlRJTUUsIFNjYWxlVHlwZS5VVEMsIFNjYWxlVHlwZS5RVUFOVElMRSwgU2NhbGVUeXBlLlFVQU5USVpFLCBTY2FsZVR5cGUuVEhSRVNIT0xELCBTY2FsZVR5cGUuQklOX09SRElOQUwsIFNjYWxlVHlwZS5PUkRJTkFMLCBTY2FsZVR5cGUuUE9JTlQsIFNjYWxlVHlwZS5CQU5EXTtcbmV4cG9ydCBjb25zdCBhbGxTY2FsZVR5cGVzU2V0ID0gbmV3IFNldChhbGxTY2FsZVR5cGVzKTsiLCJpbXBvcnQgaXNFbmFibGVkIGZyb20gJy4uL3V0aWxzL2lzRW5hYmxlZCc7XG5pbXBvcnQgeyBpc1hPclksIGlzWCB9IGZyb20gJy4uL3R5cGVHdWFyZHMvQ2hhbm5lbCc7XG5pbXBvcnQgeyBpc1R5cGVkRmllbGREZWYgfSBmcm9tICcuLi90eXBlR3VhcmRzL0NoYW5uZWxEZWYnO1xuaW1wb3J0IGV4cGFuZExhYmVsT3ZlcmxhcFN0cmF0ZWd5IGZyb20gJy4vZXhwYW5kTGFiZWxPdmVybGFwU3RyYXRlZ3knO1xuaW1wb3J0IHsgY29udGludW91c1RvQ29udGludW91c1NjYWxlVHlwZXNTZXQgfSBmcm9tICcuLi9wYXJzZXJzL3NjYWxlL3NjYWxlQ2F0ZWdvcmllcyc7XG5cbmZ1bmN0aW9uIGlzQ2hhbm5lbERlZldpdGhBeGlzU3VwcG9ydChjaGFubmVsVHlwZSwgY2hhbm5lbERlZikge1xuICByZXR1cm4gaXNUeXBlZEZpZWxkRGVmKGNoYW5uZWxEZWYpICYmIGlzWE9yWShjaGFubmVsVHlwZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXBsZXRlQXhpc0NvbmZpZyhjaGFubmVsVHlwZSwgY2hhbm5lbERlZikge1xuICBpZiAoaXNDaGFubmVsRGVmV2l0aEF4aXNTdXBwb3J0KGNoYW5uZWxUeXBlLCBjaGFubmVsRGVmKSAmJiBpc0VuYWJsZWQoY2hhbm5lbERlZi5heGlzKSkge1xuICAgIGNvbnN0IGF4aXMgPSBjaGFubmVsRGVmLmF4aXMgPT09IHRydWUgfHwgdHlwZW9mIGNoYW5uZWxEZWYuYXhpcyA9PT0gJ3VuZGVmaW5lZCcgPyB7fSA6IGNoYW5uZWxEZWYuYXhpcztcbiAgICBjb25zdCBpc1hDaGFubmVsID0gaXNYKGNoYW5uZWxUeXBlKTtcbiAgICBjb25zdCB7XG4gICAgICBmb3JtYXQgPSBjaGFubmVsRGVmLmZvcm1hdCxcbiAgICAgIGZvcm1hdFR5cGUgPSBjaGFubmVsRGVmLmZvcm1hdFR5cGUsXG4gICAgICBmb3JtYXRJbkxvY2FsVGltZSA9IGNoYW5uZWxEZWYuZm9ybWF0SW5Mb2NhbFRpbWUsXG4gICAgICBsYWJlbEFuZ2xlID0gMCxcbiAgICAgIGxhYmVsRmx1c2gsXG4gICAgICBsYWJlbE92ZXJsYXAsXG4gICAgICBsYWJlbFBhZGRpbmcgPSA0LFxuICAgICAgb3JpZW50ID0gaXNYQ2hhbm5lbCA/ICdib3R0b20nIDogJ2xlZnQnLFxuICAgICAgdGlja0NvdW50ID0gNSxcbiAgICAgIHRpY2tzID0gdHJ1ZSxcbiAgICAgIHRpdGxlID0gY2hhbm5lbERlZi50aXRsZSxcbiAgICAgIHRpdGxlUGFkZGluZyA9IDRcbiAgICB9ID0gYXhpcztcbiAgICBjb25zdCBvdXRwdXQgPSB7IC4uLmF4aXMsXG4gICAgICBmb3JtYXQsXG4gICAgICBmb3JtYXRUeXBlLFxuICAgICAgbGFiZWxBbmdsZSxcbiAgICAgIGxhYmVsRmx1c2g6IHR5cGVvZiBsYWJlbEZsdXNoID09PSAndW5kZWZpbmVkJyA/IGNoYW5uZWxEZWYuc2NhbGUgJiYgdHlwZW9mIGNoYW5uZWxEZWYuc2NhbGUudHlwZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29udGludW91c1RvQ29udGludW91c1NjYWxlVHlwZXNTZXQuaGFzKGNoYW5uZWxEZWYuc2NhbGUudHlwZSkgOiBsYWJlbEZsdXNoLFxuICAgICAgbGFiZWxPdmVybGFwOiBleHBhbmRMYWJlbE92ZXJsYXBTdHJhdGVneShjaGFubmVsVHlwZSwgbGFiZWxPdmVybGFwKSxcbiAgICAgIGxhYmVsUGFkZGluZyxcbiAgICAgIG9yaWVudCxcbiAgICAgIHRpY2tDb3VudCxcbiAgICAgIHRpY2tzLFxuICAgICAgdGl0bGUsXG4gICAgICB0aXRsZVBhZGRpbmdcbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiBmb3JtYXRJbkxvY2FsVGltZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG91dHB1dC5mb3JtYXRJbkxvY2FsVGltZSA9IGZvcm1hdEluTG9jYWxUaW1lO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcGxldGVGb3JtYXRDb25maWcoY29uZmlnKSB7XG4gIGNvbnN0IHtcbiAgICBmb3JtYXRUeXBlLFxuICAgIGZvcm1hdEluTG9jYWxUaW1lLFxuICAgIGZvcm1hdCxcbiAgICB0eXBlLFxuICAgIHNjYWxlVHlwZVxuICB9ID0gY29uZmlnO1xuICBsZXQgcmVzb2x2ZWRGb3JtYXRUeXBlO1xuXG4gIGlmICh0eXBlb2YgZm9ybWF0VHlwZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXNvbHZlZEZvcm1hdFR5cGUgPSBmb3JtYXRUeXBlO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdxdWFudGl0YXRpdmUnKSB7XG4gICAgcmVzb2x2ZWRGb3JtYXRUeXBlID0gJ251bWJlcic7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3RlbXBvcmFsJyB8fCBzY2FsZVR5cGUgPT09ICd0aW1lJyB8fCBzY2FsZVR5cGUgPT09ICd1dGMnKSB7XG4gICAgcmVzb2x2ZWRGb3JtYXRUeXBlID0gJ3RpbWUnO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBmb3JtYXQgIT09ICd1bmRlZmluZWQnICYmIGZvcm1hdC5sZW5ndGggPiAwKSB7XG4gICAgcmVzb2x2ZWRGb3JtYXRUeXBlID0gJ251bWJlcic7XG4gIH1cblxuICBpZiAocmVzb2x2ZWRGb3JtYXRUeXBlID09PSAndGltZScpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZm9ybWF0VHlwZTogJ3RpbWUnLFxuICAgICAgZm9ybWF0SW5Mb2NhbFRpbWU6IGZvcm1hdEluTG9jYWxUaW1lIHx8IHR5cGVvZiBmb3JtYXRJbkxvY2FsVGltZSA9PT0gJ3VuZGVmaW5lZCcgJiYgc2NhbGVUeXBlID09PSAndGltZScsXG4gICAgICBmb3JtYXRcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBmb3JtYXRUeXBlOiByZXNvbHZlZEZvcm1hdFR5cGUsXG4gICAgZm9ybWF0XG4gIH07XG59IiwiaW1wb3J0IHsgaXNYT3JZIH0gZnJvbSAnLi4vdHlwZUd1YXJkcy9DaGFubmVsJztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXBsZXRlTGVnZW5kQ29uZmlnKGNoYW5uZWxUeXBlLCBjaGFubmVsRGVmKSB7XG4gIGlmICgnbGVnZW5kJyBpbiBjaGFubmVsRGVmICYmIGNoYW5uZWxEZWYubGVnZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gY2hhbm5lbERlZi5sZWdlbmQ7XG4gIH1cblxuICByZXR1cm4gaXNYT3JZKGNoYW5uZWxUeXBlKSB8fCBjaGFubmVsVHlwZSA9PT0gJ1RleHQnID8gZmFsc2UgOiB7fTtcbn0iLCJpbXBvcnQgeyBTY2FsZVR5cGUgfSBmcm9tICcuLi90eXBlcyc7XG4vKipcbiAqIFNvbWV0aW1lcyBzY2FsZSB0eXBlIGlzIG5vdCBzcGVjaWZpZWQgYnV0IGNhbiBiZSBpbmZlcnJlZFxuICogZnJvbSBvdGhlciBmaWVsZHMuXG4gKiBTZWUgaHR0cHM6Ly92ZWdhLmdpdGh1Yi5pby92ZWdhLWxpdGUvZG9jcy9zY2FsZS5odG1sXG4gKiBAcGFyYW0gY2hhbm5lbFR5cGUgdHlwZSBvZiB0aGUgY2hhbm5lbFxuICogQHBhcmFtIGZpZWxkVHlwZSB0eXBlIG9mIHRoZSBmaWVsZFxuICogQHBhcmFtIGJpbiBpcyB2YWx1ZSBiaW5uZWRcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbmZlclNjYWxlVHlwZShjaGFubmVsVHlwZSwgZmllbGRUeXBlLCBiaW4gPSBmYWxzZSkge1xuICBpZiAoZmllbGRUeXBlID09PSAnbm9taW5hbCcgfHwgZmllbGRUeXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICBzd2l0Y2ggKGNoYW5uZWxUeXBlKSB7XG4gICAgICAvLyBGb3IgcG9zaXRpb25hbCAoeCBhbmQgeSkgb3JkaW5hbCBhbmQgb3JkaW5hbCBmaWVsZHMsXG4gICAgICAvLyBcInBvaW50XCIgaXMgdGhlIGRlZmF1bHQgc2NhbGUgdHlwZSBmb3IgYWxsIG1hcmtzXG4gICAgICAvLyBleGNlcHQgYmFyIGFuZCByZWN0IG1hcmtzLCB3aGljaCB1c2UgXCJiYW5kXCIgc2NhbGVzLlxuICAgICAgLy8gaHR0cHM6Ly92ZWdhLmdpdGh1Yi5pby92ZWdhLWxpdGUvZG9jcy9zY2FsZS5odG1sXG4gICAgICBjYXNlICdYQmFuZCc6XG4gICAgICBjYXNlICdZQmFuZCc6XG4gICAgICAgIHJldHVybiBTY2FsZVR5cGUuQkFORDtcblxuICAgICAgY2FzZSAnWCc6XG4gICAgICBjYXNlICdZJzpcbiAgICAgIGNhc2UgJ051bWVyaWMnOlxuICAgICAgICByZXR1cm4gU2NhbGVUeXBlLlBPSU5UO1xuXG4gICAgICBjYXNlICdDb2xvcic6XG4gICAgICBjYXNlICdDYXRlZ29yeSc6XG4gICAgICAgIHJldHVybiBTY2FsZVR5cGUuT1JESU5BTDtcblxuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gIH0gZWxzZSBpZiAoZmllbGRUeXBlID09PSAncXVhbnRpdGF0aXZlJykge1xuICAgIHN3aXRjaCAoY2hhbm5lbFR5cGUpIHtcbiAgICAgIGNhc2UgJ1hCYW5kJzpcbiAgICAgIGNhc2UgJ1lCYW5kJzpcbiAgICAgIGNhc2UgJ1gnOlxuICAgICAgY2FzZSAnWSc6XG4gICAgICBjYXNlICdOdW1lcmljJzpcbiAgICAgICAgcmV0dXJuIFNjYWxlVHlwZS5MSU5FQVI7XG5cbiAgICAgIGNhc2UgJ0NvbG9yJzpcbiAgICAgICAgcmV0dXJuIGJpbiA/IFNjYWxlVHlwZS5CSU5fT1JESU5BTCA6IFNjYWxlVHlwZS5MSU5FQVI7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuICB9IGVsc2UgaWYgKGZpZWxkVHlwZSA9PT0gJ3RlbXBvcmFsJykge1xuICAgIHN3aXRjaCAoY2hhbm5lbFR5cGUpIHtcbiAgICAgIGNhc2UgJ1hCYW5kJzpcbiAgICAgIGNhc2UgJ1lCYW5kJzpcbiAgICAgIGNhc2UgJ1gnOlxuICAgICAgY2FzZSAnWSc6XG4gICAgICBjYXNlICdOdW1lcmljJzpcbiAgICAgICAgcmV0dXJuIFNjYWxlVHlwZS5VVEM7XG5cbiAgICAgIGNhc2UgJ0NvbG9yJzpcbiAgICAgICAgcmV0dXJuIFNjYWxlVHlwZS5MSU5FQVI7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn0iLCJpbXBvcnQgeyBTY2FsZVR5cGUgfSBmcm9tICcuLi8uLi90eXBlcyc7XG5pbXBvcnQgeyBhbGxTY2FsZVR5cGVzU2V0LCBhbGxTY2FsZVR5cGVzLCBjb250aW51b3VzRG9tYWluU2NhbGVUeXBlcywgY29udGludW91c1NjYWxlVHlwZXMsIGNvbnRpbnVvdXNTY2FsZVR5cGVzU2V0IH0gZnJvbSAnLi9zY2FsZUNhdGVnb3JpZXMnO1xuY29uc3QgcG9pbnRPckJhbmQgPSBbU2NhbGVUeXBlLlBPSU5ULCBTY2FsZVR5cGUuQkFORF07XG5jb25zdCBwb2ludE9yQmFuZFNldCA9IG5ldyBTZXQocG9pbnRPckJhbmQpO1xuY29uc3QgZXhjZXB0UG9pbnRPckJhbmQgPSBhbGxTY2FsZVR5cGVzLmZpbHRlcih0eXBlID0+ICFwb2ludE9yQmFuZFNldC5oYXModHlwZSkpO1xuY29uc3QgZXhjZXB0UG9pbnRPckJhbmRTZXQgPSBuZXcgU2V0KGV4Y2VwdFBvaW50T3JCYW5kKTtcbmNvbnN0IGNvbnRpbnVvdXNPclBvaW50T3JCYW5kU2V0ID0gbmV3IFNldChjb250aW51b3VzU2NhbGVUeXBlcy5jb25jYXQocG9pbnRPckJhbmQpKTtcbmNvbnN0IHplcm9TZXQgPSBuZXcgU2V0KGNvbnRpbnVvdXNEb21haW5TY2FsZVR5cGVzKTsgLy8gbG9nIHNjYWxlIGNhbm5vdCBoYXZlIHplcm8gdmFsdWVcblxuemVyb1NldC5kZWxldGUoU2NhbGVUeXBlLkxPRyk7IC8vIHplcm8gaXMgbm90IG1lYW5pbmdmdWwgZm9yIHRpbWVcblxuemVyb1NldC5kZWxldGUoU2NhbGVUeXBlLlRJTUUpO1xuemVyb1NldC5kZWxldGUoU2NhbGVUeXBlLlVUQyk7IC8vIHRocmVzaG9sZCByZXF1aXJlcyBjdXN0b20gZG9tYWluIHNvIHplcm8gZG9lcyBub3QgbWF0dGVyXG5cbnplcm9TZXQuZGVsZXRlKFNjYWxlVHlwZS5USFJFU0hPTEQpOyAvLyBxdWFudGlsZSBkZXBlbmRzIG9uIGRpc3RyaWJ1dGlvbiBzbyB6ZXJvIGRvZXMgbm90IG1hdHRlclxuXG56ZXJvU2V0LmRlbGV0ZShTY2FsZVR5cGUuUVVBTlRJTEUpO1xuY29uc3Qgc3VwcG9ydGVkU2NhbGVUeXBlcyA9IHtcbiAgYWxpZ246IHBvaW50T3JCYW5kU2V0LFxuICBiYXNlOiBuZXcgU2V0KFtTY2FsZVR5cGUuTE9HXSksXG4gIGNsYW1wOiBjb250aW51b3VzU2NhbGVUeXBlc1NldCxcbiAgY29uc3RhbnQ6IG5ldyBTZXQoW1NjYWxlVHlwZS5TWU1MT0ddKSxcbiAgZG9tYWluOiBhbGxTY2FsZVR5cGVzU2V0LFxuICBleHBvbmVudDogbmV3IFNldChbU2NhbGVUeXBlLlBPV10pLFxuICBpbnRlcnBvbGF0ZTogZXhjZXB0UG9pbnRPckJhbmRTZXQsXG4gIG5pY2U6IG5ldyBTZXQoY29udGludW91c1NjYWxlVHlwZXMuY29uY2F0KFtTY2FsZVR5cGUuUVVBTlRJWkUsIFNjYWxlVHlwZS5USFJFU0hPTERdKSksXG4gIHBhZGRpbmc6IGNvbnRpbnVvdXNPclBvaW50T3JCYW5kU2V0LFxuICBwYWRkaW5nSW5uZXI6IG5ldyBTZXQoW1NjYWxlVHlwZS5CQU5EXSksXG4gIHBhZGRpbmdPdXRlcjogcG9pbnRPckJhbmRTZXQsXG4gIHJhbmdlOiBhbGxTY2FsZVR5cGVzU2V0LFxuICByZXZlcnNlOiBhbGxTY2FsZVR5cGVzU2V0LFxuICByb3VuZDogY29udGludW91c09yUG9pbnRPckJhbmRTZXQsXG4gIHNjaGVtZTogZXhjZXB0UG9pbnRPckJhbmRTZXQsXG4gIHR5cGU6IGFsbFNjYWxlVHlwZXNTZXQsXG4gIHVua25vd246IG5ldyBTZXQoW1NjYWxlVHlwZS5PUkRJTkFMXSksXG4gIHplcm86IHplcm9TZXRcbn07XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc1Byb3BlcnR5U3VwcG9ydGVkQnlTY2FsZVR5cGUocHJvcGVydHksIHNjYWxlVHlwZSkge1xuICByZXR1cm4gc3VwcG9ydGVkU2NhbGVUeXBlc1twcm9wZXJ0eV0uaGFzKHNjYWxlVHlwZSk7XG59IiwiaW1wb3J0IGlzUHJvcGVydHlTdXBwb3J0ZWRCeVNjYWxlVHlwZSBmcm9tICcuLi9wYXJzZXJzL3NjYWxlL2lzUHJvcGVydHlTdXBwb3J0ZWRCeVNjYWxlVHlwZSc7XG5pbXBvcnQgeyBjb250aW51b3VzU2NhbGVUeXBlc1NldCwgZGlzY3JldGl6aW5nU2NhbGVUeXBlc1NldCwgZGlzY3JldGVTY2FsZVR5cGVzU2V0IH0gZnJvbSAnLi4vcGFyc2Vycy9zY2FsZS9zY2FsZUNhdGVnb3JpZXMnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ29udGludW91c1NjYWxlQ29uZmlnKGNvbmZpZykge1xuICByZXR1cm4gY29udGludW91c1NjYWxlVHlwZXNTZXQuaGFzKGNvbmZpZy50eXBlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0Rpc2NyZXRpemluZ1NjYWxlQ29uZmlnKGNvbmZpZykge1xuICByZXR1cm4gZGlzY3JldGl6aW5nU2NhbGVUeXBlc1NldC5oYXMoY29uZmlnLnR5cGUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzRGlzY3JldGVTY2FsZUNvbmZpZyhjb25maWcpIHtcbiAgcmV0dXJuIGRpc2NyZXRlU2NhbGVUeXBlc1NldC5oYXMoY29uZmlnLnR5cGUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzU2NhbGVDb25maWdXaXRoWmVybyhjb25maWcpIHtcbiAgcmV0dXJuIGlzUHJvcGVydHlTdXBwb3J0ZWRCeVNjYWxlVHlwZSgnemVybycsIGNvbmZpZy50eXBlKTtcbn0iLCJpbXBvcnQgaW5mZXJTY2FsZVR5cGUgZnJvbSAnLi9pbmZlclNjYWxlVHlwZSc7XG5pbXBvcnQgeyBpc1R5cGVkRmllbGREZWYgfSBmcm9tICcuLi90eXBlR3VhcmRzL0NoYW5uZWxEZWYnO1xuaW1wb3J0IHsgaXNDb250aW51b3VzU2NhbGVDb25maWcsIGlzU2NhbGVDb25maWdXaXRoWmVybyB9IGZyb20gJy4uL3R5cGVHdWFyZHMvU2NhbGVDb25maWcnO1xuaW1wb3J0IGlzRW5hYmxlZCBmcm9tICcuLi91dGlscy9pc0VuYWJsZWQnO1xuaW1wb3J0IHsgdGltZVNjYWxlVHlwZXNTZXQgfSBmcm9tICcuLi9wYXJzZXJzL3NjYWxlL3NjYWxlQ2F0ZWdvcmllcyc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wbGV0ZVNjYWxlQ29uZmlnKGNoYW5uZWxUeXBlLCBjaGFubmVsRGVmKSB7XG4gIGlmIChpc1R5cGVkRmllbGREZWYoY2hhbm5lbERlZikgJiYgaXNFbmFibGVkKGNoYW5uZWxEZWYuc2NhbGUpKSB7XG4gICAgY29uc3Qge1xuICAgICAgc2NhbGUgPSB7fSxcbiAgICAgIHR5cGUsXG4gICAgICBiaW5cbiAgICB9ID0gY2hhbm5lbERlZjtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlOiBzY2FsZVR5cGUgPSBpbmZlclNjYWxlVHlwZShjaGFubmVsVHlwZSwgdHlwZSwgYmluKVxuICAgIH0gPSBzY2FsZTtcblxuICAgIGlmICh0eXBlb2Ygc2NhbGVUeXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9jb25zaXN0ZW50LXR5cGUtYXNzZXJ0aW9uc1xuXG5cbiAgICBjb25zdCBmaWxsZWRTY2FsZSA9IHsgLi4uc2NhbGUsXG4gICAgICB0eXBlOiBzY2FsZVR5cGVcbiAgICB9O1xuXG4gICAgaWYgKGlzQ29udGludW91c1NjYWxlQ29uZmlnKGZpbGxlZFNjYWxlKSkge1xuICAgICAgaWYgKHR5cGVvZiBmaWxsZWRTY2FsZS5uaWNlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBmaWxsZWRTY2FsZS5uaWNlID0gIXRpbWVTY2FsZVR5cGVzU2V0LmhhcyhzY2FsZVR5cGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGZpbGxlZFNjYWxlLmNsYW1wID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBmaWxsZWRTY2FsZS5jbGFtcCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzU2NhbGVDb25maWdXaXRoWmVybyhmaWxsZWRTY2FsZSkgJiYgdHlwZW9mIGZpbGxlZFNjYWxlLnplcm8gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBmaWxsZWRTY2FsZS56ZXJvID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmlsbGVkU2NhbGU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59IiwiaW1wb3J0IHsgaXNYT3JZIH0gZnJvbSAnLi4vdHlwZUd1YXJkcy9DaGFubmVsJztcbmNvbnN0IHRlbXBvcmFsRmllbGROYW1lcyA9IG5ldyBTZXQoWyd0aW1lJywgJ2RhdGUnLCAnZGF0ZXRpbWUnLCAndGltZXN0YW1wJ10pO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaW5mZXJGaWVsZFR5cGUoY2hhbm5lbFR5cGUsIGZpZWxkID0gJycpIHtcbiAgaWYgKGlzWE9yWShjaGFubmVsVHlwZSkgfHwgY2hhbm5lbFR5cGUgPT09ICdOdW1lcmljJykge1xuICAgIHJldHVybiB0ZW1wb3JhbEZpZWxkTmFtZXMuaGFzKGZpZWxkLnRvTG93ZXJDYXNlKCkpID8gJ3RlbXBvcmFsJyA6ICdxdWFudGl0YXRpdmUnO1xuICB9XG5cbiAgcmV0dXJuICdub21pbmFsJztcbn0iLCJpbXBvcnQgeyBpc0ZpZWxkRGVmLCBpc1ZhbHVlRGVmLCBpc1R5cGVkRmllbGREZWYgfSBmcm9tICcuLi90eXBlR3VhcmRzL0NoYW5uZWxEZWYnO1xuaW1wb3J0IGNvbXBsZXRlQXhpc0NvbmZpZyBmcm9tICcuL2NvbXBsZXRlQXhpc0NvbmZpZyc7XG5pbXBvcnQgY29tcGxldGVGb3JtYXRDb25maWcgZnJvbSAnLi9jb21wbGV0ZUZvcm1hdENvbmZpZyc7XG5pbXBvcnQgY29tcGxldGVMZWdlbmRDb25maWcgZnJvbSAnLi9jb21wbGV0ZUxlZ2VuZENvbmZpZyc7XG5pbXBvcnQgY29tcGxldGVTY2FsZUNvbmZpZyBmcm9tICcuL2NvbXBsZXRlU2NhbGVDb25maWcnO1xuaW1wb3J0IGluZmVyRmllbGRUeXBlIGZyb20gJy4vaW5mZXJGaWVsZFR5cGUnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcGxldGVDaGFubmVsRGVmKGNoYW5uZWxUeXBlLCBjaGFubmVsRGVmKSB7XG4gIHZhciBfY2hhbm5lbERlZiR0aXRsZTtcblxuICBpZiAoaXNWYWx1ZURlZihjaGFubmVsRGVmKSkge1xuICAgIHJldHVybiB7IC4uLmNoYW5uZWxEZWYsXG4gICAgICBheGlzOiBmYWxzZSxcbiAgICAgIGxlZ2VuZDogZmFsc2UsXG4gICAgICBzY2FsZTogZmFsc2UsXG4gICAgICB0aXRsZTogJydcbiAgICB9O1xuICB9IC8vIEZpbGwgdG9wLWxldmVsIHByb3BlcnRpZXNcblxuXG4gIGNvbnN0IGNvcHkgPSB7IC4uLmNoYW5uZWxEZWYsXG4gICAgdGl0bGU6IGlzRmllbGREZWYoY2hhbm5lbERlZikgPyAoX2NoYW5uZWxEZWYkdGl0bGUgPSBjaGFubmVsRGVmLnRpdGxlKSAhPSBudWxsID8gX2NoYW5uZWxEZWYkdGl0bGUgOiBjaGFubmVsRGVmLmZpZWxkIDogJycsXG4gICAgdHlwZTogaXNUeXBlZEZpZWxkRGVmKGNoYW5uZWxEZWYpID8gY2hhbm5lbERlZi50eXBlIDogaW5mZXJGaWVsZFR5cGUoY2hhbm5lbFR5cGUsIGNoYW5uZWxEZWYuZmllbGQpXG4gIH07IC8vIFNjYWxlIG5lZWRzIHRoZSB0b3AtbGV2ZWwgcHJvcGVydGllcyB0byBiZSBmaWxsZWQuXG5cbiAgY29uc3Qgc2NhbGUgPSBjb21wbGV0ZVNjYWxlQ29uZmlnKGNoYW5uZWxUeXBlLCBjb3B5KTsgLy8gRm9ybWF0IG5lZWRzIHNjYWxlLlxuXG4gIGNvbnN0IGZvcm1hdCA9IGNvbXBsZXRlRm9ybWF0Q29uZmlnKHsgLi4uY2hhbm5lbERlZixcbiAgICBzY2FsZVR5cGU6IHNjYWxlID8gc2NhbGUudHlwZSA6IHVuZGVmaW5lZFxuICB9KTtcbiAgY29uc3QgY29weTIgPSB7IC4uLmNvcHksXG4gICAgLi4uZm9ybWF0LFxuICAgIHNjYWxlXG4gIH07IC8vIFRoZXNlIG5lZWQgc2NhbGUgYW5kIGZvcm1hdFxuXG4gIGNvbnN0IGF4aXMgPSBjb21wbGV0ZUF4aXNDb25maWcoY2hhbm5lbFR5cGUsIGNvcHkyKTtcbiAgY29uc3QgbGVnZW5kID0gY29tcGxldGVMZWdlbmRDb25maWcoY2hhbm5lbFR5cGUsIGNvcHkyKTtcbiAgcmV0dXJuIHsgLi4uY29weTIsXG4gICAgYXhpcyxcbiAgICBsZWdlbmRcbiAgfTtcbn0iLCJpbXBvcnQgeyBzY2FsZUxpbmVhciwgc2NhbGVMb2csIHNjYWxlUG93LCBzY2FsZVNxcnQsIHNjYWxlVGltZSwgc2NhbGVVdGMsIHNjYWxlUXVhbnRpbGUsIHNjYWxlUXVhbnRpemUsIHNjYWxlVGhyZXNob2xkLCBzY2FsZU9yZGluYWwsIHNjYWxlUG9pbnQsIHNjYWxlQmFuZCwgc2NhbGVTeW1sb2cgfSBmcm9tICdkMy1zY2FsZSc7XG5pbXBvcnQgeyBTY2FsZVR5cGUgfSBmcm9tICcuLi8uLi90eXBlcyc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVTY2FsZUZyb21TY2FsZVR5cGUodHlwZSkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFNjYWxlVHlwZS5MSU5FQVI6XG4gICAgICByZXR1cm4gc2NhbGVMaW5lYXIoKTtcblxuICAgIGNhc2UgU2NhbGVUeXBlLkxPRzpcbiAgICAgIHJldHVybiBzY2FsZUxvZygpO1xuXG4gICAgY2FzZSBTY2FsZVR5cGUuUE9XOlxuICAgICAgcmV0dXJuIHNjYWxlUG93KCk7XG5cbiAgICBjYXNlIFNjYWxlVHlwZS5TUVJUOlxuICAgICAgcmV0dXJuIHNjYWxlU3FydCgpO1xuXG4gICAgY2FzZSBTY2FsZVR5cGUuVElNRTpcbiAgICAgIHJldHVybiBzY2FsZVRpbWUoKTtcblxuICAgIGNhc2UgU2NhbGVUeXBlLlVUQzpcbiAgICAgIHJldHVybiBzY2FsZVV0YygpO1xuXG4gICAgY2FzZSBTY2FsZVR5cGUuUVVBTlRJTEU6XG4gICAgICByZXR1cm4gc2NhbGVRdWFudGlsZSgpO1xuXG4gICAgY2FzZSBTY2FsZVR5cGUuUVVBTlRJWkU6XG4gICAgICByZXR1cm4gc2NhbGVRdWFudGl6ZSgpO1xuXG4gICAgY2FzZSBTY2FsZVR5cGUuVEhSRVNIT0xEOlxuICAgICAgcmV0dXJuIHNjYWxlVGhyZXNob2xkKCk7XG5cbiAgICBjYXNlIFNjYWxlVHlwZS5PUkRJTkFMOlxuICAgICAgcmV0dXJuIHNjYWxlT3JkaW5hbCgpO1xuXG4gICAgY2FzZSBTY2FsZVR5cGUuUE9JTlQ6XG4gICAgICByZXR1cm4gc2NhbGVQb2ludCgpO1xuXG4gICAgY2FzZSBTY2FsZVR5cGUuQkFORDpcbiAgICAgIHJldHVybiBzY2FsZUJhbmQoKTtcblxuICAgIGNhc2UgU2NhbGVUeXBlLlNZTUxPRzpcbiAgICAgIHJldHVybiBzY2FsZVN5bWxvZygpO1xuXG4gICAgY2FzZSBTY2FsZVR5cGUuQklOX09SRElOQUw6XG4gICAgICAvLyBUT0RPOiBQZW5kaW5nIHNjYWxlLmJpbnMgaW1wbGVtZW50YXRpb25cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlxcXCJ0eXBlID0gXCIgKyB0eXBlICsgXCJcXFwiIGlzIG5vdCBzdXBwb3J0ZWQgeWV0LlwiKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc2NhbGVMaW5lYXIoKTtcbiAgfVxufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFwcGx5QWxpZ24oY29uZmlnLCBzY2FsZSkge1xuICBpZiAoJ2FsaWduJyBpbiBjb25maWcgJiYgdHlwZW9mIGNvbmZpZy5hbGlnbiAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2FsaWduJyBpbiBzY2FsZSkge1xuICAgIHNjYWxlLmFsaWduKGNvbmZpZy5hbGlnbik7XG4gIH1cbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhcHBseUJhc2UoY29uZmlnLCBzY2FsZSkge1xuICBpZiAoJ2Jhc2UnIGluIGNvbmZpZyAmJiB0eXBlb2YgY29uZmlnLmJhc2UgIT09ICd1bmRlZmluZWQnICYmICdiYXNlJyBpbiBzY2FsZSkge1xuICAgIHNjYWxlLmJhc2UoY29uZmlnLmJhc2UpO1xuICB9XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXBwbHlDbGFtcChjb25maWcsIHNjYWxlKSB7XG4gIGlmICgnY2xhbXAnIGluIGNvbmZpZyAmJiBjb25maWcuY2xhbXAgPT09IHRydWUgJiYgJ2NsYW1wJyBpbiBzY2FsZSkge1xuICAgIHNjYWxlLmNsYW1wKGNvbmZpZy5jbGFtcCk7XG4gIH1cbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhcHBseUV4cG9uZW50KGNvbmZpZywgc2NhbGUpIHtcbiAgaWYgKCdleHBvbmVudCcgaW4gY29uZmlnICYmIHR5cGVvZiBjb25maWcuZXhwb25lbnQgIT09ICd1bmRlZmluZWQnICYmICdleHBvbmVudCcgaW4gc2NhbGUpIHtcbiAgICBzY2FsZS5leHBvbmVudChjb25maWcuZXhwb25lbnQpO1xuICB9XG59IiwiaW1wb3J0IHsgdGltZVNlY29uZCwgdGltZU1pbnV0ZSwgdGltZUhvdXIsIHRpbWVEYXksIHRpbWVZZWFyLCB0aW1lTW9udGgsIHRpbWVXZWVrLCB1dGNTZWNvbmQsIHV0Y01pbnV0ZSwgdXRjSG91ciwgdXRjRGF5LCB1dGNXZWVrLCB1dGNNb250aCwgdXRjWWVhciB9IGZyb20gJ2QzLXRpbWUnO1xuaW1wb3J0IHsgU2NhbGVUeXBlIH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuY29uc3QgbG9jYWxUaW1lSW50ZXJ2YWxzID0ge1xuICBkYXk6IHRpbWVEYXksXG4gIGhvdXI6IHRpbWVIb3VyLFxuICBtaW51dGU6IHRpbWVNaW51dGUsXG4gIG1vbnRoOiB0aW1lTW9udGgsXG4gIHNlY29uZDogdGltZVNlY29uZCxcbiAgd2VlazogdGltZVdlZWssXG4gIHllYXI6IHRpbWVZZWFyXG59O1xuY29uc3QgdXRjSW50ZXJ2YWxzID0ge1xuICBkYXk6IHV0Y0RheSxcbiAgaG91cjogdXRjSG91cixcbiAgbWludXRlOiB1dGNNaW51dGUsXG4gIG1vbnRoOiB1dGNNb250aCxcbiAgc2Vjb25kOiB1dGNTZWNvbmQsXG4gIHdlZWs6IHV0Y1dlZWssXG4gIHllYXI6IHV0Y1llYXJcbn07XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhcHBseU5pY2UoY29uZmlnLCBzY2FsZSkge1xuICBpZiAoJ25pY2UnIGluIGNvbmZpZyAmJiB0eXBlb2YgY29uZmlnLm5pY2UgIT09ICd1bmRlZmluZWQnICYmICduaWNlJyBpbiBzY2FsZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIG5pY2VcbiAgICB9ID0gY29uZmlnO1xuXG4gICAgaWYgKHR5cGVvZiBuaWNlID09PSAnYm9vbGVhbicpIHtcbiAgICAgIGlmIChuaWNlKSB7XG4gICAgICAgIHNjYWxlLm5pY2UoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBuaWNlID09PSAnbnVtYmVyJykge1xuICAgICAgc2NhbGUubmljZShuaWNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdGltZVNjYWxlID0gc2NhbGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHR5cGVcbiAgICAgIH0gPSBjb25maWc7XG5cbiAgICAgIGlmICh0eXBlb2YgbmljZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGltZVNjYWxlLm5pY2UodHlwZSA9PT0gU2NhbGVUeXBlLlVUQyA/IHV0Y0ludGVydmFsc1tuaWNlXSA6IGxvY2FsVGltZUludGVydmFsc1tuaWNlXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaW50ZXJ2YWwsXG4gICAgICAgICAgc3RlcFxuICAgICAgICB9ID0gbmljZTtcbiAgICAgICAgY29uc3QgcGFyc2VkSW50ZXJ2YWwgPSAodHlwZSA9PT0gU2NhbGVUeXBlLlVUQyA/IHV0Y0ludGVydmFsc1tpbnRlcnZhbF0gOiBsb2NhbFRpbWVJbnRlcnZhbHNbaW50ZXJ2YWxdKS5ldmVyeShzdGVwKTtcblxuICAgICAgICBpZiAocGFyc2VkSW50ZXJ2YWwgIT09IG51bGwpIHtcbiAgICAgICAgICB0aW1lU2NhbGUubmljZShwYXJzZWRJbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn0iLCJpbXBvcnQgeyB0aW1lU2NhbGVUeXBlc1NldCwgY29udGludW91c1NjYWxlVHlwZXNTZXQsIGRpc2NyZXRpemluZ1NjYWxlVHlwZXNTZXQsIGRpc2NyZXRlU2NhbGVUeXBlc1NldCB9IGZyb20gJy4uL3BhcnNlcnMvc2NhbGUvc2NhbGVDYXRlZ29yaWVzJztcbmV4cG9ydCBmdW5jdGlvbiBpc0NvbnRpbnVvdXNTY2FsZShzY2FsZSwgc2NhbGVUeXBlKSB7XG4gIHJldHVybiBzY2FsZSAmJiBjb250aW51b3VzU2NhbGVUeXBlc1NldC5oYXMoc2NhbGVUeXBlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0Rpc2NyZXRpemluZ1NjYWxlKHNjYWxlLCBzY2FsZVR5cGUpIHtcbiAgcmV0dXJuIHNjYWxlICYmIGRpc2NyZXRpemluZ1NjYWxlVHlwZXNTZXQuaGFzKHNjYWxlVHlwZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNEaXNjcmV0ZVNjYWxlKHNjYWxlLCBzY2FsZVR5cGUpIHtcbiAgcmV0dXJuIHNjYWxlICYmIGRpc2NyZXRlU2NhbGVUeXBlc1NldC5oYXMoc2NhbGVUeXBlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1RpbWVTY2FsZShzY2FsZSwgc2NhbGVUeXBlKSB7XG4gIHJldHVybiBzY2FsZSAmJiB0aW1lU2NhbGVUeXBlc1NldC5oYXMoc2NhbGVUeXBlKTtcbn0iLCJpbXBvcnQgeyBpc0NvbnRpbnVvdXNTY2FsZSB9IGZyb20gJy4uLy4uL3R5cGVHdWFyZHMvU2NhbGUnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXBwbHlaZXJvKGNvbmZpZywgc2NhbGUpIHtcbiAgaWYgKCd6ZXJvJyBpbiBjb25maWcgJiYgY29uZmlnLnplcm8gPT09IHRydWUgJiYgaXNDb250aW51b3VzU2NhbGUoc2NhbGUsIGNvbmZpZy50eXBlKSkge1xuICAgIGNvbnN0IGRvbWFpbiA9IHNjYWxlLmRvbWFpbigpO1xuICAgIGNvbnN0IFthLCBiXSA9IGRvbWFpbjtcbiAgICBjb25zdCBpc0Rlc2NlbmRpbmcgPSBiIDwgYTtcbiAgICBjb25zdCBbbWluLCBtYXhdID0gaXNEZXNjZW5kaW5nID8gW2IsIGFdIDogW2EsIGJdO1xuICAgIGNvbnN0IGRvbWFpbldpdGhaZXJvID0gW01hdGgubWluKDAsIG1pbiksIE1hdGgubWF4KDAsIG1heCldO1xuICAgIHNjYWxlLmRvbWFpbihpc0Rlc2NlbmRpbmcgPyBkb21haW5XaXRoWmVyby5yZXZlcnNlKCkgOiBkb21haW5XaXRoWmVybyk7XG4gIH1cbn0iLCJpbXBvcnQgeyBpbnRlcnBvbGF0ZVJnYiwgaW50ZXJwb2xhdGVMYWIsIGludGVycG9sYXRlSGNsLCBpbnRlcnBvbGF0ZUhjbExvbmcsIGludGVycG9sYXRlSHNsLCBpbnRlcnBvbGF0ZUhzbExvbmcsIGludGVycG9sYXRlQ3ViZWhlbGl4LCBpbnRlcnBvbGF0ZUN1YmVoZWxpeExvbmcgfSBmcm9tICdkMy1pbnRlcnBvbGF0ZSc7XG5jb25zdCBpbnRlcnBvbGF0b3JNYXAgPSB7XG4gIGxhYjogaW50ZXJwb2xhdGVMYWIsXG4gIGhjbDogaW50ZXJwb2xhdGVIY2wsXG4gICdoY2wtbG9uZyc6IGludGVycG9sYXRlSGNsTG9uZyxcbiAgaHNsOiBpbnRlcnBvbGF0ZUhzbCxcbiAgJ2hzbC1sb25nJzogaW50ZXJwb2xhdGVIc2xMb25nLFxuICBjdWJlaGVsaXg6IGludGVycG9sYXRlQ3ViZWhlbGl4LFxuICAnY3ViZWhlbGl4LWxvbmcnOiBpbnRlcnBvbGF0ZUN1YmVoZWxpeExvbmcsXG4gIHJnYjogaW50ZXJwb2xhdGVSZ2Jcbn07XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVDb2xvckludGVycG9sYXRvcihpbnRlcnBvbGF0ZSkge1xuICBzd2l0Y2ggKGludGVycG9sYXRlKSB7XG4gICAgY2FzZSAnbGFiJzpcbiAgICBjYXNlICdoY2wnOlxuICAgIGNhc2UgJ2hjbC1sb25nJzpcbiAgICBjYXNlICdoc2wnOlxuICAgIGNhc2UgJ2hzbC1sb25nJzpcbiAgICBjYXNlICdjdWJlaGVsaXgnOlxuICAgIGNhc2UgJ2N1YmVoZWxpeC1sb25nJzpcbiAgICBjYXNlICdyZ2InOlxuICAgICAgcmV0dXJuIGludGVycG9sYXRvck1hcFtpbnRlcnBvbGF0ZV07XG5cbiAgICBkZWZhdWx0OlxuICB9XG5cbiAgY29uc3Qge1xuICAgIHR5cGUsXG4gICAgZ2FtbWFcbiAgfSA9IGludGVycG9sYXRlO1xuICBjb25zdCBpbnRlcnBvbGF0b3IgPSBpbnRlcnBvbGF0b3JNYXBbdHlwZV07XG4gIHJldHVybiB0eXBlb2YgZ2FtbWEgPT09ICd1bmRlZmluZWQnID8gaW50ZXJwb2xhdG9yIDogaW50ZXJwb2xhdG9yLmdhbW1hKGdhbW1hKTtcbn0iLCJpbXBvcnQgY3JlYXRlQ29sb3JJbnRlcnBvbGF0b3IgZnJvbSAnLi9jcmVhdGVDb2xvckludGVycG9sYXRvcic7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhcHBseUludGVycG9sYXRlKGNvbmZpZywgc2NhbGUpIHtcbiAgaWYgKCdpbnRlcnBvbGF0ZScgaW4gY29uZmlnICYmIHR5cGVvZiBjb25maWcuaW50ZXJwb2xhdGUgIT09ICd1bmRlZmluZWQnICYmICdpbnRlcnBvbGF0ZScgaW4gc2NhbGUpIHtcbiAgICBzY2FsZS5pbnRlcnBvbGF0ZShjcmVhdGVDb2xvckludGVycG9sYXRvcihjb25maWcuaW50ZXJwb2xhdGUpKTtcbiAgfVxufSIsImltcG9ydCB7IGludGVycG9sYXRlUm91bmQgfSBmcm9tICdkMy1pbnRlcnBvbGF0ZSc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhcHBseVJvdW5kKGNvbmZpZywgc2NhbGUpIHtcbiAgaWYgKCdyb3VuZCcgaW4gY29uZmlnICYmIGNvbmZpZy5yb3VuZCA9PT0gdHJ1ZSkge1xuICAgIGNvbnN0IHJvdW5kYWJsZVNjYWxlID0gc2NhbGU7XG5cbiAgICBpZiAoJ3JvdW5kJyBpbiByb3VuZGFibGVTY2FsZSkge1xuICAgICAgcm91bmRhYmxlU2NhbGUucm91bmQoY29uZmlnLnJvdW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm91bmRhYmxlU2NhbGUuaW50ZXJwb2xhdGUoaW50ZXJwb2xhdGVSb3VuZCk7XG4gICAgfVxuICB9XG59IiwiaW1wb3J0IHsgdGltZVNjYWxlVHlwZXNTZXQgfSBmcm9tICcuLi9zY2FsZS9zY2FsZUNhdGVnb3JpZXMnO1xuLyoqXG4gKiBDb252ZXJ0IGVhY2ggZWxlbWVudCBpbiB0aGUgYXJyYXkgaW50b1xuICogLSBEYXRlIChmb3IgdGltZSBzY2FsZXMpXG4gKiAtIG51bWJlciAoZm9yIG90aGVyIGNvbnRpbnVvdXMgc2NhbGVzKVxuICogQHBhcmFtIGRvbWFpblxuICogQHBhcmFtIHNjYWxlVHlwZVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHBhcnNlQ29udGludW91c0RvbWFpbihkb21haW4sIHNjYWxlVHlwZSkge1xuICBpZiAodGltZVNjYWxlVHlwZXNTZXQuaGFzKHNjYWxlVHlwZSkpIHtcbiAgICByZXR1cm4gZG9tYWluLmZpbHRlcihkID0+IHR5cGVvZiBkICE9PSAnYm9vbGVhbicpLm1hcChkID0+IHR5cGVvZiBkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgZCA9PT0gJ251bWJlcicgPyBuZXcgRGF0ZShkKSA6IGQpO1xuICB9XG5cbiAgcmV0dXJuIGRvbWFpbi5tYXAoZCA9PiB0eXBlb2YgZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGQgPT09ICdib29sZWFuJyA/IE51bWJlcihkKSA6IGQpO1xufSIsIi8qKlxuICogRGlzY3JldGUgZG9tYWlucyBhcmUgY29udmVydGVkIGludG8gc3RyaW5nW11cbiAqIHdoZW4gdXNpbmcgRDMgc2NhbGVzXG4gKiBAcGFyYW0gZG9tYWluXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHBhcnNlRGlzY3JldGVEb21haW4oZG9tYWluKSB7XG4gIHJldHVybiBkb21haW4ubWFwKGQgPT4gXCJcIiArIGQpO1xufSIsIi8qKlxuICogQ29tYmluZSB0d28gYXJyYXlzIGludG8gYSB1bmlxdWUgbGlzdFxuICogYnkga2VlcGluZyB0aGUgb3JkZXIgdGhlIGZpeGVkQ2F0ZWdvcmllc1xuICogYW5kIGFwcGVuZCBuZXcgY2F0ZWdvcmllcyBhdCB0aGUgZW5kLlxuICogQHBhcmFtIGZpeGVkQ2F0ZWdvcmllc1xuICogQHBhcmFtIGlucHV0Q2F0ZWdvcmllc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21iaW5lQ2F0ZWdvcmllcyhmaXhlZENhdGVnb3JpZXMsIGlucHV0Q2F0ZWdvcmllcyA9IFtdKSB7XG4gIGlmIChmaXhlZENhdGVnb3JpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGlucHV0Q2F0ZWdvcmllcztcbiAgfVxuXG4gIGNvbnN0IGZpeGVkU2V0ID0gbmV3IFNldChmaXhlZENhdGVnb3JpZXMpO1xuICByZXR1cm4gZml4ZWRDYXRlZ29yaWVzLmNvbmNhdChpbnB1dENhdGVnb3JpZXMuZmlsdGVyKGQgPT4gIWZpeGVkU2V0LmhhcyhkKSkpO1xufSIsImltcG9ydCB7IGlzRXZlcnlFbGVtZW50RGVmaW5lZCwgaXNEZWZpbmVkIH0gZnJvbSAnLi4vdHlwZUd1YXJkcy9CYXNlJztcbi8qKlxuICogQ29tYmluZSB0d28gY29udGludW91cyBkb21haW4gYW5kIGVuc3VyZSB0aGF0IHRoZSBvdXRwdXRcbiAqIGRvZXMgbm90IGdvIGJleW9uZCBmaXhlZERvbWFpblxuICogQHBhcmFtIGJvdW5kc1xuICogQHBhcmFtIGRhdGFEb21haW5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21iaW5lQ29udGludW91c0RvbWFpbnMoYm91bmRzLCBkYXRhRG9tYWluKSB7XG4gIGlmIChib3VuZHMubGVuZ3RoID4gMCAmJiBpc0V2ZXJ5RWxlbWVudERlZmluZWQoYm91bmRzKSkge1xuICAgIHJldHVybiBib3VuZHM7XG4gIH1cblxuICBpZiAoYm91bmRzLmxlbmd0aCA9PT0gMiAmJiBkYXRhRG9tYWluLmxlbmd0aCA9PT0gMiAmJiBib3VuZHMuZmlsdGVyKGlzRGVmaW5lZCkubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IFtib3VuZE1pbiwgYm91bmRNYXhdID0gYm91bmRzO1xuICAgIGNvbnN0IFtkYXRhTWluLCBkYXRhTWF4XSA9IGRhdGFEb21haW47XG4gICAgbGV0IG1pbiA9IGRhdGFNaW47XG5cbiAgICBpZiAoaXNEZWZpbmVkKGJvdW5kTWluKSkge1xuICAgICAgbWluID0gYm91bmRNaW4udmFsdWVPZigpID4gZGF0YU1pbi52YWx1ZU9mKCkgPyBib3VuZE1pbiA6IGRhdGFNaW47XG4gICAgfVxuXG4gICAgbGV0IG1heCA9IGRhdGFNYXg7XG5cbiAgICBpZiAoaXNEZWZpbmVkKGJvdW5kTWF4KSkge1xuICAgICAgbWF4ID0gYm91bmRNYXgudmFsdWVPZigpIDwgZGF0YU1heC52YWx1ZU9mKCkgPyBib3VuZE1heCA6IGRhdGFNYXg7XG4gICAgfVxuXG4gICAgcmV0dXJuIFttaW4sIG1heF07XG4gIH1cblxuICByZXR1cm4gZGF0YURvbWFpbjtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZW1vdmVVbmRlZmluZWRBbmROdWxsKGFycmF5KSB7XG4gIHJldHVybiBhcnJheS5maWx0ZXIoeCA9PiB0eXBlb2YgeCAhPT0gJ3VuZGVmaW5lZCcgJiYgeCAhPT0gbnVsbCk7XG59IiwiaW1wb3J0IHsgaXNEYXRlVGltZSB9IGZyb20gJy4uL3R5cGVHdWFyZHMvRGF0ZVRpbWUnO1xuaW1wb3J0IHBhcnNlRGF0ZVRpbWUgZnJvbSAnLi9wYXJzZURhdGVUaW1lJztcbi8qKlxuICogT25seSBwYXJzZSBlbGVtZW50cyB0aGF0IGFyZSBEYXRlVGltZSB0byBEYXRlLlxuICogTGVhdmUgdGhlIHJlc3QgYWxvbmUuXG4gKiBAcGFyYW0gYXJyYXlcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwYXJzZURhdGVUaW1lSW4oYXJyYXkpIHtcbiAgcmV0dXJuIGFycmF5Lm1hcChkID0+ICEoZCBpbnN0YW5jZW9mIERhdGUpICYmIGlzRGF0ZVRpbWUoZCkgPyBwYXJzZURhdGVUaW1lKGQpIDogZCk7XG59IiwiaW1wb3J0IHsgaXNDb250aW51b3VzU2NhbGUsIGlzRGlzY3JldGl6aW5nU2NhbGUsIGlzRGlzY3JldGVTY2FsZSB9IGZyb20gJy4uLy4uL3R5cGVHdWFyZHMvU2NhbGUnO1xuaW1wb3J0IHsgaXNDb250aW51b3VzU2NhbGVDb25maWcsIGlzRGlzY3JldGl6aW5nU2NhbGVDb25maWcsIGlzRGlzY3JldGVTY2FsZUNvbmZpZyB9IGZyb20gJy4uLy4uL3R5cGVHdWFyZHMvU2NhbGVDb25maWcnO1xuaW1wb3J0IHBhcnNlQ29udGludW91c0RvbWFpbiBmcm9tICcuLi9kb21haW4vcGFyc2VDb250aW51b3VzRG9tYWluJztcbmltcG9ydCBwYXJzZURpc2NyZXRlRG9tYWluIGZyb20gJy4uL2RvbWFpbi9wYXJzZURpc2NyZXRlRG9tYWluJztcbmltcG9ydCBjb21iaW5lQ2F0ZWdvcmllcyBmcm9tICcuLi8uLi91dGlscy9jb21iaW5lQ2F0ZWdvcmllcyc7XG5pbXBvcnQgY29tYmluZUNvbnRpbnVvdXNEb21haW5zIGZyb20gJy4uLy4uL3V0aWxzL2NvbWJpbmVDb250aW51b3VzRG9tYWlucyc7XG5pbXBvcnQgcmVtb3ZlVW5kZWZpbmVkQW5kTnVsbCBmcm9tICcuLi8uLi91dGlscy9yZW1vdmVVbmRlZmluZWRBbmROdWxsJztcbmltcG9ydCBwYXJzZURhdGVUaW1lSW4gZnJvbSAnLi4vcGFyc2VEYXRlVGltZUluJztcblxuZnVuY3Rpb24gY3JlYXRlT3JkZXJGdW5jdGlvbihyZXZlcnNlKSB7XG4gIHJldHVybiByZXZlcnNlID8gYXJyYXkgPT4gYXJyYXkuY29uY2F0KCkucmV2ZXJzZSgpIDogYXJyYXkgPT4gYXJyYXk7XG59XG5cbmZ1bmN0aW9uIGlzQ29tcGxldGVEb21haW4oZG9tYWluKSB7XG4gIHJldHVybiBkb21haW4ubGVuZ3RoICE9PSAyIHx8IGRvbWFpblswXSAhPSBudWxsICYmIGRvbWFpblsxXSAhPSBudWxsO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhcHBseURvbWFpbihjb25maWcsIHNjYWxlLFxuLyoqIGRvbWFpbiBmcm9tIGRhdGFzZXQgKi9cbmRhdGFEb21haW4pIHtcbiAgY29uc3Qge1xuICAgIHJldmVyc2UsXG4gICAgdHlwZVxuICB9ID0gY29uZmlnO1xuICBjb25zdCBvcmRlciA9IGNyZWF0ZU9yZGVyRnVuY3Rpb24ocmV2ZXJzZSk7XG5cbiAgaWYgKGlzQ29udGludW91c1NjYWxlKHNjYWxlLCB0eXBlKSAmJiBpc0NvbnRpbnVvdXNTY2FsZUNvbmZpZyhjb25maWcpIHx8IGlzRGlzY3JldGl6aW5nU2NhbGUoc2NhbGUsIHR5cGUpICYmIGlzRGlzY3JldGl6aW5nU2NhbGVDb25maWcoY29uZmlnKSkge1xuICAgIC8vIEZvciBjb250aW51b3VzIGFuZCBkaXNjcmV0aXppbmcgc2NhbGVzXG4gICAgaWYgKGNvbmZpZy5kb21haW4pIHtcbiAgICAgIC8vIElmIGNvbmZpZy5kb21haW4gaXMgc3BlY2lmaWVkXG4gICAgICBpZiAoaXNDb21wbGV0ZURvbWFpbihjb25maWcuZG9tYWluKSkge1xuICAgICAgICAvLyBJZiB0aGUgY29uZmlnLmRvbWFpbiBpcyBjb21wbGV0ZWRcbiAgICAgICAgLy8gaWdub3JlcyB0aGUgZGF0YURvbWFpblxuICAgICAgICBzY2FsZS5kb21haW4ob3JkZXIocGFyc2VEYXRlVGltZUluKGNvbmZpZy5kb21haW4pKSk7XG4gICAgICB9IGVsc2UgaWYgKGRhdGFEb21haW4pIHtcbiAgICAgICAgLy8gSWYgaXQgaXMgaW5jb21wbGV0ZWQsIHRoZW4gdHJ5IHRvIGNvbWJpbmVcbiAgICAgICAgLy8gd2l0aCB0aGUgZGF0YURvbWFpblxuICAgICAgICBzY2FsZS5kb21haW4ob3JkZXIoY29tYmluZUNvbnRpbnVvdXNEb21haW5zKHBhcnNlQ29udGludW91c0RvbWFpbihwYXJzZURhdGVUaW1lSW4oY29uZmlnLmRvbWFpbiksIHR5cGUpLCBwYXJzZUNvbnRpbnVvdXNEb21haW4ocmVtb3ZlVW5kZWZpbmVkQW5kTnVsbChkYXRhRG9tYWluKSwgdHlwZSkpKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkYXRhRG9tYWluKSB7XG4gICAgICAvLyBJZiBubyBjb25maWcuZG9tYWluIHRoZW4ganVzdCB1c2UgdGhlIGRhdGFEb21haW4gaWYgYW55XG4gICAgICBzY2FsZS5kb21haW4ob3JkZXIocGFyc2VDb250aW51b3VzRG9tYWluKHJlbW92ZVVuZGVmaW5lZEFuZE51bGwoZGF0YURvbWFpbiksIHR5cGUpKSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRGlzY3JldGVTY2FsZShzY2FsZSwgdHlwZSkgJiYgaXNEaXNjcmV0ZVNjYWxlQ29uZmlnKGNvbmZpZykpIHtcbiAgICAvLyBGb3IgZGlzY3JldGUgc2NhbGVzXG4gICAgaWYgKGNvbmZpZy5kb21haW4pIHtcbiAgICAgIGNvbnN0IGZpeGVkRG9tYWluID0gcGFyc2VEaXNjcmV0ZURvbWFpbihwYXJzZURhdGVUaW1lSW4oY29uZmlnLmRvbWFpbikpO1xuICAgICAgc2NhbGUuZG9tYWluKG9yZGVyKGRhdGFEb21haW4gPyBjb21iaW5lQ2F0ZWdvcmllcyhmaXhlZERvbWFpbiwgcGFyc2VEaXNjcmV0ZURvbWFpbihkYXRhRG9tYWluKSkgOiBmaXhlZERvbWFpbikpO1xuICAgIH0gZWxzZSBpZiAoZGF0YURvbWFpbikge1xuICAgICAgLy8gSWYgbm8gY29uZmlnLmRvbWFpbiB0aGVuIGp1c3QgdXNlIHRoZSBkYXRhRG9tYWluIGlmIGFueVxuICAgICAgc2NhbGUuZG9tYWluKG9yZGVyKHBhcnNlRGlzY3JldGVEb21haW4oZGF0YURvbWFpbikpKTtcbiAgICB9XG4gIH1cbn0iLCIvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L3ByZWZlci1kZWZhdWx0LWV4cG9ydFxuZXhwb3J0IGZ1bmN0aW9uIGlzU2NoZW1lUGFyYW1zKHNjaGVtZSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHNjaGVtZSkgIT09ICdbb2JqZWN0IFN0cmluZ10nO1xufSIsImltcG9ydCB7IHdyYXBDb2xvclNjaGVtZSB9IGZyb20gJ0BlbmNvZGFibGUvY29sb3InO1xuaW1wb3J0IEVuY29kYWJsZSBmcm9tICcuLi8uLi9vcHRpb25zL0VuY29kYWJsZSc7XG5pbXBvcnQgeyBpc0NvbnRpbnVvdXNTY2FsZUNvbmZpZyB9IGZyb20gJy4uLy4uL3R5cGVHdWFyZHMvU2NhbGVDb25maWcnO1xuaW1wb3J0IHsgaXNTY2hlbWVQYXJhbXMgfSBmcm9tICcuLi8uLi90eXBlR3VhcmRzL1NjaGVtZVBhcmFtcyc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhcHBseVJhbmdlKGNvbmZpZywgc2NhbGUpIHtcbiAgY29uc3Qge1xuICAgIHJhbmdlLFxuICAgIGRvbWFpblxuICB9ID0gY29uZmlnO1xuXG4gIGlmICh0eXBlb2YgcmFuZ2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKCdzY2hlbWUnIGluIGNvbmZpZyAmJiB0eXBlb2YgY29uZmlnLnNjaGVtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2NoZW1lXG4gICAgICB9ID0gY29uZmlnO1xuICAgICAgbGV0IG5hbWU7XG4gICAgICBsZXQgY291bnQ7XG5cbiAgICAgIGlmIChpc0NvbnRpbnVvdXNTY2FsZUNvbmZpZyhjb25maWcpICYmIGRvbWFpbikge1xuICAgICAgICBjb3VudCA9IGRvbWFpbi5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGxldCBleHRlbnQ7XG5cbiAgICAgIGlmIChpc1NjaGVtZVBhcmFtcyhzY2hlbWUpKSB7XG4gICAgICAgIG5hbWUgPSBzY2hlbWUubmFtZTtcblxuICAgICAgICBpZiAoc2NoZW1lLmNvdW50KSB7XG4gICAgICAgICAgY291bnQgPSBzY2hlbWUuY291bnQ7XG4gICAgICAgIH1cblxuICAgICAgICBleHRlbnQgPSBzY2hlbWUuZXh0ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmFtZSA9IHNjaGVtZTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2NoZW1lT2JqZWN0ID0gRW5jb2RhYmxlLnJlc29sdmVDb2xvclNjaGVtZSh7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHR5cGU6ICdzZXF1ZW50aWFsJ1xuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2Ygc2NoZW1lT2JqZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBzY2hlbWVPYmplY3QudHlwZSA9PT0gJ3NlcXVlbnRpYWwnKSB7XG4gICAgICAgIGNvbnN0IHdyYXBwZWRTY2hlbWUgPSB3cmFwQ29sb3JTY2hlbWUoc2NoZW1lT2JqZWN0KTtcbiAgICAgICAgc2NhbGUucmFuZ2Uod3JhcHBlZFNjaGVtZS5nZXRDb2xvcnMoY291bnQsIGV4dGVudCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBUT0RPOiBhZGQgdHlwZSBndWFyZCBzaG91bGQgZml4IHRoaXMgcHJvYmxlbVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBzY2FsZS5yYW5nZShyYW5nZSk7XG4gIH1cbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhcHBseVBhZGRpbmcoY29uZmlnLCBzY2FsZSkge1xuICBpZiAoJ3BhZGRpbmcnIGluIGNvbmZpZyAmJiB0eXBlb2YgY29uZmlnLnBhZGRpbmcgIT09ICd1bmRlZmluZWQnICYmICdwYWRkaW5nJyBpbiBzY2FsZSkge1xuICAgIHNjYWxlLnBhZGRpbmcoY29uZmlnLnBhZGRpbmcpO1xuICB9XG5cbiAgaWYgKCdwYWRkaW5nSW5uZXInIGluIGNvbmZpZyAmJiB0eXBlb2YgY29uZmlnLnBhZGRpbmdJbm5lciAhPT0gJ3VuZGVmaW5lZCcgJiYgJ3BhZGRpbmdJbm5lcicgaW4gc2NhbGUpIHtcbiAgICBzY2FsZS5wYWRkaW5nSW5uZXIoY29uZmlnLnBhZGRpbmdJbm5lcik7XG4gIH1cblxuICBpZiAoJ3BhZGRpbmdPdXRlcicgaW4gY29uZmlnICYmIHR5cGVvZiBjb25maWcucGFkZGluZ091dGVyICE9PSAndW5kZWZpbmVkJyAmJiAncGFkZGluZ091dGVyJyBpbiBzY2FsZSkge1xuICAgIHNjYWxlLnBhZGRpbmdPdXRlcihjb25maWcucGFkZGluZ091dGVyKTtcbiAgfVxufSIsImltcG9ydCBhcHBseUFsaWduIGZyb20gJy4vYXBwbHlBbGlnbic7XG5pbXBvcnQgYXBwbHlCYXNlIGZyb20gJy4vYXBwbHlCYXNlJztcbmltcG9ydCBhcHBseUNsYW1wIGZyb20gJy4vYXBwbHlDbGFtcCc7XG5pbXBvcnQgYXBwbHlFeHBvbmVudCBmcm9tICcuL2FwcGx5RXhwb25lbnQnO1xuaW1wb3J0IGFwcGx5TmljZSBmcm9tICcuL2FwcGx5TmljZSc7XG5pbXBvcnQgYXBwbHlaZXJvIGZyb20gJy4vYXBwbHlaZXJvJztcbmltcG9ydCBhcHBseUludGVycG9sYXRlIGZyb20gJy4vYXBwbHlJbnRlcnBvbGF0ZSc7XG5pbXBvcnQgYXBwbHlSb3VuZCBmcm9tICcuL2FwcGx5Um91bmQnO1xuaW1wb3J0IGFwcGx5RG9tYWluIGZyb20gJy4vYXBwbHlEb21haW4nO1xuaW1wb3J0IGFwcGx5UmFuZ2UgZnJvbSAnLi9hcHBseVJhbmdlJztcbmltcG9ydCBhcHBseVBhZGRpbmcgZnJvbSAnLi9hcHBseVBhZGRpbmcnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXBkYXRlU2NhbGUoc2NhbGUsIGNvbmZpZykge1xuICAvLyBkb21haW4gYW5kIHJhbmdlIGFwcGx5IHRvIGFsbCBzY2FsZXNcbiAgYXBwbHlEb21haW4oY29uZmlnLCBzY2FsZSk7XG4gIGFwcGx5UmFuZ2UoY29uZmlnLCBzY2FsZSk7IC8vIFNvcnQgb3RoZXIgcHJvcGVydGllcyBhbHBoYWJldGljYWxseS5cblxuICBhcHBseUFsaWduKGNvbmZpZywgc2NhbGUpO1xuICBhcHBseUJhc2UoY29uZmlnLCBzY2FsZSk7XG4gIGFwcGx5Q2xhbXAoY29uZmlnLCBzY2FsZSk7XG4gIGFwcGx5RXhwb25lbnQoY29uZmlnLCBzY2FsZSk7XG4gIGFwcGx5SW50ZXJwb2xhdGUoY29uZmlnLCBzY2FsZSk7IC8vIE5pY2UgZGVwZW5kcyBvbiBkb21haW4uXG5cbiAgYXBwbHlOaWNlKGNvbmZpZywgc2NhbGUpO1xuICBhcHBseVBhZGRpbmcoY29uZmlnLCBzY2FsZSk7XG4gIGFwcGx5Um91bmQoY29uZmlnLCBzY2FsZSk7IC8vIFplcm8gZGVwZW5kcyBvbiBkb21haW4gYW5kIG5pY2UuXG5cbiAgYXBwbHlaZXJvKGNvbmZpZywgc2NhbGUpO1xuICByZXR1cm4gc2NhbGU7XG59IiwiaW1wb3J0IHsgU2NhbGVUeXBlIH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuaW1wb3J0IGNyZWF0ZVNjYWxlRnJvbVNjYWxlVHlwZSBmcm9tICcuL2NyZWF0ZVNjYWxlRnJvbVNjYWxlVHlwZSc7XG5pbXBvcnQgdXBkYXRlU2NhbGUgZnJvbSAnLi91cGRhdGVTY2FsZSc7XG5pbXBvcnQgRW5jb2RhYmxlIGZyb20gJy4uLy4uL29wdGlvbnMvRW5jb2RhYmxlJztcbmltcG9ydCB7IGlzU2NoZW1lUGFyYW1zIH0gZnJvbSAnLi4vLi4vdHlwZUd1YXJkcy9TY2hlbWVQYXJhbXMnO1xuaW1wb3J0IGFwcGx5RG9tYWluIGZyb20gJy4vYXBwbHlEb21haW4nO1xuXG5mdW5jdGlvbiBjcmVhdGVTY2FsZShjb25maWcpIHtcbiAgY29uc3Qge1xuICAgIHJhbmdlXG4gIH0gPSBjb25maWc7IC8vIEhhbmRsZSBjYXRlZ29yaWNhbCBjb2xvciBzY2FsZXNcbiAgLy8gQW4gb3JkaW5hbCBzY2FsZSB3aXRob3V0IHNwZWNpZmllZCByYW5nZVxuICAvLyBpcyBhc3N1bWVkIHRvIGJlIGEgY29sb3Igc2NhbGUuXG5cbiAgaWYgKGNvbmZpZy50eXBlID09PSBTY2FsZVR5cGUuT1JESU5BTCAmJiB0eXBlb2YgcmFuZ2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc3Qgc2NoZW1lID0gJ3NjaGVtZScgaW4gY29uZmlnID8gY29uZmlnLnNjaGVtZSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCByZXNvbHZlID0gRW5jb2RhYmxlLmdldENhdGVnb3JpY2FsQ29sb3JTY2FsZVJlc29sdmVyKCk7XG4gICAgbGV0IGNvbG9yU2NhbGU7XG5cbiAgICBpZiAodHlwZW9mIHNjaGVtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbG9yU2NhbGUgPSByZXNvbHZlKHt9KTtcbiAgICB9IGVsc2UgaWYgKGlzU2NoZW1lUGFyYW1zKHNjaGVtZSkpIHtcbiAgICAgIGNvbG9yU2NhbGUgPSByZXNvbHZlKHNjaGVtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbG9yU2NhbGUgPSByZXNvbHZlKHtcbiAgICAgICAgbmFtZTogc2NoZW1lXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBjYXN0ZWRDb2xvclNjYWxlID0gY29sb3JTY2FsZTtcbiAgICBhcHBseURvbWFpbihjb25maWcsIGNhc3RlZENvbG9yU2NhbGUpO1xuICAgIHJldHVybiBjYXN0ZWRDb2xvclNjYWxlO1xuICB9XG5cbiAgY29uc3Qgc2NhbGUgPSBjcmVhdGVTY2FsZUZyb21TY2FsZVR5cGUoY29uZmlnLnR5cGUpO1xuICByZXR1cm4gdXBkYXRlU2NhbGUoc2NhbGUsIGNvbmZpZyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZVNjYWxlOyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlkZW50aXR5KHgpIHtcbiAgcmV0dXJuIHg7XG59IiwiZXhwb3J0IGZ1bmN0aW9uIGlzQ29tcGxldGVWYWx1ZURlZihkZWYpIHtcbiAgcmV0dXJuICd2YWx1ZScgaW4gZGVmO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQ29tcGxldGVGaWVsZERlZihkZWYpIHtcbiAgcmV0dXJuICdmaWVsZCcgaW4gZGVmO1xufSIsImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmltcG9ydCB7IGV4dGVudCBhcyBkM0V4dGVudCB9IGZyb20gJ2QzLWFycmF5JztcbmltcG9ydCB7IFNjYWxlVHlwZSB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGlzVHlwZWRGaWVsZERlZiwgaXNWYWx1ZURlZiwgaXNGaWVsZERlZiB9IGZyb20gJy4uL3R5cGVHdWFyZHMvQ2hhbm5lbERlZic7XG5pbXBvcnQgeyBpc1gsIGlzWSwgaXNYT3JZIH0gZnJvbSAnLi4vdHlwZUd1YXJkcy9DaGFubmVsJztcbmltcG9ydCBDaGFubmVsRW5jb2RlckF4aXMgZnJvbSAnLi9DaGFubmVsRW5jb2RlckF4aXMnO1xuaW1wb3J0IGNyZWF0ZUdldHRlckZyb21DaGFubmVsRGVmIGZyb20gJy4uL3BhcnNlcnMvY3JlYXRlR2V0dGVyRnJvbUNoYW5uZWxEZWYnO1xuaW1wb3J0IGNvbXBsZXRlQ2hhbm5lbERlZiBmcm9tICcuLi9maWxsZXJzL2NvbXBsZXRlQ2hhbm5lbERlZic7XG5pbXBvcnQgY3JlYXRlU2NhbGUgZnJvbSAnLi4vcGFyc2Vycy9zY2FsZS9jcmVhdGVTY2FsZSc7XG5pbXBvcnQgaWRlbnRpdHkgZnJvbSAnLi4vdXRpbHMvaWRlbnRpdHknO1xuaW1wb3J0IGFwcGx5RG9tYWluIGZyb20gJy4uL3BhcnNlcnMvc2NhbGUvYXBwbHlEb21haW4nO1xuaW1wb3J0IGFwcGx5UmFuZ2UgZnJvbSAnLi4vcGFyc2Vycy9zY2FsZS9hcHBseVJhbmdlJztcbmltcG9ydCBhcHBseVplcm8gZnJvbSAnLi4vcGFyc2Vycy9zY2FsZS9hcHBseVplcm8nO1xuaW1wb3J0IGFwcGx5TmljZSBmcm9tICcuLi9wYXJzZXJzL3NjYWxlL2FwcGx5TmljZSc7XG5pbXBvcnQgeyBpc0NvbXBsZXRlVmFsdWVEZWYsIGlzQ29tcGxldGVGaWVsZERlZiB9IGZyb20gJy4uL3R5cGVHdWFyZHMvQ29tcGxldGVDaGFubmVsRGVmJztcbmltcG9ydCBmYWxsYmFja0Zvcm1hdHRlciBmcm9tICcuLi9wYXJzZXJzL2Zvcm1hdC9mYWxsYmFja0Zvcm1hdHRlcic7XG5pbXBvcnQgY3JlYXRlRm9ybWF0dGVyIGZyb20gJy4uL3BhcnNlcnMvZm9ybWF0L2NyZWF0ZUZvcm1hdHRlcic7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaGFubmVsRW5jb2RlciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBuYW1lLFxuICAgIGNoYW5uZWxUeXBlLFxuICAgIGRlZmluaXRpb246IG9yaWdpbmFsRGVmaW5pdGlvblxuICB9KSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY2hhbm5lbFR5cGVcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9yaWdpbmFsRGVmaW5pdGlvblwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZGVmaW5pdGlvblwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic2NhbGVcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImF4aXNcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdldFZhbHVlXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJlbmNvZGVGdW5jXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJmb3JtYXRWYWx1ZVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZW5jb2RlVmFsdWVcIiwgKHZhbHVlLCBvdGhlcndpc2UpID0+IHtcbiAgICAgIGlmICh0eXBlb2Ygb3RoZXJ3aXNlICE9PSAndW5kZWZpbmVkJyAmJiAodmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyd2lzZTtcbiAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuXG4gICAgICByZXR1cm4gdGhpcy5lbmNvZGVGdW5jKHZhbHVlKTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVuY29kZURhdHVtXCIsIChkYXR1bSwgb3RoZXJ3aXNlKSA9PiB0eXBlb2Ygb3RoZXJ3aXNlID09PSAndW5kZWZpbmVkJyA/IHRoaXMuZW5jb2RlVmFsdWUodGhpcy5nZXRWYWx1ZUZyb21EYXR1bShkYXR1bSkpIDogdGhpcy5lbmNvZGVWYWx1ZSh0aGlzLmdldFZhbHVlRnJvbURhdHVtKGRhdHVtKSwgb3RoZXJ3aXNlKSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJmb3JtYXREYXR1bVwiLCBkYXR1bSA9PiB0aGlzLmZvcm1hdFZhbHVlKHRoaXMuZ2V0VmFsdWVGcm9tRGF0dW0oZGF0dW0pKSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJnZXRWYWx1ZUZyb21EYXR1bVwiLCAoZGF0dW0sIG90aGVyd2lzZSkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldFZhbHVlKGRhdHVtKTtcbiAgICAgIHJldHVybiBvdGhlcndpc2UgIT09IHVuZGVmaW5lZCAmJiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBvdGhlcndpc2UgOiB2YWx1ZTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdldERvbWFpbkZyb21EYXRhc2V0XCIsIGRhdGEgPT4ge1xuICAgICAgaWYgKGlzVmFsdWVEZWYodGhpcy5kZWZpbml0aW9uKSkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSA9IHRoaXMuZGVmaW5pdGlvbjtcbiAgICAgICAgcmV0dXJuIFt2YWx1ZV07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdHlwZVxuICAgICAgfSA9IHRoaXMuZGVmaW5pdGlvbjtcblxuICAgICAgaWYgKHR5cGUgPT09ICdub21pbmFsJyB8fCB0eXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChkYXRhLm1hcChkID0+IHRoaXMuZ2V0VmFsdWVGcm9tRGF0dW0oZCkpKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlID09PSAncXVhbnRpdGF0aXZlJykge1xuICAgICAgICAvLyBRdWFudGlsZSBzY2FsZSBuZWVkcyBhbGwgaXRlbXNcbiAgICAgICAgLy8gYmVjYXVzZSBpdCB0cmVhdHMgZG9tYWluIGFzIGEgZGlzY3JldGUgc2V0IG9mIHNhbXBsZSB2YWx1ZXNcbiAgICAgICAgLy8gZm9yIGNvbXB1dGluZyB0aGUgcXVhbnRpbGVzXG4gICAgICAgIGlmICh0aGlzLmRlZmluaXRpb24uc2NhbGUgJiYgdGhpcy5kZWZpbml0aW9uLnNjYWxlLnR5cGUgPT09ICdxdWFudGlsZScpIHtcbiAgICAgICAgICByZXR1cm4gZGF0YS5tYXAoZCA9PiB0aGlzLmdldFZhbHVlRnJvbURhdHVtKGQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGV4dGVudCA9IGQzRXh0ZW50KGRhdGEsIGQgPT4gdGhpcy5nZXRWYWx1ZUZyb21EYXR1bShkKSk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZXh0ZW50WzBdID09PSAndW5kZWZpbmVkJyA/IFswLCAxXSA6IGV4dGVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09ICd0ZW1wb3JhbCcpIHtcbiAgICAgICAgY29uc3QgZXh0ZW50ID0gZDNFeHRlbnQoZGF0YSwgZCA9PiB0aGlzLmdldFZhbHVlRnJvbURhdHVtKGQpKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBleHRlbnRbMF0gPT09ICd1bmRlZmluZWQnID8gWzAsIDFdIDogZXh0ZW50O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW107XG4gICAgfSk7XG5cbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuY2hhbm5lbFR5cGUgPSBjaGFubmVsVHlwZTtcbiAgICB0aGlzLm9yaWdpbmFsRGVmaW5pdGlvbiA9IG9yaWdpbmFsRGVmaW5pdGlvbjtcbiAgICB0aGlzLmRlZmluaXRpb24gPSBjb21wbGV0ZUNoYW5uZWxEZWYodGhpcy5jaGFubmVsVHlwZSwgb3JpZ2luYWxEZWZpbml0aW9uKTtcbiAgICB0aGlzLmdldFZhbHVlID0gY3JlYXRlR2V0dGVyRnJvbUNoYW5uZWxEZWYodGhpcy5kZWZpbml0aW9uKTtcbiAgICB0aGlzLmZvcm1hdFZhbHVlID0gaXNGaWVsZERlZih0aGlzLmRlZmluaXRpb24pID8gY3JlYXRlRm9ybWF0dGVyKHRoaXMuZGVmaW5pdGlvbikgOiBmYWxsYmFja0Zvcm1hdHRlcjtcblxuICAgIGlmICh0aGlzLmRlZmluaXRpb24uc2NhbGUpIHtcbiAgICAgIGNvbnN0IHNjYWxlID0gY3JlYXRlU2NhbGUodGhpcy5kZWZpbml0aW9uLnNjYWxlKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuICAgICAgdGhpcy5lbmNvZGVGdW5jID0gdmFsdWUgPT4gc2NhbGUodmFsdWUpO1xuXG4gICAgICB0aGlzLnNjYWxlID0gc2NhbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGVmaW5pdGlvblxuICAgICAgfSA9IHRoaXM7XG4gICAgICB0aGlzLmVuY29kZUZ1bmMgPSBpc0NvbXBsZXRlVmFsdWVEZWYoZGVmaW5pdGlvbikgPyAoKSA9PiBkZWZpbml0aW9uLnZhbHVlIDogaWRlbnRpdHk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZGVmaW5pdGlvbi5heGlzKSB7XG4gICAgICB0aGlzLmF4aXMgPSBuZXcgQ2hhbm5lbEVuY29kZXJBeGlzKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIGdldERvbWFpbigpIHtcbiAgICBpZiAodGhpcy5zY2FsZSAmJiAnZG9tYWluJyBpbiB0aGlzLnNjYWxlKSB7XG4gICAgICByZXR1cm4gdGhpcy5zY2FsZS5kb21haW4oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW107XG4gIH1cblxuICBzZXREb21haW4oZG9tYWluKSB7XG4gICAgaWYgKHRoaXMuZGVmaW5pdGlvbi5zY2FsZSAhPT0gZmFsc2UgJiYgdGhpcy5zY2FsZSAmJiAhdGhpcy5oYXNDYXRlZ29yaWNhbENvbG9yU2NhbGUoKSAmJiAnZG9tYWluJyBpbiB0aGlzLnNjYWxlKSB7XG4gICAgICBjb25zdCBjb25maWcgPSB0aGlzLmRlZmluaXRpb24uc2NhbGU7XG4gICAgICBhcHBseURvbWFpbihjb25maWcsIHRoaXMuc2NhbGUsIGRvbWFpbik7XG4gICAgICBhcHBseVJhbmdlKGNvbmZpZywgdGhpcy5zY2FsZSk7XG4gICAgICBhcHBseVplcm8oY29uZmlnLCB0aGlzLnNjYWxlKTtcbiAgICAgIGFwcGx5TmljZShjb25maWcsIHRoaXMuc2NhbGUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0RG9tYWluRnJvbURhdGFzZXQoZGF0YSkge1xuICAgIHJldHVybiB0aGlzLnNjYWxlICYmICdkb21haW4nIGluIHRoaXMuc2NhbGUgPyB0aGlzLnNldERvbWFpbih0aGlzLmdldERvbWFpbkZyb21EYXRhc2V0KGRhdGEpKSA6IHRoaXM7XG4gIH1cblxuICBnZXRUaXRsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZpbml0aW9uLnRpdGxlO1xuICB9XG5cbiAgaXNHcm91cEJ5KCkge1xuICAgIGlmIChpc1R5cGVkRmllbGREZWYodGhpcy5kZWZpbml0aW9uKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB0eXBlXG4gICAgICB9ID0gdGhpcy5kZWZpbml0aW9uO1xuICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbFR5cGUgPT09ICdDYXRlZ29yeScgfHwgdGhpcy5jaGFubmVsVHlwZSA9PT0gJ1RleHQnIHx8IHRoaXMuY2hhbm5lbFR5cGUgPT09ICdDb2xvcicgJiYgKHR5cGUgPT09ICdub21pbmFsJyB8fCB0eXBlID09PSAnb3JkaW5hbCcpIHx8IGlzWE9yWSh0aGlzLmNoYW5uZWxUeXBlKSAmJiAodHlwZSA9PT0gJ25vbWluYWwnIHx8IHR5cGUgPT09ICdvcmRpbmFsJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaXNYKCkge1xuICAgIHJldHVybiBpc1godGhpcy5jaGFubmVsVHlwZSk7XG4gIH1cblxuICBpc1hPclkoKSB7XG4gICAgcmV0dXJuIGlzWE9yWSh0aGlzLmNoYW5uZWxUeXBlKTtcbiAgfVxuXG4gIGlzWSgpIHtcbiAgICByZXR1cm4gaXNZKHRoaXMuY2hhbm5lbFR5cGUpO1xuICB9XG5cbiAgaGFzQ2F0ZWdvcmljYWxDb2xvclNjYWxlKCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuZGVmaW5pdGlvbi5zY2FsZTsgLy8gU2NhbGUgdHlwZSBpcyBvcmRpbmFsIHdpdGggbm90IGdpdmVuIHJhbmdlXG4gICAgLy8gKG1heSBoYXZlIG9wdGlvbmFsIHNjaGVtZSlcbiAgICAvLyB3aWxsIGJlY29tZSBhIGNhdGVnb3JpY2FsIHNjYWxlXG4gICAgLy8gb2YgbmFtZWQgY29sb3Igc2NoZW1lLlxuICAgIC8vIEEgY29sb3Igc2NhbGUgZnJvbSBuYW1lZCBjb2xvciBzY2hlbWUgbWF5IGJlIHNoYXJlZCBhbW9uZyBtdWx0aXBsZSBjb21wb25lbnRzXG4gICAgLy8gaW4gdGhlIHNhbWUgbmFtZXNwYWNlIGJ5IGRlZmF1bHQsIHNvIGNoYW5naW5nIGl0cyBkb21haW4gYWZmZWN0IGFsbCBjb21wb25lbnRzLlxuICAgIC8vIChTb3VuZHMgbGlrZSBhIGJhZCBpZGVhLilcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGN1cnJlbnRseSBvbmx5IGJlaW5nIHVzZWQgdG8gY2hlY2tcbiAgICAvLyB3aGV0aGVyIHRvIGFwcGx5IGRvbWFpbiBmcm9tIGRhdGFzZXQgb3Igbm90LlxuICAgIC8vIEFuIG9yZGluYWwgc2NhbGUgd2l0aCB1c2VyLXNwZWNpZmllZCBjb2xvciBzY2hlbWUgYXMgcmFuZ2UgYXJyYXlcbiAgICAvLyB3aWxsIHJldHVybiBmYWxzZSBmcm9tIHRoaXMgZnVuY3Rpb24gYW5kIGJlIGV4Y2x1ZGVkIGZyb20gaXQuXG5cbiAgICByZXR1cm4gdGhpcy5zY2FsZSAmJiBjb25maWcgJiYgY29uZmlnLnR5cGUgPT09IFNjYWxlVHlwZS5PUkRJTkFMICYmIHR5cGVvZiBjb25maWcucmFuZ2UgPT09ICd1bmRlZmluZWQnO1xuICB9XG5cbiAgaGFzTGVnZW5kKCkge1xuICAgIHJldHVybiB0aGlzLmRlZmluaXRpb24ubGVnZW5kICE9PSBmYWxzZTtcbiAgfVxuXG4gIGhhc1ZhbHVlRGVmaW5pdGlvbigpIHtcbiAgICByZXR1cm4gaXNDb21wbGV0ZVZhbHVlRGVmKHRoaXMuZGVmaW5pdGlvbik7XG4gIH1cblxuICBoYXNGaWVsZERlZmluaXRpb24oKSB7XG4gICAgcmV0dXJuIGlzQ29tcGxldGVGaWVsZERlZih0aGlzLmRlZmluaXRpb24pO1xuICB9XG5cbn0iLCJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5pbXBvcnQgeyBpc1R5cGVkRmllbGREZWYsIGlzVmFsdWVEZWYgfSBmcm9tICcuLi90eXBlR3VhcmRzL0NoYW5uZWxEZWYnO1xuaW1wb3J0IHsgaXNOb3RBcnJheSB9IGZyb20gJy4uL3R5cGVHdWFyZHMvQmFzZSc7XG5pbXBvcnQgQ2hhbm5lbEVuY29kZXIgZnJvbSAnLi9DaGFubmVsRW5jb2Rlcic7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbmNvZGVyIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGNoYW5uZWxUeXBlcyxcbiAgICBlbmNvZGluZ1xuICB9KSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZW5jb2RpbmdcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNoYW5uZWxUeXBlc1wiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY2hhbm5lbHNcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxlZ2VuZHNcIiwgdm9pZCAwKTtcblxuICAgIHRoaXMuY2hhbm5lbFR5cGVzID0gY2hhbm5lbFR5cGVzO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgICBjb25zdCBjaGFubmVsTmFtZXMgPSB0aGlzLmdldENoYW5uZWxOYW1lcygpOyAvLyBDcmVhdGUgY2hhbm5lbCBlbmNvZGVyc1xuXG4gICAgY29uc3QgY2hhbm5lbHMgPSB7fTtcbiAgICBjaGFubmVsTmFtZXMuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgIGNvbnN0IGNoYW5uZWxFbmNvZGluZyA9IGVuY29kaW5nW25hbWVdO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGFubmVsRW5jb2RpbmcpKSB7XG4gICAgICAgIGNvbnN0IGRlZmluaXRpb25zID0gY2hhbm5lbEVuY29kaW5nO1xuICAgICAgICBjaGFubmVsc1tuYW1lXSA9IGRlZmluaXRpb25zLm1hcCgoZGVmaW5pdGlvbiwgaSkgPT4gbmV3IENoYW5uZWxFbmNvZGVyKHtcbiAgICAgICAgICBjaGFubmVsVHlwZTogY2hhbm5lbFR5cGVzW25hbWVdLFxuICAgICAgICAgIGRlZmluaXRpb24sXG4gICAgICAgICAgbmFtZTogbmFtZSArIFwiW1wiICsgaSArIFwiXVwiXG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSBjaGFubmVsRW5jb2Rpbmc7XG4gICAgICAgIGNoYW5uZWxzW25hbWVdID0gbmV3IENoYW5uZWxFbmNvZGVyKHtcbiAgICAgICAgICBjaGFubmVsVHlwZTogY2hhbm5lbFR5cGVzW25hbWVdLFxuICAgICAgICAgIGRlZmluaXRpb24sXG4gICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmNoYW5uZWxzID0gY2hhbm5lbHM7IC8vIEdyb3VwIHRoZSBjaGFubmVscyB0aGF0IHVzZSB0aGUgc2FtZSBmaWVsZCB0b2dldGhlclxuICAgIC8vIHNvIHRoZXkgY2FuIHNoYXJlIHRoZSBzYW1lIGxlZ2VuZC5cblxuICAgIHRoaXMubGVnZW5kcyA9IHt9O1xuICAgIGNoYW5uZWxOYW1lcy5tYXAobmFtZSA9PiB0aGlzLmNoYW5uZWxzW25hbWVdKS5mb3JFYWNoKGMgPT4ge1xuICAgICAgaWYgKGlzTm90QXJyYXkoYykgJiYgYy5oYXNMZWdlbmQoKSAmJiBpc1R5cGVkRmllbGREZWYoYy5kZWZpbml0aW9uKSkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZmllbGRcbiAgICAgICAgfSA9IGMuZGVmaW5pdGlvbjtcbiAgICAgICAgY29uc3QgY2hhbm5lbEVuY29kZXIgPSBjO1xuXG4gICAgICAgIGlmICh0aGlzLmxlZ2VuZHNbZmllbGRdKSB7XG4gICAgICAgICAgdGhpcy5sZWdlbmRzW2ZpZWxkXS5wdXNoKGNoYW5uZWxFbmNvZGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxlZ2VuZHNbZmllbGRdID0gW2NoYW5uZWxFbmNvZGVyXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZ2V0Q2hhbm5lbE5hbWVzKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmNoYW5uZWxUeXBlcyk7XG4gIH1cblxuICBnZXRDaGFubmVsRW5jb2RlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q2hhbm5lbE5hbWVzKCkuZmxhdE1hcChuYW1lID0+IHRoaXMuY2hhbm5lbHNbbmFtZV0pO1xuICB9XG5cbiAgZ2V0R3JvdXBCeXMoKSB7XG4gICAgY29uc3QgZmllbGRzID0gdGhpcy5nZXRDaGFubmVsRW5jb2RlcnMoKS5maWx0ZXIoYyA9PiBjLmlzR3JvdXBCeSgpKS5tYXAoYyA9PiBjLmRlZmluaXRpb24uZmllbGQpO1xuICAgIHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQoZmllbGRzKSk7XG4gIH1cblxuICBjcmVhdGVMZWdlbmRJdGVtc0ZhY3RvcnkoZmllbGQpIHtcbiAgICBjb25zdCBjaGFubmVsRW5jb2RlcnMgPSB0aGlzLmdldENoYW5uZWxFbmNvZGVycygpLmZpbHRlcihlID0+IGlzTm90QXJyYXkoZSkgJiYgaXNWYWx1ZURlZihlLmRlZmluaXRpb24pKS5mbGF0KCkuY29uY2F0KHRoaXMubGVnZW5kc1tmaWVsZF0pO1xuICAgIHJldHVybiBkb21haW4gPT4gZG9tYWluLm1hcChpbnB1dCA9PiAoe1xuICAgICAgaW5wdXQsXG4gICAgICBvdXRwdXQ6IGNoYW5uZWxFbmNvZGVycy5yZWR1Y2UoKHByZXYsIGN1cnIpID0+IHtcbiAgICAgICAgY29uc3QgbWFwID0gcHJldjtcbiAgICAgICAgbWFwW2N1cnIubmFtZV0gPSBjdXJyLmVuY29kZVZhbHVlKGlucHV0KTtcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgIH0sIHt9KVxuICAgIH0pKTtcbiAgfVxuXG4gIGdldExlZ2VuZEluZm9ybWF0aW9uKGRhdGEgPSBbXSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmxlZ2VuZHMpIC8vIGZvciBlYWNoIGZpZWxkIHRoYXQgd2FzIGVuY29kZWRcbiAgICAubWFwKGZpZWxkID0+IHtcbiAgICAgIC8vIGdldCBhbGwgdGhlIGNoYW5uZWxzIHRoYXQgdXNlIHRoaXMgZmllbGRcbiAgICAgIGNvbnN0IGNoYW5uZWxFbmNvZGVycyA9IHRoaXMubGVnZW5kc1tmaWVsZF07XG4gICAgICBjb25zdCBmaXJzdEVuY29kZXIgPSBjaGFubmVsRW5jb2RlcnNbMF07XG4gICAgICBjb25zdCBkZWZpbml0aW9uID0gZmlyc3RFbmNvZGVyLmRlZmluaXRpb247XG4gICAgICBjb25zdCBjcmVhdGVMZWdlbmRJdGVtcyA9IHRoaXMuY3JlYXRlTGVnZW5kSXRlbXNGYWN0b3J5KGZpZWxkKTtcblxuICAgICAgaWYgKGRlZmluaXRpb24udHlwZSA9PT0gJ25vbWluYWwnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2hhbm5lbEVuY29kZXJzLFxuICAgICAgICAgIGNyZWF0ZUxlZ2VuZEl0ZW1zLFxuICAgICAgICAgIGZpZWxkLFxuICAgICAgICAgIGl0ZW1zOiBjcmVhdGVMZWdlbmRJdGVtcyhmaXJzdEVuY29kZXIuZ2V0RG9tYWluRnJvbURhdGFzZXQoZGF0YSkpLFxuICAgICAgICAgIHR5cGU6IGRlZmluaXRpb24udHlwZVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjaGFubmVsRW5jb2RlcnMsXG4gICAgICAgIGNyZWF0ZUxlZ2VuZEl0ZW1zLFxuICAgICAgICBmaWVsZCxcbiAgICAgICAgdHlwZTogZGVmaW5pdGlvbi50eXBlXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgc2V0RG9tYWluRnJvbURhdGFzZXQoZGF0YSkge1xuICAgIHRoaXMuZ2V0Q2hhbm5lbEVuY29kZXJzKCkuZm9yRWFjaChjaGFubmVsRW5jb2RlciA9PiB7XG4gICAgICBjaGFubmVsRW5jb2Rlci5zZXREb21haW5Gcm9tRGF0YXNldChkYXRhKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGhhc0xlZ2VuZCgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5sZWdlbmRzKS5sZW5ndGggPiAwO1xuICB9XG5cbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtZXJnZUVuY29kaW5nKGRlZmF1bHRFbmNvZGluZywgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHsgLi4uZGVmYXVsdEVuY29kaW5nLFxuICAgIC4uLmVuY29kaW5nXG4gIH07XG59IiwiaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3IgfSBmcm9tICdyZXNlbGVjdCc7XG5pbXBvcnQgRW5jb2RlciBmcm9tICcuL0VuY29kZXInO1xuaW1wb3J0IG1lcmdlRW5jb2RpbmcgZnJvbSAnLi4vdXRpbHMvbWVyZ2VFbmNvZGluZyc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVFbmNvZGVyRmFjdG9yeShwYXJhbXMpIHtcbiAgY29uc3Qge1xuICAgIGNoYW5uZWxUeXBlc1xuICB9ID0gcGFyYW1zO1xuICBjb25zdCBjb21wbGV0ZUVuY29kaW5nID0gJ2RlZmF1bHRFbmNvZGluZycgaW4gcGFyYW1zID8gZW5jb2RpbmcgPT4gbWVyZ2VFbmNvZGluZyhwYXJhbXMuZGVmYXVsdEVuY29kaW5nLCBlbmNvZGluZykgOiBwYXJhbXMuY29tcGxldGVFbmNvZGluZztcblxuICBjb25zdCBjcmVhdGUgPSAoZW5jb2RpbmcgPSB7fSkgPT4gbmV3IEVuY29kZXIoe1xuICAgIGNoYW5uZWxUeXBlcyxcbiAgICBlbmNvZGluZzogY29tcGxldGVFbmNvZGluZyhlbmNvZGluZylcbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBjaGFubmVsVHlwZXMsXG4gICAgY3JlYXRlLFxuICAgIGNyZWF0ZVNlbGVjdG9yOiAoKSA9PiBjcmVhdGVTZWxlY3RvcihlbmNvZGluZyA9PiBlbmNvZGluZywgY3JlYXRlKSxcbiAgICBERUZBVUxUX0VOQ09ESU5HOiBjb21wbGV0ZUVuY29kaW5nKHt9KVxuICB9O1xufSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2220\n")},2391:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, "default", function() { return /* binding */ BoxPlot_BoxPlot; });\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react/index.js\nvar react = __webpack_require__(0);\nvar react_default = /*#__PURE__*/__webpack_require__.n(react);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/chart/XYChart.js + 51 modules\nvar XYChart = __webpack_require__(2390);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/classnames/index.js\nvar classnames = __webpack_require__(76);\nvar classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/@vx/group/dist/vx-group.es.js\n\n\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nfunction Group(_ref) {\n  var _ref$top = _ref.top,\n      top = _ref$top === undefined ? 0 : _ref$top,\n      _ref$left = _ref.left,\n      left = _ref$left === undefined ? 0 : _ref$left,\n      transform = _ref.transform,\n      className = _ref.className,\n      children = _ref.children,\n      restProps = objectWithoutProperties(_ref, [\'top\', \'left\', \'transform\', \'className\', \'children\']);\n\n  return react_default.a.createElement(\n    \'g\',\n    _extends({\n      className: classnames_default()(\'cx-group\', className),\n      transform: transform || \'translate(\' + left + \', \' + top + \')\'\n    }, restProps),\n    children\n  );\n}\n\n\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-array/src/index.js + 31 modules\nvar src = __webpack_require__(1934);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/init.js\nfunction initRange(domain, range) {\n  switch (arguments.length) {\n    case 0: break;\n    case 1: this.range(domain); break;\n    default: this.range(range).domain(domain); break;\n  }\n  return this;\n}\n\nfunction initInterpolator(domain, interpolator) {\n  switch (arguments.length) {\n    case 0: break;\n    case 1: this.interpolator(domain); break;\n    default: this.interpolator(interpolator).domain(domain); break;\n  }\n  return this;\n}\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-collection/src/index.js + 6 modules\nvar d3_collection_src = __webpack_require__(882);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/array.js\nvar array = Array.prototype;\n\nvar map = array.map;\nvar slice = array.slice;\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/ordinal.js\n\n\n\n\nvar implicit = {name: "implicit"};\n\nfunction ordinal() {\n  var index = Object(d3_collection_src["map"])(),\n      domain = [],\n      range = [],\n      unknown = implicit;\n\n  function scale(d) {\n    var key = d + "", i = index.get(key);\n    if (!i) {\n      if (unknown !== implicit) return unknown;\n      index.set(key, i = domain.push(d));\n    }\n    return range[(i - 1) % range.length];\n  }\n\n  scale.domain = function(_) {\n    if (!arguments.length) return domain.slice();\n    domain = [], index = Object(d3_collection_src["map"])();\n    var i = -1, n = _.length, d, key;\n    while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));\n    return scale;\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = slice.call(_), scale) : range.slice();\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  scale.copy = function() {\n    return ordinal(domain, range).unknown(unknown);\n  };\n\n  initRange.apply(scale, arguments);\n\n  return scale;\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/band.js\n\n\n\n\nfunction band() {\n  var scale = ordinal().unknown(undefined),\n      domain = scale.domain,\n      ordinalRange = scale.range,\n      range = [0, 1],\n      step,\n      bandwidth,\n      round = false,\n      paddingInner = 0,\n      paddingOuter = 0,\n      align = 0.5;\n\n  delete scale.unknown;\n\n  function rescale() {\n    var n = domain().length,\n        reverse = range[1] < range[0],\n        start = range[reverse - 0],\n        stop = range[1 - reverse];\n    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);\n    if (round) step = Math.floor(step);\n    start += (stop - start - step * (n - paddingInner)) * align;\n    bandwidth = step * (1 - paddingInner);\n    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);\n    var values = Object(src["range"])(n).map(function(i) { return start + step * i; });\n    return ordinalRange(reverse ? values.reverse() : values);\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain(_), rescale()) : domain();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = [+_[0], +_[1]], rescale()) : range.slice();\n  };\n\n  scale.rangeRound = function(_) {\n    return range = [+_[0], +_[1]], round = true, rescale();\n  };\n\n  scale.bandwidth = function() {\n    return bandwidth;\n  };\n\n  scale.step = function() {\n    return step;\n  };\n\n  scale.round = function(_) {\n    return arguments.length ? (round = !!_, rescale()) : round;\n  };\n\n  scale.padding = function(_) {\n    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;\n  };\n\n  scale.paddingInner = function(_) {\n    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;\n  };\n\n  scale.paddingOuter = function(_) {\n    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;\n  };\n\n  scale.align = function(_) {\n    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;\n  };\n\n  scale.copy = function() {\n    return band(domain(), range)\n        .round(round)\n        .paddingInner(paddingInner)\n        .paddingOuter(paddingOuter)\n        .align(align);\n  };\n\n  return initRange.apply(rescale(), arguments);\n}\n\nfunction pointish(scale) {\n  var copy = scale.copy;\n\n  scale.padding = scale.paddingOuter;\n  delete scale.paddingInner;\n  delete scale.paddingOuter;\n\n  scale.copy = function() {\n    return pointish(copy());\n  };\n\n  return scale;\n}\n\nfunction point() {\n  return pointish(band.apply(null, arguments).paddingInner(1));\n}\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-interpolate/src/value.js\nvar src_value = __webpack_require__(274);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-interpolate/src/number.js\nvar number = __webpack_require__(99);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-interpolate/src/round.js\nvar src_round = __webpack_require__(1005);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/constant.js\n/* harmony default export */ var constant = (function(x) {\n  return function() {\n    return x;\n  };\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/number.js\n/* harmony default export */ var src_number = (function(x) {\n  return +x;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/continuous.js\n\n\n\n\n\n\nvar unit = [0, 1];\n\nfunction identity(x) {\n  return x;\n}\n\nfunction normalize(a, b) {\n  return (b -= (a = +a))\n      ? function(x) { return (x - a) / b; }\n      : constant(isNaN(b) ? NaN : 0.5);\n}\n\nfunction clamper(domain) {\n  var a = domain[0], b = domain[domain.length - 1], t;\n  if (a > b) t = a, a = b, b = t;\n  return function(x) { return Math.max(a, Math.min(b, x)); };\n}\n\n// normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].\n// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].\nfunction bimap(domain, range, interpolate) {\n  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];\n  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);\n  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);\n  return function(x) { return r0(d0(x)); };\n}\n\nfunction polymap(domain, range, interpolate) {\n  var j = Math.min(domain.length, range.length) - 1,\n      d = new Array(j),\n      r = new Array(j),\n      i = -1;\n\n  // Reverse descending domains.\n  if (domain[j] < domain[0]) {\n    domain = domain.slice().reverse();\n    range = range.slice().reverse();\n  }\n\n  while (++i < j) {\n    d[i] = normalize(domain[i], domain[i + 1]);\n    r[i] = interpolate(range[i], range[i + 1]);\n  }\n\n  return function(x) {\n    var i = Object(src["bisect"])(domain, x, 1, j) - 1;\n    return r[i](d[i](x));\n  };\n}\n\nfunction copy(source, target) {\n  return target\n      .domain(source.domain())\n      .range(source.range())\n      .interpolate(source.interpolate())\n      .clamp(source.clamp())\n      .unknown(source.unknown());\n}\n\nfunction transformer() {\n  var domain = unit,\n      range = unit,\n      interpolate = src_value["a" /* default */],\n      transform,\n      untransform,\n      unknown,\n      clamp = identity,\n      piecewise,\n      output,\n      input;\n\n  function rescale() {\n    piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;\n    output = input = null;\n    return scale;\n  }\n\n  function scale(x) {\n    return isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));\n  }\n\n  scale.invert = function(y) {\n    return clamp(untransform((input || (input = piecewise(range, domain.map(transform), number["a" /* default */])))(y)));\n  };\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain = map.call(_, src_number), clamp === identity || (clamp = clamper(domain)), rescale()) : domain.slice();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = slice.call(_), rescale()) : range.slice();\n  };\n\n  scale.rangeRound = function(_) {\n    return range = slice.call(_), interpolate = src_round["a" /* default */], rescale();\n  };\n\n  scale.clamp = function(_) {\n    return arguments.length ? (clamp = _ ? clamper(domain) : identity, scale) : clamp !== identity;\n  };\n\n  scale.interpolate = function(_) {\n    return arguments.length ? (interpolate = _, rescale()) : interpolate;\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  return function(t, u) {\n    transform = t, untransform = u;\n    return rescale();\n  };\n}\n\nfunction continuous(transform, untransform) {\n  return transformer()(transform, untransform);\n}\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-format/src/formatSpecifier.js\nvar formatSpecifier = __webpack_require__(495);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-format/src/precisionPrefix.js\nvar precisionPrefix = __webpack_require__(2144);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-format/src/defaultLocale.js\nvar defaultLocale = __webpack_require__(406);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-format/src/precisionRound.js\nvar precisionRound = __webpack_require__(2145);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-format/src/precisionFixed.js\nvar precisionFixed = __webpack_require__(2146);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/tickFormat.js\n\n\n\n/* harmony default export */ var src_tickFormat = (function(start, stop, count, specifier) {\n  var step = Object(src["tickStep"])(start, stop, count),\n      precision;\n  specifier = Object(formatSpecifier["b" /* default */])(specifier == null ? ",f" : specifier);\n  switch (specifier.type) {\n    case "s": {\n      var value = Math.max(Math.abs(start), Math.abs(stop));\n      if (specifier.precision == null && !isNaN(precision = Object(precisionPrefix["a" /* default */])(step, value))) specifier.precision = precision;\n      return Object(defaultLocale["c" /* formatPrefix */])(specifier, value);\n    }\n    case "":\n    case "e":\n    case "g":\n    case "p":\n    case "r": {\n      if (specifier.precision == null && !isNaN(precision = Object(precisionRound["a" /* default */])(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");\n      break;\n    }\n    case "f":\n    case "%": {\n      if (specifier.precision == null && !isNaN(precision = Object(precisionFixed["a" /* default */])(step))) specifier.precision = precision - (specifier.type === "%") * 2;\n      break;\n    }\n  }\n  return Object(defaultLocale["b" /* format */])(specifier);\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/linear.js\n\n\n\n\n\nfunction linearish(scale) {\n  var domain = scale.domain;\n\n  scale.ticks = function(count) {\n    var d = domain();\n    return Object(src["ticks"])(d[0], d[d.length - 1], count == null ? 10 : count);\n  };\n\n  scale.tickFormat = function(count, specifier) {\n    var d = domain();\n    return src_tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);\n  };\n\n  scale.nice = function(count) {\n    if (count == null) count = 10;\n\n    var d = domain(),\n        i0 = 0,\n        i1 = d.length - 1,\n        start = d[i0],\n        stop = d[i1],\n        step;\n\n    if (stop < start) {\n      step = start, start = stop, stop = step;\n      step = i0, i0 = i1, i1 = step;\n    }\n\n    step = Object(src["tickIncrement"])(start, stop, count);\n\n    if (step > 0) {\n      start = Math.floor(start / step) * step;\n      stop = Math.ceil(stop / step) * step;\n      step = Object(src["tickIncrement"])(start, stop, count);\n    } else if (step < 0) {\n      start = Math.ceil(start * step) / step;\n      stop = Math.floor(stop * step) / step;\n      step = Object(src["tickIncrement"])(start, stop, count);\n    }\n\n    if (step > 0) {\n      d[i0] = Math.floor(start / step) * step;\n      d[i1] = Math.ceil(stop / step) * step;\n      domain(d);\n    } else if (step < 0) {\n      d[i0] = Math.ceil(start * step) / step;\n      d[i1] = Math.floor(stop * step) / step;\n      domain(d);\n    }\n\n    return scale;\n  };\n\n  return scale;\n}\n\nfunction linear() {\n  var scale = continuous(identity, identity);\n\n  scale.copy = function() {\n    return copy(scale, linear());\n  };\n\n  initRange.apply(scale, arguments);\n\n  return linearish(scale);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/identity.js\n\n\n\n\nfunction identity_identity(domain) {\n  var unknown;\n\n  function scale(x) {\n    return isNaN(x = +x) ? unknown : x;\n  }\n\n  scale.invert = scale;\n\n  scale.domain = scale.range = function(_) {\n    return arguments.length ? (domain = map.call(_, src_number), scale) : domain.slice();\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  scale.copy = function() {\n    return identity_identity(domain).unknown(unknown);\n  };\n\n  domain = arguments.length ? map.call(domain, src_number) : [0, 1];\n\n  return linearish(scale);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/nice.js\n/* harmony default export */ var src_nice = (function(domain, interval) {\n  domain = domain.slice();\n\n  var i0 = 0,\n      i1 = domain.length - 1,\n      x0 = domain[i0],\n      x1 = domain[i1],\n      t;\n\n  if (x1 < x0) {\n    t = i0, i0 = i1, i1 = t;\n    t = x0, x0 = x1, x1 = t;\n  }\n\n  domain[i0] = interval.floor(x0);\n  domain[i1] = interval.ceil(x1);\n  return domain;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/log.js\n\n\n\n\n\n\nfunction transformLog(x) {\n  return Math.log(x);\n}\n\nfunction transformExp(x) {\n  return Math.exp(x);\n}\n\nfunction transformLogn(x) {\n  return -Math.log(-x);\n}\n\nfunction transformExpn(x) {\n  return -Math.exp(-x);\n}\n\nfunction pow10(x) {\n  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;\n}\n\nfunction powp(base) {\n  return base === 10 ? pow10\n      : base === Math.E ? Math.exp\n      : function(x) { return Math.pow(base, x); };\n}\n\nfunction logp(base) {\n  return base === Math.E ? Math.log\n      : base === 10 && Math.log10\n      || base === 2 && Math.log2\n      || (base = Math.log(base), function(x) { return Math.log(x) / base; });\n}\n\nfunction reflect(f) {\n  return function(x) {\n    return -f(-x);\n  };\n}\n\nfunction loggish(transform) {\n  var scale = transform(transformLog, transformExp),\n      domain = scale.domain,\n      base = 10,\n      logs,\n      pows;\n\n  function rescale() {\n    logs = logp(base), pows = powp(base);\n    if (domain()[0] < 0) {\n      logs = reflect(logs), pows = reflect(pows);\n      transform(transformLogn, transformExpn);\n    } else {\n      transform(transformLog, transformExp);\n    }\n    return scale;\n  }\n\n  scale.base = function(_) {\n    return arguments.length ? (base = +_, rescale()) : base;\n  };\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain(_), rescale()) : domain();\n  };\n\n  scale.ticks = function(count) {\n    var d = domain(),\n        u = d[0],\n        v = d[d.length - 1],\n        r;\n\n    if (r = v < u) i = u, u = v, v = i;\n\n    var i = logs(u),\n        j = logs(v),\n        p,\n        k,\n        t,\n        n = count == null ? 10 : +count,\n        z = [];\n\n    if (!(base % 1) && j - i < n) {\n      i = Math.round(i) - 1, j = Math.round(j) + 1;\n      if (u > 0) for (; i < j; ++i) {\n        for (k = 1, p = pows(i); k < base; ++k) {\n          t = p * k;\n          if (t < u) continue;\n          if (t > v) break;\n          z.push(t);\n        }\n      } else for (; i < j; ++i) {\n        for (k = base - 1, p = pows(i); k >= 1; --k) {\n          t = p * k;\n          if (t < u) continue;\n          if (t > v) break;\n          z.push(t);\n        }\n      }\n    } else {\n      z = Object(src["ticks"])(i, j, Math.min(j - i, n)).map(pows);\n    }\n\n    return r ? z.reverse() : z;\n  };\n\n  scale.tickFormat = function(count, specifier) {\n    if (specifier == null) specifier = base === 10 ? ".0e" : ",";\n    if (typeof specifier !== "function") specifier = Object(defaultLocale["b" /* format */])(specifier);\n    if (count === Infinity) return specifier;\n    if (count == null) count = 10;\n    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?\n    return function(d) {\n      var i = d / pows(Math.round(logs(d)));\n      if (i * base < base - 0.5) i *= base;\n      return i <= k ? specifier(d) : "";\n    };\n  };\n\n  scale.nice = function() {\n    return domain(src_nice(domain(), {\n      floor: function(x) { return pows(Math.floor(logs(x))); },\n      ceil: function(x) { return pows(Math.ceil(logs(x))); }\n    }));\n  };\n\n  return scale;\n}\n\nfunction log() {\n  var scale = loggish(transformer()).domain([1, 10]);\n\n  scale.copy = function() {\n    return copy(scale, log()).base(scale.base());\n  };\n\n  initRange.apply(scale, arguments);\n\n  return scale;\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/symlog.js\n\n\n\n\nfunction transformSymlog(c) {\n  return function(x) {\n    return Math.sign(x) * Math.log1p(Math.abs(x / c));\n  };\n}\n\nfunction transformSymexp(c) {\n  return function(x) {\n    return Math.sign(x) * Math.expm1(Math.abs(x)) * c;\n  };\n}\n\nfunction symlogish(transform) {\n  var c = 1, scale = transform(transformSymlog(c), transformSymexp(c));\n\n  scale.constant = function(_) {\n    return arguments.length ? transform(transformSymlog(c = +_), transformSymexp(c)) : c;\n  };\n\n  return linearish(scale);\n}\n\nfunction symlog() {\n  var scale = symlogish(transformer());\n\n  scale.copy = function() {\n    return copy(scale, symlog()).constant(scale.constant());\n  };\n\n  return initRange.apply(scale, arguments);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/pow.js\n\n\n\n\nfunction transformPow(exponent) {\n  return function(x) {\n    return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);\n  };\n}\n\nfunction transformSqrt(x) {\n  return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);\n}\n\nfunction transformSquare(x) {\n  return x < 0 ? -x * x : x * x;\n}\n\nfunction powish(transform) {\n  var scale = transform(identity, identity),\n      exponent = 1;\n\n  function rescale() {\n    return exponent === 1 ? transform(identity, identity)\n        : exponent === 0.5 ? transform(transformSqrt, transformSquare)\n        : transform(transformPow(exponent), transformPow(1 / exponent));\n  }\n\n  scale.exponent = function(_) {\n    return arguments.length ? (exponent = +_, rescale()) : exponent;\n  };\n\n  return linearish(scale);\n}\n\nfunction pow() {\n  var scale = powish(transformer());\n\n  scale.copy = function() {\n    return copy(scale, pow()).exponent(scale.exponent());\n  };\n\n  initRange.apply(scale, arguments);\n\n  return scale;\n}\n\nfunction sqrt() {\n  return pow.apply(null, arguments).exponent(0.5);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/quantile.js\n\n\n\n\nfunction quantile() {\n  var domain = [],\n      range = [],\n      thresholds = [],\n      unknown;\n\n  function rescale() {\n    var i = 0, n = Math.max(1, range.length);\n    thresholds = new Array(n - 1);\n    while (++i < n) thresholds[i - 1] = Object(src["quantile"])(domain, i / n);\n    return scale;\n  }\n\n  function scale(x) {\n    return isNaN(x = +x) ? unknown : range[Object(src["bisect"])(thresholds, x)];\n  }\n\n  scale.invertExtent = function(y) {\n    var i = range.indexOf(y);\n    return i < 0 ? [NaN, NaN] : [\n      i > 0 ? thresholds[i - 1] : domain[0],\n      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]\n    ];\n  };\n\n  scale.domain = function(_) {\n    if (!arguments.length) return domain.slice();\n    domain = [];\n    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);\n    domain.sort(src["ascending"]);\n    return rescale();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = slice.call(_), rescale()) : range.slice();\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  scale.quantiles = function() {\n    return thresholds.slice();\n  };\n\n  scale.copy = function() {\n    return quantile()\n        .domain(domain)\n        .range(range)\n        .unknown(unknown);\n  };\n\n  return initRange.apply(scale, arguments);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/quantize.js\n\n\n\n\n\nfunction quantize() {\n  var x0 = 0,\n      x1 = 1,\n      n = 1,\n      domain = [0.5],\n      range = [0, 1],\n      unknown;\n\n  function scale(x) {\n    return x <= x ? range[Object(src["bisect"])(domain, x, 0, n)] : unknown;\n  }\n\n  function rescale() {\n    var i = -1;\n    domain = new Array(n);\n    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);\n    return scale;\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (n = (range = slice.call(_)).length - 1, rescale()) : range.slice();\n  };\n\n  scale.invertExtent = function(y) {\n    var i = range.indexOf(y);\n    return i < 0 ? [NaN, NaN]\n        : i < 1 ? [x0, domain[0]]\n        : i >= n ? [domain[n - 1], x1]\n        : [domain[i - 1], domain[i]];\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : scale;\n  };\n\n  scale.thresholds = function() {\n    return domain.slice();\n  };\n\n  scale.copy = function() {\n    return quantize()\n        .domain([x0, x1])\n        .range(range)\n        .unknown(unknown);\n  };\n\n  return initRange.apply(linearish(scale), arguments);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/threshold.js\n\n\n\n\nfunction threshold() {\n  var domain = [0.5],\n      range = [0, 1],\n      unknown,\n      n = 1;\n\n  function scale(x) {\n    return x <= x ? range[Object(src["bisect"])(domain, x, 0, n)] : unknown;\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain = slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();\n  };\n\n  scale.invertExtent = function(y) {\n    var i = range.indexOf(y);\n    return [domain[i - 1], domain[i]];\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  scale.copy = function() {\n    return threshold()\n        .domain(domain)\n        .range(range)\n        .unknown(unknown);\n  };\n\n  return initRange.apply(scale, arguments);\n}\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/year.js\nvar src_year = __webpack_require__(364);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/month.js\nvar src_month = __webpack_require__(1926);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/week.js\nvar src_week = __webpack_require__(176);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/day.js\nvar src_day = __webpack_require__(1203);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/hour.js\nvar src_hour = __webpack_require__(1925);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/minute.js\nvar src_minute = __webpack_require__(1924);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/second.js\nvar src_second = __webpack_require__(1923);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/millisecond.js\nvar src_millisecond = __webpack_require__(2366);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time-format/src/defaultLocale.js\nvar src_defaultLocale = __webpack_require__(1201);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/time.js\n\n\n\n\n\n\n\n\nvar durationSecond = 1000,\n    durationMinute = durationSecond * 60,\n    durationHour = durationMinute * 60,\n    durationDay = durationHour * 24,\n    durationWeek = durationDay * 7,\n    durationMonth = durationDay * 30,\n    durationYear = durationDay * 365;\n\nfunction date(t) {\n  return new Date(t);\n}\n\nfunction time_number(t) {\n  return t instanceof Date ? +t : +new Date(+t);\n}\n\nfunction calendar(year, month, week, day, hour, minute, second, millisecond, format) {\n  var scale = continuous(identity, identity),\n      invert = scale.invert,\n      domain = scale.domain;\n\n  var formatMillisecond = format(".%L"),\n      formatSecond = format(":%S"),\n      formatMinute = format("%I:%M"),\n      formatHour = format("%I %p"),\n      formatDay = format("%a %d"),\n      formatWeek = format("%b %d"),\n      formatMonth = format("%B"),\n      formatYear = format("%Y");\n\n  var tickIntervals = [\n    [second,  1,      durationSecond],\n    [second,  5,  5 * durationSecond],\n    [second, 15, 15 * durationSecond],\n    [second, 30, 30 * durationSecond],\n    [minute,  1,      durationMinute],\n    [minute,  5,  5 * durationMinute],\n    [minute, 15, 15 * durationMinute],\n    [minute, 30, 30 * durationMinute],\n    [  hour,  1,      durationHour  ],\n    [  hour,  3,  3 * durationHour  ],\n    [  hour,  6,  6 * durationHour  ],\n    [  hour, 12, 12 * durationHour  ],\n    [   day,  1,      durationDay   ],\n    [   day,  2,  2 * durationDay   ],\n    [  week,  1,      durationWeek  ],\n    [ month,  1,      durationMonth ],\n    [ month,  3,  3 * durationMonth ],\n    [  year,  1,      durationYear  ]\n  ];\n\n  function tickFormat(date) {\n    return (second(date) < date ? formatMillisecond\n        : minute(date) < date ? formatSecond\n        : hour(date) < date ? formatMinute\n        : day(date) < date ? formatHour\n        : month(date) < date ? (week(date) < date ? formatDay : formatWeek)\n        : year(date) < date ? formatMonth\n        : formatYear)(date);\n  }\n\n  function tickInterval(interval, start, stop, step) {\n    if (interval == null) interval = 10;\n\n    // If a desired tick count is specified, pick a reasonable tick interval\n    // based on the extent of the domain and a rough estimate of tick size.\n    // Otherwise, assume interval is already a time interval and use it.\n    if (typeof interval === "number") {\n      var target = Math.abs(stop - start) / interval,\n          i = Object(src["bisector"])(function(i) { return i[2]; }).right(tickIntervals, target);\n      if (i === tickIntervals.length) {\n        step = Object(src["tickStep"])(start / durationYear, stop / durationYear, interval);\n        interval = year;\n      } else if (i) {\n        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];\n        step = i[1];\n        interval = i[0];\n      } else {\n        step = Math.max(Object(src["tickStep"])(start, stop, interval), 1);\n        interval = millisecond;\n      }\n    }\n\n    return step == null ? interval : interval.every(step);\n  }\n\n  scale.invert = function(y) {\n    return new Date(invert(y));\n  };\n\n  scale.domain = function(_) {\n    return arguments.length ? domain(map.call(_, time_number)) : domain().map(date);\n  };\n\n  scale.ticks = function(interval, step) {\n    var d = domain(),\n        t0 = d[0],\n        t1 = d[d.length - 1],\n        r = t1 < t0,\n        t;\n    if (r) t = t0, t0 = t1, t1 = t;\n    t = tickInterval(interval, t0, t1, step);\n    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop\n    return r ? t.reverse() : t;\n  };\n\n  scale.tickFormat = function(count, specifier) {\n    return specifier == null ? tickFormat : format(specifier);\n  };\n\n  scale.nice = function(interval, step) {\n    var d = domain();\n    return (interval = tickInterval(interval, d[0], d[d.length - 1], step))\n        ? domain(src_nice(d, interval))\n        : scale;\n  };\n\n  scale.copy = function() {\n    return copy(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));\n  };\n\n  return scale;\n}\n\n/* harmony default export */ var time = (function() {\n  return initRange.apply(calendar(src_year["a" /* default */], src_month["a" /* default */], src_week["d" /* sunday */], src_day["a" /* default */], src_hour["a" /* default */], src_minute["a" /* default */], src_second["a" /* default */], src_millisecond["a" /* default */], src_defaultLocale["a" /* timeFormat */]).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);\n});\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/utcYear.js\nvar utcYear = __webpack_require__(365);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/utcMonth.js\nvar utcMonth = __webpack_require__(1929);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/utcWeek.js\nvar utcWeek = __webpack_require__(175);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/utcDay.js\nvar utcDay = __webpack_require__(1202);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/utcHour.js\nvar utcHour = __webpack_require__(1928);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/utcMinute.js\nvar utcMinute = __webpack_require__(1927);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/utcTime.js\n\n\n\n\n\n/* harmony default export */ var utcTime = (function() {\n  return initRange.apply(calendar(utcYear["a" /* default */], utcMonth["a" /* default */], utcWeek["d" /* utcSunday */], utcDay["a" /* default */], utcHour["a" /* default */], utcMinute["a" /* default */], src_second["a" /* default */], src_millisecond["a" /* default */], src_defaultLocale["b" /* utcFormat */]).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]), arguments);\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/sequential.js\n\n\n\n\n\n\n\nfunction sequential_transformer() {\n  var x0 = 0,\n      x1 = 1,\n      t0,\n      t1,\n      k10,\n      transform,\n      interpolator = identity,\n      clamp = false,\n      unknown;\n\n  function scale(x) {\n    return isNaN(x = +x) ? unknown : interpolator(k10 === 0 ? 0.5 : (x = (transform(x) - t0) * k10, clamp ? Math.max(0, Math.min(1, x)) : x));\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (t0 = transform(x0 = +_[0]), t1 = transform(x1 = +_[1]), k10 = t0 === t1 ? 0 : 1 / (t1 - t0), scale) : [x0, x1];\n  };\n\n  scale.clamp = function(_) {\n    return arguments.length ? (clamp = !!_, scale) : clamp;\n  };\n\n  scale.interpolator = function(_) {\n    return arguments.length ? (interpolator = _, scale) : interpolator;\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  return function(t) {\n    transform = t, t0 = t(x0), t1 = t(x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0);\n    return scale;\n  };\n}\n\nfunction sequential_copy(source, target) {\n  return target\n      .domain(source.domain())\n      .interpolator(source.interpolator())\n      .clamp(source.clamp())\n      .unknown(source.unknown());\n}\n\nfunction sequential() {\n  var scale = linearish(sequential_transformer()(identity));\n\n  scale.copy = function() {\n    return sequential_copy(scale, sequential());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction sequentialLog() {\n  var scale = loggish(sequential_transformer()).domain([1, 10]);\n\n  scale.copy = function() {\n    return sequential_copy(scale, sequentialLog()).base(scale.base());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction sequentialSymlog() {\n  var scale = symlogish(sequential_transformer());\n\n  scale.copy = function() {\n    return sequential_copy(scale, sequentialSymlog()).constant(scale.constant());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction sequentialPow() {\n  var scale = powish(sequential_transformer());\n\n  scale.copy = function() {\n    return sequential_copy(scale, sequentialPow()).exponent(scale.exponent());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction sequentialSqrt() {\n  return sequentialPow.apply(null, arguments).exponent(0.5);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/sequentialQuantile.js\n\n\n\n\nfunction sequentialQuantile() {\n  var domain = [],\n      interpolator = identity;\n\n  function scale(x) {\n    if (!isNaN(x = +x)) return interpolator((Object(src["bisect"])(domain, x) - 1) / (domain.length - 1));\n  }\n\n  scale.domain = function(_) {\n    if (!arguments.length) return domain.slice();\n    domain = [];\n    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);\n    domain.sort(src["ascending"]);\n    return scale;\n  };\n\n  scale.interpolator = function(_) {\n    return arguments.length ? (interpolator = _, scale) : interpolator;\n  };\n\n  scale.copy = function() {\n    return sequentialQuantile(interpolator).domain(domain);\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/diverging.js\n\n\n\n\n\n\n\n\nfunction diverging_transformer() {\n  var x0 = 0,\n      x1 = 0.5,\n      x2 = 1,\n      t0,\n      t1,\n      t2,\n      k10,\n      k21,\n      interpolator = identity,\n      transform,\n      clamp = false,\n      unknown;\n\n  function scale(x) {\n    return isNaN(x = +x) ? unknown : (x = 0.5 + ((x = +transform(x)) - t1) * (x < t1 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x)) : x));\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (t0 = transform(x0 = +_[0]), t1 = transform(x1 = +_[1]), t2 = transform(x2 = +_[2]), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), scale) : [x0, x1, x2];\n  };\n\n  scale.clamp = function(_) {\n    return arguments.length ? (clamp = !!_, scale) : clamp;\n  };\n\n  scale.interpolator = function(_) {\n    return arguments.length ? (interpolator = _, scale) : interpolator;\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  return function(t) {\n    transform = t, t0 = t(x0), t1 = t(x1), t2 = t(x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1);\n    return scale;\n  };\n}\n\nfunction diverging() {\n  var scale = linearish(diverging_transformer()(identity));\n\n  scale.copy = function() {\n    return sequential_copy(scale, diverging());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction divergingLog() {\n  var scale = loggish(diverging_transformer()).domain([0.1, 1, 10]);\n\n  scale.copy = function() {\n    return sequential_copy(scale, divergingLog()).base(scale.base());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction divergingSymlog() {\n  var scale = symlogish(diverging_transformer());\n\n  scale.copy = function() {\n    return sequential_copy(scale, divergingSymlog()).constant(scale.constant());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction divergingPow() {\n  var scale = powish(diverging_transformer());\n\n  scale.copy = function() {\n    return sequential_copy(scale, divergingPow()).exponent(scale.exponent());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction divergingSqrt() {\n  return divergingPow.apply(null, arguments).exponent(0.5);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/d3-scale/src/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/node_modules/@vx/scale/dist/vx-scale.es.js\n\n\nvar vx_scale_es_band = (function (_ref) {\n  var range = _ref.range,\n      rangeRound = _ref.rangeRound,\n      domain = _ref.domain,\n      padding = _ref.padding,\n      paddingInner = _ref.paddingInner,\n      paddingOuter = _ref.paddingOuter,\n      align = _ref.align,\n      tickFormat = _ref.tickFormat;\n\n  var scale = band();\n\n  if (range) scale.range(range);\n  if (rangeRound) scale.rangeRound(rangeRound);\n  if (domain) scale.domain(domain);\n  if (padding) scale.padding(padding);\n  if (paddingInner) scale.paddingInner(paddingInner);\n  if (paddingOuter) scale.paddingOuter(paddingOuter);\n  if (align) scale.align(align);\n  if (tickFormat) scale.tickFormat = tickFormat;\n\n  return scale;\n});\n\nvar vx_scale_es_point = (function (_ref) {\n  var range = _ref.range,\n      rangeRound = _ref.rangeRound,\n      domain = _ref.domain,\n      padding = _ref.padding,\n      align = _ref.align,\n      _ref$nice = _ref.nice,\n      nice = _ref$nice === undefined ? false : _ref$nice;\n\n  var scale = point();\n\n  if (range) scale.range(range);\n  if (rangeRound) scale.rangeRound(rangeRound);\n  if (domain) scale.domain(domain);\n  if (nice) scale.nice();\n  if (padding) scale.padding(padding);\n  if (align) scale.align(align);\n\n  return scale;\n});\n\nvar vx_scale_es_linear = (function (_ref) {\n  var range = _ref.range,\n      rangeRound = _ref.rangeRound,\n      domain = _ref.domain,\n      _ref$nice = _ref.nice,\n      nice = _ref$nice === undefined ? false : _ref$nice,\n      _ref$clamp = _ref.clamp,\n      clamp = _ref$clamp === undefined ? false : _ref$clamp;\n\n  var scale = linear();\n\n  if (range) scale.range(range);\n  if (rangeRound) scale.rangeRound(rangeRound);\n  if (domain) scale.domain(domain);\n  if (nice) scale.nice();\n  if (clamp) scale.clamp(true);\n\n  return scale;\n});\n\nvar vx_scale_es_time = (function (_ref) {\n  var range = _ref.range,\n      rangeRound = _ref.rangeRound,\n      domain = _ref.domain,\n      _ref$nice = _ref.nice,\n      nice = _ref$nice === undefined ? false : _ref$nice,\n      _ref$clamp = _ref.clamp,\n      clamp = _ref$clamp === undefined ? false : _ref$clamp;\n\n  var scale = time();\n\n  if (range) scale.range(range);\n  if (rangeRound) scale.rangeRound(rangeRound);\n  if (domain) scale.domain(domain);\n  if (nice) scale.nice();\n  if (clamp) scale.clamp(true);\n\n  return scale;\n});\n\nvar utc = (function (_ref) {\n  var range = _ref.range,\n      rangeRound = _ref.rangeRound,\n      domain = _ref.domain,\n      _ref$nice = _ref.nice,\n      nice = _ref$nice === undefined ? false : _ref$nice,\n      _ref$clamp = _ref.clamp,\n      clamp = _ref$clamp === undefined ? false : _ref$clamp;\n\n  var scale = utcTime();\n\n  if (range) scale.range(range);\n  if (rangeRound) scale.rangeRound(rangeRound);\n  if (domain) scale.domain(domain);\n  if (nice) scale.nice();\n  if (clamp) scale.clamp(true);\n\n  return scale;\n});\n\nvar vx_scale_es_log = (function (_ref) {\n  var range = _ref.range,\n      rangeRound = _ref.rangeRound,\n      domain = _ref.domain,\n      base = _ref.base,\n      _ref$nice = _ref.nice,\n      nice = _ref$nice === undefined ? false : _ref$nice,\n      _ref$clamp = _ref.clamp,\n      clamp = _ref$clamp === undefined ? false : _ref$clamp;\n\n  var scale = log();\n\n  if (range) scale.range(range);\n  if (rangeRound) scale.rangeRound(rangeRound);\n  if (domain) scale.domain(domain);\n  if (nice) scale.nice();\n  if (clamp) scale.clamp(true);\n  if (base) scale.base(base);\n\n  return scale;\n});\n\nvar power = (function (_ref) {\n  var range = _ref.range,\n      rangeRound = _ref.rangeRound,\n      domain = _ref.domain,\n      exponent = _ref.exponent,\n      _ref$nice = _ref.nice,\n      nice = _ref$nice === undefined ? false : _ref$nice,\n      _ref$clamp = _ref.clamp,\n      clamp = _ref$clamp === undefined ? false : _ref$clamp;\n\n  var scale = pow();\n\n  if (range) scale.range(range);\n  if (rangeRound) scale.rangeRound(rangeRound);\n  if (domain) scale.domain(domain);\n  if (nice) scale.nice();\n  if (clamp) scale.clamp(true);\n  if (exponent) scale.exponent(exponent);\n\n  return scale;\n});\n\nvar vx_scale_es_ordinal = (function (_ref) {\n  var range = _ref.range,\n      domain = _ref.domain,\n      unknown = _ref.unknown;\n\n  var scale = ordinal();\n\n  if (range) scale.range(range);\n  if (domain) scale.domain(domain);\n  if (unknown) scale.unknown(unknown);\n\n  return scale;\n});\n\nvar vx_scale_es_quantize = (function (_ref) {\n  var range = _ref.range,\n      domain = _ref.domain,\n      ticks = _ref.ticks,\n      tickFormat = _ref.tickFormat,\n      _ref$nice = _ref.nice,\n      nice = _ref$nice === undefined ? false : _ref$nice;\n\n  var scale = quantize();\n\n  if (range) scale.range(range);\n  if (domain) scale.domain(domain);\n  if (nice) scale.nice();\n  if (ticks) scale.ticks(ticks);\n  if (tickFormat) scale.tickFormat(tickFormat);\n\n  return scale;\n});\n\nvar vx_scale_es_quantile = (function (_ref) {\n  var range = _ref.range,\n      domain = _ref.domain;\n\n  var scale = quantile();\n\n  if (range) scale.range(range);\n  if (domain) scale.domain(domain);\n\n  return scale;\n});\n\nvar vx_scale_es_threshold = (function (_ref) {\n  var range = _ref.range,\n      domain = _ref.domain;\n\n  var scale = threshold();\n\n  if (range) scale.range(range);\n  if (domain) scale.domain(domain);\n\n  return scale;\n});\n\nvar vx_scale_es_objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nfunction updateScale(scale, _ref) {\n  var args = vx_scale_es_objectWithoutProperties(_ref, []);\n\n  var nextScale = scale.copy();\n  Object.keys(args).forEach(function (key) {\n    if (nextScale.hasOwnProperty(key)) nextScale[key](args[key]);\n  });\n  return nextScale;\n}\n\n\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-shape/src/line.js\nvar line = __webpack_require__(1983);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-shape/src/curve/cardinal.js\nvar cardinal = __webpack_require__(1950);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/stats/dist/vx-stats.es.js\n\n\n\n\n\n\nfunction callOrValue(maybeFn, data) {\n  if (typeof maybeFn === \'function\') {\n    return maybeFn(data);\n  }\n  return maybeFn;\n}\n\nfunction additionalProps(restProps, data) {\n  return Object.keys(restProps).reduce(function (ret, cur) {\n    ret[cur] = callOrValue(restProps[cur], data);\n    return ret;\n  }, {});\n}\n\nvar vx_stats_es_extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar vx_stats_es_objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i["return"]) _i["return"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError("Invalid attempt to destructure non-iterable instance");\n    }\n  };\n}();\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\nfunction verticalToHorizontal(_ref) {\n  var _ref2 = slicedToArray(_ref, 4),\n      x1 = _ref2[0],\n      y1 = _ref2[1],\n      x2 = _ref2[2],\n      y2 = _ref2[3];\n\n  return [y1, x1, y2, x2];\n}\n\nfunction vx_stats_es_BoxPlot(_ref3) {\n  var _ref3$left = _ref3.left,\n      left = _ref3$left === undefined ? 0 : _ref3$left,\n      _ref3$top = _ref3.top,\n      top = _ref3$top === undefined ? 0 : _ref3$top,\n      className = _ref3.className,\n      data = _ref3.data,\n      max = _ref3.max,\n      min = _ref3.min,\n      firstQuartile = _ref3.firstQuartile,\n      thirdQuartile = _ref3.thirdQuartile,\n      median = _ref3.median,\n      boxWidth = _ref3.boxWidth,\n      fill = _ref3.fill,\n      fillOpacity = _ref3.fillOpacity,\n      stroke = _ref3.stroke,\n      strokeWidth = _ref3.strokeWidth,\n      _ref3$rx = _ref3.rx,\n      rx = _ref3$rx === undefined ? 2 : _ref3$rx,\n      _ref3$ry = _ref3.ry,\n      ry = _ref3$ry === undefined ? 2 : _ref3$ry,\n      valueScale = _ref3.valueScale,\n      outliers = _ref3.outliers,\n      horizontal = _ref3.horizontal,\n      _ref3$medianProps = _ref3.medianProps,\n      medianProps = _ref3$medianProps === undefined ? {} : _ref3$medianProps,\n      _ref3$maxProps = _ref3.maxProps,\n      maxProps = _ref3$maxProps === undefined ? {} : _ref3$maxProps,\n      _ref3$minProps = _ref3.minProps,\n      minProps = _ref3$minProps === undefined ? {} : _ref3$minProps,\n      _ref3$boxProps = _ref3.boxProps,\n      boxProps = _ref3$boxProps === undefined ? {} : _ref3$boxProps,\n      _ref3$outlierProps = _ref3.outlierProps,\n      outlierProps = _ref3$outlierProps === undefined ? {} : _ref3$outlierProps,\n      _ref3$container = _ref3.container,\n      container = _ref3$container === undefined ? false : _ref3$container,\n      _ref3$containerProps = _ref3.containerProps,\n      containerProps = _ref3$containerProps === undefined ? {} : _ref3$containerProps,\n      restProps = vx_stats_es_objectWithoutProperties(_ref3, [\'left\', \'top\', \'className\', \'data\', \'max\', \'min\', \'firstQuartile\', \'thirdQuartile\', \'median\', \'boxWidth\', \'fill\', \'fillOpacity\', \'stroke\', \'strokeWidth\', \'rx\', \'ry\', \'valueScale\', \'outliers\', \'horizontal\', \'medianProps\', \'maxProps\', \'minProps\', \'boxProps\', \'outlierProps\', \'container\', \'containerProps\']);\n\n  var offset = horizontal ? top : left;\n  var center = offset + boxWidth / 2;\n\n  var maxLinePos = Array(4).fill(0);\n  var maxToBoxLinePos = Array(4).fill(0);\n  var boxPos = Array(4).fill(0);\n  var medianLinePos = Array(4).fill(0);\n  var minToBoxLinePos = Array(4).fill(0);\n  var minLinePos = Array(4).fill(0);\n  var containerPos = Array(4).fill(0);\n\n  // all of these are [x0, y0, x1, y1]\n  maxLinePos[0] = center - boxWidth / 4;\n  maxLinePos[1] = valueScale(max);\n  maxLinePos[2] = center + boxWidth / 4;\n  maxLinePos[3] = valueScale(max);\n\n  maxToBoxLinePos[0] = center;\n  maxToBoxLinePos[1] = valueScale(max);\n  maxToBoxLinePos[2] = center;\n  maxToBoxLinePos[3] = valueScale(thirdQuartile);\n\n  boxPos[0] = offset;\n  boxPos[1] = valueScale(thirdQuartile);\n  boxPos[2] = boxWidth;\n  boxPos[3] = Math.abs(valueScale(thirdQuartile) - valueScale(firstQuartile));\n\n  medianLinePos[0] = offset;\n  medianLinePos[1] = valueScale(median);\n  medianLinePos[2] = offset + boxWidth;\n  medianLinePos[3] = valueScale(median);\n\n  minToBoxLinePos[0] = center;\n  minToBoxLinePos[1] = valueScale(firstQuartile);\n  minToBoxLinePos[2] = center;\n  minToBoxLinePos[3] = valueScale(min);\n\n  minLinePos[0] = center - boxWidth / 4;\n  minLinePos[1] = valueScale(min);\n  minLinePos[2] = center + boxWidth / 4;\n  minLinePos[3] = valueScale(min);\n\n  var valueRange = valueScale.range();\n  containerPos[0] = boxPos[0];\n  containerPos[1] = Math.min.apply(Math, toConsumableArray(valueRange));\n  containerPos[2] = boxPos[2];\n  containerPos[3] = Math.abs(valueRange[0] - valueRange[1]);\n\n  if (horizontal) {\n    maxLinePos = verticalToHorizontal(maxLinePos);\n    maxToBoxLinePos = verticalToHorizontal(maxToBoxLinePos);\n    boxPos = verticalToHorizontal(boxPos);\n    boxPos[0] = valueScale(firstQuartile);\n    medianLinePos = verticalToHorizontal(medianLinePos);\n    minToBoxLinePos = verticalToHorizontal(minToBoxLinePos);\n    minLinePos = verticalToHorizontal(minLinePos);\n    containerPos = verticalToHorizontal(containerPos);\n    containerPos[0] = Math.min.apply(Math, toConsumableArray(valueRange));\n  }\n  return react_default.a.createElement(\n    Group,\n    { className: classnames_default()(\'vx-boxplot\', className) },\n    outliers.map(function (d, i) {\n      var cx = horizontal ? valueScale(d) : center;\n      var cy = horizontal ? center : valueScale(d);\n      return react_default.a.createElement(\'circle\', vx_stats_es_extends({\n        key: i,\n        className: \'vx-boxplot-outlier\',\n        cx: cx,\n        cy: cy,\n        stroke: stroke,\n        strokeWidth: 1,\n        fill: fill,\n        fillOpacity: fillOpacity,\n        r: \'4\'\n      }, additionalProps(outlierProps, {\n        data: d,\n        cx: cx,\n        cy: cy\n      })));\n    }),\n    react_default.a.createElement(\'line\', vx_stats_es_extends({\n      className: \'vx-boxplot-max\',\n      x1: maxLinePos[0],\n      y1: maxLinePos[1],\n      x2: maxLinePos[2],\n      y2: maxLinePos[3],\n      stroke: stroke,\n      strokeWidth: strokeWidth\n    }, additionalProps(maxProps, {\n      data: data,\n      max: max,\n      x1: maxLinePos[0],\n      x2: maxLinePos[2],\n      y1: maxLinePos[1],\n      y2: maxLinePos[3]\n    }))),\n    react_default.a.createElement(\'line\', {\n      x1: maxToBoxLinePos[0],\n      y1: maxToBoxLinePos[1],\n      x2: maxToBoxLinePos[2],\n      y2: maxToBoxLinePos[3],\n      stroke: stroke,\n      strokeWidth: strokeWidth\n    }),\n    react_default.a.createElement(\'rect\', vx_stats_es_extends({\n      className: \'vx-boxplot-box\',\n      x: boxPos[0],\n      y: boxPos[1],\n      width: boxPos[2],\n      height: boxPos[3],\n      stroke: stroke,\n      strokeWidth: strokeWidth,\n      fill: fill,\n      fillOpacity: fillOpacity,\n      rx: rx,\n      ry: ry\n    }, additionalProps(boxProps, {\n      data: data,\n      height: boxPos[3],\n      median: median,\n      firstQuartile: firstQuartile,\n      thirdQuartile: thirdQuartile,\n      min: min,\n      max: max,\n      x1: boxPos[0],\n      x2: boxPos[0] + boxPos[2],\n      y1: boxPos[1],\n      y2: boxPos[1] + boxPos[3]\n    }))),\n    react_default.a.createElement(\'line\', vx_stats_es_extends({\n      className: \'vx-boxplot-median\',\n      x1: medianLinePos[0],\n      y1: medianLinePos[1],\n      x2: medianLinePos[2],\n      y2: medianLinePos[3],\n      stroke: stroke,\n      strokeWidth: strokeWidth\n    }, additionalProps(medianProps, {\n      data: data,\n      median: median,\n      x1: medianLinePos[0],\n      x2: medianLinePos[2],\n      y1: medianLinePos[1],\n      y2: medianLinePos[3]\n    }))),\n    react_default.a.createElement(\'line\', {\n      x1: minToBoxLinePos[0],\n      y1: minToBoxLinePos[1],\n      x2: minToBoxLinePos[2],\n      y2: minToBoxLinePos[3],\n      stroke: stroke,\n      strokeWidth: strokeWidth\n    }),\n    react_default.a.createElement(\'line\', vx_stats_es_extends({\n      className: \'vx-boxplot-min\',\n      x1: minLinePos[0],\n      y1: minLinePos[1],\n      x2: minLinePos[2],\n      y2: minLinePos[3],\n      stroke: stroke,\n      strokeWidth: strokeWidth\n    }, additionalProps(minProps, {\n      data: data,\n      min: min,\n      x1: minLinePos[0],\n      x2: minLinePos[2],\n      y1: minLinePos[1],\n      y2: minLinePos[3]\n    }))),\n    container && react_default.a.createElement(\'rect\', vx_stats_es_extends({\n      x: containerPos[0],\n      y: containerPos[1],\n      width: containerPos[2],\n      height: containerPos[3],\n      fillOpacity: \'0\'\n    }, additionalProps(containerProps, {\n      data: data,\n      x1: containerPos[0],\n      x2: containerPos[0] + containerPos[2],\n      y1: containerPos[1],\n      y2: containerPos[1] + containerPos[3],\n      median: median,\n      max: max,\n      min: min,\n      thirdQuartile: thirdQuartile,\n      firstQuartile: firstQuartile\n    })))\n  );\n}\n\nfunction ViolinPlot(_ref) {\n  var _ref$left = _ref.left,\n      left = _ref$left === undefined ? 0 : _ref$left,\n      _ref$top = _ref.top,\n      top = _ref$top === undefined ? 0 : _ref$top,\n      className = _ref.className,\n      binData = _ref.binData,\n      _ref$stroke = _ref.stroke,\n      stroke = _ref$stroke === undefined ? \'black\' : _ref$stroke,\n      _ref$fill = _ref.fill,\n      fill = _ref$fill === undefined ? \'rgba(0,0,0,0.3)\' : _ref$fill,\n      opacity = _ref.opacity,\n      strokeWidth = _ref.strokeWidth,\n      width = _ref.width,\n      valueScale = _ref.valueScale,\n      strokeDasharray = _ref.strokeDasharray,\n      horizontal = _ref.horizontal,\n      restProps = vx_stats_es_objectWithoutProperties(_ref, [\'left\', \'top\', \'className\', \'binData\', \'stroke\', \'fill\', \'opacity\', \'strokeWidth\', \'width\', \'valueScale\', \'strokeDasharray\', \'horizontal\']);\n\n  var center = (horizontal ? top : left) + width / 2;\n  var binCounts = binData.map(function (bin) {\n    return bin.count;\n  });\n  var widthScale = vx_scale_es_linear({\n    rangeRound: [0, width / 2],\n    domain: [0, Math.max.apply(Math, toConsumableArray(binCounts))]\n  });\n\n  var path = \'\';\n  if (horizontal) {\n    var topCurve = Object(line["a" /* default */])().x(function (d) {\n      return valueScale(d.value);\n    }).y(function (d) {\n      return center - widthScale(d.count);\n    }).curve(cardinal["b" /* default */]);\n\n    var bottomCurve = Object(line["a" /* default */])().x(function (d) {\n      return valueScale(d.value);\n    }).y(function (d) {\n      return center + widthScale(d.count);\n    }).curve(cardinal["b" /* default */]);\n\n    var topCurvePath = topCurve(binData);\n    var bottomCurvePath = bottomCurve([].concat(toConsumableArray(binData)).reverse());\n    path = topCurvePath + \' \' + bottomCurvePath.replace(\'M\', \'L\') + \' Z\';\n  } else {\n    var rightCurve = Object(line["a" /* default */])().x(function (d) {\n      return center + widthScale(d.count);\n    }).y(function (d) {\n      return valueScale(d.value);\n    }).curve(cardinal["b" /* default */]);\n\n    var leftCurve = Object(line["a" /* default */])().x(function (d) {\n      return center - widthScale(d.count);\n    }).y(function (d) {\n      return valueScale(d.value);\n    }).curve(cardinal["b" /* default */]);\n\n    var rightCurvePath = rightCurve(binData);\n    var leftCurvePath = leftCurve([].concat(toConsumableArray(binData)).reverse());\n    path = rightCurvePath + \' \' + leftCurvePath.replace(\'M\', \'L\') + \' Z\';\n  }\n  return react_default.a.createElement(\n    Group,\n    { className: classnames_default()(\'vx-violin\', className) },\n    react_default.a.createElement(\'path\', vx_stats_es_extends({\n      d: path,\n      stroke: stroke,\n      strokeWidth: strokeWidth,\n      strokeDasharray: strokeDasharray,\n      fill: fill,\n      fillOpacity: opacity\n    }, additionalProps(restProps, binData)))\n  );\n}\n\nfunction computeStats (numericalArray) {\n  var points = [].concat(toConsumableArray(numericalArray)).sort(function (a, b) {\n    return a - b;\n  });\n  var sampleSize = points.length;\n  var firstQuartile = points[Math.round(sampleSize / 4)];\n  var thirdQuartile = points[Math.round(3 * sampleSize / 4)];\n  var IQR = thirdQuartile - firstQuartile;\n\n  var min = firstQuartile - 1.5 * IQR;\n  var max = thirdQuartile + 1.5 * IQR;\n\n  var outliers = points.filter(function (p) {\n    return p < min || p > max;\n  });\n  var binWidth = 2 * IQR * Math.pow(sampleSize - outliers.length, -1 / 3);\n  var binNum = Math.round((max - min) / binWidth);\n  var actualBinWidth = (max - min) / binNum;\n\n  var bins = Array(binNum + 2).fill(0);\n  var values = Array(binNum + 2).fill(min);\n\n  for (var i = 1; i <= binNum; i += 1) {\n    values[i] += actualBinWidth * (i - 0.5);\n  }\n\n  values[values.length - 1] = max;\n\n  points.filter(function (p) {\n    return p >= min && p <= max;\n  }).forEach(function (p) {\n    bins[Math.floor((p - min) / actualBinWidth) + 1] += 1;\n  });\n\n  var binData = values.map(function (v, i) {\n    return {\n      value: v,\n      count: bins[i]\n    };\n  });\n\n  var boxPlot = {\n    min: min,\n    firstQuartile: firstQuartile,\n    median: points[Math.round(sampleSize / 2)],\n    thirdQuartile: thirdQuartile,\n    max: max,\n    outliers: outliers\n  };\n\n  return {\n    boxPlot: boxPlot,\n    binData: binData\n  };\n}\n\n\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/shared/esm/components/FocusBlurHandler.js\nvar FocusBlurHandler = __webpack_require__(2377);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/node_modules/@vx/group/dist/vx-group.es.js\nvar vx_group_es = __webpack_require__(1941);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/prop-types/index.js\nvar prop_types = __webpack_require__(55);\nvar prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/theme/esm/color.js\nvar esm_color = __webpack_require__(1988);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/utils/chartUtils.js\nvar chartUtils = __webpack_require__(1939);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/utils/propShapes.js\nvar propShapes = __webpack_require__(1943);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/utils/sharedSeriesProps.js\nvar sharedSeriesProps = __webpack_require__(1968);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/series/BoxPlotSeries.js\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nfunction BoxPlotSeries_extends() { BoxPlotSeries_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return BoxPlotSeries_extends.apply(this, arguments); }\n\n\n\n\n\n\n\n\n\n\n\nvar propTypes = BoxPlotSeries_extends({}, sharedSeriesProps["a" /* default */], {\n  containerEvents: prop_types_default.a.bool,\n  data: propShapes["c" /* boxPlotSeriesDataShape */].isRequired,\n  fill: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.string]),\n  horizontal: prop_types_default.a.bool,\n  stroke: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.string]),\n  strokeWidth: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  fillOpacity: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  widthRatio: prop_types_default.a.number,\n  containerProps: prop_types_default.a.object,\n  // eslint-disable-line react/forbid-prop-types\n  outlierProps: prop_types_default.a.object,\n  // eslint-disable-line react/forbid-prop-types\n  boxProps: prop_types_default.a.object,\n  // eslint-disable-line react/forbid-prop-types\n  minProps: prop_types_default.a.object,\n  // eslint-disable-line react/forbid-prop-types\n  maxProps: prop_types_default.a.object,\n  // eslint-disable-line react/forbid-prop-types\n  medianProps: prop_types_default.a.object // eslint-disable-line react/forbid-prop-types\n\n});\n\nvar defaultProps = {\n  containerEvents: true,\n  stroke: esm_color["a" /* default */].darkGray,\n  strokeWidth: 2,\n  fill: esm_color["a" /* default */].default,\n  fillOpacity: 1,\n  horizontal: false,\n  widthRatio: 1,\n  containerProps: null,\n  outlierProps: null,\n  boxProps: null,\n  minProps: null,\n  maxProps: null,\n  medianProps: null\n};\nvar MAX_BOX_WIDTH = 50;\n\nvar BoxPlotSeries_x = function x(d) {\n  return d.x;\n};\n\nvar BoxPlotSeries_y = function y(d) {\n  return d.y;\n};\n\nvar BoxPlotSeries_min = function min(d) {\n  return d.min;\n};\n\nvar BoxPlotSeries_max = function max(d) {\n  return d.max;\n};\n\nvar BoxPlotSeries_median = function median(d) {\n  return d.median;\n};\n\nvar BoxPlotSeries_firstQuartile = function firstQuartile(d) {\n  return d.firstQuartile;\n};\n\nvar BoxPlotSeries_thirdQuartile = function thirdQuartile(d) {\n  return d.thirdQuartile;\n};\n\nvar BoxPlotSeries_outliers = function outliers(d) {\n  return d.outliers || [];\n};\n\nvar BoxPlotSeries_BoxPlotSeries =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inheritsLoose(BoxPlotSeries, _React$PureComponent);\n\n  function BoxPlotSeries() {\n    return _React$PureComponent.apply(this, arguments) || this;\n  }\n\n  var _proto = BoxPlotSeries.prototype;\n\n  _proto.render = function render() {\n    var _this$props = this.props,\n        containerEvents = _this$props.containerEvents,\n        data = _this$props.data,\n        fill = _this$props.fill,\n        stroke = _this$props.stroke,\n        strokeWidth = _this$props.strokeWidth,\n        xScale = _this$props.xScale,\n        yScale = _this$props.yScale,\n        horizontal = _this$props.horizontal,\n        widthRatio = _this$props.widthRatio,\n        fillOpacity = _this$props.fillOpacity,\n        containerProps = _this$props.containerProps,\n        outlierProps = _this$props.outlierProps,\n        boxProps = _this$props.boxProps,\n        minProps = _this$props.minProps,\n        maxProps = _this$props.maxProps,\n        medianProps = _this$props.medianProps,\n        onMouseMove = _this$props.onMouseMove,\n        onMouseLeave = _this$props.onMouseLeave,\n        disableMouseEvents = _this$props.disableMouseEvents,\n        onClick = _this$props.onClick;\n    if (!xScale || !yScale) return null;\n    var offsetScale = horizontal ? yScale : xScale;\n    var offsetValue = horizontal ? BoxPlotSeries_y : BoxPlotSeries_x;\n    var valueScale = horizontal ? xScale : yScale;\n    var boxWidth = offsetScale.bandwidth();\n    var actualWidth = Math.min(MAX_BOX_WIDTH, boxWidth);\n    var offset = (offsetScale.offset || 0) - (boxWidth - actualWidth) / 2;\n    var offsetPropName = horizontal ? \'top\' : \'left\';\n\n    var offsetProp = function offsetProp(d) {\n      var _ref;\n\n      return _ref = {}, _ref[offsetPropName] = offsetScale(offsetValue(d)) - offset + (1 - widthRatio) / 2 * actualWidth, _ref;\n    };\n\n    var mouseEventProps = function mouseEventProps(d, i) {\n      return {\n        onMouseMove: disableMouseEvents ? null : onMouseMove && function () {\n          return function (event) {\n            onMouseMove({\n              event: event,\n              data: data,\n              datum: d,\n              index: i\n            });\n          };\n        },\n        onMouseLeave: disableMouseEvents ? null : onMouseLeave && function () {\n          return onMouseLeave;\n        },\n        onClick: disableMouseEvents ? null : onClick && function () {\n          return function (event) {\n            onClick({\n              event: event,\n              data: data,\n              datum: d,\n              index: i\n            });\n          };\n        }\n      };\n    };\n\n    return react_default.a.createElement(vx_group_es["a" /* Group */], null, data.map(function (d, i) {\n      var mouseEvents = mouseEventProps(d, i);\n      return Object(chartUtils["j" /* isDefined */])(BoxPlotSeries_min(d)) && react_default.a.createElement(FocusBlurHandler["a" /* default */], {\n        key: offsetValue(d),\n        xlinkHref: "#",\n        onBlur: disableMouseEvents ? null : onMouseLeave,\n        onFocus: disableMouseEvents ? null : function (event) {\n          onMouseMove({\n            event: event,\n            data: data,\n            datum: d,\n            index: i\n          });\n        }\n      }, react_default.a.createElement(vx_stats_es_BoxPlot, BoxPlotSeries_extends({\n        min: BoxPlotSeries_min(d),\n        max: BoxPlotSeries_max(d)\n      }, offsetProp(d), {\n        firstQuartile: BoxPlotSeries_firstQuartile(d),\n        thirdQuartile: BoxPlotSeries_thirdQuartile(d),\n        median: BoxPlotSeries_median(d),\n        boxWidth: actualWidth * widthRatio,\n        outliers: BoxPlotSeries_outliers(d),\n        fill: d.fill || Object(chartUtils["b" /* callOrValue */])(fill, d, i),\n        stroke: d.stroke || Object(chartUtils["b" /* callOrValue */])(stroke, d, i),\n        strokeWidth: d.strokeWidth || Object(chartUtils["b" /* callOrValue */])(strokeWidth, d, i),\n        fillOpacity: d.fillOpacity || Object(chartUtils["b" /* callOrValue */])(fillOpacity, d, i),\n        valueScale: valueScale,\n        horizontal: horizontal,\n        container: containerEvents,\n        containerProps: (containerEvents || containerProps || undefined) && BoxPlotSeries_extends({}, containerProps, containerEvents && mouseEvents),\n        outlierProps: (!containerEvents || outlierProps || undefined) && BoxPlotSeries_extends({}, outlierProps, !containerEvents && mouseEvents),\n        boxProps: (!containerEvents || boxProps || undefined) && BoxPlotSeries_extends({}, boxProps, !containerEvents && mouseEvents),\n        minProps: (!containerEvents || minProps || undefined) && BoxPlotSeries_extends({}, minProps, !containerEvents && mouseEvents),\n        maxProps: (!containerEvents || maxProps || undefined) && BoxPlotSeries_extends({}, maxProps, !containerEvents && mouseEvents),\n        medianProps: (!containerEvents || medianProps || undefined) && BoxPlotSeries_extends({}, medianProps, !containerEvents && mouseEvents)\n      })));\n    }));\n  };\n\n  return BoxPlotSeries;\n}(react_default.a.PureComponent);\n\n\nBoxPlotSeries_BoxPlotSeries.propTypes = propTypes;\nBoxPlotSeries_BoxPlotSeries.defaultProps = defaultProps;\nBoxPlotSeries_BoxPlotSeries.displayName = \'BoxPlotSeries\';\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/theme/esm/chartTheme.js + 2 modules\nvar chartTheme = __webpack_require__(2408);\n\n// EXTERNAL MODULE: ../superset-ui-core/src/chart-composition/legend/WithLegend.tsx\nvar WithLegend = __webpack_require__(1060);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/typeGuards/ChannelDef.js\nvar ChannelDef = __webpack_require__(1936);\n\n// EXTERNAL MODULE: ../superset-ui-core/src/utils/isDefined.ts\nvar isDefined = __webpack_require__(468);\n\n// EXTERNAL MODULE: ../superset-ui-core/src/chart-composition/tooltip/TooltipFrame.tsx\nvar TooltipFrame = __webpack_require__(1061);\n\n// EXTERNAL MODULE: ../superset-ui-core/src/chart-composition/tooltip/TooltipTable.tsx\nvar TooltipTable = __webpack_require__(1062);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/components/BoxPlot/DefaultTooltipRenderer.tsx\n\n\nfunction DefaultTooltipRenderer({ datum, color, encoder, }) {\n    const { label, min, max, median, firstQuartile, thirdQuartile, outliers } = datum;\n    const { channels } = encoder;\n    const { formatValue } = channels.y;\n    const data = [];\n    if (Object(isDefined["a" /* default */])(min)) {\n        data.push({ key: \'Min\', valueColumn: formatValue(min) });\n    }\n    if (Object(isDefined["a" /* default */])(max)) {\n        data.push({ key: \'Max\', valueColumn: formatValue(max) });\n    }\n    if (Object(isDefined["a" /* default */])(median)) {\n        data.push({ key: \'Median\', valueColumn: formatValue(median) });\n    }\n    if (Object(isDefined["a" /* default */])(firstQuartile)) {\n        data.push({ key: \'1st Quartile\', valueColumn: formatValue(firstQuartile) });\n    }\n    if (Object(isDefined["a" /* default */])(thirdQuartile)) {\n        data.push({ key: \'3rd Quartile\', valueColumn: formatValue(thirdQuartile) });\n    }\n    if (Object(isDefined["a" /* default */])(outliers) && outliers.length > 0) {\n        data.push({ key: \'# Outliers\', valueColumn: outliers.length });\n    }\n    return (react_default.a.createElement(TooltipFrame["a" /* default */], null,\n        react_default.a.createElement("div", null,\n            react_default.a.createElement("strong", { style: { color } }, label)),\n        data.length > 0 && react_default.a.createElement("br", null),\n        react_default.a.createElement(TooltipTable["a" /* default */], { data: data })));\n}\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/encodable/esm/encoders/createEncoderFactory.js + 53 modules\nvar createEncoderFactory = __webpack_require__(2220);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/components/BoxPlot/Encoder.ts\n\nconst boxPlotEncoderFactory = Object(createEncoderFactory["a" /* default */])({\n    channelTypes: {\n        x: \'XBand\',\n        y: \'YBand\',\n        color: \'Color\',\n    },\n    defaultEncoding: {\n        x: { field: \'x\', type: \'nominal\' },\n        y: { field: \'y\', type: \'quantitative\' },\n        color: { value: \'#222\' },\n    },\n});\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/utils/createMarginSelector.tsx\nvar createMarginSelector = __webpack_require__(1978);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/utils/convertScaleToDataUIScaleShape.ts\nvar convertScaleToDataUIScaleShape = __webpack_require__(1979);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/utils/createXYChartLayoutWithTheme.ts + 3 modules\nvar createXYChartLayoutWithTheme = __webpack_require__(1980);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/components/legend/createRenderLegend.tsx + 3 modules\nvar createRenderLegend = __webpack_require__(1981);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/preset-chart-xy/src/components/BoxPlot/BoxPlot.tsx\n\n\n\n\n\n\n\n\n\n\n\nconst BoxPlot_defaultProps = {\n    className: \'\',\n    margin: createMarginSelector["a" /* DEFAULT_MARGIN */],\n    encoding: {},\n    theme: chartTheme["a" /* default */],\n    TooltipRenderer: DefaultTooltipRenderer,\n};\nclass BoxPlot_BoxPlot extends react_default.a.PureComponent {\n    constructor() {\n        super(...arguments);\n        this.createEncoder = boxPlotEncoderFactory.createSelector();\n        this.createMargin = Object(createMarginSelector["b" /* default */])();\n        this.renderChart = (dim) => {\n            const { width, height } = dim;\n            const { data, margin, theme, TooltipRenderer, encoding } = this.props;\n            const encoder = this.createEncoder(encoding);\n            const { channels } = encoder;\n            const isHorizontal = Object(ChannelDef["a" /* isFieldDef */])(channels.y.definition) && channels.y.definition.type === \'nominal\';\n            encoder.setDomainFromDataset(data);\n            const layout = Object(createXYChartLayoutWithTheme["a" /* default */])({\n                width,\n                height,\n                margin: this.createMargin(margin),\n                theme,\n                xEncoder: channels.x,\n                yEncoder: channels.y,\n            });\n            return layout.renderChartWithFrame((chartDim) => (react_default.a.createElement(XYChart["a" /* default */], { showYGrid: true, width: chartDim.width, height: chartDim.height, ariaLabel: "BoxPlot", margin: layout.margin, renderTooltip: ({ datum, color }) => (react_default.a.createElement(TooltipRenderer, { datum: datum, color: color, encoder: encoder })), theme: theme, \n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                xScale: Object(convertScaleToDataUIScaleShape["a" /* default */])(channels.x.definition.scale), \n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                yScale: Object(convertScaleToDataUIScaleShape["a" /* default */])(channels.y.definition.scale) },\n                layout.renderXAxis(),\n                layout.renderYAxis(),\n                react_default.a.createElement(BoxPlotSeries_BoxPlotSeries, { key: Object(ChannelDef["a" /* isFieldDef */])(channels.x.definition) ? channels.x.definition.field : \'\', animated: true, data: isHorizontal\n                        ? data.map(row => (Object.assign(Object.assign({}, row), { y: channels.y.getValueFromDatum(row) })))\n                        : data.map(row => (Object.assign(Object.assign({}, row), { x: channels.x.getValueFromDatum(row) }))), fill: (datum) => channels.color.encodeDatum(datum, \'#55acee\'), fillOpacity: 0.4, stroke: (datum) => channels.color.encodeDatum(datum), strokeWidth: 1, widthRatio: 0.6, horizontal: isHorizontal }))));\n        };\n    }\n    render() {\n        const { className, data, encoding, width, height } = this.props;\n        return (react_default.a.createElement(WithLegend["a" /* default */], { className: `superset-chart-box-plot ${className}`, width: width, height: height, position: "top", renderLegend: Object(createRenderLegend["a" /* default */])(this.createEncoder(encoding), data, this.props), renderChart: this.renderChart }));\n    }\n}\nBoxPlot_BoxPlot.defaultProps = BoxPlot_defaultProps;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjM5MS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0B2eC9zdGF0cy9ub2RlX21vZHVsZXMvQHZ4L2dyb3VwL2Rpc3QvdngtZ3JvdXAuZXMuanM/YzlmMCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9Adngvc3RhdHMvbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9pbml0LmpzPzc5OGUiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L3N0YXRzL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvYXJyYXkuanM/ZDIyNyIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9Adngvc3RhdHMvbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9vcmRpbmFsLmpzP2M2N2EiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L3N0YXRzL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvYmFuZC5qcz83ODE2Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0B2eC9zdGF0cy9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL2NvbnN0YW50LmpzPzI4MTciLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L3N0YXRzL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvbnVtYmVyLmpzPzk3NmQiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L3N0YXRzL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvY29udGludW91cy5qcz8zMGUxIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0B2eC9zdGF0cy9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL3RpY2tGb3JtYXQuanM/ZjJiMCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9Adngvc3RhdHMvbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9saW5lYXIuanM/ODlkZCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9Adngvc3RhdHMvbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9pZGVudGl0eS5qcz85ZGRkIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0B2eC9zdGF0cy9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL25pY2UuanM/YzkzMCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9Adngvc3RhdHMvbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9sb2cuanM/MDQ0ZCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9Adngvc3RhdHMvbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9zeW1sb2cuanM/MzY1NSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9Adngvc3RhdHMvbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9wb3cuanM/ODEzZCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9Adngvc3RhdHMvbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9xdWFudGlsZS5qcz80MzI1Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0B2eC9zdGF0cy9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL3F1YW50aXplLmpzP2MxYTkiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L3N0YXRzL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvdGhyZXNob2xkLmpzPzFhNjciLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L3N0YXRzL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvdGltZS5qcz80YWVkIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0B2eC9zdGF0cy9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL3V0Y1RpbWUuanM/ODU5YiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9Adngvc3RhdHMvbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9zZXF1ZW50aWFsLmpzP2M2M2IiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L3N0YXRzL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvc2VxdWVudGlhbFF1YW50aWxlLmpzPzQ4MTYiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L3N0YXRzL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvZGl2ZXJnaW5nLmpzPzI1ODMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L3N0YXRzL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvaW5kZXguanM/N2I4MyIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9Adngvc3RhdHMvbm9kZV9tb2R1bGVzL0B2eC9zY2FsZS9kaXN0L3Z4LXNjYWxlLmVzLmpzPzcxYzYiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L3N0YXRzL2Rpc3Qvdngtc3RhdHMuZXMuanM/YmRiNSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS94eS1jaGFydC9lc20vc2VyaWVzL0JveFBsb3RTZXJpZXMuanM/NTQ2YiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvcHJlc2V0LWNoYXJ0LXh5L3NyYy9jb21wb25lbnRzL0JveFBsb3QvRGVmYXVsdFRvb2x0aXBSZW5kZXJlci50c3g/ZWViNiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvcHJlc2V0LWNoYXJ0LXh5L3NyYy9jb21wb25lbnRzL0JveFBsb3QvRW5jb2Rlci50cz9iYzFiIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wcmVzZXQtY2hhcnQteHkvc3JjL2NvbXBvbmVudHMvQm94UGxvdC9Cb3hQbG90LnRzeD82Y2M5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY3ggZnJvbSAnY2xhc3NuYW1lcyc7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG52YXIgb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgPSBmdW5jdGlvbiAob2JqLCBrZXlzKSB7XG4gIHZhciB0YXJnZXQgPSB7fTtcblxuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7XG4gICAgdGFyZ2V0W2ldID0gb2JqW2ldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbmZ1bmN0aW9uIEdyb3VwKF9yZWYpIHtcbiAgdmFyIF9yZWYkdG9wID0gX3JlZi50b3AsXG4gICAgICB0b3AgPSBfcmVmJHRvcCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkdG9wLFxuICAgICAgX3JlZiRsZWZ0ID0gX3JlZi5sZWZ0LFxuICAgICAgbGVmdCA9IF9yZWYkbGVmdCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkbGVmdCxcbiAgICAgIHRyYW5zZm9ybSA9IF9yZWYudHJhbnNmb3JtLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ3RvcCcsICdsZWZ0JywgJ3RyYW5zZm9ybScsICdjbGFzc05hbWUnLCAnY2hpbGRyZW4nXSk7XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgJ2cnLFxuICAgIF9leHRlbmRzKHtcbiAgICAgIGNsYXNzTmFtZTogY3goJ2N4LWdyb3VwJywgY2xhc3NOYW1lKSxcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtIHx8ICd0cmFuc2xhdGUoJyArIGxlZnQgKyAnLCAnICsgdG9wICsgJyknXG4gICAgfSwgcmVzdFByb3BzKSxcbiAgICBjaGlsZHJlblxuICApO1xufVxuXG5leHBvcnQgeyBHcm91cCB9O1xuIiwiZXhwb3J0IGZ1bmN0aW9uIGluaXRSYW5nZShkb21haW4sIHJhbmdlKSB7XG4gIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogYnJlYWs7XG4gICAgY2FzZSAxOiB0aGlzLnJhbmdlKGRvbWFpbik7IGJyZWFrO1xuICAgIGRlZmF1bHQ6IHRoaXMucmFuZ2UocmFuZ2UpLmRvbWFpbihkb21haW4pOyBicmVhaztcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXRJbnRlcnBvbGF0b3IoZG9tYWluLCBpbnRlcnBvbGF0b3IpIHtcbiAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiBicmVhaztcbiAgICBjYXNlIDE6IHRoaXMuaW50ZXJwb2xhdG9yKGRvbWFpbik7IGJyZWFrO1xuICAgIGRlZmF1bHQ6IHRoaXMuaW50ZXJwb2xhdG9yKGludGVycG9sYXRvcikuZG9tYWluKGRvbWFpbik7IGJyZWFrO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuIiwidmFyIGFycmF5ID0gQXJyYXkucHJvdG90eXBlO1xuXG5leHBvcnQgdmFyIG1hcCA9IGFycmF5Lm1hcDtcbmV4cG9ydCB2YXIgc2xpY2UgPSBhcnJheS5zbGljZTtcbiIsImltcG9ydCB7bWFwfSBmcm9tIFwiZDMtY29sbGVjdGlvblwiO1xuaW1wb3J0IHtzbGljZX0gZnJvbSBcIi4vYXJyYXlcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0XCI7XG5cbmV4cG9ydCB2YXIgaW1wbGljaXQgPSB7bmFtZTogXCJpbXBsaWNpdFwifTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gb3JkaW5hbCgpIHtcbiAgdmFyIGluZGV4ID0gbWFwKCksXG4gICAgICBkb21haW4gPSBbXSxcbiAgICAgIHJhbmdlID0gW10sXG4gICAgICB1bmtub3duID0gaW1wbGljaXQ7XG5cbiAgZnVuY3Rpb24gc2NhbGUoZCkge1xuICAgIHZhciBrZXkgPSBkICsgXCJcIiwgaSA9IGluZGV4LmdldChrZXkpO1xuICAgIGlmICghaSkge1xuICAgICAgaWYgKHVua25vd24gIT09IGltcGxpY2l0KSByZXR1cm4gdW5rbm93bjtcbiAgICAgIGluZGV4LnNldChrZXksIGkgPSBkb21haW4ucHVzaChkKSk7XG4gICAgfVxuICAgIHJldHVybiByYW5nZVsoaSAtIDEpICUgcmFuZ2UubGVuZ3RoXTtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkb21haW4uc2xpY2UoKTtcbiAgICBkb21haW4gPSBbXSwgaW5kZXggPSBtYXAoKTtcbiAgICB2YXIgaSA9IC0xLCBuID0gXy5sZW5ndGgsIGQsIGtleTtcbiAgICB3aGlsZSAoKytpIDwgbikgaWYgKCFpbmRleC5oYXMoa2V5ID0gKGQgPSBfW2ldKSArIFwiXCIpKSBpbmRleC5zZXQoa2V5LCBkb21haW4ucHVzaChkKSk7XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmdlID0gc2xpY2UuY2FsbChfKSwgc2NhbGUpIDogcmFuZ2Uuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS51bmtub3duID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHVua25vd24gPSBfLCBzY2FsZSkgOiB1bmtub3duO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gb3JkaW5hbChkb21haW4sIHJhbmdlKS51bmtub3duKHVua25vd24pO1xuICB9O1xuXG4gIGluaXRSYW5nZS5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcblxuICByZXR1cm4gc2NhbGU7XG59XG4iLCJpbXBvcnQge3JhbmdlIGFzIHNlcXVlbmNlfSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0XCI7XG5pbXBvcnQgb3JkaW5hbCBmcm9tIFwiLi9vcmRpbmFsXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJhbmQoKSB7XG4gIHZhciBzY2FsZSA9IG9yZGluYWwoKS51bmtub3duKHVuZGVmaW5lZCksXG4gICAgICBkb21haW4gPSBzY2FsZS5kb21haW4sXG4gICAgICBvcmRpbmFsUmFuZ2UgPSBzY2FsZS5yYW5nZSxcbiAgICAgIHJhbmdlID0gWzAsIDFdLFxuICAgICAgc3RlcCxcbiAgICAgIGJhbmR3aWR0aCxcbiAgICAgIHJvdW5kID0gZmFsc2UsXG4gICAgICBwYWRkaW5nSW5uZXIgPSAwLFxuICAgICAgcGFkZGluZ091dGVyID0gMCxcbiAgICAgIGFsaWduID0gMC41O1xuXG4gIGRlbGV0ZSBzY2FsZS51bmtub3duO1xuXG4gIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgdmFyIG4gPSBkb21haW4oKS5sZW5ndGgsXG4gICAgICAgIHJldmVyc2UgPSByYW5nZVsxXSA8IHJhbmdlWzBdLFxuICAgICAgICBzdGFydCA9IHJhbmdlW3JldmVyc2UgLSAwXSxcbiAgICAgICAgc3RvcCA9IHJhbmdlWzEgLSByZXZlcnNlXTtcbiAgICBzdGVwID0gKHN0b3AgLSBzdGFydCkgLyBNYXRoLm1heCgxLCBuIC0gcGFkZGluZ0lubmVyICsgcGFkZGluZ091dGVyICogMik7XG4gICAgaWYgKHJvdW5kKSBzdGVwID0gTWF0aC5mbG9vcihzdGVwKTtcbiAgICBzdGFydCArPSAoc3RvcCAtIHN0YXJ0IC0gc3RlcCAqIChuIC0gcGFkZGluZ0lubmVyKSkgKiBhbGlnbjtcbiAgICBiYW5kd2lkdGggPSBzdGVwICogKDEgLSBwYWRkaW5nSW5uZXIpO1xuICAgIGlmIChyb3VuZCkgc3RhcnQgPSBNYXRoLnJvdW5kKHN0YXJ0KSwgYmFuZHdpZHRoID0gTWF0aC5yb3VuZChiYW5kd2lkdGgpO1xuICAgIHZhciB2YWx1ZXMgPSBzZXF1ZW5jZShuKS5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gc3RhcnQgKyBzdGVwICogaTsgfSk7XG4gICAgcmV0dXJuIG9yZGluYWxSYW5nZShyZXZlcnNlID8gdmFsdWVzLnJldmVyc2UoKSA6IHZhbHVlcyk7XG4gIH1cblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZG9tYWluKF8pLCByZXNjYWxlKCkpIDogZG9tYWluKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFuZ2UgPSBbK19bMF0sICtfWzFdXSwgcmVzY2FsZSgpKSA6IHJhbmdlLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2VSb3VuZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gcmFuZ2UgPSBbK19bMF0sICtfWzFdXSwgcm91bmQgPSB0cnVlLCByZXNjYWxlKCk7XG4gIH07XG5cbiAgc2NhbGUuYmFuZHdpZHRoID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGJhbmR3aWR0aDtcbiAgfTtcblxuICBzY2FsZS5zdGVwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHN0ZXA7XG4gIH07XG5cbiAgc2NhbGUucm91bmQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocm91bmQgPSAhIV8sIHJlc2NhbGUoKSkgOiByb3VuZDtcbiAgfTtcblxuICBzY2FsZS5wYWRkaW5nID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmdJbm5lciA9IE1hdGgubWluKDEsIHBhZGRpbmdPdXRlciA9ICtfKSwgcmVzY2FsZSgpKSA6IHBhZGRpbmdJbm5lcjtcbiAgfTtcblxuICBzY2FsZS5wYWRkaW5nSW5uZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ0lubmVyID0gTWF0aC5taW4oMSwgXyksIHJlc2NhbGUoKSkgOiBwYWRkaW5nSW5uZXI7XG4gIH07XG5cbiAgc2NhbGUucGFkZGluZ091dGVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmdPdXRlciA9ICtfLCByZXNjYWxlKCkpIDogcGFkZGluZ091dGVyO1xuICB9O1xuXG4gIHNjYWxlLmFsaWduID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGFsaWduID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgXykpLCByZXNjYWxlKCkpIDogYWxpZ247XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBiYW5kKGRvbWFpbigpLCByYW5nZSlcbiAgICAgICAgLnJvdW5kKHJvdW5kKVxuICAgICAgICAucGFkZGluZ0lubmVyKHBhZGRpbmdJbm5lcilcbiAgICAgICAgLnBhZGRpbmdPdXRlcihwYWRkaW5nT3V0ZXIpXG4gICAgICAgIC5hbGlnbihhbGlnbik7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRSYW5nZS5hcHBseShyZXNjYWxlKCksIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIHBvaW50aXNoKHNjYWxlKSB7XG4gIHZhciBjb3B5ID0gc2NhbGUuY29weTtcblxuICBzY2FsZS5wYWRkaW5nID0gc2NhbGUucGFkZGluZ091dGVyO1xuICBkZWxldGUgc2NhbGUucGFkZGluZ0lubmVyO1xuICBkZWxldGUgc2NhbGUucGFkZGluZ091dGVyO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcG9pbnRpc2goY29weSgpKTtcbiAgfTtcblxuICByZXR1cm4gc2NhbGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb2ludCgpIHtcbiAgcmV0dXJuIHBvaW50aXNoKGJhbmQuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5wYWRkaW5nSW5uZXIoMSkpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiAreDtcbn1cbiIsImltcG9ydCB7YmlzZWN0fSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7aW50ZXJwb2xhdGUgYXMgaW50ZXJwb2xhdGVWYWx1ZSwgaW50ZXJwb2xhdGVOdW1iZXIsIGludGVycG9sYXRlUm91bmR9IGZyb20gXCJkMy1pbnRlcnBvbGF0ZVwiO1xuaW1wb3J0IHttYXAsIHNsaWNlfSBmcm9tIFwiLi9hcnJheVwiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50XCI7XG5pbXBvcnQgbnVtYmVyIGZyb20gXCIuL251bWJlclwiO1xuXG52YXIgdW5pdCA9IFswLCAxXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlkZW50aXR5KHgpIHtcbiAgcmV0dXJuIHg7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZShhLCBiKSB7XG4gIHJldHVybiAoYiAtPSAoYSA9ICthKSlcbiAgICAgID8gZnVuY3Rpb24oeCkgeyByZXR1cm4gKHggLSBhKSAvIGI7IH1cbiAgICAgIDogY29uc3RhbnQoaXNOYU4oYikgPyBOYU4gOiAwLjUpO1xufVxuXG5mdW5jdGlvbiBjbGFtcGVyKGRvbWFpbikge1xuICB2YXIgYSA9IGRvbWFpblswXSwgYiA9IGRvbWFpbltkb21haW4ubGVuZ3RoIC0gMV0sIHQ7XG4gIGlmIChhID4gYikgdCA9IGEsIGEgPSBiLCBiID0gdDtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgubWF4KGEsIE1hdGgubWluKGIsIHgpKTsgfTtcbn1cblxuLy8gbm9ybWFsaXplKGEsIGIpKHgpIHRha2VzIGEgZG9tYWluIHZhbHVlIHggaW4gW2EsYl0gYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGFyYW1ldGVyIHQgaW4gWzAsMV0uXG4vLyBpbnRlcnBvbGF0ZShhLCBiKSh0KSB0YWtlcyBhIHBhcmFtZXRlciB0IGluIFswLDFdIGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHJhbmdlIHZhbHVlIHggaW4gW2EsYl0uXG5mdW5jdGlvbiBiaW1hcChkb21haW4sIHJhbmdlLCBpbnRlcnBvbGF0ZSkge1xuICB2YXIgZDAgPSBkb21haW5bMF0sIGQxID0gZG9tYWluWzFdLCByMCA9IHJhbmdlWzBdLCByMSA9IHJhbmdlWzFdO1xuICBpZiAoZDEgPCBkMCkgZDAgPSBub3JtYWxpemUoZDEsIGQwKSwgcjAgPSBpbnRlcnBvbGF0ZShyMSwgcjApO1xuICBlbHNlIGQwID0gbm9ybWFsaXplKGQwLCBkMSksIHIwID0gaW50ZXJwb2xhdGUocjAsIHIxKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHIwKGQwKHgpKTsgfTtcbn1cblxuZnVuY3Rpb24gcG9seW1hcChkb21haW4sIHJhbmdlLCBpbnRlcnBvbGF0ZSkge1xuICB2YXIgaiA9IE1hdGgubWluKGRvbWFpbi5sZW5ndGgsIHJhbmdlLmxlbmd0aCkgLSAxLFxuICAgICAgZCA9IG5ldyBBcnJheShqKSxcbiAgICAgIHIgPSBuZXcgQXJyYXkoaiksXG4gICAgICBpID0gLTE7XG5cbiAgLy8gUmV2ZXJzZSBkZXNjZW5kaW5nIGRvbWFpbnMuXG4gIGlmIChkb21haW5bal0gPCBkb21haW5bMF0pIHtcbiAgICBkb21haW4gPSBkb21haW4uc2xpY2UoKS5yZXZlcnNlKCk7XG4gICAgcmFuZ2UgPSByYW5nZS5zbGljZSgpLnJldmVyc2UoKTtcbiAgfVxuXG4gIHdoaWxlICgrK2kgPCBqKSB7XG4gICAgZFtpXSA9IG5vcm1hbGl6ZShkb21haW5baV0sIGRvbWFpbltpICsgMV0pO1xuICAgIHJbaV0gPSBpbnRlcnBvbGF0ZShyYW5nZVtpXSwgcmFuZ2VbaSArIDFdKTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgdmFyIGkgPSBiaXNlY3QoZG9tYWluLCB4LCAxLCBqKSAtIDE7XG4gICAgcmV0dXJuIHJbaV0oZFtpXSh4KSk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KHNvdXJjZSwgdGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXRcbiAgICAgIC5kb21haW4oc291cmNlLmRvbWFpbigpKVxuICAgICAgLnJhbmdlKHNvdXJjZS5yYW5nZSgpKVxuICAgICAgLmludGVycG9sYXRlKHNvdXJjZS5pbnRlcnBvbGF0ZSgpKVxuICAgICAgLmNsYW1wKHNvdXJjZS5jbGFtcCgpKVxuICAgICAgLnVua25vd24oc291cmNlLnVua25vd24oKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1lcigpIHtcbiAgdmFyIGRvbWFpbiA9IHVuaXQsXG4gICAgICByYW5nZSA9IHVuaXQsXG4gICAgICBpbnRlcnBvbGF0ZSA9IGludGVycG9sYXRlVmFsdWUsXG4gICAgICB0cmFuc2Zvcm0sXG4gICAgICB1bnRyYW5zZm9ybSxcbiAgICAgIHVua25vd24sXG4gICAgICBjbGFtcCA9IGlkZW50aXR5LFxuICAgICAgcGllY2V3aXNlLFxuICAgICAgb3V0cHV0LFxuICAgICAgaW5wdXQ7XG5cbiAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICBwaWVjZXdpc2UgPSBNYXRoLm1pbihkb21haW4ubGVuZ3RoLCByYW5nZS5sZW5ndGgpID4gMiA/IHBvbHltYXAgOiBiaW1hcDtcbiAgICBvdXRwdXQgPSBpbnB1dCA9IG51bGw7XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgIHJldHVybiBpc05hTih4ID0gK3gpID8gdW5rbm93biA6IChvdXRwdXQgfHwgKG91dHB1dCA9IHBpZWNld2lzZShkb21haW4ubWFwKHRyYW5zZm9ybSksIHJhbmdlLCBpbnRlcnBvbGF0ZSkpKSh0cmFuc2Zvcm0oY2xhbXAoeCkpKTtcbiAgfVxuXG4gIHNjYWxlLmludmVydCA9IGZ1bmN0aW9uKHkpIHtcbiAgICByZXR1cm4gY2xhbXAodW50cmFuc2Zvcm0oKGlucHV0IHx8IChpbnB1dCA9IHBpZWNld2lzZShyYW5nZSwgZG9tYWluLm1hcCh0cmFuc2Zvcm0pLCBpbnRlcnBvbGF0ZU51bWJlcikpKSh5KSkpO1xuICB9O1xuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4gPSBtYXAuY2FsbChfLCBudW1iZXIpLCBjbGFtcCA9PT0gaWRlbnRpdHkgfHwgKGNsYW1wID0gY2xhbXBlcihkb21haW4pKSwgcmVzY2FsZSgpKSA6IGRvbWFpbi5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmdlID0gc2xpY2UuY2FsbChfKSwgcmVzY2FsZSgpKSA6IHJhbmdlLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2VSb3VuZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gcmFuZ2UgPSBzbGljZS5jYWxsKF8pLCBpbnRlcnBvbGF0ZSA9IGludGVycG9sYXRlUm91bmQsIHJlc2NhbGUoKTtcbiAgfTtcblxuICBzY2FsZS5jbGFtcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjbGFtcCA9IF8gPyBjbGFtcGVyKGRvbWFpbikgOiBpZGVudGl0eSwgc2NhbGUpIDogY2xhbXAgIT09IGlkZW50aXR5O1xuICB9O1xuXG4gIHNjYWxlLmludGVycG9sYXRlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGludGVycG9sYXRlID0gXywgcmVzY2FsZSgpKSA6IGludGVycG9sYXRlO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHQsIHUpIHtcbiAgICB0cmFuc2Zvcm0gPSB0LCB1bnRyYW5zZm9ybSA9IHU7XG4gICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29udGludW91cyh0cmFuc2Zvcm0sIHVudHJhbnNmb3JtKSB7XG4gIHJldHVybiB0cmFuc2Zvcm1lcigpKHRyYW5zZm9ybSwgdW50cmFuc2Zvcm0pO1xufVxuIiwiaW1wb3J0IHt0aWNrU3RlcH0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge2Zvcm1hdCwgZm9ybWF0UHJlZml4LCBmb3JtYXRTcGVjaWZpZXIsIHByZWNpc2lvbkZpeGVkLCBwcmVjaXNpb25QcmVmaXgsIHByZWNpc2lvblJvdW5kfSBmcm9tIFwiZDMtZm9ybWF0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBjb3VudCwgc3BlY2lmaWVyKSB7XG4gIHZhciBzdGVwID0gdGlja1N0ZXAoc3RhcnQsIHN0b3AsIGNvdW50KSxcbiAgICAgIHByZWNpc2lvbjtcbiAgc3BlY2lmaWVyID0gZm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllciA9PSBudWxsID8gXCIsZlwiIDogc3BlY2lmaWVyKTtcbiAgc3dpdGNoIChzcGVjaWZpZXIudHlwZSkge1xuICAgIGNhc2UgXCJzXCI6IHtcbiAgICAgIHZhciB2YWx1ZSA9IE1hdGgubWF4KE1hdGguYWJzKHN0YXJ0KSwgTWF0aC5hYnMoc3RvcCkpO1xuICAgICAgaWYgKHNwZWNpZmllci5wcmVjaXNpb24gPT0gbnVsbCAmJiAhaXNOYU4ocHJlY2lzaW9uID0gcHJlY2lzaW9uUHJlZml4KHN0ZXAsIHZhbHVlKSkpIHNwZWNpZmllci5wcmVjaXNpb24gPSBwcmVjaXNpb247XG4gICAgICByZXR1cm4gZm9ybWF0UHJlZml4KHNwZWNpZmllciwgdmFsdWUpO1xuICAgIH1cbiAgICBjYXNlIFwiXCI6XG4gICAgY2FzZSBcImVcIjpcbiAgICBjYXNlIFwiZ1wiOlxuICAgIGNhc2UgXCJwXCI6XG4gICAgY2FzZSBcInJcIjoge1xuICAgICAgaWYgKHNwZWNpZmllci5wcmVjaXNpb24gPT0gbnVsbCAmJiAhaXNOYU4ocHJlY2lzaW9uID0gcHJlY2lzaW9uUm91bmQoc3RlcCwgTWF0aC5tYXgoTWF0aC5hYnMoc3RhcnQpLCBNYXRoLmFicyhzdG9wKSkpKSkgc3BlY2lmaWVyLnByZWNpc2lvbiA9IHByZWNpc2lvbiAtIChzcGVjaWZpZXIudHlwZSA9PT0gXCJlXCIpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJmXCI6XG4gICAgY2FzZSBcIiVcIjoge1xuICAgICAgaWYgKHNwZWNpZmllci5wcmVjaXNpb24gPT0gbnVsbCAmJiAhaXNOYU4ocHJlY2lzaW9uID0gcHJlY2lzaW9uRml4ZWQoc3RlcCkpKSBzcGVjaWZpZXIucHJlY2lzaW9uID0gcHJlY2lzaW9uIC0gKHNwZWNpZmllci50eXBlID09PSBcIiVcIikgKiAyO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBmb3JtYXQoc3BlY2lmaWVyKTtcbn1cbiIsImltcG9ydCB7dGlja3MsIHRpY2tJbmNyZW1lbnR9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IGNvbnRpbnVvdXMsIHtjb3B5LCBpZGVudGl0eX0gZnJvbSBcIi4vY29udGludW91c1wiO1xuaW1wb3J0IHtpbml0UmFuZ2V9IGZyb20gXCIuL2luaXRcIjtcbmltcG9ydCB0aWNrRm9ybWF0IGZyb20gXCIuL3RpY2tGb3JtYXRcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhcmlzaChzY2FsZSkge1xuICB2YXIgZG9tYWluID0gc2NhbGUuZG9tYWluO1xuXG4gIHNjYWxlLnRpY2tzID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICB2YXIgZCA9IGRvbWFpbigpO1xuICAgIHJldHVybiB0aWNrcyhkWzBdLCBkW2QubGVuZ3RoIC0gMV0sIGNvdW50ID09IG51bGwgPyAxMCA6IGNvdW50KTtcbiAgfTtcblxuICBzY2FsZS50aWNrRm9ybWF0ID0gZnVuY3Rpb24oY291bnQsIHNwZWNpZmllcikge1xuICAgIHZhciBkID0gZG9tYWluKCk7XG4gICAgcmV0dXJuIHRpY2tGb3JtYXQoZFswXSwgZFtkLmxlbmd0aCAtIDFdLCBjb3VudCA9PSBudWxsID8gMTAgOiBjb3VudCwgc3BlY2lmaWVyKTtcbiAgfTtcblxuICBzY2FsZS5uaWNlID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICBpZiAoY291bnQgPT0gbnVsbCkgY291bnQgPSAxMDtcblxuICAgIHZhciBkID0gZG9tYWluKCksXG4gICAgICAgIGkwID0gMCxcbiAgICAgICAgaTEgPSBkLmxlbmd0aCAtIDEsXG4gICAgICAgIHN0YXJ0ID0gZFtpMF0sXG4gICAgICAgIHN0b3AgPSBkW2kxXSxcbiAgICAgICAgc3RlcDtcblxuICAgIGlmIChzdG9wIDwgc3RhcnQpIHtcbiAgICAgIHN0ZXAgPSBzdGFydCwgc3RhcnQgPSBzdG9wLCBzdG9wID0gc3RlcDtcbiAgICAgIHN0ZXAgPSBpMCwgaTAgPSBpMSwgaTEgPSBzdGVwO1xuICAgIH1cblxuICAgIHN0ZXAgPSB0aWNrSW5jcmVtZW50KHN0YXJ0LCBzdG9wLCBjb3VudCk7XG5cbiAgICBpZiAoc3RlcCA+IDApIHtcbiAgICAgIHN0YXJ0ID0gTWF0aC5mbG9vcihzdGFydCAvIHN0ZXApICogc3RlcDtcbiAgICAgIHN0b3AgPSBNYXRoLmNlaWwoc3RvcCAvIHN0ZXApICogc3RlcDtcbiAgICAgIHN0ZXAgPSB0aWNrSW5jcmVtZW50KHN0YXJ0LCBzdG9wLCBjb3VudCk7XG4gICAgfSBlbHNlIGlmIChzdGVwIDwgMCkge1xuICAgICAgc3RhcnQgPSBNYXRoLmNlaWwoc3RhcnQgKiBzdGVwKSAvIHN0ZXA7XG4gICAgICBzdG9wID0gTWF0aC5mbG9vcihzdG9wICogc3RlcCkgLyBzdGVwO1xuICAgICAgc3RlcCA9IHRpY2tJbmNyZW1lbnQoc3RhcnQsIHN0b3AsIGNvdW50KTtcbiAgICB9XG5cbiAgICBpZiAoc3RlcCA+IDApIHtcbiAgICAgIGRbaTBdID0gTWF0aC5mbG9vcihzdGFydCAvIHN0ZXApICogc3RlcDtcbiAgICAgIGRbaTFdID0gTWF0aC5jZWlsKHN0b3AgLyBzdGVwKSAqIHN0ZXA7XG4gICAgICBkb21haW4oZCk7XG4gICAgfSBlbHNlIGlmIChzdGVwIDwgMCkge1xuICAgICAgZFtpMF0gPSBNYXRoLmNlaWwoc3RhcnQgKiBzdGVwKSAvIHN0ZXA7XG4gICAgICBkW2kxXSA9IE1hdGguZmxvb3Ioc3RvcCAqIHN0ZXApIC8gc3RlcDtcbiAgICAgIGRvbWFpbihkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2NhbGU7XG4gIH07XG5cbiAgcmV0dXJuIHNjYWxlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsaW5lYXIoKSB7XG4gIHZhciBzY2FsZSA9IGNvbnRpbnVvdXMoaWRlbnRpdHksIGlkZW50aXR5KTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIGxpbmVhcigpKTtcbiAgfTtcblxuICBpbml0UmFuZ2UuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG5cbiAgcmV0dXJuIGxpbmVhcmlzaChzY2FsZSk7XG59XG4iLCJpbXBvcnQge21hcH0gZnJvbSBcIi4vYXJyYXlcIjtcbmltcG9ydCB7bGluZWFyaXNofSBmcm9tIFwiLi9saW5lYXJcIjtcbmltcG9ydCBudW1iZXIgZnJvbSBcIi4vbnVtYmVyXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlkZW50aXR5KGRvbWFpbikge1xuICB2YXIgdW5rbm93bjtcblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgcmV0dXJuIGlzTmFOKHggPSAreCkgPyB1bmtub3duIDogeDtcbiAgfVxuXG4gIHNjYWxlLmludmVydCA9IHNjYWxlO1xuXG4gIHNjYWxlLmRvbWFpbiA9IHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRvbWFpbiA9IG1hcC5jYWxsKF8sIG51bWJlciksIHNjYWxlKSA6IGRvbWFpbi5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpZGVudGl0eShkb21haW4pLnVua25vd24odW5rbm93bik7XG4gIH07XG5cbiAgZG9tYWluID0gYXJndW1lbnRzLmxlbmd0aCA/IG1hcC5jYWxsKGRvbWFpbiwgbnVtYmVyKSA6IFswLCAxXTtcblxuICByZXR1cm4gbGluZWFyaXNoKHNjYWxlKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGRvbWFpbiwgaW50ZXJ2YWwpIHtcbiAgZG9tYWluID0gZG9tYWluLnNsaWNlKCk7XG5cbiAgdmFyIGkwID0gMCxcbiAgICAgIGkxID0gZG9tYWluLmxlbmd0aCAtIDEsXG4gICAgICB4MCA9IGRvbWFpbltpMF0sXG4gICAgICB4MSA9IGRvbWFpbltpMV0sXG4gICAgICB0O1xuXG4gIGlmICh4MSA8IHgwKSB7XG4gICAgdCA9IGkwLCBpMCA9IGkxLCBpMSA9IHQ7XG4gICAgdCA9IHgwLCB4MCA9IHgxLCB4MSA9IHQ7XG4gIH1cblxuICBkb21haW5baTBdID0gaW50ZXJ2YWwuZmxvb3IoeDApO1xuICBkb21haW5baTFdID0gaW50ZXJ2YWwuY2VpbCh4MSk7XG4gIHJldHVybiBkb21haW47XG59XG4iLCJpbXBvcnQge3RpY2tzfSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7Zm9ybWF0fSBmcm9tIFwiZDMtZm9ybWF0XCI7XG5pbXBvcnQgbmljZSBmcm9tIFwiLi9uaWNlXCI7XG5pbXBvcnQge2NvcHksIHRyYW5zZm9ybWVyfSBmcm9tIFwiLi9jb250aW51b3VzXCI7XG5pbXBvcnQge2luaXRSYW5nZX0gZnJvbSBcIi4vaW5pdFwiO1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Mb2coeCkge1xuICByZXR1cm4gTWF0aC5sb2coeCk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybUV4cCh4KSB7XG4gIHJldHVybiBNYXRoLmV4cCh4KTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtTG9nbih4KSB7XG4gIHJldHVybiAtTWF0aC5sb2coLXgpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1FeHBuKHgpIHtcbiAgcmV0dXJuIC1NYXRoLmV4cCgteCk7XG59XG5cbmZ1bmN0aW9uIHBvdzEwKHgpIHtcbiAgcmV0dXJuIGlzRmluaXRlKHgpID8gKyhcIjFlXCIgKyB4KSA6IHggPCAwID8gMCA6IHg7XG59XG5cbmZ1bmN0aW9uIHBvd3AoYmFzZSkge1xuICByZXR1cm4gYmFzZSA9PT0gMTAgPyBwb3cxMFxuICAgICAgOiBiYXNlID09PSBNYXRoLkUgPyBNYXRoLmV4cFxuICAgICAgOiBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLnBvdyhiYXNlLCB4KTsgfTtcbn1cblxuZnVuY3Rpb24gbG9ncChiYXNlKSB7XG4gIHJldHVybiBiYXNlID09PSBNYXRoLkUgPyBNYXRoLmxvZ1xuICAgICAgOiBiYXNlID09PSAxMCAmJiBNYXRoLmxvZzEwXG4gICAgICB8fCBiYXNlID09PSAyICYmIE1hdGgubG9nMlxuICAgICAgfHwgKGJhc2UgPSBNYXRoLmxvZyhiYXNlKSwgZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5sb2coeCkgLyBiYXNlOyB9KTtcbn1cblxuZnVuY3Rpb24gcmVmbGVjdChmKSB7XG4gIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIC1mKC14KTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvZ2dpc2godHJhbnNmb3JtKSB7XG4gIHZhciBzY2FsZSA9IHRyYW5zZm9ybSh0cmFuc2Zvcm1Mb2csIHRyYW5zZm9ybUV4cCksXG4gICAgICBkb21haW4gPSBzY2FsZS5kb21haW4sXG4gICAgICBiYXNlID0gMTAsXG4gICAgICBsb2dzLFxuICAgICAgcG93cztcblxuICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgIGxvZ3MgPSBsb2dwKGJhc2UpLCBwb3dzID0gcG93cChiYXNlKTtcbiAgICBpZiAoZG9tYWluKClbMF0gPCAwKSB7XG4gICAgICBsb2dzID0gcmVmbGVjdChsb2dzKSwgcG93cyA9IHJlZmxlY3QocG93cyk7XG4gICAgICB0cmFuc2Zvcm0odHJhbnNmb3JtTG9nbiwgdHJhbnNmb3JtRXhwbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYW5zZm9ybSh0cmFuc2Zvcm1Mb2csIHRyYW5zZm9ybUV4cCk7XG4gICAgfVxuICAgIHJldHVybiBzY2FsZTtcbiAgfVxuXG4gIHNjYWxlLmJhc2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYmFzZSA9ICtfLCByZXNjYWxlKCkpIDogYmFzZTtcbiAgfTtcblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZG9tYWluKF8pLCByZXNjYWxlKCkpIDogZG9tYWluKCk7XG4gIH07XG5cbiAgc2NhbGUudGlja3MgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIHZhciBkID0gZG9tYWluKCksXG4gICAgICAgIHUgPSBkWzBdLFxuICAgICAgICB2ID0gZFtkLmxlbmd0aCAtIDFdLFxuICAgICAgICByO1xuXG4gICAgaWYgKHIgPSB2IDwgdSkgaSA9IHUsIHUgPSB2LCB2ID0gaTtcblxuICAgIHZhciBpID0gbG9ncyh1KSxcbiAgICAgICAgaiA9IGxvZ3ModiksXG4gICAgICAgIHAsXG4gICAgICAgIGssXG4gICAgICAgIHQsXG4gICAgICAgIG4gPSBjb3VudCA9PSBudWxsID8gMTAgOiArY291bnQsXG4gICAgICAgIHogPSBbXTtcblxuICAgIGlmICghKGJhc2UgJSAxKSAmJiBqIC0gaSA8IG4pIHtcbiAgICAgIGkgPSBNYXRoLnJvdW5kKGkpIC0gMSwgaiA9IE1hdGgucm91bmQoaikgKyAxO1xuICAgICAgaWYgKHUgPiAwKSBmb3IgKDsgaSA8IGo7ICsraSkge1xuICAgICAgICBmb3IgKGsgPSAxLCBwID0gcG93cyhpKTsgayA8IGJhc2U7ICsraykge1xuICAgICAgICAgIHQgPSBwICogaztcbiAgICAgICAgICBpZiAodCA8IHUpIGNvbnRpbnVlO1xuICAgICAgICAgIGlmICh0ID4gdikgYnJlYWs7XG4gICAgICAgICAgei5wdXNoKHQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgZm9yICg7IGkgPCBqOyArK2kpIHtcbiAgICAgICAgZm9yIChrID0gYmFzZSAtIDEsIHAgPSBwb3dzKGkpOyBrID49IDE7IC0taykge1xuICAgICAgICAgIHQgPSBwICogaztcbiAgICAgICAgICBpZiAodCA8IHUpIGNvbnRpbnVlO1xuICAgICAgICAgIGlmICh0ID4gdikgYnJlYWs7XG4gICAgICAgICAgei5wdXNoKHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHogPSB0aWNrcyhpLCBqLCBNYXRoLm1pbihqIC0gaSwgbikpLm1hcChwb3dzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gciA/IHoucmV2ZXJzZSgpIDogejtcbiAgfTtcblxuICBzY2FsZS50aWNrRm9ybWF0ID0gZnVuY3Rpb24oY291bnQsIHNwZWNpZmllcikge1xuICAgIGlmIChzcGVjaWZpZXIgPT0gbnVsbCkgc3BlY2lmaWVyID0gYmFzZSA9PT0gMTAgPyBcIi4wZVwiIDogXCIsXCI7XG4gICAgaWYgKHR5cGVvZiBzcGVjaWZpZXIgIT09IFwiZnVuY3Rpb25cIikgc3BlY2lmaWVyID0gZm9ybWF0KHNwZWNpZmllcik7XG4gICAgaWYgKGNvdW50ID09PSBJbmZpbml0eSkgcmV0dXJuIHNwZWNpZmllcjtcbiAgICBpZiAoY291bnQgPT0gbnVsbCkgY291bnQgPSAxMDtcbiAgICB2YXIgayA9IE1hdGgubWF4KDEsIGJhc2UgKiBjb3VudCAvIHNjYWxlLnRpY2tzKCkubGVuZ3RoKTsgLy8gVE9ETyBmYXN0IGVzdGltYXRlP1xuICAgIHJldHVybiBmdW5jdGlvbihkKSB7XG4gICAgICB2YXIgaSA9IGQgLyBwb3dzKE1hdGgucm91bmQobG9ncyhkKSkpO1xuICAgICAgaWYgKGkgKiBiYXNlIDwgYmFzZSAtIDAuNSkgaSAqPSBiYXNlO1xuICAgICAgcmV0dXJuIGkgPD0gayA/IHNwZWNpZmllcihkKSA6IFwiXCI7XG4gICAgfTtcbiAgfTtcblxuICBzY2FsZS5uaWNlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRvbWFpbihuaWNlKGRvbWFpbigpLCB7XG4gICAgICBmbG9vcjogZnVuY3Rpb24oeCkgeyByZXR1cm4gcG93cyhNYXRoLmZsb29yKGxvZ3MoeCkpKTsgfSxcbiAgICAgIGNlaWw6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHBvd3MoTWF0aC5jZWlsKGxvZ3MoeCkpKTsgfVxuICAgIH0pKTtcbiAgfTtcblxuICByZXR1cm4gc2NhbGU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxvZygpIHtcbiAgdmFyIHNjYWxlID0gbG9nZ2lzaCh0cmFuc2Zvcm1lcigpKS5kb21haW4oWzEsIDEwXSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBsb2coKSkuYmFzZShzY2FsZS5iYXNlKCkpO1xuICB9O1xuXG4gIGluaXRSYW5nZS5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcblxuICByZXR1cm4gc2NhbGU7XG59XG4iLCJpbXBvcnQge2xpbmVhcmlzaH0gZnJvbSBcIi4vbGluZWFyXCI7XG5pbXBvcnQge2NvcHksIHRyYW5zZm9ybWVyfSBmcm9tIFwiLi9jb250aW51b3VzXCI7XG5pbXBvcnQge2luaXRSYW5nZX0gZnJvbSBcIi4vaW5pdFwiO1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TeW1sb2coYykge1xuICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBNYXRoLnNpZ24oeCkgKiBNYXRoLmxvZzFwKE1hdGguYWJzKHggLyBjKSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN5bWV4cChjKSB7XG4gIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIE1hdGguc2lnbih4KSAqIE1hdGguZXhwbTEoTWF0aC5hYnMoeCkpICogYztcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN5bWxvZ2lzaCh0cmFuc2Zvcm0pIHtcbiAgdmFyIGMgPSAxLCBzY2FsZSA9IHRyYW5zZm9ybSh0cmFuc2Zvcm1TeW1sb2coYyksIHRyYW5zZm9ybVN5bWV4cChjKSk7XG5cbiAgc2NhbGUuY29uc3RhbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0cmFuc2Zvcm0odHJhbnNmb3JtU3ltbG9nKGMgPSArXyksIHRyYW5zZm9ybVN5bWV4cChjKSkgOiBjO1xuICB9O1xuXG4gIHJldHVybiBsaW5lYXJpc2goc2NhbGUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzeW1sb2coKSB7XG4gIHZhciBzY2FsZSA9IHN5bWxvZ2lzaCh0cmFuc2Zvcm1lcigpKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIHN5bWxvZygpKS5jb25zdGFudChzY2FsZS5jb25zdGFudCgpKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdFJhbmdlLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuIiwiaW1wb3J0IHtsaW5lYXJpc2h9IGZyb20gXCIuL2xpbmVhclwiO1xuaW1wb3J0IHtjb3B5LCBpZGVudGl0eSwgdHJhbnNmb3JtZXJ9IGZyb20gXCIuL2NvbnRpbnVvdXNcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0XCI7XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVBvdyhleHBvbmVudCkge1xuICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB4IDwgMCA/IC1NYXRoLnBvdygteCwgZXhwb25lbnQpIDogTWF0aC5wb3coeCwgZXhwb25lbnQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TcXJ0KHgpIHtcbiAgcmV0dXJuIHggPCAwID8gLU1hdGguc3FydCgteCkgOiBNYXRoLnNxcnQoeCk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVNxdWFyZSh4KSB7XG4gIHJldHVybiB4IDwgMCA/IC14ICogeCA6IHggKiB4O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG93aXNoKHRyYW5zZm9ybSkge1xuICB2YXIgc2NhbGUgPSB0cmFuc2Zvcm0oaWRlbnRpdHksIGlkZW50aXR5KSxcbiAgICAgIGV4cG9uZW50ID0gMTtcblxuICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgIHJldHVybiBleHBvbmVudCA9PT0gMSA/IHRyYW5zZm9ybShpZGVudGl0eSwgaWRlbnRpdHkpXG4gICAgICAgIDogZXhwb25lbnQgPT09IDAuNSA/IHRyYW5zZm9ybSh0cmFuc2Zvcm1TcXJ0LCB0cmFuc2Zvcm1TcXVhcmUpXG4gICAgICAgIDogdHJhbnNmb3JtKHRyYW5zZm9ybVBvdyhleHBvbmVudCksIHRyYW5zZm9ybVBvdygxIC8gZXhwb25lbnQpKTtcbiAgfVxuXG4gIHNjYWxlLmV4cG9uZW50ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGV4cG9uZW50ID0gK18sIHJlc2NhbGUoKSkgOiBleHBvbmVudDtcbiAgfTtcblxuICByZXR1cm4gbGluZWFyaXNoKHNjYWxlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcG93KCkge1xuICB2YXIgc2NhbGUgPSBwb3dpc2godHJhbnNmb3JtZXIoKSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBwb3coKSkuZXhwb25lbnQoc2NhbGUuZXhwb25lbnQoKSk7XG4gIH07XG5cbiAgaW5pdFJhbmdlLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xuXG4gIHJldHVybiBzY2FsZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNxcnQoKSB7XG4gIHJldHVybiBwb3cuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5leHBvbmVudCgwLjUpO1xufVxuIiwiaW1wb3J0IHthc2NlbmRpbmcsIGJpc2VjdCwgcXVhbnRpbGUgYXMgdGhyZXNob2xkfSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7c2xpY2V9IGZyb20gXCIuL2FycmF5XCI7XG5pbXBvcnQge2luaXRSYW5nZX0gZnJvbSBcIi4vaW5pdFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBxdWFudGlsZSgpIHtcbiAgdmFyIGRvbWFpbiA9IFtdLFxuICAgICAgcmFuZ2UgPSBbXSxcbiAgICAgIHRocmVzaG9sZHMgPSBbXSxcbiAgICAgIHVua25vd247XG5cbiAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICB2YXIgaSA9IDAsIG4gPSBNYXRoLm1heCgxLCByYW5nZS5sZW5ndGgpO1xuICAgIHRocmVzaG9sZHMgPSBuZXcgQXJyYXkobiAtIDEpO1xuICAgIHdoaWxlICgrK2kgPCBuKSB0aHJlc2hvbGRzW2kgLSAxXSA9IHRocmVzaG9sZChkb21haW4sIGkgLyBuKTtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH1cblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgcmV0dXJuIGlzTmFOKHggPSAreCkgPyB1bmtub3duIDogcmFuZ2VbYmlzZWN0KHRocmVzaG9sZHMsIHgpXTtcbiAgfVxuXG4gIHNjYWxlLmludmVydEV4dGVudCA9IGZ1bmN0aW9uKHkpIHtcbiAgICB2YXIgaSA9IHJhbmdlLmluZGV4T2YoeSk7XG4gICAgcmV0dXJuIGkgPCAwID8gW05hTiwgTmFOXSA6IFtcbiAgICAgIGkgPiAwID8gdGhyZXNob2xkc1tpIC0gMV0gOiBkb21haW5bMF0sXG4gICAgICBpIDwgdGhyZXNob2xkcy5sZW5ndGggPyB0aHJlc2hvbGRzW2ldIDogZG9tYWluW2RvbWFpbi5sZW5ndGggLSAxXVxuICAgIF07XG4gIH07XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbi5zbGljZSgpO1xuICAgIGRvbWFpbiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gXy5sZW5ndGgsIGQ7IGkgPCBuOyArK2kpIGlmIChkID0gX1tpXSwgZCAhPSBudWxsICYmICFpc05hTihkID0gK2QpKSBkb21haW4ucHVzaChkKTtcbiAgICBkb21haW4uc29ydChhc2NlbmRpbmcpO1xuICAgIHJldHVybiByZXNjYWxlKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFuZ2UgPSBzbGljZS5jYWxsKF8pLCByZXNjYWxlKCkpIDogcmFuZ2Uuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS51bmtub3duID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHVua25vd24gPSBfLCBzY2FsZSkgOiB1bmtub3duO1xuICB9O1xuXG4gIHNjYWxlLnF1YW50aWxlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aHJlc2hvbGRzLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBxdWFudGlsZSgpXG4gICAgICAgIC5kb21haW4oZG9tYWluKVxuICAgICAgICAucmFuZ2UocmFuZ2UpXG4gICAgICAgIC51bmtub3duKHVua25vd24pO1xuICB9O1xuXG4gIHJldHVybiBpbml0UmFuZ2UuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG4iLCJpbXBvcnQge2Jpc2VjdH0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge3NsaWNlfSBmcm9tIFwiLi9hcnJheVwiO1xuaW1wb3J0IHtsaW5lYXJpc2h9IGZyb20gXCIuL2xpbmVhclwiO1xuaW1wb3J0IHtpbml0UmFuZ2V9IGZyb20gXCIuL2luaXRcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcXVhbnRpemUoKSB7XG4gIHZhciB4MCA9IDAsXG4gICAgICB4MSA9IDEsXG4gICAgICBuID0gMSxcbiAgICAgIGRvbWFpbiA9IFswLjVdLFxuICAgICAgcmFuZ2UgPSBbMCwgMV0sXG4gICAgICB1bmtub3duO1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICByZXR1cm4geCA8PSB4ID8gcmFuZ2VbYmlzZWN0KGRvbWFpbiwgeCwgMCwgbildIDogdW5rbm93bjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgdmFyIGkgPSAtMTtcbiAgICBkb21haW4gPSBuZXcgQXJyYXkobik7XG4gICAgd2hpbGUgKCsraSA8IG4pIGRvbWFpbltpXSA9ICgoaSArIDEpICogeDEgLSAoaSAtIG4pICogeDApIC8gKG4gKyAxKTtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH1cblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeDAgPSArX1swXSwgeDEgPSArX1sxXSwgcmVzY2FsZSgpKSA6IFt4MCwgeDFdO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG4gPSAocmFuZ2UgPSBzbGljZS5jYWxsKF8pKS5sZW5ndGggLSAxLCByZXNjYWxlKCkpIDogcmFuZ2Uuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS5pbnZlcnRFeHRlbnQgPSBmdW5jdGlvbih5KSB7XG4gICAgdmFyIGkgPSByYW5nZS5pbmRleE9mKHkpO1xuICAgIHJldHVybiBpIDwgMCA/IFtOYU4sIE5hTl1cbiAgICAgICAgOiBpIDwgMSA/IFt4MCwgZG9tYWluWzBdXVxuICAgICAgICA6IGkgPj0gbiA/IFtkb21haW5bbiAtIDFdLCB4MV1cbiAgICAgICAgOiBbZG9tYWluW2kgLSAxXSwgZG9tYWluW2ldXTtcbiAgfTtcblxuICBzY2FsZS51bmtub3duID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHVua25vd24gPSBfLCBzY2FsZSkgOiBzY2FsZTtcbiAgfTtcblxuICBzY2FsZS50aHJlc2hvbGRzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRvbWFpbi5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcXVhbnRpemUoKVxuICAgICAgICAuZG9tYWluKFt4MCwgeDFdKVxuICAgICAgICAucmFuZ2UocmFuZ2UpXG4gICAgICAgIC51bmtub3duKHVua25vd24pO1xuICB9O1xuXG4gIHJldHVybiBpbml0UmFuZ2UuYXBwbHkobGluZWFyaXNoKHNjYWxlKSwgYXJndW1lbnRzKTtcbn1cbiIsImltcG9ydCB7YmlzZWN0fSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7c2xpY2V9IGZyb20gXCIuL2FycmF5XCI7XG5pbXBvcnQge2luaXRSYW5nZX0gZnJvbSBcIi4vaW5pdFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0aHJlc2hvbGQoKSB7XG4gIHZhciBkb21haW4gPSBbMC41XSxcbiAgICAgIHJhbmdlID0gWzAsIDFdLFxuICAgICAgdW5rbm93bixcbiAgICAgIG4gPSAxO1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICByZXR1cm4geCA8PSB4ID8gcmFuZ2VbYmlzZWN0KGRvbWFpbiwgeCwgMCwgbildIDogdW5rbm93bjtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4gPSBzbGljZS5jYWxsKF8pLCBuID0gTWF0aC5taW4oZG9tYWluLmxlbmd0aCwgcmFuZ2UubGVuZ3RoIC0gMSksIHNjYWxlKSA6IGRvbWFpbi5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmdlID0gc2xpY2UuY2FsbChfKSwgbiA9IE1hdGgubWluKGRvbWFpbi5sZW5ndGgsIHJhbmdlLmxlbmd0aCAtIDEpLCBzY2FsZSkgOiByYW5nZS5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLmludmVydEV4dGVudCA9IGZ1bmN0aW9uKHkpIHtcbiAgICB2YXIgaSA9IHJhbmdlLmluZGV4T2YoeSk7XG4gICAgcmV0dXJuIFtkb21haW5baSAtIDFdLCBkb21haW5baV1dO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aHJlc2hvbGQoKVxuICAgICAgICAuZG9tYWluKGRvbWFpbilcbiAgICAgICAgLnJhbmdlKHJhbmdlKVxuICAgICAgICAudW5rbm93bih1bmtub3duKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdFJhbmdlLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuIiwiaW1wb3J0IHtiaXNlY3RvciwgdGlja1N0ZXB9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHt0aW1lWWVhciwgdGltZU1vbnRoLCB0aW1lV2VlaywgdGltZURheSwgdGltZUhvdXIsIHRpbWVNaW51dGUsIHRpbWVTZWNvbmQsIHRpbWVNaWxsaXNlY29uZH0gZnJvbSBcImQzLXRpbWVcIjtcbmltcG9ydCB7dGltZUZvcm1hdH0gZnJvbSBcImQzLXRpbWUtZm9ybWF0XCI7XG5pbXBvcnQge21hcH0gZnJvbSBcIi4vYXJyYXlcIjtcbmltcG9ydCBjb250aW51b3VzLCB7Y29weSwgaWRlbnRpdHl9IGZyb20gXCIuL2NvbnRpbnVvdXNcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0XCI7XG5pbXBvcnQgbmljZSBmcm9tIFwiLi9uaWNlXCI7XG5cbnZhciBkdXJhdGlvblNlY29uZCA9IDEwMDAsXG4gICAgZHVyYXRpb25NaW51dGUgPSBkdXJhdGlvblNlY29uZCAqIDYwLFxuICAgIGR1cmF0aW9uSG91ciA9IGR1cmF0aW9uTWludXRlICogNjAsXG4gICAgZHVyYXRpb25EYXkgPSBkdXJhdGlvbkhvdXIgKiAyNCxcbiAgICBkdXJhdGlvbldlZWsgPSBkdXJhdGlvbkRheSAqIDcsXG4gICAgZHVyYXRpb25Nb250aCA9IGR1cmF0aW9uRGF5ICogMzAsXG4gICAgZHVyYXRpb25ZZWFyID0gZHVyYXRpb25EYXkgKiAzNjU7XG5cbmZ1bmN0aW9uIGRhdGUodCkge1xuICByZXR1cm4gbmV3IERhdGUodCk7XG59XG5cbmZ1bmN0aW9uIG51bWJlcih0KSB7XG4gIHJldHVybiB0IGluc3RhbmNlb2YgRGF0ZSA/ICt0IDogK25ldyBEYXRlKCt0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGVuZGFyKHllYXIsIG1vbnRoLCB3ZWVrLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgZm9ybWF0KSB7XG4gIHZhciBzY2FsZSA9IGNvbnRpbnVvdXMoaWRlbnRpdHksIGlkZW50aXR5KSxcbiAgICAgIGludmVydCA9IHNjYWxlLmludmVydCxcbiAgICAgIGRvbWFpbiA9IHNjYWxlLmRvbWFpbjtcblxuICB2YXIgZm9ybWF0TWlsbGlzZWNvbmQgPSBmb3JtYXQoXCIuJUxcIiksXG4gICAgICBmb3JtYXRTZWNvbmQgPSBmb3JtYXQoXCI6JVNcIiksXG4gICAgICBmb3JtYXRNaW51dGUgPSBmb3JtYXQoXCIlSTolTVwiKSxcbiAgICAgIGZvcm1hdEhvdXIgPSBmb3JtYXQoXCIlSSAlcFwiKSxcbiAgICAgIGZvcm1hdERheSA9IGZvcm1hdChcIiVhICVkXCIpLFxuICAgICAgZm9ybWF0V2VlayA9IGZvcm1hdChcIiViICVkXCIpLFxuICAgICAgZm9ybWF0TW9udGggPSBmb3JtYXQoXCIlQlwiKSxcbiAgICAgIGZvcm1hdFllYXIgPSBmb3JtYXQoXCIlWVwiKTtcblxuICB2YXIgdGlja0ludGVydmFscyA9IFtcbiAgICBbc2Vjb25kLCAgMSwgICAgICBkdXJhdGlvblNlY29uZF0sXG4gICAgW3NlY29uZCwgIDUsICA1ICogZHVyYXRpb25TZWNvbmRdLFxuICAgIFtzZWNvbmQsIDE1LCAxNSAqIGR1cmF0aW9uU2Vjb25kXSxcbiAgICBbc2Vjb25kLCAzMCwgMzAgKiBkdXJhdGlvblNlY29uZF0sXG4gICAgW21pbnV0ZSwgIDEsICAgICAgZHVyYXRpb25NaW51dGVdLFxuICAgIFttaW51dGUsICA1LCAgNSAqIGR1cmF0aW9uTWludXRlXSxcbiAgICBbbWludXRlLCAxNSwgMTUgKiBkdXJhdGlvbk1pbnV0ZV0sXG4gICAgW21pbnV0ZSwgMzAsIDMwICogZHVyYXRpb25NaW51dGVdLFxuICAgIFsgIGhvdXIsICAxLCAgICAgIGR1cmF0aW9uSG91ciAgXSxcbiAgICBbICBob3VyLCAgMywgIDMgKiBkdXJhdGlvbkhvdXIgIF0sXG4gICAgWyAgaG91ciwgIDYsICA2ICogZHVyYXRpb25Ib3VyICBdLFxuICAgIFsgIGhvdXIsIDEyLCAxMiAqIGR1cmF0aW9uSG91ciAgXSxcbiAgICBbICAgZGF5LCAgMSwgICAgICBkdXJhdGlvbkRheSAgIF0sXG4gICAgWyAgIGRheSwgIDIsICAyICogZHVyYXRpb25EYXkgICBdLFxuICAgIFsgIHdlZWssICAxLCAgICAgIGR1cmF0aW9uV2VlayAgXSxcbiAgICBbIG1vbnRoLCAgMSwgICAgICBkdXJhdGlvbk1vbnRoIF0sXG4gICAgWyBtb250aCwgIDMsICAzICogZHVyYXRpb25Nb250aCBdLFxuICAgIFsgIHllYXIsICAxLCAgICAgIGR1cmF0aW9uWWVhciAgXVxuICBdO1xuXG4gIGZ1bmN0aW9uIHRpY2tGb3JtYXQoZGF0ZSkge1xuICAgIHJldHVybiAoc2Vjb25kKGRhdGUpIDwgZGF0ZSA/IGZvcm1hdE1pbGxpc2Vjb25kXG4gICAgICAgIDogbWludXRlKGRhdGUpIDwgZGF0ZSA/IGZvcm1hdFNlY29uZFxuICAgICAgICA6IGhvdXIoZGF0ZSkgPCBkYXRlID8gZm9ybWF0TWludXRlXG4gICAgICAgIDogZGF5KGRhdGUpIDwgZGF0ZSA/IGZvcm1hdEhvdXJcbiAgICAgICAgOiBtb250aChkYXRlKSA8IGRhdGUgPyAod2VlayhkYXRlKSA8IGRhdGUgPyBmb3JtYXREYXkgOiBmb3JtYXRXZWVrKVxuICAgICAgICA6IHllYXIoZGF0ZSkgPCBkYXRlID8gZm9ybWF0TW9udGhcbiAgICAgICAgOiBmb3JtYXRZZWFyKShkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRpY2tJbnRlcnZhbChpbnRlcnZhbCwgc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICBpZiAoaW50ZXJ2YWwgPT0gbnVsbCkgaW50ZXJ2YWwgPSAxMDtcblxuICAgIC8vIElmIGEgZGVzaXJlZCB0aWNrIGNvdW50IGlzIHNwZWNpZmllZCwgcGljayBhIHJlYXNvbmFibGUgdGljayBpbnRlcnZhbFxuICAgIC8vIGJhc2VkIG9uIHRoZSBleHRlbnQgb2YgdGhlIGRvbWFpbiBhbmQgYSByb3VnaCBlc3RpbWF0ZSBvZiB0aWNrIHNpemUuXG4gICAgLy8gT3RoZXJ3aXNlLCBhc3N1bWUgaW50ZXJ2YWwgaXMgYWxyZWFkeSBhIHRpbWUgaW50ZXJ2YWwgYW5kIHVzZSBpdC5cbiAgICBpZiAodHlwZW9mIGludGVydmFsID09PSBcIm51bWJlclwiKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gTWF0aC5hYnMoc3RvcCAtIHN0YXJ0KSAvIGludGVydmFsLFxuICAgICAgICAgIGkgPSBiaXNlY3RvcihmdW5jdGlvbihpKSB7IHJldHVybiBpWzJdOyB9KS5yaWdodCh0aWNrSW50ZXJ2YWxzLCB0YXJnZXQpO1xuICAgICAgaWYgKGkgPT09IHRpY2tJbnRlcnZhbHMubGVuZ3RoKSB7XG4gICAgICAgIHN0ZXAgPSB0aWNrU3RlcChzdGFydCAvIGR1cmF0aW9uWWVhciwgc3RvcCAvIGR1cmF0aW9uWWVhciwgaW50ZXJ2YWwpO1xuICAgICAgICBpbnRlcnZhbCA9IHllYXI7XG4gICAgICB9IGVsc2UgaWYgKGkpIHtcbiAgICAgICAgaSA9IHRpY2tJbnRlcnZhbHNbdGFyZ2V0IC8gdGlja0ludGVydmFsc1tpIC0gMV1bMl0gPCB0aWNrSW50ZXJ2YWxzW2ldWzJdIC8gdGFyZ2V0ID8gaSAtIDEgOiBpXTtcbiAgICAgICAgc3RlcCA9IGlbMV07XG4gICAgICAgIGludGVydmFsID0gaVswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ZXAgPSBNYXRoLm1heCh0aWNrU3RlcChzdGFydCwgc3RvcCwgaW50ZXJ2YWwpLCAxKTtcbiAgICAgICAgaW50ZXJ2YWwgPSBtaWxsaXNlY29uZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3RlcCA9PSBudWxsID8gaW50ZXJ2YWwgOiBpbnRlcnZhbC5ldmVyeShzdGVwKTtcbiAgfVxuXG4gIHNjYWxlLmludmVydCA9IGZ1bmN0aW9uKHkpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoaW52ZXJ0KHkpKTtcbiAgfTtcblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBkb21haW4obWFwLmNhbGwoXywgbnVtYmVyKSkgOiBkb21haW4oKS5tYXAoZGF0ZSk7XG4gIH07XG5cbiAgc2NhbGUudGlja3MgPSBmdW5jdGlvbihpbnRlcnZhbCwgc3RlcCkge1xuICAgIHZhciBkID0gZG9tYWluKCksXG4gICAgICAgIHQwID0gZFswXSxcbiAgICAgICAgdDEgPSBkW2QubGVuZ3RoIC0gMV0sXG4gICAgICAgIHIgPSB0MSA8IHQwLFxuICAgICAgICB0O1xuICAgIGlmIChyKSB0ID0gdDAsIHQwID0gdDEsIHQxID0gdDtcbiAgICB0ID0gdGlja0ludGVydmFsKGludGVydmFsLCB0MCwgdDEsIHN0ZXApO1xuICAgIHQgPSB0ID8gdC5yYW5nZSh0MCwgdDEgKyAxKSA6IFtdOyAvLyBpbmNsdXNpdmUgc3RvcFxuICAgIHJldHVybiByID8gdC5yZXZlcnNlKCkgOiB0O1xuICB9O1xuXG4gIHNjYWxlLnRpY2tGb3JtYXQgPSBmdW5jdGlvbihjb3VudCwgc3BlY2lmaWVyKSB7XG4gICAgcmV0dXJuIHNwZWNpZmllciA9PSBudWxsID8gdGlja0Zvcm1hdCA6IGZvcm1hdChzcGVjaWZpZXIpO1xuICB9O1xuXG4gIHNjYWxlLm5pY2UgPSBmdW5jdGlvbihpbnRlcnZhbCwgc3RlcCkge1xuICAgIHZhciBkID0gZG9tYWluKCk7XG4gICAgcmV0dXJuIChpbnRlcnZhbCA9IHRpY2tJbnRlcnZhbChpbnRlcnZhbCwgZFswXSwgZFtkLmxlbmd0aCAtIDFdLCBzdGVwKSlcbiAgICAgICAgPyBkb21haW4obmljZShkLCBpbnRlcnZhbCkpXG4gICAgICAgIDogc2NhbGU7XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBjYWxlbmRhcih5ZWFyLCBtb250aCwgd2VlaywgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIGZvcm1hdCkpO1xuICB9O1xuXG4gIHJldHVybiBzY2FsZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBpbml0UmFuZ2UuYXBwbHkoY2FsZW5kYXIodGltZVllYXIsIHRpbWVNb250aCwgdGltZVdlZWssIHRpbWVEYXksIHRpbWVIb3VyLCB0aW1lTWludXRlLCB0aW1lU2Vjb25kLCB0aW1lTWlsbGlzZWNvbmQsIHRpbWVGb3JtYXQpLmRvbWFpbihbbmV3IERhdGUoMjAwMCwgMCwgMSksIG5ldyBEYXRlKDIwMDAsIDAsIDIpXSksIGFyZ3VtZW50cyk7XG59XG4iLCJpbXBvcnQge2NhbGVuZGFyfSBmcm9tIFwiLi90aW1lXCI7XG5pbXBvcnQge3V0Y0Zvcm1hdH0gZnJvbSBcImQzLXRpbWUtZm9ybWF0XCI7XG5pbXBvcnQge3V0Y1llYXIsIHV0Y01vbnRoLCB1dGNXZWVrLCB1dGNEYXksIHV0Y0hvdXIsIHV0Y01pbnV0ZSwgdXRjU2Vjb25kLCB1dGNNaWxsaXNlY29uZH0gZnJvbSBcImQzLXRpbWVcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gaW5pdFJhbmdlLmFwcGx5KGNhbGVuZGFyKHV0Y1llYXIsIHV0Y01vbnRoLCB1dGNXZWVrLCB1dGNEYXksIHV0Y0hvdXIsIHV0Y01pbnV0ZSwgdXRjU2Vjb25kLCB1dGNNaWxsaXNlY29uZCwgdXRjRm9ybWF0KS5kb21haW4oW0RhdGUuVVRDKDIwMDAsIDAsIDEpLCBEYXRlLlVUQygyMDAwLCAwLCAyKV0pLCBhcmd1bWVudHMpO1xufVxuIiwiaW1wb3J0IHtpZGVudGl0eX0gZnJvbSBcIi4vY29udGludW91c1wiO1xuaW1wb3J0IHtpbml0SW50ZXJwb2xhdG9yfSBmcm9tIFwiLi9pbml0XCI7XG5pbXBvcnQge2xpbmVhcmlzaH0gZnJvbSBcIi4vbGluZWFyXCI7XG5pbXBvcnQge2xvZ2dpc2h9IGZyb20gXCIuL2xvZ1wiO1xuaW1wb3J0IHtzeW1sb2dpc2h9IGZyb20gXCIuL3N5bWxvZ1wiO1xuaW1wb3J0IHtwb3dpc2h9IGZyb20gXCIuL3Bvd1wiO1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1lcigpIHtcbiAgdmFyIHgwID0gMCxcbiAgICAgIHgxID0gMSxcbiAgICAgIHQwLFxuICAgICAgdDEsXG4gICAgICBrMTAsXG4gICAgICB0cmFuc2Zvcm0sXG4gICAgICBpbnRlcnBvbGF0b3IgPSBpZGVudGl0eSxcbiAgICAgIGNsYW1wID0gZmFsc2UsXG4gICAgICB1bmtub3duO1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICByZXR1cm4gaXNOYU4oeCA9ICt4KSA/IHVua25vd24gOiBpbnRlcnBvbGF0b3IoazEwID09PSAwID8gMC41IDogKHggPSAodHJhbnNmb3JtKHgpIC0gdDApICogazEwLCBjbGFtcCA/IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHgpKSA6IHgpKTtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0MCA9IHRyYW5zZm9ybSh4MCA9ICtfWzBdKSwgdDEgPSB0cmFuc2Zvcm0oeDEgPSArX1sxXSksIGsxMCA9IHQwID09PSB0MSA/IDAgOiAxIC8gKHQxIC0gdDApLCBzY2FsZSkgOiBbeDAsIHgxXTtcbiAgfTtcblxuICBzY2FsZS5jbGFtcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjbGFtcCA9ICEhXywgc2NhbGUpIDogY2xhbXA7XG4gIH07XG5cbiAgc2NhbGUuaW50ZXJwb2xhdG9yID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGludGVycG9sYXRvciA9IF8sIHNjYWxlKSA6IGludGVycG9sYXRvcjtcbiAgfTtcblxuICBzY2FsZS51bmtub3duID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHVua25vd24gPSBfLCBzY2FsZSkgOiB1bmtub3duO1xuICB9O1xuXG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdHJhbnNmb3JtID0gdCwgdDAgPSB0KHgwKSwgdDEgPSB0KHgxKSwgazEwID0gdDAgPT09IHQxID8gMCA6IDEgLyAodDEgLSB0MCk7XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29weShzb3VyY2UsIHRhcmdldCkge1xuICByZXR1cm4gdGFyZ2V0XG4gICAgICAuZG9tYWluKHNvdXJjZS5kb21haW4oKSlcbiAgICAgIC5pbnRlcnBvbGF0b3Ioc291cmNlLmludGVycG9sYXRvcigpKVxuICAgICAgLmNsYW1wKHNvdXJjZS5jbGFtcCgpKVxuICAgICAgLnVua25vd24oc291cmNlLnVua25vd24oKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNlcXVlbnRpYWwoKSB7XG4gIHZhciBzY2FsZSA9IGxpbmVhcmlzaCh0cmFuc2Zvcm1lcigpKGlkZW50aXR5KSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBzZXF1ZW50aWFsKCkpO1xuICB9O1xuXG4gIHJldHVybiBpbml0SW50ZXJwb2xhdG9yLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VxdWVudGlhbExvZygpIHtcbiAgdmFyIHNjYWxlID0gbG9nZ2lzaCh0cmFuc2Zvcm1lcigpKS5kb21haW4oWzEsIDEwXSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBzZXF1ZW50aWFsTG9nKCkpLmJhc2Uoc2NhbGUuYmFzZSgpKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdEludGVycG9sYXRvci5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlcXVlbnRpYWxTeW1sb2coKSB7XG4gIHZhciBzY2FsZSA9IHN5bWxvZ2lzaCh0cmFuc2Zvcm1lcigpKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIHNlcXVlbnRpYWxTeW1sb2coKSkuY29uc3RhbnQoc2NhbGUuY29uc3RhbnQoKSk7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRJbnRlcnBvbGF0b3IuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXF1ZW50aWFsUG93KCkge1xuICB2YXIgc2NhbGUgPSBwb3dpc2godHJhbnNmb3JtZXIoKSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBzZXF1ZW50aWFsUG93KCkpLmV4cG9uZW50KHNjYWxlLmV4cG9uZW50KCkpO1xuICB9O1xuXG4gIHJldHVybiBpbml0SW50ZXJwb2xhdG9yLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VxdWVudGlhbFNxcnQoKSB7XG4gIHJldHVybiBzZXF1ZW50aWFsUG93LmFwcGx5KG51bGwsIGFyZ3VtZW50cykuZXhwb25lbnQoMC41KTtcbn1cbiIsImltcG9ydCB7YXNjZW5kaW5nLCBiaXNlY3R9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHtpZGVudGl0eX0gZnJvbSBcIi4vY29udGludW91c1wiO1xuaW1wb3J0IHtpbml0SW50ZXJwb2xhdG9yfSBmcm9tIFwiLi9pbml0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNlcXVlbnRpYWxRdWFudGlsZSgpIHtcbiAgdmFyIGRvbWFpbiA9IFtdLFxuICAgICAgaW50ZXJwb2xhdG9yID0gaWRlbnRpdHk7XG5cbiAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgIGlmICghaXNOYU4oeCA9ICt4KSkgcmV0dXJuIGludGVycG9sYXRvcigoYmlzZWN0KGRvbWFpbiwgeCkgLSAxKSAvIChkb21haW4ubGVuZ3RoIC0gMSkpO1xuICB9XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbi5zbGljZSgpO1xuICAgIGRvbWFpbiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gXy5sZW5ndGgsIGQ7IGkgPCBuOyArK2kpIGlmIChkID0gX1tpXSwgZCAhPSBudWxsICYmICFpc05hTihkID0gK2QpKSBkb21haW4ucHVzaChkKTtcbiAgICBkb21haW4uc29ydChhc2NlbmRpbmcpO1xuICAgIHJldHVybiBzY2FsZTtcbiAgfTtcblxuICBzY2FsZS5pbnRlcnBvbGF0b3IgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaW50ZXJwb2xhdG9yID0gXywgc2NhbGUpIDogaW50ZXJwb2xhdG9yO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2VxdWVudGlhbFF1YW50aWxlKGludGVycG9sYXRvcikuZG9tYWluKGRvbWFpbik7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRJbnRlcnBvbGF0b3IuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG4iLCJpbXBvcnQge2lkZW50aXR5fSBmcm9tIFwiLi9jb250aW51b3VzXCI7XG5pbXBvcnQge2luaXRJbnRlcnBvbGF0b3J9IGZyb20gXCIuL2luaXRcIjtcbmltcG9ydCB7bGluZWFyaXNofSBmcm9tIFwiLi9saW5lYXJcIjtcbmltcG9ydCB7bG9nZ2lzaH0gZnJvbSBcIi4vbG9nXCI7XG5pbXBvcnQge2NvcHl9IGZyb20gXCIuL3NlcXVlbnRpYWxcIjtcbmltcG9ydCB7c3ltbG9naXNofSBmcm9tIFwiLi9zeW1sb2dcIjtcbmltcG9ydCB7cG93aXNofSBmcm9tIFwiLi9wb3dcIjtcblxuZnVuY3Rpb24gdHJhbnNmb3JtZXIoKSB7XG4gIHZhciB4MCA9IDAsXG4gICAgICB4MSA9IDAuNSxcbiAgICAgIHgyID0gMSxcbiAgICAgIHQwLFxuICAgICAgdDEsXG4gICAgICB0MixcbiAgICAgIGsxMCxcbiAgICAgIGsyMSxcbiAgICAgIGludGVycG9sYXRvciA9IGlkZW50aXR5LFxuICAgICAgdHJhbnNmb3JtLFxuICAgICAgY2xhbXAgPSBmYWxzZSxcbiAgICAgIHVua25vd247XG5cbiAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgIHJldHVybiBpc05hTih4ID0gK3gpID8gdW5rbm93biA6ICh4ID0gMC41ICsgKCh4ID0gK3RyYW5zZm9ybSh4KSkgLSB0MSkgKiAoeCA8IHQxID8gazEwIDogazIxKSwgaW50ZXJwb2xhdG9yKGNsYW1wID8gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgeCkpIDogeCkpO1xuICB9XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHQwID0gdHJhbnNmb3JtKHgwID0gK19bMF0pLCB0MSA9IHRyYW5zZm9ybSh4MSA9ICtfWzFdKSwgdDIgPSB0cmFuc2Zvcm0oeDIgPSArX1syXSksIGsxMCA9IHQwID09PSB0MSA/IDAgOiAwLjUgLyAodDEgLSB0MCksIGsyMSA9IHQxID09PSB0MiA/IDAgOiAwLjUgLyAodDIgLSB0MSksIHNjYWxlKSA6IFt4MCwgeDEsIHgyXTtcbiAgfTtcblxuICBzY2FsZS5jbGFtcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjbGFtcCA9ICEhXywgc2NhbGUpIDogY2xhbXA7XG4gIH07XG5cbiAgc2NhbGUuaW50ZXJwb2xhdG9yID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGludGVycG9sYXRvciA9IF8sIHNjYWxlKSA6IGludGVycG9sYXRvcjtcbiAgfTtcblxuICBzY2FsZS51bmtub3duID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHVua25vd24gPSBfLCBzY2FsZSkgOiB1bmtub3duO1xuICB9O1xuXG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdHJhbnNmb3JtID0gdCwgdDAgPSB0KHgwKSwgdDEgPSB0KHgxKSwgdDIgPSB0KHgyKSwgazEwID0gdDAgPT09IHQxID8gMCA6IDAuNSAvICh0MSAtIHQwKSwgazIxID0gdDEgPT09IHQyID8gMCA6IDAuNSAvICh0MiAtIHQxKTtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRpdmVyZ2luZygpIHtcbiAgdmFyIHNjYWxlID0gbGluZWFyaXNoKHRyYW5zZm9ybWVyKCkoaWRlbnRpdHkpKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIGRpdmVyZ2luZygpKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdEludGVycG9sYXRvci5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpdmVyZ2luZ0xvZygpIHtcbiAgdmFyIHNjYWxlID0gbG9nZ2lzaCh0cmFuc2Zvcm1lcigpKS5kb21haW4oWzAuMSwgMSwgMTBdKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIGRpdmVyZ2luZ0xvZygpKS5iYXNlKHNjYWxlLmJhc2UoKSk7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRJbnRlcnBvbGF0b3IuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXZlcmdpbmdTeW1sb2coKSB7XG4gIHZhciBzY2FsZSA9IHN5bWxvZ2lzaCh0cmFuc2Zvcm1lcigpKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIGRpdmVyZ2luZ1N5bWxvZygpKS5jb25zdGFudChzY2FsZS5jb25zdGFudCgpKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdEludGVycG9sYXRvci5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpdmVyZ2luZ1BvdygpIHtcbiAgdmFyIHNjYWxlID0gcG93aXNoKHRyYW5zZm9ybWVyKCkpO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgZGl2ZXJnaW5nUG93KCkpLmV4cG9uZW50KHNjYWxlLmV4cG9uZW50KCkpO1xuICB9O1xuXG4gIHJldHVybiBpbml0SW50ZXJwb2xhdG9yLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGl2ZXJnaW5nU3FydCgpIHtcbiAgcmV0dXJuIGRpdmVyZ2luZ1Bvdy5hcHBseShudWxsLCBhcmd1bWVudHMpLmV4cG9uZW50KDAuNSk7XG59XG4iLCJleHBvcnQge1xuICBkZWZhdWx0IGFzIHNjYWxlQmFuZCxcbiAgcG9pbnQgYXMgc2NhbGVQb2ludFxufSBmcm9tIFwiLi9iYW5kXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgc2NhbGVJZGVudGl0eVxufSBmcm9tIFwiLi9pZGVudGl0eVwiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIHNjYWxlTGluZWFyXG59IGZyb20gXCIuL2xpbmVhclwiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIHNjYWxlTG9nXG59IGZyb20gXCIuL2xvZ1wiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIHNjYWxlU3ltbG9nXG59IGZyb20gXCIuL3N5bWxvZ1wiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIHNjYWxlT3JkaW5hbCxcbiAgaW1wbGljaXQgYXMgc2NhbGVJbXBsaWNpdFxufSBmcm9tIFwiLi9vcmRpbmFsXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgc2NhbGVQb3csXG4gIHNxcnQgYXMgc2NhbGVTcXJ0XG59IGZyb20gXCIuL3Bvd1wiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIHNjYWxlUXVhbnRpbGVcbn0gZnJvbSBcIi4vcXVhbnRpbGVcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyBzY2FsZVF1YW50aXplXG59IGZyb20gXCIuL3F1YW50aXplXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgc2NhbGVUaHJlc2hvbGRcbn0gZnJvbSBcIi4vdGhyZXNob2xkXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgc2NhbGVUaW1lXG59IGZyb20gXCIuL3RpbWVcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyBzY2FsZVV0Y1xufSBmcm9tIFwiLi91dGNUaW1lXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgc2NhbGVTZXF1ZW50aWFsLFxuICBzZXF1ZW50aWFsTG9nIGFzIHNjYWxlU2VxdWVudGlhbExvZyxcbiAgc2VxdWVudGlhbFBvdyBhcyBzY2FsZVNlcXVlbnRpYWxQb3csXG4gIHNlcXVlbnRpYWxTcXJ0IGFzIHNjYWxlU2VxdWVudGlhbFNxcnQsXG4gIHNlcXVlbnRpYWxTeW1sb2cgYXMgc2NhbGVTZXF1ZW50aWFsU3ltbG9nXG59IGZyb20gXCIuL3NlcXVlbnRpYWxcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyBzY2FsZVNlcXVlbnRpYWxRdWFudGlsZVxufSBmcm9tIFwiLi9zZXF1ZW50aWFsUXVhbnRpbGVcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyBzY2FsZURpdmVyZ2luZyxcbiAgZGl2ZXJnaW5nTG9nIGFzIHNjYWxlRGl2ZXJnaW5nTG9nLFxuICBkaXZlcmdpbmdQb3cgYXMgc2NhbGVEaXZlcmdpbmdQb3csXG4gIGRpdmVyZ2luZ1NxcnQgYXMgc2NhbGVEaXZlcmdpbmdTcXJ0LFxuICBkaXZlcmdpbmdTeW1sb2cgYXMgc2NhbGVEaXZlcmdpbmdTeW1sb2dcbn0gZnJvbSBcIi4vZGl2ZXJnaW5nXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgdGlja0Zvcm1hdFxufSBmcm9tIFwiLi90aWNrRm9ybWF0XCI7XG4iLCJpbXBvcnQgeyBzY2FsZUJhbmQsIHNjYWxlUG9pbnQsIHNjYWxlTGluZWFyLCBzY2FsZVRpbWUsIHNjYWxlVXRjLCBzY2FsZUxvZywgc2NhbGVQb3csIHNjYWxlT3JkaW5hbCwgc2NhbGVRdWFudGl6ZSwgc2NhbGVRdWFudGlsZSwgc2NhbGVUaHJlc2hvbGQgfSBmcm9tICdkMy1zY2FsZSc7XG5cbnZhciBiYW5kID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciByYW5nZSA9IF9yZWYucmFuZ2UsXG4gICAgICByYW5nZVJvdW5kID0gX3JlZi5yYW5nZVJvdW5kLFxuICAgICAgZG9tYWluID0gX3JlZi5kb21haW4sXG4gICAgICBwYWRkaW5nID0gX3JlZi5wYWRkaW5nLFxuICAgICAgcGFkZGluZ0lubmVyID0gX3JlZi5wYWRkaW5nSW5uZXIsXG4gICAgICBwYWRkaW5nT3V0ZXIgPSBfcmVmLnBhZGRpbmdPdXRlcixcbiAgICAgIGFsaWduID0gX3JlZi5hbGlnbixcbiAgICAgIHRpY2tGb3JtYXQgPSBfcmVmLnRpY2tGb3JtYXQ7XG5cbiAgdmFyIHNjYWxlID0gc2NhbGVCYW5kKCk7XG5cbiAgaWYgKHJhbmdlKSBzY2FsZS5yYW5nZShyYW5nZSk7XG4gIGlmIChyYW5nZVJvdW5kKSBzY2FsZS5yYW5nZVJvdW5kKHJhbmdlUm91bmQpO1xuICBpZiAoZG9tYWluKSBzY2FsZS5kb21haW4oZG9tYWluKTtcbiAgaWYgKHBhZGRpbmcpIHNjYWxlLnBhZGRpbmcocGFkZGluZyk7XG4gIGlmIChwYWRkaW5nSW5uZXIpIHNjYWxlLnBhZGRpbmdJbm5lcihwYWRkaW5nSW5uZXIpO1xuICBpZiAocGFkZGluZ091dGVyKSBzY2FsZS5wYWRkaW5nT3V0ZXIocGFkZGluZ091dGVyKTtcbiAgaWYgKGFsaWduKSBzY2FsZS5hbGlnbihhbGlnbik7XG4gIGlmICh0aWNrRm9ybWF0KSBzY2FsZS50aWNrRm9ybWF0ID0gdGlja0Zvcm1hdDtcblxuICByZXR1cm4gc2NhbGU7XG59KTtcblxudmFyIHBvaW50ID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciByYW5nZSA9IF9yZWYucmFuZ2UsXG4gICAgICByYW5nZVJvdW5kID0gX3JlZi5yYW5nZVJvdW5kLFxuICAgICAgZG9tYWluID0gX3JlZi5kb21haW4sXG4gICAgICBwYWRkaW5nID0gX3JlZi5wYWRkaW5nLFxuICAgICAgYWxpZ24gPSBfcmVmLmFsaWduLFxuICAgICAgX3JlZiRuaWNlID0gX3JlZi5uaWNlLFxuICAgICAgbmljZSA9IF9yZWYkbmljZSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJG5pY2U7XG5cbiAgdmFyIHNjYWxlID0gc2NhbGVQb2ludCgpO1xuXG4gIGlmIChyYW5nZSkgc2NhbGUucmFuZ2UocmFuZ2UpO1xuICBpZiAocmFuZ2VSb3VuZCkgc2NhbGUucmFuZ2VSb3VuZChyYW5nZVJvdW5kKTtcbiAgaWYgKGRvbWFpbikgc2NhbGUuZG9tYWluKGRvbWFpbik7XG4gIGlmIChuaWNlKSBzY2FsZS5uaWNlKCk7XG4gIGlmIChwYWRkaW5nKSBzY2FsZS5wYWRkaW5nKHBhZGRpbmcpO1xuICBpZiAoYWxpZ24pIHNjYWxlLmFsaWduKGFsaWduKTtcblxuICByZXR1cm4gc2NhbGU7XG59KTtcblxudmFyIGxpbmVhciA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgcmFuZ2UgPSBfcmVmLnJhbmdlLFxuICAgICAgcmFuZ2VSb3VuZCA9IF9yZWYucmFuZ2VSb3VuZCxcbiAgICAgIGRvbWFpbiA9IF9yZWYuZG9tYWluLFxuICAgICAgX3JlZiRuaWNlID0gX3JlZi5uaWNlLFxuICAgICAgbmljZSA9IF9yZWYkbmljZSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJG5pY2UsXG4gICAgICBfcmVmJGNsYW1wID0gX3JlZi5jbGFtcCxcbiAgICAgIGNsYW1wID0gX3JlZiRjbGFtcCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJGNsYW1wO1xuXG4gIHZhciBzY2FsZSA9IHNjYWxlTGluZWFyKCk7XG5cbiAgaWYgKHJhbmdlKSBzY2FsZS5yYW5nZShyYW5nZSk7XG4gIGlmIChyYW5nZVJvdW5kKSBzY2FsZS5yYW5nZVJvdW5kKHJhbmdlUm91bmQpO1xuICBpZiAoZG9tYWluKSBzY2FsZS5kb21haW4oZG9tYWluKTtcbiAgaWYgKG5pY2UpIHNjYWxlLm5pY2UoKTtcbiAgaWYgKGNsYW1wKSBzY2FsZS5jbGFtcCh0cnVlKTtcblxuICByZXR1cm4gc2NhbGU7XG59KTtcblxudmFyIHRpbWUgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHJhbmdlID0gX3JlZi5yYW5nZSxcbiAgICAgIHJhbmdlUm91bmQgPSBfcmVmLnJhbmdlUm91bmQsXG4gICAgICBkb21haW4gPSBfcmVmLmRvbWFpbixcbiAgICAgIF9yZWYkbmljZSA9IF9yZWYubmljZSxcbiAgICAgIG5pY2UgPSBfcmVmJG5pY2UgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiRuaWNlLFxuICAgICAgX3JlZiRjbGFtcCA9IF9yZWYuY2xhbXAsXG4gICAgICBjbGFtcCA9IF9yZWYkY2xhbXAgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiRjbGFtcDtcblxuICB2YXIgc2NhbGUgPSBzY2FsZVRpbWUoKTtcblxuICBpZiAocmFuZ2UpIHNjYWxlLnJhbmdlKHJhbmdlKTtcbiAgaWYgKHJhbmdlUm91bmQpIHNjYWxlLnJhbmdlUm91bmQocmFuZ2VSb3VuZCk7XG4gIGlmIChkb21haW4pIHNjYWxlLmRvbWFpbihkb21haW4pO1xuICBpZiAobmljZSkgc2NhbGUubmljZSgpO1xuICBpZiAoY2xhbXApIHNjYWxlLmNsYW1wKHRydWUpO1xuXG4gIHJldHVybiBzY2FsZTtcbn0pO1xuXG52YXIgdXRjID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciByYW5nZSA9IF9yZWYucmFuZ2UsXG4gICAgICByYW5nZVJvdW5kID0gX3JlZi5yYW5nZVJvdW5kLFxuICAgICAgZG9tYWluID0gX3JlZi5kb21haW4sXG4gICAgICBfcmVmJG5pY2UgPSBfcmVmLm5pY2UsXG4gICAgICBuaWNlID0gX3JlZiRuaWNlID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkbmljZSxcbiAgICAgIF9yZWYkY2xhbXAgPSBfcmVmLmNsYW1wLFxuICAgICAgY2xhbXAgPSBfcmVmJGNsYW1wID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkY2xhbXA7XG5cbiAgdmFyIHNjYWxlID0gc2NhbGVVdGMoKTtcblxuICBpZiAocmFuZ2UpIHNjYWxlLnJhbmdlKHJhbmdlKTtcbiAgaWYgKHJhbmdlUm91bmQpIHNjYWxlLnJhbmdlUm91bmQocmFuZ2VSb3VuZCk7XG4gIGlmIChkb21haW4pIHNjYWxlLmRvbWFpbihkb21haW4pO1xuICBpZiAobmljZSkgc2NhbGUubmljZSgpO1xuICBpZiAoY2xhbXApIHNjYWxlLmNsYW1wKHRydWUpO1xuXG4gIHJldHVybiBzY2FsZTtcbn0pO1xuXG52YXIgbG9nID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciByYW5nZSA9IF9yZWYucmFuZ2UsXG4gICAgICByYW5nZVJvdW5kID0gX3JlZi5yYW5nZVJvdW5kLFxuICAgICAgZG9tYWluID0gX3JlZi5kb21haW4sXG4gICAgICBiYXNlID0gX3JlZi5iYXNlLFxuICAgICAgX3JlZiRuaWNlID0gX3JlZi5uaWNlLFxuICAgICAgbmljZSA9IF9yZWYkbmljZSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJG5pY2UsXG4gICAgICBfcmVmJGNsYW1wID0gX3JlZi5jbGFtcCxcbiAgICAgIGNsYW1wID0gX3JlZiRjbGFtcCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJGNsYW1wO1xuXG4gIHZhciBzY2FsZSA9IHNjYWxlTG9nKCk7XG5cbiAgaWYgKHJhbmdlKSBzY2FsZS5yYW5nZShyYW5nZSk7XG4gIGlmIChyYW5nZVJvdW5kKSBzY2FsZS5yYW5nZVJvdW5kKHJhbmdlUm91bmQpO1xuICBpZiAoZG9tYWluKSBzY2FsZS5kb21haW4oZG9tYWluKTtcbiAgaWYgKG5pY2UpIHNjYWxlLm5pY2UoKTtcbiAgaWYgKGNsYW1wKSBzY2FsZS5jbGFtcCh0cnVlKTtcbiAgaWYgKGJhc2UpIHNjYWxlLmJhc2UoYmFzZSk7XG5cbiAgcmV0dXJuIHNjYWxlO1xufSk7XG5cbnZhciBwb3dlciA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgcmFuZ2UgPSBfcmVmLnJhbmdlLFxuICAgICAgcmFuZ2VSb3VuZCA9IF9yZWYucmFuZ2VSb3VuZCxcbiAgICAgIGRvbWFpbiA9IF9yZWYuZG9tYWluLFxuICAgICAgZXhwb25lbnQgPSBfcmVmLmV4cG9uZW50LFxuICAgICAgX3JlZiRuaWNlID0gX3JlZi5uaWNlLFxuICAgICAgbmljZSA9IF9yZWYkbmljZSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJG5pY2UsXG4gICAgICBfcmVmJGNsYW1wID0gX3JlZi5jbGFtcCxcbiAgICAgIGNsYW1wID0gX3JlZiRjbGFtcCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJGNsYW1wO1xuXG4gIHZhciBzY2FsZSA9IHNjYWxlUG93KCk7XG5cbiAgaWYgKHJhbmdlKSBzY2FsZS5yYW5nZShyYW5nZSk7XG4gIGlmIChyYW5nZVJvdW5kKSBzY2FsZS5yYW5nZVJvdW5kKHJhbmdlUm91bmQpO1xuICBpZiAoZG9tYWluKSBzY2FsZS5kb21haW4oZG9tYWluKTtcbiAgaWYgKG5pY2UpIHNjYWxlLm5pY2UoKTtcbiAgaWYgKGNsYW1wKSBzY2FsZS5jbGFtcCh0cnVlKTtcbiAgaWYgKGV4cG9uZW50KSBzY2FsZS5leHBvbmVudChleHBvbmVudCk7XG5cbiAgcmV0dXJuIHNjYWxlO1xufSk7XG5cbnZhciBvcmRpbmFsID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciByYW5nZSA9IF9yZWYucmFuZ2UsXG4gICAgICBkb21haW4gPSBfcmVmLmRvbWFpbixcbiAgICAgIHVua25vd24gPSBfcmVmLnVua25vd247XG5cbiAgdmFyIHNjYWxlID0gc2NhbGVPcmRpbmFsKCk7XG5cbiAgaWYgKHJhbmdlKSBzY2FsZS5yYW5nZShyYW5nZSk7XG4gIGlmIChkb21haW4pIHNjYWxlLmRvbWFpbihkb21haW4pO1xuICBpZiAodW5rbm93bikgc2NhbGUudW5rbm93bih1bmtub3duKTtcblxuICByZXR1cm4gc2NhbGU7XG59KTtcblxudmFyIHF1YW50aXplID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciByYW5nZSA9IF9yZWYucmFuZ2UsXG4gICAgICBkb21haW4gPSBfcmVmLmRvbWFpbixcbiAgICAgIHRpY2tzID0gX3JlZi50aWNrcyxcbiAgICAgIHRpY2tGb3JtYXQgPSBfcmVmLnRpY2tGb3JtYXQsXG4gICAgICBfcmVmJG5pY2UgPSBfcmVmLm5pY2UsXG4gICAgICBuaWNlID0gX3JlZiRuaWNlID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkbmljZTtcblxuICB2YXIgc2NhbGUgPSBzY2FsZVF1YW50aXplKCk7XG5cbiAgaWYgKHJhbmdlKSBzY2FsZS5yYW5nZShyYW5nZSk7XG4gIGlmIChkb21haW4pIHNjYWxlLmRvbWFpbihkb21haW4pO1xuICBpZiAobmljZSkgc2NhbGUubmljZSgpO1xuICBpZiAodGlja3MpIHNjYWxlLnRpY2tzKHRpY2tzKTtcbiAgaWYgKHRpY2tGb3JtYXQpIHNjYWxlLnRpY2tGb3JtYXQodGlja0Zvcm1hdCk7XG5cbiAgcmV0dXJuIHNjYWxlO1xufSk7XG5cbnZhciBxdWFudGlsZSA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgcmFuZ2UgPSBfcmVmLnJhbmdlLFxuICAgICAgZG9tYWluID0gX3JlZi5kb21haW47XG5cbiAgdmFyIHNjYWxlID0gc2NhbGVRdWFudGlsZSgpO1xuXG4gIGlmIChyYW5nZSkgc2NhbGUucmFuZ2UocmFuZ2UpO1xuICBpZiAoZG9tYWluKSBzY2FsZS5kb21haW4oZG9tYWluKTtcblxuICByZXR1cm4gc2NhbGU7XG59KTtcblxudmFyIHRocmVzaG9sZCA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgcmFuZ2UgPSBfcmVmLnJhbmdlLFxuICAgICAgZG9tYWluID0gX3JlZi5kb21haW47XG5cbiAgdmFyIHNjYWxlID0gc2NhbGVUaHJlc2hvbGQoKTtcblxuICBpZiAocmFuZ2UpIHNjYWxlLnJhbmdlKHJhbmdlKTtcbiAgaWYgKGRvbWFpbikgc2NhbGUuZG9tYWluKGRvbWFpbik7XG5cbiAgcmV0dXJuIHNjYWxlO1xufSk7XG5cbnZhciBvYmplY3RXaXRob3V0UHJvcGVydGllcyA9IGZ1bmN0aW9uIChvYmosIGtleXMpIHtcbiAgdmFyIHRhcmdldCA9IHt9O1xuXG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTtcbiAgICB0YXJnZXRbaV0gPSBvYmpbaV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuZnVuY3Rpb24gdXBkYXRlU2NhbGUoc2NhbGUsIF9yZWYpIHtcbiAgdmFyIGFyZ3MgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbXSk7XG5cbiAgdmFyIG5leHRTY2FsZSA9IHNjYWxlLmNvcHkoKTtcbiAgT2JqZWN0LmtleXMoYXJncykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKG5leHRTY2FsZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSBuZXh0U2NhbGVba2V5XShhcmdzW2tleV0pO1xuICB9KTtcbiAgcmV0dXJuIG5leHRTY2FsZTtcbn1cblxuZXhwb3J0IHsgYmFuZCBhcyBzY2FsZUJhbmQsIHBvaW50IGFzIHNjYWxlUG9pbnQsIGxpbmVhciBhcyBzY2FsZUxpbmVhciwgdGltZSBhcyBzY2FsZVRpbWUsIHV0YyBhcyBzY2FsZVV0YywgbG9nIGFzIHNjYWxlTG9nLCBwb3dlciBhcyBzY2FsZVBvd2VyLCBvcmRpbmFsIGFzIHNjYWxlT3JkaW5hbCwgcXVhbnRpemUgYXMgc2NhbGVRdWFudGl6ZSwgcXVhbnRpbGUgYXMgc2NhbGVRdWFudGlsZSwgdGhyZXNob2xkIGFzIHNjYWxlVGhyZXNob2xkLCB1cGRhdGVTY2FsZSB9O1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IHsgR3JvdXAgfSBmcm9tICdAdngvZ3JvdXAnO1xuaW1wb3J0IHsgc2NhbGVMaW5lYXIgfSBmcm9tICdAdngvc2NhbGUnO1xuaW1wb3J0IHsgbGluZSwgY3VydmVDYXJkaW5hbCB9IGZyb20gJ2QzLXNoYXBlJztcblxuZnVuY3Rpb24gY2FsbE9yVmFsdWUobWF5YmVGbiwgZGF0YSkge1xuICBpZiAodHlwZW9mIG1heWJlRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVGbihkYXRhKTtcbiAgfVxuICByZXR1cm4gbWF5YmVGbjtcbn1cblxuZnVuY3Rpb24gYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcywgZGF0YSkge1xuICByZXR1cm4gT2JqZWN0LmtleXMocmVzdFByb3BzKS5yZWR1Y2UoZnVuY3Rpb24gKHJldCwgY3VyKSB7XG4gICAgcmV0W2N1cl0gPSBjYWxsT3JWYWx1ZShyZXN0UHJvcHNbY3VyXSwgZGF0YSk7XG4gICAgcmV0dXJuIHJldDtcbiAgfSwge30pO1xufVxuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxudmFyIG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG9iaiwga2V5cykge1xuICB2YXIgdGFyZ2V0ID0ge307XG5cbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlO1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlO1xuICAgIHRhcmdldFtpXSA9IG9ialtpXTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG52YXIgc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHtcbiAgICB2YXIgX2FyciA9IFtdO1xuICAgIHZhciBfbiA9IHRydWU7XG4gICAgdmFyIF9kID0gZmFsc2U7XG4gICAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfZCA9IHRydWU7XG4gICAgICBfZSA9IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9hcnI7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgIHJldHVybiBhcnI7XG4gICAgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHtcbiAgICAgIHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xuICAgIH1cbiAgfTtcbn0oKTtcblxudmFyIHRvQ29uc3VtYWJsZUFycmF5ID0gZnVuY3Rpb24gKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICAgIHJldHVybiBhcnIyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGFycik7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHZlcnRpY2FsVG9Ib3Jpem9udGFsKF9yZWYpIHtcbiAgdmFyIF9yZWYyID0gc2xpY2VkVG9BcnJheShfcmVmLCA0KSxcbiAgICAgIHgxID0gX3JlZjJbMF0sXG4gICAgICB5MSA9IF9yZWYyWzFdLFxuICAgICAgeDIgPSBfcmVmMlsyXSxcbiAgICAgIHkyID0gX3JlZjJbM107XG5cbiAgcmV0dXJuIFt5MSwgeDEsIHkyLCB4Ml07XG59XG5cbmZ1bmN0aW9uIEJveFBsb3QoX3JlZjMpIHtcbiAgdmFyIF9yZWYzJGxlZnQgPSBfcmVmMy5sZWZ0LFxuICAgICAgbGVmdCA9IF9yZWYzJGxlZnQgPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmMyRsZWZ0LFxuICAgICAgX3JlZjMkdG9wID0gX3JlZjMudG9wLFxuICAgICAgdG9wID0gX3JlZjMkdG9wID09PSB1bmRlZmluZWQgPyAwIDogX3JlZjMkdG9wLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZjMuY2xhc3NOYW1lLFxuICAgICAgZGF0YSA9IF9yZWYzLmRhdGEsXG4gICAgICBtYXggPSBfcmVmMy5tYXgsXG4gICAgICBtaW4gPSBfcmVmMy5taW4sXG4gICAgICBmaXJzdFF1YXJ0aWxlID0gX3JlZjMuZmlyc3RRdWFydGlsZSxcbiAgICAgIHRoaXJkUXVhcnRpbGUgPSBfcmVmMy50aGlyZFF1YXJ0aWxlLFxuICAgICAgbWVkaWFuID0gX3JlZjMubWVkaWFuLFxuICAgICAgYm94V2lkdGggPSBfcmVmMy5ib3hXaWR0aCxcbiAgICAgIGZpbGwgPSBfcmVmMy5maWxsLFxuICAgICAgZmlsbE9wYWNpdHkgPSBfcmVmMy5maWxsT3BhY2l0eSxcbiAgICAgIHN0cm9rZSA9IF9yZWYzLnN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoID0gX3JlZjMuc3Ryb2tlV2lkdGgsXG4gICAgICBfcmVmMyRyeCA9IF9yZWYzLnJ4LFxuICAgICAgcnggPSBfcmVmMyRyeCA9PT0gdW5kZWZpbmVkID8gMiA6IF9yZWYzJHJ4LFxuICAgICAgX3JlZjMkcnkgPSBfcmVmMy5yeSxcbiAgICAgIHJ5ID0gX3JlZjMkcnkgPT09IHVuZGVmaW5lZCA/IDIgOiBfcmVmMyRyeSxcbiAgICAgIHZhbHVlU2NhbGUgPSBfcmVmMy52YWx1ZVNjYWxlLFxuICAgICAgb3V0bGllcnMgPSBfcmVmMy5vdXRsaWVycyxcbiAgICAgIGhvcml6b250YWwgPSBfcmVmMy5ob3Jpem9udGFsLFxuICAgICAgX3JlZjMkbWVkaWFuUHJvcHMgPSBfcmVmMy5tZWRpYW5Qcm9wcyxcbiAgICAgIG1lZGlhblByb3BzID0gX3JlZjMkbWVkaWFuUHJvcHMgPT09IHVuZGVmaW5lZCA/IHt9IDogX3JlZjMkbWVkaWFuUHJvcHMsXG4gICAgICBfcmVmMyRtYXhQcm9wcyA9IF9yZWYzLm1heFByb3BzLFxuICAgICAgbWF4UHJvcHMgPSBfcmVmMyRtYXhQcm9wcyA9PT0gdW5kZWZpbmVkID8ge30gOiBfcmVmMyRtYXhQcm9wcyxcbiAgICAgIF9yZWYzJG1pblByb3BzID0gX3JlZjMubWluUHJvcHMsXG4gICAgICBtaW5Qcm9wcyA9IF9yZWYzJG1pblByb3BzID09PSB1bmRlZmluZWQgPyB7fSA6IF9yZWYzJG1pblByb3BzLFxuICAgICAgX3JlZjMkYm94UHJvcHMgPSBfcmVmMy5ib3hQcm9wcyxcbiAgICAgIGJveFByb3BzID0gX3JlZjMkYm94UHJvcHMgPT09IHVuZGVmaW5lZCA/IHt9IDogX3JlZjMkYm94UHJvcHMsXG4gICAgICBfcmVmMyRvdXRsaWVyUHJvcHMgPSBfcmVmMy5vdXRsaWVyUHJvcHMsXG4gICAgICBvdXRsaWVyUHJvcHMgPSBfcmVmMyRvdXRsaWVyUHJvcHMgPT09IHVuZGVmaW5lZCA/IHt9IDogX3JlZjMkb3V0bGllclByb3BzLFxuICAgICAgX3JlZjMkY29udGFpbmVyID0gX3JlZjMuY29udGFpbmVyLFxuICAgICAgY29udGFpbmVyID0gX3JlZjMkY29udGFpbmVyID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYzJGNvbnRhaW5lcixcbiAgICAgIF9yZWYzJGNvbnRhaW5lclByb3BzID0gX3JlZjMuY29udGFpbmVyUHJvcHMsXG4gICAgICBjb250YWluZXJQcm9wcyA9IF9yZWYzJGNvbnRhaW5lclByb3BzID09PSB1bmRlZmluZWQgPyB7fSA6IF9yZWYzJGNvbnRhaW5lclByb3BzLFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjMsIFsnbGVmdCcsICd0b3AnLCAnY2xhc3NOYW1lJywgJ2RhdGEnLCAnbWF4JywgJ21pbicsICdmaXJzdFF1YXJ0aWxlJywgJ3RoaXJkUXVhcnRpbGUnLCAnbWVkaWFuJywgJ2JveFdpZHRoJywgJ2ZpbGwnLCAnZmlsbE9wYWNpdHknLCAnc3Ryb2tlJywgJ3N0cm9rZVdpZHRoJywgJ3J4JywgJ3J5JywgJ3ZhbHVlU2NhbGUnLCAnb3V0bGllcnMnLCAnaG9yaXpvbnRhbCcsICdtZWRpYW5Qcm9wcycsICdtYXhQcm9wcycsICdtaW5Qcm9wcycsICdib3hQcm9wcycsICdvdXRsaWVyUHJvcHMnLCAnY29udGFpbmVyJywgJ2NvbnRhaW5lclByb3BzJ10pO1xuXG4gIHZhciBvZmZzZXQgPSBob3Jpem9udGFsID8gdG9wIDogbGVmdDtcbiAgdmFyIGNlbnRlciA9IG9mZnNldCArIGJveFdpZHRoIC8gMjtcblxuICB2YXIgbWF4TGluZVBvcyA9IEFycmF5KDQpLmZpbGwoMCk7XG4gIHZhciBtYXhUb0JveExpbmVQb3MgPSBBcnJheSg0KS5maWxsKDApO1xuICB2YXIgYm94UG9zID0gQXJyYXkoNCkuZmlsbCgwKTtcbiAgdmFyIG1lZGlhbkxpbmVQb3MgPSBBcnJheSg0KS5maWxsKDApO1xuICB2YXIgbWluVG9Cb3hMaW5lUG9zID0gQXJyYXkoNCkuZmlsbCgwKTtcbiAgdmFyIG1pbkxpbmVQb3MgPSBBcnJheSg0KS5maWxsKDApO1xuICB2YXIgY29udGFpbmVyUG9zID0gQXJyYXkoNCkuZmlsbCgwKTtcblxuICAvLyBhbGwgb2YgdGhlc2UgYXJlIFt4MCwgeTAsIHgxLCB5MV1cbiAgbWF4TGluZVBvc1swXSA9IGNlbnRlciAtIGJveFdpZHRoIC8gNDtcbiAgbWF4TGluZVBvc1sxXSA9IHZhbHVlU2NhbGUobWF4KTtcbiAgbWF4TGluZVBvc1syXSA9IGNlbnRlciArIGJveFdpZHRoIC8gNDtcbiAgbWF4TGluZVBvc1szXSA9IHZhbHVlU2NhbGUobWF4KTtcblxuICBtYXhUb0JveExpbmVQb3NbMF0gPSBjZW50ZXI7XG4gIG1heFRvQm94TGluZVBvc1sxXSA9IHZhbHVlU2NhbGUobWF4KTtcbiAgbWF4VG9Cb3hMaW5lUG9zWzJdID0gY2VudGVyO1xuICBtYXhUb0JveExpbmVQb3NbM10gPSB2YWx1ZVNjYWxlKHRoaXJkUXVhcnRpbGUpO1xuXG4gIGJveFBvc1swXSA9IG9mZnNldDtcbiAgYm94UG9zWzFdID0gdmFsdWVTY2FsZSh0aGlyZFF1YXJ0aWxlKTtcbiAgYm94UG9zWzJdID0gYm94V2lkdGg7XG4gIGJveFBvc1szXSA9IE1hdGguYWJzKHZhbHVlU2NhbGUodGhpcmRRdWFydGlsZSkgLSB2YWx1ZVNjYWxlKGZpcnN0UXVhcnRpbGUpKTtcblxuICBtZWRpYW5MaW5lUG9zWzBdID0gb2Zmc2V0O1xuICBtZWRpYW5MaW5lUG9zWzFdID0gdmFsdWVTY2FsZShtZWRpYW4pO1xuICBtZWRpYW5MaW5lUG9zWzJdID0gb2Zmc2V0ICsgYm94V2lkdGg7XG4gIG1lZGlhbkxpbmVQb3NbM10gPSB2YWx1ZVNjYWxlKG1lZGlhbik7XG5cbiAgbWluVG9Cb3hMaW5lUG9zWzBdID0gY2VudGVyO1xuICBtaW5Ub0JveExpbmVQb3NbMV0gPSB2YWx1ZVNjYWxlKGZpcnN0UXVhcnRpbGUpO1xuICBtaW5Ub0JveExpbmVQb3NbMl0gPSBjZW50ZXI7XG4gIG1pblRvQm94TGluZVBvc1szXSA9IHZhbHVlU2NhbGUobWluKTtcblxuICBtaW5MaW5lUG9zWzBdID0gY2VudGVyIC0gYm94V2lkdGggLyA0O1xuICBtaW5MaW5lUG9zWzFdID0gdmFsdWVTY2FsZShtaW4pO1xuICBtaW5MaW5lUG9zWzJdID0gY2VudGVyICsgYm94V2lkdGggLyA0O1xuICBtaW5MaW5lUG9zWzNdID0gdmFsdWVTY2FsZShtaW4pO1xuXG4gIHZhciB2YWx1ZVJhbmdlID0gdmFsdWVTY2FsZS5yYW5nZSgpO1xuICBjb250YWluZXJQb3NbMF0gPSBib3hQb3NbMF07XG4gIGNvbnRhaW5lclBvc1sxXSA9IE1hdGgubWluLmFwcGx5KE1hdGgsIHRvQ29uc3VtYWJsZUFycmF5KHZhbHVlUmFuZ2UpKTtcbiAgY29udGFpbmVyUG9zWzJdID0gYm94UG9zWzJdO1xuICBjb250YWluZXJQb3NbM10gPSBNYXRoLmFicyh2YWx1ZVJhbmdlWzBdIC0gdmFsdWVSYW5nZVsxXSk7XG5cbiAgaWYgKGhvcml6b250YWwpIHtcbiAgICBtYXhMaW5lUG9zID0gdmVydGljYWxUb0hvcml6b250YWwobWF4TGluZVBvcyk7XG4gICAgbWF4VG9Cb3hMaW5lUG9zID0gdmVydGljYWxUb0hvcml6b250YWwobWF4VG9Cb3hMaW5lUG9zKTtcbiAgICBib3hQb3MgPSB2ZXJ0aWNhbFRvSG9yaXpvbnRhbChib3hQb3MpO1xuICAgIGJveFBvc1swXSA9IHZhbHVlU2NhbGUoZmlyc3RRdWFydGlsZSk7XG4gICAgbWVkaWFuTGluZVBvcyA9IHZlcnRpY2FsVG9Ib3Jpem9udGFsKG1lZGlhbkxpbmVQb3MpO1xuICAgIG1pblRvQm94TGluZVBvcyA9IHZlcnRpY2FsVG9Ib3Jpem9udGFsKG1pblRvQm94TGluZVBvcyk7XG4gICAgbWluTGluZVBvcyA9IHZlcnRpY2FsVG9Ib3Jpem9udGFsKG1pbkxpbmVQb3MpO1xuICAgIGNvbnRhaW5lclBvcyA9IHZlcnRpY2FsVG9Ib3Jpem9udGFsKGNvbnRhaW5lclBvcyk7XG4gICAgY29udGFpbmVyUG9zWzBdID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgdG9Db25zdW1hYmxlQXJyYXkodmFsdWVSYW5nZSkpO1xuICB9XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIEdyb3VwLFxuICAgIHsgY2xhc3NOYW1lOiBjbGFzc25hbWVzKCd2eC1ib3hwbG90JywgY2xhc3NOYW1lKSB9LFxuICAgIG91dGxpZXJzLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgdmFyIGN4ID0gaG9yaXpvbnRhbCA/IHZhbHVlU2NhbGUoZCkgOiBjZW50ZXI7XG4gICAgICB2YXIgY3kgPSBob3Jpem9udGFsID8gY2VudGVyIDogdmFsdWVTY2FsZShkKTtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdjaXJjbGUnLCBfZXh0ZW5kcyh7XG4gICAgICAgIGtleTogaSxcbiAgICAgICAgY2xhc3NOYW1lOiAndngtYm94cGxvdC1vdXRsaWVyJyxcbiAgICAgICAgY3g6IGN4LFxuICAgICAgICBjeTogY3ksXG4gICAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgZmlsbDogZmlsbCxcbiAgICAgICAgZmlsbE9wYWNpdHk6IGZpbGxPcGFjaXR5LFxuICAgICAgICByOiAnNCdcbiAgICAgIH0sIGFkZGl0aW9uYWxQcm9wcyhvdXRsaWVyUHJvcHMsIHtcbiAgICAgICAgZGF0YTogZCxcbiAgICAgICAgY3g6IGN4LFxuICAgICAgICBjeTogY3lcbiAgICAgIH0pKSk7XG4gICAgfSksXG4gICAgUmVhY3QuY3JlYXRlRWxlbWVudCgnbGluZScsIF9leHRlbmRzKHtcbiAgICAgIGNsYXNzTmFtZTogJ3Z4LWJveHBsb3QtbWF4JyxcbiAgICAgIHgxOiBtYXhMaW5lUG9zWzBdLFxuICAgICAgeTE6IG1heExpbmVQb3NbMV0sXG4gICAgICB4MjogbWF4TGluZVBvc1syXSxcbiAgICAgIHkyOiBtYXhMaW5lUG9zWzNdLFxuICAgICAgc3Ryb2tlOiBzdHJva2UsXG4gICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGhcbiAgICB9LCBhZGRpdGlvbmFsUHJvcHMobWF4UHJvcHMsIHtcbiAgICAgIGRhdGE6IGRhdGEsXG4gICAgICBtYXg6IG1heCxcbiAgICAgIHgxOiBtYXhMaW5lUG9zWzBdLFxuICAgICAgeDI6IG1heExpbmVQb3NbMl0sXG4gICAgICB5MTogbWF4TGluZVBvc1sxXSxcbiAgICAgIHkyOiBtYXhMaW5lUG9zWzNdXG4gICAgfSkpKSxcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdsaW5lJywge1xuICAgICAgeDE6IG1heFRvQm94TGluZVBvc1swXSxcbiAgICAgIHkxOiBtYXhUb0JveExpbmVQb3NbMV0sXG4gICAgICB4MjogbWF4VG9Cb3hMaW5lUG9zWzJdLFxuICAgICAgeTI6IG1heFRvQm94TGluZVBvc1szXSxcbiAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoXG4gICAgfSksXG4gICAgUmVhY3QuY3JlYXRlRWxlbWVudCgncmVjdCcsIF9leHRlbmRzKHtcbiAgICAgIGNsYXNzTmFtZTogJ3Z4LWJveHBsb3QtYm94JyxcbiAgICAgIHg6IGJveFBvc1swXSxcbiAgICAgIHk6IGJveFBvc1sxXSxcbiAgICAgIHdpZHRoOiBib3hQb3NbMl0sXG4gICAgICBoZWlnaHQ6IGJveFBvc1szXSxcbiAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgICAgZmlsbDogZmlsbCxcbiAgICAgIGZpbGxPcGFjaXR5OiBmaWxsT3BhY2l0eSxcbiAgICAgIHJ4OiByeCxcbiAgICAgIHJ5OiByeVxuICAgIH0sIGFkZGl0aW9uYWxQcm9wcyhib3hQcm9wcywge1xuICAgICAgZGF0YTogZGF0YSxcbiAgICAgIGhlaWdodDogYm94UG9zWzNdLFxuICAgICAgbWVkaWFuOiBtZWRpYW4sXG4gICAgICBmaXJzdFF1YXJ0aWxlOiBmaXJzdFF1YXJ0aWxlLFxuICAgICAgdGhpcmRRdWFydGlsZTogdGhpcmRRdWFydGlsZSxcbiAgICAgIG1pbjogbWluLFxuICAgICAgbWF4OiBtYXgsXG4gICAgICB4MTogYm94UG9zWzBdLFxuICAgICAgeDI6IGJveFBvc1swXSArIGJveFBvc1syXSxcbiAgICAgIHkxOiBib3hQb3NbMV0sXG4gICAgICB5MjogYm94UG9zWzFdICsgYm94UG9zWzNdXG4gICAgfSkpKSxcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdsaW5lJywgX2V4dGVuZHMoe1xuICAgICAgY2xhc3NOYW1lOiAndngtYm94cGxvdC1tZWRpYW4nLFxuICAgICAgeDE6IG1lZGlhbkxpbmVQb3NbMF0sXG4gICAgICB5MTogbWVkaWFuTGluZVBvc1sxXSxcbiAgICAgIHgyOiBtZWRpYW5MaW5lUG9zWzJdLFxuICAgICAgeTI6IG1lZGlhbkxpbmVQb3NbM10sXG4gICAgICBzdHJva2U6IHN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aFxuICAgIH0sIGFkZGl0aW9uYWxQcm9wcyhtZWRpYW5Qcm9wcywge1xuICAgICAgZGF0YTogZGF0YSxcbiAgICAgIG1lZGlhbjogbWVkaWFuLFxuICAgICAgeDE6IG1lZGlhbkxpbmVQb3NbMF0sXG4gICAgICB4MjogbWVkaWFuTGluZVBvc1syXSxcbiAgICAgIHkxOiBtZWRpYW5MaW5lUG9zWzFdLFxuICAgICAgeTI6IG1lZGlhbkxpbmVQb3NbM11cbiAgICB9KSkpLFxuICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2xpbmUnLCB7XG4gICAgICB4MTogbWluVG9Cb3hMaW5lUG9zWzBdLFxuICAgICAgeTE6IG1pblRvQm94TGluZVBvc1sxXSxcbiAgICAgIHgyOiBtaW5Ub0JveExpbmVQb3NbMl0sXG4gICAgICB5MjogbWluVG9Cb3hMaW5lUG9zWzNdLFxuICAgICAgc3Ryb2tlOiBzdHJva2UsXG4gICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGhcbiAgICB9KSxcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdsaW5lJywgX2V4dGVuZHMoe1xuICAgICAgY2xhc3NOYW1lOiAndngtYm94cGxvdC1taW4nLFxuICAgICAgeDE6IG1pbkxpbmVQb3NbMF0sXG4gICAgICB5MTogbWluTGluZVBvc1sxXSxcbiAgICAgIHgyOiBtaW5MaW5lUG9zWzJdLFxuICAgICAgeTI6IG1pbkxpbmVQb3NbM10sXG4gICAgICBzdHJva2U6IHN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aFxuICAgIH0sIGFkZGl0aW9uYWxQcm9wcyhtaW5Qcm9wcywge1xuICAgICAgZGF0YTogZGF0YSxcbiAgICAgIG1pbjogbWluLFxuICAgICAgeDE6IG1pbkxpbmVQb3NbMF0sXG4gICAgICB4MjogbWluTGluZVBvc1syXSxcbiAgICAgIHkxOiBtaW5MaW5lUG9zWzFdLFxuICAgICAgeTI6IG1pbkxpbmVQb3NbM11cbiAgICB9KSkpLFxuICAgIGNvbnRhaW5lciAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KCdyZWN0JywgX2V4dGVuZHMoe1xuICAgICAgeDogY29udGFpbmVyUG9zWzBdLFxuICAgICAgeTogY29udGFpbmVyUG9zWzFdLFxuICAgICAgd2lkdGg6IGNvbnRhaW5lclBvc1syXSxcbiAgICAgIGhlaWdodDogY29udGFpbmVyUG9zWzNdLFxuICAgICAgZmlsbE9wYWNpdHk6ICcwJ1xuICAgIH0sIGFkZGl0aW9uYWxQcm9wcyhjb250YWluZXJQcm9wcywge1xuICAgICAgZGF0YTogZGF0YSxcbiAgICAgIHgxOiBjb250YWluZXJQb3NbMF0sXG4gICAgICB4MjogY29udGFpbmVyUG9zWzBdICsgY29udGFpbmVyUG9zWzJdLFxuICAgICAgeTE6IGNvbnRhaW5lclBvc1sxXSxcbiAgICAgIHkyOiBjb250YWluZXJQb3NbMV0gKyBjb250YWluZXJQb3NbM10sXG4gICAgICBtZWRpYW46IG1lZGlhbixcbiAgICAgIG1heDogbWF4LFxuICAgICAgbWluOiBtaW4sXG4gICAgICB0aGlyZFF1YXJ0aWxlOiB0aGlyZFF1YXJ0aWxlLFxuICAgICAgZmlyc3RRdWFydGlsZTogZmlyc3RRdWFydGlsZVxuICAgIH0pKSlcbiAgKTtcbn1cblxuZnVuY3Rpb24gVmlvbGluUGxvdChfcmVmKSB7XG4gIHZhciBfcmVmJGxlZnQgPSBfcmVmLmxlZnQsXG4gICAgICBsZWZ0ID0gX3JlZiRsZWZ0ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiRsZWZ0LFxuICAgICAgX3JlZiR0b3AgPSBfcmVmLnRvcCxcbiAgICAgIHRvcCA9IF9yZWYkdG9wID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiR0b3AsXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIGJpbkRhdGEgPSBfcmVmLmJpbkRhdGEsXG4gICAgICBfcmVmJHN0cm9rZSA9IF9yZWYuc3Ryb2tlLFxuICAgICAgc3Ryb2tlID0gX3JlZiRzdHJva2UgPT09IHVuZGVmaW5lZCA/ICdibGFjaycgOiBfcmVmJHN0cm9rZSxcbiAgICAgIF9yZWYkZmlsbCA9IF9yZWYuZmlsbCxcbiAgICAgIGZpbGwgPSBfcmVmJGZpbGwgPT09IHVuZGVmaW5lZCA/ICdyZ2JhKDAsMCwwLDAuMyknIDogX3JlZiRmaWxsLFxuICAgICAgb3BhY2l0eSA9IF9yZWYub3BhY2l0eSxcbiAgICAgIHN0cm9rZVdpZHRoID0gX3JlZi5zdHJva2VXaWR0aCxcbiAgICAgIHdpZHRoID0gX3JlZi53aWR0aCxcbiAgICAgIHZhbHVlU2NhbGUgPSBfcmVmLnZhbHVlU2NhbGUsXG4gICAgICBzdHJva2VEYXNoYXJyYXkgPSBfcmVmLnN0cm9rZURhc2hhcnJheSxcbiAgICAgIGhvcml6b250YWwgPSBfcmVmLmhvcml6b250YWwsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2xlZnQnLCAndG9wJywgJ2NsYXNzTmFtZScsICdiaW5EYXRhJywgJ3N0cm9rZScsICdmaWxsJywgJ29wYWNpdHknLCAnc3Ryb2tlV2lkdGgnLCAnd2lkdGgnLCAndmFsdWVTY2FsZScsICdzdHJva2VEYXNoYXJyYXknLCAnaG9yaXpvbnRhbCddKTtcblxuICB2YXIgY2VudGVyID0gKGhvcml6b250YWwgPyB0b3AgOiBsZWZ0KSArIHdpZHRoIC8gMjtcbiAgdmFyIGJpbkNvdW50cyA9IGJpbkRhdGEubWFwKGZ1bmN0aW9uIChiaW4pIHtcbiAgICByZXR1cm4gYmluLmNvdW50O1xuICB9KTtcbiAgdmFyIHdpZHRoU2NhbGUgPSBzY2FsZUxpbmVhcih7XG4gICAgcmFuZ2VSb3VuZDogWzAsIHdpZHRoIC8gMl0sXG4gICAgZG9tYWluOiBbMCwgTWF0aC5tYXguYXBwbHkoTWF0aCwgdG9Db25zdW1hYmxlQXJyYXkoYmluQ291bnRzKSldXG4gIH0pO1xuXG4gIHZhciBwYXRoID0gJyc7XG4gIGlmIChob3Jpem9udGFsKSB7XG4gICAgdmFyIHRvcEN1cnZlID0gbGluZSgpLngoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiB2YWx1ZVNjYWxlKGQudmFsdWUpO1xuICAgIH0pLnkoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBjZW50ZXIgLSB3aWR0aFNjYWxlKGQuY291bnQpO1xuICAgIH0pLmN1cnZlKGN1cnZlQ2FyZGluYWwpO1xuXG4gICAgdmFyIGJvdHRvbUN1cnZlID0gbGluZSgpLngoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiB2YWx1ZVNjYWxlKGQudmFsdWUpO1xuICAgIH0pLnkoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBjZW50ZXIgKyB3aWR0aFNjYWxlKGQuY291bnQpO1xuICAgIH0pLmN1cnZlKGN1cnZlQ2FyZGluYWwpO1xuXG4gICAgdmFyIHRvcEN1cnZlUGF0aCA9IHRvcEN1cnZlKGJpbkRhdGEpO1xuICAgIHZhciBib3R0b21DdXJ2ZVBhdGggPSBib3R0b21DdXJ2ZShbXS5jb25jYXQodG9Db25zdW1hYmxlQXJyYXkoYmluRGF0YSkpLnJldmVyc2UoKSk7XG4gICAgcGF0aCA9IHRvcEN1cnZlUGF0aCArICcgJyArIGJvdHRvbUN1cnZlUGF0aC5yZXBsYWNlKCdNJywgJ0wnKSArICcgWic7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHJpZ2h0Q3VydmUgPSBsaW5lKCkueChmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIGNlbnRlciArIHdpZHRoU2NhbGUoZC5jb3VudCk7XG4gICAgfSkueShmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIHZhbHVlU2NhbGUoZC52YWx1ZSk7XG4gICAgfSkuY3VydmUoY3VydmVDYXJkaW5hbCk7XG5cbiAgICB2YXIgbGVmdEN1cnZlID0gbGluZSgpLngoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBjZW50ZXIgLSB3aWR0aFNjYWxlKGQuY291bnQpO1xuICAgIH0pLnkoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiB2YWx1ZVNjYWxlKGQudmFsdWUpO1xuICAgIH0pLmN1cnZlKGN1cnZlQ2FyZGluYWwpO1xuXG4gICAgdmFyIHJpZ2h0Q3VydmVQYXRoID0gcmlnaHRDdXJ2ZShiaW5EYXRhKTtcbiAgICB2YXIgbGVmdEN1cnZlUGF0aCA9IGxlZnRDdXJ2ZShbXS5jb25jYXQodG9Db25zdW1hYmxlQXJyYXkoYmluRGF0YSkpLnJldmVyc2UoKSk7XG4gICAgcGF0aCA9IHJpZ2h0Q3VydmVQYXRoICsgJyAnICsgbGVmdEN1cnZlUGF0aC5yZXBsYWNlKCdNJywgJ0wnKSArICcgWic7XG4gIH1cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgR3JvdXAsXG4gICAgeyBjbGFzc05hbWU6IGNsYXNzbmFtZXMoJ3Z4LXZpb2xpbicsIGNsYXNzTmFtZSkgfSxcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgICAgZDogcGF0aCxcbiAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlRGFzaGFycmF5OiBzdHJva2VEYXNoYXJyYXksXG4gICAgICBmaWxsOiBmaWxsLFxuICAgICAgZmlsbE9wYWNpdHk6IG9wYWNpdHlcbiAgICB9LCBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzLCBiaW5EYXRhKSkpXG4gICk7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVTdGF0cyAobnVtZXJpY2FsQXJyYXkpIHtcbiAgdmFyIHBvaW50cyA9IFtdLmNvbmNhdCh0b0NvbnN1bWFibGVBcnJheShudW1lcmljYWxBcnJheSkpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYSAtIGI7XG4gIH0pO1xuICB2YXIgc2FtcGxlU2l6ZSA9IHBvaW50cy5sZW5ndGg7XG4gIHZhciBmaXJzdFF1YXJ0aWxlID0gcG9pbnRzW01hdGgucm91bmQoc2FtcGxlU2l6ZSAvIDQpXTtcbiAgdmFyIHRoaXJkUXVhcnRpbGUgPSBwb2ludHNbTWF0aC5yb3VuZCgzICogc2FtcGxlU2l6ZSAvIDQpXTtcbiAgdmFyIElRUiA9IHRoaXJkUXVhcnRpbGUgLSBmaXJzdFF1YXJ0aWxlO1xuXG4gIHZhciBtaW4gPSBmaXJzdFF1YXJ0aWxlIC0gMS41ICogSVFSO1xuICB2YXIgbWF4ID0gdGhpcmRRdWFydGlsZSArIDEuNSAqIElRUjtcblxuICB2YXIgb3V0bGllcnMgPSBwb2ludHMuZmlsdGVyKGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIHAgPCBtaW4gfHwgcCA+IG1heDtcbiAgfSk7XG4gIHZhciBiaW5XaWR0aCA9IDIgKiBJUVIgKiBNYXRoLnBvdyhzYW1wbGVTaXplIC0gb3V0bGllcnMubGVuZ3RoLCAtMSAvIDMpO1xuICB2YXIgYmluTnVtID0gTWF0aC5yb3VuZCgobWF4IC0gbWluKSAvIGJpbldpZHRoKTtcbiAgdmFyIGFjdHVhbEJpbldpZHRoID0gKG1heCAtIG1pbikgLyBiaW5OdW07XG5cbiAgdmFyIGJpbnMgPSBBcnJheShiaW5OdW0gKyAyKS5maWxsKDApO1xuICB2YXIgdmFsdWVzID0gQXJyYXkoYmluTnVtICsgMikuZmlsbChtaW4pO1xuXG4gIGZvciAodmFyIGkgPSAxOyBpIDw9IGJpbk51bTsgaSArPSAxKSB7XG4gICAgdmFsdWVzW2ldICs9IGFjdHVhbEJpbldpZHRoICogKGkgLSAwLjUpO1xuICB9XG5cbiAgdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXSA9IG1heDtcblxuICBwb2ludHMuZmlsdGVyKGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIHAgPj0gbWluICYmIHAgPD0gbWF4O1xuICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgYmluc1tNYXRoLmZsb29yKChwIC0gbWluKSAvIGFjdHVhbEJpbldpZHRoKSArIDFdICs9IDE7XG4gIH0pO1xuXG4gIHZhciBiaW5EYXRhID0gdmFsdWVzLm1hcChmdW5jdGlvbiAodiwgaSkge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogdixcbiAgICAgIGNvdW50OiBiaW5zW2ldXG4gICAgfTtcbiAgfSk7XG5cbiAgdmFyIGJveFBsb3QgPSB7XG4gICAgbWluOiBtaW4sXG4gICAgZmlyc3RRdWFydGlsZTogZmlyc3RRdWFydGlsZSxcbiAgICBtZWRpYW46IHBvaW50c1tNYXRoLnJvdW5kKHNhbXBsZVNpemUgLyAyKV0sXG4gICAgdGhpcmRRdWFydGlsZTogdGhpcmRRdWFydGlsZSxcbiAgICBtYXg6IG1heCxcbiAgICBvdXRsaWVyczogb3V0bGllcnNcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGJveFBsb3Q6IGJveFBsb3QsXG4gICAgYmluRGF0YTogYmluRGF0YVxuICB9O1xufVxuXG5leHBvcnQgeyBCb3hQbG90LCBWaW9saW5QbG90LCBjb21wdXRlU3RhdHMgfTtcbiIsImZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5pbXBvcnQgeyBCb3hQbG90IH0gZnJvbSAnQHZ4L3N0YXRzJztcbmltcG9ydCB7IEZvY3VzQmx1ckhhbmRsZXIgfSBmcm9tICdAZGF0YS11aS9zaGFyZWQnO1xuaW1wb3J0IHsgR3JvdXAgfSBmcm9tICdAdngvZ3JvdXAnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjb2xvciBhcyB0aGVtZUNvbG9ycyB9IGZyb20gJ0BkYXRhLXVpL3RoZW1lJztcbmltcG9ydCB7IGNhbGxPclZhbHVlLCBpc0RlZmluZWQgfSBmcm9tICcuLi91dGlscy9jaGFydFV0aWxzJztcbmltcG9ydCB7IGJveFBsb3RTZXJpZXNEYXRhU2hhcGUgfSBmcm9tICcuLi91dGlscy9wcm9wU2hhcGVzJztcbmltcG9ydCBzaGFyZWRTZXJpZXNQcm9wcyBmcm9tICcuLi91dGlscy9zaGFyZWRTZXJpZXNQcm9wcyc7XG5cbnZhciBwcm9wVHlwZXMgPSBfZXh0ZW5kcyh7fSwgc2hhcmVkU2VyaWVzUHJvcHMsIHtcbiAgY29udGFpbmVyRXZlbnRzOiBQcm9wVHlwZXMuYm9vbCxcbiAgZGF0YTogYm94UGxvdFNlcmllc0RhdGFTaGFwZS5pc1JlcXVpcmVkLFxuICBmaWxsOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLnN0cmluZ10pLFxuICBob3Jpem9udGFsOiBQcm9wVHlwZXMuYm9vbCxcbiAgc3Ryb2tlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLnN0cmluZ10pLFxuICBzdHJva2VXaWR0aDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgZmlsbE9wYWNpdHk6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gIHdpZHRoUmF0aW86IFByb3BUeXBlcy5udW1iZXIsXG4gIGNvbnRhaW5lclByb3BzOiBQcm9wVHlwZXMub2JqZWN0LFxuICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlYWN0L2ZvcmJpZC1wcm9wLXR5cGVzXG4gIG91dGxpZXJQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcbiAgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZWFjdC9mb3JiaWQtcHJvcC10eXBlc1xuICBib3hQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcbiAgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZWFjdC9mb3JiaWQtcHJvcC10eXBlc1xuICBtaW5Qcm9wczogUHJvcFR5cGVzLm9iamVjdCxcbiAgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZWFjdC9mb3JiaWQtcHJvcC10eXBlc1xuICBtYXhQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcbiAgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZWFjdC9mb3JiaWQtcHJvcC10eXBlc1xuICBtZWRpYW5Qcm9wczogUHJvcFR5cGVzLm9iamVjdCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlYWN0L2ZvcmJpZC1wcm9wLXR5cGVzXG5cbn0pO1xuXG52YXIgZGVmYXVsdFByb3BzID0ge1xuICBjb250YWluZXJFdmVudHM6IHRydWUsXG4gIHN0cm9rZTogdGhlbWVDb2xvcnMuZGFya0dyYXksXG4gIHN0cm9rZVdpZHRoOiAyLFxuICBmaWxsOiB0aGVtZUNvbG9ycy5kZWZhdWx0LFxuICBmaWxsT3BhY2l0eTogMSxcbiAgaG9yaXpvbnRhbDogZmFsc2UsXG4gIHdpZHRoUmF0aW86IDEsXG4gIGNvbnRhaW5lclByb3BzOiBudWxsLFxuICBvdXRsaWVyUHJvcHM6IG51bGwsXG4gIGJveFByb3BzOiBudWxsLFxuICBtaW5Qcm9wczogbnVsbCxcbiAgbWF4UHJvcHM6IG51bGwsXG4gIG1lZGlhblByb3BzOiBudWxsXG59O1xudmFyIE1BWF9CT1hfV0lEVEggPSA1MDtcblxudmFyIHggPSBmdW5jdGlvbiB4KGQpIHtcbiAgcmV0dXJuIGQueDtcbn07XG5cbnZhciB5ID0gZnVuY3Rpb24geShkKSB7XG4gIHJldHVybiBkLnk7XG59O1xuXG52YXIgbWluID0gZnVuY3Rpb24gbWluKGQpIHtcbiAgcmV0dXJuIGQubWluO1xufTtcblxudmFyIG1heCA9IGZ1bmN0aW9uIG1heChkKSB7XG4gIHJldHVybiBkLm1heDtcbn07XG5cbnZhciBtZWRpYW4gPSBmdW5jdGlvbiBtZWRpYW4oZCkge1xuICByZXR1cm4gZC5tZWRpYW47XG59O1xuXG52YXIgZmlyc3RRdWFydGlsZSA9IGZ1bmN0aW9uIGZpcnN0UXVhcnRpbGUoZCkge1xuICByZXR1cm4gZC5maXJzdFF1YXJ0aWxlO1xufTtcblxudmFyIHRoaXJkUXVhcnRpbGUgPSBmdW5jdGlvbiB0aGlyZFF1YXJ0aWxlKGQpIHtcbiAgcmV0dXJuIGQudGhpcmRRdWFydGlsZTtcbn07XG5cbnZhciBvdXRsaWVycyA9IGZ1bmN0aW9uIG91dGxpZXJzKGQpIHtcbiAgcmV0dXJuIGQub3V0bGllcnMgfHwgW107XG59O1xuXG52YXIgQm94UGxvdFNlcmllcyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1JlYWN0JFB1cmVDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoQm94UGxvdFNlcmllcywgX1JlYWN0JFB1cmVDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIEJveFBsb3RTZXJpZXMoKSB7XG4gICAgcmV0dXJuIF9SZWFjdCRQdXJlQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBCb3hQbG90U2VyaWVzLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIGNvbnRhaW5lckV2ZW50cyA9IF90aGlzJHByb3BzLmNvbnRhaW5lckV2ZW50cyxcbiAgICAgICAgZGF0YSA9IF90aGlzJHByb3BzLmRhdGEsXG4gICAgICAgIGZpbGwgPSBfdGhpcyRwcm9wcy5maWxsLFxuICAgICAgICBzdHJva2UgPSBfdGhpcyRwcm9wcy5zdHJva2UsXG4gICAgICAgIHN0cm9rZVdpZHRoID0gX3RoaXMkcHJvcHMuc3Ryb2tlV2lkdGgsXG4gICAgICAgIHhTY2FsZSA9IF90aGlzJHByb3BzLnhTY2FsZSxcbiAgICAgICAgeVNjYWxlID0gX3RoaXMkcHJvcHMueVNjYWxlLFxuICAgICAgICBob3Jpem9udGFsID0gX3RoaXMkcHJvcHMuaG9yaXpvbnRhbCxcbiAgICAgICAgd2lkdGhSYXRpbyA9IF90aGlzJHByb3BzLndpZHRoUmF0aW8sXG4gICAgICAgIGZpbGxPcGFjaXR5ID0gX3RoaXMkcHJvcHMuZmlsbE9wYWNpdHksXG4gICAgICAgIGNvbnRhaW5lclByb3BzID0gX3RoaXMkcHJvcHMuY29udGFpbmVyUHJvcHMsXG4gICAgICAgIG91dGxpZXJQcm9wcyA9IF90aGlzJHByb3BzLm91dGxpZXJQcm9wcyxcbiAgICAgICAgYm94UHJvcHMgPSBfdGhpcyRwcm9wcy5ib3hQcm9wcyxcbiAgICAgICAgbWluUHJvcHMgPSBfdGhpcyRwcm9wcy5taW5Qcm9wcyxcbiAgICAgICAgbWF4UHJvcHMgPSBfdGhpcyRwcm9wcy5tYXhQcm9wcyxcbiAgICAgICAgbWVkaWFuUHJvcHMgPSBfdGhpcyRwcm9wcy5tZWRpYW5Qcm9wcyxcbiAgICAgICAgb25Nb3VzZU1vdmUgPSBfdGhpcyRwcm9wcy5vbk1vdXNlTW92ZSxcbiAgICAgICAgb25Nb3VzZUxlYXZlID0gX3RoaXMkcHJvcHMub25Nb3VzZUxlYXZlLFxuICAgICAgICBkaXNhYmxlTW91c2VFdmVudHMgPSBfdGhpcyRwcm9wcy5kaXNhYmxlTW91c2VFdmVudHMsXG4gICAgICAgIG9uQ2xpY2sgPSBfdGhpcyRwcm9wcy5vbkNsaWNrO1xuICAgIGlmICgheFNjYWxlIHx8ICF5U2NhbGUpIHJldHVybiBudWxsO1xuICAgIHZhciBvZmZzZXRTY2FsZSA9IGhvcml6b250YWwgPyB5U2NhbGUgOiB4U2NhbGU7XG4gICAgdmFyIG9mZnNldFZhbHVlID0gaG9yaXpvbnRhbCA/IHkgOiB4O1xuICAgIHZhciB2YWx1ZVNjYWxlID0gaG9yaXpvbnRhbCA/IHhTY2FsZSA6IHlTY2FsZTtcbiAgICB2YXIgYm94V2lkdGggPSBvZmZzZXRTY2FsZS5iYW5kd2lkdGgoKTtcbiAgICB2YXIgYWN0dWFsV2lkdGggPSBNYXRoLm1pbihNQVhfQk9YX1dJRFRILCBib3hXaWR0aCk7XG4gICAgdmFyIG9mZnNldCA9IChvZmZzZXRTY2FsZS5vZmZzZXQgfHwgMCkgLSAoYm94V2lkdGggLSBhY3R1YWxXaWR0aCkgLyAyO1xuICAgIHZhciBvZmZzZXRQcm9wTmFtZSA9IGhvcml6b250YWwgPyAndG9wJyA6ICdsZWZ0JztcblxuICAgIHZhciBvZmZzZXRQcm9wID0gZnVuY3Rpb24gb2Zmc2V0UHJvcChkKSB7XG4gICAgICB2YXIgX3JlZjtcblxuICAgICAgcmV0dXJuIF9yZWYgPSB7fSwgX3JlZltvZmZzZXRQcm9wTmFtZV0gPSBvZmZzZXRTY2FsZShvZmZzZXRWYWx1ZShkKSkgLSBvZmZzZXQgKyAoMSAtIHdpZHRoUmF0aW8pIC8gMiAqIGFjdHVhbFdpZHRoLCBfcmVmO1xuICAgIH07XG5cbiAgICB2YXIgbW91c2VFdmVudFByb3BzID0gZnVuY3Rpb24gbW91c2VFdmVudFByb3BzKGQsIGkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9uTW91c2VNb3ZlOiBkaXNhYmxlTW91c2VFdmVudHMgPyBudWxsIDogb25Nb3VzZU1vdmUgJiYgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIG9uTW91c2VNb3ZlKHtcbiAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICBkYXR1bTogZCxcbiAgICAgICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIG9uTW91c2VMZWF2ZTogZGlzYWJsZU1vdXNlRXZlbnRzID8gbnVsbCA6IG9uTW91c2VMZWF2ZSAmJiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIG9uTW91c2VMZWF2ZTtcbiAgICAgICAgfSxcbiAgICAgICAgb25DbGljazogZGlzYWJsZU1vdXNlRXZlbnRzID8gbnVsbCA6IG9uQ2xpY2sgJiYgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIG9uQ2xpY2soe1xuICAgICAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICAgIGRhdHVtOiBkLFxuICAgICAgICAgICAgICBpbmRleDogaVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoR3JvdXAsIG51bGwsIGRhdGEubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICB2YXIgbW91c2VFdmVudHMgPSBtb3VzZUV2ZW50UHJvcHMoZCwgaSk7XG4gICAgICByZXR1cm4gaXNEZWZpbmVkKG1pbihkKSkgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChGb2N1c0JsdXJIYW5kbGVyLCB7XG4gICAgICAgIGtleTogb2Zmc2V0VmFsdWUoZCksXG4gICAgICAgIHhsaW5rSHJlZjogXCIjXCIsXG4gICAgICAgIG9uQmx1cjogZGlzYWJsZU1vdXNlRXZlbnRzID8gbnVsbCA6IG9uTW91c2VMZWF2ZSxcbiAgICAgICAgb25Gb2N1czogZGlzYWJsZU1vdXNlRXZlbnRzID8gbnVsbCA6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIG9uTW91c2VNb3ZlKHtcbiAgICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICBkYXR1bTogZCxcbiAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQm94UGxvdCwgX2V4dGVuZHMoe1xuICAgICAgICBtaW46IG1pbihkKSxcbiAgICAgICAgbWF4OiBtYXgoZClcbiAgICAgIH0sIG9mZnNldFByb3AoZCksIHtcbiAgICAgICAgZmlyc3RRdWFydGlsZTogZmlyc3RRdWFydGlsZShkKSxcbiAgICAgICAgdGhpcmRRdWFydGlsZTogdGhpcmRRdWFydGlsZShkKSxcbiAgICAgICAgbWVkaWFuOiBtZWRpYW4oZCksXG4gICAgICAgIGJveFdpZHRoOiBhY3R1YWxXaWR0aCAqIHdpZHRoUmF0aW8sXG4gICAgICAgIG91dGxpZXJzOiBvdXRsaWVycyhkKSxcbiAgICAgICAgZmlsbDogZC5maWxsIHx8IGNhbGxPclZhbHVlKGZpbGwsIGQsIGkpLFxuICAgICAgICBzdHJva2U6IGQuc3Ryb2tlIHx8IGNhbGxPclZhbHVlKHN0cm9rZSwgZCwgaSksXG4gICAgICAgIHN0cm9rZVdpZHRoOiBkLnN0cm9rZVdpZHRoIHx8IGNhbGxPclZhbHVlKHN0cm9rZVdpZHRoLCBkLCBpKSxcbiAgICAgICAgZmlsbE9wYWNpdHk6IGQuZmlsbE9wYWNpdHkgfHwgY2FsbE9yVmFsdWUoZmlsbE9wYWNpdHksIGQsIGkpLFxuICAgICAgICB2YWx1ZVNjYWxlOiB2YWx1ZVNjYWxlLFxuICAgICAgICBob3Jpem9udGFsOiBob3Jpem9udGFsLFxuICAgICAgICBjb250YWluZXI6IGNvbnRhaW5lckV2ZW50cyxcbiAgICAgICAgY29udGFpbmVyUHJvcHM6IChjb250YWluZXJFdmVudHMgfHwgY29udGFpbmVyUHJvcHMgfHwgdW5kZWZpbmVkKSAmJiBfZXh0ZW5kcyh7fSwgY29udGFpbmVyUHJvcHMsIGNvbnRhaW5lckV2ZW50cyAmJiBtb3VzZUV2ZW50cyksXG4gICAgICAgIG91dGxpZXJQcm9wczogKCFjb250YWluZXJFdmVudHMgfHwgb3V0bGllclByb3BzIHx8IHVuZGVmaW5lZCkgJiYgX2V4dGVuZHMoe30sIG91dGxpZXJQcm9wcywgIWNvbnRhaW5lckV2ZW50cyAmJiBtb3VzZUV2ZW50cyksXG4gICAgICAgIGJveFByb3BzOiAoIWNvbnRhaW5lckV2ZW50cyB8fCBib3hQcm9wcyB8fCB1bmRlZmluZWQpICYmIF9leHRlbmRzKHt9LCBib3hQcm9wcywgIWNvbnRhaW5lckV2ZW50cyAmJiBtb3VzZUV2ZW50cyksXG4gICAgICAgIG1pblByb3BzOiAoIWNvbnRhaW5lckV2ZW50cyB8fCBtaW5Qcm9wcyB8fCB1bmRlZmluZWQpICYmIF9leHRlbmRzKHt9LCBtaW5Qcm9wcywgIWNvbnRhaW5lckV2ZW50cyAmJiBtb3VzZUV2ZW50cyksXG4gICAgICAgIG1heFByb3BzOiAoIWNvbnRhaW5lckV2ZW50cyB8fCBtYXhQcm9wcyB8fCB1bmRlZmluZWQpICYmIF9leHRlbmRzKHt9LCBtYXhQcm9wcywgIWNvbnRhaW5lckV2ZW50cyAmJiBtb3VzZUV2ZW50cyksXG4gICAgICAgIG1lZGlhblByb3BzOiAoIWNvbnRhaW5lckV2ZW50cyB8fCBtZWRpYW5Qcm9wcyB8fCB1bmRlZmluZWQpICYmIF9leHRlbmRzKHt9LCBtZWRpYW5Qcm9wcywgIWNvbnRhaW5lckV2ZW50cyAmJiBtb3VzZUV2ZW50cylcbiAgICAgIH0pKSk7XG4gICAgfSkpO1xuICB9O1xuXG4gIHJldHVybiBCb3hQbG90U2VyaWVzO1xufShSZWFjdC5QdXJlQ29tcG9uZW50KTtcblxuZXhwb3J0IHsgQm94UGxvdFNlcmllcyBhcyBkZWZhdWx0IH07XG5Cb3hQbG90U2VyaWVzLnByb3BUeXBlcyA9IHByb3BUeXBlcztcbkJveFBsb3RTZXJpZXMuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuQm94UGxvdFNlcmllcy5kaXNwbGF5TmFtZSA9ICdCb3hQbG90U2VyaWVzJzsiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgaXNEZWZpbmVkLCBUb29sdGlwRnJhbWUsIFRvb2x0aXBUYWJsZSB9IGZyb20gJ0BzdXBlcnNldC11aS9jb3JlJztcbmltcG9ydCB7IEJveFBsb3RFbmNvZGVyIH0gZnJvbSAnLi9FbmNvZGVyJztcbmltcG9ydCB7IEJveFBsb3REYXRhUm93IH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERlZmF1bHRUb29sdGlwUmVuZGVyZXIoe1xuICBkYXR1bSxcbiAgY29sb3IsXG4gIGVuY29kZXIsXG59OiB7XG4gIGRhdHVtOiBCb3hQbG90RGF0YVJvdztcbiAgY29sb3I6IHN0cmluZztcbiAgZW5jb2RlcjogQm94UGxvdEVuY29kZXI7XG59KSB7XG4gIGNvbnN0IHsgbGFiZWwsIG1pbiwgbWF4LCBtZWRpYW4sIGZpcnN0UXVhcnRpbGUsIHRoaXJkUXVhcnRpbGUsIG91dGxpZXJzIH0gPSBkYXR1bTtcbiAgY29uc3QgeyBjaGFubmVscyB9ID0gZW5jb2RlcjtcblxuICBjb25zdCB7IGZvcm1hdFZhbHVlIH0gPSBjaGFubmVscy55O1xuXG4gIGNvbnN0IGRhdGE6IHsga2V5OiBzdHJpbmc7IHZhbHVlQ29sdW1uOiBudW1iZXIgfCBzdHJpbmcgfVtdID0gW107XG4gIGlmIChpc0RlZmluZWQobWluKSkge1xuICAgIGRhdGEucHVzaCh7IGtleTogJ01pbicsIHZhbHVlQ29sdW1uOiBmb3JtYXRWYWx1ZShtaW4pIH0pO1xuICB9XG4gIGlmIChpc0RlZmluZWQobWF4KSkge1xuICAgIGRhdGEucHVzaCh7IGtleTogJ01heCcsIHZhbHVlQ29sdW1uOiBmb3JtYXRWYWx1ZShtYXgpIH0pO1xuICB9XG4gIGlmIChpc0RlZmluZWQobWVkaWFuKSkge1xuICAgIGRhdGEucHVzaCh7IGtleTogJ01lZGlhbicsIHZhbHVlQ29sdW1uOiBmb3JtYXRWYWx1ZShtZWRpYW4pIH0pO1xuICB9XG4gIGlmIChpc0RlZmluZWQoZmlyc3RRdWFydGlsZSkpIHtcbiAgICBkYXRhLnB1c2goeyBrZXk6ICcxc3QgUXVhcnRpbGUnLCB2YWx1ZUNvbHVtbjogZm9ybWF0VmFsdWUoZmlyc3RRdWFydGlsZSkgfSk7XG4gIH1cbiAgaWYgKGlzRGVmaW5lZCh0aGlyZFF1YXJ0aWxlKSkge1xuICAgIGRhdGEucHVzaCh7IGtleTogJzNyZCBRdWFydGlsZScsIHZhbHVlQ29sdW1uOiBmb3JtYXRWYWx1ZSh0aGlyZFF1YXJ0aWxlKSB9KTtcbiAgfVxuICBpZiAoaXNEZWZpbmVkKG91dGxpZXJzKSAmJiBvdXRsaWVycy5sZW5ndGggPiAwKSB7XG4gICAgZGF0YS5wdXNoKHsga2V5OiAnIyBPdXRsaWVycycsIHZhbHVlQ29sdW1uOiBvdXRsaWVycy5sZW5ndGggfSk7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxUb29sdGlwRnJhbWU+XG4gICAgICA8ZGl2PlxuICAgICAgICA8c3Ryb25nIHN0eWxlPXt7IGNvbG9yIH19PntsYWJlbH08L3N0cm9uZz5cbiAgICAgIDwvZGl2PlxuICAgICAge2RhdGEubGVuZ3RoID4gMCAmJiA8YnIgLz59XG4gICAgICA8VG9vbHRpcFRhYmxlIGRhdGE9e2RhdGF9IC8+XG4gICAgPC9Ub29sdGlwRnJhbWU+XG4gICk7XG59XG4iLCJpbXBvcnQgeyBjcmVhdGVFbmNvZGVyRmFjdG9yeSwgRW5jb2RlciwgRGVyaXZlRW5jb2RpbmcgfSBmcm9tICdlbmNvZGFibGUnO1xuXG5leHBvcnQgdHlwZSBCb3hQbG90RW5jb2RpbmdDb25maWcgPSB7XG4gIHg6IFsnWEJhbmQnLCBudW1iZXJdO1xuICB5OiBbJ1lCYW5kJywgbnVtYmVyXTtcbiAgY29sb3I6IFsnQ29sb3InLCBzdHJpbmddO1xufTtcblxuZXhwb3J0IGNvbnN0IGJveFBsb3RFbmNvZGVyRmFjdG9yeSA9IGNyZWF0ZUVuY29kZXJGYWN0b3J5PEJveFBsb3RFbmNvZGluZ0NvbmZpZz4oe1xuICBjaGFubmVsVHlwZXM6IHtcbiAgICB4OiAnWEJhbmQnLFxuICAgIHk6ICdZQmFuZCcsXG4gICAgY29sb3I6ICdDb2xvcicsXG4gIH0sXG4gIGRlZmF1bHRFbmNvZGluZzoge1xuICAgIHg6IHsgZmllbGQ6ICd4JywgdHlwZTogJ25vbWluYWwnIH0sXG4gICAgeTogeyBmaWVsZDogJ3knLCB0eXBlOiAncXVhbnRpdGF0aXZlJyB9LFxuICAgIGNvbG9yOiB7IHZhbHVlOiAnIzIyMicgfSxcbiAgfSxcbn0pO1xuXG5leHBvcnQgdHlwZSBCb3hQbG90RW5jb2RpbmcgPSBEZXJpdmVFbmNvZGluZzxCb3hQbG90RW5jb2RpbmdDb25maWc+O1xuXG5leHBvcnQgdHlwZSBCb3hQbG90RW5jb2RlciA9IEVuY29kZXI8Qm94UGxvdEVuY29kaW5nQ29uZmlnPjtcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBCb3hQbG90U2VyaWVzLCBYWUNoYXJ0IH0gZnJvbSAnQGRhdGEtdWkveHktY2hhcnQnO1xuaW1wb3J0IHsgY2hhcnRUaGVtZSwgQ2hhcnRUaGVtZSB9IGZyb20gJ0BkYXRhLXVpL3RoZW1lJztcbmltcG9ydCB7IFdpdGhMZWdlbmQsIE1hcmdpbiwgRGltZW5zaW9uIH0gZnJvbSAnQHN1cGVyc2V0LXVpL2NvcmUnO1xuaW1wb3J0IHsgRGF0YXNldCwgUGxhaW5PYmplY3QsIGlzRmllbGREZWYgfSBmcm9tICdlbmNvZGFibGUnO1xuaW1wb3J0IERlZmF1bHRUb29sdGlwUmVuZGVyZXIgZnJvbSAnLi9EZWZhdWx0VG9vbHRpcFJlbmRlcmVyJztcbmltcG9ydCB7XG4gIEJveFBsb3RFbmNvZGluZ0NvbmZpZyxcbiAgQm94UGxvdEVuY29kaW5nLFxuICBCb3hQbG90RW5jb2RlcixcbiAgYm94UGxvdEVuY29kZXJGYWN0b3J5LFxufSBmcm9tICcuL0VuY29kZXInO1xuaW1wb3J0IGNyZWF0ZU1hcmdpblNlbGVjdG9yLCB7IERFRkFVTFRfTUFSR0lOIH0gZnJvbSAnLi4vLi4vdXRpbHMvY3JlYXRlTWFyZ2luU2VsZWN0b3InO1xuaW1wb3J0IHsgQm94UGxvdERhdGFSb3cgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCBjb252ZXJ0U2NhbGVUb0RhdGFVSVNjYWxlIGZyb20gJy4uLy4uL3V0aWxzL2NvbnZlcnRTY2FsZVRvRGF0YVVJU2NhbGVTaGFwZSc7XG5pbXBvcnQgY3JlYXRlWFlDaGFydExheW91dFdpdGhUaGVtZSBmcm9tICcuLi8uLi91dGlscy9jcmVhdGVYWUNoYXJ0TGF5b3V0V2l0aFRoZW1lJztcbmltcG9ydCBjcmVhdGVSZW5kZXJMZWdlbmQgZnJvbSAnLi4vbGVnZW5kL2NyZWF0ZVJlbmRlckxlZ2VuZCc7XG5pbXBvcnQgeyBMZWdlbmRIb29rcyB9IGZyb20gJy4uL2xlZ2VuZC90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVG9vbHRpcFByb3BzIHtcbiAgZGF0dW06IEJveFBsb3REYXRhUm93O1xuICBjb2xvcjogc3RyaW5nO1xuICBlbmNvZGVyOiBCb3hQbG90RW5jb2Rlcjtcbn1cblxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBjbGFzc05hbWU6ICcnLFxuICBtYXJnaW46IERFRkFVTFRfTUFSR0lOLFxuICBlbmNvZGluZzoge30sXG4gIHRoZW1lOiBjaGFydFRoZW1lLFxuICBUb29sdGlwUmVuZGVyZXI6IERlZmF1bHRUb29sdGlwUmVuZGVyZXIsXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgdHlwZSBIb29rUHJvcHMgPSB7XG4gIFRvb2x0aXBSZW5kZXJlcj86IFJlYWN0LkNvbXBvbmVudFR5cGU8VG9vbHRpcFByb3BzPjtcbn0gJiBMZWdlbmRIb29rczxCb3hQbG90RW5jb2RpbmdDb25maWc+O1xuXG50eXBlIFByb3BzID0ge1xuICBjbGFzc05hbWU/OiBzdHJpbmc7XG4gIHdpZHRoOiBzdHJpbmcgfCBudW1iZXI7XG4gIGhlaWdodDogc3RyaW5nIHwgbnVtYmVyO1xuICBtYXJnaW4/OiBNYXJnaW47XG4gIGVuY29kaW5nPzogUGFydGlhbDxCb3hQbG90RW5jb2Rpbmc+O1xuICBkYXRhOiBEYXRhc2V0O1xuICB0aGVtZT86IENoYXJ0VGhlbWU7XG59ICYgSG9va1Byb3BzICZcbiAgUmVhZG9ubHk8dHlwZW9mIGRlZmF1bHRQcm9wcz47XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJveFBsb3QgZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50PFByb3BzPiB7XG4gIHByaXZhdGUgY3JlYXRlRW5jb2RlciA9IGJveFBsb3RFbmNvZGVyRmFjdG9yeS5jcmVhdGVTZWxlY3RvcigpO1xuXG4gIHByaXZhdGUgY3JlYXRlTWFyZ2luID0gY3JlYXRlTWFyZ2luU2VsZWN0b3IoKTtcblxuICBzdGF0aWMgZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuXG4gIHJlbmRlckNoYXJ0ID0gKGRpbTogRGltZW5zaW9uKSA9PiB7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBkaW07XG4gICAgY29uc3QgeyBkYXRhLCBtYXJnaW4sIHRoZW1lLCBUb29sdGlwUmVuZGVyZXIsIGVuY29kaW5nIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGVuY29kZXIgPSB0aGlzLmNyZWF0ZUVuY29kZXIoZW5jb2RpbmcpO1xuICAgIGNvbnN0IHsgY2hhbm5lbHMgfSA9IGVuY29kZXI7XG5cbiAgICBjb25zdCBpc0hvcml6b250YWwgPVxuICAgICAgaXNGaWVsZERlZihjaGFubmVscy55LmRlZmluaXRpb24pICYmIGNoYW5uZWxzLnkuZGVmaW5pdGlvbi50eXBlID09PSAnbm9taW5hbCc7XG5cbiAgICBlbmNvZGVyLnNldERvbWFpbkZyb21EYXRhc2V0KGRhdGEpO1xuXG4gICAgY29uc3QgbGF5b3V0ID0gY3JlYXRlWFlDaGFydExheW91dFdpdGhUaGVtZSh7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIG1hcmdpbjogdGhpcy5jcmVhdGVNYXJnaW4obWFyZ2luKSxcbiAgICAgIHRoZW1lLFxuICAgICAgeEVuY29kZXI6IGNoYW5uZWxzLngsXG4gICAgICB5RW5jb2RlcjogY2hhbm5lbHMueSxcbiAgICB9KTtcblxuICAgIHJldHVybiBsYXlvdXQucmVuZGVyQ2hhcnRXaXRoRnJhbWUoKGNoYXJ0RGltOiBEaW1lbnNpb24pID0+IChcbiAgICAgIDxYWUNoYXJ0XG4gICAgICAgIHNob3dZR3JpZFxuICAgICAgICB3aWR0aD17Y2hhcnREaW0ud2lkdGh9XG4gICAgICAgIGhlaWdodD17Y2hhcnREaW0uaGVpZ2h0fVxuICAgICAgICBhcmlhTGFiZWw9XCJCb3hQbG90XCJcbiAgICAgICAgbWFyZ2luPXtsYXlvdXQubWFyZ2lufVxuICAgICAgICByZW5kZXJUb29sdGlwPXsoeyBkYXR1bSwgY29sb3IgfTogeyBkYXR1bTogQm94UGxvdERhdGFSb3c7IGNvbG9yOiBzdHJpbmcgfSkgPT4gKFxuICAgICAgICAgIDxUb29sdGlwUmVuZGVyZXIgZGF0dW09e2RhdHVtfSBjb2xvcj17Y29sb3J9IGVuY29kZXI9e2VuY29kZXJ9IC8+XG4gICAgICAgICl9XG4gICAgICAgIHRoZW1lPXt0aGVtZX1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgeFNjYWxlPXtjb252ZXJ0U2NhbGVUb0RhdGFVSVNjYWxlKGNoYW5uZWxzLnguZGVmaW5pdGlvbi5zY2FsZSBhcyBhbnkpfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICB5U2NhbGU9e2NvbnZlcnRTY2FsZVRvRGF0YVVJU2NhbGUoY2hhbm5lbHMueS5kZWZpbml0aW9uLnNjYWxlIGFzIGFueSl9XG4gICAgICA+XG4gICAgICAgIHtsYXlvdXQucmVuZGVyWEF4aXMoKX1cbiAgICAgICAge2xheW91dC5yZW5kZXJZQXhpcygpfVxuICAgICAgICA8Qm94UGxvdFNlcmllc1xuICAgICAgICAgIGtleT17aXNGaWVsZERlZihjaGFubmVscy54LmRlZmluaXRpb24pID8gY2hhbm5lbHMueC5kZWZpbml0aW9uLmZpZWxkIDogJyd9XG4gICAgICAgICAgYW5pbWF0ZWRcbiAgICAgICAgICBkYXRhPXtcbiAgICAgICAgICAgIGlzSG9yaXpvbnRhbFxuICAgICAgICAgICAgICA/IGRhdGEubWFwKHJvdyA9PiAoeyAuLi5yb3csIHk6IGNoYW5uZWxzLnkuZ2V0VmFsdWVGcm9tRGF0dW0ocm93KSB9KSlcbiAgICAgICAgICAgICAgOiBkYXRhLm1hcChyb3cgPT4gKHsgLi4ucm93LCB4OiBjaGFubmVscy54LmdldFZhbHVlRnJvbURhdHVtKHJvdykgfSkpXG4gICAgICAgICAgfVxuICAgICAgICAgIGZpbGw9eyhkYXR1bTogUGxhaW5PYmplY3QpID0+IGNoYW5uZWxzLmNvbG9yLmVuY29kZURhdHVtKGRhdHVtLCAnIzU1YWNlZScpfVxuICAgICAgICAgIGZpbGxPcGFjaXR5PXswLjR9XG4gICAgICAgICAgc3Ryb2tlPXsoZGF0dW06IFBsYWluT2JqZWN0KSA9PiBjaGFubmVscy5jb2xvci5lbmNvZGVEYXR1bShkYXR1bSl9XG4gICAgICAgICAgc3Ryb2tlV2lkdGg9ezF9XG4gICAgICAgICAgd2lkdGhSYXRpbz17MC42fVxuICAgICAgICAgIGhvcml6b250YWw9e2lzSG9yaXpvbnRhbH1cbiAgICAgICAgLz5cbiAgICAgIDwvWFlDaGFydD5cbiAgICApKTtcbiAgfTtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBjbGFzc05hbWUsIGRhdGEsIGVuY29kaW5nLCB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzLnByb3BzO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxXaXRoTGVnZW5kXG4gICAgICAgIGNsYXNzTmFtZT17YHN1cGVyc2V0LWNoYXJ0LWJveC1wbG90ICR7Y2xhc3NOYW1lfWB9XG4gICAgICAgIHdpZHRoPXt3aWR0aH1cbiAgICAgICAgaGVpZ2h0PXtoZWlnaHR9XG4gICAgICAgIHBvc2l0aW9uPVwidG9wXCJcbiAgICAgICAgcmVuZGVyTGVnZW5kPXtjcmVhdGVSZW5kZXJMZWdlbmQodGhpcy5jcmVhdGVFbmNvZGVyKGVuY29kaW5nKSwgZGF0YSwgdGhpcy5wcm9wcyl9XG4gICAgICAgIHJlbmRlckNoYXJ0PXt0aGlzLnJlbmRlckNoYXJ0fVxuICAgICAgLz5cbiAgICApO1xuICB9XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNuR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDSkE7QUFDQTtBQUNBOzs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZGQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUlBO0FBQ0E7QUFJQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFPQTtBQUNBO0FBR0E7QUFDQTtBQU9BO0FBQ0E7QUFHQTs7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDdE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25kQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hOQTtBQUNBO0FBSUE7QUFTQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFHQTs7Ozs7O0FDaERBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUVBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaUJBO0FBQUE7O0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBV0E7QUFnQkE7QUFkQTtBQUNBO0FBRUE7QUFVQTs7QUF4RUE7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2391\n')}}]);