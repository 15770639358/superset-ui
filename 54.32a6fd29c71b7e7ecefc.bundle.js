(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{2508:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, "default", function() { return /* binding */ TableChart; });\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react/index.js\nvar react = __webpack_require__(0);\nvar react_default = /*#__PURE__*/__webpack_require__.n(react);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/node_modules/d3-array/src/max.js\nvar max = __webpack_require__(2500);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/node_modules/d3-array/src/extent.js\nvar extent = __webpack_require__(2501);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react-icons/fa/index.esm.js + 4 modules\nvar index_esm = __webpack_require__(2457);\n\n// EXTERNAL MODULE: ../superset-ui-core/src/query/types/QueryResponse.ts\nvar QueryResponse = __webpack_require__(328);\n\n// EXTERNAL MODULE: ../superset-ui-core/src/translation/TranslatorSingleton.ts + 1 modules\nvar TranslatorSingleton = __webpack_require__(15);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react-table/index.js\nvar react_table = __webpack_require__(2235);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/match-sorter/dist/match-sorter.esm.js\nvar match_sorter_esm = __webpack_require__(2449);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/regenerator-runtime/runtime.js\nvar runtime = __webpack_require__(292);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/DataTable/utils/useAsyncState.ts\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\n// useAsyncDebounce in dist build of `react-table` requires regeneratorRuntime\n\n/**\n * Hook useState to allow always return latest initialValue\n */\nfunction useAsyncState(initialValue, callback, wait = 200) {\n    const [value, setValue] = Object(react["useState"])(initialValue);\n    const valueRef = Object(react["useRef"])(initialValue);\n    const onChange = Object(react_table["useAsyncDebounce"])(callback, wait);\n    // sync updated initialValue\n    if (valueRef.current !== initialValue) {\n        valueRef.current = initialValue;\n        if (value !== initialValue) {\n            setValue(initialValue);\n        }\n    }\n    const setBoth = (newValue) => {\n        setValue(newValue);\n        onChange(newValue);\n    };\n    return [value, setBoth];\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/DataTable/components/GlobalFilter.tsx\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\nfunction DefaultSearchInput({ count, value, onChange }) {\n    return (react_default.a.createElement("span", { className: "dt-global-filter" },\n        "Search",\n        \' \',\n        react_default.a.createElement("input", { className: "form-control input-sm", placeholder: `${count} records...`, value: value, onChange: onChange })));\n}\n/* harmony default export */ var components_GlobalFilter = (react_default.a.memo(function GlobalFilter({ preGlobalFilteredRows, filterValue = \'\', searchInput, setGlobalFilter, }) {\n    const count = preGlobalFilteredRows.length;\n    const [value, setValue] = useAsyncState(filterValue, (newValue) => {\n        setGlobalFilter(newValue || undefined);\n    }, 200);\n    const SearchInput = searchInput || DefaultSearchInput;\n    return (react_default.a.createElement(SearchInput, { count: count, value: value, onChange: e => {\n            const target = e.target;\n            e.preventDefault();\n            setValue(target.value);\n        } }));\n}));\n\n// EXTERNAL MODULE: ../superset-ui-chart-controls/src/utils/selectOptions.ts\nvar selectOptions = __webpack_require__(166);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/DataTable/components/SelectPageSize.tsx\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\nfunction DefaultSelectRenderer({ current, options, onChange }) {\n    return (react_default.a.createElement("span", { className: "dt-select-page-size form-inline" },\n        "Show",\n        \' \',\n        react_default.a.createElement("select", { className: "form-control input-sm", value: current, onBlur: () => { }, onChange: e => {\n                onChange(Number(e.target.value));\n            } }, options.map(option => {\n            const [size, text] = Array.isArray(option) ? option : [option, option];\n            return (react_default.a.createElement("option", { key: size, value: size }, text));\n        })),\n        \' \',\n        "entries"));\n}\nfunction getOptionValue(x) {\n    return Array.isArray(x) ? x[0] : x;\n}\n/* harmony default export */ var components_SelectPageSize = (react_default.a.memo(function SelectPageSize({ total, options: sizeOptions, current: currentSize, selectRenderer, onChange, }) {\n    const sizeOptionValues = sizeOptions.map(getOptionValue);\n    let options = [...sizeOptions];\n    // insert current size to list\n    if (currentSize !== undefined &&\n        (currentSize !== total || !sizeOptionValues.includes(0)) &&\n        !sizeOptionValues.includes(currentSize)) {\n        options = [...sizeOptions];\n        options.splice(sizeOptionValues.findIndex(x => x > currentSize), 0, Object(selectOptions["a" /* formatSelectOptions */])([currentSize])[0]);\n    }\n    const current = currentSize === undefined ? sizeOptionValues[0] : currentSize;\n    const SelectRenderer = selectRenderer || DefaultSelectRenderer;\n    return react_default.a.createElement(SelectRenderer, { current: current, options: options, onChange: onChange });\n}));\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/DataTable/components/Pagination.tsx\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n// first, ..., prev, current, next, ..., last\nconst MINIMAL_PAGE_ITEM_COUNT = 7;\n/**\n * Generate numeric page items around current page.\n *   - Always include first and last page\n *   - Add ellipsis if needed\n */\nfunction generatePageItems(total, current, width) {\n    if (width < MINIMAL_PAGE_ITEM_COUNT) {\n        throw new Error(`Must allow at least ${MINIMAL_PAGE_ITEM_COUNT} page items`);\n    }\n    if (width % 2 === 0) {\n        throw new Error(`Must allow odd number of page items`);\n    }\n    if (total < width) {\n        return [...new Array(total).keys()];\n    }\n    const left = Math.max(0, Math.min(total - width, current - Math.floor(width / 2)));\n    const items = new Array(width);\n    for (let i = 0; i < width; i += 1) {\n        items[i] = i + left;\n    }\n    // replace non-ending items with placeholders\n    if (items[0] > 0) {\n        items[0] = 0;\n        items[1] = \'prev-more\';\n    }\n    if (items[items.length - 1] < total - 1) {\n        items[items.length - 1] = total - 1;\n        items[items.length - 2] = \'next-more\';\n    }\n    return items;\n}\n/* harmony default export */ var components_Pagination = (react_default.a.memo(react_default.a.forwardRef(function Pagination({ style, pageCount, currentPage = 0, maxPageItemCount = 9, onPageChange }, ref) {\n    const pageItems = generatePageItems(pageCount, currentPage, maxPageItemCount);\n    return (react_default.a.createElement("div", { ref: ref, className: "dt-pagination", style: style },\n        react_default.a.createElement("ul", { className: "pagination pagination-sm" }, pageItems.map(item => typeof item === \'number\' ? (\n        // actual page number\n        react_default.a.createElement("li", { key: item, className: currentPage === item ? \'active\' : undefined },\n            react_default.a.createElement("a", { href: `#page-${item}`, role: "button", onClick: e => {\n                    e.preventDefault();\n                    onPageChange(item);\n                } }, item + 1))) : (react_default.a.createElement("li", { key: item, className: "dt-pagination-ellipsis" },\n            react_default.a.createElement("span", null, "\\u2026")))))));\n})));\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/DataTable/utils/getScrollBarSize.ts\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nlet cached;\nconst css = (x) => x.join(\'\\n\');\nfunction getScrollBarSize(forceRefresh = false) {\n    if (typeof document === \'undefined\') {\n        return 0;\n    }\n    if (cached === undefined || forceRefresh) {\n        const inner = document.createElement(\'div\');\n        const outer = document.createElement(\'div\');\n        inner.style.cssText = css `\n      width: auto;\n      height: 100%;\n      overflow: scroll;\n    `;\n        outer.style.cssText = css `\n      position: absolute;\n      visibility: hidden;\n      overflow: hidden;\n      width: 100px;\n      height: 50px;\n    `;\n        outer.append(inner);\n        document.body.append(outer);\n        cached = outer.clientWidth - inner.clientWidth;\n        outer.remove();\n    }\n    return cached;\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/DataTable/utils/needScrollBar.ts\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/**\n * Whether a container need scroll bars when in another container.\n */\nfunction needScrollBar({ width, height, innerHeight, innerWidth, scrollBarSize, }) {\n    const hasVerticalScroll = innerHeight > height;\n    const hasHorizontalScroll = innerWidth > width - (hasVerticalScroll ? scrollBarSize : 0);\n    return [hasVerticalScroll, hasHorizontalScroll];\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/DataTable/utils/useMountedMemo.ts\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n/**\n * Execute a memoized callback only when mounted. Execute again when factory updated.\n * Returns undefined if not mounted yet.\n */\nfunction useMountedMemo(factory, deps) {\n    const mounted = Object(react["useRef"])();\n    Object(react["useLayoutEffect"])(() => {\n        mounted.current = factory;\n    });\n    return Object(react["useMemo"])(() => {\n        if (mounted.current) {\n            return factory();\n        }\n        return undefined;\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [mounted.current, mounted.current === factory, ...(deps || [])]);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/DataTable/hooks/useSticky.tsx\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\n\n\nvar ReducerActions;\n(function (ReducerActions) {\n    ReducerActions["init"] = "init";\n    ReducerActions["setStickyState"] = "setStickyState";\n})(ReducerActions || (ReducerActions = {}));\nconst sum = (a, b) => a + b;\nconst mergeStyleProp = (node, style) => ({\n    style: Object.assign(Object.assign({}, node.props.style), style),\n});\n/**\n * An HOC for generating sticky header and fixed-height scrollable area\n */\nfunction StickyWrap({ sticky = {}, width: maxWidth, height: maxHeight, children: table, setStickyState, }) {\n    if (!table || table.type !== \'table\') {\n        throw new Error(\'<StickyWrap> must have only one <table> element as child\');\n    }\n    let thead;\n    let tbody;\n    let colgroup;\n    react_default.a.Children.forEach(table.props.children, node => {\n        if (node.type === \'thead\') {\n            thead = node;\n        }\n        else if (node.type === \'tbody\') {\n            tbody = node;\n        }\n        else if (node.type === \'colgroup\') {\n            colgroup = node;\n        }\n    });\n    if (!thead || !tbody) {\n        throw new Error(\'<table> in <StickyWrap> must contain both thead and tbody.\');\n    }\n    const columnCount = Object(react["useMemo"])(() => {\n        const headerRows = react_default.a.Children.toArray(thead === null || thead === void 0 ? void 0 : thead.props.children).pop();\n        return headerRows.props.children.length;\n    }, [thead]);\n    const theadRef = Object(react["useRef"])(null); // original thead for layout computation\n    const scrollHeaderRef = Object(react["useRef"])(null); // fixed header\n    const scrollBodyRef = Object(react["useRef"])(null); // main body\n    const { bodyHeight, columnWidths } = sticky;\n    const needSizer = !columnWidths ||\n        sticky.width !== maxWidth ||\n        sticky.height !== maxHeight ||\n        sticky.setStickyState !== setStickyState;\n    const scrollBarSize = getScrollBarSize();\n    // update scrollable area and header column sizes when mounted\n    Object(react["useLayoutEffect"])(() => {\n        if (theadRef.current) {\n            const bodyThead = theadRef.current;\n            const theadHeight = bodyThead.clientHeight;\n            if (!theadHeight) {\n                return;\n            }\n            const fullTableHeight = bodyThead.parentNode.clientHeight;\n            const ths = bodyThead.childNodes[0].childNodes;\n            const widths = Array.from(ths).map(th => th.clientWidth);\n            const [hasVerticalScroll, hasHorizontalScroll] = needScrollBar({\n                width: maxWidth,\n                height: maxHeight - theadHeight,\n                innerHeight: fullTableHeight,\n                innerWidth: widths.reduce(sum),\n                scrollBarSize,\n            });\n            // real container height, include table header and space for\n            // horizontal scroll bar\n            const realHeight = Math.min(maxHeight, hasHorizontalScroll ? fullTableHeight + scrollBarSize : fullTableHeight);\n            setStickyState({\n                hasVerticalScroll,\n                hasHorizontalScroll,\n                setStickyState,\n                width: maxWidth,\n                height: maxHeight,\n                realHeight,\n                tableHeight: fullTableHeight,\n                bodyHeight: realHeight - theadHeight,\n                columnWidths: widths,\n            });\n        }\n    }, [maxWidth, maxHeight, setStickyState, scrollBarSize]);\n    let sizerTable;\n    let headerTable;\n    let bodyTable;\n    if (needSizer) {\n        const theadWithRef = react_default.a.cloneElement(thead, { ref: theadRef });\n        sizerTable = (react_default.a.createElement("div", { key: "sizer", style: {\n                height: maxHeight,\n                overflow: \'auto\',\n                visibility: \'hidden\',\n            } }, react_default.a.cloneElement(table, {}, colgroup, theadWithRef, tbody)));\n    }\n    // reuse previously column widths, will be updated by `useLayoutEffect` above\n    const colWidths = columnWidths === null || columnWidths === void 0 ? void 0 : columnWidths.slice(0, columnCount);\n    if (colWidths && bodyHeight) {\n        const tableStyle = { tableLayout: \'fixed\' };\n        const bodyCols = colWidths.map((w, i) => (\n        // eslint-disable-next-line react/no-array-index-key\n        react_default.a.createElement("col", { key: i, width: w })));\n        const bodyColgroup = react_default.a.createElement("colgroup", null, bodyCols);\n        // header columns do not have vertical scroll bars,\n        // so we add scroll bar size to the last column\n        const headerColgroup = sticky.hasVerticalScroll && scrollBarSize ? (react_default.a.createElement("colgroup", null, colWidths.map((x, i) => (\n        // eslint-disable-next-line react/no-array-index-key\n        react_default.a.createElement("col", { key: i, width: x + (i === colWidths.length - 1 ? scrollBarSize : 0) }))))) : (bodyColgroup);\n        headerTable = (react_default.a.createElement("div", { key: "header", ref: scrollHeaderRef, style: {\n                overflow: \'hidden\',\n            } },\n            react_default.a.cloneElement(table, mergeStyleProp(table, tableStyle), headerColgroup, thead),\n            headerTable));\n        const onScroll = e => {\n            if (scrollHeaderRef.current) {\n                scrollHeaderRef.current.scrollLeft = e.currentTarget.scrollLeft;\n            }\n        };\n        bodyTable = (react_default.a.createElement("div", { key: "body", ref: scrollBodyRef, style: {\n                height: bodyHeight,\n                overflow: \'auto\',\n            }, onScroll: sticky.hasHorizontalScroll ? onScroll : undefined }, react_default.a.cloneElement(table, mergeStyleProp(table, tableStyle), bodyColgroup, tbody)));\n    }\n    return (react_default.a.createElement("div", { style: {\n            width: maxWidth,\n            height: sticky.realHeight || maxHeight,\n            overflow: \'hidden\',\n        } },\n        headerTable,\n        bodyTable,\n        sizerTable));\n}\nfunction useInstance(instance) {\n    const { dispatch, state: { sticky }, data, page, rows, getTableSize = () => undefined, } = instance;\n    const setStickyState = Object(react["useCallback"])((size) => {\n        dispatch({\n            type: ReducerActions.setStickyState,\n            size,\n        });\n    }, \n    // turning pages would also trigger a resize\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [dispatch, getTableSize, page, rows]);\n    const useStickyWrap = (renderer) => {\n        const { width, height } = useMountedMemo(getTableSize, [getTableSize]) || sticky;\n        // only change of data should trigger re-render\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        const table = Object(react["useMemo"])(renderer, [page, rows]);\n        Object(react["useLayoutEffect"])(() => {\n            if (!width || !height) {\n                setStickyState();\n            }\n        }, [width, height]);\n        if (!width || !height) {\n            return null;\n        }\n        if (data.length === 0) {\n            return table;\n        }\n        return (react_default.a.createElement(StickyWrap, { width: width, height: height, sticky: sticky, setStickyState: setStickyState }, table));\n    };\n    Object.assign(instance, {\n        setStickyState,\n        wrapStickyTable: useStickyWrap,\n    });\n}\nfunction useSticky(hooks) {\n    hooks.useInstance.push(useInstance);\n    hooks.stateReducers.push((newState, action_) => {\n        const action = action_;\n        if (action.type === ReducerActions.init) {\n            return Object.assign(Object.assign({}, newState), { sticky: newState.sticky || {} });\n        }\n        if (action.type === ReducerActions.setStickyState) {\n            const { size } = action;\n            if (!size) {\n                return Object.assign({}, newState);\n            }\n            return Object.assign(Object.assign({}, newState), { sticky: Object.assign(Object.assign({}, newState.sticky), action.size) });\n        }\n        return newState;\n    });\n}\nuseSticky.pluginName = \'useSticky\';\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/consts.ts\nvar consts = __webpack_require__(551);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/DataTable/DataTable.tsx\nvar __rest = (undefined && undefined.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === "function")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\n\n\n\n\n\n\n// Be sure to pass our updateMyData and the skipReset option\nfunction DataTable(_a) {\n    var _b, _c;\n    var { tableClassName, columns, data, serverPaginationData, width: initialWidth = \'100%\', height: initialHeight = 300, pageSize: initialPageSize = 0, initialState: initialState_ = {}, pageSizeOptions = consts["a" /* PAGE_SIZE_OPTIONS */], maxPageItemCount = 9, sticky: doSticky, searchInput = true, onServerPaginationChange, rowCount, selectPageSize, noResults: noResultsText = \'No data found\', hooks, serverPagination, wrapperRef: userWrapperRef } = _a, moreUseTableOptions = __rest(_a, ["tableClassName", "columns", "data", "serverPaginationData", "width", "height", "pageSize", "initialState", "pageSizeOptions", "maxPageItemCount", "sticky", "searchInput", "onServerPaginationChange", "rowCount", "selectPageSize", "noResults", "hooks", "serverPagination", "wrapperRef"]);\n    const tableHooks = [\n        react_table["useGlobalFilter"],\n        react_table["useSortBy"],\n        react_table["usePagination"],\n        doSticky ? useSticky : [],\n        hooks || [],\n    ].flat();\n    const resultsSize = serverPagination ? rowCount : data.length;\n    const sortByRef = Object(react["useRef"])([]); // cache initial `sortby` so sorting doesn\'t trigger page reset\n    const pageSizeRef = Object(react["useRef"])([initialPageSize, resultsSize]);\n    const hasPagination = initialPageSize > 0 && resultsSize > 0; // pageSize == 0 means no pagination\n    const hasGlobalControl = hasPagination || !!searchInput;\n    const initialState = Object.assign(Object.assign({}, initialState_), { \n        // zero length means all pages, the `usePagination` plugin does not\n        // understand pageSize = 0\n        sortBy: sortByRef.current, pageSize: initialPageSize > 0 ? initialPageSize : resultsSize || 10 });\n    const defaultWrapperRef = Object(react["useRef"])(null);\n    const globalControlRef = Object(react["useRef"])(null);\n    const paginationRef = Object(react["useRef"])(null);\n    const wrapperRef = userWrapperRef || defaultWrapperRef;\n    const defaultGetTableSize = Object(react["useCallback"])(() => {\n        var _a, _b;\n        if (wrapperRef.current) {\n            // `initialWidth` and `initialHeight` could be also parameters like `100%`\n            // `Number` reaturns `NaN` on them, then we fallback to computed size\n            const width = Number(initialWidth) || wrapperRef.current.clientWidth;\n            const height = (Number(initialHeight) || wrapperRef.current.clientHeight) -\n                (((_a = globalControlRef.current) === null || _a === void 0 ? void 0 : _a.clientHeight) || 0) -\n                (((_b = paginationRef.current) === null || _b === void 0 ? void 0 : _b.clientHeight) || 0);\n            return { width, height };\n        }\n        return undefined;\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        initialHeight,\n        initialWidth,\n        wrapperRef,\n        hasPagination,\n        hasGlobalControl,\n        paginationRef,\n        resultsSize,\n        JSON.stringify(serverPaginationData),\n    ]);\n    const defaultGlobalFilter = Object(react["useCallback"])((rows, columnIds, filterValue) => {\n        // allow searching by "col1_value col2_value"\n        const joinedString = (row) => columnIds.map(x => row.values[x]).join(\' \');\n        return Object(match_sorter_esm["a" /* matchSorter */])(rows, filterValue, {\n            keys: [...columnIds, joinedString],\n            threshold: match_sorter_esm["b" /* rankings */].ACRONYM,\n        });\n    }, []);\n    const { getTableProps, getTableBodyProps, prepareRow, headerGroups, page, pageCount, gotoPage, preGlobalFilteredRows, setGlobalFilter, setPageSize: setPageSize_, wrapStickyTable, state: { pageIndex, pageSize, globalFilter: filterValue, sticky = {} }, } = Object(react_table["useTable"])(Object.assign({ columns,\n        data,\n        initialState, getTableSize: defaultGetTableSize, globalFilter: defaultGlobalFilter }, moreUseTableOptions), ...tableHooks);\n    // make setPageSize accept 0\n    const setPageSize = (size) => {\n        if (serverPagination) {\n            onServerPaginationChange(0, size);\n        }\n        // keep the original size if data is empty\n        if (size || resultsSize !== 0) {\n            setPageSize_(size === 0 ? resultsSize : size);\n        }\n    };\n    const noResults = typeof noResultsText === \'function\' ? noResultsText(filterValue) : noResultsText;\n    const getNoResults = () => react_default.a.createElement("div", { className: "dt-no-results" }, noResults);\n    if (!columns || columns.length === 0) {\n        return (wrapStickyTable ? wrapStickyTable(getNoResults) : getNoResults());\n    }\n    const renderTable = () => (react_default.a.createElement("table", Object.assign({}, getTableProps({ className: tableClassName })),\n        react_default.a.createElement("thead", null, headerGroups.map(headerGroup => {\n            const _a = headerGroup.getHeaderGroupProps(), { key: headerGroupKey } = _a, headerGroupProps = __rest(_a, ["key"]);\n            return (react_default.a.createElement("tr", Object.assign({ key: headerGroupKey || headerGroup.id }, headerGroupProps), headerGroup.headers.map(column => column.render(\'Header\', Object.assign({ key: column.id }, column.getSortByToggleProps())))));\n        })),\n        react_default.a.createElement("tbody", Object.assign({}, getTableBodyProps()), page && page.length > 0 ? (page.map(row => {\n            prepareRow(row);\n            const _a = row.getRowProps(), { key: rowKey } = _a, rowProps = __rest(_a, ["key"]);\n            return (react_default.a.createElement("tr", Object.assign({ key: rowKey || row.id }, rowProps), row.cells.map(cell => cell.render(\'Cell\', { key: cell.column.id }))));\n        })) : (react_default.a.createElement("tr", null,\n            react_default.a.createElement("td", { className: "dt-no-results", colSpan: columns.length }, noResults))))));\n    // force update the pageSize when it\'s been update from the initial state\n    if (pageSizeRef.current[0] !== initialPageSize ||\n        // when initialPageSize stays as zero, but total number of records changed,\n        // we\'d also need to update page size\n        (initialPageSize === 0 && pageSizeRef.current[1] !== resultsSize)) {\n        pageSizeRef.current = [initialPageSize, resultsSize];\n        setPageSize(initialPageSize);\n    }\n    const paginationStyle = sticky.height ? {} : { visibility: \'hidden\' };\n    let resultPageCount = pageCount;\n    let resultCurrentPageSize = pageSize;\n    let resultCurrentPage = pageIndex;\n    let resultOnPageChange = gotoPage;\n    if (serverPagination) {\n        const serverPageSize = (_b = serverPaginationData.pageSize) !== null && _b !== void 0 ? _b : initialPageSize;\n        resultPageCount = Math.ceil(rowCount / serverPageSize);\n        if (!Number.isFinite(resultPageCount)) {\n            resultPageCount = 0;\n        }\n        resultCurrentPageSize = serverPageSize;\n        const foundPageSizeIndex = pageSizeOptions.findIndex(([option]) => option >= resultCurrentPageSize);\n        if (foundPageSizeIndex === -1) {\n            resultCurrentPageSize = 0;\n        }\n        resultCurrentPage = (_c = serverPaginationData.currentPage) !== null && _c !== void 0 ? _c : 0;\n        resultOnPageChange = (pageNumber) => onServerPaginationChange(pageNumber, serverPageSize);\n    }\n    return (react_default.a.createElement("div", { ref: wrapperRef, style: { width: initialWidth, height: initialHeight } },\n        hasGlobalControl ? (react_default.a.createElement("div", { ref: globalControlRef, className: "form-inline dt-controls" },\n            react_default.a.createElement("div", { className: "row" },\n                react_default.a.createElement("div", { className: "col-sm-6" }, hasPagination ? (react_default.a.createElement(components_SelectPageSize, { total: resultsSize, current: resultCurrentPageSize, options: pageSizeOptions, selectRenderer: typeof selectPageSize === \'boolean\' ? undefined : selectPageSize, onChange: setPageSize })) : null),\n                searchInput ? (react_default.a.createElement("div", { className: "col-sm-6" },\n                    react_default.a.createElement(components_GlobalFilter, { searchInput: typeof searchInput === \'boolean\' ? undefined : searchInput, preGlobalFilteredRows: preGlobalFilteredRows, setGlobalFilter: setGlobalFilter, filterValue: filterValue }))) : null))) : null,\n        wrapStickyTable ? wrapStickyTable(renderTable) : renderTable(),\n        hasPagination && resultPageCount > 1 ? (react_default.a.createElement(components_Pagination, { ref: paginationRef, style: paginationStyle, maxPageItemCount: maxPageItemCount, pageCount: resultPageCount, currentPage: resultCurrentPage, onPageChange: resultOnPageChange })) : null));\n}\n\n// EXTERNAL MODULE: ../superset-ui-core/src/style/index.ts\nvar src_style = __webpack_require__(434);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/Styles.tsx\n\n/* harmony default export */ var Styles = (src_style["c" /* styled */].div `\n  table {\n    width: 100%;\n    min-width: auto;\n    max-width: none;\n    margin: 0;\n  }\n\n  th,\n  td {\n    min-width: 4.3em;\n  }\n\n  thead > tr > th {\n    padding-right: 1.4em;\n    position: relative;\n    background: #fff;\n  }\n  th svg {\n    color: #ccc;\n    position: absolute;\n    bottom: 0.6em;\n    right: 0.2em;\n  }\n  th.is-sorted svg {\n    color: #a8a8a8;\n  }\n  .table > tbody > tr:first-of-type > td,\n  .table > tbody > tr:first-of-type > th {\n    border-top: 0;\n  }\n\n  .dt-controls {\n    padding-bottom: 0.65em;\n  }\n  .dt-metric {\n    text-align: right;\n  }\n  .dt-is-null {\n    color: ${({ theme: { colors } }) => colors.grayscale.light1};\n  }\n  td.dt-is-filter {\n    cursor: pointer;\n  }\n  td.dt-is-filter:hover {\n    background-color: linen;\n  }\n  td.dt-is-active-filter,\n  td.dt-is-active-filter:hover {\n    background-color: lightcyan;\n  }\n\n  .dt-global-filter {\n    float: right;\n  }\n\n  .dt-pagination {\n    text-align: right;\n    /* use padding instead of margin so clientHeight can capture it */\n    padding-top: 0.5em;\n  }\n  .dt-pagination .pagination {\n    margin: 0;\n  }\n\n  .pagination > li > span.dt-pagination-ellipsis:focus,\n  .pagination > li > span.dt-pagination-ellipsis:hover {\n    background: #fff;\n  }\n\n  .dt-no-results {\n    text-align: center;\n    padding: 1em 0.6em;\n  }\n`);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/xss/lib/index.js\nvar lib = __webpack_require__(2444);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/utils/formatValue.ts\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nconst xss = new lib["FilterXSS"]({\n    whiteList: Object.assign(Object.assign({}, Object(lib["getDefaultWhiteList"])()), { span: [\'style\', \'class\', \'title\'], div: [\'style\', \'class\'], a: [\'style\', \'class\', \'href\', \'title\', \'target\'], img: [\'style\', \'class\', \'src\', \'alt\', \'title\', \'width\', \'height\'] }),\n    stripIgnoreTag: true,\n    css: false,\n});\nfunction isProbablyHTML(text) {\n    return /<[^>]+>/.test(text);\n}\n/**\n * Format text for cell value.\n */\nfunction formatValue({ formatter }, value) {\n    if (value === null) {\n        return [false, \'N/A\', \'dt-is-null\'];\n    }\n    if (formatter) {\n        // in case percent metric can specify percent format in the future\n        return [false, formatter(value), null];\n    }\n    if (typeof value === \'string\') {\n        return isProbablyHTML(value) ? [true, xss.process(value), null] : [false, value, null];\n    }\n    return [false, value.toString(), null];\n}\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/DataTable/utils/externalAPIs.ts\nvar externalAPIs = __webpack_require__(1048);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/TableChart.tsx\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\n\n\n\n\n\n\n\n/**\n * Return sortType based on data type\n */\nfunction getSortTypeByDataType(dataType) {\n    if (dataType === QueryResponse["a" /* GenericDataType */].TEMPORAL) {\n        return \'datetime\';\n    }\n    if (dataType === QueryResponse["a" /* GenericDataType */].STRING) {\n        return \'alphanumeric\';\n    }\n    return \'basic\';\n}\n/**\n * Cell background to render columns as horizontal bar chart\n */\nfunction cellBar({ value, valueRange, colorPositiveNegative = false, alignPositiveNegative, }) {\n    const [minValue, maxValue] = valueRange;\n    const r = colorPositiveNegative && value < 0 ? 150 : 0;\n    if (alignPositiveNegative) {\n        const perc = Math.abs(Math.round((value / maxValue) * 100));\n        // The 0.01 to 0.001 is a workaround for what appears to be a\n        // CSS rendering bug on flat, transparent colors\n        return (`linear-gradient(to right, rgba(${r},0,0,0.2), rgba(${r},0,0,0.2) ${perc}%, ` +\n            `rgba(0,0,0,0.01) ${perc}%, rgba(0,0,0,0.001) 100%)`);\n    }\n    const posExtent = Math.abs(Math.max(maxValue, 0));\n    const negExtent = Math.abs(Math.min(minValue, 0));\n    const tot = posExtent + negExtent;\n    const perc1 = Math.round((Math.min(negExtent + value, negExtent) / tot) * 100);\n    const perc2 = Math.round((Math.abs(value) / tot) * 100);\n    // The 0.01 to 0.001 is a workaround for what appears to be a\n    // CSS rendering bug on flat, transparent colors\n    return (`linear-gradient(to right, rgba(0,0,0,0.01), rgba(0,0,0,0.001) ${perc1}%, ` +\n        `rgba(${r},0,0,0.2) ${perc1}%, rgba(${r},0,0,0.2) ${perc1 + perc2}%, ` +\n        `rgba(0,0,0,0.01) ${perc1 + perc2}%, rgba(0,0,0,0.001) 100%)`);\n}\nfunction SortIcon({ column }) {\n    const { isSorted, isSortedDesc } = column;\n    let sortIcon = react_default.a.createElement(index_esm["a" /* FaSort */], null);\n    if (isSorted) {\n        sortIcon = isSortedDesc ? react_default.a.createElement(index_esm["b" /* FaSortDown */], null) : react_default.a.createElement(index_esm["c" /* FaSortUp */], null);\n    }\n    return sortIcon;\n}\nfunction TableChart_SearchInput({ count, value, onChange }) {\n    return (react_default.a.createElement("span", { className: "dt-global-filter" },\n        Object(TranslatorSingleton["e" /* t */])(\'Search\'),\n        \' \',\n        react_default.a.createElement("input", { className: "form-control input-sm", placeholder: Object(TranslatorSingleton["f" /* tn */])(\'search.num_records\', count), value: value, onChange: onChange })));\n}\nfunction TableChart_SelectPageSize({ options, current, onChange }) {\n    return (react_default.a.createElement("span", { className: "dt-select-page-size form-inline" },\n        Object(TranslatorSingleton["e" /* t */])(\'page_size.show\'),\n        \' \',\n        react_default.a.createElement("select", { className: "form-control input-sm", value: current, onBlur: () => { }, onChange: e => {\n                onChange(Number(e.target.value));\n            } }, options.map(option => {\n            const [size, text] = Array.isArray(option) ? option : [option, option];\n            return (react_default.a.createElement("option", { key: size, value: size }, text));\n        })),\n        \' \',\n        Object(TranslatorSingleton["e" /* t */])(\'page_size.entries\')));\n}\nfunction TableChart(props) {\n    const { height, width, data, isRawRecords, rowCount = 0, columns: columnsMeta, alignPositiveNegative = false, colorPositiveNegative = false, includeSearch = false, pageSize = 0, serverPagination = false, serverPaginationData, setDataMask, showCellBars = true, emitFilter = false, sortDesc = false, onChangeFilter, filters: initialFilters, sticky = true, } = props;\n    const [filters, setFilters] = Object(react["useState"])(initialFilters);\n    // only take relevant page size options\n    const pageSizeOptions = Object(react["useMemo"])(() => {\n        const getServerPagination = (n) => n <= rowCount;\n        return consts["a" /* PAGE_SIZE_OPTIONS */].filter(([n]) => serverPagination ? getServerPagination(n) : n <= 2 * data.length);\n    }, [data.length, rowCount]);\n    const getValueRange = Object(react["useCallback"])(function getValueRange(key) {\n        var _a;\n        if (typeof ((_a = data === null || data === void 0 ? void 0 : data[0]) === null || _a === void 0 ? void 0 : _a[key]) === \'number\') {\n            const nums = data.map(row => row[key]);\n            return (alignPositiveNegative\n                ? [0, Object(max["a" /* default */])(nums.map(Math.abs))]\n                : Object(extent["a" /* default */])(nums));\n        }\n        return null;\n    }, [alignPositiveNegative, data]);\n    const isActiveFilterValue = Object(react["useCallback"])(function isActiveFilterValue(key, val) {\n        var _a;\n        return !!filters && ((_a = filters[key]) === null || _a === void 0 ? void 0 : _a.includes(val));\n    }, [filters]);\n    const toggleFilter = Object(react["useCallback"])(function toggleFilter(key, val) {\n        const updatedFilters = Object.assign({}, (filters || {}));\n        if (filters && isActiveFilterValue(key, val)) {\n            updatedFilters[key] = filters[key].filter((x) => x !== val);\n        }\n        else {\n            updatedFilters[key] = [...((filters === null || filters === void 0 ? void 0 : filters[key]) || []), val];\n        }\n        setFilters(updatedFilters);\n        if (onChangeFilter) {\n            onChangeFilter(updatedFilters);\n        }\n    }, [filters, isActiveFilterValue, onChangeFilter]);\n    const getColumnConfigs = Object(react["useCallback"])((column, i) => {\n        const { key, label, dataType, isMetric } = column;\n        let className = \'\';\n        if (dataType === QueryResponse["a" /* GenericDataType */].NUMERIC) {\n            className += \' dt-metric\';\n        }\n        else if (emitFilter) {\n            className += \' dt-is-filter\';\n        }\n        const valueRange = showCellBars && (isMetric || isRawRecords) && getValueRange(key);\n        return {\n            id: String(i),\n            // must use custom accessor to allow `.` in column names\n            // typing is incorrect in current version of `@types/react-table`\n            // so we ask TS not to check.\n            accessor: ((datum) => datum[key]),\n            Cell: ({ value }) => {\n                const [isHtml, text, customClassName] = formatValue(column, value);\n                const style = {\n                    background: valueRange\n                        ? cellBar({\n                            value: value,\n                            valueRange,\n                            alignPositiveNegative,\n                            colorPositiveNegative,\n                        })\n                        : undefined,\n                };\n                const html = isHtml ? { __html: text } : undefined;\n                const cellProps = {\n                    // show raw number in title in case of numeric values\n                    title: typeof value === \'number\' ? String(value) : undefined,\n                    onClick: emitFilter && !valueRange ? () => toggleFilter(key, value) : undefined,\n                    className: `${className} ${customClassName || \'\'} ${isActiveFilterValue(key, value) ? \' dt-is-active-filter\' : \'\'}`,\n                    style,\n                };\n                if (html) {\n                    // eslint-disable-next-line react/no-danger\n                    return react_default.a.createElement("td", Object.assign({}, cellProps, { dangerouslySetInnerHTML: html }));\n                }\n                // If cellProps renderes textContent already, then we don\'t have to\n                // render `Cell`. This saves some time for large tables.\n                return react_default.a.createElement("td", Object.assign({}, cellProps), text);\n            },\n            Header: ({ column: col, onClick, style }) => (react_default.a.createElement("th", { title: "Shift + Click to sort by multiple columns", className: col.isSorted ? `${className || \'\'} is-sorted` : className, style: style, onClick: onClick },\n                label,\n                react_default.a.createElement(SortIcon, { column: col }))),\n            sortDescFirst: sortDesc,\n            sortType: getSortTypeByDataType(dataType),\n        };\n    }, [\n        alignPositiveNegative,\n        colorPositiveNegative,\n        emitFilter,\n        getValueRange,\n        isActiveFilterValue,\n        showCellBars,\n        sortDesc,\n        toggleFilter,\n    ]);\n    const columns = Object(react["useMemo"])(() => columnsMeta.map(getColumnConfigs), [columnsMeta, getColumnConfigs]);\n    const handleServerPaginationChange = (pageNumber, pageSize) => {\n        Object(externalAPIs["a" /* updateExternalFormData */])(setDataMask, pageNumber, pageSize);\n    };\n    return (react_default.a.createElement(Styles, null,\n        react_default.a.createElement(DataTable, { columns: columns, data: data, rowCount: rowCount, tableClassName: "table table-striped table-condensed", pageSize: pageSize, serverPaginationData: serverPaginationData, pageSizeOptions: pageSizeOptions, width: width, height: height, serverPagination: serverPagination, onServerPaginationChange: handleServerPaginationChange, \n            // 9 page items in > 340px works well even for 100+ pages\n            maxPageItemCount: width > 340 ? 9 : 7, noResults: (filter) => Object(TranslatorSingleton["e" /* t */])(filter ? \'No matching records found\' : \'No records found\'), searchInput: includeSearch && TableChart_SearchInput, selectPageSize: pageSize !== null && TableChart_SelectPageSize, \n            // not in use in Superset, but needed for unit tests\n            sticky: sticky })));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUwOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wbHVnaW4tY2hhcnQtdGFibGUvc3JjL0RhdGFUYWJsZS91dGlscy91c2VBc3luY1N0YXRlLnRzP2Q0MmUiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9wbHVnaW5zL3BsdWdpbi1jaGFydC10YWJsZS9zcmMvRGF0YVRhYmxlL2NvbXBvbmVudHMvR2xvYmFsRmlsdGVyLnRzeD82NmM3Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wbHVnaW4tY2hhcnQtdGFibGUvc3JjL0RhdGFUYWJsZS9jb21wb25lbnRzL1NlbGVjdFBhZ2VTaXplLnRzeD80MWU4Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wbHVnaW4tY2hhcnQtdGFibGUvc3JjL0RhdGFUYWJsZS9jb21wb25lbnRzL1BhZ2luYXRpb24udHN4PzlhOTIiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9wbHVnaW5zL3BsdWdpbi1jaGFydC10YWJsZS9zcmMvRGF0YVRhYmxlL3V0aWxzL2dldFNjcm9sbEJhclNpemUudHM/NDI0OCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvcGx1Z2luLWNoYXJ0LXRhYmxlL3NyYy9EYXRhVGFibGUvdXRpbHMvbmVlZFNjcm9sbEJhci50cz8xNzUzIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wbHVnaW4tY2hhcnQtdGFibGUvc3JjL0RhdGFUYWJsZS91dGlscy91c2VNb3VudGVkTWVtby50cz85YzI5Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wbHVnaW4tY2hhcnQtdGFibGUvc3JjL0RhdGFUYWJsZS9ob29rcy91c2VTdGlja3kudHN4P2YwNGUiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9wbHVnaW5zL3BsdWdpbi1jaGFydC10YWJsZS9zcmMvRGF0YVRhYmxlL0RhdGFUYWJsZS50c3g/Mzg2NCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvcGx1Z2luLWNoYXJ0LXRhYmxlL3NyYy9TdHlsZXMudHN4PzNjMmYiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9wbHVnaW5zL3BsdWdpbi1jaGFydC10YWJsZS9zcmMvdXRpbHMvZm9ybWF0VmFsdWUudHM/MDE1NCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvcGx1Z2luLWNoYXJ0LXRhYmxlL3NyYy9UYWJsZUNoYXJ0LnRzeD8yODI1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VBc3luY0RlYm91bmNlIH0gZnJvbSAncmVhY3QtdGFibGUnO1xuXG4vLyB1c2VBc3luY0RlYm91bmNlIGluIGRpc3QgYnVpbGQgb2YgYHJlYWN0LXRhYmxlYCByZXF1aXJlcyByZWdlbmVyYXRvclJ1bnRpbWVcbmltcG9ydCAncmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lJztcblxuLyoqXG4gKiBIb29rIHVzZVN0YXRlIHRvIGFsbG93IGFsd2F5cyByZXR1cm4gbGF0ZXN0IGluaXRpYWxWYWx1ZVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1c2VBc3luY1N0YXRlPFQsIEYgZXh0ZW5kcyAobmV3VmFsdWU6IFQpID0+IHVua25vd24+KFxuICBpbml0aWFsVmFsdWU6IFQsXG4gIGNhbGxiYWNrOiBGLFxuICB3YWl0ID0gMjAwLFxuKSB7XG4gIGNvbnN0IFt2YWx1ZSwgc2V0VmFsdWVdID0gdXNlU3RhdGUoaW5pdGlhbFZhbHVlKTtcbiAgY29uc3QgdmFsdWVSZWYgPSB1c2VSZWYoaW5pdGlhbFZhbHVlKTtcbiAgY29uc3Qgb25DaGFuZ2UgPSB1c2VBc3luY0RlYm91bmNlKGNhbGxiYWNrLCB3YWl0KTtcblxuICAvLyBzeW5jIHVwZGF0ZWQgaW5pdGlhbFZhbHVlXG4gIGlmICh2YWx1ZVJlZi5jdXJyZW50ICE9PSBpbml0aWFsVmFsdWUpIHtcbiAgICB2YWx1ZVJlZi5jdXJyZW50ID0gaW5pdGlhbFZhbHVlO1xuICAgIGlmICh2YWx1ZSAhPT0gaW5pdGlhbFZhbHVlKSB7XG4gICAgICBzZXRWYWx1ZShpbml0aWFsVmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHNldEJvdGggPSAobmV3VmFsdWU6IFQpID0+IHtcbiAgICBzZXRWYWx1ZShuZXdWYWx1ZSk7XG4gICAgb25DaGFuZ2UobmV3VmFsdWUpO1xuICB9O1xuXG4gIHJldHVybiBbdmFsdWUsIHNldEJvdGhdIGFzIFt0eXBlb2YgdmFsdWUsIHR5cGVvZiBzZXRWYWx1ZV07XG59XG4iLCIvKipcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50VHlwZSwgQ2hhbmdlRXZlbnRIYW5kbGVyIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUm93LCBGaWx0ZXJWYWx1ZSB9IGZyb20gJ3JlYWN0LXRhYmxlJztcbmltcG9ydCB1c2VBc3luY1N0YXRlIGZyb20gJy4uL3V0aWxzL3VzZUFzeW5jU3RhdGUnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNlYXJjaElucHV0UHJvcHMge1xuICBjb3VudDogbnVtYmVyO1xuICB2YWx1ZTogc3RyaW5nO1xuICBvbkNoYW5nZTogQ2hhbmdlRXZlbnRIYW5kbGVyPEhUTUxJbnB1dEVsZW1lbnQ+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdsb2JhbEZpbHRlclByb3BzPEQgZXh0ZW5kcyBvYmplY3Q+IHtcbiAgcHJlR2xvYmFsRmlsdGVyZWRSb3dzOiBSb3c8RD5bXTtcbiAgLy8gZmlsdGVyIHZhbHVlIGNhbm5vdCBiZSBgdW5kZWZpbmVkYCBvdGhlcndpc2UgUmVhY3Qgd2lsbCByZXBvcnQgY29tcG9uZW50XG4gIC8vIGNvbnRyb2wgdHlwZSB1bmRlZmluZWQgZXJyb3JcbiAgZmlsdGVyVmFsdWU6IHN0cmluZztcbiAgc2V0R2xvYmFsRmlsdGVyOiAoZmlsdGVyVmFsdWU6IEZpbHRlclZhbHVlKSA9PiB2b2lkO1xuICBzZWFyY2hJbnB1dD86IENvbXBvbmVudFR5cGU8U2VhcmNoSW5wdXRQcm9wcz47XG59XG5cbmZ1bmN0aW9uIERlZmF1bHRTZWFyY2hJbnB1dCh7IGNvdW50LCB2YWx1ZSwgb25DaGFuZ2UgfTogU2VhcmNoSW5wdXRQcm9wcykge1xuICByZXR1cm4gKFxuICAgIDxzcGFuIGNsYXNzTmFtZT1cImR0LWdsb2JhbC1maWx0ZXJcIj5cbiAgICAgIFNlYXJjaHsnICd9XG4gICAgICA8aW5wdXRcbiAgICAgICAgY2xhc3NOYW1lPVwiZm9ybS1jb250cm9sIGlucHV0LXNtXCJcbiAgICAgICAgcGxhY2Vob2xkZXI9e2Ake2NvdW50fSByZWNvcmRzLi4uYH1cbiAgICAgICAgdmFsdWU9e3ZhbHVlfVxuICAgICAgICBvbkNoYW5nZT17b25DaGFuZ2V9XG4gICAgICAvPlxuICAgIDwvc3Bhbj5cbiAgKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgKFJlYWN0Lm1lbW8gYXMgPFQ+KGZuOiBUKSA9PiBUKShmdW5jdGlvbiBHbG9iYWxGaWx0ZXI8RCBleHRlbmRzIG9iamVjdD4oe1xuICBwcmVHbG9iYWxGaWx0ZXJlZFJvd3MsXG4gIGZpbHRlclZhbHVlID0gJycsXG4gIHNlYXJjaElucHV0LFxuICBzZXRHbG9iYWxGaWx0ZXIsXG59OiBHbG9iYWxGaWx0ZXJQcm9wczxEPikge1xuICBjb25zdCBjb3VudCA9IHByZUdsb2JhbEZpbHRlcmVkUm93cy5sZW5ndGg7XG4gIGNvbnN0IFt2YWx1ZSwgc2V0VmFsdWVdID0gdXNlQXN5bmNTdGF0ZShcbiAgICBmaWx0ZXJWYWx1ZSxcbiAgICAobmV3VmFsdWU6IHN0cmluZykgPT4ge1xuICAgICAgc2V0R2xvYmFsRmlsdGVyKG5ld1ZhbHVlIHx8IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICAyMDAsXG4gICk7XG5cbiAgY29uc3QgU2VhcmNoSW5wdXQgPSBzZWFyY2hJbnB1dCB8fCBEZWZhdWx0U2VhcmNoSW5wdXQ7XG5cbiAgcmV0dXJuIChcbiAgICA8U2VhcmNoSW5wdXRcbiAgICAgIGNvdW50PXtjb3VudH1cbiAgICAgIHZhbHVlPXt2YWx1ZX1cbiAgICAgIG9uQ2hhbmdlPXtlID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudDtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBzZXRWYWx1ZSh0YXJnZXQudmFsdWUpO1xuICAgICAgfX1cbiAgICAvPlxuICApO1xufSk7XG4iLCIvKipcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZm9ybWF0U2VsZWN0T3B0aW9ucyB9IGZyb20gJ0BzdXBlcnNldC11aS9jaGFydC1jb250cm9scyc7XG5cbmV4cG9ydCB0eXBlIFNpemVPcHRpb24gPSBbbnVtYmVyLCBzdHJpbmddO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNlbGVjdFBhZ2VTaXplUmVuZGVyZXJQcm9wcyB7XG4gIGN1cnJlbnQ6IG51bWJlcjtcbiAgb3B0aW9uczogU2l6ZU9wdGlvbltdO1xuICBvbkNoYW5nZTogU2VsZWN0UGFnZVNpemVQcm9wc1snb25DaGFuZ2UnXTtcbn1cblxuZnVuY3Rpb24gRGVmYXVsdFNlbGVjdFJlbmRlcmVyKHsgY3VycmVudCwgb3B0aW9ucywgb25DaGFuZ2UgfTogU2VsZWN0UGFnZVNpemVSZW5kZXJlclByb3BzKSB7XG4gIHJldHVybiAoXG4gICAgPHNwYW4gY2xhc3NOYW1lPVwiZHQtc2VsZWN0LXBhZ2Utc2l6ZSBmb3JtLWlubGluZVwiPlxuICAgICAgU2hvd3snICd9XG4gICAgICA8c2VsZWN0XG4gICAgICAgIGNsYXNzTmFtZT1cImZvcm0tY29udHJvbCBpbnB1dC1zbVwiXG4gICAgICAgIHZhbHVlPXtjdXJyZW50fVxuICAgICAgICBvbkJsdXI9eygpID0+IHt9fVxuICAgICAgICBvbkNoYW5nZT17ZSA9PiB7XG4gICAgICAgICAgb25DaGFuZ2UoTnVtYmVyKChlLnRhcmdldCBhcyBIVE1MU2VsZWN0RWxlbWVudCkudmFsdWUpKTtcbiAgICAgICAgfX1cbiAgICAgID5cbiAgICAgICAge29wdGlvbnMubWFwKG9wdGlvbiA9PiB7XG4gICAgICAgICAgY29uc3QgW3NpemUsIHRleHRdID0gQXJyYXkuaXNBcnJheShvcHRpb24pID8gb3B0aW9uIDogW29wdGlvbiwgb3B0aW9uXTtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPG9wdGlvbiBrZXk9e3NpemV9IHZhbHVlPXtzaXplfT5cbiAgICAgICAgICAgICAge3RleHR9XG4gICAgICAgICAgICA8L29wdGlvbj5cbiAgICAgICAgICApO1xuICAgICAgICB9KX1cbiAgICAgIDwvc2VsZWN0PnsnICd9XG4gICAgICBlbnRyaWVzXG4gICAgPC9zcGFuPlxuICApO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlbGVjdFBhZ2VTaXplUHJvcHMgZXh0ZW5kcyBTZWxlY3RQYWdlU2l6ZVJlbmRlcmVyUHJvcHMge1xuICB0b3RhbD86IG51bWJlcjtcbiAgc2VsZWN0UmVuZGVyZXI/OiB0eXBlb2YgRGVmYXVsdFNlbGVjdFJlbmRlcmVyO1xuICBvbkNoYW5nZTogKHBhZ2VTaXplOiBudW1iZXIpID0+IHZvaWQ7XG59XG5cbmZ1bmN0aW9uIGdldE9wdGlvblZhbHVlKHg6IFNpemVPcHRpb24pIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoeCkgPyB4WzBdIDogeDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVhY3QubWVtbyhmdW5jdGlvbiBTZWxlY3RQYWdlU2l6ZSh7XG4gIHRvdGFsLFxuICBvcHRpb25zOiBzaXplT3B0aW9ucyxcbiAgY3VycmVudDogY3VycmVudFNpemUsXG4gIHNlbGVjdFJlbmRlcmVyLFxuICBvbkNoYW5nZSxcbn06IFNlbGVjdFBhZ2VTaXplUHJvcHMpIHtcbiAgY29uc3Qgc2l6ZU9wdGlvblZhbHVlcyA9IHNpemVPcHRpb25zLm1hcChnZXRPcHRpb25WYWx1ZSk7XG4gIGxldCBvcHRpb25zID0gWy4uLnNpemVPcHRpb25zXTtcbiAgLy8gaW5zZXJ0IGN1cnJlbnQgc2l6ZSB0byBsaXN0XG4gIGlmIChcbiAgICBjdXJyZW50U2l6ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgKGN1cnJlbnRTaXplICE9PSB0b3RhbCB8fCAhc2l6ZU9wdGlvblZhbHVlcy5pbmNsdWRlcygwKSkgJiZcbiAgICAhc2l6ZU9wdGlvblZhbHVlcy5pbmNsdWRlcyhjdXJyZW50U2l6ZSlcbiAgKSB7XG4gICAgb3B0aW9ucyA9IFsuLi5zaXplT3B0aW9uc107XG4gICAgb3B0aW9ucy5zcGxpY2UoXG4gICAgICBzaXplT3B0aW9uVmFsdWVzLmZpbmRJbmRleCh4ID0+IHggPiBjdXJyZW50U2l6ZSksXG4gICAgICAwLFxuICAgICAgZm9ybWF0U2VsZWN0T3B0aW9ucyhbY3VycmVudFNpemVdKVswXSxcbiAgICApO1xuICB9XG4gIGNvbnN0IGN1cnJlbnQgPSBjdXJyZW50U2l6ZSA9PT0gdW5kZWZpbmVkID8gc2l6ZU9wdGlvblZhbHVlc1swXSA6IGN1cnJlbnRTaXplO1xuICBjb25zdCBTZWxlY3RSZW5kZXJlciA9IHNlbGVjdFJlbmRlcmVyIHx8IERlZmF1bHRTZWxlY3RSZW5kZXJlcjtcbiAgcmV0dXJuIDxTZWxlY3RSZW5kZXJlciBjdXJyZW50PXtjdXJyZW50fSBvcHRpb25zPXtvcHRpb25zfSBvbkNoYW5nZT17b25DaGFuZ2V9IC8+O1xufSk7XG4iLCIvKipcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgUmVhY3QsIHsgQ1NTUHJvcGVydGllcyB9IGZyb20gJ3JlYWN0JztcblxuZXhwb3J0IGludGVyZmFjZSBQYWdpbmF0aW9uUHJvcHMge1xuICBwYWdlQ291bnQ6IG51bWJlcjsgLy8gbnVtYmVyIG9mIHBhZ2VzXG4gIGN1cnJlbnRQYWdlPzogbnVtYmVyOyAvLyBpbmRleCBvZiBjdXJyZW50IHBhZ2UsIHplcm8tYmFzZWRcbiAgbWF4UGFnZUl0ZW1Db3VudD86IG51bWJlcjtcbiAgZWxsaXBzaXM/OiBzdHJpbmc7IC8vIGNvbnRlbnQgZm9yIGVsbGlwc2lzIGl0ZW1cbiAgb25QYWdlQ2hhbmdlOiAocGFnZTogbnVtYmVyKSA9PiB2b2lkOyAvLyBgcGFnZWAgaXMgemVyby1iYXNlZFxuICBzdHlsZT86IENTU1Byb3BlcnRpZXM7XG59XG5cbi8vIGZpcnN0LCAuLi4sIHByZXYsIGN1cnJlbnQsIG5leHQsIC4uLiwgbGFzdFxuY29uc3QgTUlOSU1BTF9QQUdFX0lURU1fQ09VTlQgPSA3O1xuXG4vKipcbiAqIEdlbmVyYXRlIG51bWVyaWMgcGFnZSBpdGVtcyBhcm91bmQgY3VycmVudCBwYWdlLlxuICogICAtIEFsd2F5cyBpbmNsdWRlIGZpcnN0IGFuZCBsYXN0IHBhZ2VcbiAqICAgLSBBZGQgZWxsaXBzaXMgaWYgbmVlZGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVBhZ2VJdGVtcyh0b3RhbDogbnVtYmVyLCBjdXJyZW50OiBudW1iZXIsIHdpZHRoOiBudW1iZXIpIHtcbiAgaWYgKHdpZHRoIDwgTUlOSU1BTF9QQUdFX0lURU1fQ09VTlQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE11c3QgYWxsb3cgYXQgbGVhc3QgJHtNSU5JTUFMX1BBR0VfSVRFTV9DT1VOVH0gcGFnZSBpdGVtc2ApO1xuICB9XG4gIGlmICh3aWR0aCAlIDIgPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE11c3QgYWxsb3cgb2RkIG51bWJlciBvZiBwYWdlIGl0ZW1zYCk7XG4gIH1cbiAgaWYgKHRvdGFsIDwgd2lkdGgpIHtcbiAgICByZXR1cm4gWy4uLm5ldyBBcnJheSh0b3RhbCkua2V5cygpXTtcbiAgfVxuICBjb25zdCBsZWZ0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odG90YWwgLSB3aWR0aCwgY3VycmVudCAtIE1hdGguZmxvb3Iod2lkdGggLyAyKSkpO1xuICBjb25zdCBpdGVtczogKHN0cmluZyB8IG51bWJlcilbXSA9IG5ldyBBcnJheSh3aWR0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgd2lkdGg7IGkgKz0gMSkge1xuICAgIGl0ZW1zW2ldID0gaSArIGxlZnQ7XG4gIH1cbiAgLy8gcmVwbGFjZSBub24tZW5kaW5nIGl0ZW1zIHdpdGggcGxhY2Vob2xkZXJzXG4gIGlmIChpdGVtc1swXSA+IDApIHtcbiAgICBpdGVtc1swXSA9IDA7XG4gICAgaXRlbXNbMV0gPSAncHJldi1tb3JlJztcbiAgfVxuICBpZiAoaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV0gPCB0b3RhbCAtIDEpIHtcbiAgICBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXSA9IHRvdGFsIC0gMTtcbiAgICBpdGVtc1tpdGVtcy5sZW5ndGggLSAyXSA9ICduZXh0LW1vcmUnO1xuICB9XG4gIHJldHVybiBpdGVtcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVhY3QubWVtbyhcbiAgUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBQYWdpbmF0aW9uKFxuICAgIHsgc3R5bGUsIHBhZ2VDb3VudCwgY3VycmVudFBhZ2UgPSAwLCBtYXhQYWdlSXRlbUNvdW50ID0gOSwgb25QYWdlQ2hhbmdlIH06IFBhZ2luYXRpb25Qcm9wcyxcbiAgICByZWY6IFJlYWN0LlJlZjxIVE1MRGl2RWxlbWVudD4sXG4gICkge1xuICAgIGNvbnN0IHBhZ2VJdGVtcyA9IGdlbmVyYXRlUGFnZUl0ZW1zKHBhZ2VDb3VudCwgY3VycmVudFBhZ2UsIG1heFBhZ2VJdGVtQ291bnQpO1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IHJlZj17cmVmfSBjbGFzc05hbWU9XCJkdC1wYWdpbmF0aW9uXCIgc3R5bGU9e3N0eWxlfT5cbiAgICAgICAgPHVsIGNsYXNzTmFtZT1cInBhZ2luYXRpb24gcGFnaW5hdGlvbi1zbVwiPlxuICAgICAgICAgIHtwYWdlSXRlbXMubWFwKGl0ZW0gPT5cbiAgICAgICAgICAgIHR5cGVvZiBpdGVtID09PSAnbnVtYmVyJyA/IChcbiAgICAgICAgICAgICAgLy8gYWN0dWFsIHBhZ2UgbnVtYmVyXG4gICAgICAgICAgICAgIDxsaSBrZXk9e2l0ZW19IGNsYXNzTmFtZT17Y3VycmVudFBhZ2UgPT09IGl0ZW0gPyAnYWN0aXZlJyA6IHVuZGVmaW5lZH0+XG4gICAgICAgICAgICAgICAgPGFcbiAgICAgICAgICAgICAgICAgIGhyZWY9e2AjcGFnZS0ke2l0ZW19YH1cbiAgICAgICAgICAgICAgICAgIHJvbGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICAgICAgb25DbGljaz17ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgb25QYWdlQ2hhbmdlKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICB7aXRlbSArIDF9XG4gICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgPGxpIGtleT17aXRlbX0gY2xhc3NOYW1lPVwiZHQtcGFnaW5hdGlvbi1lbGxpcHNpc1wiPlxuICAgICAgICAgICAgICAgIDxzcGFuPuKApjwvc3Bhbj5cbiAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgICksXG4gICAgICAgICAgKX1cbiAgICAgICAgPC91bD5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH0pLFxuKTtcbiIsIi8qKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmxldCBjYWNoZWQ6IG51bWJlciB8IHVuZGVmaW5lZDtcblxuY29uc3QgY3NzID0gKHg6IFRlbXBsYXRlU3RyaW5nc0FycmF5KSA9PiB4LmpvaW4oJ1xcbicpO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRTY3JvbGxCYXJTaXplKGZvcmNlUmVmcmVzaCA9IGZhbHNlKSB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKGNhY2hlZCA9PT0gdW5kZWZpbmVkIHx8IGZvcmNlUmVmcmVzaCkge1xuICAgIGNvbnN0IGlubmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29uc3Qgb3V0ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBpbm5lci5zdHlsZS5jc3NUZXh0ID0gY3NzYFxuICAgICAgd2lkdGg6IGF1dG87XG4gICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICBvdmVyZmxvdzogc2Nyb2xsO1xuICAgIGA7XG4gICAgb3V0ZXIuc3R5bGUuY3NzVGV4dCA9IGNzc2BcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICB3aWR0aDogMTAwcHg7XG4gICAgICBoZWlnaHQ6IDUwcHg7XG4gICAgYDtcbiAgICBvdXRlci5hcHBlbmQoaW5uZXIpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKG91dGVyKTtcbiAgICBjYWNoZWQgPSBvdXRlci5jbGllbnRXaWR0aCAtIGlubmVyLmNsaWVudFdpZHRoO1xuICAgIG91dGVyLnJlbW92ZSgpO1xuICB9XG4gIHJldHVybiBjYWNoZWQ7XG59XG4iLCIvKipcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFdoZXRoZXIgYSBjb250YWluZXIgbmVlZCBzY3JvbGwgYmFycyB3aGVuIGluIGFub3RoZXIgY29udGFpbmVyLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBuZWVkU2Nyb2xsQmFyKHtcbiAgd2lkdGgsXG4gIGhlaWdodCxcbiAgaW5uZXJIZWlnaHQsXG4gIGlubmVyV2lkdGgsXG4gIHNjcm9sbEJhclNpemUsXG59OiB7XG4gIHdpZHRoOiBudW1iZXI7XG4gIGhlaWdodDogbnVtYmVyO1xuICBpbm5lckhlaWdodDogbnVtYmVyO1xuICBzY3JvbGxCYXJTaXplOiBudW1iZXI7XG4gIGlubmVyV2lkdGg6IG51bWJlcjtcbn0pOiBbYm9vbGVhbiwgYm9vbGVhbl0ge1xuICBjb25zdCBoYXNWZXJ0aWNhbFNjcm9sbCA9IGlubmVySGVpZ2h0ID4gaGVpZ2h0O1xuICBjb25zdCBoYXNIb3Jpem9udGFsU2Nyb2xsID0gaW5uZXJXaWR0aCA+IHdpZHRoIC0gKGhhc1ZlcnRpY2FsU2Nyb2xsID8gc2Nyb2xsQmFyU2l6ZSA6IDApO1xuICByZXR1cm4gW2hhc1ZlcnRpY2FsU2Nyb2xsLCBoYXNIb3Jpem9udGFsU2Nyb2xsXTtcbn1cbiIsIi8qKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCwgdXNlUmVmLCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIEV4ZWN1dGUgYSBtZW1vaXplZCBjYWxsYmFjayBvbmx5IHdoZW4gbW91bnRlZC4gRXhlY3V0ZSBhZ2FpbiB3aGVuIGZhY3RvcnkgdXBkYXRlZC5cbiAqIFJldHVybnMgdW5kZWZpbmVkIGlmIG5vdCBtb3VudGVkIHlldC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXNlTW91bnRlZE1lbW88VD4oZmFjdG9yeTogKCkgPT4gVCwgZGVwcz86IHVua25vd25bXSk6IFQgfCB1bmRlZmluZWQge1xuICBjb25zdCBtb3VudGVkID0gdXNlUmVmPHR5cGVvZiBmYWN0b3J5PigpO1xuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIG1vdW50ZWQuY3VycmVudCA9IGZhY3Rvcnk7XG4gIH0pO1xuICByZXR1cm4gdXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKG1vdW50ZWQuY3VycmVudCkge1xuICAgICAgcmV0dXJuIGZhY3RvcnkoKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFttb3VudGVkLmN1cnJlbnQsIG1vdW50ZWQuY3VycmVudCA9PT0gZmFjdG9yeSwgLi4uKGRlcHMgfHwgW10pXSk7XG59XG4iLCIvKipcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgUmVhY3QsIHtcbiAgdXNlUmVmLFxuICB1c2VNZW1vLFxuICB1c2VMYXlvdXRFZmZlY3QsXG4gIHVzZUNhbGxiYWNrLFxuICBSZWFjdE5vZGUsXG4gIFJlYWN0RWxlbWVudCxcbiAgQ29tcG9uZW50UHJvcHNXaXRoUmVmLFxuICBDU1NQcm9wZXJ0aWVzLFxuICBVSUV2ZW50SGFuZGxlcixcbn0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgVGFibGVJbnN0YW5jZSwgSG9va3MgfSBmcm9tICdyZWFjdC10YWJsZSc7XG5pbXBvcnQgZ2V0U2Nyb2xsQmFyU2l6ZSBmcm9tICcuLi91dGlscy9nZXRTY3JvbGxCYXJTaXplJztcbmltcG9ydCBuZWVkU2Nyb2xsQmFyIGZyb20gJy4uL3V0aWxzL25lZWRTY3JvbGxCYXInO1xuaW1wb3J0IHVzZU1vdW50ZWRNZW1vIGZyb20gJy4uL3V0aWxzL3VzZU1vdW50ZWRNZW1vJztcblxudHlwZSBSZWFjdEVsZW1lbnRXaXRoQ2hpbGRyZW48XG4gIFQgZXh0ZW5kcyBrZXlvZiBKU1guSW50cmluc2ljRWxlbWVudHMsXG4gIEMgZXh0ZW5kcyBSZWFjdE5vZGUgPSBSZWFjdE5vZGVcbj4gPSBSZWFjdEVsZW1lbnQ8Q29tcG9uZW50UHJvcHNXaXRoUmVmPFQ+ICYgeyBjaGlsZHJlbjogQyB9LCBUPjtcblxudHlwZSBUaCA9IFJlYWN0RWxlbWVudFdpdGhDaGlsZHJlbjwndGgnPjtcbnR5cGUgVGQgPSBSZWFjdEVsZW1lbnRXaXRoQ2hpbGRyZW48J3RkJz47XG50eXBlIFRyV2l0aFRoID0gUmVhY3RFbGVtZW50V2l0aENoaWxkcmVuPCd0cicsIFRoW10+O1xudHlwZSBUcldpdGhUZCA9IFJlYWN0RWxlbWVudFdpdGhDaGlsZHJlbjwndHInLCBUZFtdPjtcbnR5cGUgVGhlYWQgPSBSZWFjdEVsZW1lbnRXaXRoQ2hpbGRyZW48J3RoZWFkJywgVHJXaXRoVGg+O1xudHlwZSBUYm9keSA9IFJlYWN0RWxlbWVudFdpdGhDaGlsZHJlbjwndGJvZHknLCBUcldpdGhUZD47XG50eXBlIENvbCA9IFJlYWN0RWxlbWVudFdpdGhDaGlsZHJlbjwnY29sJywgbnVsbD47XG50eXBlIENvbEdyb3VwID0gUmVhY3RFbGVtZW50V2l0aENoaWxkcmVuPCdjb2xncm91cCcsIENvbD47XG5cbmV4cG9ydCB0eXBlIFRhYmxlID0gUmVhY3RFbGVtZW50V2l0aENoaWxkcmVuPCd0YWJsZScsIChUaGVhZCB8IFRib2R5IHwgQ29sR3JvdXApW10+O1xuZXhwb3J0IHR5cGUgVGFibGVSZW5kZXJlciA9ICgpID0+IFRhYmxlO1xuZXhwb3J0IHR5cGUgR2V0VGFibGVTaXplID0gKCkgPT4gUGFydGlhbDxTdGlja3lTdGF0ZT4gfCB1bmRlZmluZWQ7XG5leHBvcnQgdHlwZSBTZXRTdGlja3lTdGF0ZSA9IChzaXplPzogU3RpY2t5U3RhdGUpID0+IHZvaWQ7XG5cbmV4cG9ydCBlbnVtIFJlZHVjZXJBY3Rpb25zIHtcbiAgaW5pdCA9ICdpbml0JywgLy8gdGhpcyBpcyBmcm9tIGdsb2JhbCByZWR1Y2VyXG4gIHNldFN0aWNreVN0YXRlID0gJ3NldFN0aWNreVN0YXRlJyxcbn1cblxuZXhwb3J0IHR5cGUgUmVkdWNlckFjdGlvbjxUIGV4dGVuZHMgc3RyaW5nLCBQIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4+ID0gUCAmIHsgdHlwZTogVCB9O1xuXG5leHBvcnQgdHlwZSBDb2x1bW5XaWR0aHMgPSBudW1iZXJbXTtcblxuZXhwb3J0IGludGVyZmFjZSBTdGlja3lTdGF0ZSB7XG4gIHdpZHRoPzogbnVtYmVyOyAvLyBtYXhpbXVtIGZ1bGwgdGFibGUgd2lkdGhcbiAgaGVpZ2h0PzogbnVtYmVyOyAvLyBtYXhpbXVtIGZ1bGwgdGFibGUgaGVpZ2h0XG4gIHJlYWxIZWlnaHQ/OiBudW1iZXI7IC8vIGFjdHVhbCB0YWJsZSB2aWV3cG9ydCBoZWlnaHQgKGhlYWRlciArIHNjcm9sbGFibGUgYXJlYSlcbiAgYm9keUhlaWdodD86IG51bWJlcjsgLy8gc2Nyb2xsYWJsZSBhcmVhIGhlaWdodFxuICB0YWJsZUhlaWdodD86IG51bWJlcjsgLy8gdGhlIGZ1bGwgdGFibGUgaGVpZ2h0XG4gIGNvbHVtbldpZHRocz86IENvbHVtbldpZHRocztcbiAgaGFzSG9yaXpvbnRhbFNjcm9sbD86IGJvb2xlYW47XG4gIGhhc1ZlcnRpY2FsU2Nyb2xsPzogYm9vbGVhbjtcbiAgcmVuZGVyaW5nPzogYm9vbGVhbjtcbiAgc2V0U3RpY2t5U3RhdGU/OiBTZXRTdGlja3lTdGF0ZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VTdGlja3lUYWJsZU9wdGlvbnMge1xuICBnZXRUYWJsZVNpemU/OiBHZXRUYWJsZVNpemU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU3RpY2t5SW5zdGFuY2VQcm9wcyB7XG4gIC8vIG1hbmlwdWxhdGUgRE9NcyBpbiA8dGFibGU+IHRvIG1ha2UgdGhlIGhlYWRlciBzdGlja3lcbiAgd3JhcFN0aWNreVRhYmxlOiAocmVuZGVyZXI6IFRhYmxlUmVuZGVyZXIpID0+IFJlYWN0Tm9kZTtcbiAgLy8gdXBkYXRlIG9yIHJlY29tcHV0ZSB0aGUgc3RpY2t5IHRhYmxlIHNpemVcbiAgc2V0U3RpY2t5U3RhdGU6IFNldFN0aWNreVN0YXRlO1xufVxuXG5leHBvcnQgdHlwZSBVc2VTdGlja3lTdGF0ZSA9IHtcbiAgc3RpY2t5OiBTdGlja3lTdGF0ZTtcbn07XG5cbmNvbnN0IHN1bSA9IChhOiBudW1iZXIsIGI6IG51bWJlcikgPT4gYSArIGI7XG5jb25zdCBtZXJnZVN0eWxlUHJvcCA9IChub2RlOiBSZWFjdEVsZW1lbnQ8eyBzdHlsZT86IENTU1Byb3BlcnRpZXMgfT4sIHN0eWxlOiBDU1NQcm9wZXJ0aWVzKSA9PiAoe1xuICBzdHlsZToge1xuICAgIC4uLm5vZGUucHJvcHMuc3R5bGUsXG4gICAgLi4uc3R5bGUsXG4gIH0sXG59KTtcblxuLyoqXG4gKiBBbiBIT0MgZm9yIGdlbmVyYXRpbmcgc3RpY2t5IGhlYWRlciBhbmQgZml4ZWQtaGVpZ2h0IHNjcm9sbGFibGUgYXJlYVxuICovXG5mdW5jdGlvbiBTdGlja3lXcmFwKHtcbiAgc3RpY2t5ID0ge30sXG4gIHdpZHRoOiBtYXhXaWR0aCxcbiAgaGVpZ2h0OiBtYXhIZWlnaHQsXG4gIGNoaWxkcmVuOiB0YWJsZSxcbiAgc2V0U3RpY2t5U3RhdGUsXG59OiB7XG4gIHdpZHRoOiBudW1iZXI7XG4gIGhlaWdodDogbnVtYmVyO1xuICBzZXRTdGlja3lTdGF0ZTogU2V0U3RpY2t5U3RhdGU7XG4gIGNoaWxkcmVuOiBUYWJsZTtcbiAgc3RpY2t5PzogU3RpY2t5U3RhdGU7IC8vIGN1cnJlbnQgc3RpY2t5IGVsZW1lbnQgc2l6ZXNcbn0pIHtcbiAgaWYgKCF0YWJsZSB8fCB0YWJsZS50eXBlICE9PSAndGFibGUnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCc8U3RpY2t5V3JhcD4gbXVzdCBoYXZlIG9ubHkgb25lIDx0YWJsZT4gZWxlbWVudCBhcyBjaGlsZCcpO1xuICB9XG4gIGxldCB0aGVhZDogVGhlYWQgfCB1bmRlZmluZWQ7XG4gIGxldCB0Ym9keTogVGJvZHkgfCB1bmRlZmluZWQ7XG4gIGxldCBjb2xncm91cDogQ29sR3JvdXAgfCB1bmRlZmluZWQ7XG4gIFJlYWN0LkNoaWxkcmVuLmZvckVhY2godGFibGUucHJvcHMuY2hpbGRyZW4sIG5vZGUgPT4ge1xuICAgIGlmIChub2RlLnR5cGUgPT09ICd0aGVhZCcpIHtcbiAgICAgIHRoZWFkID0gbm9kZTtcbiAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ3Rib2R5Jykge1xuICAgICAgdGJvZHkgPSBub2RlO1xuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAnY29sZ3JvdXAnKSB7XG4gICAgICBjb2xncm91cCA9IG5vZGU7XG4gICAgfVxuICB9KTtcbiAgaWYgKCF0aGVhZCB8fCAhdGJvZHkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJzx0YWJsZT4gaW4gPFN0aWNreVdyYXA+IG11c3QgY29udGFpbiBib3RoIHRoZWFkIGFuZCB0Ym9keS4nKTtcbiAgfVxuICBjb25zdCBjb2x1bW5Db3VudCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IGhlYWRlclJvd3MgPSBSZWFjdC5DaGlsZHJlbi50b0FycmF5KHRoZWFkPy5wcm9wcy5jaGlsZHJlbikucG9wKCkgYXMgVHJXaXRoVGg7XG4gICAgcmV0dXJuIGhlYWRlclJvd3MucHJvcHMuY2hpbGRyZW4ubGVuZ3RoO1xuICB9LCBbdGhlYWRdKTtcblxuICBjb25zdCB0aGVhZFJlZiA9IHVzZVJlZjxIVE1MVGFibGVTZWN0aW9uRWxlbWVudD4obnVsbCk7IC8vIG9yaWdpbmFsIHRoZWFkIGZvciBsYXlvdXQgY29tcHV0YXRpb25cbiAgY29uc3Qgc2Nyb2xsSGVhZGVyUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTsgLy8gZml4ZWQgaGVhZGVyXG4gIGNvbnN0IHNjcm9sbEJvZHlSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpOyAvLyBtYWluIGJvZHlcblxuICBjb25zdCB7IGJvZHlIZWlnaHQsIGNvbHVtbldpZHRocyB9ID0gc3RpY2t5O1xuICBjb25zdCBuZWVkU2l6ZXIgPVxuICAgICFjb2x1bW5XaWR0aHMgfHxcbiAgICBzdGlja3kud2lkdGggIT09IG1heFdpZHRoIHx8XG4gICAgc3RpY2t5LmhlaWdodCAhPT0gbWF4SGVpZ2h0IHx8XG4gICAgc3RpY2t5LnNldFN0aWNreVN0YXRlICE9PSBzZXRTdGlja3lTdGF0ZTtcbiAgY29uc3Qgc2Nyb2xsQmFyU2l6ZSA9IGdldFNjcm9sbEJhclNpemUoKTtcblxuICAvLyB1cGRhdGUgc2Nyb2xsYWJsZSBhcmVhIGFuZCBoZWFkZXIgY29sdW1uIHNpemVzIHdoZW4gbW91bnRlZFxuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0aGVhZFJlZi5jdXJyZW50KSB7XG4gICAgICBjb25zdCBib2R5VGhlYWQgPSB0aGVhZFJlZi5jdXJyZW50O1xuICAgICAgY29uc3QgdGhlYWRIZWlnaHQgPSBib2R5VGhlYWQuY2xpZW50SGVpZ2h0O1xuICAgICAgaWYgKCF0aGVhZEhlaWdodCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBmdWxsVGFibGVIZWlnaHQgPSAoYm9keVRoZWFkLnBhcmVudE5vZGUgYXMgSFRNTFRhYmxlRWxlbWVudCkuY2xpZW50SGVpZ2h0O1xuICAgICAgY29uc3QgdGhzID0gYm9keVRoZWFkLmNoaWxkTm9kZXNbMF0uY2hpbGROb2RlcyBhcyBOb2RlTGlzdE9mPEhUTUxUYWJsZUhlYWRlckNlbGxFbGVtZW50PjtcbiAgICAgIGNvbnN0IHdpZHRocyA9IEFycmF5LmZyb20odGhzKS5tYXAodGggPT4gdGguY2xpZW50V2lkdGgpO1xuICAgICAgY29uc3QgW2hhc1ZlcnRpY2FsU2Nyb2xsLCBoYXNIb3Jpem9udGFsU2Nyb2xsXSA9IG5lZWRTY3JvbGxCYXIoe1xuICAgICAgICB3aWR0aDogbWF4V2lkdGgsXG4gICAgICAgIGhlaWdodDogbWF4SGVpZ2h0IC0gdGhlYWRIZWlnaHQsXG4gICAgICAgIGlubmVySGVpZ2h0OiBmdWxsVGFibGVIZWlnaHQsXG4gICAgICAgIGlubmVyV2lkdGg6IHdpZHRocy5yZWR1Y2Uoc3VtKSxcbiAgICAgICAgc2Nyb2xsQmFyU2l6ZSxcbiAgICAgIH0pO1xuICAgICAgLy8gcmVhbCBjb250YWluZXIgaGVpZ2h0LCBpbmNsdWRlIHRhYmxlIGhlYWRlciBhbmQgc3BhY2UgZm9yXG4gICAgICAvLyBob3Jpem9udGFsIHNjcm9sbCBiYXJcbiAgICAgIGNvbnN0IHJlYWxIZWlnaHQgPSBNYXRoLm1pbihcbiAgICAgICAgbWF4SGVpZ2h0LFxuICAgICAgICBoYXNIb3Jpem9udGFsU2Nyb2xsID8gZnVsbFRhYmxlSGVpZ2h0ICsgc2Nyb2xsQmFyU2l6ZSA6IGZ1bGxUYWJsZUhlaWdodCxcbiAgICAgICk7XG4gICAgICBzZXRTdGlja3lTdGF0ZSh7XG4gICAgICAgIGhhc1ZlcnRpY2FsU2Nyb2xsLFxuICAgICAgICBoYXNIb3Jpem9udGFsU2Nyb2xsLFxuICAgICAgICBzZXRTdGlja3lTdGF0ZSxcbiAgICAgICAgd2lkdGg6IG1heFdpZHRoLFxuICAgICAgICBoZWlnaHQ6IG1heEhlaWdodCxcbiAgICAgICAgcmVhbEhlaWdodCxcbiAgICAgICAgdGFibGVIZWlnaHQ6IGZ1bGxUYWJsZUhlaWdodCxcbiAgICAgICAgYm9keUhlaWdodDogcmVhbEhlaWdodCAtIHRoZWFkSGVpZ2h0LFxuICAgICAgICBjb2x1bW5XaWR0aHM6IHdpZHRocyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW21heFdpZHRoLCBtYXhIZWlnaHQsIHNldFN0aWNreVN0YXRlLCBzY3JvbGxCYXJTaXplXSk7XG5cbiAgbGV0IHNpemVyVGFibGU6IFJlYWN0RWxlbWVudCB8IHVuZGVmaW5lZDtcbiAgbGV0IGhlYWRlclRhYmxlOiBSZWFjdEVsZW1lbnQgfCB1bmRlZmluZWQ7XG4gIGxldCBib2R5VGFibGU6IFJlYWN0RWxlbWVudCB8IHVuZGVmaW5lZDtcbiAgaWYgKG5lZWRTaXplcikge1xuICAgIGNvbnN0IHRoZWFkV2l0aFJlZiA9IFJlYWN0LmNsb25lRWxlbWVudCh0aGVhZCwgeyByZWY6IHRoZWFkUmVmIH0pO1xuICAgIHNpemVyVGFibGUgPSAoXG4gICAgICA8ZGl2XG4gICAgICAgIGtleT1cInNpemVyXCJcbiAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICBoZWlnaHQ6IG1heEhlaWdodCxcbiAgICAgICAgICBvdmVyZmxvdzogJ2F1dG8nLFxuICAgICAgICAgIHZpc2liaWxpdHk6ICdoaWRkZW4nLFxuICAgICAgICB9fVxuICAgICAgPlxuICAgICAgICB7UmVhY3QuY2xvbmVFbGVtZW50KHRhYmxlLCB7fSwgY29sZ3JvdXAsIHRoZWFkV2l0aFJlZiwgdGJvZHkpfVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIC8vIHJldXNlIHByZXZpb3VzbHkgY29sdW1uIHdpZHRocywgd2lsbCBiZSB1cGRhdGVkIGJ5IGB1c2VMYXlvdXRFZmZlY3RgIGFib3ZlXG4gIGNvbnN0IGNvbFdpZHRocyA9IGNvbHVtbldpZHRocz8uc2xpY2UoMCwgY29sdW1uQ291bnQpO1xuICBpZiAoY29sV2lkdGhzICYmIGJvZHlIZWlnaHQpIHtcbiAgICBjb25zdCB0YWJsZVN0eWxlOiBDU1NQcm9wZXJ0aWVzID0geyB0YWJsZUxheW91dDogJ2ZpeGVkJyB9O1xuXG4gICAgY29uc3QgYm9keUNvbHMgPSBjb2xXaWR0aHMubWFwKCh3LCBpKSA9PiAoXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tYXJyYXktaW5kZXgta2V5XG4gICAgICA8Y29sIGtleT17aX0gd2lkdGg9e3d9IC8+XG4gICAgKSk7XG4gICAgY29uc3QgYm9keUNvbGdyb3VwID0gPGNvbGdyb3VwPntib2R5Q29sc308L2NvbGdyb3VwPjtcblxuICAgIC8vIGhlYWRlciBjb2x1bW5zIGRvIG5vdCBoYXZlIHZlcnRpY2FsIHNjcm9sbCBiYXJzLFxuICAgIC8vIHNvIHdlIGFkZCBzY3JvbGwgYmFyIHNpemUgdG8gdGhlIGxhc3QgY29sdW1uXG4gICAgY29uc3QgaGVhZGVyQ29sZ3JvdXAgPVxuICAgICAgc3RpY2t5Lmhhc1ZlcnRpY2FsU2Nyb2xsICYmIHNjcm9sbEJhclNpemUgPyAoXG4gICAgICAgIDxjb2xncm91cD5cbiAgICAgICAgICB7Y29sV2lkdGhzLm1hcCgoeCwgaSkgPT4gKFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L25vLWFycmF5LWluZGV4LWtleVxuICAgICAgICAgICAgPGNvbCBrZXk9e2l9IHdpZHRoPXt4ICsgKGkgPT09IGNvbFdpZHRocy5sZW5ndGggLSAxID8gc2Nyb2xsQmFyU2l6ZSA6IDApfSAvPlxuICAgICAgICAgICkpfVxuICAgICAgICA8L2NvbGdyb3VwPlxuICAgICAgKSA6IChcbiAgICAgICAgYm9keUNvbGdyb3VwXG4gICAgICApO1xuXG4gICAgaGVhZGVyVGFibGUgPSAoXG4gICAgICA8ZGl2XG4gICAgICAgIGtleT1cImhlYWRlclwiXG4gICAgICAgIHJlZj17c2Nyb2xsSGVhZGVyUmVmfVxuICAgICAgICBzdHlsZT17e1xuICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgICAgfX1cbiAgICAgID5cbiAgICAgICAge1JlYWN0LmNsb25lRWxlbWVudCh0YWJsZSwgbWVyZ2VTdHlsZVByb3AodGFibGUsIHRhYmxlU3R5bGUpLCBoZWFkZXJDb2xncm91cCwgdGhlYWQpfVxuICAgICAgICB7aGVhZGVyVGFibGV9XG4gICAgICA8L2Rpdj5cbiAgICApO1xuXG4gICAgY29uc3Qgb25TY3JvbGw6IFVJRXZlbnRIYW5kbGVyPEhUTUxEaXZFbGVtZW50PiA9IGUgPT4ge1xuICAgICAgaWYgKHNjcm9sbEhlYWRlclJlZi5jdXJyZW50KSB7XG4gICAgICAgIHNjcm9sbEhlYWRlclJlZi5jdXJyZW50LnNjcm9sbExlZnQgPSBlLmN1cnJlbnRUYXJnZXQuc2Nyb2xsTGVmdDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGJvZHlUYWJsZSA9IChcbiAgICAgIDxkaXZcbiAgICAgICAga2V5PVwiYm9keVwiXG4gICAgICAgIHJlZj17c2Nyb2xsQm9keVJlZn1cbiAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICBoZWlnaHQ6IGJvZHlIZWlnaHQsXG4gICAgICAgICAgb3ZlcmZsb3c6ICdhdXRvJyxcbiAgICAgICAgfX1cbiAgICAgICAgb25TY3JvbGw9e3N0aWNreS5oYXNIb3Jpem9udGFsU2Nyb2xsID8gb25TY3JvbGwgOiB1bmRlZmluZWR9XG4gICAgICA+XG4gICAgICAgIHtSZWFjdC5jbG9uZUVsZW1lbnQodGFibGUsIG1lcmdlU3R5bGVQcm9wKHRhYmxlLCB0YWJsZVN0eWxlKSwgYm9keUNvbGdyb3VwLCB0Ym9keSl9XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICBzdHlsZT17e1xuICAgICAgICB3aWR0aDogbWF4V2lkdGgsXG4gICAgICAgIGhlaWdodDogc3RpY2t5LnJlYWxIZWlnaHQgfHwgbWF4SGVpZ2h0LFxuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICB9fVxuICAgID5cbiAgICAgIHtoZWFkZXJUYWJsZX1cbiAgICAgIHtib2R5VGFibGV9XG4gICAgICB7c2l6ZXJUYWJsZX1cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuZnVuY3Rpb24gdXNlSW5zdGFuY2U8RCBleHRlbmRzIG9iamVjdD4oaW5zdGFuY2U6IFRhYmxlSW5zdGFuY2U8RD4pIHtcbiAgY29uc3Qge1xuICAgIGRpc3BhdGNoLFxuICAgIHN0YXRlOiB7IHN0aWNreSB9LFxuICAgIGRhdGEsXG4gICAgcGFnZSxcbiAgICByb3dzLFxuICAgIGdldFRhYmxlU2l6ZSA9ICgpID0+IHVuZGVmaW5lZCxcbiAgfSA9IGluc3RhbmNlO1xuXG4gIGNvbnN0IHNldFN0aWNreVN0YXRlID0gdXNlQ2FsbGJhY2soXG4gICAgKHNpemU/OiBQYXJ0aWFsPFN0aWNreVN0YXRlPikgPT4ge1xuICAgICAgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBSZWR1Y2VyQWN0aW9ucy5zZXRTdGlja3lTdGF0ZSxcbiAgICAgICAgc2l6ZSxcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgLy8gdHVybmluZyBwYWdlcyB3b3VsZCBhbHNvIHRyaWdnZXIgYSByZXNpemVcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgW2Rpc3BhdGNoLCBnZXRUYWJsZVNpemUsIHBhZ2UsIHJvd3NdLFxuICApO1xuXG4gIGNvbnN0IHVzZVN0aWNreVdyYXAgPSAocmVuZGVyZXI6IFRhYmxlUmVuZGVyZXIpID0+IHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHVzZU1vdW50ZWRNZW1vKGdldFRhYmxlU2l6ZSwgW2dldFRhYmxlU2l6ZV0pIHx8IHN0aWNreTtcbiAgICAvLyBvbmx5IGNoYW5nZSBvZiBkYXRhIHNob3VsZCB0cmlnZ2VyIHJlLXJlbmRlclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBjb25zdCB0YWJsZSA9IHVzZU1lbW8ocmVuZGVyZXIsIFtwYWdlLCByb3dzXSk7XG5cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgaWYgKCF3aWR0aCB8fCAhaGVpZ2h0KSB7XG4gICAgICAgIHNldFN0aWNreVN0YXRlKCk7XG4gICAgICB9XG4gICAgfSwgW3dpZHRoLCBoZWlnaHRdKTtcblxuICAgIGlmICghd2lkdGggfHwgIWhlaWdodCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRhYmxlO1xuICAgIH1cbiAgICByZXR1cm4gKFxuICAgICAgPFN0aWNreVdyYXAgd2lkdGg9e3dpZHRofSBoZWlnaHQ9e2hlaWdodH0gc3RpY2t5PXtzdGlja3l9IHNldFN0aWNreVN0YXRlPXtzZXRTdGlja3lTdGF0ZX0+XG4gICAgICAgIHt0YWJsZX1cbiAgICAgIDwvU3RpY2t5V3JhcD5cbiAgICApO1xuICB9O1xuXG4gIE9iamVjdC5hc3NpZ24oaW5zdGFuY2UsIHtcbiAgICBzZXRTdGlja3lTdGF0ZSxcbiAgICB3cmFwU3RpY2t5VGFibGU6IHVzZVN0aWNreVdyYXAsXG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1c2VTdGlja3k8RCBleHRlbmRzIG9iamVjdD4oaG9va3M6IEhvb2tzPEQ+KSB7XG4gIGhvb2tzLnVzZUluc3RhbmNlLnB1c2godXNlSW5zdGFuY2UpO1xuICBob29rcy5zdGF0ZVJlZHVjZXJzLnB1c2goKG5ld1N0YXRlLCBhY3Rpb25fKSA9PiB7XG4gICAgY29uc3QgYWN0aW9uID0gYWN0aW9uXyBhcyBSZWR1Y2VyQWN0aW9uPFJlZHVjZXJBY3Rpb25zLCB7IHNpemU6IFN0aWNreVN0YXRlIH0+O1xuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gUmVkdWNlckFjdGlvbnMuaW5pdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubmV3U3RhdGUsXG4gICAgICAgIHN0aWNreTogbmV3U3RhdGUuc3RpY2t5IHx8IHt9LFxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBSZWR1Y2VyQWN0aW9ucy5zZXRTdGlja3lTdGF0ZSkge1xuICAgICAgY29uc3QgeyBzaXplIH0gPSBhY3Rpb247XG4gICAgICBpZiAoIXNpemUpIHtcbiAgICAgICAgcmV0dXJuIHsgLi4ubmV3U3RhdGUgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm5ld1N0YXRlLFxuICAgICAgICBzdGlja3k6IHtcbiAgICAgICAgICAuLi5uZXdTdGF0ZS5zdGlja3ksXG4gICAgICAgICAgLi4uYWN0aW9uLnNpemUsXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbmV3U3RhdGU7XG4gIH0pO1xufVxudXNlU3RpY2t5LnBsdWdpbk5hbWUgPSAndXNlU3RpY2t5JztcbiIsIi8qKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCBSZWFjdCwge1xuICB1c2VDYWxsYmFjayxcbiAgdXNlUmVmLFxuICBSZWFjdE5vZGUsXG4gIEhUTUxQcm9wcyxcbiAgTXV0YWJsZVJlZk9iamVjdCxcbiAgQ1NTUHJvcGVydGllcyxcbn0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHtcbiAgdXNlVGFibGUsXG4gIHVzZVBhZ2luYXRpb24sXG4gIHVzZVNvcnRCeSxcbiAgdXNlR2xvYmFsRmlsdGVyLFxuICBQbHVnaW5Ib29rLFxuICBUYWJsZU9wdGlvbnMsXG4gIEZpbHRlclR5cGUsXG4gIElkVHlwZSxcbiAgUm93LFxufSBmcm9tICdyZWFjdC10YWJsZSc7XG5pbXBvcnQgeyBtYXRjaFNvcnRlciwgcmFua2luZ3MgfSBmcm9tICdtYXRjaC1zb3J0ZXInO1xuaW1wb3J0IEdsb2JhbEZpbHRlciwgeyBHbG9iYWxGaWx0ZXJQcm9wcyB9IGZyb20gJy4vY29tcG9uZW50cy9HbG9iYWxGaWx0ZXInO1xuaW1wb3J0IFNlbGVjdFBhZ2VTaXplLCB7IFNlbGVjdFBhZ2VTaXplUHJvcHMsIFNpemVPcHRpb24gfSBmcm9tICcuL2NvbXBvbmVudHMvU2VsZWN0UGFnZVNpemUnO1xuaW1wb3J0IFNpbXBsZVBhZ2luYXRpb24gZnJvbSAnLi9jb21wb25lbnRzL1BhZ2luYXRpb24nO1xuaW1wb3J0IHVzZVN0aWNreSBmcm9tICcuL2hvb2tzL3VzZVN0aWNreSc7XG5pbXBvcnQgeyBQQUdFX1NJWkVfT1BUSU9OUyB9IGZyb20gJy4uL2NvbnN0cyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0YVRhYmxlUHJvcHM8RCBleHRlbmRzIG9iamVjdD4gZXh0ZW5kcyBUYWJsZU9wdGlvbnM8RD4ge1xuICB0YWJsZUNsYXNzTmFtZT86IHN0cmluZztcbiAgc2VhcmNoSW5wdXQ/OiBib29sZWFuIHwgR2xvYmFsRmlsdGVyUHJvcHM8RD5bJ3NlYXJjaElucHV0J107XG4gIHNlbGVjdFBhZ2VTaXplPzogYm9vbGVhbiB8IFNlbGVjdFBhZ2VTaXplUHJvcHNbJ3NlbGVjdFJlbmRlcmVyJ107XG4gIHBhZ2VTaXplT3B0aW9ucz86IFNpemVPcHRpb25bXTsgLy8gYXZhaWxhYmxlIHBhZ2Ugc2l6ZSBvcHRpb25zXG4gIG1heFBhZ2VJdGVtQ291bnQ/OiBudW1iZXI7XG4gIGhvb2tzPzogUGx1Z2luSG9vazxEPltdOyAvLyBhbnkgYWRkaXRpb25hbCBob29rc1xuICB3aWR0aD86IHN0cmluZyB8IG51bWJlcjtcbiAgaGVpZ2h0Pzogc3RyaW5nIHwgbnVtYmVyO1xuICBzZXJ2ZXJQYWdpbmF0aW9uPzogYm9vbGVhbjtcbiAgb25TZXJ2ZXJQYWdpbmF0aW9uQ2hhbmdlOiAocGFnZU51bWJlcjogbnVtYmVyLCBwYWdlU2l6ZTogbnVtYmVyKSA9PiB2b2lkO1xuICBzZXJ2ZXJQYWdpbmF0aW9uRGF0YTogeyBwYWdlU2l6ZT86IG51bWJlcjsgY3VycmVudFBhZ2U/OiBudW1iZXIgfTtcbiAgcGFnZVNpemU/OiBudW1iZXI7XG4gIG5vUmVzdWx0cz86IHN0cmluZyB8ICgoZmlsdGVyU3RyaW5nOiBzdHJpbmcpID0+IFJlYWN0Tm9kZSk7XG4gIHN0aWNreT86IGJvb2xlYW47XG4gIHJvd0NvdW50OiBudW1iZXI7XG4gIHdyYXBwZXJSZWY/OiBNdXRhYmxlUmVmT2JqZWN0PEhUTUxEaXZFbGVtZW50Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZW5kZXJIVE1MQ2VsbFByb3BzIGV4dGVuZHMgSFRNTFByb3BzPEhUTUxUYWJsZUNlbGxFbGVtZW50PiB7XG4gIGNlbGxDb250ZW50OiBSZWFjdE5vZGU7XG59XG5cbi8vIEJlIHN1cmUgdG8gcGFzcyBvdXIgdXBkYXRlTXlEYXRhIGFuZCB0aGUgc2tpcFJlc2V0IG9wdGlvblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRGF0YVRhYmxlPEQgZXh0ZW5kcyBvYmplY3Q+KHtcbiAgdGFibGVDbGFzc05hbWUsXG4gIGNvbHVtbnMsXG4gIGRhdGEsXG4gIHNlcnZlclBhZ2luYXRpb25EYXRhLFxuICB3aWR0aDogaW5pdGlhbFdpZHRoID0gJzEwMCUnLFxuICBoZWlnaHQ6IGluaXRpYWxIZWlnaHQgPSAzMDAsXG4gIHBhZ2VTaXplOiBpbml0aWFsUGFnZVNpemUgPSAwLFxuICBpbml0aWFsU3RhdGU6IGluaXRpYWxTdGF0ZV8gPSB7fSxcbiAgcGFnZVNpemVPcHRpb25zID0gUEFHRV9TSVpFX09QVElPTlMsXG4gIG1heFBhZ2VJdGVtQ291bnQgPSA5LFxuICBzdGlja3k6IGRvU3RpY2t5LFxuICBzZWFyY2hJbnB1dCA9IHRydWUsXG4gIG9uU2VydmVyUGFnaW5hdGlvbkNoYW5nZSxcbiAgcm93Q291bnQsXG4gIHNlbGVjdFBhZ2VTaXplLFxuICBub1Jlc3VsdHM6IG5vUmVzdWx0c1RleHQgPSAnTm8gZGF0YSBmb3VuZCcsXG4gIGhvb2tzLFxuICBzZXJ2ZXJQYWdpbmF0aW9uLFxuICB3cmFwcGVyUmVmOiB1c2VyV3JhcHBlclJlZixcbiAgLi4ubW9yZVVzZVRhYmxlT3B0aW9uc1xufTogRGF0YVRhYmxlUHJvcHM8RD4pOiBKU1guRWxlbWVudCB7XG4gIGNvbnN0IHRhYmxlSG9va3M6IFBsdWdpbkhvb2s8RD5bXSA9IFtcbiAgICB1c2VHbG9iYWxGaWx0ZXIsXG4gICAgdXNlU29ydEJ5LFxuICAgIHVzZVBhZ2luYXRpb24sXG4gICAgZG9TdGlja3kgPyB1c2VTdGlja3kgOiBbXSxcbiAgICBob29rcyB8fCBbXSxcbiAgXS5mbGF0KCk7XG4gIGNvbnN0IHJlc3VsdHNTaXplID0gc2VydmVyUGFnaW5hdGlvbiA/IHJvd0NvdW50IDogZGF0YS5sZW5ndGg7XG4gIGNvbnN0IHNvcnRCeVJlZiA9IHVzZVJlZihbXSk7IC8vIGNhY2hlIGluaXRpYWwgYHNvcnRieWAgc28gc29ydGluZyBkb2Vzbid0IHRyaWdnZXIgcGFnZSByZXNldFxuICBjb25zdCBwYWdlU2l6ZVJlZiA9IHVzZVJlZihbaW5pdGlhbFBhZ2VTaXplLCByZXN1bHRzU2l6ZV0pO1xuICBjb25zdCBoYXNQYWdpbmF0aW9uID0gaW5pdGlhbFBhZ2VTaXplID4gMCAmJiByZXN1bHRzU2l6ZSA+IDA7IC8vIHBhZ2VTaXplID09IDAgbWVhbnMgbm8gcGFnaW5hdGlvblxuICBjb25zdCBoYXNHbG9iYWxDb250cm9sID0gaGFzUGFnaW5hdGlvbiB8fCAhIXNlYXJjaElucHV0O1xuICBjb25zdCBpbml0aWFsU3RhdGUgPSB7XG4gICAgLi4uaW5pdGlhbFN0YXRlXyxcbiAgICAvLyB6ZXJvIGxlbmd0aCBtZWFucyBhbGwgcGFnZXMsIHRoZSBgdXNlUGFnaW5hdGlvbmAgcGx1Z2luIGRvZXMgbm90XG4gICAgLy8gdW5kZXJzdGFuZCBwYWdlU2l6ZSA9IDBcbiAgICBzb3J0Qnk6IHNvcnRCeVJlZi5jdXJyZW50LFxuICAgIHBhZ2VTaXplOiBpbml0aWFsUGFnZVNpemUgPiAwID8gaW5pdGlhbFBhZ2VTaXplIDogcmVzdWx0c1NpemUgfHwgMTAsXG4gIH07XG5cbiAgY29uc3QgZGVmYXVsdFdyYXBwZXJSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpO1xuICBjb25zdCBnbG9iYWxDb250cm9sUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTtcbiAgY29uc3QgcGFnaW5hdGlvblJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCk7XG4gIGNvbnN0IHdyYXBwZXJSZWYgPSB1c2VyV3JhcHBlclJlZiB8fCBkZWZhdWx0V3JhcHBlclJlZjtcblxuICBjb25zdCBkZWZhdWx0R2V0VGFibGVTaXplID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmICh3cmFwcGVyUmVmLmN1cnJlbnQpIHtcbiAgICAgIC8vIGBpbml0aWFsV2lkdGhgIGFuZCBgaW5pdGlhbEhlaWdodGAgY291bGQgYmUgYWxzbyBwYXJhbWV0ZXJzIGxpa2UgYDEwMCVgXG4gICAgICAvLyBgTnVtYmVyYCByZWF0dXJucyBgTmFOYCBvbiB0aGVtLCB0aGVuIHdlIGZhbGxiYWNrIHRvIGNvbXB1dGVkIHNpemVcbiAgICAgIGNvbnN0IHdpZHRoID0gTnVtYmVyKGluaXRpYWxXaWR0aCkgfHwgd3JhcHBlclJlZi5jdXJyZW50LmNsaWVudFdpZHRoO1xuICAgICAgY29uc3QgaGVpZ2h0ID1cbiAgICAgICAgKE51bWJlcihpbml0aWFsSGVpZ2h0KSB8fCB3cmFwcGVyUmVmLmN1cnJlbnQuY2xpZW50SGVpZ2h0KSAtXG4gICAgICAgIChnbG9iYWxDb250cm9sUmVmLmN1cnJlbnQ/LmNsaWVudEhlaWdodCB8fCAwKSAtXG4gICAgICAgIChwYWdpbmF0aW9uUmVmLmN1cnJlbnQ/LmNsaWVudEhlaWdodCB8fCAwKTtcbiAgICAgIHJldHVybiB7IHdpZHRoLCBoZWlnaHQgfTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtcbiAgICBpbml0aWFsSGVpZ2h0LFxuICAgIGluaXRpYWxXaWR0aCxcbiAgICB3cmFwcGVyUmVmLFxuICAgIGhhc1BhZ2luYXRpb24sXG4gICAgaGFzR2xvYmFsQ29udHJvbCxcbiAgICBwYWdpbmF0aW9uUmVmLFxuICAgIHJlc3VsdHNTaXplLFxuICAgIEpTT04uc3RyaW5naWZ5KHNlcnZlclBhZ2luYXRpb25EYXRhKSxcbiAgXSk7XG5cbiAgY29uc3QgZGVmYXVsdEdsb2JhbEZpbHRlcjogRmlsdGVyVHlwZTxEPiA9IHVzZUNhbGxiYWNrKFxuICAgIChyb3dzOiBSb3c8RD5bXSwgY29sdW1uSWRzOiBJZFR5cGU8RD5bXSwgZmlsdGVyVmFsdWU6IHN0cmluZykgPT4ge1xuICAgICAgLy8gYWxsb3cgc2VhcmNoaW5nIGJ5IFwiY29sMV92YWx1ZSBjb2wyX3ZhbHVlXCJcbiAgICAgIGNvbnN0IGpvaW5lZFN0cmluZyA9IChyb3c6IFJvdzxEPikgPT4gY29sdW1uSWRzLm1hcCh4ID0+IHJvdy52YWx1ZXNbeF0pLmpvaW4oJyAnKTtcbiAgICAgIHJldHVybiBtYXRjaFNvcnRlcihyb3dzLCBmaWx0ZXJWYWx1ZSwge1xuICAgICAgICBrZXlzOiBbLi4uY29sdW1uSWRzLCBqb2luZWRTdHJpbmddLFxuICAgICAgICB0aHJlc2hvbGQ6IHJhbmtpbmdzLkFDUk9OWU0sXG4gICAgICB9KSBhcyB0eXBlb2Ygcm93cztcbiAgICB9LFxuICAgIFtdLFxuICApO1xuXG4gIGNvbnN0IHtcbiAgICBnZXRUYWJsZVByb3BzLFxuICAgIGdldFRhYmxlQm9keVByb3BzLFxuICAgIHByZXBhcmVSb3csXG4gICAgaGVhZGVyR3JvdXBzLFxuICAgIHBhZ2UsXG4gICAgcGFnZUNvdW50LFxuICAgIGdvdG9QYWdlLFxuICAgIHByZUdsb2JhbEZpbHRlcmVkUm93cyxcbiAgICBzZXRHbG9iYWxGaWx0ZXIsXG4gICAgc2V0UGFnZVNpemU6IHNldFBhZ2VTaXplXyxcbiAgICB3cmFwU3RpY2t5VGFibGUsXG4gICAgc3RhdGU6IHsgcGFnZUluZGV4LCBwYWdlU2l6ZSwgZ2xvYmFsRmlsdGVyOiBmaWx0ZXJWYWx1ZSwgc3RpY2t5ID0ge30gfSxcbiAgfSA9IHVzZVRhYmxlPEQ+KFxuICAgIHtcbiAgICAgIGNvbHVtbnMsXG4gICAgICBkYXRhLFxuICAgICAgaW5pdGlhbFN0YXRlLFxuICAgICAgZ2V0VGFibGVTaXplOiBkZWZhdWx0R2V0VGFibGVTaXplLFxuICAgICAgZ2xvYmFsRmlsdGVyOiBkZWZhdWx0R2xvYmFsRmlsdGVyLFxuICAgICAgLi4ubW9yZVVzZVRhYmxlT3B0aW9ucyxcbiAgICB9LFxuICAgIC4uLnRhYmxlSG9va3MsXG4gICk7XG4gIC8vIG1ha2Ugc2V0UGFnZVNpemUgYWNjZXB0IDBcbiAgY29uc3Qgc2V0UGFnZVNpemUgPSAoc2l6ZTogbnVtYmVyKSA9PiB7XG4gICAgaWYgKHNlcnZlclBhZ2luYXRpb24pIHtcbiAgICAgIG9uU2VydmVyUGFnaW5hdGlvbkNoYW5nZSgwLCBzaXplKTtcbiAgICB9XG4gICAgLy8ga2VlcCB0aGUgb3JpZ2luYWwgc2l6ZSBpZiBkYXRhIGlzIGVtcHR5XG4gICAgaWYgKHNpemUgfHwgcmVzdWx0c1NpemUgIT09IDApIHtcbiAgICAgIHNldFBhZ2VTaXplXyhzaXplID09PSAwID8gcmVzdWx0c1NpemUgOiBzaXplKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3Qgbm9SZXN1bHRzID1cbiAgICB0eXBlb2Ygbm9SZXN1bHRzVGV4dCA9PT0gJ2Z1bmN0aW9uJyA/IG5vUmVzdWx0c1RleHQoZmlsdGVyVmFsdWUgYXMgc3RyaW5nKSA6IG5vUmVzdWx0c1RleHQ7XG5cbiAgY29uc3QgZ2V0Tm9SZXN1bHRzID0gKCkgPT4gPGRpdiBjbGFzc05hbWU9XCJkdC1uby1yZXN1bHRzXCI+e25vUmVzdWx0c308L2Rpdj47XG5cbiAgaWYgKCFjb2x1bW5zIHx8IGNvbHVtbnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICh3cmFwU3RpY2t5VGFibGUgPyB3cmFwU3RpY2t5VGFibGUoZ2V0Tm9SZXN1bHRzKSA6IGdldE5vUmVzdWx0cygpKSBhcyBKU1guRWxlbWVudDtcbiAgfVxuXG4gIGNvbnN0IHJlbmRlclRhYmxlID0gKCkgPT4gKFxuICAgIDx0YWJsZSB7Li4uZ2V0VGFibGVQcm9wcyh7IGNsYXNzTmFtZTogdGFibGVDbGFzc05hbWUgfSl9PlxuICAgICAgPHRoZWFkPlxuICAgICAgICB7aGVhZGVyR3JvdXBzLm1hcChoZWFkZXJHcm91cCA9PiB7XG4gICAgICAgICAgY29uc3QgeyBrZXk6IGhlYWRlckdyb3VwS2V5LCAuLi5oZWFkZXJHcm91cFByb3BzIH0gPSBoZWFkZXJHcm91cC5nZXRIZWFkZXJHcm91cFByb3BzKCk7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDx0ciBrZXk9e2hlYWRlckdyb3VwS2V5IHx8IGhlYWRlckdyb3VwLmlkfSB7Li4uaGVhZGVyR3JvdXBQcm9wc30+XG4gICAgICAgICAgICAgIHtoZWFkZXJHcm91cC5oZWFkZXJzLm1hcChjb2x1bW4gPT5cbiAgICAgICAgICAgICAgICBjb2x1bW4ucmVuZGVyKCdIZWFkZXInLCB7XG4gICAgICAgICAgICAgICAgICBrZXk6IGNvbHVtbi5pZCxcbiAgICAgICAgICAgICAgICAgIC4uLmNvbHVtbi5nZXRTb3J0QnlUb2dnbGVQcm9wcygpLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICApO1xuICAgICAgICB9KX1cbiAgICAgIDwvdGhlYWQ+XG4gICAgICA8dGJvZHkgey4uLmdldFRhYmxlQm9keVByb3BzKCl9PlxuICAgICAgICB7cGFnZSAmJiBwYWdlLmxlbmd0aCA+IDAgPyAoXG4gICAgICAgICAgcGFnZS5tYXAocm93ID0+IHtcbiAgICAgICAgICAgIHByZXBhcmVSb3cocm93KTtcbiAgICAgICAgICAgIGNvbnN0IHsga2V5OiByb3dLZXksIC4uLnJvd1Byb3BzIH0gPSByb3cuZ2V0Um93UHJvcHMoKTtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIDx0ciBrZXk9e3Jvd0tleSB8fCByb3cuaWR9IHsuLi5yb3dQcm9wc30+XG4gICAgICAgICAgICAgICAge3Jvdy5jZWxscy5tYXAoY2VsbCA9PiBjZWxsLnJlbmRlcignQ2VsbCcsIHsga2V5OiBjZWxsLmNvbHVtbi5pZCB9KSl9XG4gICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pXG4gICAgICAgICkgOiAoXG4gICAgICAgICAgPHRyPlxuICAgICAgICAgICAgPHRkIGNsYXNzTmFtZT1cImR0LW5vLXJlc3VsdHNcIiBjb2xTcGFuPXtjb2x1bW5zLmxlbmd0aH0+XG4gICAgICAgICAgICAgIHtub1Jlc3VsdHN9XG4gICAgICAgICAgICA8L3RkPlxuICAgICAgICAgIDwvdHI+XG4gICAgICAgICl9XG4gICAgICA8L3Rib2R5PlxuICAgIDwvdGFibGU+XG4gICk7XG5cbiAgLy8gZm9yY2UgdXBkYXRlIHRoZSBwYWdlU2l6ZSB3aGVuIGl0J3MgYmVlbiB1cGRhdGUgZnJvbSB0aGUgaW5pdGlhbCBzdGF0ZVxuICBpZiAoXG4gICAgcGFnZVNpemVSZWYuY3VycmVudFswXSAhPT0gaW5pdGlhbFBhZ2VTaXplIHx8XG4gICAgLy8gd2hlbiBpbml0aWFsUGFnZVNpemUgc3RheXMgYXMgemVybywgYnV0IHRvdGFsIG51bWJlciBvZiByZWNvcmRzIGNoYW5nZWQsXG4gICAgLy8gd2UnZCBhbHNvIG5lZWQgdG8gdXBkYXRlIHBhZ2Ugc2l6ZVxuICAgIChpbml0aWFsUGFnZVNpemUgPT09IDAgJiYgcGFnZVNpemVSZWYuY3VycmVudFsxXSAhPT0gcmVzdWx0c1NpemUpXG4gICkge1xuICAgIHBhZ2VTaXplUmVmLmN1cnJlbnQgPSBbaW5pdGlhbFBhZ2VTaXplLCByZXN1bHRzU2l6ZV07XG4gICAgc2V0UGFnZVNpemUoaW5pdGlhbFBhZ2VTaXplKTtcbiAgfVxuXG4gIGNvbnN0IHBhZ2luYXRpb25TdHlsZTogQ1NTUHJvcGVydGllcyA9IHN0aWNreS5oZWlnaHQgPyB7fSA6IHsgdmlzaWJpbGl0eTogJ2hpZGRlbicgfTtcblxuICBsZXQgcmVzdWx0UGFnZUNvdW50ID0gcGFnZUNvdW50O1xuICBsZXQgcmVzdWx0Q3VycmVudFBhZ2VTaXplID0gcGFnZVNpemU7XG4gIGxldCByZXN1bHRDdXJyZW50UGFnZSA9IHBhZ2VJbmRleDtcbiAgbGV0IHJlc3VsdE9uUGFnZUNoYW5nZTogKHBhZ2U6IG51bWJlcikgPT4gdm9pZCA9IGdvdG9QYWdlO1xuICBpZiAoc2VydmVyUGFnaW5hdGlvbikge1xuICAgIGNvbnN0IHNlcnZlclBhZ2VTaXplID0gc2VydmVyUGFnaW5hdGlvbkRhdGEucGFnZVNpemUgPz8gaW5pdGlhbFBhZ2VTaXplO1xuICAgIHJlc3VsdFBhZ2VDb3VudCA9IE1hdGguY2VpbChyb3dDb3VudCAvIHNlcnZlclBhZ2VTaXplKTtcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShyZXN1bHRQYWdlQ291bnQpKSB7XG4gICAgICByZXN1bHRQYWdlQ291bnQgPSAwO1xuICAgIH1cbiAgICByZXN1bHRDdXJyZW50UGFnZVNpemUgPSBzZXJ2ZXJQYWdlU2l6ZTtcbiAgICBjb25zdCBmb3VuZFBhZ2VTaXplSW5kZXggPSBwYWdlU2l6ZU9wdGlvbnMuZmluZEluZGV4KFxuICAgICAgKFtvcHRpb25dKSA9PiBvcHRpb24gPj0gcmVzdWx0Q3VycmVudFBhZ2VTaXplLFxuICAgICk7XG4gICAgaWYgKGZvdW5kUGFnZVNpemVJbmRleCA9PT0gLTEpIHtcbiAgICAgIHJlc3VsdEN1cnJlbnRQYWdlU2l6ZSA9IDA7XG4gICAgfVxuICAgIHJlc3VsdEN1cnJlbnRQYWdlID0gc2VydmVyUGFnaW5hdGlvbkRhdGEuY3VycmVudFBhZ2UgPz8gMDtcbiAgICByZXN1bHRPblBhZ2VDaGFuZ2UgPSAocGFnZU51bWJlcjogbnVtYmVyKSA9PlxuICAgICAgb25TZXJ2ZXJQYWdpbmF0aW9uQ2hhbmdlKHBhZ2VOdW1iZXIsIHNlcnZlclBhZ2VTaXplKTtcbiAgfVxuICByZXR1cm4gKFxuICAgIDxkaXYgcmVmPXt3cmFwcGVyUmVmfSBzdHlsZT17eyB3aWR0aDogaW5pdGlhbFdpZHRoLCBoZWlnaHQ6IGluaXRpYWxIZWlnaHQgfX0+XG4gICAgICB7aGFzR2xvYmFsQ29udHJvbCA/IChcbiAgICAgICAgPGRpdiByZWY9e2dsb2JhbENvbnRyb2xSZWZ9IGNsYXNzTmFtZT1cImZvcm0taW5saW5lIGR0LWNvbnRyb2xzXCI+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyb3dcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29sLXNtLTZcIj5cbiAgICAgICAgICAgICAge2hhc1BhZ2luYXRpb24gPyAoXG4gICAgICAgICAgICAgICAgPFNlbGVjdFBhZ2VTaXplXG4gICAgICAgICAgICAgICAgICB0b3RhbD17cmVzdWx0c1NpemV9XG4gICAgICAgICAgICAgICAgICBjdXJyZW50PXtyZXN1bHRDdXJyZW50UGFnZVNpemV9XG4gICAgICAgICAgICAgICAgICBvcHRpb25zPXtwYWdlU2l6ZU9wdGlvbnN9XG4gICAgICAgICAgICAgICAgICBzZWxlY3RSZW5kZXJlcj17dHlwZW9mIHNlbGVjdFBhZ2VTaXplID09PSAnYm9vbGVhbicgPyB1bmRlZmluZWQgOiBzZWxlY3RQYWdlU2l6ZX1cbiAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtzZXRQYWdlU2l6ZX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICApIDogbnVsbH1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAge3NlYXJjaElucHV0ID8gKFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbC1zbS02XCI+XG4gICAgICAgICAgICAgICAgPEdsb2JhbEZpbHRlcjxEPlxuICAgICAgICAgICAgICAgICAgc2VhcmNoSW5wdXQ9e3R5cGVvZiBzZWFyY2hJbnB1dCA9PT0gJ2Jvb2xlYW4nID8gdW5kZWZpbmVkIDogc2VhcmNoSW5wdXR9XG4gICAgICAgICAgICAgICAgICBwcmVHbG9iYWxGaWx0ZXJlZFJvd3M9e3ByZUdsb2JhbEZpbHRlcmVkUm93c31cbiAgICAgICAgICAgICAgICAgIHNldEdsb2JhbEZpbHRlcj17c2V0R2xvYmFsRmlsdGVyfVxuICAgICAgICAgICAgICAgICAgZmlsdGVyVmFsdWU9e2ZpbHRlclZhbHVlfVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKSA6IG51bGx9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgKSA6IG51bGx9XG4gICAgICB7d3JhcFN0aWNreVRhYmxlID8gd3JhcFN0aWNreVRhYmxlKHJlbmRlclRhYmxlKSA6IHJlbmRlclRhYmxlKCl9XG4gICAgICB7aGFzUGFnaW5hdGlvbiAmJiByZXN1bHRQYWdlQ291bnQgPiAxID8gKFxuICAgICAgICA8U2ltcGxlUGFnaW5hdGlvblxuICAgICAgICAgIHJlZj17cGFnaW5hdGlvblJlZn1cbiAgICAgICAgICBzdHlsZT17cGFnaW5hdGlvblN0eWxlfVxuICAgICAgICAgIG1heFBhZ2VJdGVtQ291bnQ9e21heFBhZ2VJdGVtQ291bnR9XG4gICAgICAgICAgcGFnZUNvdW50PXtyZXN1bHRQYWdlQ291bnR9XG4gICAgICAgICAgY3VycmVudFBhZ2U9e3Jlc3VsdEN1cnJlbnRQYWdlfVxuICAgICAgICAgIG9uUGFnZUNoYW5nZT17cmVzdWx0T25QYWdlQ2hhbmdlfVxuICAgICAgICAvPlxuICAgICAgKSA6IG51bGx9XG4gICAgPC9kaXY+XG4gICk7XG59XG4iLCJpbXBvcnQgeyBzdHlsZWQgfSBmcm9tICdAc3VwZXJzZXQtdWkvY29yZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHN0eWxlZC5kaXZgXG4gIHRhYmxlIHtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBtaW4td2lkdGg6IGF1dG87XG4gICAgbWF4LXdpZHRoOiBub25lO1xuICAgIG1hcmdpbjogMDtcbiAgfVxuXG4gIHRoLFxuICB0ZCB7XG4gICAgbWluLXdpZHRoOiA0LjNlbTtcbiAgfVxuXG4gIHRoZWFkID4gdHIgPiB0aCB7XG4gICAgcGFkZGluZy1yaWdodDogMS40ZW07XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIGJhY2tncm91bmQ6ICNmZmY7XG4gIH1cbiAgdGggc3ZnIHtcbiAgICBjb2xvcjogI2NjYztcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgYm90dG9tOiAwLjZlbTtcbiAgICByaWdodDogMC4yZW07XG4gIH1cbiAgdGguaXMtc29ydGVkIHN2ZyB7XG4gICAgY29sb3I6ICNhOGE4YTg7XG4gIH1cbiAgLnRhYmxlID4gdGJvZHkgPiB0cjpmaXJzdC1vZi10eXBlID4gdGQsXG4gIC50YWJsZSA+IHRib2R5ID4gdHI6Zmlyc3Qtb2YtdHlwZSA+IHRoIHtcbiAgICBib3JkZXItdG9wOiAwO1xuICB9XG5cbiAgLmR0LWNvbnRyb2xzIHtcbiAgICBwYWRkaW5nLWJvdHRvbTogMC42NWVtO1xuICB9XG4gIC5kdC1tZXRyaWMge1xuICAgIHRleHQtYWxpZ246IHJpZ2h0O1xuICB9XG4gIC5kdC1pcy1udWxsIHtcbiAgICBjb2xvcjogJHsoeyB0aGVtZTogeyBjb2xvcnMgfSB9KSA9PiBjb2xvcnMuZ3JheXNjYWxlLmxpZ2h0MX07XG4gIH1cbiAgdGQuZHQtaXMtZmlsdGVyIHtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gIH1cbiAgdGQuZHQtaXMtZmlsdGVyOmhvdmVyIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBsaW5lbjtcbiAgfVxuICB0ZC5kdC1pcy1hY3RpdmUtZmlsdGVyLFxuICB0ZC5kdC1pcy1hY3RpdmUtZmlsdGVyOmhvdmVyIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBsaWdodGN5YW47XG4gIH1cblxuICAuZHQtZ2xvYmFsLWZpbHRlciB7XG4gICAgZmxvYXQ6IHJpZ2h0O1xuICB9XG5cbiAgLmR0LXBhZ2luYXRpb24ge1xuICAgIHRleHQtYWxpZ246IHJpZ2h0O1xuICAgIC8qIHVzZSBwYWRkaW5nIGluc3RlYWQgb2YgbWFyZ2luIHNvIGNsaWVudEhlaWdodCBjYW4gY2FwdHVyZSBpdCAqL1xuICAgIHBhZGRpbmctdG9wOiAwLjVlbTtcbiAgfVxuICAuZHQtcGFnaW5hdGlvbiAucGFnaW5hdGlvbiB7XG4gICAgbWFyZ2luOiAwO1xuICB9XG5cbiAgLnBhZ2luYXRpb24gPiBsaSA+IHNwYW4uZHQtcGFnaW5hdGlvbi1lbGxpcHNpczpmb2N1cyxcbiAgLnBhZ2luYXRpb24gPiBsaSA+IHNwYW4uZHQtcGFnaW5hdGlvbi1lbGxpcHNpczpob3ZlciB7XG4gICAgYmFja2dyb3VuZDogI2ZmZjtcbiAgfVxuXG4gIC5kdC1uby1yZXN1bHRzIHtcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgcGFkZGluZzogMWVtIDAuNmVtO1xuICB9XG5gO1xuIiwiLyoqXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgRmlsdGVyWFNTLCBnZXREZWZhdWx0V2hpdGVMaXN0IH0gZnJvbSAneHNzJztcbmltcG9ydCB7IERhdGFSZWNvcmRWYWx1ZSB9IGZyb20gJ0BzdXBlcnNldC11aS9jb3JlJztcbmltcG9ydCB7IERhdGFDb2x1bW5NZXRhIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5jb25zdCB4c3MgPSBuZXcgRmlsdGVyWFNTKHtcbiAgd2hpdGVMaXN0OiB7XG4gICAgLi4uZ2V0RGVmYXVsdFdoaXRlTGlzdCgpLFxuICAgIHNwYW46IFsnc3R5bGUnLCAnY2xhc3MnLCAndGl0bGUnXSxcbiAgICBkaXY6IFsnc3R5bGUnLCAnY2xhc3MnXSxcbiAgICBhOiBbJ3N0eWxlJywgJ2NsYXNzJywgJ2hyZWYnLCAndGl0bGUnLCAndGFyZ2V0J10sXG4gICAgaW1nOiBbJ3N0eWxlJywgJ2NsYXNzJywgJ3NyYycsICdhbHQnLCAndGl0bGUnLCAnd2lkdGgnLCAnaGVpZ2h0J10sXG4gIH0sXG4gIHN0cmlwSWdub3JlVGFnOiB0cnVlLFxuICBjc3M6IGZhbHNlLFxufSk7XG5cbmZ1bmN0aW9uIGlzUHJvYmFibHlIVE1MKHRleHQ6IHN0cmluZykge1xuICByZXR1cm4gLzxbXj5dKz4vLnRlc3QodGV4dCk7XG59XG4vKipcbiAqIEZvcm1hdCB0ZXh0IGZvciBjZWxsIHZhbHVlLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmb3JtYXRWYWx1ZShcbiAgeyBmb3JtYXR0ZXIgfTogRGF0YUNvbHVtbk1ldGEsXG4gIHZhbHVlOiBEYXRhUmVjb3JkVmFsdWUsXG4pOiBbYm9vbGVhbiwgc3RyaW5nLCBzdHJpbmcgfCBudWxsXSB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBbZmFsc2UsICdOL0EnLCAnZHQtaXMtbnVsbCddO1xuICB9XG4gIGlmIChmb3JtYXR0ZXIpIHtcbiAgICAvLyBpbiBjYXNlIHBlcmNlbnQgbWV0cmljIGNhbiBzcGVjaWZ5IHBlcmNlbnQgZm9ybWF0IGluIHRoZSBmdXR1cmVcbiAgICByZXR1cm4gW2ZhbHNlLCBmb3JtYXR0ZXIodmFsdWUgYXMgbnVtYmVyKSwgbnVsbF07XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gaXNQcm9iYWJseUhUTUwodmFsdWUpID8gW3RydWUsIHhzcy5wcm9jZXNzKHZhbHVlKSwgbnVsbF0gOiBbZmFsc2UsIHZhbHVlLCBudWxsXTtcbiAgfVxuICByZXR1cm4gW2ZhbHNlLCB2YWx1ZS50b1N0cmluZygpLCBudWxsXTtcbn1cbiIsIi8qKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSwgdXNlTWVtbywgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBDb2x1bW5JbnN0YW5jZSwgRGVmYXVsdFNvcnRUeXBlcywgQ29sdW1uV2l0aExvb3NlQWNjZXNzb3IgfSBmcm9tICdyZWFjdC10YWJsZSc7XG5pbXBvcnQgeyBleHRlbnQgYXMgZDNFeHRlbnQsIG1heCBhcyBkM01heCB9IGZyb20gJ2QzLWFycmF5JztcbmltcG9ydCB7IEZhU29ydCwgRmFTb3J0VXAgYXMgRmFTb3J0QXNjLCBGYVNvcnREb3duIGFzIEZhU29ydERlc2MgfSBmcm9tICdyZWFjdC1pY29ucy9mYSc7XG5pbXBvcnQgeyB0LCB0biwgRGF0YVJlY29yZFZhbHVlLCBEYXRhUmVjb3JkLCBHZW5lcmljRGF0YVR5cGUgfSBmcm9tICdAc3VwZXJzZXQtdWkvY29yZSc7XG5cbmltcG9ydCB7IFRhYmxlQ2hhcnRUcmFuc2Zvcm1lZFByb3BzLCBEYXRhQ29sdW1uTWV0YSB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IERhdGFUYWJsZSwge1xuICBEYXRhVGFibGVQcm9wcyxcbiAgU2VhcmNoSW5wdXRQcm9wcyxcbiAgU2VsZWN0UGFnZVNpemVSZW5kZXJlclByb3BzLFxuICBTaXplT3B0aW9uLFxufSBmcm9tICcuL0RhdGFUYWJsZSc7XG5cbmltcG9ydCBTdHlsZXMgZnJvbSAnLi9TdHlsZXMnO1xuaW1wb3J0IGZvcm1hdFZhbHVlIGZyb20gJy4vdXRpbHMvZm9ybWF0VmFsdWUnO1xuaW1wb3J0IHsgUEFHRV9TSVpFX09QVElPTlMgfSBmcm9tICcuL2NvbnN0cyc7XG5pbXBvcnQgeyB1cGRhdGVFeHRlcm5hbEZvcm1EYXRhIH0gZnJvbSAnLi9EYXRhVGFibGUvdXRpbHMvZXh0ZXJuYWxBUElzJztcblxudHlwZSBWYWx1ZVJhbmdlID0gW251bWJlciwgbnVtYmVyXTtcblxuLyoqXG4gKiBSZXR1cm4gc29ydFR5cGUgYmFzZWQgb24gZGF0YSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGdldFNvcnRUeXBlQnlEYXRhVHlwZShkYXRhVHlwZTogR2VuZXJpY0RhdGFUeXBlKTogRGVmYXVsdFNvcnRUeXBlcyB7XG4gIGlmIChkYXRhVHlwZSA9PT0gR2VuZXJpY0RhdGFUeXBlLlRFTVBPUkFMKSB7XG4gICAgcmV0dXJuICdkYXRldGltZSc7XG4gIH1cbiAgaWYgKGRhdGFUeXBlID09PSBHZW5lcmljRGF0YVR5cGUuU1RSSU5HKSB7XG4gICAgcmV0dXJuICdhbHBoYW51bWVyaWMnO1xuICB9XG4gIHJldHVybiAnYmFzaWMnO1xufVxuXG4vKipcbiAqIENlbGwgYmFja2dyb3VuZCB0byByZW5kZXIgY29sdW1ucyBhcyBob3Jpem9udGFsIGJhciBjaGFydFxuICovXG5mdW5jdGlvbiBjZWxsQmFyKHtcbiAgdmFsdWUsXG4gIHZhbHVlUmFuZ2UsXG4gIGNvbG9yUG9zaXRpdmVOZWdhdGl2ZSA9IGZhbHNlLFxuICBhbGlnblBvc2l0aXZlTmVnYXRpdmUsXG59OiB7XG4gIHZhbHVlOiBudW1iZXI7XG4gIHZhbHVlUmFuZ2U6IFZhbHVlUmFuZ2U7XG4gIGNvbG9yUG9zaXRpdmVOZWdhdGl2ZTogYm9vbGVhbjtcbiAgYWxpZ25Qb3NpdGl2ZU5lZ2F0aXZlOiBib29sZWFuO1xufSkge1xuICBjb25zdCBbbWluVmFsdWUsIG1heFZhbHVlXSA9IHZhbHVlUmFuZ2U7XG4gIGNvbnN0IHIgPSBjb2xvclBvc2l0aXZlTmVnYXRpdmUgJiYgdmFsdWUgPCAwID8gMTUwIDogMDtcbiAgaWYgKGFsaWduUG9zaXRpdmVOZWdhdGl2ZSkge1xuICAgIGNvbnN0IHBlcmMgPSBNYXRoLmFicyhNYXRoLnJvdW5kKCh2YWx1ZSAvIG1heFZhbHVlKSAqIDEwMCkpO1xuICAgIC8vIFRoZSAwLjAxIHRvIDAuMDAxIGlzIGEgd29ya2Fyb3VuZCBmb3Igd2hhdCBhcHBlYXJzIHRvIGJlIGFcbiAgICAvLyBDU1MgcmVuZGVyaW5nIGJ1ZyBvbiBmbGF0LCB0cmFuc3BhcmVudCBjb2xvcnNcbiAgICByZXR1cm4gKFxuICAgICAgYGxpbmVhci1ncmFkaWVudCh0byByaWdodCwgcmdiYSgke3J9LDAsMCwwLjIpLCByZ2JhKCR7cn0sMCwwLDAuMikgJHtwZXJjfSUsIGAgK1xuICAgICAgYHJnYmEoMCwwLDAsMC4wMSkgJHtwZXJjfSUsIHJnYmEoMCwwLDAsMC4wMDEpIDEwMCUpYFxuICAgICk7XG4gIH1cbiAgY29uc3QgcG9zRXh0ZW50ID0gTWF0aC5hYnMoTWF0aC5tYXgobWF4VmFsdWUsIDApKTtcbiAgY29uc3QgbmVnRXh0ZW50ID0gTWF0aC5hYnMoTWF0aC5taW4obWluVmFsdWUsIDApKTtcbiAgY29uc3QgdG90ID0gcG9zRXh0ZW50ICsgbmVnRXh0ZW50O1xuICBjb25zdCBwZXJjMSA9IE1hdGgucm91bmQoKE1hdGgubWluKG5lZ0V4dGVudCArIHZhbHVlLCBuZWdFeHRlbnQpIC8gdG90KSAqIDEwMCk7XG4gIGNvbnN0IHBlcmMyID0gTWF0aC5yb3VuZCgoTWF0aC5hYnModmFsdWUpIC8gdG90KSAqIDEwMCk7XG4gIC8vIFRoZSAwLjAxIHRvIDAuMDAxIGlzIGEgd29ya2Fyb3VuZCBmb3Igd2hhdCBhcHBlYXJzIHRvIGJlIGFcbiAgLy8gQ1NTIHJlbmRlcmluZyBidWcgb24gZmxhdCwgdHJhbnNwYXJlbnQgY29sb3JzXG4gIHJldHVybiAoXG4gICAgYGxpbmVhci1ncmFkaWVudCh0byByaWdodCwgcmdiYSgwLDAsMCwwLjAxKSwgcmdiYSgwLDAsMCwwLjAwMSkgJHtwZXJjMX0lLCBgICtcbiAgICBgcmdiYSgke3J9LDAsMCwwLjIpICR7cGVyYzF9JSwgcmdiYSgke3J9LDAsMCwwLjIpICR7cGVyYzEgKyBwZXJjMn0lLCBgICtcbiAgICBgcmdiYSgwLDAsMCwwLjAxKSAke3BlcmMxICsgcGVyYzJ9JSwgcmdiYSgwLDAsMCwwLjAwMSkgMTAwJSlgXG4gICk7XG59XG5cbmZ1bmN0aW9uIFNvcnRJY29uPEQgZXh0ZW5kcyBvYmplY3Q+KHsgY29sdW1uIH06IHsgY29sdW1uOiBDb2x1bW5JbnN0YW5jZTxEPiB9KSB7XG4gIGNvbnN0IHsgaXNTb3J0ZWQsIGlzU29ydGVkRGVzYyB9ID0gY29sdW1uO1xuICBsZXQgc29ydEljb24gPSA8RmFTb3J0IC8+O1xuICBpZiAoaXNTb3J0ZWQpIHtcbiAgICBzb3J0SWNvbiA9IGlzU29ydGVkRGVzYyA/IDxGYVNvcnREZXNjIC8+IDogPEZhU29ydEFzYyAvPjtcbiAgfVxuICByZXR1cm4gc29ydEljb247XG59XG5cbmZ1bmN0aW9uIFNlYXJjaElucHV0KHsgY291bnQsIHZhbHVlLCBvbkNoYW5nZSB9OiBTZWFyY2hJbnB1dFByb3BzKSB7XG4gIHJldHVybiAoXG4gICAgPHNwYW4gY2xhc3NOYW1lPVwiZHQtZ2xvYmFsLWZpbHRlclwiPlxuICAgICAge3QoJ1NlYXJjaCcpfXsnICd9XG4gICAgICA8aW5wdXRcbiAgICAgICAgY2xhc3NOYW1lPVwiZm9ybS1jb250cm9sIGlucHV0LXNtXCJcbiAgICAgICAgcGxhY2Vob2xkZXI9e3RuKCdzZWFyY2gubnVtX3JlY29yZHMnLCBjb3VudCl9XG4gICAgICAgIHZhbHVlPXt2YWx1ZX1cbiAgICAgICAgb25DaGFuZ2U9e29uQ2hhbmdlfVxuICAgICAgLz5cbiAgICA8L3NwYW4+XG4gICk7XG59XG5cbmZ1bmN0aW9uIFNlbGVjdFBhZ2VTaXplKHsgb3B0aW9ucywgY3VycmVudCwgb25DaGFuZ2UgfTogU2VsZWN0UGFnZVNpemVSZW5kZXJlclByb3BzKSB7XG4gIHJldHVybiAoXG4gICAgPHNwYW4gY2xhc3NOYW1lPVwiZHQtc2VsZWN0LXBhZ2Utc2l6ZSBmb3JtLWlubGluZVwiPlxuICAgICAge3QoJ3BhZ2Vfc2l6ZS5zaG93Jyl9eycgJ31cbiAgICAgIDxzZWxlY3RcbiAgICAgICAgY2xhc3NOYW1lPVwiZm9ybS1jb250cm9sIGlucHV0LXNtXCJcbiAgICAgICAgdmFsdWU9e2N1cnJlbnR9XG4gICAgICAgIG9uQmx1cj17KCkgPT4ge319XG4gICAgICAgIG9uQ2hhbmdlPXtlID0+IHtcbiAgICAgICAgICBvbkNoYW5nZShOdW1iZXIoKGUudGFyZ2V0IGFzIEhUTUxTZWxlY3RFbGVtZW50KS52YWx1ZSkpO1xuICAgICAgICB9fVxuICAgICAgPlxuICAgICAgICB7b3B0aW9ucy5tYXAob3B0aW9uID0+IHtcbiAgICAgICAgICBjb25zdCBbc2l6ZSwgdGV4dF0gPSBBcnJheS5pc0FycmF5KG9wdGlvbikgPyBvcHRpb24gOiBbb3B0aW9uLCBvcHRpb25dO1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8b3B0aW9uIGtleT17c2l6ZX0gdmFsdWU9e3NpemV9PlxuICAgICAgICAgICAgICB7dGV4dH1cbiAgICAgICAgICAgIDwvb3B0aW9uPlxuICAgICAgICAgICk7XG4gICAgICAgIH0pfVxuICAgICAgPC9zZWxlY3Q+eycgJ31cbiAgICAgIHt0KCdwYWdlX3NpemUuZW50cmllcycpfVxuICAgIDwvc3Bhbj5cbiAgKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gVGFibGVDaGFydDxEIGV4dGVuZHMgRGF0YVJlY29yZCA9IERhdGFSZWNvcmQ+KFxuICBwcm9wczogVGFibGVDaGFydFRyYW5zZm9ybWVkUHJvcHM8RD4gJiB7XG4gICAgc3RpY2t5PzogRGF0YVRhYmxlUHJvcHM8RD5bJ3N0aWNreSddO1xuICB9LFxuKSB7XG4gIGNvbnN0IHtcbiAgICBoZWlnaHQsXG4gICAgd2lkdGgsXG4gICAgZGF0YSxcbiAgICBpc1Jhd1JlY29yZHMsXG4gICAgcm93Q291bnQgPSAwLFxuICAgIGNvbHVtbnM6IGNvbHVtbnNNZXRhLFxuICAgIGFsaWduUG9zaXRpdmVOZWdhdGl2ZSA9IGZhbHNlLFxuICAgIGNvbG9yUG9zaXRpdmVOZWdhdGl2ZSA9IGZhbHNlLFxuICAgIGluY2x1ZGVTZWFyY2ggPSBmYWxzZSxcbiAgICBwYWdlU2l6ZSA9IDAsXG4gICAgc2VydmVyUGFnaW5hdGlvbiA9IGZhbHNlLFxuICAgIHNlcnZlclBhZ2luYXRpb25EYXRhLFxuICAgIHNldERhdGFNYXNrLFxuICAgIHNob3dDZWxsQmFycyA9IHRydWUsXG4gICAgZW1pdEZpbHRlciA9IGZhbHNlLFxuICAgIHNvcnREZXNjID0gZmFsc2UsXG4gICAgb25DaGFuZ2VGaWx0ZXIsXG4gICAgZmlsdGVyczogaW5pdGlhbEZpbHRlcnMsXG4gICAgc3RpY2t5ID0gdHJ1ZSwgLy8gd2hldGhlciB0byB1c2Ugc3RpY2t5IGhlYWRlclxuICB9ID0gcHJvcHM7XG5cbiAgY29uc3QgW2ZpbHRlcnMsIHNldEZpbHRlcnNdID0gdXNlU3RhdGUoaW5pdGlhbEZpbHRlcnMpO1xuXG4gIC8vIG9ubHkgdGFrZSByZWxldmFudCBwYWdlIHNpemUgb3B0aW9uc1xuICBjb25zdCBwYWdlU2l6ZU9wdGlvbnMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBnZXRTZXJ2ZXJQYWdpbmF0aW9uID0gKG46IG51bWJlcikgPT4gbiA8PSByb3dDb3VudDtcbiAgICByZXR1cm4gUEFHRV9TSVpFX09QVElPTlMuZmlsdGVyKChbbl0pID0+XG4gICAgICBzZXJ2ZXJQYWdpbmF0aW9uID8gZ2V0U2VydmVyUGFnaW5hdGlvbihuKSA6IG4gPD0gMiAqIGRhdGEubGVuZ3RoLFxuICAgICkgYXMgU2l6ZU9wdGlvbltdO1xuICB9LCBbZGF0YS5sZW5ndGgsIHJvd0NvdW50XSk7XG5cbiAgY29uc3QgZ2V0VmFsdWVSYW5nZSA9IHVzZUNhbGxiYWNrKFxuICAgIGZ1bmN0aW9uIGdldFZhbHVlUmFuZ2Uoa2V5OiBzdHJpbmcpIHtcbiAgICAgIGlmICh0eXBlb2YgZGF0YT8uWzBdPy5ba2V5XSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgY29uc3QgbnVtcyA9IGRhdGEubWFwKHJvdyA9PiByb3dba2V5XSkgYXMgbnVtYmVyW107XG4gICAgICAgIHJldHVybiAoYWxpZ25Qb3NpdGl2ZU5lZ2F0aXZlXG4gICAgICAgICAgPyBbMCwgZDNNYXgobnVtcy5tYXAoTWF0aC5hYnMpKV1cbiAgICAgICAgICA6IGQzRXh0ZW50KG51bXMpKSBhcyBWYWx1ZVJhbmdlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBbYWxpZ25Qb3NpdGl2ZU5lZ2F0aXZlLCBkYXRhXSxcbiAgKTtcblxuICBjb25zdCBpc0FjdGl2ZUZpbHRlclZhbHVlID0gdXNlQ2FsbGJhY2soXG4gICAgZnVuY3Rpb24gaXNBY3RpdmVGaWx0ZXJWYWx1ZShrZXk6IHN0cmluZywgdmFsOiBEYXRhUmVjb3JkVmFsdWUpIHtcbiAgICAgIHJldHVybiAhIWZpbHRlcnMgJiYgZmlsdGVyc1trZXldPy5pbmNsdWRlcyh2YWwpO1xuICAgIH0sXG4gICAgW2ZpbHRlcnNdLFxuICApO1xuXG4gIGNvbnN0IHRvZ2dsZUZpbHRlciA9IHVzZUNhbGxiYWNrKFxuICAgIGZ1bmN0aW9uIHRvZ2dsZUZpbHRlcihrZXk6IHN0cmluZywgdmFsOiBEYXRhUmVjb3JkVmFsdWUpIHtcbiAgICAgIGNvbnN0IHVwZGF0ZWRGaWx0ZXJzID0geyAuLi4oZmlsdGVycyB8fCB7fSkgfTtcbiAgICAgIGlmIChmaWx0ZXJzICYmIGlzQWN0aXZlRmlsdGVyVmFsdWUoa2V5LCB2YWwpKSB7XG4gICAgICAgIHVwZGF0ZWRGaWx0ZXJzW2tleV0gPSBmaWx0ZXJzW2tleV0uZmlsdGVyKCh4OiBEYXRhUmVjb3JkVmFsdWUpID0+IHggIT09IHZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cGRhdGVkRmlsdGVyc1trZXldID0gWy4uLihmaWx0ZXJzPy5ba2V5XSB8fCBbXSksIHZhbF07XG4gICAgICB9XG4gICAgICBzZXRGaWx0ZXJzKHVwZGF0ZWRGaWx0ZXJzKTtcbiAgICAgIGlmIChvbkNoYW5nZUZpbHRlcikge1xuICAgICAgICBvbkNoYW5nZUZpbHRlcih1cGRhdGVkRmlsdGVycyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbZmlsdGVycywgaXNBY3RpdmVGaWx0ZXJWYWx1ZSwgb25DaGFuZ2VGaWx0ZXJdLFxuICApO1xuXG4gIGNvbnN0IGdldENvbHVtbkNvbmZpZ3MgPSB1c2VDYWxsYmFjayhcbiAgICAoY29sdW1uOiBEYXRhQ29sdW1uTWV0YSwgaTogbnVtYmVyKTogQ29sdW1uV2l0aExvb3NlQWNjZXNzb3I8RD4gPT4ge1xuICAgICAgY29uc3QgeyBrZXksIGxhYmVsLCBkYXRhVHlwZSwgaXNNZXRyaWMgfSA9IGNvbHVtbjtcbiAgICAgIGxldCBjbGFzc05hbWUgPSAnJztcbiAgICAgIGlmIChkYXRhVHlwZSA9PT0gR2VuZXJpY0RhdGFUeXBlLk5VTUVSSUMpIHtcbiAgICAgICAgY2xhc3NOYW1lICs9ICcgZHQtbWV0cmljJztcbiAgICAgIH0gZWxzZSBpZiAoZW1pdEZpbHRlcikge1xuICAgICAgICBjbGFzc05hbWUgKz0gJyBkdC1pcy1maWx0ZXInO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWVSYW5nZSA9IHNob3dDZWxsQmFycyAmJiAoaXNNZXRyaWMgfHwgaXNSYXdSZWNvcmRzKSAmJiBnZXRWYWx1ZVJhbmdlKGtleSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZDogU3RyaW5nKGkpLCAvLyB0byBhbGxvdyBkdXBsaWNhdGUgY29sdW1uIGtleXNcbiAgICAgICAgLy8gbXVzdCB1c2UgY3VzdG9tIGFjY2Vzc29yIHRvIGFsbG93IGAuYCBpbiBjb2x1bW4gbmFtZXNcbiAgICAgICAgLy8gdHlwaW5nIGlzIGluY29ycmVjdCBpbiBjdXJyZW50IHZlcnNpb24gb2YgYEB0eXBlcy9yZWFjdC10YWJsZWBcbiAgICAgICAgLy8gc28gd2UgYXNrIFRTIG5vdCB0byBjaGVjay5cbiAgICAgICAgYWNjZXNzb3I6ICgoZGF0dW06IEQpID0+IGRhdHVtW2tleV0pIGFzIG5ldmVyLFxuICAgICAgICBDZWxsOiAoeyB2YWx1ZSB9OiB7IGNvbHVtbjogQ29sdW1uSW5zdGFuY2U8RD47IHZhbHVlOiBEYXRhUmVjb3JkVmFsdWUgfSkgPT4ge1xuICAgICAgICAgIGNvbnN0IFtpc0h0bWwsIHRleHQsIGN1c3RvbUNsYXNzTmFtZV0gPSBmb3JtYXRWYWx1ZShjb2x1bW4sIHZhbHVlKTtcbiAgICAgICAgICBjb25zdCBzdHlsZSA9IHtcbiAgICAgICAgICAgIGJhY2tncm91bmQ6IHZhbHVlUmFuZ2VcbiAgICAgICAgICAgICAgPyBjZWxsQmFyKHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSBhcyBudW1iZXIsXG4gICAgICAgICAgICAgICAgICB2YWx1ZVJhbmdlLFxuICAgICAgICAgICAgICAgICAgYWxpZ25Qb3NpdGl2ZU5lZ2F0aXZlLFxuICAgICAgICAgICAgICAgICAgY29sb3JQb3NpdGl2ZU5lZ2F0aXZlLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3QgaHRtbCA9IGlzSHRtbCA/IHsgX19odG1sOiB0ZXh0IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgY29uc3QgY2VsbFByb3BzID0ge1xuICAgICAgICAgICAgLy8gc2hvdyByYXcgbnVtYmVyIGluIHRpdGxlIGluIGNhc2Ugb2YgbnVtZXJpYyB2YWx1ZXNcbiAgICAgICAgICAgIHRpdGxlOiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInID8gU3RyaW5nKHZhbHVlKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG9uQ2xpY2s6IGVtaXRGaWx0ZXIgJiYgIXZhbHVlUmFuZ2UgPyAoKSA9PiB0b2dnbGVGaWx0ZXIoa2V5LCB2YWx1ZSkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjbGFzc05hbWU6IGAke2NsYXNzTmFtZX0gJHtjdXN0b21DbGFzc05hbWUgfHwgJyd9ICR7XG4gICAgICAgICAgICAgIGlzQWN0aXZlRmlsdGVyVmFsdWUoa2V5LCB2YWx1ZSkgPyAnIGR0LWlzLWFjdGl2ZS1maWx0ZXInIDogJydcbiAgICAgICAgICAgIH1gLFxuICAgICAgICAgICAgc3R5bGUsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoaHRtbCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L25vLWRhbmdlclxuICAgICAgICAgICAgcmV0dXJuIDx0ZCB7Li4uY2VsbFByb3BzfSBkYW5nZXJvdXNseVNldElubmVySFRNTD17aHRtbH0gLz47XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIElmIGNlbGxQcm9wcyByZW5kZXJlcyB0ZXh0Q29udGVudCBhbHJlYWR5LCB0aGVuIHdlIGRvbid0IGhhdmUgdG9cbiAgICAgICAgICAvLyByZW5kZXIgYENlbGxgLiBUaGlzIHNhdmVzIHNvbWUgdGltZSBmb3IgbGFyZ2UgdGFibGVzLlxuICAgICAgICAgIHJldHVybiA8dGQgey4uLmNlbGxQcm9wc30+e3RleHR9PC90ZD47XG4gICAgICAgIH0sXG4gICAgICAgIEhlYWRlcjogKHsgY29sdW1uOiBjb2wsIG9uQ2xpY2ssIHN0eWxlIH0pID0+IChcbiAgICAgICAgICA8dGhcbiAgICAgICAgICAgIHRpdGxlPVwiU2hpZnQgKyBDbGljayB0byBzb3J0IGJ5IG11bHRpcGxlIGNvbHVtbnNcIlxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjb2wuaXNTb3J0ZWQgPyBgJHtjbGFzc05hbWUgfHwgJyd9IGlzLXNvcnRlZGAgOiBjbGFzc05hbWV9XG4gICAgICAgICAgICBzdHlsZT17c3R5bGV9XG4gICAgICAgICAgICBvbkNsaWNrPXtvbkNsaWNrfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHtsYWJlbH1cbiAgICAgICAgICAgIDxTb3J0SWNvbiBjb2x1bW49e2NvbH0gLz5cbiAgICAgICAgICA8L3RoPlxuICAgICAgICApLFxuICAgICAgICBzb3J0RGVzY0ZpcnN0OiBzb3J0RGVzYyxcbiAgICAgICAgc29ydFR5cGU6IGdldFNvcnRUeXBlQnlEYXRhVHlwZShkYXRhVHlwZSksXG4gICAgICB9O1xuICAgIH0sXG4gICAgW1xuICAgICAgYWxpZ25Qb3NpdGl2ZU5lZ2F0aXZlLFxuICAgICAgY29sb3JQb3NpdGl2ZU5lZ2F0aXZlLFxuICAgICAgZW1pdEZpbHRlcixcbiAgICAgIGdldFZhbHVlUmFuZ2UsXG4gICAgICBpc0FjdGl2ZUZpbHRlclZhbHVlLFxuICAgICAgc2hvd0NlbGxCYXJzLFxuICAgICAgc29ydERlc2MsXG4gICAgICB0b2dnbGVGaWx0ZXIsXG4gICAgXSxcbiAgKTtcblxuICBjb25zdCBjb2x1bW5zID0gdXNlTWVtbygoKSA9PiBjb2x1bW5zTWV0YS5tYXAoZ2V0Q29sdW1uQ29uZmlncyksIFtjb2x1bW5zTWV0YSwgZ2V0Q29sdW1uQ29uZmlnc10pO1xuXG4gIGNvbnN0IGhhbmRsZVNlcnZlclBhZ2luYXRpb25DaGFuZ2UgPSAocGFnZU51bWJlcjogbnVtYmVyLCBwYWdlU2l6ZTogbnVtYmVyKSA9PiB7XG4gICAgdXBkYXRlRXh0ZXJuYWxGb3JtRGF0YShzZXREYXRhTWFzaywgcGFnZU51bWJlciwgcGFnZVNpemUpO1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPFN0eWxlcz5cbiAgICAgIDxEYXRhVGFibGU8RD5cbiAgICAgICAgY29sdW1ucz17Y29sdW1uc31cbiAgICAgICAgZGF0YT17ZGF0YX1cbiAgICAgICAgcm93Q291bnQ9e3Jvd0NvdW50fVxuICAgICAgICB0YWJsZUNsYXNzTmFtZT1cInRhYmxlIHRhYmxlLXN0cmlwZWQgdGFibGUtY29uZGVuc2VkXCJcbiAgICAgICAgcGFnZVNpemU9e3BhZ2VTaXplfVxuICAgICAgICBzZXJ2ZXJQYWdpbmF0aW9uRGF0YT17c2VydmVyUGFnaW5hdGlvbkRhdGF9XG4gICAgICAgIHBhZ2VTaXplT3B0aW9ucz17cGFnZVNpemVPcHRpb25zfVxuICAgICAgICB3aWR0aD17d2lkdGh9XG4gICAgICAgIGhlaWdodD17aGVpZ2h0fVxuICAgICAgICBzZXJ2ZXJQYWdpbmF0aW9uPXtzZXJ2ZXJQYWdpbmF0aW9ufVxuICAgICAgICBvblNlcnZlclBhZ2luYXRpb25DaGFuZ2U9e2hhbmRsZVNlcnZlclBhZ2luYXRpb25DaGFuZ2V9XG4gICAgICAgIC8vIDkgcGFnZSBpdGVtcyBpbiA+IDM0MHB4IHdvcmtzIHdlbGwgZXZlbiBmb3IgMTAwKyBwYWdlc1xuICAgICAgICBtYXhQYWdlSXRlbUNvdW50PXt3aWR0aCA+IDM0MCA/IDkgOiA3fVxuICAgICAgICBub1Jlc3VsdHM9eyhmaWx0ZXI6IHN0cmluZykgPT4gdChmaWx0ZXIgPyAnTm8gbWF0Y2hpbmcgcmVjb3JkcyBmb3VuZCcgOiAnTm8gcmVjb3JkcyBmb3VuZCcpfVxuICAgICAgICBzZWFyY2hJbnB1dD17aW5jbHVkZVNlYXJjaCAmJiBTZWFyY2hJbnB1dH1cbiAgICAgICAgc2VsZWN0UGFnZVNpemU9e3BhZ2VTaXplICE9PSBudWxsICYmIFNlbGVjdFBhZ2VTaXplfVxuICAgICAgICAvLyBub3QgaW4gdXNlIGluIFN1cGVyc2V0LCBidXQgbmVlZGVkIGZvciB1bml0IHRlc3RzXG4gICAgICAgIHN0aWNreT17c3RpY2t5fVxuICAgICAgLz5cbiAgICA8L1N0eWxlcz5cbiAgKTtcbn1cbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7O0FDbERBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTtBQUNBO0FBRUE7QUFpQkE7QUFDQTs7QUFFQTtBQUNBO0FBUUE7QUFFQTtBQU1BO0FBQ0E7QUFHQTtBQUNBO0FBSUE7QUFFQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7Ozs7OztBQy9FQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFDQTtBQUNBO0FBVUE7QUFDQTs7QUFFQTtBQUNBO0FBS0E7QUFDQTtBQUdBO0FBQ0E7QUFLQTtBQUNBO0FBRUE7QUFFQTtBQVFBO0FBQ0E7QUFDQTtBQUVBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFGQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFDQTtBQVdBO0FBQ0E7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBS0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBT0E7QUFPQTs7O0FDakdBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL0NBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTtBQUNBOztBQUVBO0FBQ0E7QUFhQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTtBQUNBO0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFDQTtBQVlBO0FBQ0E7QUFDQTtBQXFCQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBa0NBO0FBQ0E7QUFDQTtBQUlBO0FBRUE7O0FBRUE7QUFDQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBT0E7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQU1BO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQVNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdFdBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTtBQUNBO0FBUUE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF5QkE7QUFDQTs7QUFBQTtBQXNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBZ0JBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQVVBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFLQTtBQUdBO0FBU0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFXQTtBQUVBO0FBV0E7QUFDQTtBQVlBOzs7Ozs7QUN0VEE7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1DQTs7Ozs7O0FDNUVBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTtBQUNBO0FBSUE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3ZEQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFRQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBR0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFLQTtBQXNCQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7O0FBRUE7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBWUE7QUFDQTtBQUlBO0FBQ0E7QUFJQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2508\n')}}]);