(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{2470:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, "default", function() { return /* binding */ TableChart; });\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react/index.js\nvar react = __webpack_require__(0);\nvar react_default = /*#__PURE__*/__webpack_require__.n(react);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/node_modules/d3-array/src/max.js\nvar max = __webpack_require__(2461);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/node_modules/d3-array/src/extent.js\nvar extent = __webpack_require__(2462);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react-icons/fa/index.esm.js + 4 modules\nvar index_esm = __webpack_require__(2416);\n\n// EXTERNAL MODULE: ../superset-ui-core/src/query/types/QueryResponse.ts\nvar QueryResponse = __webpack_require__(172);\n\n// EXTERNAL MODULE: ../superset-ui-core/src/translation/TranslatorSingleton.ts + 1 modules\nvar TranslatorSingleton = __webpack_require__(13);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react-table/index.js\nvar react_table = __webpack_require__(2219);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/match-sorter/dist/match-sorter.esm.js\nvar match_sorter_esm = __webpack_require__(2410);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/regenerator-runtime/runtime.js\nvar runtime = __webpack_require__(295);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/DataTable/utils/useAsyncState.ts\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\n// useAsyncDebounce in dist build of `react-table` requires regeneratorRuntime\n\n/**\n * Hook useState to allow always return latest initialValue\n */\nfunction useAsyncState(initialValue, callback, wait = 200) {\n    const [value, setValue] = Object(react["useState"])(initialValue);\n    const valueRef = Object(react["useRef"])(initialValue);\n    const onChange = Object(react_table["useAsyncDebounce"])(callback, wait);\n    // sync updated initialValue\n    if (valueRef.current !== initialValue) {\n        valueRef.current = initialValue;\n        if (value !== initialValue) {\n            setValue(initialValue);\n        }\n    }\n    const setBoth = (newValue) => {\n        setValue(newValue);\n        onChange(newValue);\n    };\n    return [value, setBoth];\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/DataTable/components/GlobalFilter.tsx\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\nfunction DefaultSearchInput({ count, value, onChange }) {\n    return (react_default.a.createElement("span", { className: "dt-global-filter" },\n        "Search",\n        \' \',\n        react_default.a.createElement("input", { className: "form-control input-sm", placeholder: `${count} records...`, value: value, onChange: onChange })));\n}\n/* harmony default export */ var components_GlobalFilter = (react_default.a.memo(function GlobalFilter({ preGlobalFilteredRows, filterValue = \'\', searchInput, setGlobalFilter, }) {\n    const count = preGlobalFilteredRows.length;\n    const [value, setValue] = useAsyncState(filterValue, (newValue) => {\n        setGlobalFilter(newValue || undefined);\n    }, 200);\n    const SearchInput = searchInput || DefaultSearchInput;\n    return (react_default.a.createElement(SearchInput, { count: count, value: value, onChange: e => {\n            const target = e.target;\n            e.preventDefault();\n            setValue(target.value);\n        } }));\n}));\n\n// EXTERNAL MODULE: ../superset-ui-chart-controls/src/utils/selectOptions.ts\nvar selectOptions = __webpack_require__(177);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/DataTable/components/SelectPageSize.tsx\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\nfunction DefaultSelectRenderer({ current, options, onChange }) {\n    return (react_default.a.createElement("span", { className: "dt-select-page-size form-inline" },\n        "Show",\n        \' \',\n        react_default.a.createElement("select", { className: "form-control input-sm", value: current, onBlur: () => { }, onChange: e => {\n                onChange(Number(e.target.value));\n            } }, options.map(option => {\n            const [size, text] = Array.isArray(option) ? option : [option, option];\n            return (react_default.a.createElement("option", { key: size, value: size }, text));\n        })),\n        \' \',\n        "entries"));\n}\nfunction getOptionValue(x) {\n    return Array.isArray(x) ? x[0] : x;\n}\n/* harmony default export */ var components_SelectPageSize = (react_default.a.memo(function SelectPageSize({ total, options: sizeOptions, current: currentSize, selectRenderer, onChange, }) {\n    const sizeOptionValues = sizeOptions.map(getOptionValue);\n    let options = [...sizeOptions];\n    // insert current size to list\n    if (currentSize !== undefined &&\n        (currentSize !== total || !sizeOptionValues.includes(0)) &&\n        !sizeOptionValues.includes(currentSize)) {\n        options = [...sizeOptions];\n        options.splice(sizeOptionValues.findIndex(x => x > currentSize), 0, Object(selectOptions["a" /* formatSelectOptions */])([currentSize])[0]);\n    }\n    const current = currentSize === undefined ? sizeOptionValues[0] : currentSize;\n    const SelectRenderer = selectRenderer || DefaultSelectRenderer;\n    return react_default.a.createElement(SelectRenderer, { current: current, options: options, onChange: onChange });\n}));\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/DataTable/components/Pagination.tsx\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n// first, ..., prev, current, next, ..., last\nconst MINIMAL_PAGE_ITEM_COUNT = 7;\n/**\n * Generate numeric page items around current page.\n *   - Always include first and last page\n *   - Add ellipsis if needed\n */\nfunction generatePageItems(total, current, width) {\n    if (width < MINIMAL_PAGE_ITEM_COUNT) {\n        throw new Error(`Must allow at least ${MINIMAL_PAGE_ITEM_COUNT} page items`);\n    }\n    if (width % 2 === 0) {\n        throw new Error(`Must allow odd number of page items`);\n    }\n    if (total < width) {\n        return [...new Array(total).keys()];\n    }\n    const left = Math.max(0, Math.min(total - width, current - Math.floor(width / 2)));\n    const items = new Array(width);\n    for (let i = 0; i < width; i += 1) {\n        items[i] = i + left;\n    }\n    // replace non-ending items with placeholders\n    if (items[0] > 0) {\n        items[0] = 0;\n        items[1] = \'prev-more\';\n    }\n    if (items[items.length - 1] < total - 1) {\n        items[items.length - 1] = total - 1;\n        items[items.length - 2] = \'next-more\';\n    }\n    return items;\n}\n/* harmony default export */ var components_Pagination = (react_default.a.memo(react_default.a.forwardRef(function Pagination({ style, pageCount, currentPage = 0, maxPageItemCount = 9, onPageChange }, ref) {\n    const pageItems = generatePageItems(pageCount, currentPage, maxPageItemCount);\n    return (react_default.a.createElement("div", { ref: ref, className: "dt-pagination", style: style },\n        react_default.a.createElement("ul", { className: "pagination pagination-sm" }, pageItems.map(item => typeof item === \'number\' ? (\n        // actual page number\n        react_default.a.createElement("li", { key: item, className: currentPage === item ? \'active\' : undefined },\n            react_default.a.createElement("a", { href: `#page-${item}`, role: "button", onClick: e => {\n                    e.preventDefault();\n                    onPageChange(item);\n                } }, item + 1))) : (react_default.a.createElement("li", { key: item, className: "dt-pagination-ellipsis" },\n            react_default.a.createElement("span", null, "\\u2026")))))));\n})));\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/DataTable/utils/getScrollBarSize.ts\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nlet cached;\nconst css = (x) => x.join(\'\\n\');\nfunction getScrollBarSize(forceRefresh = false) {\n    if (typeof document === \'undefined\') {\n        return 0;\n    }\n    if (cached === undefined || forceRefresh) {\n        const inner = document.createElement(\'div\');\n        const outer = document.createElement(\'div\');\n        inner.style.cssText = css `\n      width: auto;\n      height: 100%;\n      overflow: scroll;\n    `;\n        outer.style.cssText = css `\n      position: absolute;\n      visibility: hidden;\n      overflow: hidden;\n      width: 100px;\n      height: 50px;\n    `;\n        outer.append(inner);\n        document.body.append(outer);\n        cached = outer.clientWidth - inner.clientWidth;\n        outer.remove();\n    }\n    return cached;\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/DataTable/utils/needScrollBar.ts\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/**\n * Whether a container need scroll bars when in another container.\n */\nfunction needScrollBar({ width, height, innerHeight, innerWidth, scrollBarSize, }) {\n    const hasVerticalScroll = innerHeight > height;\n    const hasHorizontalScroll = innerWidth > width - (hasVerticalScroll ? scrollBarSize : 0);\n    return [hasVerticalScroll, hasHorizontalScroll];\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/DataTable/utils/useMountedMemo.ts\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n/**\n * Execute a memoized callback only when mounted. Execute again when factory updated.\n * Returns undefined if not mounted yet.\n */\nfunction useMountedMemo(factory, deps) {\n    const mounted = Object(react["useRef"])();\n    Object(react["useLayoutEffect"])(() => {\n        mounted.current = factory;\n    });\n    return Object(react["useMemo"])(() => {\n        if (mounted.current) {\n            return factory();\n        }\n        return undefined;\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [mounted.current, mounted.current === factory, ...(deps || [])]);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/DataTable/hooks/useSticky.tsx\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\n\n\nvar ReducerActions;\n(function (ReducerActions) {\n    ReducerActions["init"] = "init";\n    ReducerActions["setStickyState"] = "setStickyState";\n})(ReducerActions || (ReducerActions = {}));\nconst sum = (a, b) => a + b;\nconst mergeStyleProp = (node, style) => ({\n    style: Object.assign(Object.assign({}, node.props.style), style),\n});\nconst fixedTableLayout = { tableLayout: \'fixed\' };\n/**\n * An HOC for generating sticky header and fixed-height scrollable area\n */\nfunction StickyWrap({ sticky = {}, width: maxWidth, height: maxHeight, children: table, setStickyState, }) {\n    if (!table || table.type !== \'table\') {\n        throw new Error(\'<StickyWrap> must have only one <table> element as child\');\n    }\n    let thead;\n    let tbody;\n    let tfoot;\n    react_default.a.Children.forEach(table.props.children, node => {\n        if (!node) {\n            return;\n        }\n        if (node.type === \'thead\') {\n            thead = node;\n        }\n        else if (node.type === \'tbody\') {\n            tbody = node;\n        }\n        else if (node.type === \'tfoot\') {\n            tfoot = node;\n        }\n    });\n    if (!thead || !tbody) {\n        throw new Error(\'<table> in <StickyWrap> must contain both thead and tbody.\');\n    }\n    const columnCount = Object(react["useMemo"])(() => {\n        const headerRows = react_default.a.Children.toArray(thead === null || thead === void 0 ? void 0 : thead.props.children).pop();\n        return headerRows.props.children.length;\n    }, [thead]);\n    const theadRef = Object(react["useRef"])(null); // original thead for layout computation\n    const tfootRef = Object(react["useRef"])(null); // original tfoot for layout computation\n    const scrollHeaderRef = Object(react["useRef"])(null); // fixed header\n    const scrollFooterRef = Object(react["useRef"])(null); // fixed footer\n    const scrollBodyRef = Object(react["useRef"])(null); // main body\n    const scrollBarSize = getScrollBarSize();\n    const { bodyHeight, columnWidths } = sticky;\n    const needSizer = !columnWidths ||\n        sticky.width !== maxWidth ||\n        sticky.height !== maxHeight ||\n        sticky.setStickyState !== setStickyState;\n    // update scrollable area and header column sizes when mounted\n    Object(react["useLayoutEffect"])(() => {\n        if (!theadRef.current) {\n            return;\n        }\n        const bodyThead = theadRef.current;\n        const theadHeight = bodyThead.clientHeight;\n        const tfootHeight = tfootRef.current ? tfootRef.current.clientHeight : 0;\n        if (!theadHeight) {\n            return;\n        }\n        const fullTableHeight = bodyThead.parentNode.clientHeight;\n        const ths = bodyThead.childNodes[0].childNodes;\n        const widths = Array.from(ths).map(th => th.clientWidth);\n        const [hasVerticalScroll, hasHorizontalScroll] = needScrollBar({\n            width: maxWidth,\n            height: maxHeight - theadHeight - tfootHeight,\n            innerHeight: fullTableHeight,\n            innerWidth: widths.reduce(sum),\n            scrollBarSize,\n        });\n        // real container height, include table header, footer and space for\n        // horizontal scroll bar\n        const realHeight = Math.min(maxHeight, hasHorizontalScroll ? fullTableHeight + scrollBarSize : fullTableHeight);\n        setStickyState({\n            hasVerticalScroll,\n            hasHorizontalScroll,\n            setStickyState,\n            width: maxWidth,\n            height: maxHeight,\n            realHeight,\n            tableHeight: fullTableHeight,\n            bodyHeight: realHeight - theadHeight - tfootHeight,\n            columnWidths: widths,\n        });\n    }, [maxWidth, maxHeight, setStickyState, scrollBarSize]);\n    let sizerTable;\n    let headerTable;\n    let footerTable;\n    let bodyTable;\n    if (needSizer) {\n        const theadWithRef = react_default.a.cloneElement(thead, { ref: theadRef });\n        const tfootWithRef = tfoot && react_default.a.cloneElement(tfoot, { ref: tfootRef });\n        sizerTable = (react_default.a.createElement("div", { key: "sizer", style: {\n                height: maxHeight,\n                overflow: \'auto\',\n                visibility: \'hidden\',\n            } }, react_default.a.cloneElement(table, {}, theadWithRef, tbody, tfootWithRef)));\n    }\n    // reuse previously column widths, will be updated by `useLayoutEffect` above\n    const colWidths = columnWidths === null || columnWidths === void 0 ? void 0 : columnWidths.slice(0, columnCount);\n    if (colWidths && bodyHeight) {\n        const bodyColgroup = (react_default.a.createElement("colgroup", null, colWidths.map((w, i) => (\n        // eslint-disable-next-line react/no-array-index-key\n        react_default.a.createElement("col", { key: i, width: w })))));\n        // header columns do not have vertical scroll bars,\n        // so we add scroll bar size to the last column\n        const headerColgroup = sticky.hasVerticalScroll && scrollBarSize ? (react_default.a.createElement("colgroup", null, colWidths.map((x, i) => (\n        // eslint-disable-next-line react/no-array-index-key\n        react_default.a.createElement("col", { key: i, width: x + (i === colWidths.length - 1 ? scrollBarSize : 0) }))))) : (bodyColgroup);\n        headerTable = (react_default.a.createElement("div", { key: "header", ref: scrollHeaderRef, style: {\n                overflow: \'hidden\',\n            } },\n            react_default.a.cloneElement(table, mergeStyleProp(table, fixedTableLayout), headerColgroup, thead),\n            headerTable));\n        footerTable = tfoot && (react_default.a.createElement("div", { key: "footer", ref: scrollFooterRef, style: {\n                overflow: \'hidden\',\n            } },\n            react_default.a.cloneElement(table, mergeStyleProp(table, fixedTableLayout), headerColgroup, tfoot),\n            footerTable));\n        const onScroll = e => {\n            if (scrollHeaderRef.current) {\n                scrollHeaderRef.current.scrollLeft = e.currentTarget.scrollLeft;\n            }\n            if (scrollFooterRef.current) {\n                scrollFooterRef.current.scrollLeft = e.currentTarget.scrollLeft;\n            }\n        };\n        bodyTable = (react_default.a.createElement("div", { key: "body", ref: scrollBodyRef, style: {\n                height: bodyHeight,\n                overflow: \'auto\',\n            }, onScroll: sticky.hasHorizontalScroll ? onScroll : undefined }, react_default.a.cloneElement(table, mergeStyleProp(table, fixedTableLayout), bodyColgroup, tbody)));\n    }\n    return (react_default.a.createElement("div", { style: {\n            width: maxWidth,\n            height: sticky.realHeight || maxHeight,\n            overflow: \'hidden\',\n        } },\n        headerTable,\n        bodyTable,\n        footerTable,\n        sizerTable));\n}\nfunction useInstance(instance) {\n    const { dispatch, state: { sticky }, data, page, rows, getTableSize = () => undefined, } = instance;\n    const setStickyState = Object(react["useCallback"])((size) => {\n        dispatch({\n            type: ReducerActions.setStickyState,\n            size,\n        });\n    }, \n    // turning pages would also trigger a resize\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [dispatch, getTableSize, page, rows]);\n    const useStickyWrap = (renderer) => {\n        const { width, height } = useMountedMemo(getTableSize, [getTableSize]) || sticky;\n        // only change of data should trigger re-render\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        const table = Object(react["useMemo"])(renderer, [page, rows]);\n        Object(react["useLayoutEffect"])(() => {\n            if (!width || !height) {\n                setStickyState();\n            }\n        }, [width, height]);\n        if (!width || !height) {\n            return null;\n        }\n        if (data.length === 0) {\n            return table;\n        }\n        return (react_default.a.createElement(StickyWrap, { width: width, height: height, sticky: sticky, setStickyState: setStickyState }, table));\n    };\n    Object.assign(instance, {\n        setStickyState,\n        wrapStickyTable: useStickyWrap,\n    });\n}\nfunction useSticky(hooks) {\n    hooks.useInstance.push(useInstance);\n    hooks.stateReducers.push((newState, action_, prevState) => {\n        const action = action_;\n        if (action.type === ReducerActions.init) {\n            return Object.assign(Object.assign({}, newState), { sticky: Object.assign({}, prevState === null || prevState === void 0 ? void 0 : prevState.sticky) });\n        }\n        if (action.type === ReducerActions.setStickyState) {\n            const { size } = action;\n            if (!size) {\n                return Object.assign({}, newState);\n            }\n            return Object.assign(Object.assign({}, newState), { sticky: Object.assign(Object.assign(Object.assign({}, prevState === null || prevState === void 0 ? void 0 : prevState.sticky), newState === null || newState === void 0 ? void 0 : newState.sticky), action.size) });\n        }\n        return newState;\n    });\n}\nuseSticky.pluginName = \'useSticky\';\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/consts.ts\nvar consts = __webpack_require__(569);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/DataTable/DataTable.tsx\nvar __rest = (undefined && undefined.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === "function")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\n\n\n\n\n\n\n\n// Be sure to pass our updateMyData and the skipReset option\nfunction DataTable(_a) {\n    var _b, _c;\n    var { tableClassName, columns, data, totals, totalsHeaderSpan, serverPaginationData, width: initialWidth = \'100%\', height: initialHeight = 300, pageSize: initialPageSize = 0, initialState: initialState_ = {}, pageSizeOptions = consts["a" /* PAGE_SIZE_OPTIONS */], maxPageItemCount = 9, sticky: doSticky, searchInput = true, onServerPaginationChange, rowCount, selectPageSize, noResults: noResultsText = \'No data found\', hooks, serverPagination, wrapperRef: userWrapperRef } = _a, moreUseTableOptions = __rest(_a, ["tableClassName", "columns", "data", "totals", "totalsHeaderSpan", "serverPaginationData", "width", "height", "pageSize", "initialState", "pageSizeOptions", "maxPageItemCount", "sticky", "searchInput", "onServerPaginationChange", "rowCount", "selectPageSize", "noResults", "hooks", "serverPagination", "wrapperRef"]);\n    const tableHooks = [\n        react_table["useGlobalFilter"],\n        react_table["useSortBy"],\n        react_table["usePagination"],\n        doSticky ? useSticky : [],\n        hooks || [],\n    ].flat();\n    const resultsSize = serverPagination ? rowCount : data.length;\n    const sortByRef = Object(react["useRef"])([]); // cache initial `sortby` so sorting doesn\'t trigger page reset\n    const pageSizeRef = Object(react["useRef"])([initialPageSize, resultsSize]);\n    const hasPagination = initialPageSize > 0 && resultsSize > 0; // pageSize == 0 means no pagination\n    const hasGlobalControl = hasPagination || !!searchInput;\n    const initialState = Object.assign(Object.assign({}, initialState_), { \n        // zero length means all pages, the `usePagination` plugin does not\n        // understand pageSize = 0\n        sortBy: sortByRef.current, pageSize: initialPageSize > 0 ? initialPageSize : resultsSize || 10 });\n    const defaultWrapperRef = Object(react["useRef"])(null);\n    const globalControlRef = Object(react["useRef"])(null);\n    const paginationRef = Object(react["useRef"])(null);\n    const wrapperRef = userWrapperRef || defaultWrapperRef;\n    const paginationData = JSON.stringify(serverPaginationData);\n    const defaultGetTableSize = Object(react["useCallback"])(() => {\n        var _a, _b;\n        if (wrapperRef.current) {\n            // `initialWidth` and `initialHeight` could be also parameters like `100%`\n            // `Number` reaturns `NaN` on them, then we fallback to computed size\n            const width = Number(initialWidth) || wrapperRef.current.clientWidth;\n            const height = (Number(initialHeight) || wrapperRef.current.clientHeight) -\n                (((_a = globalControlRef.current) === null || _a === void 0 ? void 0 : _a.clientHeight) || 0) -\n                (((_b = paginationRef.current) === null || _b === void 0 ? void 0 : _b.clientHeight) || 0);\n            return { width, height };\n        }\n        return undefined;\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        initialHeight,\n        initialWidth,\n        wrapperRef,\n        hasPagination,\n        hasGlobalControl,\n        paginationRef,\n        resultsSize,\n        paginationData,\n    ]);\n    const defaultGlobalFilter = Object(react["useCallback"])((rows, columnIds, filterValue) => {\n        // allow searching by "col1_value col2_value"\n        const joinedString = (row) => columnIds.map(x => row.values[x]).join(\' \');\n        return Object(match_sorter_esm["a" /* matchSorter */])(rows, filterValue, {\n            keys: [...columnIds, joinedString],\n            threshold: match_sorter_esm["b" /* rankings */].ACRONYM,\n        });\n    }, []);\n    const { getTableProps, getTableBodyProps, prepareRow, headerGroups, page, pageCount, gotoPage, preGlobalFilteredRows, setGlobalFilter, setPageSize: setPageSize_, wrapStickyTable, state: { pageIndex, pageSize, globalFilter: filterValue, sticky = {} }, } = Object(react_table["useTable"])(Object.assign({ columns,\n        data,\n        initialState, getTableSize: defaultGetTableSize, globalFilter: defaultGlobalFilter }, moreUseTableOptions), ...tableHooks);\n    // make setPageSize accept 0\n    const setPageSize = (size) => {\n        if (serverPagination) {\n            onServerPaginationChange(0, size);\n        }\n        // keep the original size if data is empty\n        if (size || resultsSize !== 0) {\n            setPageSize_(size === 0 ? resultsSize : size);\n        }\n    };\n    const noResults = typeof noResultsText === \'function\' ? noResultsText(filterValue) : noResultsText;\n    const getNoResults = () => react_default.a.createElement("div", { className: "dt-no-results" }, noResults);\n    if (!columns || columns.length === 0) {\n        return (wrapStickyTable ? wrapStickyTable(getNoResults) : getNoResults());\n    }\n    const renderTable = () => (react_default.a.createElement("table", Object.assign({}, getTableProps({ className: tableClassName })),\n        react_default.a.createElement("thead", null, headerGroups.map(headerGroup => {\n            const _a = headerGroup.getHeaderGroupProps(), { key: headerGroupKey } = _a, headerGroupProps = __rest(_a, ["key"]);\n            return (react_default.a.createElement("tr", Object.assign({ key: headerGroupKey || headerGroup.id }, headerGroupProps), headerGroup.headers.map(column => column.render(\'Header\', Object.assign({ key: column.id }, column.getSortByToggleProps())))));\n        })),\n        react_default.a.createElement("tbody", Object.assign({}, getTableBodyProps()), page && page.length > 0 ? (page.map(row => {\n            prepareRow(row);\n            const _a = row.getRowProps(), { key: rowKey } = _a, rowProps = __rest(_a, ["key"]);\n            return (react_default.a.createElement("tr", Object.assign({ key: rowKey || row.id }, rowProps), row.cells.map(cell => cell.render(\'Cell\', { key: cell.column.id }))));\n        })) : (react_default.a.createElement("tr", null,\n            react_default.a.createElement("td", { className: "dt-no-results", colSpan: columns.length }, noResults)))),\n        totals && (react_default.a.createElement("tfoot", null,\n            react_default.a.createElement("tr", { key: "totals", className: "dt-totals" },\n                react_default.a.createElement("td", { colSpan: totalsHeaderSpan }, Object(TranslatorSingleton["e" /* t */])(\'Totals\')),\n                totals.map(item => (react_default.a.createElement("td", { className: item.className }, item.value))))))));\n    // force update the pageSize when it\'s been update from the initial state\n    if (pageSizeRef.current[0] !== initialPageSize ||\n        // when initialPageSize stays as zero, but total number of records changed,\n        // we\'d also need to update page size\n        (initialPageSize === 0 && pageSizeRef.current[1] !== resultsSize)) {\n        pageSizeRef.current = [initialPageSize, resultsSize];\n        setPageSize(initialPageSize);\n    }\n    const paginationStyle = sticky.height ? {} : { visibility: \'hidden\' };\n    let resultPageCount = pageCount;\n    let resultCurrentPageSize = pageSize;\n    let resultCurrentPage = pageIndex;\n    let resultOnPageChange = gotoPage;\n    if (serverPagination) {\n        const serverPageSize = (_b = serverPaginationData.pageSize) !== null && _b !== void 0 ? _b : initialPageSize;\n        resultPageCount = Math.ceil(rowCount / serverPageSize);\n        if (!Number.isFinite(resultPageCount)) {\n            resultPageCount = 0;\n        }\n        resultCurrentPageSize = serverPageSize;\n        const foundPageSizeIndex = pageSizeOptions.findIndex(([option]) => option >= resultCurrentPageSize);\n        if (foundPageSizeIndex === -1) {\n            resultCurrentPageSize = 0;\n        }\n        resultCurrentPage = (_c = serverPaginationData.currentPage) !== null && _c !== void 0 ? _c : 0;\n        resultOnPageChange = (pageNumber) => onServerPaginationChange(pageNumber, serverPageSize);\n    }\n    return (react_default.a.createElement("div", { ref: wrapperRef, style: { width: initialWidth, height: initialHeight } },\n        hasGlobalControl ? (react_default.a.createElement("div", { ref: globalControlRef, className: "form-inline dt-controls" },\n            react_default.a.createElement("div", { className: "row" },\n                react_default.a.createElement("div", { className: "col-sm-6" }, hasPagination ? (react_default.a.createElement(components_SelectPageSize, { total: resultsSize, current: resultCurrentPageSize, options: pageSizeOptions, selectRenderer: typeof selectPageSize === \'boolean\' ? undefined : selectPageSize, onChange: setPageSize })) : null),\n                searchInput ? (react_default.a.createElement("div", { className: "col-sm-6" },\n                    react_default.a.createElement(components_GlobalFilter, { searchInput: typeof searchInput === \'boolean\' ? undefined : searchInput, preGlobalFilteredRows: preGlobalFilteredRows, setGlobalFilter: setGlobalFilter, filterValue: filterValue }))) : null))) : null,\n        wrapStickyTable ? wrapStickyTable(renderTable) : renderTable(),\n        hasPagination && resultPageCount > 1 ? (react_default.a.createElement(components_Pagination, { ref: paginationRef, style: paginationStyle, maxPageItemCount: maxPageItemCount, pageCount: resultPageCount, currentPage: resultCurrentPage, onPageChange: resultOnPageChange })) : null));\n}\n\n// EXTERNAL MODULE: ../superset-ui-core/src/style/index.ts\nvar src_style = __webpack_require__(442);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/Styles.tsx\n\n/* harmony default export */ var Styles = (src_style["d" /* styled */].div `\n  table {\n    width: 100%;\n    min-width: auto;\n    max-width: none;\n    margin: 0;\n  }\n\n  th,\n  td {\n    min-width: 4.3em;\n  }\n\n  thead > tr > th {\n    padding-right: 1.4em;\n    position: relative;\n    background: #fff;\n  }\n  th svg {\n    color: #ccc;\n    position: absolute;\n    bottom: 0.6em;\n    right: 0.2em;\n  }\n  th.is-sorted svg {\n    color: #a8a8a8;\n  }\n  .table > tbody > tr:first-of-type > td,\n  .table > tbody > tr:first-of-type > th {\n    border-top: 0;\n  }\n\n  .dt-controls {\n    padding-bottom: 0.65em;\n  }\n  .dt-metric {\n    text-align: right;\n  }\n  .dt-totals {\n    font-weight: bold;\n  }\n  .dt-is-null {\n    color: ${({ theme: { colors } }) => colors.grayscale.light1};\n  }\n  td.dt-is-filter {\n    cursor: pointer;\n  }\n  td.dt-is-filter:hover {\n    background-color: ${({ theme: { colors } }) => colors.secondary.light4};\n  }\n  td.dt-is-active-filter,\n  td.dt-is-active-filter:hover {\n    background-color: ${({ theme: { colors } }) => colors.secondary.light3};\n  }\n\n  .dt-global-filter {\n    float: right;\n  }\n\n  .dt-pagination {\n    text-align: right;\n    /* use padding instead of margin so clientHeight can capture it */\n    padding-top: 0.5em;\n  }\n  .dt-pagination .pagination {\n    margin: 0;\n  }\n\n  .pagination > li > span.dt-pagination-ellipsis:focus,\n  .pagination > li > span.dt-pagination-ellipsis:hover {\n    background: #fff;\n  }\n\n  .dt-no-results {\n    text-align: center;\n    padding: 1em 0.6em;\n  }\n`);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/xss/lib/index.js\nvar lib = __webpack_require__(2405);\n\n// EXTERNAL MODULE: ../superset-ui-core/src/number-format/NumberFormatterRegistrySingleton.ts\nvar NumberFormatterRegistrySingleton = __webpack_require__(156);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/utils/formatValue.ts\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\nconst xss = new lib["FilterXSS"]({\n    whiteList: Object.assign(Object.assign({}, Object(lib["getDefaultWhiteList"])()), { span: [\'style\', \'class\', \'title\'], div: [\'style\', \'class\'], a: [\'style\', \'class\', \'href\', \'title\', \'target\'], img: [\'style\', \'class\', \'src\', \'alt\', \'title\', \'width\', \'height\'], video: [\'autoplay\', \'controls\', \'loop\', \'preload\', \'src\', \'height\', \'width\', \'muted\'] }),\n    stripIgnoreTag: true,\n    css: false,\n});\nfunction isProbablyHTML(text) {\n    return /<[^>]+>/.test(text);\n}\n/**\n * Format text for cell value.\n */\nfunction formatValue(formatter, value) {\n    if (value === null || typeof value === \'undefined\') {\n        return [false, \'N/A\'];\n    }\n    if (formatter) {\n        // in case percent metric can specify percent format in the future\n        return [false, formatter(value)];\n    }\n    if (typeof value === \'string\') {\n        return isProbablyHTML(value) ? [true, xss.process(value)] : [false, value];\n    }\n    return [false, value.toString()];\n}\nfunction formatColumnValue(column, value) {\n    const { dataType, formatter, config = {} } = column;\n    const isNumber = dataType === QueryResponse["a" /* GenericDataType */].NUMERIC;\n    const smallNumberFormatter = config.d3SmallNumberFormat === undefined\n        ? formatter\n        : Object(NumberFormatterRegistrySingleton["c" /* getNumberFormatter */])(config.d3SmallNumberFormat);\n    return formatValue(isNumber && typeof value === \'number\' && Math.abs(value) < 1 ? smallNumberFormatter : formatter, value);\n}\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/DataTable/utils/externalAPIs.ts\nvar externalAPIs = __webpack_require__(1054);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/plugin-chart-table/src/TableChart.tsx\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\n\n\n\n\n\n\n\n/**\n * Return sortType based on data type\n */\nfunction getSortTypeByDataType(dataType) {\n    if (dataType === QueryResponse["a" /* GenericDataType */].TEMPORAL) {\n        return \'datetime\';\n    }\n    if (dataType === QueryResponse["a" /* GenericDataType */].STRING) {\n        return \'alphanumeric\';\n    }\n    return \'basic\';\n}\n/**\n * Cell background to render columns as horizontal bar chart\n */\nfunction cellBar({ value, valueRange, colorPositiveNegative = false, alignPositiveNegative, }) {\n    const [minValue, maxValue] = valueRange;\n    const r = colorPositiveNegative && value < 0 ? 150 : 0;\n    if (alignPositiveNegative) {\n        const perc = Math.abs(Math.round((value / maxValue) * 100));\n        // The 0.01 to 0.001 is a workaround for what appears to be a\n        // CSS rendering bug on flat, transparent colors\n        return (`linear-gradient(to right, rgba(${r},0,0,0.2), rgba(${r},0,0,0.2) ${perc}%, ` +\n            `rgba(0,0,0,0.01) ${perc}%, rgba(0,0,0,0.001) 100%)`);\n    }\n    const posExtent = Math.abs(Math.max(maxValue, 0));\n    const negExtent = Math.abs(Math.min(minValue, 0));\n    const tot = posExtent + negExtent;\n    const perc1 = Math.round((Math.min(negExtent + value, negExtent) / tot) * 100);\n    const perc2 = Math.round((Math.abs(value) / tot) * 100);\n    // The 0.01 to 0.001 is a workaround for what appears to be a\n    // CSS rendering bug on flat, transparent colors\n    return (`linear-gradient(to right, rgba(0,0,0,0.01), rgba(0,0,0,0.001) ${perc1}%, ` +\n        `rgba(${r},0,0,0.2) ${perc1}%, rgba(${r},0,0,0.2) ${perc1 + perc2}%, ` +\n        `rgba(0,0,0,0.01) ${perc1 + perc2}%, rgba(0,0,0,0.001) 100%)`);\n}\nfunction SortIcon({ column }) {\n    const { isSorted, isSortedDesc } = column;\n    let sortIcon = react_default.a.createElement(index_esm["a" /* FaSort */], null);\n    if (isSorted) {\n        sortIcon = isSortedDesc ? react_default.a.createElement(index_esm["b" /* FaSortDown */], null) : react_default.a.createElement(index_esm["c" /* FaSortUp */], null);\n    }\n    return sortIcon;\n}\nfunction TableChart_SearchInput({ count, value, onChange }) {\n    return (react_default.a.createElement("span", { className: "dt-global-filter" },\n        Object(TranslatorSingleton["e" /* t */])(\'Search\'),\n        \' \',\n        react_default.a.createElement("input", { className: "form-control input-sm", placeholder: Object(TranslatorSingleton["f" /* tn */])(\'search.num_records\', count), value: value, onChange: onChange })));\n}\nfunction TableChart_SelectPageSize({ options, current, onChange }) {\n    return (react_default.a.createElement("span", { className: "dt-select-page-size form-inline" },\n        Object(TranslatorSingleton["e" /* t */])(\'page_size.show\'),\n        \' \',\n        react_default.a.createElement("select", { className: "form-control input-sm", value: current, onBlur: () => { }, onChange: e => {\n                onChange(Number(e.target.value));\n            } }, options.map(option => {\n            const [size, text] = Array.isArray(option) ? option : [option, option];\n            return (react_default.a.createElement("option", { key: size, value: size }, text));\n        })),\n        \' \',\n        Object(TranslatorSingleton["e" /* t */])(\'page_size.entries\')));\n}\nfunction TableChart(props) {\n    const { height, width, data, totals, isRawRecords, rowCount = 0, columns: columnsMeta, alignPositiveNegative: defaultAlignPN = false, colorPositiveNegative: defaultColorPN = false, includeSearch = false, pageSize = 0, serverPagination = false, serverPaginationData, setDataMask, showCellBars = true, emitFilter = false, sortDesc = false, filters: initialFilters = {}, sticky = true, } = props;\n    const [filters, setFilters] = Object(react["useState"])(initialFilters);\n    const handleChange = Object(react["useCallback"])((filters) => {\n        if (!emitFilter) {\n            return;\n        }\n        const groupBy = Object.keys(filters);\n        const groupByValues = Object.values(filters);\n        setDataMask({\n            extraFormData: {\n                filters: groupBy.length === 0\n                    ? []\n                    : groupBy.map(col => {\n                        const val = filters === null || filters === void 0 ? void 0 : filters[col];\n                        if (val === null || val === undefined)\n                            return {\n                                col,\n                                op: \'IS NULL\',\n                            };\n                        return {\n                            col,\n                            op: \'IN\',\n                            val: val,\n                        };\n                    }),\n            },\n            filterState: {\n                value: groupByValues.length ? groupByValues : null,\n            },\n        });\n    }, [emitFilter, setDataMask]);\n    // only take relevant page size options\n    const pageSizeOptions = Object(react["useMemo"])(() => {\n        const getServerPagination = (n) => n <= rowCount;\n        return consts["a" /* PAGE_SIZE_OPTIONS */].filter(([n]) => serverPagination ? getServerPagination(n) : n <= 2 * data.length);\n    }, [data.length, rowCount, serverPagination]);\n    const getValueRange = Object(react["useCallback"])(function getValueRange(key, alignPositiveNegative) {\n        var _a;\n        if (typeof ((_a = data === null || data === void 0 ? void 0 : data[0]) === null || _a === void 0 ? void 0 : _a[key]) === \'number\') {\n            const nums = data.map(row => row[key]);\n            return (alignPositiveNegative\n                ? [0, Object(max["a" /* default */])(nums.map(Math.abs))]\n                : Object(extent["a" /* default */])(nums));\n        }\n        return null;\n    }, [data]);\n    const isActiveFilterValue = Object(react["useCallback"])(function isActiveFilterValue(key, val) {\n        var _a;\n        return !!filters && ((_a = filters[key]) === null || _a === void 0 ? void 0 : _a.includes(val));\n    }, [filters]);\n    const toggleFilter = Object(react["useCallback"])(function toggleFilter(key, val) {\n        const updatedFilters = Object.assign({}, (filters || {}));\n        if (filters && isActiveFilterValue(key, val)) {\n            updatedFilters[key] = filters[key].filter((x) => x !== val);\n        }\n        else {\n            updatedFilters[key] = [...((filters === null || filters === void 0 ? void 0 : filters[key]) || []), val];\n        }\n        if (Array.isArray(updatedFilters[key]) && updatedFilters[key].length === 0) {\n            delete updatedFilters[key];\n        }\n        setFilters(updatedFilters);\n        handleChange(updatedFilters);\n    }, [filters, handleChange, isActiveFilterValue]);\n    const getColumnConfigs = Object(react["useCallback"])((column, i) => {\n        const { key, label, dataType, isMetric, config = {} } = column;\n        const isNumber = dataType === QueryResponse["a" /* GenericDataType */].NUMERIC;\n        const isFilter = !isNumber && emitFilter;\n        const textAlign = config.horizontalAlign\n            ? config.horizontalAlign\n            : isNumber\n                ? \'right\'\n                : \'left\';\n        const columnWidth = Number.isNaN(Number(config.columnWidth))\n            ? config.columnWidth\n            : Number(config.columnWidth);\n        // inline style for both th and td cell\n        const sharedStyle = {\n            textAlign,\n        };\n        const alignPositiveNegative = config.alignPositiveNegative === undefined ? defaultAlignPN : config.alignPositiveNegative;\n        const colorPositiveNegative = config.colorPositiveNegative === undefined ? defaultColorPN : config.colorPositiveNegative;\n        const valueRange = (config.showCellBars === undefined ? showCellBars : config.showCellBars) &&\n            (isMetric || isRawRecords) &&\n            getValueRange(key, alignPositiveNegative);\n        let className = \'\';\n        if (isFilter) {\n            className += \' dt-is-filter\';\n        }\n        return {\n            id: String(i),\n            // must use custom accessor to allow `.` in column names\n            // typing is incorrect in current version of `@types/react-table`\n            // so we ask TS not to check.\n            accessor: ((datum) => datum[key]),\n            Cell: ({ value }) => {\n                const [isHtml, text] = formatColumnValue(column, value);\n                const html = isHtml ? { __html: text } : undefined;\n                const cellProps = {\n                    // show raw number in title in case of numeric values\n                    title: typeof value === \'number\' ? String(value) : undefined,\n                    onClick: emitFilter && !valueRange ? () => toggleFilter(key, value) : undefined,\n                    className: [\n                        className,\n                        value == null ? \'dt-is-null\' : \'\',\n                        isActiveFilterValue(key, value) ? \' dt-is-active-filter\' : \'\',\n                    ].join(\' \'),\n                    style: Object.assign(Object.assign({}, sharedStyle), { background: valueRange\n                            ? cellBar({\n                                value: value,\n                                valueRange,\n                                alignPositiveNegative,\n                                colorPositiveNegative,\n                            })\n                            : undefined }),\n                };\n                if (html) {\n                    // eslint-disable-next-line react/no-danger\n                    return react_default.a.createElement("td", Object.assign({}, cellProps, { dangerouslySetInnerHTML: html }));\n                }\n                // If cellProps renderes textContent already, then we don\'t have to\n                // render `Cell`. This saves some time for large tables.\n                return react_default.a.createElement("td", Object.assign({}, cellProps), text);\n            },\n            Header: ({ column: col, onClick, style }) => (react_default.a.createElement("th", { title: "Shift + Click to sort by multiple columns", className: [className, col.isSorted ? \'is-sorted\' : \'\'].join(\' \'), style: Object.assign(Object.assign({}, sharedStyle), style), onClick: onClick },\n                config.columnWidth ? (\n                // column width hint\n                react_default.a.createElement("div", { style: {\n                        width: columnWidth,\n                        height: 0.01,\n                    } })) : null,\n                label,\n                react_default.a.createElement(SortIcon, { column: col }))),\n            sortDescFirst: sortDesc,\n            sortType: getSortTypeByDataType(dataType),\n        };\n    }, [\n        defaultAlignPN,\n        defaultColorPN,\n        emitFilter,\n        getValueRange,\n        isActiveFilterValue,\n        isRawRecords,\n        showCellBars,\n        sortDesc,\n        toggleFilter,\n    ]);\n    const columns = Object(react["useMemo"])(() => columnsMeta.map(getColumnConfigs), [columnsMeta, getColumnConfigs]);\n    const handleServerPaginationChange = (pageNumber, pageSize) => {\n        Object(externalAPIs["a" /* updateExternalFormData */])(setDataMask, pageNumber, pageSize);\n    };\n    const totalsFormatted = totals &&\n        columnsMeta\n            .filter(column => Object.keys(totals).includes(column.key))\n            .reduce((acc, column) => [\n            ...acc,\n            {\n                value: formatColumnValue(column, totals[column.key])[1],\n                className: column.dataType === QueryResponse["a" /* GenericDataType */].NUMERIC ? \'dt-metric\' : \'\',\n            },\n        ], []);\n    const totalsHeaderSpan = totalsFormatted &&\n        columnsMeta.filter(column => !column.isPercentMetric).length - totalsFormatted.length;\n    return (react_default.a.createElement(Styles, null,\n        react_default.a.createElement(DataTable, { columns: columns, totals: totalsFormatted, totalsHeaderSpan: totalsHeaderSpan, data: data, rowCount: rowCount, tableClassName: "table table-striped table-condensed", pageSize: pageSize, serverPaginationData: serverPaginationData, pageSizeOptions: pageSizeOptions, height: height, serverPagination: serverPagination, onServerPaginationChange: handleServerPaginationChange, \n            // 9 page items in > 340px works well even for 100+ pages\n            maxPageItemCount: width > 340 ? 9 : 7, noResults: (filter) => Object(TranslatorSingleton["e" /* t */])(filter ? \'No matching records found\' : \'No records found\'), searchInput: includeSearch && TableChart_SearchInput, selectPageSize: pageSize !== null && TableChart_SelectPageSize, \n            // not in use in Superset, but needed for unit tests\n            sticky: sticky })));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQ3MC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wbHVnaW4tY2hhcnQtdGFibGUvc3JjL0RhdGFUYWJsZS91dGlscy91c2VBc3luY1N0YXRlLnRzP2Q0MmUiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9wbHVnaW5zL3BsdWdpbi1jaGFydC10YWJsZS9zcmMvRGF0YVRhYmxlL2NvbXBvbmVudHMvR2xvYmFsRmlsdGVyLnRzeD82NmM3Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wbHVnaW4tY2hhcnQtdGFibGUvc3JjL0RhdGFUYWJsZS9jb21wb25lbnRzL1NlbGVjdFBhZ2VTaXplLnRzeD80MWU4Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wbHVnaW4tY2hhcnQtdGFibGUvc3JjL0RhdGFUYWJsZS9jb21wb25lbnRzL1BhZ2luYXRpb24udHN4PzlhOTIiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9wbHVnaW5zL3BsdWdpbi1jaGFydC10YWJsZS9zcmMvRGF0YVRhYmxlL3V0aWxzL2dldFNjcm9sbEJhclNpemUudHM/NDI0OCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvcGx1Z2luLWNoYXJ0LXRhYmxlL3NyYy9EYXRhVGFibGUvdXRpbHMvbmVlZFNjcm9sbEJhci50cz8xNzUzIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wbHVnaW4tY2hhcnQtdGFibGUvc3JjL0RhdGFUYWJsZS91dGlscy91c2VNb3VudGVkTWVtby50cz85YzI5Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9wbHVnaW4tY2hhcnQtdGFibGUvc3JjL0RhdGFUYWJsZS9ob29rcy91c2VTdGlja3kudHN4P2YwNGUiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9wbHVnaW5zL3BsdWdpbi1jaGFydC10YWJsZS9zcmMvRGF0YVRhYmxlL0RhdGFUYWJsZS50c3g/Mzg2NCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvcGx1Z2luLWNoYXJ0LXRhYmxlL3NyYy9TdHlsZXMudHN4PzNjMmYiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9wbHVnaW5zL3BsdWdpbi1jaGFydC10YWJsZS9zcmMvdXRpbHMvZm9ybWF0VmFsdWUudHM/MDE1NCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvcGx1Z2luLWNoYXJ0LXRhYmxlL3NyYy9UYWJsZUNoYXJ0LnRzeD8yODI1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VBc3luY0RlYm91bmNlIH0gZnJvbSAncmVhY3QtdGFibGUnO1xuXG4vLyB1c2VBc3luY0RlYm91bmNlIGluIGRpc3QgYnVpbGQgb2YgYHJlYWN0LXRhYmxlYCByZXF1aXJlcyByZWdlbmVyYXRvclJ1bnRpbWVcbmltcG9ydCAncmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lJztcblxuLyoqXG4gKiBIb29rIHVzZVN0YXRlIHRvIGFsbG93IGFsd2F5cyByZXR1cm4gbGF0ZXN0IGluaXRpYWxWYWx1ZVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1c2VBc3luY1N0YXRlPFQsIEYgZXh0ZW5kcyAobmV3VmFsdWU6IFQpID0+IHVua25vd24+KFxuICBpbml0aWFsVmFsdWU6IFQsXG4gIGNhbGxiYWNrOiBGLFxuICB3YWl0ID0gMjAwLFxuKSB7XG4gIGNvbnN0IFt2YWx1ZSwgc2V0VmFsdWVdID0gdXNlU3RhdGUoaW5pdGlhbFZhbHVlKTtcbiAgY29uc3QgdmFsdWVSZWYgPSB1c2VSZWYoaW5pdGlhbFZhbHVlKTtcbiAgY29uc3Qgb25DaGFuZ2UgPSB1c2VBc3luY0RlYm91bmNlKGNhbGxiYWNrLCB3YWl0KTtcblxuICAvLyBzeW5jIHVwZGF0ZWQgaW5pdGlhbFZhbHVlXG4gIGlmICh2YWx1ZVJlZi5jdXJyZW50ICE9PSBpbml0aWFsVmFsdWUpIHtcbiAgICB2YWx1ZVJlZi5jdXJyZW50ID0gaW5pdGlhbFZhbHVlO1xuICAgIGlmICh2YWx1ZSAhPT0gaW5pdGlhbFZhbHVlKSB7XG4gICAgICBzZXRWYWx1ZShpbml0aWFsVmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHNldEJvdGggPSAobmV3VmFsdWU6IFQpID0+IHtcbiAgICBzZXRWYWx1ZShuZXdWYWx1ZSk7XG4gICAgb25DaGFuZ2UobmV3VmFsdWUpO1xuICB9O1xuXG4gIHJldHVybiBbdmFsdWUsIHNldEJvdGhdIGFzIFt0eXBlb2YgdmFsdWUsIHR5cGVvZiBzZXRWYWx1ZV07XG59XG4iLCIvKipcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50VHlwZSwgQ2hhbmdlRXZlbnRIYW5kbGVyIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUm93LCBGaWx0ZXJWYWx1ZSB9IGZyb20gJ3JlYWN0LXRhYmxlJztcbmltcG9ydCB1c2VBc3luY1N0YXRlIGZyb20gJy4uL3V0aWxzL3VzZUFzeW5jU3RhdGUnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNlYXJjaElucHV0UHJvcHMge1xuICBjb3VudDogbnVtYmVyO1xuICB2YWx1ZTogc3RyaW5nO1xuICBvbkNoYW5nZTogQ2hhbmdlRXZlbnRIYW5kbGVyPEhUTUxJbnB1dEVsZW1lbnQ+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdsb2JhbEZpbHRlclByb3BzPEQgZXh0ZW5kcyBvYmplY3Q+IHtcbiAgcHJlR2xvYmFsRmlsdGVyZWRSb3dzOiBSb3c8RD5bXTtcbiAgLy8gZmlsdGVyIHZhbHVlIGNhbm5vdCBiZSBgdW5kZWZpbmVkYCBvdGhlcndpc2UgUmVhY3Qgd2lsbCByZXBvcnQgY29tcG9uZW50XG4gIC8vIGNvbnRyb2wgdHlwZSB1bmRlZmluZWQgZXJyb3JcbiAgZmlsdGVyVmFsdWU6IHN0cmluZztcbiAgc2V0R2xvYmFsRmlsdGVyOiAoZmlsdGVyVmFsdWU6IEZpbHRlclZhbHVlKSA9PiB2b2lkO1xuICBzZWFyY2hJbnB1dD86IENvbXBvbmVudFR5cGU8U2VhcmNoSW5wdXRQcm9wcz47XG59XG5cbmZ1bmN0aW9uIERlZmF1bHRTZWFyY2hJbnB1dCh7IGNvdW50LCB2YWx1ZSwgb25DaGFuZ2UgfTogU2VhcmNoSW5wdXRQcm9wcykge1xuICByZXR1cm4gKFxuICAgIDxzcGFuIGNsYXNzTmFtZT1cImR0LWdsb2JhbC1maWx0ZXJcIj5cbiAgICAgIFNlYXJjaHsnICd9XG4gICAgICA8aW5wdXRcbiAgICAgICAgY2xhc3NOYW1lPVwiZm9ybS1jb250cm9sIGlucHV0LXNtXCJcbiAgICAgICAgcGxhY2Vob2xkZXI9e2Ake2NvdW50fSByZWNvcmRzLi4uYH1cbiAgICAgICAgdmFsdWU9e3ZhbHVlfVxuICAgICAgICBvbkNoYW5nZT17b25DaGFuZ2V9XG4gICAgICAvPlxuICAgIDwvc3Bhbj5cbiAgKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgKFJlYWN0Lm1lbW8gYXMgPFQ+KGZuOiBUKSA9PiBUKShmdW5jdGlvbiBHbG9iYWxGaWx0ZXI8RCBleHRlbmRzIG9iamVjdD4oe1xuICBwcmVHbG9iYWxGaWx0ZXJlZFJvd3MsXG4gIGZpbHRlclZhbHVlID0gJycsXG4gIHNlYXJjaElucHV0LFxuICBzZXRHbG9iYWxGaWx0ZXIsXG59OiBHbG9iYWxGaWx0ZXJQcm9wczxEPikge1xuICBjb25zdCBjb3VudCA9IHByZUdsb2JhbEZpbHRlcmVkUm93cy5sZW5ndGg7XG4gIGNvbnN0IFt2YWx1ZSwgc2V0VmFsdWVdID0gdXNlQXN5bmNTdGF0ZShcbiAgICBmaWx0ZXJWYWx1ZSxcbiAgICAobmV3VmFsdWU6IHN0cmluZykgPT4ge1xuICAgICAgc2V0R2xvYmFsRmlsdGVyKG5ld1ZhbHVlIHx8IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICAyMDAsXG4gICk7XG5cbiAgY29uc3QgU2VhcmNoSW5wdXQgPSBzZWFyY2hJbnB1dCB8fCBEZWZhdWx0U2VhcmNoSW5wdXQ7XG5cbiAgcmV0dXJuIChcbiAgICA8U2VhcmNoSW5wdXRcbiAgICAgIGNvdW50PXtjb3VudH1cbiAgICAgIHZhbHVlPXt2YWx1ZX1cbiAgICAgIG9uQ2hhbmdlPXtlID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudDtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBzZXRWYWx1ZSh0YXJnZXQudmFsdWUpO1xuICAgICAgfX1cbiAgICAvPlxuICApO1xufSk7XG4iLCIvKipcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZm9ybWF0U2VsZWN0T3B0aW9ucyB9IGZyb20gJ0BzdXBlcnNldC11aS9jaGFydC1jb250cm9scyc7XG5cbmV4cG9ydCB0eXBlIFNpemVPcHRpb24gPSBbbnVtYmVyLCBzdHJpbmddO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNlbGVjdFBhZ2VTaXplUmVuZGVyZXJQcm9wcyB7XG4gIGN1cnJlbnQ6IG51bWJlcjtcbiAgb3B0aW9uczogU2l6ZU9wdGlvbltdO1xuICBvbkNoYW5nZTogU2VsZWN0UGFnZVNpemVQcm9wc1snb25DaGFuZ2UnXTtcbn1cblxuZnVuY3Rpb24gRGVmYXVsdFNlbGVjdFJlbmRlcmVyKHsgY3VycmVudCwgb3B0aW9ucywgb25DaGFuZ2UgfTogU2VsZWN0UGFnZVNpemVSZW5kZXJlclByb3BzKSB7XG4gIHJldHVybiAoXG4gICAgPHNwYW4gY2xhc3NOYW1lPVwiZHQtc2VsZWN0LXBhZ2Utc2l6ZSBmb3JtLWlubGluZVwiPlxuICAgICAgU2hvd3snICd9XG4gICAgICA8c2VsZWN0XG4gICAgICAgIGNsYXNzTmFtZT1cImZvcm0tY29udHJvbCBpbnB1dC1zbVwiXG4gICAgICAgIHZhbHVlPXtjdXJyZW50fVxuICAgICAgICBvbkJsdXI9eygpID0+IHt9fVxuICAgICAgICBvbkNoYW5nZT17ZSA9PiB7XG4gICAgICAgICAgb25DaGFuZ2UoTnVtYmVyKChlLnRhcmdldCBhcyBIVE1MU2VsZWN0RWxlbWVudCkudmFsdWUpKTtcbiAgICAgICAgfX1cbiAgICAgID5cbiAgICAgICAge29wdGlvbnMubWFwKG9wdGlvbiA9PiB7XG4gICAgICAgICAgY29uc3QgW3NpemUsIHRleHRdID0gQXJyYXkuaXNBcnJheShvcHRpb24pID8gb3B0aW9uIDogW29wdGlvbiwgb3B0aW9uXTtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPG9wdGlvbiBrZXk9e3NpemV9IHZhbHVlPXtzaXplfT5cbiAgICAgICAgICAgICAge3RleHR9XG4gICAgICAgICAgICA8L29wdGlvbj5cbiAgICAgICAgICApO1xuICAgICAgICB9KX1cbiAgICAgIDwvc2VsZWN0PnsnICd9XG4gICAgICBlbnRyaWVzXG4gICAgPC9zcGFuPlxuICApO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlbGVjdFBhZ2VTaXplUHJvcHMgZXh0ZW5kcyBTZWxlY3RQYWdlU2l6ZVJlbmRlcmVyUHJvcHMge1xuICB0b3RhbD86IG51bWJlcjtcbiAgc2VsZWN0UmVuZGVyZXI/OiB0eXBlb2YgRGVmYXVsdFNlbGVjdFJlbmRlcmVyO1xuICBvbkNoYW5nZTogKHBhZ2VTaXplOiBudW1iZXIpID0+IHZvaWQ7XG59XG5cbmZ1bmN0aW9uIGdldE9wdGlvblZhbHVlKHg6IFNpemVPcHRpb24pIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoeCkgPyB4WzBdIDogeDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVhY3QubWVtbyhmdW5jdGlvbiBTZWxlY3RQYWdlU2l6ZSh7XG4gIHRvdGFsLFxuICBvcHRpb25zOiBzaXplT3B0aW9ucyxcbiAgY3VycmVudDogY3VycmVudFNpemUsXG4gIHNlbGVjdFJlbmRlcmVyLFxuICBvbkNoYW5nZSxcbn06IFNlbGVjdFBhZ2VTaXplUHJvcHMpIHtcbiAgY29uc3Qgc2l6ZU9wdGlvblZhbHVlcyA9IHNpemVPcHRpb25zLm1hcChnZXRPcHRpb25WYWx1ZSk7XG4gIGxldCBvcHRpb25zID0gWy4uLnNpemVPcHRpb25zXTtcbiAgLy8gaW5zZXJ0IGN1cnJlbnQgc2l6ZSB0byBsaXN0XG4gIGlmIChcbiAgICBjdXJyZW50U2l6ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgKGN1cnJlbnRTaXplICE9PSB0b3RhbCB8fCAhc2l6ZU9wdGlvblZhbHVlcy5pbmNsdWRlcygwKSkgJiZcbiAgICAhc2l6ZU9wdGlvblZhbHVlcy5pbmNsdWRlcyhjdXJyZW50U2l6ZSlcbiAgKSB7XG4gICAgb3B0aW9ucyA9IFsuLi5zaXplT3B0aW9uc107XG4gICAgb3B0aW9ucy5zcGxpY2UoXG4gICAgICBzaXplT3B0aW9uVmFsdWVzLmZpbmRJbmRleCh4ID0+IHggPiBjdXJyZW50U2l6ZSksXG4gICAgICAwLFxuICAgICAgZm9ybWF0U2VsZWN0T3B0aW9ucyhbY3VycmVudFNpemVdKVswXSxcbiAgICApO1xuICB9XG4gIGNvbnN0IGN1cnJlbnQgPSBjdXJyZW50U2l6ZSA9PT0gdW5kZWZpbmVkID8gc2l6ZU9wdGlvblZhbHVlc1swXSA6IGN1cnJlbnRTaXplO1xuICBjb25zdCBTZWxlY3RSZW5kZXJlciA9IHNlbGVjdFJlbmRlcmVyIHx8IERlZmF1bHRTZWxlY3RSZW5kZXJlcjtcbiAgcmV0dXJuIDxTZWxlY3RSZW5kZXJlciBjdXJyZW50PXtjdXJyZW50fSBvcHRpb25zPXtvcHRpb25zfSBvbkNoYW5nZT17b25DaGFuZ2V9IC8+O1xufSk7XG4iLCIvKipcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgUmVhY3QsIHsgQ1NTUHJvcGVydGllcyB9IGZyb20gJ3JlYWN0JztcblxuZXhwb3J0IGludGVyZmFjZSBQYWdpbmF0aW9uUHJvcHMge1xuICBwYWdlQ291bnQ6IG51bWJlcjsgLy8gbnVtYmVyIG9mIHBhZ2VzXG4gIGN1cnJlbnRQYWdlPzogbnVtYmVyOyAvLyBpbmRleCBvZiBjdXJyZW50IHBhZ2UsIHplcm8tYmFzZWRcbiAgbWF4UGFnZUl0ZW1Db3VudD86IG51bWJlcjtcbiAgZWxsaXBzaXM/OiBzdHJpbmc7IC8vIGNvbnRlbnQgZm9yIGVsbGlwc2lzIGl0ZW1cbiAgb25QYWdlQ2hhbmdlOiAocGFnZTogbnVtYmVyKSA9PiB2b2lkOyAvLyBgcGFnZWAgaXMgemVyby1iYXNlZFxuICBzdHlsZT86IENTU1Byb3BlcnRpZXM7XG59XG5cbi8vIGZpcnN0LCAuLi4sIHByZXYsIGN1cnJlbnQsIG5leHQsIC4uLiwgbGFzdFxuY29uc3QgTUlOSU1BTF9QQUdFX0lURU1fQ09VTlQgPSA3O1xuXG4vKipcbiAqIEdlbmVyYXRlIG51bWVyaWMgcGFnZSBpdGVtcyBhcm91bmQgY3VycmVudCBwYWdlLlxuICogICAtIEFsd2F5cyBpbmNsdWRlIGZpcnN0IGFuZCBsYXN0IHBhZ2VcbiAqICAgLSBBZGQgZWxsaXBzaXMgaWYgbmVlZGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVBhZ2VJdGVtcyh0b3RhbDogbnVtYmVyLCBjdXJyZW50OiBudW1iZXIsIHdpZHRoOiBudW1iZXIpIHtcbiAgaWYgKHdpZHRoIDwgTUlOSU1BTF9QQUdFX0lURU1fQ09VTlQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE11c3QgYWxsb3cgYXQgbGVhc3QgJHtNSU5JTUFMX1BBR0VfSVRFTV9DT1VOVH0gcGFnZSBpdGVtc2ApO1xuICB9XG4gIGlmICh3aWR0aCAlIDIgPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE11c3QgYWxsb3cgb2RkIG51bWJlciBvZiBwYWdlIGl0ZW1zYCk7XG4gIH1cbiAgaWYgKHRvdGFsIDwgd2lkdGgpIHtcbiAgICByZXR1cm4gWy4uLm5ldyBBcnJheSh0b3RhbCkua2V5cygpXTtcbiAgfVxuICBjb25zdCBsZWZ0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odG90YWwgLSB3aWR0aCwgY3VycmVudCAtIE1hdGguZmxvb3Iod2lkdGggLyAyKSkpO1xuICBjb25zdCBpdGVtczogKHN0cmluZyB8IG51bWJlcilbXSA9IG5ldyBBcnJheSh3aWR0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgd2lkdGg7IGkgKz0gMSkge1xuICAgIGl0ZW1zW2ldID0gaSArIGxlZnQ7XG4gIH1cbiAgLy8gcmVwbGFjZSBub24tZW5kaW5nIGl0ZW1zIHdpdGggcGxhY2Vob2xkZXJzXG4gIGlmIChpdGVtc1swXSA+IDApIHtcbiAgICBpdGVtc1swXSA9IDA7XG4gICAgaXRlbXNbMV0gPSAncHJldi1tb3JlJztcbiAgfVxuICBpZiAoaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV0gPCB0b3RhbCAtIDEpIHtcbiAgICBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXSA9IHRvdGFsIC0gMTtcbiAgICBpdGVtc1tpdGVtcy5sZW5ndGggLSAyXSA9ICduZXh0LW1vcmUnO1xuICB9XG4gIHJldHVybiBpdGVtcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVhY3QubWVtbyhcbiAgUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBQYWdpbmF0aW9uKFxuICAgIHsgc3R5bGUsIHBhZ2VDb3VudCwgY3VycmVudFBhZ2UgPSAwLCBtYXhQYWdlSXRlbUNvdW50ID0gOSwgb25QYWdlQ2hhbmdlIH06IFBhZ2luYXRpb25Qcm9wcyxcbiAgICByZWY6IFJlYWN0LlJlZjxIVE1MRGl2RWxlbWVudD4sXG4gICkge1xuICAgIGNvbnN0IHBhZ2VJdGVtcyA9IGdlbmVyYXRlUGFnZUl0ZW1zKHBhZ2VDb3VudCwgY3VycmVudFBhZ2UsIG1heFBhZ2VJdGVtQ291bnQpO1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IHJlZj17cmVmfSBjbGFzc05hbWU9XCJkdC1wYWdpbmF0aW9uXCIgc3R5bGU9e3N0eWxlfT5cbiAgICAgICAgPHVsIGNsYXNzTmFtZT1cInBhZ2luYXRpb24gcGFnaW5hdGlvbi1zbVwiPlxuICAgICAgICAgIHtwYWdlSXRlbXMubWFwKGl0ZW0gPT5cbiAgICAgICAgICAgIHR5cGVvZiBpdGVtID09PSAnbnVtYmVyJyA/IChcbiAgICAgICAgICAgICAgLy8gYWN0dWFsIHBhZ2UgbnVtYmVyXG4gICAgICAgICAgICAgIDxsaSBrZXk9e2l0ZW19IGNsYXNzTmFtZT17Y3VycmVudFBhZ2UgPT09IGl0ZW0gPyAnYWN0aXZlJyA6IHVuZGVmaW5lZH0+XG4gICAgICAgICAgICAgICAgPGFcbiAgICAgICAgICAgICAgICAgIGhyZWY9e2AjcGFnZS0ke2l0ZW19YH1cbiAgICAgICAgICAgICAgICAgIHJvbGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICAgICAgb25DbGljaz17ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgb25QYWdlQ2hhbmdlKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICB7aXRlbSArIDF9XG4gICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgPGxpIGtleT17aXRlbX0gY2xhc3NOYW1lPVwiZHQtcGFnaW5hdGlvbi1lbGxpcHNpc1wiPlxuICAgICAgICAgICAgICAgIDxzcGFuPuKApjwvc3Bhbj5cbiAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgICksXG4gICAgICAgICAgKX1cbiAgICAgICAgPC91bD5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH0pLFxuKTtcbiIsIi8qKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmxldCBjYWNoZWQ6IG51bWJlciB8IHVuZGVmaW5lZDtcblxuY29uc3QgY3NzID0gKHg6IFRlbXBsYXRlU3RyaW5nc0FycmF5KSA9PiB4LmpvaW4oJ1xcbicpO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRTY3JvbGxCYXJTaXplKGZvcmNlUmVmcmVzaCA9IGZhbHNlKSB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKGNhY2hlZCA9PT0gdW5kZWZpbmVkIHx8IGZvcmNlUmVmcmVzaCkge1xuICAgIGNvbnN0IGlubmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29uc3Qgb3V0ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBpbm5lci5zdHlsZS5jc3NUZXh0ID0gY3NzYFxuICAgICAgd2lkdGg6IGF1dG87XG4gICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICBvdmVyZmxvdzogc2Nyb2xsO1xuICAgIGA7XG4gICAgb3V0ZXIuc3R5bGUuY3NzVGV4dCA9IGNzc2BcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICB3aWR0aDogMTAwcHg7XG4gICAgICBoZWlnaHQ6IDUwcHg7XG4gICAgYDtcbiAgICBvdXRlci5hcHBlbmQoaW5uZXIpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKG91dGVyKTtcbiAgICBjYWNoZWQgPSBvdXRlci5jbGllbnRXaWR0aCAtIGlubmVyLmNsaWVudFdpZHRoO1xuICAgIG91dGVyLnJlbW92ZSgpO1xuICB9XG4gIHJldHVybiBjYWNoZWQ7XG59XG4iLCIvKipcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFdoZXRoZXIgYSBjb250YWluZXIgbmVlZCBzY3JvbGwgYmFycyB3aGVuIGluIGFub3RoZXIgY29udGFpbmVyLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBuZWVkU2Nyb2xsQmFyKHtcbiAgd2lkdGgsXG4gIGhlaWdodCxcbiAgaW5uZXJIZWlnaHQsXG4gIGlubmVyV2lkdGgsXG4gIHNjcm9sbEJhclNpemUsXG59OiB7XG4gIHdpZHRoOiBudW1iZXI7XG4gIGhlaWdodDogbnVtYmVyO1xuICBpbm5lckhlaWdodDogbnVtYmVyO1xuICBzY3JvbGxCYXJTaXplOiBudW1iZXI7XG4gIGlubmVyV2lkdGg6IG51bWJlcjtcbn0pOiBbYm9vbGVhbiwgYm9vbGVhbl0ge1xuICBjb25zdCBoYXNWZXJ0aWNhbFNjcm9sbCA9IGlubmVySGVpZ2h0ID4gaGVpZ2h0O1xuICBjb25zdCBoYXNIb3Jpem9udGFsU2Nyb2xsID0gaW5uZXJXaWR0aCA+IHdpZHRoIC0gKGhhc1ZlcnRpY2FsU2Nyb2xsID8gc2Nyb2xsQmFyU2l6ZSA6IDApO1xuICByZXR1cm4gW2hhc1ZlcnRpY2FsU2Nyb2xsLCBoYXNIb3Jpem9udGFsU2Nyb2xsXTtcbn1cbiIsIi8qKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCwgdXNlUmVmLCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIEV4ZWN1dGUgYSBtZW1vaXplZCBjYWxsYmFjayBvbmx5IHdoZW4gbW91bnRlZC4gRXhlY3V0ZSBhZ2FpbiB3aGVuIGZhY3RvcnkgdXBkYXRlZC5cbiAqIFJldHVybnMgdW5kZWZpbmVkIGlmIG5vdCBtb3VudGVkIHlldC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXNlTW91bnRlZE1lbW88VD4oZmFjdG9yeTogKCkgPT4gVCwgZGVwcz86IHVua25vd25bXSk6IFQgfCB1bmRlZmluZWQge1xuICBjb25zdCBtb3VudGVkID0gdXNlUmVmPHR5cGVvZiBmYWN0b3J5PigpO1xuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIG1vdW50ZWQuY3VycmVudCA9IGZhY3Rvcnk7XG4gIH0pO1xuICByZXR1cm4gdXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKG1vdW50ZWQuY3VycmVudCkge1xuICAgICAgcmV0dXJuIGZhY3RvcnkoKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFttb3VudGVkLmN1cnJlbnQsIG1vdW50ZWQuY3VycmVudCA9PT0gZmFjdG9yeSwgLi4uKGRlcHMgfHwgW10pXSk7XG59XG4iLCIvKipcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgUmVhY3QsIHtcbiAgdXNlUmVmLFxuICB1c2VNZW1vLFxuICB1c2VMYXlvdXRFZmZlY3QsXG4gIHVzZUNhbGxiYWNrLFxuICBSZWFjdE5vZGUsXG4gIFJlYWN0RWxlbWVudCxcbiAgQ29tcG9uZW50UHJvcHNXaXRoUmVmLFxuICBDU1NQcm9wZXJ0aWVzLFxuICBVSUV2ZW50SGFuZGxlcixcbn0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgVGFibGVJbnN0YW5jZSwgSG9va3MgfSBmcm9tICdyZWFjdC10YWJsZSc7XG5pbXBvcnQgZ2V0U2Nyb2xsQmFyU2l6ZSBmcm9tICcuLi91dGlscy9nZXRTY3JvbGxCYXJTaXplJztcbmltcG9ydCBuZWVkU2Nyb2xsQmFyIGZyb20gJy4uL3V0aWxzL25lZWRTY3JvbGxCYXInO1xuaW1wb3J0IHVzZU1vdW50ZWRNZW1vIGZyb20gJy4uL3V0aWxzL3VzZU1vdW50ZWRNZW1vJztcblxudHlwZSBSZWFjdEVsZW1lbnRXaXRoQ2hpbGRyZW48XG4gIFQgZXh0ZW5kcyBrZXlvZiBKU1guSW50cmluc2ljRWxlbWVudHMsXG4gIEMgZXh0ZW5kcyBSZWFjdE5vZGUgPSBSZWFjdE5vZGVcbj4gPSBSZWFjdEVsZW1lbnQ8Q29tcG9uZW50UHJvcHNXaXRoUmVmPFQ+ICYgeyBjaGlsZHJlbjogQyB9LCBUPjtcblxudHlwZSBUaCA9IFJlYWN0RWxlbWVudFdpdGhDaGlsZHJlbjwndGgnPjtcbnR5cGUgVGQgPSBSZWFjdEVsZW1lbnRXaXRoQ2hpbGRyZW48J3RkJz47XG50eXBlIFRyV2l0aFRoID0gUmVhY3RFbGVtZW50V2l0aENoaWxkcmVuPCd0cicsIFRoW10+O1xudHlwZSBUcldpdGhUZCA9IFJlYWN0RWxlbWVudFdpdGhDaGlsZHJlbjwndHInLCBUZFtdPjtcbnR5cGUgVGhlYWQgPSBSZWFjdEVsZW1lbnRXaXRoQ2hpbGRyZW48J3RoZWFkJywgVHJXaXRoVGg+O1xudHlwZSBUYm9keSA9IFJlYWN0RWxlbWVudFdpdGhDaGlsZHJlbjwndGJvZHknLCBUcldpdGhUZD47XG50eXBlIFRmb290ID0gUmVhY3RFbGVtZW50V2l0aENoaWxkcmVuPCd0Zm9vdCcsIFRyV2l0aFRkPjtcbnR5cGUgQ29sID0gUmVhY3RFbGVtZW50V2l0aENoaWxkcmVuPCdjb2wnLCBudWxsPjtcbnR5cGUgQ29sR3JvdXAgPSBSZWFjdEVsZW1lbnRXaXRoQ2hpbGRyZW48J2NvbGdyb3VwJywgQ29sPjtcblxuZXhwb3J0IHR5cGUgVGFibGUgPSBSZWFjdEVsZW1lbnRXaXRoQ2hpbGRyZW48J3RhYmxlJywgKFRoZWFkIHwgVGJvZHkgfCBUZm9vdCB8IENvbEdyb3VwKVtdPjtcbmV4cG9ydCB0eXBlIFRhYmxlUmVuZGVyZXIgPSAoKSA9PiBUYWJsZTtcbmV4cG9ydCB0eXBlIEdldFRhYmxlU2l6ZSA9ICgpID0+IFBhcnRpYWw8U3RpY2t5U3RhdGU+IHwgdW5kZWZpbmVkO1xuZXhwb3J0IHR5cGUgU2V0U3RpY2t5U3RhdGUgPSAoc2l6ZT86IFBhcnRpYWw8U3RpY2t5U3RhdGU+KSA9PiB2b2lkO1xuXG5leHBvcnQgZW51bSBSZWR1Y2VyQWN0aW9ucyB7XG4gIGluaXQgPSAnaW5pdCcsIC8vIHRoaXMgaXMgZnJvbSBnbG9iYWwgcmVkdWNlclxuICBzZXRTdGlja3lTdGF0ZSA9ICdzZXRTdGlja3lTdGF0ZScsXG59XG5cbmV4cG9ydCB0eXBlIFJlZHVjZXJBY3Rpb248VCBleHRlbmRzIHN0cmluZywgUCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIHVua25vd24+PiA9IFAgJiB7IHR5cGU6IFQgfTtcblxuZXhwb3J0IHR5cGUgQ29sdW1uV2lkdGhzID0gbnVtYmVyW107XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RpY2t5U3RhdGUge1xuICB3aWR0aD86IG51bWJlcjsgLy8gbWF4aW11bSBmdWxsIHRhYmxlIHdpZHRoXG4gIGhlaWdodD86IG51bWJlcjsgLy8gbWF4aW11bSBmdWxsIHRhYmxlIGhlaWdodFxuICByZWFsSGVpZ2h0PzogbnVtYmVyOyAvLyBhY3R1YWwgdGFibGUgdmlld3BvcnQgaGVpZ2h0IChoZWFkZXIgKyBzY3JvbGxhYmxlIGFyZWEpXG4gIGJvZHlIZWlnaHQ/OiBudW1iZXI7IC8vIHNjcm9sbGFibGUgYXJlYSBoZWlnaHRcbiAgdGFibGVIZWlnaHQ/OiBudW1iZXI7IC8vIHRoZSBmdWxsIHRhYmxlIGhlaWdodFxuICBjb2x1bW5XaWR0aHM/OiBDb2x1bW5XaWR0aHM7XG4gIGhhc0hvcml6b250YWxTY3JvbGw/OiBib29sZWFuO1xuICBoYXNWZXJ0aWNhbFNjcm9sbD86IGJvb2xlYW47XG4gIHJlbmRlcmluZz86IGJvb2xlYW47XG4gIHNldFN0aWNreVN0YXRlPzogU2V0U3RpY2t5U3RhdGU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU3RpY2t5VGFibGVPcHRpb25zIHtcbiAgZ2V0VGFibGVTaXplPzogR2V0VGFibGVTaXplO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVN0aWNreUluc3RhbmNlUHJvcHMge1xuICAvLyBtYW5pcHVsYXRlIERPTXMgaW4gPHRhYmxlPiB0byBtYWtlIHRoZSBoZWFkZXIgc3RpY2t5XG4gIHdyYXBTdGlja3lUYWJsZTogKHJlbmRlcmVyOiBUYWJsZVJlbmRlcmVyKSA9PiBSZWFjdE5vZGU7XG4gIC8vIHVwZGF0ZSBvciByZWNvbXB1dGUgdGhlIHN0aWNreSB0YWJsZSBzaXplXG4gIHNldFN0aWNreVN0YXRlOiBTZXRTdGlja3lTdGF0ZTtcbn1cblxuZXhwb3J0IHR5cGUgVXNlU3RpY2t5U3RhdGUgPSB7XG4gIHN0aWNreTogU3RpY2t5U3RhdGU7XG59O1xuXG5jb25zdCBzdW0gPSAoYTogbnVtYmVyLCBiOiBudW1iZXIpID0+IGEgKyBiO1xuY29uc3QgbWVyZ2VTdHlsZVByb3AgPSAobm9kZTogUmVhY3RFbGVtZW50PHsgc3R5bGU/OiBDU1NQcm9wZXJ0aWVzIH0+LCBzdHlsZTogQ1NTUHJvcGVydGllcykgPT4gKHtcbiAgc3R5bGU6IHtcbiAgICAuLi5ub2RlLnByb3BzLnN0eWxlLFxuICAgIC4uLnN0eWxlLFxuICB9LFxufSk7XG5jb25zdCBmaXhlZFRhYmxlTGF5b3V0OiBDU1NQcm9wZXJ0aWVzID0geyB0YWJsZUxheW91dDogJ2ZpeGVkJyB9O1xuXG4vKipcbiAqIEFuIEhPQyBmb3IgZ2VuZXJhdGluZyBzdGlja3kgaGVhZGVyIGFuZCBmaXhlZC1oZWlnaHQgc2Nyb2xsYWJsZSBhcmVhXG4gKi9cbmZ1bmN0aW9uIFN0aWNreVdyYXAoe1xuICBzdGlja3kgPSB7fSxcbiAgd2lkdGg6IG1heFdpZHRoLFxuICBoZWlnaHQ6IG1heEhlaWdodCxcbiAgY2hpbGRyZW46IHRhYmxlLFxuICBzZXRTdGlja3lTdGF0ZSxcbn06IHtcbiAgd2lkdGg6IG51bWJlcjtcbiAgaGVpZ2h0OiBudW1iZXI7XG4gIHNldFN0aWNreVN0YXRlOiBTZXRTdGlja3lTdGF0ZTtcbiAgY2hpbGRyZW46IFRhYmxlO1xuICBzdGlja3k/OiBTdGlja3lTdGF0ZTsgLy8gY3VycmVudCBzdGlja3kgZWxlbWVudCBzaXplc1xufSkge1xuICBpZiAoIXRhYmxlIHx8IHRhYmxlLnR5cGUgIT09ICd0YWJsZScpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJzxTdGlja3lXcmFwPiBtdXN0IGhhdmUgb25seSBvbmUgPHRhYmxlPiBlbGVtZW50IGFzIGNoaWxkJyk7XG4gIH1cbiAgbGV0IHRoZWFkOiBUaGVhZCB8IHVuZGVmaW5lZDtcbiAgbGV0IHRib2R5OiBUYm9keSB8IHVuZGVmaW5lZDtcbiAgbGV0IHRmb290OiBUZm9vdCB8IHVuZGVmaW5lZDtcblxuICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKHRhYmxlLnByb3BzLmNoaWxkcmVuLCBub2RlID0+IHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gJ3RoZWFkJykge1xuICAgICAgdGhlYWQgPSBub2RlO1xuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAndGJvZHknKSB7XG4gICAgICB0Ym9keSA9IG5vZGU7XG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09ICd0Zm9vdCcpIHtcbiAgICAgIHRmb290ID0gbm9kZTtcbiAgICB9XG4gIH0pO1xuICBpZiAoIXRoZWFkIHx8ICF0Ym9keSkge1xuICAgIHRocm93IG5ldyBFcnJvcignPHRhYmxlPiBpbiA8U3RpY2t5V3JhcD4gbXVzdCBjb250YWluIGJvdGggdGhlYWQgYW5kIHRib2R5LicpO1xuICB9XG4gIGNvbnN0IGNvbHVtbkNvdW50ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgaGVhZGVyUm93cyA9IFJlYWN0LkNoaWxkcmVuLnRvQXJyYXkodGhlYWQ/LnByb3BzLmNoaWxkcmVuKS5wb3AoKSBhcyBUcldpdGhUaDtcbiAgICByZXR1cm4gaGVhZGVyUm93cy5wcm9wcy5jaGlsZHJlbi5sZW5ndGg7XG4gIH0sIFt0aGVhZF0pO1xuXG4gIGNvbnN0IHRoZWFkUmVmID0gdXNlUmVmPEhUTUxUYWJsZVNlY3Rpb25FbGVtZW50PihudWxsKTsgLy8gb3JpZ2luYWwgdGhlYWQgZm9yIGxheW91dCBjb21wdXRhdGlvblxuICBjb25zdCB0Zm9vdFJlZiA9IHVzZVJlZjxIVE1MVGFibGVTZWN0aW9uRWxlbWVudD4obnVsbCk7IC8vIG9yaWdpbmFsIHRmb290IGZvciBsYXlvdXQgY29tcHV0YXRpb25cbiAgY29uc3Qgc2Nyb2xsSGVhZGVyUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTsgLy8gZml4ZWQgaGVhZGVyXG4gIGNvbnN0IHNjcm9sbEZvb3RlclJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCk7IC8vIGZpeGVkIGZvb3RlclxuICBjb25zdCBzY3JvbGxCb2R5UmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTsgLy8gbWFpbiBib2R5XG5cbiAgY29uc3Qgc2Nyb2xsQmFyU2l6ZSA9IGdldFNjcm9sbEJhclNpemUoKTtcbiAgY29uc3QgeyBib2R5SGVpZ2h0LCBjb2x1bW5XaWR0aHMgfSA9IHN0aWNreTtcbiAgY29uc3QgbmVlZFNpemVyID1cbiAgICAhY29sdW1uV2lkdGhzIHx8XG4gICAgc3RpY2t5LndpZHRoICE9PSBtYXhXaWR0aCB8fFxuICAgIHN0aWNreS5oZWlnaHQgIT09IG1heEhlaWdodCB8fFxuICAgIHN0aWNreS5zZXRTdGlja3lTdGF0ZSAhPT0gc2V0U3RpY2t5U3RhdGU7XG5cbiAgLy8gdXBkYXRlIHNjcm9sbGFibGUgYXJlYSBhbmQgaGVhZGVyIGNvbHVtbiBzaXplcyB3aGVuIG1vdW50ZWRcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXRoZWFkUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYm9keVRoZWFkID0gdGhlYWRSZWYuY3VycmVudDtcbiAgICBjb25zdCB0aGVhZEhlaWdodCA9IGJvZHlUaGVhZC5jbGllbnRIZWlnaHQ7XG4gICAgY29uc3QgdGZvb3RIZWlnaHQgPSB0Zm9vdFJlZi5jdXJyZW50ID8gdGZvb3RSZWYuY3VycmVudC5jbGllbnRIZWlnaHQgOiAwO1xuICAgIGlmICghdGhlYWRIZWlnaHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZnVsbFRhYmxlSGVpZ2h0ID0gKGJvZHlUaGVhZC5wYXJlbnROb2RlIGFzIEhUTUxUYWJsZUVsZW1lbnQpLmNsaWVudEhlaWdodDtcbiAgICBjb25zdCB0aHMgPSBib2R5VGhlYWQuY2hpbGROb2Rlc1swXS5jaGlsZE5vZGVzIGFzIE5vZGVMaXN0T2Y8SFRNTFRhYmxlSGVhZGVyQ2VsbEVsZW1lbnQ+O1xuICAgIGNvbnN0IHdpZHRocyA9IEFycmF5LmZyb20odGhzKS5tYXAodGggPT4gdGguY2xpZW50V2lkdGgpO1xuICAgIGNvbnN0IFtoYXNWZXJ0aWNhbFNjcm9sbCwgaGFzSG9yaXpvbnRhbFNjcm9sbF0gPSBuZWVkU2Nyb2xsQmFyKHtcbiAgICAgIHdpZHRoOiBtYXhXaWR0aCxcbiAgICAgIGhlaWdodDogbWF4SGVpZ2h0IC0gdGhlYWRIZWlnaHQgLSB0Zm9vdEhlaWdodCxcbiAgICAgIGlubmVySGVpZ2h0OiBmdWxsVGFibGVIZWlnaHQsXG4gICAgICBpbm5lcldpZHRoOiB3aWR0aHMucmVkdWNlKHN1bSksXG4gICAgICBzY3JvbGxCYXJTaXplLFxuICAgIH0pO1xuICAgIC8vIHJlYWwgY29udGFpbmVyIGhlaWdodCwgaW5jbHVkZSB0YWJsZSBoZWFkZXIsIGZvb3RlciBhbmQgc3BhY2UgZm9yXG4gICAgLy8gaG9yaXpvbnRhbCBzY3JvbGwgYmFyXG4gICAgY29uc3QgcmVhbEhlaWdodCA9IE1hdGgubWluKFxuICAgICAgbWF4SGVpZ2h0LFxuICAgICAgaGFzSG9yaXpvbnRhbFNjcm9sbCA/IGZ1bGxUYWJsZUhlaWdodCArIHNjcm9sbEJhclNpemUgOiBmdWxsVGFibGVIZWlnaHQsXG4gICAgKTtcbiAgICBzZXRTdGlja3lTdGF0ZSh7XG4gICAgICBoYXNWZXJ0aWNhbFNjcm9sbCxcbiAgICAgIGhhc0hvcml6b250YWxTY3JvbGwsXG4gICAgICBzZXRTdGlja3lTdGF0ZSxcbiAgICAgIHdpZHRoOiBtYXhXaWR0aCxcbiAgICAgIGhlaWdodDogbWF4SGVpZ2h0LFxuICAgICAgcmVhbEhlaWdodCxcbiAgICAgIHRhYmxlSGVpZ2h0OiBmdWxsVGFibGVIZWlnaHQsXG4gICAgICBib2R5SGVpZ2h0OiByZWFsSGVpZ2h0IC0gdGhlYWRIZWlnaHQgLSB0Zm9vdEhlaWdodCxcbiAgICAgIGNvbHVtbldpZHRoczogd2lkdGhzLFxuICAgIH0pO1xuICB9LCBbbWF4V2lkdGgsIG1heEhlaWdodCwgc2V0U3RpY2t5U3RhdGUsIHNjcm9sbEJhclNpemVdKTtcblxuICBsZXQgc2l6ZXJUYWJsZTogUmVhY3RFbGVtZW50IHwgdW5kZWZpbmVkO1xuICBsZXQgaGVhZGVyVGFibGU6IFJlYWN0RWxlbWVudCB8IHVuZGVmaW5lZDtcbiAgbGV0IGZvb3RlclRhYmxlOiBSZWFjdEVsZW1lbnQgfCB1bmRlZmluZWQ7XG4gIGxldCBib2R5VGFibGU6IFJlYWN0RWxlbWVudCB8IHVuZGVmaW5lZDtcbiAgaWYgKG5lZWRTaXplcikge1xuICAgIGNvbnN0IHRoZWFkV2l0aFJlZiA9IFJlYWN0LmNsb25lRWxlbWVudCh0aGVhZCwgeyByZWY6IHRoZWFkUmVmIH0pO1xuICAgIGNvbnN0IHRmb290V2l0aFJlZiA9IHRmb290ICYmIFJlYWN0LmNsb25lRWxlbWVudCh0Zm9vdCwgeyByZWY6IHRmb290UmVmIH0pO1xuICAgIHNpemVyVGFibGUgPSAoXG4gICAgICA8ZGl2XG4gICAgICAgIGtleT1cInNpemVyXCJcbiAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICBoZWlnaHQ6IG1heEhlaWdodCxcbiAgICAgICAgICBvdmVyZmxvdzogJ2F1dG8nLFxuICAgICAgICAgIHZpc2liaWxpdHk6ICdoaWRkZW4nLFxuICAgICAgICB9fVxuICAgICAgPlxuICAgICAgICB7UmVhY3QuY2xvbmVFbGVtZW50KHRhYmxlLCB7fSwgdGhlYWRXaXRoUmVmLCB0Ym9keSwgdGZvb3RXaXRoUmVmKX1cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICAvLyByZXVzZSBwcmV2aW91c2x5IGNvbHVtbiB3aWR0aHMsIHdpbGwgYmUgdXBkYXRlZCBieSBgdXNlTGF5b3V0RWZmZWN0YCBhYm92ZVxuICBjb25zdCBjb2xXaWR0aHMgPSBjb2x1bW5XaWR0aHM/LnNsaWNlKDAsIGNvbHVtbkNvdW50KTtcblxuICBpZiAoY29sV2lkdGhzICYmIGJvZHlIZWlnaHQpIHtcbiAgICBjb25zdCBib2R5Q29sZ3JvdXAgPSAoXG4gICAgICA8Y29sZ3JvdXA+XG4gICAgICAgIHtjb2xXaWR0aHMubWFwKCh3LCBpKSA9PiAoXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L25vLWFycmF5LWluZGV4LWtleVxuICAgICAgICAgIDxjb2wga2V5PXtpfSB3aWR0aD17d30gLz5cbiAgICAgICAgKSl9XG4gICAgICA8L2NvbGdyb3VwPlxuICAgICk7XG5cbiAgICAvLyBoZWFkZXIgY29sdW1ucyBkbyBub3QgaGF2ZSB2ZXJ0aWNhbCBzY3JvbGwgYmFycyxcbiAgICAvLyBzbyB3ZSBhZGQgc2Nyb2xsIGJhciBzaXplIHRvIHRoZSBsYXN0IGNvbHVtblxuICAgIGNvbnN0IGhlYWRlckNvbGdyb3VwID1cbiAgICAgIHN0aWNreS5oYXNWZXJ0aWNhbFNjcm9sbCAmJiBzY3JvbGxCYXJTaXplID8gKFxuICAgICAgICA8Y29sZ3JvdXA+XG4gICAgICAgICAge2NvbFdpZHRocy5tYXAoKHgsIGkpID0+IChcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9uby1hcnJheS1pbmRleC1rZXlcbiAgICAgICAgICAgIDxjb2wga2V5PXtpfSB3aWR0aD17eCArIChpID09PSBjb2xXaWR0aHMubGVuZ3RoIC0gMSA/IHNjcm9sbEJhclNpemUgOiAwKX0gLz5cbiAgICAgICAgICApKX1cbiAgICAgICAgPC9jb2xncm91cD5cbiAgICAgICkgOiAoXG4gICAgICAgIGJvZHlDb2xncm91cFxuICAgICAgKTtcblxuICAgIGhlYWRlclRhYmxlID0gKFxuICAgICAgPGRpdlxuICAgICAgICBrZXk9XCJoZWFkZXJcIlxuICAgICAgICByZWY9e3Njcm9sbEhlYWRlclJlZn1cbiAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgIH19XG4gICAgICA+XG4gICAgICAgIHtSZWFjdC5jbG9uZUVsZW1lbnQodGFibGUsIG1lcmdlU3R5bGVQcm9wKHRhYmxlLCBmaXhlZFRhYmxlTGF5b3V0KSwgaGVhZGVyQ29sZ3JvdXAsIHRoZWFkKX1cbiAgICAgICAge2hlYWRlclRhYmxlfVxuICAgICAgPC9kaXY+XG4gICAgKTtcblxuICAgIGZvb3RlclRhYmxlID0gdGZvb3QgJiYgKFxuICAgICAgPGRpdlxuICAgICAgICBrZXk9XCJmb290ZXJcIlxuICAgICAgICByZWY9e3Njcm9sbEZvb3RlclJlZn1cbiAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgIH19XG4gICAgICA+XG4gICAgICAgIHtSZWFjdC5jbG9uZUVsZW1lbnQodGFibGUsIG1lcmdlU3R5bGVQcm9wKHRhYmxlLCBmaXhlZFRhYmxlTGF5b3V0KSwgaGVhZGVyQ29sZ3JvdXAsIHRmb290KX1cbiAgICAgICAge2Zvb3RlclRhYmxlfVxuICAgICAgPC9kaXY+XG4gICAgKTtcblxuICAgIGNvbnN0IG9uU2Nyb2xsOiBVSUV2ZW50SGFuZGxlcjxIVE1MRGl2RWxlbWVudD4gPSBlID0+IHtcbiAgICAgIGlmIChzY3JvbGxIZWFkZXJSZWYuY3VycmVudCkge1xuICAgICAgICBzY3JvbGxIZWFkZXJSZWYuY3VycmVudC5zY3JvbGxMZWZ0ID0gZS5jdXJyZW50VGFyZ2V0LnNjcm9sbExlZnQ7XG4gICAgICB9XG4gICAgICBpZiAoc2Nyb2xsRm9vdGVyUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgc2Nyb2xsRm9vdGVyUmVmLmN1cnJlbnQuc2Nyb2xsTGVmdCA9IGUuY3VycmVudFRhcmdldC5zY3JvbGxMZWZ0O1xuICAgICAgfVxuICAgIH07XG4gICAgYm9keVRhYmxlID0gKFxuICAgICAgPGRpdlxuICAgICAgICBrZXk9XCJib2R5XCJcbiAgICAgICAgcmVmPXtzY3JvbGxCb2R5UmVmfVxuICAgICAgICBzdHlsZT17e1xuICAgICAgICAgIGhlaWdodDogYm9keUhlaWdodCxcbiAgICAgICAgICBvdmVyZmxvdzogJ2F1dG8nLFxuICAgICAgICB9fVxuICAgICAgICBvblNjcm9sbD17c3RpY2t5Lmhhc0hvcml6b250YWxTY3JvbGwgPyBvblNjcm9sbCA6IHVuZGVmaW5lZH1cbiAgICAgID5cbiAgICAgICAge1JlYWN0LmNsb25lRWxlbWVudCh0YWJsZSwgbWVyZ2VTdHlsZVByb3AodGFibGUsIGZpeGVkVGFibGVMYXlvdXQpLCBib2R5Q29sZ3JvdXAsIHRib2R5KX1cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIHN0eWxlPXt7XG4gICAgICAgIHdpZHRoOiBtYXhXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiBzdGlja3kucmVhbEhlaWdodCB8fCBtYXhIZWlnaHQsXG4gICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgIH19XG4gICAgPlxuICAgICAge2hlYWRlclRhYmxlfVxuICAgICAge2JvZHlUYWJsZX1cbiAgICAgIHtmb290ZXJUYWJsZX1cbiAgICAgIHtzaXplclRhYmxlfVxuICAgIDwvZGl2PlxuICApO1xufVxuXG5mdW5jdGlvbiB1c2VJbnN0YW5jZTxEIGV4dGVuZHMgb2JqZWN0PihpbnN0YW5jZTogVGFibGVJbnN0YW5jZTxEPikge1xuICBjb25zdCB7XG4gICAgZGlzcGF0Y2gsXG4gICAgc3RhdGU6IHsgc3RpY2t5IH0sXG4gICAgZGF0YSxcbiAgICBwYWdlLFxuICAgIHJvd3MsXG4gICAgZ2V0VGFibGVTaXplID0gKCkgPT4gdW5kZWZpbmVkLFxuICB9ID0gaW5zdGFuY2U7XG5cbiAgY29uc3Qgc2V0U3RpY2t5U3RhdGUgPSB1c2VDYWxsYmFjayhcbiAgICAoc2l6ZT86IFBhcnRpYWw8U3RpY2t5U3RhdGU+KSA9PiB7XG4gICAgICBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IFJlZHVjZXJBY3Rpb25zLnNldFN0aWNreVN0YXRlLFxuICAgICAgICBzaXplLFxuICAgICAgfSk7XG4gICAgfSxcbiAgICAvLyB0dXJuaW5nIHBhZ2VzIHdvdWxkIGFsc28gdHJpZ2dlciBhIHJlc2l6ZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBbZGlzcGF0Y2gsIGdldFRhYmxlU2l6ZSwgcGFnZSwgcm93c10sXG4gICk7XG5cbiAgY29uc3QgdXNlU3RpY2t5V3JhcCA9IChyZW5kZXJlcjogVGFibGVSZW5kZXJlcikgPT4ge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdXNlTW91bnRlZE1lbW8oZ2V0VGFibGVTaXplLCBbZ2V0VGFibGVTaXplXSkgfHwgc3RpY2t5O1xuICAgIC8vIG9ubHkgY2hhbmdlIG9mIGRhdGEgc2hvdWxkIHRyaWdnZXIgcmUtcmVuZGVyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIGNvbnN0IHRhYmxlID0gdXNlTWVtbyhyZW5kZXJlciwgW3BhZ2UsIHJvd3NdKTtcblxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICBpZiAoIXdpZHRoIHx8ICFoZWlnaHQpIHtcbiAgICAgICAgc2V0U3RpY2t5U3RhdGUoKTtcbiAgICAgIH1cbiAgICB9LCBbd2lkdGgsIGhlaWdodF0pO1xuXG4gICAgaWYgKCF3aWR0aCB8fCAhaGVpZ2h0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGFibGU7XG4gICAgfVxuICAgIHJldHVybiAoXG4gICAgICA8U3RpY2t5V3JhcCB3aWR0aD17d2lkdGh9IGhlaWdodD17aGVpZ2h0fSBzdGlja3k9e3N0aWNreX0gc2V0U3RpY2t5U3RhdGU9e3NldFN0aWNreVN0YXRlfT5cbiAgICAgICAge3RhYmxlfVxuICAgICAgPC9TdGlja3lXcmFwPlxuICAgICk7XG4gIH07XG5cbiAgT2JqZWN0LmFzc2lnbihpbnN0YW5jZSwge1xuICAgIHNldFN0aWNreVN0YXRlLFxuICAgIHdyYXBTdGlja3lUYWJsZTogdXNlU3RpY2t5V3JhcCxcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVzZVN0aWNreTxEIGV4dGVuZHMgb2JqZWN0Pihob29rczogSG9va3M8RD4pIHtcbiAgaG9va3MudXNlSW5zdGFuY2UucHVzaCh1c2VJbnN0YW5jZSk7XG4gIGhvb2tzLnN0YXRlUmVkdWNlcnMucHVzaCgobmV3U3RhdGUsIGFjdGlvbl8sIHByZXZTdGF0ZSkgPT4ge1xuICAgIGNvbnN0IGFjdGlvbiA9IGFjdGlvbl8gYXMgUmVkdWNlckFjdGlvbjxSZWR1Y2VyQWN0aW9ucywgeyBzaXplOiBTdGlja3lTdGF0ZSB9PjtcbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IFJlZHVjZXJBY3Rpb25zLmluaXQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm5ld1N0YXRlLFxuICAgICAgICBzdGlja3k6IHtcbiAgICAgICAgICAuLi5wcmV2U3RhdGU/LnN0aWNreSxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gUmVkdWNlckFjdGlvbnMuc2V0U3RpY2t5U3RhdGUpIHtcbiAgICAgIGNvbnN0IHsgc2l6ZSB9ID0gYWN0aW9uO1xuICAgICAgaWYgKCFzaXplKSB7XG4gICAgICAgIHJldHVybiB7IC4uLm5ld1N0YXRlIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5uZXdTdGF0ZSxcbiAgICAgICAgc3RpY2t5OiB7XG4gICAgICAgICAgLi4ucHJldlN0YXRlPy5zdGlja3ksXG4gICAgICAgICAgLi4ubmV3U3RhdGU/LnN0aWNreSxcbiAgICAgICAgICAuLi5hY3Rpb24uc2l6ZSxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgfSk7XG59XG51c2VTdGlja3kucGx1Z2luTmFtZSA9ICd1c2VTdGlja3knO1xuIiwiLyoqXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IFJlYWN0LCB7XG4gIHVzZUNhbGxiYWNrLFxuICB1c2VSZWYsXG4gIFJlYWN0Tm9kZSxcbiAgSFRNTFByb3BzLFxuICBNdXRhYmxlUmVmT2JqZWN0LFxuICBDU1NQcm9wZXJ0aWVzLFxufSBmcm9tICdyZWFjdCc7XG5pbXBvcnQge1xuICB1c2VUYWJsZSxcbiAgdXNlUGFnaW5hdGlvbixcbiAgdXNlU29ydEJ5LFxuICB1c2VHbG9iYWxGaWx0ZXIsXG4gIFBsdWdpbkhvb2ssXG4gIFRhYmxlT3B0aW9ucyxcbiAgRmlsdGVyVHlwZSxcbiAgSWRUeXBlLFxuICBSb3csXG59IGZyb20gJ3JlYWN0LXRhYmxlJztcbmltcG9ydCB7IHQgfSBmcm9tICdAc3VwZXJzZXQtdWkvY29yZSc7XG5pbXBvcnQgeyBtYXRjaFNvcnRlciwgcmFua2luZ3MgfSBmcm9tICdtYXRjaC1zb3J0ZXInO1xuaW1wb3J0IEdsb2JhbEZpbHRlciwgeyBHbG9iYWxGaWx0ZXJQcm9wcyB9IGZyb20gJy4vY29tcG9uZW50cy9HbG9iYWxGaWx0ZXInO1xuaW1wb3J0IFNlbGVjdFBhZ2VTaXplLCB7IFNlbGVjdFBhZ2VTaXplUHJvcHMsIFNpemVPcHRpb24gfSBmcm9tICcuL2NvbXBvbmVudHMvU2VsZWN0UGFnZVNpemUnO1xuaW1wb3J0IFNpbXBsZVBhZ2luYXRpb24gZnJvbSAnLi9jb21wb25lbnRzL1BhZ2luYXRpb24nO1xuaW1wb3J0IHVzZVN0aWNreSBmcm9tICcuL2hvb2tzL3VzZVN0aWNreSc7XG5pbXBvcnQgeyBQQUdFX1NJWkVfT1BUSU9OUyB9IGZyb20gJy4uL2NvbnN0cyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0YVRhYmxlUHJvcHM8RCBleHRlbmRzIG9iamVjdD4gZXh0ZW5kcyBUYWJsZU9wdGlvbnM8RD4ge1xuICB0YWJsZUNsYXNzTmFtZT86IHN0cmluZztcbiAgdG90YWxzPzogeyB2YWx1ZTogc3RyaW5nOyBjbGFzc05hbWU/OiBzdHJpbmcgfVtdO1xuICB0b3RhbHNIZWFkZXJTcGFuPzogbnVtYmVyO1xuICBzZWFyY2hJbnB1dD86IGJvb2xlYW4gfCBHbG9iYWxGaWx0ZXJQcm9wczxEPlsnc2VhcmNoSW5wdXQnXTtcbiAgc2VsZWN0UGFnZVNpemU/OiBib29sZWFuIHwgU2VsZWN0UGFnZVNpemVQcm9wc1snc2VsZWN0UmVuZGVyZXInXTtcbiAgcGFnZVNpemVPcHRpb25zPzogU2l6ZU9wdGlvbltdOyAvLyBhdmFpbGFibGUgcGFnZSBzaXplIG9wdGlvbnNcbiAgbWF4UGFnZUl0ZW1Db3VudD86IG51bWJlcjtcbiAgaG9va3M/OiBQbHVnaW5Ib29rPEQ+W107IC8vIGFueSBhZGRpdGlvbmFsIGhvb2tzXG4gIHdpZHRoPzogc3RyaW5nIHwgbnVtYmVyO1xuICBoZWlnaHQ/OiBzdHJpbmcgfCBudW1iZXI7XG4gIHNlcnZlclBhZ2luYXRpb24/OiBib29sZWFuO1xuICBvblNlcnZlclBhZ2luYXRpb25DaGFuZ2U6IChwYWdlTnVtYmVyOiBudW1iZXIsIHBhZ2VTaXplOiBudW1iZXIpID0+IHZvaWQ7XG4gIHNlcnZlclBhZ2luYXRpb25EYXRhOiB7IHBhZ2VTaXplPzogbnVtYmVyOyBjdXJyZW50UGFnZT86IG51bWJlciB9O1xuICBwYWdlU2l6ZT86IG51bWJlcjtcbiAgbm9SZXN1bHRzPzogc3RyaW5nIHwgKChmaWx0ZXJTdHJpbmc6IHN0cmluZykgPT4gUmVhY3ROb2RlKTtcbiAgc3RpY2t5PzogYm9vbGVhbjtcbiAgcm93Q291bnQ6IG51bWJlcjtcbiAgd3JhcHBlclJlZj86IE11dGFibGVSZWZPYmplY3Q8SFRNTERpdkVsZW1lbnQ+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlbmRlckhUTUxDZWxsUHJvcHMgZXh0ZW5kcyBIVE1MUHJvcHM8SFRNTFRhYmxlQ2VsbEVsZW1lbnQ+IHtcbiAgY2VsbENvbnRlbnQ6IFJlYWN0Tm9kZTtcbn1cblxuLy8gQmUgc3VyZSB0byBwYXNzIG91ciB1cGRhdGVNeURhdGEgYW5kIHRoZSBza2lwUmVzZXQgb3B0aW9uXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEYXRhVGFibGU8RCBleHRlbmRzIG9iamVjdD4oe1xuICB0YWJsZUNsYXNzTmFtZSxcbiAgY29sdW1ucyxcbiAgZGF0YSxcbiAgdG90YWxzLFxuICB0b3RhbHNIZWFkZXJTcGFuLFxuICBzZXJ2ZXJQYWdpbmF0aW9uRGF0YSxcbiAgd2lkdGg6IGluaXRpYWxXaWR0aCA9ICcxMDAlJyxcbiAgaGVpZ2h0OiBpbml0aWFsSGVpZ2h0ID0gMzAwLFxuICBwYWdlU2l6ZTogaW5pdGlhbFBhZ2VTaXplID0gMCxcbiAgaW5pdGlhbFN0YXRlOiBpbml0aWFsU3RhdGVfID0ge30sXG4gIHBhZ2VTaXplT3B0aW9ucyA9IFBBR0VfU0laRV9PUFRJT05TLFxuICBtYXhQYWdlSXRlbUNvdW50ID0gOSxcbiAgc3RpY2t5OiBkb1N0aWNreSxcbiAgc2VhcmNoSW5wdXQgPSB0cnVlLFxuICBvblNlcnZlclBhZ2luYXRpb25DaGFuZ2UsXG4gIHJvd0NvdW50LFxuICBzZWxlY3RQYWdlU2l6ZSxcbiAgbm9SZXN1bHRzOiBub1Jlc3VsdHNUZXh0ID0gJ05vIGRhdGEgZm91bmQnLFxuICBob29rcyxcbiAgc2VydmVyUGFnaW5hdGlvbixcbiAgd3JhcHBlclJlZjogdXNlcldyYXBwZXJSZWYsXG4gIC4uLm1vcmVVc2VUYWJsZU9wdGlvbnNcbn06IERhdGFUYWJsZVByb3BzPEQ+KTogSlNYLkVsZW1lbnQge1xuICBjb25zdCB0YWJsZUhvb2tzOiBQbHVnaW5Ib29rPEQ+W10gPSBbXG4gICAgdXNlR2xvYmFsRmlsdGVyLFxuICAgIHVzZVNvcnRCeSxcbiAgICB1c2VQYWdpbmF0aW9uLFxuICAgIGRvU3RpY2t5ID8gdXNlU3RpY2t5IDogW10sXG4gICAgaG9va3MgfHwgW10sXG4gIF0uZmxhdCgpO1xuICBjb25zdCByZXN1bHRzU2l6ZSA9IHNlcnZlclBhZ2luYXRpb24gPyByb3dDb3VudCA6IGRhdGEubGVuZ3RoO1xuICBjb25zdCBzb3J0QnlSZWYgPSB1c2VSZWYoW10pOyAvLyBjYWNoZSBpbml0aWFsIGBzb3J0YnlgIHNvIHNvcnRpbmcgZG9lc24ndCB0cmlnZ2VyIHBhZ2UgcmVzZXRcbiAgY29uc3QgcGFnZVNpemVSZWYgPSB1c2VSZWYoW2luaXRpYWxQYWdlU2l6ZSwgcmVzdWx0c1NpemVdKTtcbiAgY29uc3QgaGFzUGFnaW5hdGlvbiA9IGluaXRpYWxQYWdlU2l6ZSA+IDAgJiYgcmVzdWx0c1NpemUgPiAwOyAvLyBwYWdlU2l6ZSA9PSAwIG1lYW5zIG5vIHBhZ2luYXRpb25cbiAgY29uc3QgaGFzR2xvYmFsQ29udHJvbCA9IGhhc1BhZ2luYXRpb24gfHwgISFzZWFyY2hJbnB1dDtcbiAgY29uc3QgaW5pdGlhbFN0YXRlID0ge1xuICAgIC4uLmluaXRpYWxTdGF0ZV8sXG4gICAgLy8gemVybyBsZW5ndGggbWVhbnMgYWxsIHBhZ2VzLCB0aGUgYHVzZVBhZ2luYXRpb25gIHBsdWdpbiBkb2VzIG5vdFxuICAgIC8vIHVuZGVyc3RhbmQgcGFnZVNpemUgPSAwXG4gICAgc29ydEJ5OiBzb3J0QnlSZWYuY3VycmVudCxcbiAgICBwYWdlU2l6ZTogaW5pdGlhbFBhZ2VTaXplID4gMCA/IGluaXRpYWxQYWdlU2l6ZSA6IHJlc3VsdHNTaXplIHx8IDEwLFxuICB9O1xuICBjb25zdCBkZWZhdWx0V3JhcHBlclJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCk7XG4gIGNvbnN0IGdsb2JhbENvbnRyb2xSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpO1xuICBjb25zdCBwYWdpbmF0aW9uUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTtcbiAgY29uc3Qgd3JhcHBlclJlZiA9IHVzZXJXcmFwcGVyUmVmIHx8IGRlZmF1bHRXcmFwcGVyUmVmO1xuICBjb25zdCBwYWdpbmF0aW9uRGF0YSA9IEpTT04uc3RyaW5naWZ5KHNlcnZlclBhZ2luYXRpb25EYXRhKTtcblxuICBjb25zdCBkZWZhdWx0R2V0VGFibGVTaXplID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmICh3cmFwcGVyUmVmLmN1cnJlbnQpIHtcbiAgICAgIC8vIGBpbml0aWFsV2lkdGhgIGFuZCBgaW5pdGlhbEhlaWdodGAgY291bGQgYmUgYWxzbyBwYXJhbWV0ZXJzIGxpa2UgYDEwMCVgXG4gICAgICAvLyBgTnVtYmVyYCByZWF0dXJucyBgTmFOYCBvbiB0aGVtLCB0aGVuIHdlIGZhbGxiYWNrIHRvIGNvbXB1dGVkIHNpemVcbiAgICAgIGNvbnN0IHdpZHRoID0gTnVtYmVyKGluaXRpYWxXaWR0aCkgfHwgd3JhcHBlclJlZi5jdXJyZW50LmNsaWVudFdpZHRoO1xuICAgICAgY29uc3QgaGVpZ2h0ID1cbiAgICAgICAgKE51bWJlcihpbml0aWFsSGVpZ2h0KSB8fCB3cmFwcGVyUmVmLmN1cnJlbnQuY2xpZW50SGVpZ2h0KSAtXG4gICAgICAgIChnbG9iYWxDb250cm9sUmVmLmN1cnJlbnQ/LmNsaWVudEhlaWdodCB8fCAwKSAtXG4gICAgICAgIChwYWdpbmF0aW9uUmVmLmN1cnJlbnQ/LmNsaWVudEhlaWdodCB8fCAwKTtcbiAgICAgIHJldHVybiB7IHdpZHRoLCBoZWlnaHQgfTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtcbiAgICBpbml0aWFsSGVpZ2h0LFxuICAgIGluaXRpYWxXaWR0aCxcbiAgICB3cmFwcGVyUmVmLFxuICAgIGhhc1BhZ2luYXRpb24sXG4gICAgaGFzR2xvYmFsQ29udHJvbCxcbiAgICBwYWdpbmF0aW9uUmVmLFxuICAgIHJlc3VsdHNTaXplLFxuICAgIHBhZ2luYXRpb25EYXRhLFxuICBdKTtcblxuICBjb25zdCBkZWZhdWx0R2xvYmFsRmlsdGVyOiBGaWx0ZXJUeXBlPEQ+ID0gdXNlQ2FsbGJhY2soXG4gICAgKHJvd3M6IFJvdzxEPltdLCBjb2x1bW5JZHM6IElkVHlwZTxEPltdLCBmaWx0ZXJWYWx1ZTogc3RyaW5nKSA9PiB7XG4gICAgICAvLyBhbGxvdyBzZWFyY2hpbmcgYnkgXCJjb2wxX3ZhbHVlIGNvbDJfdmFsdWVcIlxuICAgICAgY29uc3Qgam9pbmVkU3RyaW5nID0gKHJvdzogUm93PEQ+KSA9PiBjb2x1bW5JZHMubWFwKHggPT4gcm93LnZhbHVlc1t4XSkuam9pbignICcpO1xuICAgICAgcmV0dXJuIG1hdGNoU29ydGVyKHJvd3MsIGZpbHRlclZhbHVlLCB7XG4gICAgICAgIGtleXM6IFsuLi5jb2x1bW5JZHMsIGpvaW5lZFN0cmluZ10sXG4gICAgICAgIHRocmVzaG9sZDogcmFua2luZ3MuQUNST05ZTSxcbiAgICAgIH0pIGFzIHR5cGVvZiByb3dzO1xuICAgIH0sXG4gICAgW10sXG4gICk7XG5cbiAgY29uc3Qge1xuICAgIGdldFRhYmxlUHJvcHMsXG4gICAgZ2V0VGFibGVCb2R5UHJvcHMsXG4gICAgcHJlcGFyZVJvdyxcbiAgICBoZWFkZXJHcm91cHMsXG4gICAgcGFnZSxcbiAgICBwYWdlQ291bnQsXG4gICAgZ290b1BhZ2UsXG4gICAgcHJlR2xvYmFsRmlsdGVyZWRSb3dzLFxuICAgIHNldEdsb2JhbEZpbHRlcixcbiAgICBzZXRQYWdlU2l6ZTogc2V0UGFnZVNpemVfLFxuICAgIHdyYXBTdGlja3lUYWJsZSxcbiAgICBzdGF0ZTogeyBwYWdlSW5kZXgsIHBhZ2VTaXplLCBnbG9iYWxGaWx0ZXI6IGZpbHRlclZhbHVlLCBzdGlja3kgPSB7fSB9LFxuICB9ID0gdXNlVGFibGU8RD4oXG4gICAge1xuICAgICAgY29sdW1ucyxcbiAgICAgIGRhdGEsXG4gICAgICBpbml0aWFsU3RhdGUsXG4gICAgICBnZXRUYWJsZVNpemU6IGRlZmF1bHRHZXRUYWJsZVNpemUsXG4gICAgICBnbG9iYWxGaWx0ZXI6IGRlZmF1bHRHbG9iYWxGaWx0ZXIsXG4gICAgICAuLi5tb3JlVXNlVGFibGVPcHRpb25zLFxuICAgIH0sXG4gICAgLi4udGFibGVIb29rcyxcbiAgKTtcbiAgLy8gbWFrZSBzZXRQYWdlU2l6ZSBhY2NlcHQgMFxuICBjb25zdCBzZXRQYWdlU2l6ZSA9IChzaXplOiBudW1iZXIpID0+IHtcbiAgICBpZiAoc2VydmVyUGFnaW5hdGlvbikge1xuICAgICAgb25TZXJ2ZXJQYWdpbmF0aW9uQ2hhbmdlKDAsIHNpemUpO1xuICAgIH1cbiAgICAvLyBrZWVwIHRoZSBvcmlnaW5hbCBzaXplIGlmIGRhdGEgaXMgZW1wdHlcbiAgICBpZiAoc2l6ZSB8fCByZXN1bHRzU2l6ZSAhPT0gMCkge1xuICAgICAgc2V0UGFnZVNpemVfKHNpemUgPT09IDAgPyByZXN1bHRzU2l6ZSA6IHNpemUpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBub1Jlc3VsdHMgPVxuICAgIHR5cGVvZiBub1Jlc3VsdHNUZXh0ID09PSAnZnVuY3Rpb24nID8gbm9SZXN1bHRzVGV4dChmaWx0ZXJWYWx1ZSBhcyBzdHJpbmcpIDogbm9SZXN1bHRzVGV4dDtcblxuICBjb25zdCBnZXROb1Jlc3VsdHMgPSAoKSA9PiA8ZGl2IGNsYXNzTmFtZT1cImR0LW5vLXJlc3VsdHNcIj57bm9SZXN1bHRzfTwvZGl2PjtcblxuICBpZiAoIWNvbHVtbnMgfHwgY29sdW1ucy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gKHdyYXBTdGlja3lUYWJsZSA/IHdyYXBTdGlja3lUYWJsZShnZXROb1Jlc3VsdHMpIDogZ2V0Tm9SZXN1bHRzKCkpIGFzIEpTWC5FbGVtZW50O1xuICB9XG5cbiAgY29uc3QgcmVuZGVyVGFibGUgPSAoKSA9PiAoXG4gICAgPHRhYmxlIHsuLi5nZXRUYWJsZVByb3BzKHsgY2xhc3NOYW1lOiB0YWJsZUNsYXNzTmFtZSB9KX0+XG4gICAgICA8dGhlYWQ+XG4gICAgICAgIHtoZWFkZXJHcm91cHMubWFwKGhlYWRlckdyb3VwID0+IHtcbiAgICAgICAgICBjb25zdCB7IGtleTogaGVhZGVyR3JvdXBLZXksIC4uLmhlYWRlckdyb3VwUHJvcHMgfSA9IGhlYWRlckdyb3VwLmdldEhlYWRlckdyb3VwUHJvcHMoKTtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPHRyIGtleT17aGVhZGVyR3JvdXBLZXkgfHwgaGVhZGVyR3JvdXAuaWR9IHsuLi5oZWFkZXJHcm91cFByb3BzfT5cbiAgICAgICAgICAgICAge2hlYWRlckdyb3VwLmhlYWRlcnMubWFwKGNvbHVtbiA9PlxuICAgICAgICAgICAgICAgIGNvbHVtbi5yZW5kZXIoJ0hlYWRlcicsIHtcbiAgICAgICAgICAgICAgICAgIGtleTogY29sdW1uLmlkLFxuICAgICAgICAgICAgICAgICAgLi4uY29sdW1uLmdldFNvcnRCeVRvZ2dsZVByb3BzKCksXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICl9XG4gICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICk7XG4gICAgICAgIH0pfVxuICAgICAgPC90aGVhZD5cbiAgICAgIDx0Ym9keSB7Li4uZ2V0VGFibGVCb2R5UHJvcHMoKX0+XG4gICAgICAgIHtwYWdlICYmIHBhZ2UubGVuZ3RoID4gMCA/IChcbiAgICAgICAgICBwYWdlLm1hcChyb3cgPT4ge1xuICAgICAgICAgICAgcHJlcGFyZVJvdyhyb3cpO1xuICAgICAgICAgICAgY29uc3QgeyBrZXk6IHJvd0tleSwgLi4ucm93UHJvcHMgfSA9IHJvdy5nZXRSb3dQcm9wcygpO1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgPHRyIGtleT17cm93S2V5IHx8IHJvdy5pZH0gey4uLnJvd1Byb3BzfT5cbiAgICAgICAgICAgICAgICB7cm93LmNlbGxzLm1hcChjZWxsID0+IGNlbGwucmVuZGVyKCdDZWxsJywgeyBrZXk6IGNlbGwuY29sdW1uLmlkIH0pKX1cbiAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSlcbiAgICAgICAgKSA6IChcbiAgICAgICAgICA8dHI+XG4gICAgICAgICAgICA8dGQgY2xhc3NOYW1lPVwiZHQtbm8tcmVzdWx0c1wiIGNvbFNwYW49e2NvbHVtbnMubGVuZ3RofT5cbiAgICAgICAgICAgICAge25vUmVzdWx0c31cbiAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgPC90cj5cbiAgICAgICAgKX1cbiAgICAgIDwvdGJvZHk+XG4gICAgICB7dG90YWxzICYmIChcbiAgICAgICAgPHRmb290PlxuICAgICAgICAgIDx0ciBrZXk9XCJ0b3RhbHNcIiBjbGFzc05hbWU9XCJkdC10b3RhbHNcIj5cbiAgICAgICAgICAgIDx0ZCBjb2xTcGFuPXt0b3RhbHNIZWFkZXJTcGFufT57dCgnVG90YWxzJyl9PC90ZD5cbiAgICAgICAgICAgIHt0b3RhbHMubWFwKGl0ZW0gPT4gKFxuICAgICAgICAgICAgICA8dGQgY2xhc3NOYW1lPXtpdGVtLmNsYXNzTmFtZX0+e2l0ZW0udmFsdWV9PC90ZD5cbiAgICAgICAgICAgICkpfVxuICAgICAgICAgIDwvdHI+XG4gICAgICAgIDwvdGZvb3Q+XG4gICAgICApfVxuICAgIDwvdGFibGU+XG4gICk7XG5cbiAgLy8gZm9yY2UgdXBkYXRlIHRoZSBwYWdlU2l6ZSB3aGVuIGl0J3MgYmVlbiB1cGRhdGUgZnJvbSB0aGUgaW5pdGlhbCBzdGF0ZVxuICBpZiAoXG4gICAgcGFnZVNpemVSZWYuY3VycmVudFswXSAhPT0gaW5pdGlhbFBhZ2VTaXplIHx8XG4gICAgLy8gd2hlbiBpbml0aWFsUGFnZVNpemUgc3RheXMgYXMgemVybywgYnV0IHRvdGFsIG51bWJlciBvZiByZWNvcmRzIGNoYW5nZWQsXG4gICAgLy8gd2UnZCBhbHNvIG5lZWQgdG8gdXBkYXRlIHBhZ2Ugc2l6ZVxuICAgIChpbml0aWFsUGFnZVNpemUgPT09IDAgJiYgcGFnZVNpemVSZWYuY3VycmVudFsxXSAhPT0gcmVzdWx0c1NpemUpXG4gICkge1xuICAgIHBhZ2VTaXplUmVmLmN1cnJlbnQgPSBbaW5pdGlhbFBhZ2VTaXplLCByZXN1bHRzU2l6ZV07XG4gICAgc2V0UGFnZVNpemUoaW5pdGlhbFBhZ2VTaXplKTtcbiAgfVxuXG4gIGNvbnN0IHBhZ2luYXRpb25TdHlsZTogQ1NTUHJvcGVydGllcyA9IHN0aWNreS5oZWlnaHQgPyB7fSA6IHsgdmlzaWJpbGl0eTogJ2hpZGRlbicgfTtcblxuICBsZXQgcmVzdWx0UGFnZUNvdW50ID0gcGFnZUNvdW50O1xuICBsZXQgcmVzdWx0Q3VycmVudFBhZ2VTaXplID0gcGFnZVNpemU7XG4gIGxldCByZXN1bHRDdXJyZW50UGFnZSA9IHBhZ2VJbmRleDtcbiAgbGV0IHJlc3VsdE9uUGFnZUNoYW5nZTogKHBhZ2U6IG51bWJlcikgPT4gdm9pZCA9IGdvdG9QYWdlO1xuICBpZiAoc2VydmVyUGFnaW5hdGlvbikge1xuICAgIGNvbnN0IHNlcnZlclBhZ2VTaXplID0gc2VydmVyUGFnaW5hdGlvbkRhdGEucGFnZVNpemUgPz8gaW5pdGlhbFBhZ2VTaXplO1xuICAgIHJlc3VsdFBhZ2VDb3VudCA9IE1hdGguY2VpbChyb3dDb3VudCAvIHNlcnZlclBhZ2VTaXplKTtcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShyZXN1bHRQYWdlQ291bnQpKSB7XG4gICAgICByZXN1bHRQYWdlQ291bnQgPSAwO1xuICAgIH1cbiAgICByZXN1bHRDdXJyZW50UGFnZVNpemUgPSBzZXJ2ZXJQYWdlU2l6ZTtcbiAgICBjb25zdCBmb3VuZFBhZ2VTaXplSW5kZXggPSBwYWdlU2l6ZU9wdGlvbnMuZmluZEluZGV4KFxuICAgICAgKFtvcHRpb25dKSA9PiBvcHRpb24gPj0gcmVzdWx0Q3VycmVudFBhZ2VTaXplLFxuICAgICk7XG4gICAgaWYgKGZvdW5kUGFnZVNpemVJbmRleCA9PT0gLTEpIHtcbiAgICAgIHJlc3VsdEN1cnJlbnRQYWdlU2l6ZSA9IDA7XG4gICAgfVxuICAgIHJlc3VsdEN1cnJlbnRQYWdlID0gc2VydmVyUGFnaW5hdGlvbkRhdGEuY3VycmVudFBhZ2UgPz8gMDtcbiAgICByZXN1bHRPblBhZ2VDaGFuZ2UgPSAocGFnZU51bWJlcjogbnVtYmVyKSA9PlxuICAgICAgb25TZXJ2ZXJQYWdpbmF0aW9uQ2hhbmdlKHBhZ2VOdW1iZXIsIHNlcnZlclBhZ2VTaXplKTtcbiAgfVxuICByZXR1cm4gKFxuICAgIDxkaXYgcmVmPXt3cmFwcGVyUmVmfSBzdHlsZT17eyB3aWR0aDogaW5pdGlhbFdpZHRoLCBoZWlnaHQ6IGluaXRpYWxIZWlnaHQgfX0+XG4gICAgICB7aGFzR2xvYmFsQ29udHJvbCA/IChcbiAgICAgICAgPGRpdiByZWY9e2dsb2JhbENvbnRyb2xSZWZ9IGNsYXNzTmFtZT1cImZvcm0taW5saW5lIGR0LWNvbnRyb2xzXCI+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyb3dcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29sLXNtLTZcIj5cbiAgICAgICAgICAgICAge2hhc1BhZ2luYXRpb24gPyAoXG4gICAgICAgICAgICAgICAgPFNlbGVjdFBhZ2VTaXplXG4gICAgICAgICAgICAgICAgICB0b3RhbD17cmVzdWx0c1NpemV9XG4gICAgICAgICAgICAgICAgICBjdXJyZW50PXtyZXN1bHRDdXJyZW50UGFnZVNpemV9XG4gICAgICAgICAgICAgICAgICBvcHRpb25zPXtwYWdlU2l6ZU9wdGlvbnN9XG4gICAgICAgICAgICAgICAgICBzZWxlY3RSZW5kZXJlcj17dHlwZW9mIHNlbGVjdFBhZ2VTaXplID09PSAnYm9vbGVhbicgPyB1bmRlZmluZWQgOiBzZWxlY3RQYWdlU2l6ZX1cbiAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtzZXRQYWdlU2l6ZX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICApIDogbnVsbH1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAge3NlYXJjaElucHV0ID8gKFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbC1zbS02XCI+XG4gICAgICAgICAgICAgICAgPEdsb2JhbEZpbHRlcjxEPlxuICAgICAgICAgICAgICAgICAgc2VhcmNoSW5wdXQ9e3R5cGVvZiBzZWFyY2hJbnB1dCA9PT0gJ2Jvb2xlYW4nID8gdW5kZWZpbmVkIDogc2VhcmNoSW5wdXR9XG4gICAgICAgICAgICAgICAgICBwcmVHbG9iYWxGaWx0ZXJlZFJvd3M9e3ByZUdsb2JhbEZpbHRlcmVkUm93c31cbiAgICAgICAgICAgICAgICAgIHNldEdsb2JhbEZpbHRlcj17c2V0R2xvYmFsRmlsdGVyfVxuICAgICAgICAgICAgICAgICAgZmlsdGVyVmFsdWU9e2ZpbHRlclZhbHVlfVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKSA6IG51bGx9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgKSA6IG51bGx9XG4gICAgICB7d3JhcFN0aWNreVRhYmxlID8gd3JhcFN0aWNreVRhYmxlKHJlbmRlclRhYmxlKSA6IHJlbmRlclRhYmxlKCl9XG4gICAgICB7aGFzUGFnaW5hdGlvbiAmJiByZXN1bHRQYWdlQ291bnQgPiAxID8gKFxuICAgICAgICA8U2ltcGxlUGFnaW5hdGlvblxuICAgICAgICAgIHJlZj17cGFnaW5hdGlvblJlZn1cbiAgICAgICAgICBzdHlsZT17cGFnaW5hdGlvblN0eWxlfVxuICAgICAgICAgIG1heFBhZ2VJdGVtQ291bnQ9e21heFBhZ2VJdGVtQ291bnR9XG4gICAgICAgICAgcGFnZUNvdW50PXtyZXN1bHRQYWdlQ291bnR9XG4gICAgICAgICAgY3VycmVudFBhZ2U9e3Jlc3VsdEN1cnJlbnRQYWdlfVxuICAgICAgICAgIG9uUGFnZUNoYW5nZT17cmVzdWx0T25QYWdlQ2hhbmdlfVxuICAgICAgICAvPlxuICAgICAgKSA6IG51bGx9XG4gICAgPC9kaXY+XG4gICk7XG59XG4iLCJpbXBvcnQgeyBzdHlsZWQgfSBmcm9tICdAc3VwZXJzZXQtdWkvY29yZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHN0eWxlZC5kaXZgXG4gIHRhYmxlIHtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBtaW4td2lkdGg6IGF1dG87XG4gICAgbWF4LXdpZHRoOiBub25lO1xuICAgIG1hcmdpbjogMDtcbiAgfVxuXG4gIHRoLFxuICB0ZCB7XG4gICAgbWluLXdpZHRoOiA0LjNlbTtcbiAgfVxuXG4gIHRoZWFkID4gdHIgPiB0aCB7XG4gICAgcGFkZGluZy1yaWdodDogMS40ZW07XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIGJhY2tncm91bmQ6ICNmZmY7XG4gIH1cbiAgdGggc3ZnIHtcbiAgICBjb2xvcjogI2NjYztcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgYm90dG9tOiAwLjZlbTtcbiAgICByaWdodDogMC4yZW07XG4gIH1cbiAgdGguaXMtc29ydGVkIHN2ZyB7XG4gICAgY29sb3I6ICNhOGE4YTg7XG4gIH1cbiAgLnRhYmxlID4gdGJvZHkgPiB0cjpmaXJzdC1vZi10eXBlID4gdGQsXG4gIC50YWJsZSA+IHRib2R5ID4gdHI6Zmlyc3Qtb2YtdHlwZSA+IHRoIHtcbiAgICBib3JkZXItdG9wOiAwO1xuICB9XG5cbiAgLmR0LWNvbnRyb2xzIHtcbiAgICBwYWRkaW5nLWJvdHRvbTogMC42NWVtO1xuICB9XG4gIC5kdC1tZXRyaWMge1xuICAgIHRleHQtYWxpZ246IHJpZ2h0O1xuICB9XG4gIC5kdC10b3RhbHMge1xuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICB9XG4gIC5kdC1pcy1udWxsIHtcbiAgICBjb2xvcjogJHsoeyB0aGVtZTogeyBjb2xvcnMgfSB9KSA9PiBjb2xvcnMuZ3JheXNjYWxlLmxpZ2h0MX07XG4gIH1cbiAgdGQuZHQtaXMtZmlsdGVyIHtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gIH1cbiAgdGQuZHQtaXMtZmlsdGVyOmhvdmVyIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkeyh7IHRoZW1lOiB7IGNvbG9ycyB9IH0pID0+IGNvbG9ycy5zZWNvbmRhcnkubGlnaHQ0fTtcbiAgfVxuICB0ZC5kdC1pcy1hY3RpdmUtZmlsdGVyLFxuICB0ZC5kdC1pcy1hY3RpdmUtZmlsdGVyOmhvdmVyIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkeyh7IHRoZW1lOiB7IGNvbG9ycyB9IH0pID0+IGNvbG9ycy5zZWNvbmRhcnkubGlnaHQzfTtcbiAgfVxuXG4gIC5kdC1nbG9iYWwtZmlsdGVyIHtcbiAgICBmbG9hdDogcmlnaHQ7XG4gIH1cblxuICAuZHQtcGFnaW5hdGlvbiB7XG4gICAgdGV4dC1hbGlnbjogcmlnaHQ7XG4gICAgLyogdXNlIHBhZGRpbmcgaW5zdGVhZCBvZiBtYXJnaW4gc28gY2xpZW50SGVpZ2h0IGNhbiBjYXB0dXJlIGl0ICovXG4gICAgcGFkZGluZy10b3A6IDAuNWVtO1xuICB9XG4gIC5kdC1wYWdpbmF0aW9uIC5wYWdpbmF0aW9uIHtcbiAgICBtYXJnaW46IDA7XG4gIH1cblxuICAucGFnaW5hdGlvbiA+IGxpID4gc3Bhbi5kdC1wYWdpbmF0aW9uLWVsbGlwc2lzOmZvY3VzLFxuICAucGFnaW5hdGlvbiA+IGxpID4gc3Bhbi5kdC1wYWdpbmF0aW9uLWVsbGlwc2lzOmhvdmVyIHtcbiAgICBiYWNrZ3JvdW5kOiAjZmZmO1xuICB9XG5cbiAgLmR0LW5vLXJlc3VsdHMge1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICBwYWRkaW5nOiAxZW0gMC42ZW07XG4gIH1cbmA7XG4iLCIvKipcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBGaWx0ZXJYU1MsIGdldERlZmF1bHRXaGl0ZUxpc3QgfSBmcm9tICd4c3MnO1xuaW1wb3J0IHsgRGF0YVJlY29yZFZhbHVlLCBHZW5lcmljRGF0YVR5cGUsIGdldE51bWJlckZvcm1hdHRlciB9IGZyb20gJ0BzdXBlcnNldC11aS9jb3JlJztcbmltcG9ydCB7IERhdGFDb2x1bW5NZXRhIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5jb25zdCB4c3MgPSBuZXcgRmlsdGVyWFNTKHtcbiAgd2hpdGVMaXN0OiB7XG4gICAgLi4uZ2V0RGVmYXVsdFdoaXRlTGlzdCgpLFxuICAgIHNwYW46IFsnc3R5bGUnLCAnY2xhc3MnLCAndGl0bGUnXSxcbiAgICBkaXY6IFsnc3R5bGUnLCAnY2xhc3MnXSxcbiAgICBhOiBbJ3N0eWxlJywgJ2NsYXNzJywgJ2hyZWYnLCAndGl0bGUnLCAndGFyZ2V0J10sXG4gICAgaW1nOiBbJ3N0eWxlJywgJ2NsYXNzJywgJ3NyYycsICdhbHQnLCAndGl0bGUnLCAnd2lkdGgnLCAnaGVpZ2h0J10sXG4gICAgdmlkZW86IFsnYXV0b3BsYXknLCAnY29udHJvbHMnLCAnbG9vcCcsICdwcmVsb2FkJywgJ3NyYycsICdoZWlnaHQnLCAnd2lkdGgnLCAnbXV0ZWQnXSxcbiAgfSxcbiAgc3RyaXBJZ25vcmVUYWc6IHRydWUsXG4gIGNzczogZmFsc2UsXG59KTtcblxuZnVuY3Rpb24gaXNQcm9iYWJseUhUTUwodGV4dDogc3RyaW5nKSB7XG4gIHJldHVybiAvPFtePl0rPi8udGVzdCh0ZXh0KTtcbn1cblxuLyoqXG4gKiBGb3JtYXQgdGV4dCBmb3IgY2VsbCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZm9ybWF0VmFsdWUoXG4gIGZvcm1hdHRlcjogRGF0YUNvbHVtbk1ldGFbJ2Zvcm1hdHRlciddLFxuICB2YWx1ZTogRGF0YVJlY29yZFZhbHVlLFxuKTogW2Jvb2xlYW4sIHN0cmluZ10ge1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBbZmFsc2UsICdOL0EnXTtcbiAgfVxuICBpZiAoZm9ybWF0dGVyKSB7XG4gICAgLy8gaW4gY2FzZSBwZXJjZW50IG1ldHJpYyBjYW4gc3BlY2lmeSBwZXJjZW50IGZvcm1hdCBpbiB0aGUgZnV0dXJlXG4gICAgcmV0dXJuIFtmYWxzZSwgZm9ybWF0dGVyKHZhbHVlIGFzIG51bWJlcildO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGlzUHJvYmFibHlIVE1MKHZhbHVlKSA/IFt0cnVlLCB4c3MucHJvY2Vzcyh2YWx1ZSldIDogW2ZhbHNlLCB2YWx1ZV07XG4gIH1cbiAgcmV0dXJuIFtmYWxzZSwgdmFsdWUudG9TdHJpbmcoKV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRDb2x1bW5WYWx1ZShjb2x1bW46IERhdGFDb2x1bW5NZXRhLCB2YWx1ZTogRGF0YVJlY29yZFZhbHVlKSB7XG4gIGNvbnN0IHsgZGF0YVR5cGUsIGZvcm1hdHRlciwgY29uZmlnID0ge30gfSA9IGNvbHVtbjtcbiAgY29uc3QgaXNOdW1iZXIgPSBkYXRhVHlwZSA9PT0gR2VuZXJpY0RhdGFUeXBlLk5VTUVSSUM7XG4gIGNvbnN0IHNtYWxsTnVtYmVyRm9ybWF0dGVyID1cbiAgICBjb25maWcuZDNTbWFsbE51bWJlckZvcm1hdCA9PT0gdW5kZWZpbmVkXG4gICAgICA/IGZvcm1hdHRlclxuICAgICAgOiBnZXROdW1iZXJGb3JtYXR0ZXIoY29uZmlnLmQzU21hbGxOdW1iZXJGb3JtYXQpO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoXG4gICAgaXNOdW1iZXIgJiYgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBNYXRoLmFicyh2YWx1ZSkgPCAxID8gc21hbGxOdW1iZXJGb3JtYXR0ZXIgOiBmb3JtYXR0ZXIsXG4gICAgdmFsdWUsXG4gICk7XG59XG4iLCIvKipcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgUmVhY3QsIHsgQ1NTUHJvcGVydGllcywgdXNlQ2FsbGJhY2ssIHVzZU1lbW8sIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQ29sdW1uSW5zdGFuY2UsIENvbHVtbldpdGhMb29zZUFjY2Vzc29yLCBEZWZhdWx0U29ydFR5cGVzIH0gZnJvbSAncmVhY3QtdGFibGUnO1xuaW1wb3J0IHsgZXh0ZW50IGFzIGQzRXh0ZW50LCBtYXggYXMgZDNNYXggfSBmcm9tICdkMy1hcnJheSc7XG5pbXBvcnQgeyBGYVNvcnQsIEZhU29ydERvd24gYXMgRmFTb3J0RGVzYywgRmFTb3J0VXAgYXMgRmFTb3J0QXNjIH0gZnJvbSAncmVhY3QtaWNvbnMvZmEnO1xuaW1wb3J0IHsgRGF0YVJlY29yZCwgRGF0YVJlY29yZFZhbHVlLCBHZW5lcmljRGF0YVR5cGUsIHQsIHRuIH0gZnJvbSAnQHN1cGVyc2V0LXVpL2NvcmUnO1xuXG5pbXBvcnQgeyBEYXRhQ29sdW1uTWV0YSwgVGFibGVDaGFydFRyYW5zZm9ybWVkUHJvcHMgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCBEYXRhVGFibGUsIHtcbiAgRGF0YVRhYmxlUHJvcHMsXG4gIFNlYXJjaElucHV0UHJvcHMsXG4gIFNlbGVjdFBhZ2VTaXplUmVuZGVyZXJQcm9wcyxcbiAgU2l6ZU9wdGlvbixcbn0gZnJvbSAnLi9EYXRhVGFibGUnO1xuXG5pbXBvcnQgU3R5bGVzIGZyb20gJy4vU3R5bGVzJztcbmltcG9ydCB7IGZvcm1hdENvbHVtblZhbHVlIH0gZnJvbSAnLi91dGlscy9mb3JtYXRWYWx1ZSc7XG5pbXBvcnQgeyBQQUdFX1NJWkVfT1BUSU9OUyB9IGZyb20gJy4vY29uc3RzJztcbmltcG9ydCB7IHVwZGF0ZUV4dGVybmFsRm9ybURhdGEgfSBmcm9tICcuL0RhdGFUYWJsZS91dGlscy9leHRlcm5hbEFQSXMnO1xuXG50eXBlIFZhbHVlUmFuZ2UgPSBbbnVtYmVyLCBudW1iZXJdO1xuXG4vKipcbiAqIFJldHVybiBzb3J0VHlwZSBiYXNlZCBvbiBkYXRhIHR5cGVcbiAqL1xuZnVuY3Rpb24gZ2V0U29ydFR5cGVCeURhdGFUeXBlKGRhdGFUeXBlOiBHZW5lcmljRGF0YVR5cGUpOiBEZWZhdWx0U29ydFR5cGVzIHtcbiAgaWYgKGRhdGFUeXBlID09PSBHZW5lcmljRGF0YVR5cGUuVEVNUE9SQUwpIHtcbiAgICByZXR1cm4gJ2RhdGV0aW1lJztcbiAgfVxuICBpZiAoZGF0YVR5cGUgPT09IEdlbmVyaWNEYXRhVHlwZS5TVFJJTkcpIHtcbiAgICByZXR1cm4gJ2FscGhhbnVtZXJpYyc7XG4gIH1cbiAgcmV0dXJuICdiYXNpYyc7XG59XG5cbi8qKlxuICogQ2VsbCBiYWNrZ3JvdW5kIHRvIHJlbmRlciBjb2x1bW5zIGFzIGhvcml6b250YWwgYmFyIGNoYXJ0XG4gKi9cbmZ1bmN0aW9uIGNlbGxCYXIoe1xuICB2YWx1ZSxcbiAgdmFsdWVSYW5nZSxcbiAgY29sb3JQb3NpdGl2ZU5lZ2F0aXZlID0gZmFsc2UsXG4gIGFsaWduUG9zaXRpdmVOZWdhdGl2ZSxcbn06IHtcbiAgdmFsdWU6IG51bWJlcjtcbiAgdmFsdWVSYW5nZTogVmFsdWVSYW5nZTtcbiAgY29sb3JQb3NpdGl2ZU5lZ2F0aXZlOiBib29sZWFuO1xuICBhbGlnblBvc2l0aXZlTmVnYXRpdmU6IGJvb2xlYW47XG59KSB7XG4gIGNvbnN0IFttaW5WYWx1ZSwgbWF4VmFsdWVdID0gdmFsdWVSYW5nZTtcbiAgY29uc3QgciA9IGNvbG9yUG9zaXRpdmVOZWdhdGl2ZSAmJiB2YWx1ZSA8IDAgPyAxNTAgOiAwO1xuICBpZiAoYWxpZ25Qb3NpdGl2ZU5lZ2F0aXZlKSB7XG4gICAgY29uc3QgcGVyYyA9IE1hdGguYWJzKE1hdGgucm91bmQoKHZhbHVlIC8gbWF4VmFsdWUpICogMTAwKSk7XG4gICAgLy8gVGhlIDAuMDEgdG8gMC4wMDEgaXMgYSB3b3JrYXJvdW5kIGZvciB3aGF0IGFwcGVhcnMgdG8gYmUgYVxuICAgIC8vIENTUyByZW5kZXJpbmcgYnVnIG9uIGZsYXQsIHRyYW5zcGFyZW50IGNvbG9yc1xuICAgIHJldHVybiAoXG4gICAgICBgbGluZWFyLWdyYWRpZW50KHRvIHJpZ2h0LCByZ2JhKCR7cn0sMCwwLDAuMiksIHJnYmEoJHtyfSwwLDAsMC4yKSAke3BlcmN9JSwgYCArXG4gICAgICBgcmdiYSgwLDAsMCwwLjAxKSAke3BlcmN9JSwgcmdiYSgwLDAsMCwwLjAwMSkgMTAwJSlgXG4gICAgKTtcbiAgfVxuICBjb25zdCBwb3NFeHRlbnQgPSBNYXRoLmFicyhNYXRoLm1heChtYXhWYWx1ZSwgMCkpO1xuICBjb25zdCBuZWdFeHRlbnQgPSBNYXRoLmFicyhNYXRoLm1pbihtaW5WYWx1ZSwgMCkpO1xuICBjb25zdCB0b3QgPSBwb3NFeHRlbnQgKyBuZWdFeHRlbnQ7XG4gIGNvbnN0IHBlcmMxID0gTWF0aC5yb3VuZCgoTWF0aC5taW4obmVnRXh0ZW50ICsgdmFsdWUsIG5lZ0V4dGVudCkgLyB0b3QpICogMTAwKTtcbiAgY29uc3QgcGVyYzIgPSBNYXRoLnJvdW5kKChNYXRoLmFicyh2YWx1ZSkgLyB0b3QpICogMTAwKTtcbiAgLy8gVGhlIDAuMDEgdG8gMC4wMDEgaXMgYSB3b3JrYXJvdW5kIGZvciB3aGF0IGFwcGVhcnMgdG8gYmUgYVxuICAvLyBDU1MgcmVuZGVyaW5nIGJ1ZyBvbiBmbGF0LCB0cmFuc3BhcmVudCBjb2xvcnNcbiAgcmV0dXJuIChcbiAgICBgbGluZWFyLWdyYWRpZW50KHRvIHJpZ2h0LCByZ2JhKDAsMCwwLDAuMDEpLCByZ2JhKDAsMCwwLDAuMDAxKSAke3BlcmMxfSUsIGAgK1xuICAgIGByZ2JhKCR7cn0sMCwwLDAuMikgJHtwZXJjMX0lLCByZ2JhKCR7cn0sMCwwLDAuMikgJHtwZXJjMSArIHBlcmMyfSUsIGAgK1xuICAgIGByZ2JhKDAsMCwwLDAuMDEpICR7cGVyYzEgKyBwZXJjMn0lLCByZ2JhKDAsMCwwLDAuMDAxKSAxMDAlKWBcbiAgKTtcbn1cblxuZnVuY3Rpb24gU29ydEljb248RCBleHRlbmRzIG9iamVjdD4oeyBjb2x1bW4gfTogeyBjb2x1bW46IENvbHVtbkluc3RhbmNlPEQ+IH0pIHtcbiAgY29uc3QgeyBpc1NvcnRlZCwgaXNTb3J0ZWREZXNjIH0gPSBjb2x1bW47XG4gIGxldCBzb3J0SWNvbiA9IDxGYVNvcnQgLz47XG4gIGlmIChpc1NvcnRlZCkge1xuICAgIHNvcnRJY29uID0gaXNTb3J0ZWREZXNjID8gPEZhU29ydERlc2MgLz4gOiA8RmFTb3J0QXNjIC8+O1xuICB9XG4gIHJldHVybiBzb3J0SWNvbjtcbn1cblxuZnVuY3Rpb24gU2VhcmNoSW5wdXQoeyBjb3VudCwgdmFsdWUsIG9uQ2hhbmdlIH06IFNlYXJjaElucHV0UHJvcHMpIHtcbiAgcmV0dXJuIChcbiAgICA8c3BhbiBjbGFzc05hbWU9XCJkdC1nbG9iYWwtZmlsdGVyXCI+XG4gICAgICB7dCgnU2VhcmNoJyl9eycgJ31cbiAgICAgIDxpbnB1dFxuICAgICAgICBjbGFzc05hbWU9XCJmb3JtLWNvbnRyb2wgaW5wdXQtc21cIlxuICAgICAgICBwbGFjZWhvbGRlcj17dG4oJ3NlYXJjaC5udW1fcmVjb3JkcycsIGNvdW50KX1cbiAgICAgICAgdmFsdWU9e3ZhbHVlfVxuICAgICAgICBvbkNoYW5nZT17b25DaGFuZ2V9XG4gICAgICAvPlxuICAgIDwvc3Bhbj5cbiAgKTtcbn1cblxuZnVuY3Rpb24gU2VsZWN0UGFnZVNpemUoeyBvcHRpb25zLCBjdXJyZW50LCBvbkNoYW5nZSB9OiBTZWxlY3RQYWdlU2l6ZVJlbmRlcmVyUHJvcHMpIHtcbiAgcmV0dXJuIChcbiAgICA8c3BhbiBjbGFzc05hbWU9XCJkdC1zZWxlY3QtcGFnZS1zaXplIGZvcm0taW5saW5lXCI+XG4gICAgICB7dCgncGFnZV9zaXplLnNob3cnKX17JyAnfVxuICAgICAgPHNlbGVjdFxuICAgICAgICBjbGFzc05hbWU9XCJmb3JtLWNvbnRyb2wgaW5wdXQtc21cIlxuICAgICAgICB2YWx1ZT17Y3VycmVudH1cbiAgICAgICAgb25CbHVyPXsoKSA9PiB7fX1cbiAgICAgICAgb25DaGFuZ2U9e2UgPT4ge1xuICAgICAgICAgIG9uQ2hhbmdlKE51bWJlcigoZS50YXJnZXQgYXMgSFRNTFNlbGVjdEVsZW1lbnQpLnZhbHVlKSk7XG4gICAgICAgIH19XG4gICAgICA+XG4gICAgICAgIHtvcHRpb25zLm1hcChvcHRpb24gPT4ge1xuICAgICAgICAgIGNvbnN0IFtzaXplLCB0ZXh0XSA9IEFycmF5LmlzQXJyYXkob3B0aW9uKSA/IG9wdGlvbiA6IFtvcHRpb24sIG9wdGlvbl07XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxvcHRpb24ga2V5PXtzaXplfSB2YWx1ZT17c2l6ZX0+XG4gICAgICAgICAgICAgIHt0ZXh0fVxuICAgICAgICAgICAgPC9vcHRpb24+XG4gICAgICAgICAgKTtcbiAgICAgICAgfSl9XG4gICAgICA8L3NlbGVjdD57JyAnfVxuICAgICAge3QoJ3BhZ2Vfc2l6ZS5lbnRyaWVzJyl9XG4gICAgPC9zcGFuPlxuICApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBUYWJsZUNoYXJ0PEQgZXh0ZW5kcyBEYXRhUmVjb3JkID0gRGF0YVJlY29yZD4oXG4gIHByb3BzOiBUYWJsZUNoYXJ0VHJhbnNmb3JtZWRQcm9wczxEPiAmIHtcbiAgICBzdGlja3k/OiBEYXRhVGFibGVQcm9wczxEPlsnc3RpY2t5J107XG4gIH0sXG4pIHtcbiAgY29uc3Qge1xuICAgIGhlaWdodCxcbiAgICB3aWR0aCxcbiAgICBkYXRhLFxuICAgIHRvdGFscyxcbiAgICBpc1Jhd1JlY29yZHMsXG4gICAgcm93Q291bnQgPSAwLFxuICAgIGNvbHVtbnM6IGNvbHVtbnNNZXRhLFxuICAgIGFsaWduUG9zaXRpdmVOZWdhdGl2ZTogZGVmYXVsdEFsaWduUE4gPSBmYWxzZSxcbiAgICBjb2xvclBvc2l0aXZlTmVnYXRpdmU6IGRlZmF1bHRDb2xvclBOID0gZmFsc2UsXG4gICAgaW5jbHVkZVNlYXJjaCA9IGZhbHNlLFxuICAgIHBhZ2VTaXplID0gMCxcbiAgICBzZXJ2ZXJQYWdpbmF0aW9uID0gZmFsc2UsXG4gICAgc2VydmVyUGFnaW5hdGlvbkRhdGEsXG4gICAgc2V0RGF0YU1hc2ssXG4gICAgc2hvd0NlbGxCYXJzID0gdHJ1ZSxcbiAgICBlbWl0RmlsdGVyID0gZmFsc2UsXG4gICAgc29ydERlc2MgPSBmYWxzZSxcbiAgICBmaWx0ZXJzOiBpbml0aWFsRmlsdGVycyA9IHt9LFxuICAgIHN0aWNreSA9IHRydWUsIC8vIHdoZXRoZXIgdG8gdXNlIHN0aWNreSBoZWFkZXJcbiAgfSA9IHByb3BzO1xuXG4gIGNvbnN0IFtmaWx0ZXJzLCBzZXRGaWx0ZXJzXSA9IHVzZVN0YXRlKGluaXRpYWxGaWx0ZXJzKTtcblxuICBjb25zdCBoYW5kbGVDaGFuZ2UgPSB1c2VDYWxsYmFjayhcbiAgICAoZmlsdGVyczogeyBbeDogc3RyaW5nXTogRGF0YVJlY29yZFZhbHVlW10gfSkgPT4ge1xuICAgICAgaWYgKCFlbWl0RmlsdGVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZ3JvdXBCeSA9IE9iamVjdC5rZXlzKGZpbHRlcnMpO1xuICAgICAgY29uc3QgZ3JvdXBCeVZhbHVlcyA9IE9iamVjdC52YWx1ZXMoZmlsdGVycyk7XG4gICAgICBzZXREYXRhTWFzayh7XG4gICAgICAgIGV4dHJhRm9ybURhdGE6IHtcbiAgICAgICAgICBmaWx0ZXJzOlxuICAgICAgICAgICAgZ3JvdXBCeS5sZW5ndGggPT09IDBcbiAgICAgICAgICAgICAgPyBbXVxuICAgICAgICAgICAgICA6IGdyb3VwQnkubWFwKGNvbCA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBmaWx0ZXJzPy5bY29sXTtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgY29sLFxuICAgICAgICAgICAgICAgICAgICAgIG9wOiAnSVMgTlVMTCcsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjb2wsXG4gICAgICAgICAgICAgICAgICAgIG9wOiAnSU4nLFxuICAgICAgICAgICAgICAgICAgICB2YWw6IHZhbCBhcyAoc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbilbXSxcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgIH0sXG4gICAgICAgIGZpbHRlclN0YXRlOiB7XG4gICAgICAgICAgdmFsdWU6IGdyb3VwQnlWYWx1ZXMubGVuZ3RoID8gZ3JvdXBCeVZhbHVlcyA6IG51bGwsXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9LFxuICAgIFtlbWl0RmlsdGVyLCBzZXREYXRhTWFza10sXG4gICk7XG5cbiAgLy8gb25seSB0YWtlIHJlbGV2YW50IHBhZ2Ugc2l6ZSBvcHRpb25zXG4gIGNvbnN0IHBhZ2VTaXplT3B0aW9ucyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IGdldFNlcnZlclBhZ2luYXRpb24gPSAobjogbnVtYmVyKSA9PiBuIDw9IHJvd0NvdW50O1xuICAgIHJldHVybiBQQUdFX1NJWkVfT1BUSU9OUy5maWx0ZXIoKFtuXSkgPT5cbiAgICAgIHNlcnZlclBhZ2luYXRpb24gPyBnZXRTZXJ2ZXJQYWdpbmF0aW9uKG4pIDogbiA8PSAyICogZGF0YS5sZW5ndGgsXG4gICAgKSBhcyBTaXplT3B0aW9uW107XG4gIH0sIFtkYXRhLmxlbmd0aCwgcm93Q291bnQsIHNlcnZlclBhZ2luYXRpb25dKTtcblxuICBjb25zdCBnZXRWYWx1ZVJhbmdlID0gdXNlQ2FsbGJhY2soXG4gICAgZnVuY3Rpb24gZ2V0VmFsdWVSYW5nZShrZXk6IHN0cmluZywgYWxpZ25Qb3NpdGl2ZU5lZ2F0aXZlOiBib29sZWFuKSB7XG4gICAgICBpZiAodHlwZW9mIGRhdGE/LlswXT8uW2tleV0gPT09ICdudW1iZXInKSB7XG4gICAgICAgIGNvbnN0IG51bXMgPSBkYXRhLm1hcChyb3cgPT4gcm93W2tleV0pIGFzIG51bWJlcltdO1xuICAgICAgICByZXR1cm4gKGFsaWduUG9zaXRpdmVOZWdhdGl2ZVxuICAgICAgICAgID8gWzAsIGQzTWF4KG51bXMubWFwKE1hdGguYWJzKSldXG4gICAgICAgICAgOiBkM0V4dGVudChudW1zKSkgYXMgVmFsdWVSYW5nZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgW2RhdGFdLFxuICApO1xuXG4gIGNvbnN0IGlzQWN0aXZlRmlsdGVyVmFsdWUgPSB1c2VDYWxsYmFjayhcbiAgICBmdW5jdGlvbiBpc0FjdGl2ZUZpbHRlclZhbHVlKGtleTogc3RyaW5nLCB2YWw6IERhdGFSZWNvcmRWYWx1ZSkge1xuICAgICAgcmV0dXJuICEhZmlsdGVycyAmJiBmaWx0ZXJzW2tleV0/LmluY2x1ZGVzKHZhbCk7XG4gICAgfSxcbiAgICBbZmlsdGVyc10sXG4gICk7XG5cbiAgY29uc3QgdG9nZ2xlRmlsdGVyID0gdXNlQ2FsbGJhY2soXG4gICAgZnVuY3Rpb24gdG9nZ2xlRmlsdGVyKGtleTogc3RyaW5nLCB2YWw6IERhdGFSZWNvcmRWYWx1ZSkge1xuICAgICAgY29uc3QgdXBkYXRlZEZpbHRlcnMgPSB7IC4uLihmaWx0ZXJzIHx8IHt9KSB9O1xuICAgICAgaWYgKGZpbHRlcnMgJiYgaXNBY3RpdmVGaWx0ZXJWYWx1ZShrZXksIHZhbCkpIHtcbiAgICAgICAgdXBkYXRlZEZpbHRlcnNba2V5XSA9IGZpbHRlcnNba2V5XS5maWx0ZXIoKHg6IERhdGFSZWNvcmRWYWx1ZSkgPT4geCAhPT0gdmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVwZGF0ZWRGaWx0ZXJzW2tleV0gPSBbLi4uKGZpbHRlcnM/LltrZXldIHx8IFtdKSwgdmFsXTtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHVwZGF0ZWRGaWx0ZXJzW2tleV0pICYmIHVwZGF0ZWRGaWx0ZXJzW2tleV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGRlbGV0ZSB1cGRhdGVkRmlsdGVyc1trZXldO1xuICAgICAgfVxuICAgICAgc2V0RmlsdGVycyh1cGRhdGVkRmlsdGVycyk7XG4gICAgICBoYW5kbGVDaGFuZ2UodXBkYXRlZEZpbHRlcnMpO1xuICAgIH0sXG4gICAgW2ZpbHRlcnMsIGhhbmRsZUNoYW5nZSwgaXNBY3RpdmVGaWx0ZXJWYWx1ZV0sXG4gICk7XG5cbiAgY29uc3QgZ2V0Q29sdW1uQ29uZmlncyA9IHVzZUNhbGxiYWNrKFxuICAgIChjb2x1bW46IERhdGFDb2x1bW5NZXRhLCBpOiBudW1iZXIpOiBDb2x1bW5XaXRoTG9vc2VBY2Nlc3NvcjxEPiA9PiB7XG4gICAgICBjb25zdCB7IGtleSwgbGFiZWwsIGRhdGFUeXBlLCBpc01ldHJpYywgY29uZmlnID0ge30gfSA9IGNvbHVtbjtcbiAgICAgIGNvbnN0IGlzTnVtYmVyID0gZGF0YVR5cGUgPT09IEdlbmVyaWNEYXRhVHlwZS5OVU1FUklDO1xuICAgICAgY29uc3QgaXNGaWx0ZXIgPSAhaXNOdW1iZXIgJiYgZW1pdEZpbHRlcjtcbiAgICAgIGNvbnN0IHRleHRBbGlnbiA9IGNvbmZpZy5ob3Jpem9udGFsQWxpZ25cbiAgICAgICAgPyBjb25maWcuaG9yaXpvbnRhbEFsaWduXG4gICAgICAgIDogaXNOdW1iZXJcbiAgICAgICAgPyAncmlnaHQnXG4gICAgICAgIDogJ2xlZnQnO1xuICAgICAgY29uc3QgY29sdW1uV2lkdGggPSBOdW1iZXIuaXNOYU4oTnVtYmVyKGNvbmZpZy5jb2x1bW5XaWR0aCkpXG4gICAgICAgID8gY29uZmlnLmNvbHVtbldpZHRoXG4gICAgICAgIDogTnVtYmVyKGNvbmZpZy5jb2x1bW5XaWR0aCk7XG5cbiAgICAgIC8vIGlubGluZSBzdHlsZSBmb3IgYm90aCB0aCBhbmQgdGQgY2VsbFxuICAgICAgY29uc3Qgc2hhcmVkU3R5bGU6IENTU1Byb3BlcnRpZXMgPSB7XG4gICAgICAgIHRleHRBbGlnbixcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGFsaWduUG9zaXRpdmVOZWdhdGl2ZSA9XG4gICAgICAgIGNvbmZpZy5hbGlnblBvc2l0aXZlTmVnYXRpdmUgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRBbGlnblBOIDogY29uZmlnLmFsaWduUG9zaXRpdmVOZWdhdGl2ZTtcbiAgICAgIGNvbnN0IGNvbG9yUG9zaXRpdmVOZWdhdGl2ZSA9XG4gICAgICAgIGNvbmZpZy5jb2xvclBvc2l0aXZlTmVnYXRpdmUgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRDb2xvclBOIDogY29uZmlnLmNvbG9yUG9zaXRpdmVOZWdhdGl2ZTtcblxuICAgICAgY29uc3QgdmFsdWVSYW5nZSA9XG4gICAgICAgIChjb25maWcuc2hvd0NlbGxCYXJzID09PSB1bmRlZmluZWQgPyBzaG93Q2VsbEJhcnMgOiBjb25maWcuc2hvd0NlbGxCYXJzKSAmJlxuICAgICAgICAoaXNNZXRyaWMgfHwgaXNSYXdSZWNvcmRzKSAmJlxuICAgICAgICBnZXRWYWx1ZVJhbmdlKGtleSwgYWxpZ25Qb3NpdGl2ZU5lZ2F0aXZlKTtcblxuICAgICAgbGV0IGNsYXNzTmFtZSA9ICcnO1xuICAgICAgaWYgKGlzRmlsdGVyKSB7XG4gICAgICAgIGNsYXNzTmFtZSArPSAnIGR0LWlzLWZpbHRlcic7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBTdHJpbmcoaSksIC8vIHRvIGFsbG93IGR1cGxpY2F0ZSBjb2x1bW4ga2V5c1xuICAgICAgICAvLyBtdXN0IHVzZSBjdXN0b20gYWNjZXNzb3IgdG8gYWxsb3cgYC5gIGluIGNvbHVtbiBuYW1lc1xuICAgICAgICAvLyB0eXBpbmcgaXMgaW5jb3JyZWN0IGluIGN1cnJlbnQgdmVyc2lvbiBvZiBgQHR5cGVzL3JlYWN0LXRhYmxlYFxuICAgICAgICAvLyBzbyB3ZSBhc2sgVFMgbm90IHRvIGNoZWNrLlxuICAgICAgICBhY2Nlc3NvcjogKChkYXR1bTogRCkgPT4gZGF0dW1ba2V5XSkgYXMgbmV2ZXIsXG4gICAgICAgIENlbGw6ICh7IHZhbHVlIH06IHsgY29sdW1uOiBDb2x1bW5JbnN0YW5jZTxEPjsgdmFsdWU6IERhdGFSZWNvcmRWYWx1ZSB9KSA9PiB7XG4gICAgICAgICAgY29uc3QgW2lzSHRtbCwgdGV4dF0gPSBmb3JtYXRDb2x1bW5WYWx1ZShjb2x1bW4sIHZhbHVlKTtcbiAgICAgICAgICBjb25zdCBodG1sID0gaXNIdG1sID8geyBfX2h0bWw6IHRleHQgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICBjb25zdCBjZWxsUHJvcHMgPSB7XG4gICAgICAgICAgICAvLyBzaG93IHJhdyBudW1iZXIgaW4gdGl0bGUgaW4gY2FzZSBvZiBudW1lcmljIHZhbHVlc1xuICAgICAgICAgICAgdGl0bGU6IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgPyBTdHJpbmcodmFsdWUpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgb25DbGljazogZW1pdEZpbHRlciAmJiAhdmFsdWVSYW5nZSA/ICgpID0+IHRvZ2dsZUZpbHRlcihrZXksIHZhbHVlKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogW1xuICAgICAgICAgICAgICBjbGFzc05hbWUsXG4gICAgICAgICAgICAgIHZhbHVlID09IG51bGwgPyAnZHQtaXMtbnVsbCcgOiAnJyxcbiAgICAgICAgICAgICAgaXNBY3RpdmVGaWx0ZXJWYWx1ZShrZXksIHZhbHVlKSA/ICcgZHQtaXMtYWN0aXZlLWZpbHRlcicgOiAnJyxcbiAgICAgICAgICAgIF0uam9pbignICcpLFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgLi4uc2hhcmVkU3R5bGUsXG4gICAgICAgICAgICAgIGJhY2tncm91bmQ6IHZhbHVlUmFuZ2VcbiAgICAgICAgICAgICAgICA/IGNlbGxCYXIoe1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUgYXMgbnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVJhbmdlLFxuICAgICAgICAgICAgICAgICAgICBhbGlnblBvc2l0aXZlTmVnYXRpdmUsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yUG9zaXRpdmVOZWdhdGl2ZSxcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKGh0bWwpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9uby1kYW5nZXJcbiAgICAgICAgICAgIHJldHVybiA8dGQgey4uLmNlbGxQcm9wc30gZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e2h0bWx9IC8+O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBJZiBjZWxsUHJvcHMgcmVuZGVyZXMgdGV4dENvbnRlbnQgYWxyZWFkeSwgdGhlbiB3ZSBkb24ndCBoYXZlIHRvXG4gICAgICAgICAgLy8gcmVuZGVyIGBDZWxsYC4gVGhpcyBzYXZlcyBzb21lIHRpbWUgZm9yIGxhcmdlIHRhYmxlcy5cbiAgICAgICAgICByZXR1cm4gPHRkIHsuLi5jZWxsUHJvcHN9Pnt0ZXh0fTwvdGQ+O1xuICAgICAgICB9LFxuICAgICAgICBIZWFkZXI6ICh7IGNvbHVtbjogY29sLCBvbkNsaWNrLCBzdHlsZSB9KSA9PiAoXG4gICAgICAgICAgPHRoXG4gICAgICAgICAgICB0aXRsZT1cIlNoaWZ0ICsgQ2xpY2sgdG8gc29ydCBieSBtdWx0aXBsZSBjb2x1bW5zXCJcbiAgICAgICAgICAgIGNsYXNzTmFtZT17W2NsYXNzTmFtZSwgY29sLmlzU29ydGVkID8gJ2lzLXNvcnRlZCcgOiAnJ10uam9pbignICcpfVxuICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgLi4uc2hhcmVkU3R5bGUsXG4gICAgICAgICAgICAgIC4uLnN0eWxlLFxuICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIG9uQ2xpY2s9e29uQ2xpY2t9XG4gICAgICAgICAgPlxuICAgICAgICAgICAgey8qIGNhbid0IHVzZSBgY29sdW1uV2lkdGggJiZgIGJlY2F1c2UgaXQgbWF5IGFsc28gYmUgemVybyAqL31cbiAgICAgICAgICAgIHtjb25maWcuY29sdW1uV2lkdGggPyAoXG4gICAgICAgICAgICAgIC8vIGNvbHVtbiB3aWR0aCBoaW50XG4gICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgd2lkdGg6IGNvbHVtbldpZHRoLFxuICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAwLjAxLFxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICApIDogbnVsbH1cbiAgICAgICAgICAgIHtsYWJlbH1cbiAgICAgICAgICAgIDxTb3J0SWNvbiBjb2x1bW49e2NvbH0gLz5cbiAgICAgICAgICA8L3RoPlxuICAgICAgICApLFxuICAgICAgICBzb3J0RGVzY0ZpcnN0OiBzb3J0RGVzYyxcbiAgICAgICAgc29ydFR5cGU6IGdldFNvcnRUeXBlQnlEYXRhVHlwZShkYXRhVHlwZSksXG4gICAgICB9O1xuICAgIH0sXG4gICAgW1xuICAgICAgZGVmYXVsdEFsaWduUE4sXG4gICAgICBkZWZhdWx0Q29sb3JQTixcbiAgICAgIGVtaXRGaWx0ZXIsXG4gICAgICBnZXRWYWx1ZVJhbmdlLFxuICAgICAgaXNBY3RpdmVGaWx0ZXJWYWx1ZSxcbiAgICAgIGlzUmF3UmVjb3JkcyxcbiAgICAgIHNob3dDZWxsQmFycyxcbiAgICAgIHNvcnREZXNjLFxuICAgICAgdG9nZ2xlRmlsdGVyLFxuICAgIF0sXG4gICk7XG5cbiAgY29uc3QgY29sdW1ucyA9IHVzZU1lbW8oKCkgPT4gY29sdW1uc01ldGEubWFwKGdldENvbHVtbkNvbmZpZ3MpLCBbY29sdW1uc01ldGEsIGdldENvbHVtbkNvbmZpZ3NdKTtcblxuICBjb25zdCBoYW5kbGVTZXJ2ZXJQYWdpbmF0aW9uQ2hhbmdlID0gKHBhZ2VOdW1iZXI6IG51bWJlciwgcGFnZVNpemU6IG51bWJlcikgPT4ge1xuICAgIHVwZGF0ZUV4dGVybmFsRm9ybURhdGEoc2V0RGF0YU1hc2ssIHBhZ2VOdW1iZXIsIHBhZ2VTaXplKTtcbiAgfTtcblxuICBjb25zdCB0b3RhbHNGb3JtYXR0ZWQgPVxuICAgIHRvdGFscyAmJlxuICAgIGNvbHVtbnNNZXRhXG4gICAgICAuZmlsdGVyKGNvbHVtbiA9PiBPYmplY3Qua2V5cyh0b3RhbHMpLmluY2x1ZGVzKGNvbHVtbi5rZXkpKVxuICAgICAgLnJlZHVjZShcbiAgICAgICAgKGFjYzogeyB2YWx1ZTogc3RyaW5nOyBjbGFzc05hbWU6IHN0cmluZyB9W10sIGNvbHVtbikgPT4gW1xuICAgICAgICAgIC4uLmFjYyxcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YWx1ZTogZm9ybWF0Q29sdW1uVmFsdWUoY29sdW1uLCB0b3RhbHNbY29sdW1uLmtleV0pWzFdLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBjb2x1bW4uZGF0YVR5cGUgPT09IEdlbmVyaWNEYXRhVHlwZS5OVU1FUklDID8gJ2R0LW1ldHJpYycgOiAnJyxcbiAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBbXSxcbiAgICAgICk7XG5cbiAgY29uc3QgdG90YWxzSGVhZGVyU3BhbiA9XG4gICAgdG90YWxzRm9ybWF0dGVkICYmXG4gICAgY29sdW1uc01ldGEuZmlsdGVyKGNvbHVtbiA9PiAhY29sdW1uLmlzUGVyY2VudE1ldHJpYykubGVuZ3RoIC0gdG90YWxzRm9ybWF0dGVkLmxlbmd0aDtcblxuICByZXR1cm4gKFxuICAgIDxTdHlsZXM+XG4gICAgICA8RGF0YVRhYmxlPEQ+XG4gICAgICAgIGNvbHVtbnM9e2NvbHVtbnN9XG4gICAgICAgIHRvdGFscz17dG90YWxzRm9ybWF0dGVkfVxuICAgICAgICB0b3RhbHNIZWFkZXJTcGFuPXt0b3RhbHNIZWFkZXJTcGFufVxuICAgICAgICBkYXRhPXtkYXRhfVxuICAgICAgICByb3dDb3VudD17cm93Q291bnR9XG4gICAgICAgIHRhYmxlQ2xhc3NOYW1lPVwidGFibGUgdGFibGUtc3RyaXBlZCB0YWJsZS1jb25kZW5zZWRcIlxuICAgICAgICBwYWdlU2l6ZT17cGFnZVNpemV9XG4gICAgICAgIHNlcnZlclBhZ2luYXRpb25EYXRhPXtzZXJ2ZXJQYWdpbmF0aW9uRGF0YX1cbiAgICAgICAgcGFnZVNpemVPcHRpb25zPXtwYWdlU2l6ZU9wdGlvbnN9XG4gICAgICAgIGhlaWdodD17aGVpZ2h0fVxuICAgICAgICBzZXJ2ZXJQYWdpbmF0aW9uPXtzZXJ2ZXJQYWdpbmF0aW9ufVxuICAgICAgICBvblNlcnZlclBhZ2luYXRpb25DaGFuZ2U9e2hhbmRsZVNlcnZlclBhZ2luYXRpb25DaGFuZ2V9XG4gICAgICAgIC8vIDkgcGFnZSBpdGVtcyBpbiA+IDM0MHB4IHdvcmtzIHdlbGwgZXZlbiBmb3IgMTAwKyBwYWdlc1xuICAgICAgICBtYXhQYWdlSXRlbUNvdW50PXt3aWR0aCA+IDM0MCA/IDkgOiA3fVxuICAgICAgICBub1Jlc3VsdHM9eyhmaWx0ZXI6IHN0cmluZykgPT4gdChmaWx0ZXIgPyAnTm8gbWF0Y2hpbmcgcmVjb3JkcyBmb3VuZCcgOiAnTm8gcmVjb3JkcyBmb3VuZCcpfVxuICAgICAgICBzZWFyY2hJbnB1dD17aW5jbHVkZVNlYXJjaCAmJiBTZWFyY2hJbnB1dH1cbiAgICAgICAgc2VsZWN0UGFnZVNpemU9e3BhZ2VTaXplICE9PSBudWxsICYmIFNlbGVjdFBhZ2VTaXplfVxuICAgICAgICAvLyBub3QgaW4gdXNlIGluIFN1cGVyc2V0LCBidXQgbmVlZGVkIGZvciB1bml0IHRlc3RzXG4gICAgICAgIHN0aWNreT17c3RpY2t5fVxuICAgICAgLz5cbiAgICA8L1N0eWxlcz5cbiAgKTtcbn1cbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7O0FDbERBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTtBQUNBO0FBRUE7QUFpQkE7QUFDQTs7QUFFQTtBQUNBO0FBUUE7QUFFQTtBQU1BO0FBQ0E7QUFHQTtBQUNBO0FBSUE7QUFFQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7Ozs7OztBQy9FQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFDQTtBQUNBO0FBVUE7QUFDQTs7QUFFQTtBQUNBO0FBS0E7QUFDQTtBQUdBO0FBQ0E7QUFLQTtBQUNBO0FBRUE7QUFFQTtBQVFBO0FBQ0E7QUFDQTtBQUVBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFGQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFDQTtBQVdBO0FBQ0E7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBS0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBT0E7QUFPQTs7O0FDakdBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL0NBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTtBQUNBOztBQUVBO0FBQ0E7QUFhQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTtBQUNBO0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFDQTtBQVlBO0FBQ0E7QUFDQTtBQXNCQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBa0NBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQU9BO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBTUE7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFTQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3hZQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFDQTtBQVFBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUEyQkE7QUFDQTs7QUFBQTtBQXdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFnQkE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBVUE7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUtBO0FBR0E7QUFNQTtBQUVBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBV0E7QUFFQTtBQVdBO0FBQ0E7QUFZQTs7Ozs7O0FDclVBO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTBDQTs7Ozs7O0FBTUE7Ozs7QUFJQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQTs7Ozs7Ozs7O0FDL0VBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSUE7Ozs7OztBQ3RFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFRQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBR0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFLQTtBQXNCQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBOztBQUVBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBR0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUVBO0FBRUE7QUFFQTtBQWFBO0FBQ0E7QUFJQTtBQUNBO0FBSUE7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2470\n')}}]);