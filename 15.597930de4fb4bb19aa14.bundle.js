(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{1384:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"a\", function() { return /* binding */ getTextDimension; });\n\n// CONCATENATED MODULE: ../superset-ui-dimension/src/svg/updateTextNode.ts\nconst STYLE_FIELDS = [\n    'font',\n    'fontWeight',\n    'fontStyle',\n    'fontSize',\n    'fontFamily',\n    'letterSpacing',\n];\nfunction updateTextNode(node, { className, style = {}, text, } = {}) {\n    const textNode = node;\n    if (textNode.textContent !== text) {\n        textNode.textContent = typeof text === 'undefined' ? null : text;\n    }\n    if (textNode.getAttribute('class') !== className) {\n        textNode.setAttribute('class', className !== null && className !== void 0 ? className : '');\n    }\n    // Clear style\n    // Note: multi-word property names are hyphenated and not camel-cased.\n    textNode.style.removeProperty('font');\n    textNode.style.removeProperty('font-weight');\n    textNode.style.removeProperty('font-style');\n    textNode.style.removeProperty('font-size');\n    textNode.style.removeProperty('font-family');\n    textNode.style.removeProperty('letter-spacing');\n    // Apply new style\n    // Note: the font field will auto-populate other font fields when applicable.\n    STYLE_FIELDS.filter((field) => typeof style[field] !== 'undefined' && style[field] !== null).forEach((field) => {\n        textNode.style[field] = `${style[field]}`;\n    });\n    return textNode;\n}\n\n// CONCATENATED MODULE: ../superset-ui-dimension/src/svg/getBBoxCeil.ts\nconst DEFAULT_DIMENSION = { height: 20, width: 100 };\nfunction getBBoxCeil(node, defaultDimension = DEFAULT_DIMENSION) {\n    const { width, height } = node.getBBox ? node.getBBox() : defaultDimension;\n    return {\n        height: Math.ceil(height),\n        width: Math.ceil(width),\n    };\n}\n\n// CONCATENATED MODULE: ../superset-ui-dimension/src/svg/LazyFactory.ts\nclass LazyFactory {\n    constructor(factoryFn) {\n        this.activeNodes = new Map();\n        this.factoryFn = factoryFn;\n    }\n    createInContainer(container = document.body) {\n        if (this.activeNodes.has(container)) {\n            const entry = this.activeNodes.get(container);\n            entry.counter += 1;\n            return entry.node;\n        }\n        const node = this.factoryFn();\n        container.append(node);\n        this.activeNodes.set(container, { counter: 1, node });\n        return node;\n    }\n    removeFromContainer(container = document.body) {\n        if (this.activeNodes.has(container)) {\n            const entry = this.activeNodes.get(container);\n            entry.counter -= 1;\n            if (entry.counter === 0) {\n                container.removeChild(entry.node);\n                this.activeNodes.delete(container);\n            }\n        }\n    }\n}\n\n// CONCATENATED MODULE: ../superset-ui-dimension/src/svg/constants.ts\n// eslint-disable-next-line import/prefer-default-export\nconst SVG_NS = 'http://www.w3.org/2000/svg';\n\n// CONCATENATED MODULE: ../superset-ui-dimension/src/svg/createHiddenSvgNode.ts\n\nfunction createHiddenSvgNode() {\n    const svgNode = document.createElementNS(SVG_NS, 'svg');\n    svgNode.style.position = 'absolute'; // so it won't disrupt page layout\n    svgNode.style.top = '-100%';\n    svgNode.style.left = '-100%';\n    svgNode.style.width = '0'; // no dimensions\n    svgNode.style.height = '0';\n    svgNode.style.opacity = '0'; // not visible\n    svgNode.style.pointerEvents = 'none'; // won't capture mouse events\n    return svgNode;\n}\n\n// CONCATENATED MODULE: ../superset-ui-dimension/src/svg/createTextNode.ts\n\nfunction createTextNode() {\n    return document.createElementNS(SVG_NS, 'text');\n}\n\n// CONCATENATED MODULE: ../superset-ui-dimension/src/svg/factories.ts\n\n\n\nconst hiddenSvgFactory = new LazyFactory(createHiddenSvgNode);\nconst textFactory = new LazyFactory(createTextNode);\n\n// CONCATENATED MODULE: ../superset-ui-dimension/src/getTextDimension.ts\n\n\n\nfunction getTextDimension(input, defaultDimension) {\n    const { text, className, style, container } = input;\n    // Empty string\n    if (text.length === 0) {\n        return { height: 0, width: 0 };\n    }\n    const svgNode = hiddenSvgFactory.createInContainer(container);\n    const textNode = textFactory.createInContainer(svgNode);\n    updateTextNode(textNode, { className, style, text });\n    const dimension = getBBoxCeil(textNode, defaultDimension);\n    // The nodes are added to the DOM briefly only to make getBBox works.\n    // (If not added to DOM getBBox will always return 0x0.)\n    // After that the svg nodes are not needed.\n    // We delay its removal in case there are subsequent calls to this function\n    // that can reuse the svg nodes.\n    // Experiments have shown that reusing existing nodes\n    // instead of deleting and adding new ones can save lot of time.\n    setTimeout(() => {\n        textFactory.removeFromContainer(svgNode);\n        hiddenSvgFactory.removeFromContainer(container);\n    }, 500);\n    return dimension;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM4NC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9zdXBlcnNldC11aS1kaW1lbnNpb24vc3JjL3N2Zy91cGRhdGVUZXh0Tm9kZS50cz8zZDE4Iiwid2VicGFjazovLy8uLi9zdXBlcnNldC11aS1kaW1lbnNpb24vc3JjL3N2Zy9nZXRCQm94Q2VpbC50cz9hMTc5Iiwid2VicGFjazovLy8uLi9zdXBlcnNldC11aS1kaW1lbnNpb24vc3JjL3N2Zy9MYXp5RmFjdG9yeS50cz9lNTI0Iiwid2VicGFjazovLy8uLi9zdXBlcnNldC11aS1kaW1lbnNpb24vc3JjL3N2Zy9jb25zdGFudHMudHM/NzkzZCIsIndlYnBhY2s6Ly8vLi4vc3VwZXJzZXQtdWktZGltZW5zaW9uL3NyYy9zdmcvY3JlYXRlSGlkZGVuU3ZnTm9kZS50cz82MTYyIiwid2VicGFjazovLy8uLi9zdXBlcnNldC11aS1kaW1lbnNpb24vc3JjL3N2Zy9jcmVhdGVUZXh0Tm9kZS50cz81ZGI3Iiwid2VicGFjazovLy8uLi9zdXBlcnNldC11aS1kaW1lbnNpb24vc3JjL3N2Zy9mYWN0b3JpZXMudHM/ODQyYyIsIndlYnBhY2s6Ly8vLi4vc3VwZXJzZXQtdWktZGltZW5zaW9uL3NyYy9nZXRUZXh0RGltZW5zaW9uLnRzP2U5MzMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVGV4dFN0eWxlIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5jb25zdCBTVFlMRV9GSUVMRFM6IChrZXlvZiBUZXh0U3R5bGUpW10gPSBbXG4gICdmb250JyxcbiAgJ2ZvbnRXZWlnaHQnLFxuICAnZm9udFN0eWxlJyxcbiAgJ2ZvbnRTaXplJyxcbiAgJ2ZvbnRGYW1pbHknLFxuICAnbGV0dGVyU3BhY2luZycsXG5dO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1cGRhdGVUZXh0Tm9kZShcbiAgbm9kZTogU1ZHVGV4dEVsZW1lbnQsXG4gIHtcbiAgICBjbGFzc05hbWUsXG4gICAgc3R5bGUgPSB7fSxcbiAgICB0ZXh0LFxuICB9OiB7XG4gICAgY2xhc3NOYW1lPzogc3RyaW5nO1xuICAgIHN0eWxlPzogVGV4dFN0eWxlO1xuICAgIHRleHQ/OiBzdHJpbmc7XG4gIH0gPSB7fSxcbikge1xuICBjb25zdCB0ZXh0Tm9kZSA9IG5vZGU7XG5cbiAgaWYgKHRleHROb2RlLnRleHRDb250ZW50ICE9PSB0ZXh0KSB7XG4gICAgdGV4dE5vZGUudGV4dENvbnRlbnQgPSB0eXBlb2YgdGV4dCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogdGV4dDtcbiAgfVxuICBpZiAodGV4dE5vZGUuZ2V0QXR0cmlidXRlKCdjbGFzcycpICE9PSBjbGFzc05hbWUpIHtcbiAgICB0ZXh0Tm9kZS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2xhc3NOYW1lID8/ICcnKTtcbiAgfVxuXG4gIC8vIENsZWFyIHN0eWxlXG4gIC8vIE5vdGU6IG11bHRpLXdvcmQgcHJvcGVydHkgbmFtZXMgYXJlIGh5cGhlbmF0ZWQgYW5kIG5vdCBjYW1lbC1jYXNlZC5cbiAgdGV4dE5vZGUuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ2ZvbnQnKTtcbiAgdGV4dE5vZGUuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ2ZvbnQtd2VpZ2h0Jyk7XG4gIHRleHROb2RlLnN0eWxlLnJlbW92ZVByb3BlcnR5KCdmb250LXN0eWxlJyk7XG4gIHRleHROb2RlLnN0eWxlLnJlbW92ZVByb3BlcnR5KCdmb250LXNpemUnKTtcbiAgdGV4dE5vZGUuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ2ZvbnQtZmFtaWx5Jyk7XG4gIHRleHROb2RlLnN0eWxlLnJlbW92ZVByb3BlcnR5KCdsZXR0ZXItc3BhY2luZycpO1xuXG4gIC8vIEFwcGx5IG5ldyBzdHlsZVxuICAvLyBOb3RlOiB0aGUgZm9udCBmaWVsZCB3aWxsIGF1dG8tcG9wdWxhdGUgb3RoZXIgZm9udCBmaWVsZHMgd2hlbiBhcHBsaWNhYmxlLlxuICBTVFlMRV9GSUVMRFMuZmlsdGVyKFxuICAgIChmaWVsZDoga2V5b2YgVGV4dFN0eWxlKSA9PiB0eXBlb2Ygc3R5bGVbZmllbGRdICE9PSAndW5kZWZpbmVkJyAmJiBzdHlsZVtmaWVsZF0gIT09IG51bGwsXG4gICkuZm9yRWFjaCgoZmllbGQ6IGtleW9mIFRleHRTdHlsZSkgPT4ge1xuICAgIHRleHROb2RlLnN0eWxlW2ZpZWxkXSA9IGAke3N0eWxlW2ZpZWxkXX1gO1xuICB9KTtcblxuICByZXR1cm4gdGV4dE5vZGU7XG59XG4iLCJpbXBvcnQgeyBEaW1lbnNpb24gfSBmcm9tICcuLi90eXBlcyc7XG5cbmNvbnN0IERFRkFVTFRfRElNRU5TSU9OID0geyBoZWlnaHQ6IDIwLCB3aWR0aDogMTAwIH07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEJCb3hDZWlsKFxuICBub2RlOiBTVkdHcmFwaGljc0VsZW1lbnQsXG4gIGRlZmF1bHREaW1lbnNpb246IERpbWVuc2lvbiA9IERFRkFVTFRfRElNRU5TSU9OLFxuKSB7XG4gIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gbm9kZS5nZXRCQm94ID8gbm9kZS5nZXRCQm94KCkgOiBkZWZhdWx0RGltZW5zaW9uO1xuXG4gIHJldHVybiB7XG4gICAgaGVpZ2h0OiBNYXRoLmNlaWwoaGVpZ2h0KSxcbiAgICB3aWR0aDogTWF0aC5jZWlsKHdpZHRoKSxcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIExhenlGYWN0b3J5PFQgZXh0ZW5kcyBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnQ+IHtcbiAgcHJpdmF0ZSBhY3RpdmVOb2RlcyA9IG5ldyBNYXA8XG4gICAgSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50LFxuICAgIHtcbiAgICAgIGNvdW50ZXI6IG51bWJlcjtcbiAgICAgIG5vZGU6IFQ7XG4gICAgfVxuICA+KCk7XG5cbiAgcHJpdmF0ZSBmYWN0b3J5Rm46ICgpID0+IFQ7XG5cbiAgY29uc3RydWN0b3IoZmFjdG9yeUZuOiAoKSA9PiBUKSB7XG4gICAgdGhpcy5mYWN0b3J5Rm4gPSBmYWN0b3J5Rm47XG4gIH1cblxuICBjcmVhdGVJbkNvbnRhaW5lcihjb250YWluZXI6IEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudCA9IGRvY3VtZW50LmJvZHkpIHtcbiAgICBpZiAodGhpcy5hY3RpdmVOb2Rlcy5oYXMoY29udGFpbmVyKSkge1xuICAgICAgY29uc3QgZW50cnkgPSB0aGlzLmFjdGl2ZU5vZGVzLmdldChjb250YWluZXIpITtcbiAgICAgIGVudHJ5LmNvdW50ZXIgKz0gMTtcblxuICAgICAgcmV0dXJuIGVudHJ5Lm5vZGU7XG4gICAgfVxuXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuZmFjdG9yeUZuKCk7XG4gICAgY29udGFpbmVyLmFwcGVuZChub2RlKTtcbiAgICB0aGlzLmFjdGl2ZU5vZGVzLnNldChjb250YWluZXIsIHsgY291bnRlcjogMSwgbm9kZSB9KTtcblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcmVtb3ZlRnJvbUNvbnRhaW5lcihjb250YWluZXI6IEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudCA9IGRvY3VtZW50LmJvZHkpIHtcbiAgICBpZiAodGhpcy5hY3RpdmVOb2Rlcy5oYXMoY29udGFpbmVyKSkge1xuICAgICAgY29uc3QgZW50cnkgPSB0aGlzLmFjdGl2ZU5vZGVzLmdldChjb250YWluZXIpITtcbiAgICAgIGVudHJ5LmNvdW50ZXIgLT0gMTtcbiAgICAgIGlmIChlbnRyeS5jb3VudGVyID09PSAwKSB7XG4gICAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChlbnRyeS5ub2RlKTtcbiAgICAgICAgdGhpcy5hY3RpdmVOb2Rlcy5kZWxldGUoY29udGFpbmVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiIsIi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvcHJlZmVyLWRlZmF1bHQtZXhwb3J0XG5leHBvcnQgY29uc3QgU1ZHX05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbiIsImltcG9ydCB7IFNWR19OUyB9IGZyb20gJy4vY29uc3RhbnRzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlSGlkZGVuU3ZnTm9kZSgpIHtcbiAgY29uc3Qgc3ZnTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsICdzdmcnKTtcbiAgc3ZnTm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7IC8vIHNvIGl0IHdvbid0IGRpc3J1cHQgcGFnZSBsYXlvdXRcbiAgc3ZnTm9kZS5zdHlsZS50b3AgPSAnLTEwMCUnO1xuICBzdmdOb2RlLnN0eWxlLmxlZnQgPSAnLTEwMCUnO1xuICBzdmdOb2RlLnN0eWxlLndpZHRoID0gJzAnOyAvLyBubyBkaW1lbnNpb25zXG4gIHN2Z05vZGUuc3R5bGUuaGVpZ2h0ID0gJzAnO1xuICBzdmdOb2RlLnN0eWxlLm9wYWNpdHkgPSAnMCc7IC8vIG5vdCB2aXNpYmxlXG4gIHN2Z05vZGUuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJzsgLy8gd29uJ3QgY2FwdHVyZSBtb3VzZSBldmVudHNcblxuICByZXR1cm4gc3ZnTm9kZTtcbn1cbiIsImltcG9ydCB7IFNWR19OUyB9IGZyb20gJy4vY29uc3RhbnRzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUoKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCAndGV4dCcpO1xufVxuIiwiaW1wb3J0IExhenlGYWN0b3J5IGZyb20gJy4vTGF6eUZhY3RvcnknO1xuaW1wb3J0IGNyZWF0ZUhpZGRlblN2Z05vZGUgZnJvbSAnLi9jcmVhdGVIaWRkZW5TdmdOb2RlJztcbmltcG9ydCBjcmVhdGVUZXh0Tm9kZSBmcm9tICcuL2NyZWF0ZVRleHROb2RlJztcblxuZXhwb3J0IGNvbnN0IGhpZGRlblN2Z0ZhY3RvcnkgPSBuZXcgTGF6eUZhY3RvcnkoY3JlYXRlSGlkZGVuU3ZnTm9kZSk7XG5leHBvcnQgY29uc3QgdGV4dEZhY3RvcnkgPSBuZXcgTGF6eUZhY3RvcnkoY3JlYXRlVGV4dE5vZGUpO1xuIiwiaW1wb3J0IHsgVGV4dFN0eWxlLCBEaW1lbnNpb24gfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB1cGRhdGVUZXh0Tm9kZSBmcm9tICcuL3N2Zy91cGRhdGVUZXh0Tm9kZSc7XG5pbXBvcnQgZ2V0QkJveENlaWwgZnJvbSAnLi9zdmcvZ2V0QkJveENlaWwnO1xuaW1wb3J0IHsgaGlkZGVuU3ZnRmFjdG9yeSwgdGV4dEZhY3RvcnkgfSBmcm9tICcuL3N2Zy9mYWN0b3JpZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIEdldFRleHREaW1lbnNpb25JbnB1dCB7XG4gIGNsYXNzTmFtZT86IHN0cmluZztcbiAgY29udGFpbmVyPzogSFRNTEVsZW1lbnQ7XG4gIHN0eWxlPzogVGV4dFN0eWxlO1xuICB0ZXh0OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFRleHREaW1lbnNpb24oXG4gIGlucHV0OiBHZXRUZXh0RGltZW5zaW9uSW5wdXQsXG4gIGRlZmF1bHREaW1lbnNpb24/OiBEaW1lbnNpb24sXG4pOiBEaW1lbnNpb24ge1xuICBjb25zdCB7IHRleHQsIGNsYXNzTmFtZSwgc3R5bGUsIGNvbnRhaW5lciB9ID0gaW5wdXQ7XG5cbiAgLy8gRW1wdHkgc3RyaW5nXG4gIGlmICh0ZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB7IGhlaWdodDogMCwgd2lkdGg6IDAgfTtcbiAgfVxuXG4gIGNvbnN0IHN2Z05vZGUgPSBoaWRkZW5TdmdGYWN0b3J5LmNyZWF0ZUluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gIGNvbnN0IHRleHROb2RlID0gdGV4dEZhY3RvcnkuY3JlYXRlSW5Db250YWluZXIoc3ZnTm9kZSk7XG4gIHVwZGF0ZVRleHROb2RlKHRleHROb2RlLCB7IGNsYXNzTmFtZSwgc3R5bGUsIHRleHQgfSk7XG4gIGNvbnN0IGRpbWVuc2lvbiA9IGdldEJCb3hDZWlsKHRleHROb2RlLCBkZWZhdWx0RGltZW5zaW9uKTtcblxuICAvLyBUaGUgbm9kZXMgYXJlIGFkZGVkIHRvIHRoZSBET00gYnJpZWZseSBvbmx5IHRvIG1ha2UgZ2V0QkJveCB3b3Jrcy5cbiAgLy8gKElmIG5vdCBhZGRlZCB0byBET00gZ2V0QkJveCB3aWxsIGFsd2F5cyByZXR1cm4gMHgwLilcbiAgLy8gQWZ0ZXIgdGhhdCB0aGUgc3ZnIG5vZGVzIGFyZSBub3QgbmVlZGVkLlxuICAvLyBXZSBkZWxheSBpdHMgcmVtb3ZhbCBpbiBjYXNlIHRoZXJlIGFyZSBzdWJzZXF1ZW50IGNhbGxzIHRvIHRoaXMgZnVuY3Rpb25cbiAgLy8gdGhhdCBjYW4gcmV1c2UgdGhlIHN2ZyBub2Rlcy5cbiAgLy8gRXhwZXJpbWVudHMgaGF2ZSBzaG93biB0aGF0IHJldXNpbmcgZXhpc3Rpbmcgbm9kZXNcbiAgLy8gaW5zdGVhZCBvZiBkZWxldGluZyBhbmQgYWRkaW5nIG5ldyBvbmVzIGNhbiBzYXZlIGxvdCBvZiB0aW1lLlxuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICB0ZXh0RmFjdG9yeS5yZW1vdmVGcm9tQ29udGFpbmVyKHN2Z05vZGUpO1xuICAgIGhpZGRlblN2Z0ZhY3RvcnkucmVtb3ZlRnJvbUNvbnRhaW5lcihjb250YWluZXIpO1xuICB9LCA1MDApO1xuXG4gIHJldHVybiBkaW1lbnNpb247XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBWUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7OztBQ2hEQTtBQUVBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNkQTtBQVdBO0FBVkE7QUFXQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hDQTtBQUNBOzs7QUNEQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7OztBQ2JBO0FBRUE7QUFDQTtBQUNBOzs7QUNKQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7QUNKQTtBQUNBO0FBQ0E7QUFTQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1384\n")},2377:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, "renderTooltipFactory", function() { return /* binding */ renderTooltipFactory; });\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react/index.js\nvar react = __webpack_require__(0);\nvar react_default = /*#__PURE__*/__webpack_require__.n(react);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/shortid/index.js\nvar shortid = __webpack_require__(1846);\nvar shortid_default = /*#__PURE__*/__webpack_require__.n(shortid);\n\n// EXTERNAL MODULE: ../superset-ui-translation/src/TranslatorSingleton.ts + 1 modules\nvar TranslatorSingleton = __webpack_require__(2);\n\n// EXTERNAL MODULE: ../superset-ui-number-format/src/NumberFormatterRegistrySingleton.ts + 2 modules\nvar NumberFormatterRegistrySingleton = __webpack_require__(103);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/chart/XYChart.js + 51 modules\nvar XYChart = __webpack_require__(2344);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/aesthetic/LinearGradient.js\nvar LinearGradient = __webpack_require__(1855);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/series/AreaSeries.js\nvar AreaSeries = __webpack_require__(1856);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/xy-chart/esm/chart/CrossHair.js\nvar CrossHair = __webpack_require__(1857);\n\n// EXTERNAL MODULE: ../superset-ui-color/src/index.ts + 3 modules\nvar src = __webpack_require__(183);\n\n// EXTERNAL MODULE: ../superset-ui-dimension/src/getTextDimension.ts + 7 modules\nvar getTextDimension = __webpack_require__(1384);\n\n// CONCATENATED MODULE: ../superset-ui-dimension/src/computeMaxFontSize.ts\nvar __rest = (undefined && undefined.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === "function")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n\nfunction decreaseSizeUntil(startSize, computeDimension, condition) {\n    let size = startSize;\n    let dimension = computeDimension(size);\n    while (!condition(dimension)) {\n        size -= 1;\n        dimension = computeDimension(size);\n    }\n    return size;\n}\nfunction computeMaxFontSize(input) {\n    const { idealFontSize, maxWidth, maxHeight, style } = input, rest = __rest(input, ["idealFontSize", "maxWidth", "maxHeight", "style"]);\n    let size;\n    if (idealFontSize !== undefined && idealFontSize !== null) {\n        size = idealFontSize;\n    }\n    else if (maxHeight === undefined || maxHeight === null) {\n        throw new Error(\'You must specify at least one of maxHeight or idealFontSize\');\n    }\n    else {\n        size = Math.floor(maxHeight);\n    }\n    function computeDimension(fontSize) {\n        return Object(getTextDimension["a" /* default */])(Object.assign(Object.assign({}, rest), { style: Object.assign(Object.assign({}, style), { fontSize: `${fontSize}px` }) }));\n    }\n    if (maxWidth !== undefined && maxWidth !== null) {\n        size = decreaseSizeUntil(size, computeDimension, dim => dim.width <= maxWidth);\n    }\n    if (maxHeight !== undefined && maxHeight !== null) {\n        size = decreaseSizeUntil(size, computeDimension, dim => dim.height <= maxHeight);\n    }\n    return size;\n}\n\n// EXTERNAL MODULE: ../superset-ui-style/src/index.ts\nvar superset_ui_style_src = __webpack_require__(150);\n\n// EXTERNAL MODULE: ../superset-ui-time-format/src/formatters/smartDateVerbose.ts\nvar smartDateVerbose = __webpack_require__(565);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-preset-chart-big-number/src/BigNumber/BigNumber.tsx\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\n\n\n\n\n\n\n\nconst defaultNumberFormatter = Object(NumberFormatterRegistrySingleton["c" /* getNumberFormatter */])();\nconst CHART_MARGIN = {\n    top: 4,\n    right: 4,\n    bottom: 4,\n    left: 4,\n};\nconst PROPORTION = {\n    // text size: proportion of the chart container sans trendline\n    HEADER: 0.3,\n    SUBHEADER: 0.125,\n    // trendline size: proportion of the whole chart container\n    TRENDLINE: 0.3,\n};\nfunction renderTooltipFactory(formatDate = smartDateVerbose["a" /* default */], formatValue = defaultNumberFormatter) {\n    return function renderTooltip({ datum: { x, y } }) {\n        // even though `formatDate` supports timestamp as numbers, we need\n        // `new Date` to pass type check\n        return (react_default.a.createElement("div", { style: { padding: \'4px 8px\' } },\n            formatDate(new Date(x)),\n            react_default.a.createElement("br", null),\n            react_default.a.createElement("strong", null, y === null ? Object(TranslatorSingleton["b" /* t */])(\'N/A\') : formatValue(y))));\n    };\n}\nclass BigNumber_BigNumberVis extends react_default.a.PureComponent {\n    constructor() {\n        super(...arguments);\n        this.gradientId = shortid_default.a.generate();\n    }\n    getClassName() {\n        const { className, showTrendLine, bigNumberFallback } = this.props;\n        const names = `superset-legacy-chart-big-number ${className} ${bigNumberFallback ? \'is-fallback-value\' : \'\'}`;\n        if (showTrendLine)\n            return names;\n        return `${names} no-trendline`;\n    }\n    createTemporaryContainer() {\n        const container = document.createElement(\'div\');\n        container.className = this.getClassName();\n        container.style.position = \'absolute\'; // so it won\'t disrupt page layout\n        container.style.opacity = \'0\'; // and not visible\n        return container;\n    }\n    renderFallbackWarning() {\n        const { bigNumberFallback, formatTime } = this.props;\n        if (!bigNumberFallback)\n            return null;\n        return (react_default.a.createElement("span", { className: "alert alert-warning", role: "alert", title: Object(TranslatorSingleton["b" /* t */])(`Last available value seen on %s`, formatTime(bigNumberFallback.x)) }, Object(TranslatorSingleton["b" /* t */])(\'Not up to date\')));\n    }\n    renderHeader(maxHeight) {\n        const { bigNumber, formatNumber, width } = this.props;\n        const text = bigNumber === null ? Object(TranslatorSingleton["b" /* t */])(\'No data\') : formatNumber(bigNumber);\n        const container = this.createTemporaryContainer();\n        document.body.append(container);\n        const fontSize = computeMaxFontSize({\n            text,\n            maxWidth: width,\n            maxHeight,\n            className: \'header-line\',\n            container,\n        });\n        container.remove();\n        return (react_default.a.createElement("div", { className: "header-line", style: {\n                fontSize,\n                height: maxHeight,\n            } }, text));\n    }\n    renderSubheader(maxHeight) {\n        const { bigNumber, subheader, width, bigNumberFallback } = this.props;\n        let fontSize = 0;\n        const NO_DATA_OR_HASNT_LANDED = Object(TranslatorSingleton["b" /* t */])(\'No data after filtering or data is NULL for the latest time record\');\n        const NO_DATA = Object(TranslatorSingleton["b" /* t */])(\'Try applying different filters or ensuring your datasource has data\');\n        let text = subheader;\n        if (bigNumber === null) {\n            text = bigNumberFallback ? NO_DATA : NO_DATA_OR_HASNT_LANDED;\n        }\n        if (text) {\n            const container = this.createTemporaryContainer();\n            document.body.append(container);\n            fontSize = computeMaxFontSize({\n                text,\n                maxWidth: width,\n                maxHeight,\n                className: \'subheader-line\',\n                container,\n            });\n            container.remove();\n            return (react_default.a.createElement("div", { className: "subheader-line", style: {\n                    fontSize,\n                    height: maxHeight,\n                } }, text));\n        }\n        return null;\n    }\n    renderTrendline(maxHeight) {\n        var _a;\n        const { width, trendLineData, mainColor, subheader, startYAxisAtZero, formatNumber, formatTime, fromDatetime, timeRangeFixed, } = this.props;\n        // if can\'t find any non-null values, no point rendering the trendline\n        if (!(trendLineData === null || trendLineData === void 0 ? void 0 : trendLineData.some(d => d.y !== null))) {\n            return null;\n        }\n        // Apply a fixed X range if a time range is specified.\n        //\n        // XYChart checks the existence of `domain` property and decide whether to\n        // apply a domain or not, so it must not be `null` or `undefined`\n        const xScale = { type: \'timeUtc\' };\n        const tooltipData = trendLineData && [...trendLineData];\n        if (tooltipData && timeRangeFixed && fromDatetime) {\n            const toDatetime = (_a = this.props.toDatetime) !== null && _a !== void 0 ? _a : Date.now();\n            if (tooltipData[0].x > fromDatetime) {\n                tooltipData.unshift({\n                    x: fromDatetime,\n                    y: null,\n                });\n            }\n            if (tooltipData[tooltipData.length - 1].x < toDatetime) {\n                tooltipData.push({\n                    x: toDatetime,\n                    y: null,\n                });\n            }\n            xScale.domain = [fromDatetime, toDatetime];\n        }\n        return (react_default.a.createElement(XYChart["a" /* default */], { snapTooltipToDataX: true, ariaLabel: `Big number visualization ${subheader}`, renderTooltip: renderTooltipFactory(formatTime, formatNumber), xScale: xScale, yScale: {\n                type: \'linear\',\n                includeZero: startYAxisAtZero,\n            }, width: Math.floor(width), height: maxHeight, margin: CHART_MARGIN, eventTrigger: "container" },\n            react_default.a.createElement(LinearGradient["a" /* default */], { id: this.gradientId, from: mainColor, to: "#fff" }),\n            react_default.a.createElement(AreaSeries["a" /* default */], { data: tooltipData, fill: `url(#${this.gradientId})`, stroke: mainColor }),\n            react_default.a.createElement(CrossHair["a" /* default */], { fullHeight: true, stroke: mainColor, circleFill: mainColor, circleStroke: "#fff", showHorizontalLine: false, strokeDasharray: "5,2" })));\n    }\n    render() {\n        const { showTrendLine, height, headerFontSize, subheaderFontSize } = this.props;\n        const className = this.getClassName();\n        if (showTrendLine) {\n            const chartHeight = Math.floor(PROPORTION.TRENDLINE * height);\n            const allTextHeight = height - chartHeight;\n            return (react_default.a.createElement("div", { className: className },\n                react_default.a.createElement("div", { className: "text-container", style: { height: allTextHeight } },\n                    this.renderFallbackWarning(),\n                    this.renderHeader(Math.ceil(headerFontSize * (1 - PROPORTION.TRENDLINE) * height)),\n                    this.renderSubheader(Math.ceil(subheaderFontSize * (1 - PROPORTION.TRENDLINE) * height))),\n                this.renderTrendline(chartHeight)));\n        }\n        return (react_default.a.createElement("div", { className: className, style: { height } },\n            this.renderHeader(Math.ceil(headerFontSize * height)),\n            this.renderSubheader(Math.ceil(subheaderFontSize * height))));\n    }\n}\nBigNumber_BigNumberVis.defaultProps = {\n    className: \'\',\n    formatNumber: (num) => String(num),\n    formatTime: smartDateVerbose["a" /* default */].formatFunc,\n    headerFontSize: PROPORTION.HEADER,\n    mainColor: src["BRAND_COLOR"],\n    showTrendLine: false,\n    startYAxisAtZero: true,\n    subheader: \'\',\n    subheaderFontSize: PROPORTION.SUBHEADER,\n    timeRangeFixed: false,\n};\n/* harmony default export */ var BigNumber = __webpack_exports__["default"] = (Object(superset_ui_style_src["a" /* default */])(BigNumber_BigNumberVis) `\n  font-family: ${({ theme }) => theme.typography.families.sansSerif};\n  position: relative;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n\n  &.no-trendline .subheader-line {\n    padding-bottom: 0.3em;\n  }\n\n  .text-container {\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    align-items: flex-start;\n    .alert {\n      font-size: ${({ theme }) => theme.typography.sizes.s};\n      margin: -0.5em 0 0.4em;\n      line-height: 1;\n      padding: 2px 4px 3px;\n      border-radius: 3px;\n    }\n  }\n\n  .header-line {\n    font-weight: ${({ theme }) => theme.typography.weights.normal};\n    position: relative;\n    line-height: 1em;\n    span {\n      position: absolute;\n      bottom: 0;\n    }\n  }\n\n  .subheader-line {\n    font-weight: ${({ theme }) => theme.typography.weights.light};\n    line-height: 1em;\n    padding-bottom: 0;\n  }\n\n  &.is-fallback-value {\n    .header-line,\n    .subheader-line {\n      opacity: 0.5;\n    }\n  }\n\n  .superset-data-ui-tooltip {\n    z-index: 1000;\n    background: #000;\n  }\n`);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjM3Ny5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9zdXBlcnNldC11aS1kaW1lbnNpb24vc3JjL2NvbXB1dGVNYXhGb250U2l6ZS50cz9lMTZkIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9sZWdhY3ktcHJlc2V0LWNoYXJ0LWJpZy1udW1iZXIvc3JjL0JpZ051bWJlci9CaWdOdW1iZXIudHN4PzIwYTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGdldFRleHREaW1lbnNpb24sIHsgR2V0VGV4dERpbWVuc2lvbklucHV0IH0gZnJvbSAnLi9nZXRUZXh0RGltZW5zaW9uJztcbmltcG9ydCB7IERpbWVuc2lvbiB9IGZyb20gJy4vdHlwZXMnO1xuXG5mdW5jdGlvbiBkZWNyZWFzZVNpemVVbnRpbChcbiAgc3RhcnRTaXplOiBudW1iZXIsXG4gIGNvbXB1dGVEaW1lbnNpb246IChzaXplOiBudW1iZXIpID0+IERpbWVuc2lvbixcbiAgY29uZGl0aW9uOiAoZGltZW5zaW9uOiBEaW1lbnNpb24pID0+IGJvb2xlYW4sXG4pOiBudW1iZXIge1xuICBsZXQgc2l6ZSA9IHN0YXJ0U2l6ZTtcbiAgbGV0IGRpbWVuc2lvbiA9IGNvbXB1dGVEaW1lbnNpb24oc2l6ZSk7XG4gIHdoaWxlICghY29uZGl0aW9uKGRpbWVuc2lvbikpIHtcbiAgICBzaXplIC09IDE7XG4gICAgZGltZW5zaW9uID0gY29tcHV0ZURpbWVuc2lvbihzaXplKTtcbiAgfVxuXG4gIHJldHVybiBzaXplO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wdXRlTWF4Rm9udFNpemUoXG4gIGlucHV0OiBHZXRUZXh0RGltZW5zaW9uSW5wdXQgJiB7XG4gICAgbWF4V2lkdGg/OiBudW1iZXI7XG4gICAgbWF4SGVpZ2h0PzogbnVtYmVyO1xuICAgIGlkZWFsRm9udFNpemU/OiBudW1iZXI7XG4gIH0sXG4pIHtcbiAgY29uc3QgeyBpZGVhbEZvbnRTaXplLCBtYXhXaWR0aCwgbWF4SGVpZ2h0LCBzdHlsZSwgLi4ucmVzdCB9ID0gaW5wdXQ7XG5cbiAgbGV0IHNpemU6IG51bWJlcjtcbiAgaWYgKGlkZWFsRm9udFNpemUgIT09IHVuZGVmaW5lZCAmJiBpZGVhbEZvbnRTaXplICE9PSBudWxsKSB7XG4gICAgc2l6ZSA9IGlkZWFsRm9udFNpemU7XG4gIH0gZWxzZSBpZiAobWF4SGVpZ2h0ID09PSB1bmRlZmluZWQgfHwgbWF4SGVpZ2h0ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBzcGVjaWZ5IGF0IGxlYXN0IG9uZSBvZiBtYXhIZWlnaHQgb3IgaWRlYWxGb250U2l6ZScpO1xuICB9IGVsc2Uge1xuICAgIHNpemUgPSBNYXRoLmZsb29yKG1heEhlaWdodCk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wdXRlRGltZW5zaW9uKGZvbnRTaXplOiBudW1iZXIpIHtcbiAgICByZXR1cm4gZ2V0VGV4dERpbWVuc2lvbih7XG4gICAgICAuLi5yZXN0LFxuICAgICAgc3R5bGU6IHsgLi4uc3R5bGUsIGZvbnRTaXplOiBgJHtmb250U2l6ZX1weGAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChtYXhXaWR0aCAhPT0gdW5kZWZpbmVkICYmIG1heFdpZHRoICE9PSBudWxsKSB7XG4gICAgc2l6ZSA9IGRlY3JlYXNlU2l6ZVVudGlsKHNpemUsIGNvbXB1dGVEaW1lbnNpb24sIGRpbSA9PiBkaW0ud2lkdGggPD0gbWF4V2lkdGgpO1xuICB9XG5cbiAgaWYgKG1heEhlaWdodCAhPT0gdW5kZWZpbmVkICYmIG1heEhlaWdodCAhPT0gbnVsbCkge1xuICAgIHNpemUgPSBkZWNyZWFzZVNpemVVbnRpbChzaXplLCBjb21wdXRlRGltZW5zaW9uLCBkaW0gPT4gZGltLmhlaWdodCA8PSBtYXhIZWlnaHQpO1xuICB9XG5cbiAgcmV0dXJuIHNpemU7XG59XG4iLCIvKipcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHNob3J0aWQgZnJvbSAnc2hvcnRpZCc7XG5pbXBvcnQgeyB0IH0gZnJvbSAnQHN1cGVyc2V0LXVpL3RyYW5zbGF0aW9uJztcbmltcG9ydCB7IGdldE51bWJlckZvcm1hdHRlciwgTnVtYmVyRm9ybWF0dGVyIH0gZnJvbSAnQHN1cGVyc2V0LXVpL251bWJlci1mb3JtYXQnO1xuaW1wb3J0IHsgWFlDaGFydCwgQXJlYVNlcmllcywgQ3Jvc3NIYWlyLCBMaW5lYXJHcmFkaWVudCB9IGZyb20gJ0BkYXRhLXVpL3h5LWNoYXJ0JztcbmltcG9ydCB7IEJSQU5EX0NPTE9SIH0gZnJvbSAnQHN1cGVyc2V0LXVpL2NvbG9yJztcbmltcG9ydCB7IGNvbXB1dGVNYXhGb250U2l6ZSB9IGZyb20gJ0BzdXBlcnNldC11aS9kaW1lbnNpb24nO1xuXG5pbXBvcnQgc3R5bGVkIGZyb20gJ0BzdXBlcnNldC11aS9zdHlsZSc7XG5pbXBvcnQgeyBzbWFydERhdGVWZXJib3NlRm9ybWF0dGVyLCBUaW1lRm9ybWF0dGVyIH0gZnJvbSAnQHN1cGVyc2V0LXVpL3RpbWUtZm9ybWF0JztcblxuY29uc3QgZGVmYXVsdE51bWJlckZvcm1hdHRlciA9IGdldE51bWJlckZvcm1hdHRlcigpO1xuXG5jb25zdCBDSEFSVF9NQVJHSU4gPSB7XG4gIHRvcDogNCxcbiAgcmlnaHQ6IDQsXG4gIGJvdHRvbTogNCxcbiAgbGVmdDogNCxcbn07XG5cbmNvbnN0IFBST1BPUlRJT04gPSB7XG4gIC8vIHRleHQgc2l6ZTogcHJvcG9ydGlvbiBvZiB0aGUgY2hhcnQgY29udGFpbmVyIHNhbnMgdHJlbmRsaW5lXG4gIEhFQURFUjogMC4zLFxuICBTVUJIRUFERVI6IDAuMTI1LFxuICAvLyB0cmVuZGxpbmUgc2l6ZTogcHJvcG9ydGlvbiBvZiB0aGUgd2hvbGUgY2hhcnQgY29udGFpbmVyXG4gIFRSRU5ETElORTogMC4zLFxufTtcblxudHlwZSBUaW1lU2VyaWVzRGF0dW0gPSB7XG4gIHg6IG51bWJlcjsgLy8gdGltZXN0YW1wIGFzIGEgbnVtYmVyXG4gIHk6IG51bWJlciB8IG51bGw7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyVG9vbHRpcEZhY3RvcnkoXG4gIGZvcm1hdERhdGUgPSBzbWFydERhdGVWZXJib3NlRm9ybWF0dGVyLFxuICBmb3JtYXRWYWx1ZSA9IGRlZmF1bHROdW1iZXJGb3JtYXR0ZXIsXG4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHJlbmRlclRvb2x0aXAoeyBkYXR1bTogeyB4LCB5IH0gfTogeyBkYXR1bTogVGltZVNlcmllc0RhdHVtIH0pIHtcbiAgICAvLyBldmVuIHRob3VnaCBgZm9ybWF0RGF0ZWAgc3VwcG9ydHMgdGltZXN0YW1wIGFzIG51bWJlcnMsIHdlIG5lZWRcbiAgICAvLyBgbmV3IERhdGVgIHRvIHBhc3MgdHlwZSBjaGVja1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IHN0eWxlPXt7IHBhZGRpbmc6ICc0cHggOHB4JyB9fT5cbiAgICAgICAge2Zvcm1hdERhdGUobmV3IERhdGUoeCkpfVxuICAgICAgICA8YnIgLz5cbiAgICAgICAgPHN0cm9uZz57eSA9PT0gbnVsbCA/IHQoJ04vQScpIDogZm9ybWF0VmFsdWUoeSl9PC9zdHJvbmc+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9O1xufVxuXG50eXBlIEJpZ051bWJlclZpc1Byb3BzID0ge1xuICBjbGFzc05hbWU/OiBzdHJpbmc7XG4gIHdpZHRoOiBudW1iZXI7XG4gIGhlaWdodDogbnVtYmVyO1xuICBiaWdOdW1iZXI/OiBudW1iZXIgfCBudWxsO1xuICBiaWdOdW1iZXJGYWxsYmFjaz86IFRpbWVTZXJpZXNEYXR1bTtcbiAgZm9ybWF0TnVtYmVyOiBOdW1iZXJGb3JtYXR0ZXI7XG4gIGZvcm1hdFRpbWU6IFRpbWVGb3JtYXR0ZXI7XG4gIGZyb21EYXRldGltZT86IG51bWJlcjtcbiAgdG9EYXRldGltZT86IG51bWJlcjtcbiAgaGVhZGVyRm9udFNpemU6IG51bWJlcjtcbiAgc3ViaGVhZGVyOiBzdHJpbmc7XG4gIHN1YmhlYWRlckZvbnRTaXplOiBudW1iZXI7XG4gIHNob3dUcmVuZExpbmU/OiBib29sZWFuO1xuICBzdGFydFlBeGlzQXRaZXJvPzogYm9vbGVhbjtcbiAgdGltZVJhbmdlRml4ZWQ/OiBib29sZWFuO1xuICB0cmVuZExpbmVEYXRhPzogVGltZVNlcmllc0RhdHVtW107XG4gIG1haW5Db2xvcjogc3RyaW5nO1xufTtcblxuY2xhc3MgQmlnTnVtYmVyVmlzIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudDxCaWdOdW1iZXJWaXNQcm9wcywge30+IHtcbiAgcHJpdmF0ZSBncmFkaWVudElkOiBzdHJpbmcgPSBzaG9ydGlkLmdlbmVyYXRlKCk7XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBjbGFzc05hbWU6ICcnLFxuICAgIGZvcm1hdE51bWJlcjogKG51bTogbnVtYmVyKSA9PiBTdHJpbmcobnVtKSxcbiAgICBmb3JtYXRUaW1lOiBzbWFydERhdGVWZXJib3NlRm9ybWF0dGVyLmZvcm1hdEZ1bmMsXG4gICAgaGVhZGVyRm9udFNpemU6IFBST1BPUlRJT04uSEVBREVSLFxuICAgIG1haW5Db2xvcjogQlJBTkRfQ09MT1IsXG4gICAgc2hvd1RyZW5kTGluZTogZmFsc2UsXG4gICAgc3RhcnRZQXhpc0F0WmVybzogdHJ1ZSxcbiAgICBzdWJoZWFkZXI6ICcnLFxuICAgIHN1YmhlYWRlckZvbnRTaXplOiBQUk9QT1JUSU9OLlNVQkhFQURFUixcbiAgICB0aW1lUmFuZ2VGaXhlZDogZmFsc2UsXG4gIH07XG5cbiAgZ2V0Q2xhc3NOYW1lKCkge1xuICAgIGNvbnN0IHsgY2xhc3NOYW1lLCBzaG93VHJlbmRMaW5lLCBiaWdOdW1iZXJGYWxsYmFjayB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBuYW1lcyA9IGBzdXBlcnNldC1sZWdhY3ktY2hhcnQtYmlnLW51bWJlciAke2NsYXNzTmFtZX0gJHtcbiAgICAgIGJpZ051bWJlckZhbGxiYWNrID8gJ2lzLWZhbGxiYWNrLXZhbHVlJyA6ICcnXG4gICAgfWA7XG4gICAgaWYgKHNob3dUcmVuZExpbmUpIHJldHVybiBuYW1lcztcbiAgICByZXR1cm4gYCR7bmFtZXN9IG5vLXRyZW5kbGluZWA7XG4gIH1cblxuICBjcmVhdGVUZW1wb3JhcnlDb250YWluZXIoKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGFpbmVyLmNsYXNzTmFtZSA9IHRoaXMuZ2V0Q2xhc3NOYW1lKCk7XG4gICAgY29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJzsgLy8gc28gaXQgd29uJ3QgZGlzcnVwdCBwYWdlIGxheW91dFxuICAgIGNvbnRhaW5lci5zdHlsZS5vcGFjaXR5ID0gJzAnOyAvLyBhbmQgbm90IHZpc2libGVcbiAgICByZXR1cm4gY29udGFpbmVyO1xuICB9XG5cbiAgcmVuZGVyRmFsbGJhY2tXYXJuaW5nKCkge1xuICAgIGNvbnN0IHsgYmlnTnVtYmVyRmFsbGJhY2ssIGZvcm1hdFRpbWUgfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKCFiaWdOdW1iZXJGYWxsYmFjaykgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIChcbiAgICAgIDxzcGFuXG4gICAgICAgIGNsYXNzTmFtZT1cImFsZXJ0IGFsZXJ0LXdhcm5pbmdcIlxuICAgICAgICByb2xlPVwiYWxlcnRcIlxuICAgICAgICB0aXRsZT17dChgTGFzdCBhdmFpbGFibGUgdmFsdWUgc2VlbiBvbiAlc2AsIGZvcm1hdFRpbWUoYmlnTnVtYmVyRmFsbGJhY2sueCkpfVxuICAgICAgPlxuICAgICAgICB7dCgnTm90IHVwIHRvIGRhdGUnKX1cbiAgICAgIDwvc3Bhbj5cbiAgICApO1xuICB9XG5cbiAgcmVuZGVySGVhZGVyKG1heEhlaWdodDogbnVtYmVyKSB7XG4gICAgY29uc3QgeyBiaWdOdW1iZXIsIGZvcm1hdE51bWJlciwgd2lkdGggfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgdGV4dCA9IGJpZ051bWJlciA9PT0gbnVsbCA/IHQoJ05vIGRhdGEnKSA6IGZvcm1hdE51bWJlcihiaWdOdW1iZXIpO1xuXG4gICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jcmVhdGVUZW1wb3JhcnlDb250YWluZXIoKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZChjb250YWluZXIpO1xuICAgIGNvbnN0IGZvbnRTaXplID0gY29tcHV0ZU1heEZvbnRTaXplKHtcbiAgICAgIHRleHQsXG4gICAgICBtYXhXaWR0aDogd2lkdGgsXG4gICAgICBtYXhIZWlnaHQsXG4gICAgICBjbGFzc05hbWU6ICdoZWFkZXItbGluZScsXG4gICAgICBjb250YWluZXIsXG4gICAgfSk7XG4gICAgY29udGFpbmVyLnJlbW92ZSgpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXZcbiAgICAgICAgY2xhc3NOYW1lPVwiaGVhZGVyLWxpbmVcIlxuICAgICAgICBzdHlsZT17e1xuICAgICAgICAgIGZvbnRTaXplLFxuICAgICAgICAgIGhlaWdodDogbWF4SGVpZ2h0LFxuICAgICAgICB9fVxuICAgICAgPlxuICAgICAgICB7dGV4dH1cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICByZW5kZXJTdWJoZWFkZXIobWF4SGVpZ2h0OiBudW1iZXIpIHtcbiAgICBjb25zdCB7IGJpZ051bWJlciwgc3ViaGVhZGVyLCB3aWR0aCwgYmlnTnVtYmVyRmFsbGJhY2sgfSA9IHRoaXMucHJvcHM7XG4gICAgbGV0IGZvbnRTaXplID0gMDtcblxuICAgIGNvbnN0IE5PX0RBVEFfT1JfSEFTTlRfTEFOREVEID0gdChcbiAgICAgICdObyBkYXRhIGFmdGVyIGZpbHRlcmluZyBvciBkYXRhIGlzIE5VTEwgZm9yIHRoZSBsYXRlc3QgdGltZSByZWNvcmQnLFxuICAgICk7XG4gICAgY29uc3QgTk9fREFUQSA9IHQoJ1RyeSBhcHBseWluZyBkaWZmZXJlbnQgZmlsdGVycyBvciBlbnN1cmluZyB5b3VyIGRhdGFzb3VyY2UgaGFzIGRhdGEnKTtcbiAgICBsZXQgdGV4dCA9IHN1YmhlYWRlcjtcbiAgICBpZiAoYmlnTnVtYmVyID09PSBudWxsKSB7XG4gICAgICB0ZXh0ID0gYmlnTnVtYmVyRmFsbGJhY2sgPyBOT19EQVRBIDogTk9fREFUQV9PUl9IQVNOVF9MQU5ERUQ7XG4gICAgfVxuICAgIGlmICh0ZXh0KSB7XG4gICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNyZWF0ZVRlbXBvcmFyeUNvbnRhaW5lcigpO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmQoY29udGFpbmVyKTtcbiAgICAgIGZvbnRTaXplID0gY29tcHV0ZU1heEZvbnRTaXplKHtcbiAgICAgICAgdGV4dCxcbiAgICAgICAgbWF4V2lkdGg6IHdpZHRoLFxuICAgICAgICBtYXhIZWlnaHQsXG4gICAgICAgIGNsYXNzTmFtZTogJ3N1YmhlYWRlci1saW5lJyxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgfSk7XG4gICAgICBjb250YWluZXIucmVtb3ZlKCk7XG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxkaXZcbiAgICAgICAgICBjbGFzc05hbWU9XCJzdWJoZWFkZXItbGluZVwiXG4gICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgIGZvbnRTaXplLFxuICAgICAgICAgICAgaGVpZ2h0OiBtYXhIZWlnaHQsXG4gICAgICAgICAgfX1cbiAgICAgICAgPlxuICAgICAgICAgIHt0ZXh0fVxuICAgICAgICA8L2Rpdj5cbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmVuZGVyVHJlbmRsaW5lKG1heEhlaWdodDogbnVtYmVyKSB7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICB0cmVuZExpbmVEYXRhLFxuICAgICAgbWFpbkNvbG9yLFxuICAgICAgc3ViaGVhZGVyLFxuICAgICAgc3RhcnRZQXhpc0F0WmVybyxcbiAgICAgIGZvcm1hdE51bWJlcixcbiAgICAgIGZvcm1hdFRpbWUsXG4gICAgICBmcm9tRGF0ZXRpbWUsXG4gICAgICB0aW1lUmFuZ2VGaXhlZCxcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIC8vIGlmIGNhbid0IGZpbmQgYW55IG5vbi1udWxsIHZhbHVlcywgbm8gcG9pbnQgcmVuZGVyaW5nIHRoZSB0cmVuZGxpbmVcbiAgICBpZiAoIXRyZW5kTGluZURhdGE/LnNvbWUoZCA9PiBkLnkgIT09IG51bGwpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBBcHBseSBhIGZpeGVkIFggcmFuZ2UgaWYgYSB0aW1lIHJhbmdlIGlzIHNwZWNpZmllZC5cbiAgICAvL1xuICAgIC8vIFhZQ2hhcnQgY2hlY2tzIHRoZSBleGlzdGVuY2Ugb2YgYGRvbWFpbmAgcHJvcGVydHkgYW5kIGRlY2lkZSB3aGV0aGVyIHRvXG4gICAgLy8gYXBwbHkgYSBkb21haW4gb3Igbm90LCBzbyBpdCBtdXN0IG5vdCBiZSBgbnVsbGAgb3IgYHVuZGVmaW5lZGBcbiAgICBjb25zdCB4U2NhbGU6IHsgdHlwZTogc3RyaW5nOyBkb21haW4/OiBudW1iZXJbXSB9ID0geyB0eXBlOiAndGltZVV0YycgfTtcbiAgICBjb25zdCB0b29sdGlwRGF0YSA9IHRyZW5kTGluZURhdGEgJiYgWy4uLnRyZW5kTGluZURhdGFdO1xuICAgIGlmICh0b29sdGlwRGF0YSAmJiB0aW1lUmFuZ2VGaXhlZCAmJiBmcm9tRGF0ZXRpbWUpIHtcbiAgICAgIGNvbnN0IHRvRGF0ZXRpbWUgPSB0aGlzLnByb3BzLnRvRGF0ZXRpbWUgPz8gRGF0ZS5ub3coKTtcbiAgICAgIGlmICh0b29sdGlwRGF0YVswXS54ID4gZnJvbURhdGV0aW1lKSB7XG4gICAgICAgIHRvb2x0aXBEYXRhLnVuc2hpZnQoe1xuICAgICAgICAgIHg6IGZyb21EYXRldGltZSxcbiAgICAgICAgICB5OiBudWxsLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICh0b29sdGlwRGF0YVt0b29sdGlwRGF0YS5sZW5ndGggLSAxXS54IDwgdG9EYXRldGltZSkge1xuICAgICAgICB0b29sdGlwRGF0YS5wdXNoKHtcbiAgICAgICAgICB4OiB0b0RhdGV0aW1lLFxuICAgICAgICAgIHk6IG51bGwsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgeFNjYWxlLmRvbWFpbiA9IFtmcm9tRGF0ZXRpbWUsIHRvRGF0ZXRpbWVdO1xuICAgIH1cbiAgICByZXR1cm4gKFxuICAgICAgPFhZQ2hhcnRcbiAgICAgICAgc25hcFRvb2x0aXBUb0RhdGFYXG4gICAgICAgIGFyaWFMYWJlbD17YEJpZyBudW1iZXIgdmlzdWFsaXphdGlvbiAke3N1YmhlYWRlcn1gfVxuICAgICAgICByZW5kZXJUb29sdGlwPXtyZW5kZXJUb29sdGlwRmFjdG9yeShmb3JtYXRUaW1lLCBmb3JtYXROdW1iZXIpfVxuICAgICAgICB4U2NhbGU9e3hTY2FsZX1cbiAgICAgICAgeVNjYWxlPXt7XG4gICAgICAgICAgdHlwZTogJ2xpbmVhcicsXG4gICAgICAgICAgaW5jbHVkZVplcm86IHN0YXJ0WUF4aXNBdFplcm8sXG4gICAgICAgIH19XG4gICAgICAgIHdpZHRoPXtNYXRoLmZsb29yKHdpZHRoKX1cbiAgICAgICAgaGVpZ2h0PXttYXhIZWlnaHR9XG4gICAgICAgIG1hcmdpbj17Q0hBUlRfTUFSR0lOfVxuICAgICAgICBldmVudFRyaWdnZXI9XCJjb250YWluZXJcIlxuICAgICAgPlxuICAgICAgICA8TGluZWFyR3JhZGllbnQgaWQ9e3RoaXMuZ3JhZGllbnRJZH0gZnJvbT17bWFpbkNvbG9yfSB0bz1cIiNmZmZcIiAvPlxuICAgICAgICA8QXJlYVNlcmllcyBkYXRhPXt0b29sdGlwRGF0YX0gZmlsbD17YHVybCgjJHt0aGlzLmdyYWRpZW50SWR9KWB9IHN0cm9rZT17bWFpbkNvbG9yfSAvPlxuICAgICAgICA8Q3Jvc3NIYWlyXG4gICAgICAgICAgZnVsbEhlaWdodFxuICAgICAgICAgIHN0cm9rZT17bWFpbkNvbG9yfVxuICAgICAgICAgIGNpcmNsZUZpbGw9e21haW5Db2xvcn1cbiAgICAgICAgICBjaXJjbGVTdHJva2U9XCIjZmZmXCJcbiAgICAgICAgICBzaG93SG9yaXpvbnRhbExpbmU9e2ZhbHNlfVxuICAgICAgICAgIHN0cm9rZURhc2hhcnJheT1cIjUsMlwiXG4gICAgICAgIC8+XG4gICAgICA8L1hZQ2hhcnQ+XG4gICAgKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IHNob3dUcmVuZExpbmUsIGhlaWdodCwgaGVhZGVyRm9udFNpemUsIHN1YmhlYWRlckZvbnRTaXplIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGNsYXNzTmFtZSA9IHRoaXMuZ2V0Q2xhc3NOYW1lKCk7XG5cbiAgICBpZiAoc2hvd1RyZW5kTGluZSkge1xuICAgICAgY29uc3QgY2hhcnRIZWlnaHQgPSBNYXRoLmZsb29yKFBST1BPUlRJT04uVFJFTkRMSU5FICogaGVpZ2h0KTtcbiAgICAgIGNvbnN0IGFsbFRleHRIZWlnaHQgPSBoZWlnaHQgLSBjaGFydEhlaWdodDtcblxuICAgICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e2NsYXNzTmFtZX0+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LWNvbnRhaW5lclwiIHN0eWxlPXt7IGhlaWdodDogYWxsVGV4dEhlaWdodCB9fT5cbiAgICAgICAgICAgIHt0aGlzLnJlbmRlckZhbGxiYWNrV2FybmluZygpfVxuICAgICAgICAgICAge3RoaXMucmVuZGVySGVhZGVyKE1hdGguY2VpbChoZWFkZXJGb250U2l6ZSAqICgxIC0gUFJPUE9SVElPTi5UUkVORExJTkUpICogaGVpZ2h0KSl9XG4gICAgICAgICAgICB7dGhpcy5yZW5kZXJTdWJoZWFkZXIoXG4gICAgICAgICAgICAgIE1hdGguY2VpbChzdWJoZWFkZXJGb250U2l6ZSAqICgxIC0gUFJPUE9SVElPTi5UUkVORExJTkUpICogaGVpZ2h0KSxcbiAgICAgICAgICAgICl9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAge3RoaXMucmVuZGVyVHJlbmRsaW5lKGNoYXJ0SGVpZ2h0KX1cbiAgICAgICAgPC9kaXY+XG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3NOYW1lfSBzdHlsZT17eyBoZWlnaHQgfX0+XG4gICAgICAgIHt0aGlzLnJlbmRlckhlYWRlcihNYXRoLmNlaWwoaGVhZGVyRm9udFNpemUgKiBoZWlnaHQpKX1cbiAgICAgICAge3RoaXMucmVuZGVyU3ViaGVhZGVyKE1hdGguY2VpbChzdWJoZWFkZXJGb250U2l6ZSAqIGhlaWdodCkpfVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBzdHlsZWQoQmlnTnVtYmVyVmlzKWBcbiAgZm9udC1mYW1pbHk6ICR7KHsgdGhlbWUgfSkgPT4gdGhlbWUudHlwb2dyYXBoeS5mYW1pbGllcy5zYW5zU2VyaWZ9O1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuXG4gICYubm8tdHJlbmRsaW5lIC5zdWJoZWFkZXItbGluZSB7XG4gICAgcGFkZGluZy1ib3R0b206IDAuM2VtO1xuICB9XG5cbiAgLnRleHQtY29udGFpbmVyIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgYWxpZ24taXRlbXM6IGZsZXgtc3RhcnQ7XG4gICAgLmFsZXJ0IHtcbiAgICAgIGZvbnQtc2l6ZTogJHsoeyB0aGVtZSB9KSA9PiB0aGVtZS50eXBvZ3JhcGh5LnNpemVzLnN9O1xuICAgICAgbWFyZ2luOiAtMC41ZW0gMCAwLjRlbTtcbiAgICAgIGxpbmUtaGVpZ2h0OiAxO1xuICAgICAgcGFkZGluZzogMnB4IDRweCAzcHg7XG4gICAgICBib3JkZXItcmFkaXVzOiAzcHg7XG4gICAgfVxuICB9XG5cbiAgLmhlYWRlci1saW5lIHtcbiAgICBmb250LXdlaWdodDogJHsoeyB0aGVtZSB9KSA9PiB0aGVtZS50eXBvZ3JhcGh5LndlaWdodHMubm9ybWFsfTtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgbGluZS1oZWlnaHQ6IDFlbTtcbiAgICBzcGFuIHtcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIGJvdHRvbTogMDtcbiAgICB9XG4gIH1cblxuICAuc3ViaGVhZGVyLWxpbmUge1xuICAgIGZvbnQtd2VpZ2h0OiAkeyh7IHRoZW1lIH0pID0+IHRoZW1lLnR5cG9ncmFwaHkud2VpZ2h0cy5saWdodH07XG4gICAgbGluZS1oZWlnaHQ6IDFlbTtcbiAgICBwYWRkaW5nLWJvdHRvbTogMDtcbiAgfVxuXG4gICYuaXMtZmFsbGJhY2stdmFsdWUge1xuICAgIC5oZWFkZXItbGluZSxcbiAgICAuc3ViaGVhZGVyLWxpbmUge1xuICAgICAgb3BhY2l0eTogMC41O1xuICAgIH1cbiAgfVxuXG4gIC5zdXBlcnNldC1kYXRhLXVpLXRvb2x0aXAge1xuICAgIHotaW5kZXg6IDEwMDA7XG4gICAgYmFja2dyb3VuZDogIzAwMDtcbiAgfVxuYDtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUdBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBT0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7Ozs7Ozs7OztBQ3BEQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFzQkE7QUFBQTs7QUFDQTtBQW1OQTtBQXBNQTtBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQVNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFVQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUdBO0FBRUE7QUFFQTtBQUNBO0FBR0E7O0FBaE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXdNQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBOzs7Ozs7Ozs7QUFTQTs7Ozs7Ozs7OztBQVVBOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2377\n')}}]);