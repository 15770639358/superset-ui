(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{2316:function(module,exports,__webpack_require__){eval("var api = __webpack_require__(351);\n            var content = __webpack_require__(2317);\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.i, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\nvar exported = content.locals ? content.locals : {};\n\n\n\nmodule.exports = exported;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMxNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9sZWdhY3ktcGx1Z2luLWNoYXJ0LXBhcmFsbGVsLWNvb3JkaW5hdGVzL3NyYy92ZW5kb3IvcGFyY29vcmRzL2QzLnBhcmNvb3Jkcy5jc3M/ODcwMSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXBpID0gcmVxdWlyZShcIiEuLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9zdXBlcnNldC11aS1kZW1vL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvc3VwZXJzZXQtdWktZGVtby9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS02LTEhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cG9zdGNzcyEuL2QzLnBhcmNvb3Jkcy5jc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBcImhlYWRcIjtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cbnZhciBleHBvcnRlZCA9IGNvbnRlbnQubG9jYWxzID8gY29udGVudC5sb2NhbHMgOiB7fTtcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0ZWQ7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2316\n")},2317:function(module,exports,__webpack_require__){eval('// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(352);\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, "/* [LICENSE TBD] */\\n.parcoords svg,\\n.parcoords canvas {\\n  font-size: 12px;\\n  position: absolute;\\n}\\n.parcoords > canvas {\\n  pointer-events: none;\\n}\\n\\n.parcoords text.label {\\n  font: 100%;\\n  font-size: 12px;\\n  cursor: drag;\\n}\\n\\n.parcoords rect.background {\\n  fill: transparent;\\n}\\n.parcoords rect.background:hover {\\n  fill: rgba(120, 120, 120, 0.2);\\n}\\n.parcoords .resize rect {\\n  fill: rgba(0, 0, 0, 0.1);\\n}\\n.parcoords rect.extent {\\n  fill: rgba(255, 255, 255, 0.25);\\n  stroke: rgba(0, 0, 0, 0.6);\\n}\\n.parcoords .axis line,\\n.parcoords .axis path {\\n  fill: none;\\n  stroke: #222;\\n  shape-rendering: crispEdges;\\n}\\n.parcoords canvas {\\n  opacity: 1;\\n  -moz-transition: opacity 0.3s;\\n  -webkit-transition: opacity 0.3s;\\n  -o-transition: opacity 0.3s;\\n}\\n.parcoords canvas.faded {\\n  opacity: 0.25;\\n}\\n.parcoords {\\n  -webkit-touch-callout: none;\\n  -webkit-user-select: none;\\n  user-select: none;\\n  background-color: white;\\n}\\n\\n/* data table styles */\\n.parcoords .row,\\n.parcoords .header {\\n  clear: left;\\n  font-size: 12px;\\n  line-height: 18px;\\n  height: 18px;\\n  margin: 0px;\\n}\\n.parcoords .row:nth-child(odd) {\\n  background: rgba(0, 0, 0, 0.05);\\n}\\n.parcoords .header {\\n  font-weight: bold;\\n}\\n.parcoords .cell {\\n  float: left;\\n  overflow: hidden;\\n  white-space: nowrap;\\n  width: 100px;\\n  height: 18px;\\n}\\n.parcoords .col-0 {\\n  width: 180px;\\n}\\n", ""]);\n// Exports\nmodule.exports = exports;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMxNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9sZWdhY3ktcGx1Z2luLWNoYXJ0LXBhcmFsbGVsLWNvb3JkaW5hdGVzL3NyYy92ZW5kb3IvcGFyY29vcmRzL2QzLnBhcmNvb3Jkcy5jc3M/OWRjOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL3N1cGVyc2V0LXVpLWRlbW8vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiKTtcbmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIvKiBbTElDRU5TRSBUQkRdICovXFxuLnBhcmNvb3JkcyBzdmcsXFxuLnBhcmNvb3JkcyBjYW52YXMge1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbn1cXG4ucGFyY29vcmRzID4gY2FudmFzIHtcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbn1cXG5cXG4ucGFyY29vcmRzIHRleHQubGFiZWwge1xcbiAgZm9udDogMTAwJTtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIGN1cnNvcjogZHJhZztcXG59XFxuXFxuLnBhcmNvb3JkcyByZWN0LmJhY2tncm91bmQge1xcbiAgZmlsbDogdHJhbnNwYXJlbnQ7XFxufVxcbi5wYXJjb29yZHMgcmVjdC5iYWNrZ3JvdW5kOmhvdmVyIHtcXG4gIGZpbGw6IHJnYmEoMTIwLCAxMjAsIDEyMCwgMC4yKTtcXG59XFxuLnBhcmNvb3JkcyAucmVzaXplIHJlY3Qge1xcbiAgZmlsbDogcmdiYSgwLCAwLCAwLCAwLjEpO1xcbn1cXG4ucGFyY29vcmRzIHJlY3QuZXh0ZW50IHtcXG4gIGZpbGw6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yNSk7XFxuICBzdHJva2U6IHJnYmEoMCwgMCwgMCwgMC42KTtcXG59XFxuLnBhcmNvb3JkcyAuYXhpcyBsaW5lLFxcbi5wYXJjb29yZHMgLmF4aXMgcGF0aCB7XFxuICBmaWxsOiBub25lO1xcbiAgc3Ryb2tlOiAjMjIyO1xcbiAgc2hhcGUtcmVuZGVyaW5nOiBjcmlzcEVkZ2VzO1xcbn1cXG4ucGFyY29vcmRzIGNhbnZhcyB7XFxuICBvcGFjaXR5OiAxO1xcbiAgLW1vei10cmFuc2l0aW9uOiBvcGFjaXR5IDAuM3M7XFxuICAtd2Via2l0LXRyYW5zaXRpb246IG9wYWNpdHkgMC4zcztcXG4gIC1vLXRyYW5zaXRpb246IG9wYWNpdHkgMC4zcztcXG59XFxuLnBhcmNvb3JkcyBjYW52YXMuZmFkZWQge1xcbiAgb3BhY2l0eTogMC4yNTtcXG59XFxuLnBhcmNvb3JkcyB7XFxuICAtd2Via2l0LXRvdWNoLWNhbGxvdXQ6IG5vbmU7XFxuICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcbiAgdXNlci1zZWxlY3Q6IG5vbmU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcXG59XFxuXFxuLyogZGF0YSB0YWJsZSBzdHlsZXMgKi9cXG4ucGFyY29vcmRzIC5yb3csXFxuLnBhcmNvb3JkcyAuaGVhZGVyIHtcXG4gIGNsZWFyOiBsZWZ0O1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgbGluZS1oZWlnaHQ6IDE4cHg7XFxuICBoZWlnaHQ6IDE4cHg7XFxuICBtYXJnaW46IDBweDtcXG59XFxuLnBhcmNvb3JkcyAucm93Om50aC1jaGlsZChvZGQpIHtcXG4gIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC4wNSk7XFxufVxcbi5wYXJjb29yZHMgLmhlYWRlciB7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG59XFxuLnBhcmNvb3JkcyAuY2VsbCB7XFxuICBmbG9hdDogbGVmdDtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbiAgd2lkdGg6IDEwMHB4O1xcbiAgaGVpZ2h0OiAxOHB4O1xcbn1cXG4ucGFyY29vcmRzIC5jb2wtMCB7XFxuICB3aWR0aDogMTgwcHg7XFxufVxcblwiLCBcIlwiXSk7XG4vLyBFeHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHM7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2317\n')},2509:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react/index.js\nvar react = __webpack_require__(0);\nvar react_default = /*#__PURE__*/__webpack_require__.n(react);\n\n// EXTERNAL MODULE: ../superset-ui-core/src/chart/components/reactify.tsx\nvar reactify = __webpack_require__(1015);\n\n// EXTERNAL MODULE: ../superset-ui-core/src/style/index.ts\nvar style = __webpack_require__(435);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/prop-types/index.js\nvar prop_types = __webpack_require__(57);\nvar prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3/d3.js\nvar d3_d3 = __webpack_require__(154);\nvar d3_default = /*#__PURE__*/__webpack_require__.n(d3_d3);\n\n// EXTERNAL MODULE: ../superset-ui-core/src/color/SequentialSchemeRegistrySingleton.ts\nvar SequentialSchemeRegistrySingleton = __webpack_require__(576);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/core-js/modules/web.dom-collections.iterator.js\nvar web_dom_collections_iterator = __webpack_require__(53);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/d3.parcoords.js\n/* [LICENSE TBD] */ /* eslint-disable *//* harmony default export */ var d3_parcoords = (function(config){var __={data:[],highlighted:[],dimensions:[],dimensionTitles:{},dimensionTitleRotation:0,types:{},brushed:!1,brushedColor:null,alphaOnBrushed:0,mode:"default",rate:20,width:600,height:300,margin:{top:24,right:0,bottom:12,left:0},nullValueSeparator:"undefined",// set to "top" or "bottom"\nnullValueSeparatorPadding:{top:8,right:0,bottom:8,left:0},color:"#069",composite:"source-over",alpha:.7,bundlingStrength:.5,bundleDimension:null,smoothness:0,showControlPoints:!1,hideAxis:[]};(function(target,source){for(var key in source){target[key]=source[key]}return target})(__,config);var pc=function(selection){selection=pc.selection=d3.select(selection);__.width=selection[0][0].clientWidth;__.height=selection[0][0].clientHeight;// canvas data layers\n["marks","foreground","brushed","highlight"].forEach(function(layer){canvas[layer]=selection.append("canvas").attr("class",layer)[0][0];ctx[layer]=canvas[layer].getContext("2d")});// svg tick and brush layers\npc.svg=selection.append("svg").attr("width",__.width).attr("height",__.height).append("svg:g").attr("transform","translate("+__.margin.left+","+__.margin.top+")");return pc},events=d3.dispatch.apply(this,["render","resize","highlight","brush","brushend","axesreorder"].concat(d3.keys(__))),w=function(){return __.width-__.margin.right-__.margin.left},h=function(){return __.height-__.margin.top-__.margin.bottom},flags={brushable:!1,reorderable:!1,axes:!1,interactive:!1,debug:!1},xscale=d3.scale.ordinal(),yscale={},dragging={},line=d3.svg.line(),axis=d3.svg.axis().orient("left").ticks(5),g,// groups for axes, brushes\nctx={},canvas={},side_effects=d3.dispatch.apply(this,d3.keys(__)).on("composite",function(d){ctx.foreground.globalCompositeOperation=d.value;ctx.brushed.globalCompositeOperation=d.value}).on("alpha",function(d){ctx.foreground.globalAlpha=d.value;ctx.brushed.globalAlpha=d.value}).on("brushedColor",function(d){ctx.brushed.strokeStyle=d.value}).on("width",function(){pc.resize()}).on("height",function(){pc.resize()}).on("margin",function(){pc.resize()}).on("rate",function(d){brushedQueue.rate(d.value);foregroundQueue.rate(d.value)}).on("dimensions",function(){xscale.domain(__.dimensions);if(flags.interactive){pc.render().updateAxes()}}).on("bundleDimension",function(d){if(!__.dimensions.length)pc.detectDimensions();if(!(__.dimensions[0]in yscale))pc.autoscale();if("number"==typeof d.value){if(d.value<__.dimensions.length){__.bundleDimension=__.dimensions[d.value]}else if(d.value<__.hideAxis.length){__.bundleDimension=__.hideAxis[d.value]}}else{__.bundleDimension=d.value}__.clusterCentroids=compute_cluster_centroids(__.bundleDimension)}).on("hideAxis",function(d){if(!__.dimensions.length)pc.detectDimensions();pc.dimensions(without(__.dimensions,d.value))});// expose the state of the chart\npc.state=__;pc.flags=flags;// create getter/setters\n(// getter/setter with event firing\nfunction(obj,state,events){d3.keys(state).forEach(function(key){obj[key]=function(x){if(!arguments.length){return state[key]}var old=state[key];state[key]=x;side_effects[key].call(pc,{value:x,previous:old});events[key].call(pc,{value:x,previous:old});return obj}})})(pc,__,events);// expose events\nd3.rebind(pc,events,"on");function without(arr,item){return arr.filter(function(elem){return-1===item.indexOf(elem)})}/** adjusts an axis\' default range [h()+1, 1] if a NullValueSeparator is set */function getRange(){if("bottom"==__.nullValueSeparator){return[h()+1-__.nullValueSeparatorPadding.bottom-__.nullValueSeparatorPadding.top,1]}else if("top"==__.nullValueSeparator){return[h()+1,1+__.nullValueSeparatorPadding.bottom+__.nullValueSeparatorPadding.top]}return[h()+1,1]}pc.autoscale=function(){// yscale\nvar defaultScales={date:function(k){var extent=d3.extent(__.data,function(d){return d[k]?d[k].getTime():null});// special case if single value\nif(extent[0]===extent[1]){return d3.scale.ordinal().domain([extent[0]]).rangePoints(getRange())}return d3.time.scale().domain(extent).range(getRange())},number:function(k){var extent=d3.extent(__.data,function(d){return+d[k]});// special case if single value\nif(extent[0]===extent[1]){return d3.scale.ordinal().domain([extent[0]]).rangePoints(getRange())}return d3.scale.linear().domain(extent).range(getRange())},string:function(k){var counts={},domain=[];// Let\'s get the count for each value so that we can sort the domain based\n// on the number of items for each value.\n__.data.map(function(p){if(p[k]===void 0&&"undefined"!==__.nullValueSeparator){return;// null values will be drawn beyond the horizontal null value separator!\n}if(counts[p[k]]===void 0){counts[p[k]]=1}else{counts[p[k]]=counts[p[k]]+1}});domain=Object.getOwnPropertyNames(counts).sort(function(a,b){return counts[a]-counts[b]});return d3.scale.ordinal().domain(domain).rangePoints(getRange())}};__.dimensions.forEach(function(k){yscale[k]=defaultScales[__.types[k]](k)});__.hideAxis.forEach(function(k){yscale[k]=defaultScales[__.types[k]](k)});// xscale\nxscale.rangePoints([0,w()],1);// canvas sizes\npc.selection.selectAll("canvas").style("margin-top",__.margin.top+"px").style("margin-left",__.margin.left+"px").attr("width",w()+2).attr("height",h()+2);// default styles, needs to be set when canvas width changes\nctx.foreground.strokeStyle=__.color;ctx.foreground.lineWidth=1.4;ctx.foreground.globalCompositeOperation=__.composite;ctx.foreground.globalAlpha=__.alpha;ctx.brushed.strokeStyle=__.brushedColor;ctx.brushed.lineWidth=1.4;ctx.brushed.globalCompositeOperation=__.composite;ctx.brushed.globalAlpha=__.alpha;ctx.highlight.lineWidth=3;return this};pc.scale=function(d,domain){yscale[d].domain(domain);return this};pc.flip=function(d){//yscale[d].domain().reverse();         // does not work\nyscale[d].domain(yscale[d].domain().reverse());// works\nreturn this};pc.commonScale=function(global,type){if("undefined"==typeof global){global=!0}// scales of the same type\nvar scales=__.dimensions.concat(__.hideAxis).filter(function(p){return __.types[p]==(type||"number")});if(global){var extent=d3.extent(scales.map(function(p){return yscale[p].domain()}).reduce(function(a,b){return a.concat(b)}));scales.forEach(function(d){yscale[d].domain(extent)})}else{scales.forEach(function(k){yscale[k].domain(d3.extent(__.data,function(d){return+d[k]}))})}// update centroids\nif(null!==__.bundleDimension){pc.bundleDimension(__.bundleDimension)}return this};pc.detectDimensions=function(){pc.types(pc.detectDimensionTypes(__.data));pc.dimensions(d3.keys(pc.types()));return this};// a better "typeof" from this post: http://stackoverflow.com/questions/7390426/better-way-to-get-type-of-a-javascript-variable\npc.toType=function(v){return{}.toString.call(v).match(/\\s([a-zA-Z]+)/)[1].toLowerCase()};// try to coerce to number before returning type\npc.toTypeCoerceNumbers=function(v){if(parseFloat(v)==v&&null!=v){return"number"}return pc.toType(v)};// attempt to determine types of each dimension based on first row of data\npc.detectDimensionTypes=function(data){var types={};d3.keys(data[0]).forEach(function(col){types[col]=pc.toTypeCoerceNumbers(data[0][col])});return types};pc.render=function(){// try to autodetect dimensions and create scales\nif(!__.dimensions.length)pc.detectDimensions();if(!(__.dimensions[0]in yscale))pc.autoscale();pc.render[__.mode]();events.render.call(this);return this};pc.renderBrushed=function(){if(!__.dimensions.length)pc.detectDimensions();if(!(__.dimensions[0]in yscale))pc.autoscale();pc.renderBrushed[__.mode]();events.render.call(this);return this};function isBrushed(){if(__.brushed&&__.brushed.length!==__.data.length)return!0;var object=brush.currentMode().brushState();for(var key in object){if(object.hasOwnProperty(key)){return!0}}return!1}pc.render.default=function(){pc.clear("foreground");pc.clear("highlight");pc.renderBrushed.default();__.data.forEach(path_foreground)};var foregroundQueue=d3.renderQueue(path_foreground).rate(50).clear(function(){pc.clear("foreground");pc.clear("highlight")});pc.render.queue=function(){pc.renderBrushed.queue();foregroundQueue(__.data)};pc.renderBrushed.default=function(){pc.clear("brushed");if(isBrushed()){__.brushed.forEach(path_brushed)}};var brushedQueue=d3.renderQueue(path_brushed).rate(50).clear(function(){pc.clear("brushed")});pc.renderBrushed.queue=function(){if(isBrushed()){brushedQueue(__.brushed)}else{brushedQueue([]);// This is needed to clear the currently brushed items\n}};function compute_cluster_centroids(d){var clusterCentroids=d3.map(),clusterCounts=d3.map();// determine clusterCounts\n__.data.forEach(function(row){var scaled=yscale[d](row[d]);if(!clusterCounts.has(scaled)){clusterCounts.set(scaled,0)}var count=clusterCounts.get(scaled);clusterCounts.set(scaled,count+1)});__.data.forEach(function(row){__.dimensions.map(function(p){var scaled=yscale[d](row[d]);if(!clusterCentroids.has(scaled)){var map=d3.map();clusterCentroids.set(scaled,map)}if(!clusterCentroids.get(scaled).has(p)){clusterCentroids.get(scaled).set(p,0)}var value=clusterCentroids.get(scaled).get(p);value+=yscale[p](row[p])/clusterCounts.get(scaled);clusterCentroids.get(scaled).set(p,value)})});return clusterCentroids}function compute_centroids(row){// center between axes\nfor(var centroids=[],p=__.dimensions,cols=p.length,a=.5,i=0;i<cols;++i){// centroids on \'real\' axes\nvar x=position(p[i]),y=yscale[p[i]](row[p[i]]);centroids.push($V([x,y]));// centroids on \'virtual\' axes\nif(i<cols-1){var cx=x+a*(position(p[i+1])-x),cy=y+a*(yscale[p[i+1]](row[p[i+1]])-y);if(null!==__.bundleDimension){var leftCentroid=__.clusterCentroids.get(yscale[__.bundleDimension](row[__.bundleDimension])).get(p[i]),rightCentroid=__.clusterCentroids.get(yscale[__.bundleDimension](row[__.bundleDimension])).get(p[i+1]),centroid=.5*(leftCentroid+rightCentroid);cy=centroid+(1-__.bundlingStrength)*(cy-centroid)}centroids.push($V([cx,cy]))}}return centroids}function compute_control_points(centroids){var cols=centroids.length,a=__.smoothness,cps=[];cps.push(centroids[0]);cps.push($V([centroids[0].e(1)+2*a*(centroids[1].e(1)-centroids[0].e(1)),centroids[0].e(2)]));for(var col=1;col<cols-1;++col){var mid=centroids[col],left=centroids[col-1],right=centroids[col+1],diff=left.subtract(right);cps.push(mid.add(diff.x(a)));cps.push(mid);cps.push(mid.subtract(diff.x(a)))}cps.push($V([centroids[cols-1].e(1)+2*a*(centroids[cols-2].e(1)-centroids[cols-1].e(1)),centroids[cols-1].e(2)]));cps.push(centroids[cols-1]);return cps}pc.shadows=function(){flags.shadows=!0;pc.alphaOnBrushed(.1);pc.render();return this};// draw dots with radius r on the axis line where data intersects\npc.axisDots=function(r){var r=r||.1,ctx=pc.ctx.marks,endAngle=2*Math.PI;ctx.globalAlpha=d3.min([1/Math.pow(__.data.length,1/2),1]);__.data.forEach(function(d){__.dimensions.map(function(p){ctx.beginPath();ctx.arc(position(p),yscale[p](d[p]),r,0,endAngle);ctx.stroke();ctx.fill()})});return this};// draw single cubic bezier curve\nfunction single_curve(d,ctx){var centroids=compute_centroids(d),cps=compute_control_points(centroids);ctx.moveTo(cps[0].e(1),cps[0].e(2));for(var i=1;i<cps.length;i+=3){if(__.showControlPoints){for(var j=0;3>j;j+=1){ctx.fillRect(cps[i+j].e(1),cps[i+j].e(2),2,2)}}ctx.bezierCurveTo(cps[i].e(1),cps[i].e(2),cps[i+1].e(1),cps[i+1].e(2),cps[i+2].e(1),cps[i+2].e(2))}}// draw single polyline\nfunction color_path(d,ctx){ctx.beginPath();if(null!==__.bundleDimension&&0<__.bundlingStrength||0<__.smoothness){single_curve(d,ctx)}else{single_path(d,ctx)}ctx.stroke()}// draw many polylines of the same color\n// returns the y-position just beyond the separating null value line\nfunction getNullPosition(){if("bottom"==__.nullValueSeparator){return h()+1}else if("top"==__.nullValueSeparator){return 1}else{console.log("A value is NULL, but nullValueSeparator is not set; set it to \'bottom\' or \'top\'.")}return h()+1}function single_path(d,ctx){__.dimensions.map(function(p,i){if(0==i){ctx.moveTo(position(p),"undefined"==typeof d[p]?getNullPosition():yscale[p](d[p]))}else{ctx.lineTo(position(p),"undefined"==typeof d[p]?getNullPosition():yscale[p](d[p]))}})}function path_brushed(d,i){if(null!==__.brushedColor){ctx.brushed.strokeStyle=d3.functor(__.brushedColor)(d,i)}else{ctx.brushed.strokeStyle=d3.functor(__.color)(d,i)}return color_path(d,ctx.brushed)}function path_foreground(d,i){ctx.foreground.strokeStyle=d3.functor(__.color)(d,i);return color_path(d,ctx.foreground)}function path_highlight(d,i){ctx.highlight.strokeStyle=d3.functor(__.color)(d,i);return color_path(d,ctx.highlight)}pc.clear=function(layer){ctx[layer].clearRect(0,0,w()+2,h()+2);// This will make sure that the foreground items are transparent\n// without the need for changing the opacity style of the foreground canvas\n// as this would stop the css styling from working\nif("brushed"===layer&&isBrushed()){ctx.brushed.fillStyle=pc.selection.style("background-color");ctx.brushed.globalAlpha=1-__.alphaOnBrushed;ctx.brushed.fillRect(0,0,w()+2,h()+2);ctx.brushed.globalAlpha=__.alpha}return this};d3.rebind(pc,axis,"ticks","orient","tickValues","tickSubdivide","tickSize","tickPadding","tickFormat");function flipAxisAndUpdatePCP(dimension){pc.svg.selectAll(".dimension");pc.flip(dimension);d3.select(this.parentElement).transition().duration(1100).call(axis.scale(yscale[dimension]));pc.render()}function rotateLabels(){var delta=d3.event.deltaY;delta=0>delta?-5:delta;delta=0<delta?5:delta;__.dimensionTitleRotation+=delta;pc.svg.selectAll("text.label").attr("transform","translate(0,-5) rotate("+__.dimensionTitleRotation+")");d3.event.preventDefault()}function dimensionLabels(d){return d in __.dimensionTitles?__.dimensionTitles[d]:d;// dimension display names\n}pc.createAxes=function(){if(g)pc.removeAxes();// Add a group element for each dimension.\ng=pc.svg.selectAll(".dimension").data(__.dimensions,function(d){return d}).enter().append("svg:g").attr("class","dimension").attr("transform",function(d){return"translate("+xscale(d)+")"});// Add an axis and title.\ng.append("svg:g").attr("class","axis").attr("transform","translate(0,0)").each(function(d){d3.select(this).call(axis.scale(yscale[d]))}).append("svg:text").attr({"text-anchor":"middle",y:0,transform:"translate(0,-5) rotate("+__.dimensionTitleRotation+")",x:0,class:"label"}).text(dimensionLabels).on("dblclick",flipAxisAndUpdatePCP).on("wheel",rotateLabels);if("top"==__.nullValueSeparator){pc.svg.append("line").attr("x1",0).attr("y1",1+__.nullValueSeparatorPadding.top).attr("x2",w()).attr("y2",1+__.nullValueSeparatorPadding.top).attr("stroke-width",1).attr("stroke","#777").attr("fill","none").attr("shape-rendering","crispEdges")}else if("bottom"==__.nullValueSeparator){pc.svg.append("line").attr("x1",0).attr("y1",h()+1-__.nullValueSeparatorPadding.bottom).attr("x2",w()).attr("y2",h()+1-__.nullValueSeparatorPadding.bottom).attr("stroke-width",1).attr("stroke","#777").attr("fill","none").attr("shape-rendering","crispEdges")}flags.axes=!0;return this};pc.removeAxes=function(){g.remove();return this};pc.updateAxes=function(){var g_data=pc.svg.selectAll(".dimension").data(__.dimensions);// Enter\ng_data.enter().append("svg:g").attr("class","dimension").attr("transform",function(p){return"translate("+position(p)+")"}).style("opacity",0).append("svg:g").attr("class","axis").attr("transform","translate(0,0)").each(function(d){d3.select(this).call(axis.scale(yscale[d]))}).append("svg:text").attr({"text-anchor":"middle",y:0,transform:"translate(0,-5) rotate("+__.dimensionTitleRotation+")",x:0,class:"label"}).text(dimensionLabels).on("dblclick",flipAxisAndUpdatePCP).on("wheel",rotateLabels);// Update\ng_data.attr("opacity",0);g_data.select(".axis").transition().duration(1100).each(function(d){d3.select(this).call(axis.scale(yscale[d]))});g_data.select(".label").transition().duration(1100).text(dimensionLabels).attr("transform","translate(0,-5) rotate("+__.dimensionTitleRotation+")");// Exit\ng_data.exit().remove();g=pc.svg.selectAll(".dimension");g.transition().duration(1100).attr("transform",function(p){return"translate("+position(p)+")"}).style("opacity",1);pc.svg.selectAll(".axis").transition().duration(1100).each(function(d){d3.select(this).call(axis.scale(yscale[d]))});if(flags.brushable)pc.brushable();if(flags.reorderable)pc.reorderable();if("None"!==pc.brushMode()){var mode=pc.brushMode();pc.brushMode("None");pc.brushMode(mode)}return this};// Jason Davies, http://bl.ocks.org/1341281\npc.reorderable=function(){if(!g)pc.createAxes();g.style("cursor","move").call(d3.behavior.drag().on("dragstart",function(d){dragging[d]=this.__origin__=xscale(d)}).on("drag",function(d){dragging[d]=Math.min(w(),Math.max(0,this.__origin__+=d3.event.dx));__.dimensions.sort(function(a,b){return position(a)-position(b)});xscale.domain(__.dimensions);pc.render();g.attr("transform",function(d){return"translate("+position(d)+")"})}).on("dragend",function(d){// Let\'s see if the order has changed and send out an event if so.\nvar i=0,j=__.dimensions.indexOf(d),elem=this,parent=this.parentElement;while(null!=(elem=elem.previousElementSibling))++i;if(i!==j){events.axesreorder.call(pc,__.dimensions);// We now also want to reorder the actual dom elements that represent\n// the axes. That is, the g.dimension elements. If we don\'t do this,\n// we get a weird and confusing transition when updateAxes is called.\n// This is due to the fact that, initially the nth g.dimension element\n// represents the nth axis. However, after a manual reordering,\n// without reordering the dom elements, the nth dom elements no longer\n// necessarily represents the nth axis.\n//\n// i is the original index of the dom element\n// j is the new index of the dom element\nif(i>j){// Element moved left\nparent.insertBefore(this,parent.children[j-1])}else{// Element moved right\nif(j+1<parent.children.length){parent.insertBefore(this,parent.children[j+1])}else{parent.appendChild(this)}}}delete this.__origin__;delete dragging[d];d3.select(this).transition().attr("transform","translate("+xscale(d)+")");pc.render()}));flags.reorderable=!0;return this};// Reorder dimensions, such that the highest value (visually) is on the left and\n// the lowest on the right. Visual values are determined by the data values in\n// the given row.\npc.reorder=function(rowdata){var dims=__.dimensions.slice(0);__.dimensions.sort(function(a,b){var pixelDifference=yscale[a](rowdata[a])-yscale[b](rowdata[b]);// Array.sort is not necessarily stable, this means that if pixelDifference is zero\n// the ordering of dimensions might change unexpectedly. This is solved by sorting on\n// variable name in that case.\nif(0==pixelDifference){return a.localeCompare(b)}// else\nreturn pixelDifference});// NOTE: this is relatively cheap given that:\n// number of dimensions < number of data items\n// Thus we check equality of order to prevent rerendering when this is the case.\nvar reordered=!1;dims.some(function(val,index){reordered=val!==__.dimensions[index];return reordered});if(reordered){xscale.domain(__.dimensions);var highlighted=__.highlighted.slice(0);pc.unhighlight();g.transition().duration(1500).attr("transform",function(d){return"translate("+xscale(d)+")"});pc.render();// pc.highlight() does not check whether highlighted is length zero, so we do that here.\nif(0!==highlighted.length){pc.highlight(highlighted)}}};// pairs of adjacent dimensions\npc.adjacent_pairs=function(arr){for(var ret=[],i=0;i<arr.length-1;i+=1){ret.push([arr[i],arr[i+1]])}return ret};var brush={modes:{None:{install:function(){},// Nothing to be done.\nuninstall:function(){},// Nothing to be done.\nselected:function(){return[]},// Nothing to return\nbrushState:function(){return{}}}},mode:"None",predicate:"AND",currentMode:function(){return this.modes[this.mode]}};// This function can be used for \'live\' updates of brushes. That is, during the\n// specification of a brush, this method can be called to update the view.\n//\n// @param newSelection - The new set of data items that is currently contained\n//                       by the brushes\nfunction brushUpdated(newSelection){__.brushed=newSelection;events.brush.call(pc,__.brushed);pc.renderBrushed()}function brushPredicate(predicate){if(!arguments.length){return brush.predicate}predicate=(predicate+"").toUpperCase();if("AND"!==predicate&&"OR"!==predicate){throw"Invalid predicate "+predicate}brush.predicate=predicate;__.brushed=brush.currentMode().selected();pc.renderBrushed();return pc}pc.brushModes=function(){return Object.getOwnPropertyNames(brush.modes)};pc.brushMode=function(mode){if(0===arguments.length){return brush.mode}if(-1===pc.brushModes().indexOf(mode)){throw"pc.brushmode: Unsupported brush mode: "+mode}// Make sure that we don\'t trigger unnecessary events by checking if the mode\n// actually changes.\nif(mode!==brush.mode){// When changing brush modes, the first thing we need to do is clearing any\n// brushes from the current mode, if any.\nif("None"!==brush.mode){pc.brushReset()}// Next, we need to \'uninstall\' the current brushMode.\nbrush.modes[brush.mode].uninstall(pc);// Finally, we can install the requested one.\nbrush.mode=mode;brush.modes[brush.mode].install();if("None"===mode){delete pc.brushPredicate}else{pc.brushPredicate=brushPredicate}}return pc};// brush mode: 1D-Axes\n(function(){var brushes={};function is_brushed(p){return!brushes[p].empty()}// data within extents\nfunction selected(){var actives=__.dimensions.filter(is_brushed),extents=actives.map(function(p){return brushes[p].extent()});// We don\'t want to return the full data set when there are no axes brushed.\n// Actually, when there are no axes brushed, by definition, no items are\n// selected. So, let\'s avoid the filtering and just return false.\n//if (actives.length === 0) return false;\n// Resolves broken examples for now. They expect to get the full dataset back from empty brushes\nif(0===actives.length)return __.data;// test if within range\nvar within={date:function(d,p,dimension){if("function"==typeof yscale[p].rangePoints){// if it is ordinal\nreturn extents[dimension][0]<=yscale[p](d[p])&&yscale[p](d[p])<=extents[dimension][1]}else{return extents[dimension][0]<=d[p]&&d[p]<=extents[dimension][1]}},number:function(d,p,dimension){if("function"==typeof yscale[p].rangePoints){// if it is ordinal\nreturn extents[dimension][0]<=yscale[p](d[p])&&yscale[p](d[p])<=extents[dimension][1]}else{return extents[dimension][0]<=d[p]&&d[p]<=extents[dimension][1]}},string:function(d,p,dimension){return extents[dimension][0]<=yscale[p](d[p])&&yscale[p](d[p])<=extents[dimension][1]}};return __.data.filter(function(d){switch(brush.predicate){case"AND":return actives.every(function(p,dimension){return within[__.types[p]](d,p,dimension)});case"OR":return actives.some(function(p,dimension){return within[__.types[p]](d,p,dimension)});default:throw"Unknown brush predicate "+__.brushPredicate;}})}function brushExtents(extents){if("undefined"==typeof extents){var extents={};__.dimensions.forEach(function(d){var brush=brushes[d];if(brush!==void 0&&!brush.empty()){var extent=brush.extent();extent.sort(d3.ascending);extents[d]=extent}});return extents}else{//first get all the brush selections\nvar brushSelections={};g.selectAll(".brush").each(function(d){brushSelections[d]=d3.select(this)});// loop over each dimension and update appropriately (if it was passed in through extents)\n__.dimensions.forEach(function(d){if(extents[d]===void 0){return}var brush=brushes[d];if(brush!==void 0){//update the extent\nbrush.extent(extents[d]);//redraw the brush\nbrush(brushSelections[d]);//fire some events\nbrush.event(brushSelections[d])}});//redraw the chart\npc.renderBrushed()}}function brushFor(axis){var brush=d3.svg.brush();brush.y(yscale[axis]).on("brushstart",function(){if(null!==d3.event.sourceEvent){d3.event.sourceEvent.stopPropagation()}}).on("brush",function(){brushUpdated(selected())}).on("brushend",function(){events.brushend.call(pc,__.brushed)});brushes[axis]=brush;return brush}function brushReset(){__.brushed=!1;if(g){g.selectAll(".brush").each(function(d){d3.select(this).call(brushes[d].clear())});pc.renderBrushed()}return this}function install(){if(!g)pc.createAxes();// Add and store a brush for each axis.\ng.append("svg:g").attr("class","brush").each(function(d){d3.select(this).call(brushFor(d))}).selectAll("rect").style("visibility",null).attr("x",-15).attr("width",30);pc.brushExtents=brushExtents;pc.brushReset=brushReset;return pc}brush.modes["1D-axes"]={install:install,uninstall:function(){g.selectAll(".brush").remove();brushes={};delete pc.brushExtents;delete pc.brushReset},selected:selected,brushState:brushExtents}})();// brush mode: 2D-strums\n// bl.ocks.org/syntagmatic/5441022\n(function(){var strums={},strumRect;function drawStrum(strum,activePoint){var svg=pc.selection.select("svg").select("g#strums"),id=strum.dims.i,points=[strum.p1,strum.p2],line=svg.selectAll("line#strum-"+id).data([strum]),circles=svg.selectAll("circle#strum-"+id).data(points),drag=d3.behavior.drag();line.enter().append("line").attr("id","strum-"+id).attr("class","strum");line.attr("x1",function(d){return d.p1[0]}).attr("y1",function(d){return d.p1[1]}).attr("x2",function(d){return d.p2[0]}).attr("y2",function(d){return d.p2[1]}).attr("stroke","black").attr("stroke-width",2);drag.on("drag",function(d,i){var ev=d3.event;i=i+1;strum["p"+i][0]=Math.min(Math.max(strum.minX+1,ev.x),strum.maxX);strum["p"+i][1]=Math.min(Math.max(strum.minY,ev.y),strum.maxY);drawStrum(strum,i-1)}).on("dragend",onDragEnd());circles.enter().append("circle").attr("id","strum-"+id).attr("class","strum");circles.attr("cx",function(d){return d[0]}).attr("cy",function(d){return d[1]}).attr("r",5).style("opacity",function(d,i){return activePoint!==void 0&&i===activePoint?.8:0}).on("mouseover",function(){d3.select(this).style("opacity",.8)}).on("mouseout",function(){d3.select(this).style("opacity",0)}).call(drag)}function dimensionsForPoint(p){var dims={i:-1,left:void 0,right:void 0};__.dimensions.some(function(dim,i){if(xscale(dim)<p[0]){var next=__.dimensions[i+1];dims.i=i;dims.left=dim;dims.right=next;return!1}return!0});if(dims.left===void 0){// Event on the left side of the first axis.\ndims.i=0;dims.left=__.dimensions[0];dims.right=__.dimensions[1]}else if(dims.right===void 0){// Event on the right side of the last axis\ndims.i=__.dimensions.length-1;dims.right=dims.left;dims.left=__.dimensions[__.dimensions.length-2]}return dims}function onDragStart(){// First we need to determine between which two axes the sturm was started.\n// This will determine the freedom of movement, because a strum can\n// logically only happen between two axes, so no movement outside these axes\n// should be allowed.\nreturn function(){var p=d3.mouse(strumRect[0][0]),dims,strum;p[0]=p[0]-__.margin.left;p[1]=p[1]-__.margin.top;dims=dimensionsForPoint(p),strum={p1:p,dims:dims,minX:xscale(dims.left),maxX:xscale(dims.right),minY:0,maxY:h()};strums[dims.i]=strum;strums.active=dims.i;// Make sure that the point is within the bounds\nstrum.p1[0]=Math.min(Math.max(strum.minX,p[0]),strum.maxX);strum.p2=strum.p1.slice()}}function onDrag(){return function(){var ev=d3.event,strum=strums[strums.active];// Make sure that the point is within the bounds\nstrum.p2[0]=Math.min(Math.max(strum.minX+1,ev.x-__.margin.left),strum.maxX);strum.p2[1]=Math.min(Math.max(strum.minY,ev.y-__.margin.top),strum.maxY);drawStrum(strum,1)}}function containmentTest(strum,width){var p1=[strum.p1[0]-strum.minX,strum.p1[1]-strum.minX],p2=[strum.p2[0]-strum.minX,strum.p2[1]-strum.minX],m1=1-width/p1[0],b1=p1[1]*(1-m1),m2=1-width/p2[0],b2=p2[1]*(1-m2);// test if point falls between lines\nreturn function(p){var x=p[0],y=p[1],y1=m1*x+b1,y2=m2*x+b2;if(y>Math.min(y1,y2)&&y<Math.max(y1,y2)){return!0}return!1}}function selected(){var ids=Object.getOwnPropertyNames(strums),brushed=__.data;// Get the ids of the currently active strums.\nids=ids.filter(function(d){return!isNaN(d)});function crossesStrum(d,id){var strum=strums[id],test=containmentTest(strum,strums.width(id)),d1=strum.dims.left,d2=strum.dims.right,y1=yscale[d1],y2=yscale[d2],point=[y1(d[d1])-strum.minX,y2(d[d2])-strum.minX];return test(point)}if(0===ids.length){return brushed}return brushed.filter(function(d){switch(brush.predicate){case"AND":return ids.every(function(id){return crossesStrum(d,id)});case"OR":return ids.some(function(id){return crossesStrum(d,id)});default:throw"Unknown brush predicate "+__.brushPredicate;}})}function removeStrum(){var strum=strums[strums.active],svg=pc.selection.select("svg").select("g#strums");delete strums[strums.active];strums.active=void 0;svg.selectAll("line#strum-"+strum.dims.i).remove();svg.selectAll("circle#strum-"+strum.dims.i).remove()}function onDragEnd(){return function(){var brushed=__.data,strum=strums[strums.active];// Okay, somewhat unexpected, but not totally unsurprising, a mousclick is\n// considered a drag without move. So we have to deal with that case\nif(strum&&strum.p1[0]===strum.p2[0]&&strum.p1[1]===strum.p2[1]){removeStrum(strums)}brushed=selected(strums);strums.active=void 0;__.brushed=brushed;pc.renderBrushed();events.brushend.call(pc,__.brushed)}}function brushReset(strums){return function(){var ids=Object.getOwnPropertyNames(strums).filter(function(d){return!isNaN(d)});ids.forEach(function(d){strums.active=d;removeStrum(strums)});onDragEnd(strums)()}}brush.modes["2D-strums"]={install:function(){var drag=d3.behavior.drag();// Map of current strums. Strums are stored per segment of the PC. A segment,\n// being the area between two axes. The left most area is indexed at 0.\nstrums.active=void 0;// Returns the width of the PC segment where currently a strum is being\n// placed. NOTE: even though they are evenly spaced in our current\n// implementation, we keep for when non-even spaced segments are supported as\n// well.\nstrums.width=function(id){var strum=strums[id];if(strum===void 0){return}return strum.maxX-strum.minX};pc.on("axesreorder.strums",function(){var ids=Object.getOwnPropertyNames(strums).filter(function(d){return!isNaN(d)});// Checks if the first dimension is directly left of the second dimension.\nfunction consecutive(first,second){var length=__.dimensions.length;return __.dimensions.some(function(d,i){return d===first?i+i<length&&__.dimensions[i+1]===second:!1})}if(0<ids.length){// We have some strums, which might need to be removed.\nids.forEach(function(d){var dims=strums[d].dims;strums.active=d;// If the two dimensions of the current strum are not next to each other\n// any more, than we\'ll need to remove the strum. Otherwise we keep it.\nif(!consecutive(dims.left,dims.right)){removeStrum(strums)}});onDragEnd(strums)()}});// Add a new svg group in which we draw the strums.\npc.selection.select("svg").append("g").attr("id","strums").attr("transform","translate("+__.margin.left+","+__.margin.top+")");// Install the required brushReset function\npc.brushReset=brushReset(strums);drag.on("dragstart",onDragStart(strums)).on("drag",onDrag(strums)).on("dragend",onDragEnd(strums));// NOTE: The styling needs to be done here and not in the css. This is because\n//       for 1D brushing, the canvas layers should not listen to\n//       pointer-events.\nstrumRect=pc.selection.select("svg").insert("rect","g#strums").attr("id","strum-events").attr("x",__.margin.left).attr("y",__.margin.top).attr("width",w()).attr("height",h()+2).style("opacity",0).call(drag)},uninstall:function(){pc.selection.select("svg").select("g#strums").remove();pc.selection.select("svg").select("rect#strum-events").remove();pc.on("axesreorder.strums",void 0);delete pc.brushReset;strumRect=void 0},selected:selected,brushState:function(){return strums}}})();// brush mode: 1D-Axes with multiple extents\n// requires d3.svg.multibrush\n(function(){if("function"!=typeof d3.svg.multibrush){return}var brushes={};function is_brushed(p){return!brushes[p].empty()}// data within extents\nfunction selected(){var actives=__.dimensions.filter(is_brushed),extents=actives.map(function(p){return brushes[p].extent()});// We don\'t want to return the full data set when there are no axes brushed.\n// Actually, when there are no axes brushed, by definition, no items are\n// selected. So, let\'s avoid the filtering and just return false.\n//if (actives.length === 0) return false;\n// Resolves broken examples for now. They expect to get the full dataset back from empty brushes\nif(0===actives.length)return __.data;// test if within range\nvar within={date:function(d,p,dimension,b){if("function"==typeof yscale[p].rangePoints){// if it is ordinal\nreturn b[0]<=yscale[p](d[p])&&yscale[p](d[p])<=b[1]}else{return b[0]<=d[p]&&d[p]<=b[1]}},number:function(d,p,dimension,b){if("function"==typeof yscale[p].rangePoints){// if it is ordinal\nreturn b[0]<=yscale[p](d[p])&&yscale[p](d[p])<=b[1]}else{return b[0]<=d[p]&&d[p]<=b[1]}},string:function(d,p,dimension,b){return b[0]<=yscale[p](d[p])&&yscale[p](d[p])<=b[1]}};return __.data.filter(function(d){switch(brush.predicate){case"AND":return actives.every(function(p,dimension){return extents[dimension].some(function(b){return within[__.types[p]](d,p,dimension,b)})});case"OR":return actives.some(function(p,dimension){return extents[dimension].some(function(b){return within[__.types[p]](d,p,dimension,b)})});default:throw"Unknown brush predicate "+__.brushPredicate;}})}function brushExtents(){var extents={};__.dimensions.forEach(function(d){var brush=brushes[d];if(brush!==void 0&&!brush.empty()){var extent=brush.extent();extents[d]=extent}});return extents}function brushFor(axis){var brush=d3.svg.multibrush();brush.y(yscale[axis]).on("brushstart",function(){if(null!==d3.event.sourceEvent){d3.event.sourceEvent.stopPropagation()}}).on("brush",function(){brushUpdated(selected())}).on("brushend",function(){// d3.svg.multibrush clears extents just before calling \'brushend\'\n// so we have to update here again.\n// This fixes issue #103 for now, but should be changed in d3.svg.multibrush\n// to avoid unnecessary computation.\nbrushUpdated(selected());events.brushend.call(pc,__.brushed)}).extentAdaption(function(selection){selection.style("visibility",null).attr("x",-15).attr("width",30)}).resizeAdaption(function(selection){selection.selectAll("rect").attr("x",-15).attr("width",30)});brushes[axis]=brush;return brush}function brushReset(){__.brushed=!1;if(g){g.selectAll(".brush").each(function(d){d3.select(this).call(brushes[d].clear())});pc.renderBrushed()}return this}function install(){if(!g)pc.createAxes();// Add and store a brush for each axis.\ng.append("svg:g").attr("class","brush").each(function(d){d3.select(this).call(brushFor(d))}).selectAll("rect").style("visibility",null).attr("x",-15).attr("width",30);pc.brushExtents=brushExtents;pc.brushReset=brushReset;return pc}brush.modes["1D-axes-multi"]={install:install,uninstall:function(){g.selectAll(".brush").remove();brushes={};delete pc.brushExtents;delete pc.brushReset},selected:selected,brushState:brushExtents}})();// brush mode: angular\n// code based on 2D.strums.js\n(function(){var arcs={},strumRect;function drawStrum(arc,activePoint){var svg=pc.selection.select("svg").select("g#arcs"),id=arc.dims.i,points=[arc.p2,arc.p3],line=svg.selectAll("line#arc-"+id).data([{p1:arc.p1,p2:arc.p2},{p1:arc.p1,p2:arc.p3}]),circles=svg.selectAll("circle#arc-"+id).data(points),drag=d3.behavior.drag(),path=svg.selectAll("path#arc-"+id).data([arc]);path.enter().append("path").attr("id","arc-"+id).attr("class","arc").style("fill","orange").style("opacity",.5);path.attr("d",arc.arc).attr("transform","translate("+arc.p1[0]+","+arc.p1[1]+")");line.enter().append("line").attr("id","arc-"+id).attr("class","arc");line.attr("x1",function(d){return d.p1[0]}).attr("y1",function(d){return d.p1[1]}).attr("x2",function(d){return d.p2[0]}).attr("y2",function(d){return d.p2[1]}).attr("stroke","black").attr("stroke-width",2);drag.on("drag",function(d,i){var ev=d3.event,angle=0;i=i+2;arc["p"+i][0]=Math.min(Math.max(arc.minX+1,ev.x),arc.maxX);arc["p"+i][1]=Math.min(Math.max(arc.minY,ev.y),arc.maxY);angle=3===i?arcs.startAngle(id):arcs.endAngle(id);if(arc.startAngle<Math.PI&&arc.endAngle<Math.PI&&angle<Math.PI||arc.startAngle>=Math.PI&&arc.endAngle>=Math.PI&&angle>=Math.PI){if(2===i){arc.endAngle=angle;arc.arc.endAngle(angle)}else if(3===i){arc.startAngle=angle;arc.arc.startAngle(angle)}}drawStrum(arc,i-2)}).on("dragend",onDragEnd());circles.enter().append("circle").attr("id","arc-"+id).attr("class","arc");circles.attr("cx",function(d){return d[0]}).attr("cy",function(d){return d[1]}).attr("r",5).style("opacity",function(d,i){return activePoint!==void 0&&i===activePoint?.8:0}).on("mouseover",function(){d3.select(this).style("opacity",.8)}).on("mouseout",function(){d3.select(this).style("opacity",0)}).call(drag)}function dimensionsForPoint(p){var dims={i:-1,left:void 0,right:void 0};__.dimensions.some(function(dim,i){if(xscale(dim)<p[0]){var next=__.dimensions[i+1];dims.i=i;dims.left=dim;dims.right=next;return!1}return!0});if(dims.left===void 0){// Event on the left side of the first axis.\ndims.i=0;dims.left=__.dimensions[0];dims.right=__.dimensions[1]}else if(dims.right===void 0){// Event on the right side of the last axis\ndims.i=__.dimensions.length-1;dims.right=dims.left;dims.left=__.dimensions[__.dimensions.length-2]}return dims}function onDragStart(){// First we need to determine between which two axes the arc was started.\n// This will determine the freedom of movement, because a arc can\n// logically only happen between two axes, so no movement outside these axes\n// should be allowed.\nreturn function(){var p=d3.mouse(strumRect[0][0]),dims,arc;p[0]=p[0]-__.margin.left;p[1]=p[1]-__.margin.top;dims=dimensionsForPoint(p),arc={p1:p,dims:dims,minX:xscale(dims.left),maxX:xscale(dims.right),minY:0,maxY:h(),startAngle:void 0,endAngle:void 0,arc:d3.svg.arc().innerRadius(0)};arcs[dims.i]=arc;arcs.active=dims.i;// Make sure that the point is within the bounds\narc.p1[0]=Math.min(Math.max(arc.minX,p[0]),arc.maxX);arc.p2=arc.p1.slice();arc.p3=arc.p1.slice()}}function onDrag(){return function(){var ev=d3.event,arc=arcs[arcs.active];// Make sure that the point is within the bounds\narc.p2[0]=Math.min(Math.max(arc.minX+1,ev.x-__.margin.left),arc.maxX);arc.p2[1]=Math.min(Math.max(arc.minY,ev.y-__.margin.top),arc.maxY);arc.p3=arc.p2.slice();drawStrum(arc,1)}}// some helper functions\nfunction hypothenuse(a,b){return Math.sqrt(a*a+b*b)}var rad=function(){var c=Math.PI/180;return function(angle){return angle*c}}(),deg=function(){var c=180/Math.PI;return function(angle){return angle*c}}(),signedAngle=function(angle){var ret=angle;if(angle>Math.PI){ret=angle-1.5*Math.PI;ret=angle-1.5*Math.PI}else{ret=angle-.5*Math.PI;ret=angle-.5*Math.PI}return-ret};/**\n     * angles are stored in radians from in [0, 2*PI], where 0 in 12 o\'clock.\n     * However, one can only select lines from 0 to PI, so we compute the\n     * \'signed\' angle, where 0 is the horizontal line (3 o\'clock), and +/- PI/2\n     * are 12 and 6 o\'clock respectively.\n     */function containmentTest(arc){var startAngle=signedAngle(arc.startAngle),endAngle=signedAngle(arc.endAngle);if(startAngle>endAngle){var tmp=startAngle;startAngle=endAngle;endAngle=tmp}// test if segment angle is contained in angle interval\nreturn function(a){if(a>=startAngle&&a<=endAngle){return!0}return!1}}function selected(){var ids=Object.getOwnPropertyNames(arcs),brushed=__.data;// Get the ids of the currently active arcs.\nids=ids.filter(function(d){return!isNaN(d)});function crossesStrum(d,id){var arc=arcs[id],test=containmentTest(arc),d1=arc.dims.left,d2=arc.dims.right,y1=yscale[d1],y2=yscale[d2],a=arcs.width(id),b=y1(d[d1])-y2(d[d2]),c=hypothenuse(a,b),angle=Math.asin(b/c);// rad in [-PI/2, PI/2]\nreturn test(angle)}if(0===ids.length){return brushed}return brushed.filter(function(d){switch(brush.predicate){case"AND":return ids.every(function(id){return crossesStrum(d,id)});case"OR":return ids.some(function(id){return crossesStrum(d,id)});default:throw"Unknown brush predicate "+__.brushPredicate;}})}function removeStrum(){var arc=arcs[arcs.active],svg=pc.selection.select("svg").select("g#arcs");delete arcs[arcs.active];arcs.active=void 0;svg.selectAll("line#arc-"+arc.dims.i).remove();svg.selectAll("circle#arc-"+arc.dims.i).remove();svg.selectAll("path#arc-"+arc.dims.i).remove()}function onDragEnd(){return function(){var brushed=__.data,arc=arcs[arcs.active];// Okay, somewhat unexpected, but not totally unsurprising, a mousclick is\n// considered a drag without move. So we have to deal with that case\nif(arc&&arc.p1[0]===arc.p2[0]&&arc.p1[1]===arc.p2[1]){removeStrum(arcs)}if(arc){var angle=arcs.startAngle(arcs.active);arc.startAngle=angle;arc.endAngle=angle;arc.arc.outerRadius(arcs.length(arcs.active)).startAngle(angle).endAngle(angle)}brushed=selected(arcs);arcs.active=void 0;__.brushed=brushed;pc.renderBrushed();events.brushend.call(pc,__.brushed)}}function brushReset(arcs){return function(){var ids=Object.getOwnPropertyNames(arcs).filter(function(d){return!isNaN(d)});ids.forEach(function(d){arcs.active=d;removeStrum(arcs)});onDragEnd(arcs)()}}brush.modes.angular={install:function(){var drag=d3.behavior.drag();// Map of current arcs. arcs are stored per segment of the PC. A segment,\n// being the area between two axes. The left most area is indexed at 0.\narcs.active=void 0;// Returns the width of the PC segment where currently a arc is being\n// placed. NOTE: even though they are evenly spaced in our current\n// implementation, we keep for when non-even spaced segments are supported as\n// well.\narcs.width=function(id){var arc=arcs[id];if(arc===void 0){return}return arc.maxX-arc.minX};// returns angles in [-PI/2, PI/2]\nangle=function(p1,p2){var a=p1[0]-p2[0],b=p1[1]-p2[1],c=hypothenuse(a,b);return Math.asin(b/c)};// returns angles in [0, 2 * PI]\narcs.endAngle=function(id){var arc=arcs[id];if(arc===void 0){return}var sAngle=angle(arc.p1,arc.p2),uAngle=-sAngle+Math.PI/2;if(arc.p1[0]>arc.p2[0]){uAngle=2*Math.PI-uAngle}return uAngle};arcs.startAngle=function(id){var arc=arcs[id];if(arc===void 0){return}var sAngle=angle(arc.p1,arc.p3),uAngle=-sAngle+Math.PI/2;if(arc.p1[0]>arc.p3[0]){uAngle=2*Math.PI-uAngle}return uAngle};arcs.length=function(id){var arc=arcs[id];if(arc===void 0){return}var a=arc.p1[0]-arc.p2[0],b=arc.p1[1]-arc.p2[1],c=hypothenuse(a,b);return c};pc.on("axesreorder.arcs",function(){var ids=Object.getOwnPropertyNames(arcs).filter(function(d){return!isNaN(d)});// Checks if the first dimension is directly left of the second dimension.\nfunction consecutive(first,second){var length=__.dimensions.length;return __.dimensions.some(function(d,i){return d===first?i+i<length&&__.dimensions[i+1]===second:!1})}if(0<ids.length){// We have some arcs, which might need to be removed.\nids.forEach(function(d){var dims=arcs[d].dims;arcs.active=d;// If the two dimensions of the current arc are not next to each other\n// any more, than we\'ll need to remove the arc. Otherwise we keep it.\nif(!consecutive(dims.left,dims.right)){removeStrum(arcs)}});onDragEnd(arcs)()}});// Add a new svg group in which we draw the arcs.\npc.selection.select("svg").append("g").attr("id","arcs").attr("transform","translate("+__.margin.left+","+__.margin.top+")");// Install the required brushReset function\npc.brushReset=brushReset(arcs);drag.on("dragstart",onDragStart(arcs)).on("drag",onDrag(arcs)).on("dragend",onDragEnd(arcs));// NOTE: The styling needs to be done here and not in the css. This is because\n//       for 1D brushing, the canvas layers should not listen to\n//       pointer-events.\nstrumRect=pc.selection.select("svg").insert("rect","g#arcs").attr("id","arc-events").attr("x",__.margin.left).attr("y",__.margin.top).attr("width",w()).attr("height",h()+2).style("opacity",0).call(drag)},uninstall:function(){pc.selection.select("svg").select("g#arcs").remove();pc.selection.select("svg").select("rect#arc-events").remove();pc.on("axesreorder.arcs",void 0);delete pc.brushReset;strumRect=void 0},selected:selected,brushState:function(){return arcs}}})();pc.interactive=function(){flags.interactive=!0;return this};// expose a few objects\npc.xscale=xscale;pc.yscale=yscale;pc.ctx=ctx;pc.canvas=canvas;pc.g=function(){return g};// rescale for height, width and margins\n// TODO currently assumes chart is brushable, and destroys old brushes\npc.resize=function(){// selection size\npc.selection.select("svg").attr("width",__.width).attr("height",__.height);pc.svg.attr("transform","translate("+__.margin.left+","+__.margin.top+")");// FIXME: the current brush state should pass through\nif(flags.brushable)pc.brushReset();// scales\npc.autoscale();// axes, destroys old brushes.\nif(g)pc.createAxes();if(flags.brushable)pc.brushable();if(flags.reorderable)pc.reorderable();events.resize.call(this,{width:__.width,height:__.height,margin:__.margin});return this};// highlight an array of data\npc.highlight=function(data){if(0===arguments.length){return __.highlighted}__.highlighted=data;pc.clear("highlight");d3.selectAll([canvas.foreground,canvas.brushed]).classed("faded",!0);data.forEach(path_highlight);events.highlight.call(this,data);return this};// clear highlighting\npc.unhighlight=function(){__.highlighted=[];pc.clear("highlight");d3.selectAll([canvas.foreground,canvas.brushed]).classed("faded",!1);return this};// calculate 2d intersection of line a->b with line c->d\n// points are objects with x and y properties\npc.intersection=function(a,b,c,d){return{x:((a.x*b.y-a.y*b.x)*(c.x-d.x)-(a.x-b.x)*(c.x*d.y-c.y*d.x))/((a.x-b.x)*(c.y-d.y)-(a.y-b.y)*(c.x-d.x)),y:((a.x*b.y-a.y*b.x)*(c.y-d.y)-(a.y-b.y)*(c.x*d.y-c.y*d.x))/((a.x-b.x)*(c.y-d.y)-(a.y-b.y)*(c.x-d.x))}};function position(d){var v=dragging[d];return null==v?xscale(d):v}pc.version="0.7.0";// this descriptive text should live with other introspective methods\npc.toString=function(){return"Parallel Coordinates: "+__.dimensions.length+" dimensions ("+d3.keys(__.data[0]).length+" total) , "+__.data.length+" rows"};return pc});d3.renderQueue=function(func){var _queue=[],// data to be rendered\n_rate=10,// number of calls per frame\n_clear=function(){},// clearing function\n_i=0,rq=function(data){if(data)rq.data(data);rq.invalidate();_clear();rq.render()};// current iteration\nrq.render=function(){_i=0;var valid=!0;rq.invalidate=function(){valid=!1};function doFrame(){if(!valid)return!0;if(_i>_queue.length)return!0;// Typical d3 behavior is to pass a data item *and* its index. As the\n// render queue splits the original data set, we\'ll have to be slightly\n// more carefull about passing the correct index with the data item.\nfor(var end=Math.min(_i+_rate,_queue.length),i=_i;i<end;i+=1){func(_queue[i],i)}_i+=_rate}d3.timer(doFrame)};rq.data=function(data){rq.invalidate();_queue=data.slice(0);return rq};rq.rate=function(value){if(!arguments.length)return _rate;_rate=value;return rq};rq.remaining=function(){return _queue.length-_i};// clear the canvas\nrq.clear=function(func){if(!arguments.length){_clear();return rq}_clear=func;return rq};rq.invalidate=function(){};return rq};\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/divgrid.js\n/* [LICENSE TBD] */ /* eslint-disable */ // from http://bl.ocks.org/3687826\n/* harmony default export */ var divgrid = (function(){var columns=[],dg=function(selection){if(0==columns.length)columns=d3.keys(selection.data()[0][0]);// header\nselection.selectAll(".header").data([!0]).enter().append("div").attr("class","header");var header=selection.select(".header").selectAll(".cell").data(columns);header.enter().append("div").attr("class",function(d,i){return"col-"+i}).classed("cell",!0);selection.selectAll(".header .cell").text(function(d){return d});header.exit().remove();// rows\nvar rows=selection.selectAll(".row").data(function(d){return d});rows.enter().append("div").attr("class","row");rows.exit().remove();var cells=selection.selectAll(".row").selectAll(".cell").data(function(d){return columns.map(function(col){return d[col]})});// cells\ncells.enter().append("div").attr("class",function(d,i){return"col-"+i}).classed("cell",!0);cells.exit().remove();selection.selectAll(".cell").text(function(d){return d});return dg};dg.columns=function(_){if(!arguments.length)return columns;columns=_;return this};return dg});\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/d3.parcoords.css\nvar parcoords_d3_parcoords = __webpack_require__(2316);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-parallel-coordinates/src/ParallelCoordinates.js\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */ /* eslint-disable react/sort-prop-types */const propTypes={// Standard tabular data [{ fieldName1: value1, fieldName2: value2 }]\ndata:prop_types_default.a.arrayOf(prop_types_default.a.object),width:prop_types_default.a.number,height:prop_types_default.a.number,colorMetric:prop_types_default.a.string,includeSeries:prop_types_default.a.bool,linearColorScheme:prop_types_default.a.string,metrics:prop_types_default.a.arrayOf(prop_types_default.a.string),series:prop_types_default.a.string,showDatatable:prop_types_default.a.bool};function ParallelCoordinates(element,props){const{data,width,height,colorMetric,includeSeries,linearColorScheme,metrics,series,showDatatable}=props,cols=includeSeries?[series].concat(metrics):metrics,ttypes={};ttypes[series]="string";metrics.forEach(v=>{ttypes[v]="number"});const colorScale=colorMetric?Object(SequentialSchemeRegistrySingleton["a" /* default */])().get(linearColorScheme).createLinearScale(d3_default.a.extent(data,d=>d[colorMetric])):()=>"grey",container=d3_default.a.select(element).classed("superset-legacy-chart-parallel-coordinates",!0);container.selectAll("*").remove();const effHeight=showDatatable?height/2:height,div=container.append("div").style("height",`${effHeight}px`).classed("parcoords",!0),chart=d3_parcoords()(div.node()).width(width).color(d=>colorScale(d[colorMetric])).alpha(.5).composite("darken").height(effHeight).data(data).dimensions(cols).types(ttypes).render().createAxes().shadows().reorderable().brushMode("1D-axes");if(showDatatable){// create data table, row hover highlighting\nconst grid=divgrid();container.append("div").style("height",`${effHeight}px`).datum(data).call(grid).classed("parcoords grid",!0).selectAll(".row").on({mouseover(d){chart.highlight([d])},mouseout:chart.unhighlight});// update data table on brush event\nchart.on("brush",d=>{d3_default.a.select(".grid").datum(d).call(grid).selectAll(".row").on({mouseover(dd){chart.highlight([dd])},mouseout:chart.unhighlight})})}}ParallelCoordinates.displayName="ParallelCoordinates";ParallelCoordinates.propTypes=propTypes;/* harmony default export */ var src_ParallelCoordinates = (ParallelCoordinates);\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-parallel-coordinates/src/ReactParallelCoordinates.jsx\nfunction _objectWithoutProperties(source,excluded){if(null==source)return{};var target=_objectWithoutPropertiesLoose(source,excluded),key,i;if(Object.getOwnPropertySymbols){var sourceSymbolKeys=Object.getOwnPropertySymbols(source);for(i=0;i<sourceSymbolKeys.length;i++){key=sourceSymbolKeys[i];if(0<=excluded.indexOf(key))continue;if(!Object.prototype.propertyIsEnumerable.call(source,key))continue;target[key]=source[key]}}return target}function _objectWithoutPropertiesLoose(source,excluded){if(null==source)return{};var target={},sourceKeys=Object.keys(source),key,i;for(i=0;i<sourceKeys.length;i++){key=sourceKeys[i];if(0<=excluded.indexOf(key))continue;target[key]=source[key]}return target}/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * "License"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */const ReactComponent=Object(reactify["a" /* default */])(src_ParallelCoordinates),ParallelCoordianes=(_ref)=>{let{className}=_ref,otherProps=_objectWithoutProperties(_ref,["className"]);return/*#__PURE__*/react_default.a.createElement("div",{className:className},/*#__PURE__*/react_default.a.createElement(ReactComponent,otherProps))};ParallelCoordianes.displayName="ParallelCoordianes";ParallelCoordianes.propTypes={className:prop_types_default.a.string.isRequired};/* harmony default export */ var ReactParallelCoordinates = __webpack_exports__["default"] = (Object(style["d" /* styled */])(ParallelCoordianes)`\n  .superset-legacy-chart-parallel-coordinates {\n    div.grid {\n      overflow: auto;\n      div.row {\n        &:hover {\n          background-color: #ccc;\n        }\n      }\n    }\n  }\n`);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUwOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9sZWdhY3ktcGx1Z2luLWNoYXJ0LXBhcmFsbGVsLWNvb3JkaW5hdGVzL3NyYy92ZW5kb3IvcGFyY29vcmRzL2QzLnBhcmNvb3Jkcy5qcz9hNzQ0Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9sZWdhY3ktcGx1Z2luLWNoYXJ0LXBhcmFsbGVsLWNvb3JkaW5hdGVzL3NyYy92ZW5kb3IvcGFyY29vcmRzL2RpdmdyaWQuanM/NzRjNiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvbGVnYWN5LXBsdWdpbi1jaGFydC1wYXJhbGxlbC1jb29yZGluYXRlcy9zcmMvUGFyYWxsZWxDb29yZGluYXRlcy5qcz8wN2NmIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9sZWdhY3ktcGx1Z2luLWNoYXJ0LXBhcmFsbGVsLWNvb3JkaW5hdGVzL3NyYy9SZWFjdFBhcmFsbGVsQ29vcmRpbmF0ZXMuanN4PzY3NjQiXSwic291cmNlc0NvbnRlbnQiOlsiLyogW0xJQ0VOU0UgVEJEXSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgdmFyIF9fID0ge1xuICAgIGRhdGE6IFtdLFxuICAgIGhpZ2hsaWdodGVkOiBbXSxcbiAgICBkaW1lbnNpb25zOiBbXSxcbiAgICBkaW1lbnNpb25UaXRsZXM6IHt9LFxuICAgIGRpbWVuc2lvblRpdGxlUm90YXRpb246IDAsXG4gICAgdHlwZXM6IHt9LFxuICAgIGJydXNoZWQ6IGZhbHNlLFxuICAgIGJydXNoZWRDb2xvcjogbnVsbCxcbiAgICBhbHBoYU9uQnJ1c2hlZDogMC4wLFxuICAgIG1vZGU6ICdkZWZhdWx0JyxcbiAgICByYXRlOiAyMCxcbiAgICB3aWR0aDogNjAwLFxuICAgIGhlaWdodDogMzAwLFxuICAgIG1hcmdpbjogeyB0b3A6IDI0LCByaWdodDogMCwgYm90dG9tOiAxMiwgbGVmdDogMCB9LFxuICAgIG51bGxWYWx1ZVNlcGFyYXRvcjogJ3VuZGVmaW5lZCcsIC8vIHNldCB0byBcInRvcFwiIG9yIFwiYm90dG9tXCJcbiAgICBudWxsVmFsdWVTZXBhcmF0b3JQYWRkaW5nOiB7IHRvcDogOCwgcmlnaHQ6IDAsIGJvdHRvbTogOCwgbGVmdDogMCB9LFxuICAgIGNvbG9yOiAnIzA2OScsXG4gICAgY29tcG9zaXRlOiAnc291cmNlLW92ZXInLFxuICAgIGFscGhhOiAwLjcsXG4gICAgYnVuZGxpbmdTdHJlbmd0aDogMC41LFxuICAgIGJ1bmRsZURpbWVuc2lvbjogbnVsbCxcbiAgICBzbW9vdGhuZXNzOiAwLjAsXG4gICAgc2hvd0NvbnRyb2xQb2ludHM6IGZhbHNlLFxuICAgIGhpZGVBeGlzOiBbXSxcbiAgfTtcblxuICBleHRlbmQoX18sIGNvbmZpZyk7XG5cbiAgdmFyIHBjID0gZnVuY3Rpb24gKHNlbGVjdGlvbikge1xuICAgIHNlbGVjdGlvbiA9IHBjLnNlbGVjdGlvbiA9IGQzLnNlbGVjdChzZWxlY3Rpb24pO1xuXG4gICAgX18ud2lkdGggPSBzZWxlY3Rpb25bMF1bMF0uY2xpZW50V2lkdGg7XG4gICAgX18uaGVpZ2h0ID0gc2VsZWN0aW9uWzBdWzBdLmNsaWVudEhlaWdodDtcblxuICAgIC8vIGNhbnZhcyBkYXRhIGxheWVyc1xuICAgIFsnbWFya3MnLCAnZm9yZWdyb3VuZCcsICdicnVzaGVkJywgJ2hpZ2hsaWdodCddLmZvckVhY2goZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICBjYW52YXNbbGF5ZXJdID0gc2VsZWN0aW9uLmFwcGVuZCgnY2FudmFzJykuYXR0cignY2xhc3MnLCBsYXllcilbMF1bMF07XG4gICAgICBjdHhbbGF5ZXJdID0gY2FudmFzW2xheWVyXS5nZXRDb250ZXh0KCcyZCcpO1xuICAgIH0pO1xuXG4gICAgLy8gc3ZnIHRpY2sgYW5kIGJydXNoIGxheWVyc1xuICAgIHBjLnN2ZyA9IHNlbGVjdGlvblxuICAgICAgLmFwcGVuZCgnc3ZnJylcbiAgICAgIC5hdHRyKCd3aWR0aCcsIF9fLndpZHRoKVxuICAgICAgLmF0dHIoJ2hlaWdodCcsIF9fLmhlaWdodClcbiAgICAgIC5hcHBlbmQoJ3N2ZzpnJylcbiAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBfXy5tYXJnaW4ubGVmdCArICcsJyArIF9fLm1hcmdpbi50b3AgKyAnKScpO1xuXG4gICAgcmV0dXJuIHBjO1xuICB9O1xuICB2YXIgZXZlbnRzID0gZDMuZGlzcGF0Y2guYXBwbHkoXG4gICAgICB0aGlzLFxuICAgICAgWydyZW5kZXInLCAncmVzaXplJywgJ2hpZ2hsaWdodCcsICdicnVzaCcsICdicnVzaGVuZCcsICdheGVzcmVvcmRlciddLmNvbmNhdChkMy5rZXlzKF9fKSksXG4gICAgKSxcbiAgICB3ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9fLndpZHRoIC0gX18ubWFyZ2luLnJpZ2h0IC0gX18ubWFyZ2luLmxlZnQ7XG4gICAgfSxcbiAgICBoID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9fLmhlaWdodCAtIF9fLm1hcmdpbi50b3AgLSBfXy5tYXJnaW4uYm90dG9tO1xuICAgIH0sXG4gICAgZmxhZ3MgPSB7XG4gICAgICBicnVzaGFibGU6IGZhbHNlLFxuICAgICAgcmVvcmRlcmFibGU6IGZhbHNlLFxuICAgICAgYXhlczogZmFsc2UsXG4gICAgICBpbnRlcmFjdGl2ZTogZmFsc2UsXG4gICAgICBkZWJ1ZzogZmFsc2UsXG4gICAgfSxcbiAgICB4c2NhbGUgPSBkMy5zY2FsZS5vcmRpbmFsKCksXG4gICAgeXNjYWxlID0ge30sXG4gICAgZHJhZ2dpbmcgPSB7fSxcbiAgICBsaW5lID0gZDMuc3ZnLmxpbmUoKSxcbiAgICBheGlzID0gZDMuc3ZnLmF4aXMoKS5vcmllbnQoJ2xlZnQnKS50aWNrcyg1KSxcbiAgICBnLCAvLyBncm91cHMgZm9yIGF4ZXMsIGJydXNoZXNcbiAgICBjdHggPSB7fSxcbiAgICBjYW52YXMgPSB7fSxcbiAgICBjbHVzdGVyQ2VudHJvaWRzID0gW107XG5cbiAgLy8gc2lkZSBlZmZlY3RzIGZvciBzZXR0ZXJzXG4gIHZhciBzaWRlX2VmZmVjdHMgPSBkMy5kaXNwYXRjaFxuICAgIC5hcHBseSh0aGlzLCBkMy5rZXlzKF9fKSlcbiAgICAub24oJ2NvbXBvc2l0ZScsIGZ1bmN0aW9uIChkKSB7XG4gICAgICBjdHguZm9yZWdyb3VuZC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBkLnZhbHVlO1xuICAgICAgY3R4LmJydXNoZWQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gZC52YWx1ZTtcbiAgICB9KVxuICAgIC5vbignYWxwaGEnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgY3R4LmZvcmVncm91bmQuZ2xvYmFsQWxwaGEgPSBkLnZhbHVlO1xuICAgICAgY3R4LmJydXNoZWQuZ2xvYmFsQWxwaGEgPSBkLnZhbHVlO1xuICAgIH0pXG4gICAgLm9uKCdicnVzaGVkQ29sb3InLCBmdW5jdGlvbiAoZCkge1xuICAgICAgY3R4LmJydXNoZWQuc3Ryb2tlU3R5bGUgPSBkLnZhbHVlO1xuICAgIH0pXG4gICAgLm9uKCd3aWR0aCcsIGZ1bmN0aW9uIChkKSB7XG4gICAgICBwYy5yZXNpemUoKTtcbiAgICB9KVxuICAgIC5vbignaGVpZ2h0JywgZnVuY3Rpb24gKGQpIHtcbiAgICAgIHBjLnJlc2l6ZSgpO1xuICAgIH0pXG4gICAgLm9uKCdtYXJnaW4nLCBmdW5jdGlvbiAoZCkge1xuICAgICAgcGMucmVzaXplKCk7XG4gICAgfSlcbiAgICAub24oJ3JhdGUnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgYnJ1c2hlZFF1ZXVlLnJhdGUoZC52YWx1ZSk7XG4gICAgICBmb3JlZ3JvdW5kUXVldWUucmF0ZShkLnZhbHVlKTtcbiAgICB9KVxuICAgIC5vbignZGltZW5zaW9ucycsIGZ1bmN0aW9uIChkKSB7XG4gICAgICB4c2NhbGUuZG9tYWluKF9fLmRpbWVuc2lvbnMpO1xuICAgICAgaWYgKGZsYWdzLmludGVyYWN0aXZlKSB7XG4gICAgICAgIHBjLnJlbmRlcigpLnVwZGF0ZUF4ZXMoKTtcbiAgICAgIH1cbiAgICB9KVxuICAgIC5vbignYnVuZGxlRGltZW5zaW9uJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgIGlmICghX18uZGltZW5zaW9ucy5sZW5ndGgpIHBjLmRldGVjdERpbWVuc2lvbnMoKTtcbiAgICAgIGlmICghKF9fLmRpbWVuc2lvbnNbMF0gaW4geXNjYWxlKSkgcGMuYXV0b3NjYWxlKCk7XG4gICAgICBpZiAodHlwZW9mIGQudmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChkLnZhbHVlIDwgX18uZGltZW5zaW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICBfXy5idW5kbGVEaW1lbnNpb24gPSBfXy5kaW1lbnNpb25zW2QudmFsdWVdO1xuICAgICAgICB9IGVsc2UgaWYgKGQudmFsdWUgPCBfXy5oaWRlQXhpcy5sZW5ndGgpIHtcbiAgICAgICAgICBfXy5idW5kbGVEaW1lbnNpb24gPSBfXy5oaWRlQXhpc1tkLnZhbHVlXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX18uYnVuZGxlRGltZW5zaW9uID0gZC52YWx1ZTtcbiAgICAgIH1cblxuICAgICAgX18uY2x1c3RlckNlbnRyb2lkcyA9IGNvbXB1dGVfY2x1c3Rlcl9jZW50cm9pZHMoX18uYnVuZGxlRGltZW5zaW9uKTtcbiAgICB9KVxuICAgIC5vbignaGlkZUF4aXMnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgaWYgKCFfXy5kaW1lbnNpb25zLmxlbmd0aCkgcGMuZGV0ZWN0RGltZW5zaW9ucygpO1xuICAgICAgcGMuZGltZW5zaW9ucyh3aXRob3V0KF9fLmRpbWVuc2lvbnMsIGQudmFsdWUpKTtcbiAgICB9KTtcblxuICAvLyBleHBvc2UgdGhlIHN0YXRlIG9mIHRoZSBjaGFydFxuICBwYy5zdGF0ZSA9IF9fO1xuICBwYy5mbGFncyA9IGZsYWdzO1xuXG4gIC8vIGNyZWF0ZSBnZXR0ZXIvc2V0dGVyc1xuICBnZXRzZXQocGMsIF9fLCBldmVudHMpO1xuXG4gIC8vIGV4cG9zZSBldmVudHNcbiAgZDMucmViaW5kKHBjLCBldmVudHMsICdvbicpO1xuXG4gIC8vIGdldHRlci9zZXR0ZXIgd2l0aCBldmVudCBmaXJpbmdcbiAgZnVuY3Rpb24gZ2V0c2V0KG9iaiwgc3RhdGUsIGV2ZW50cykge1xuICAgIGQzLmtleXMoc3RhdGUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgb2JqW2tleV0gPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGVba2V5XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb2xkID0gc3RhdGVba2V5XTtcbiAgICAgICAgc3RhdGVba2V5XSA9IHg7XG4gICAgICAgIHNpZGVfZWZmZWN0c1trZXldLmNhbGwocGMsIHsgdmFsdWU6IHgsIHByZXZpb3VzOiBvbGQgfSk7XG4gICAgICAgIGV2ZW50c1trZXldLmNhbGwocGMsIHsgdmFsdWU6IHgsIHByZXZpb3VzOiBvbGQgfSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCwgc291cmNlKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdpdGhvdXQoYXJyLCBpdGVtKSB7XG4gICAgcmV0dXJuIGFyci5maWx0ZXIoZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgIHJldHVybiBpdGVtLmluZGV4T2YoZWxlbSkgPT09IC0xO1xuICAgIH0pO1xuICB9XG4gIC8qKiBhZGp1c3RzIGFuIGF4aXMnIGRlZmF1bHQgcmFuZ2UgW2goKSsxLCAxXSBpZiBhIE51bGxWYWx1ZVNlcGFyYXRvciBpcyBzZXQgKi9cbiAgZnVuY3Rpb24gZ2V0UmFuZ2UoKSB7XG4gICAgaWYgKF9fLm51bGxWYWx1ZVNlcGFyYXRvciA9PSAnYm90dG9tJykge1xuICAgICAgcmV0dXJuIFtoKCkgKyAxIC0gX18ubnVsbFZhbHVlU2VwYXJhdG9yUGFkZGluZy5ib3R0b20gLSBfXy5udWxsVmFsdWVTZXBhcmF0b3JQYWRkaW5nLnRvcCwgMV07XG4gICAgfSBlbHNlIGlmIChfXy5udWxsVmFsdWVTZXBhcmF0b3IgPT0gJ3RvcCcpIHtcbiAgICAgIHJldHVybiBbaCgpICsgMSwgMSArIF9fLm51bGxWYWx1ZVNlcGFyYXRvclBhZGRpbmcuYm90dG9tICsgX18ubnVsbFZhbHVlU2VwYXJhdG9yUGFkZGluZy50b3BdO1xuICAgIH1cbiAgICByZXR1cm4gW2goKSArIDEsIDFdO1xuICB9XG5cbiAgcGMuYXV0b3NjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHlzY2FsZVxuICAgIHZhciBkZWZhdWx0U2NhbGVzID0ge1xuICAgICAgZGF0ZTogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgdmFyIGV4dGVudCA9IGQzLmV4dGVudChfXy5kYXRhLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBkW2tdID8gZFtrXS5nZXRUaW1lKCkgOiBudWxsO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBzcGVjaWFsIGNhc2UgaWYgc2luZ2xlIHZhbHVlXG4gICAgICAgIGlmIChleHRlbnRbMF0gPT09IGV4dGVudFsxXSkge1xuICAgICAgICAgIHJldHVybiBkMy5zY2FsZS5vcmRpbmFsKCkuZG9tYWluKFtleHRlbnRbMF1dKS5yYW5nZVBvaW50cyhnZXRSYW5nZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkMy50aW1lLnNjYWxlKCkuZG9tYWluKGV4dGVudCkucmFuZ2UoZ2V0UmFuZ2UoKSk7XG4gICAgICB9LFxuICAgICAgbnVtYmVyOiBmdW5jdGlvbiAoaykge1xuICAgICAgICB2YXIgZXh0ZW50ID0gZDMuZXh0ZW50KF9fLmRhdGEsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuICtkW2tdO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBzcGVjaWFsIGNhc2UgaWYgc2luZ2xlIHZhbHVlXG4gICAgICAgIGlmIChleHRlbnRbMF0gPT09IGV4dGVudFsxXSkge1xuICAgICAgICAgIHJldHVybiBkMy5zY2FsZS5vcmRpbmFsKCkuZG9tYWluKFtleHRlbnRbMF1dKS5yYW5nZVBvaW50cyhnZXRSYW5nZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkMy5zY2FsZS5saW5lYXIoKS5kb21haW4oZXh0ZW50KS5yYW5nZShnZXRSYW5nZSgpKTtcbiAgICAgIH0sXG4gICAgICBzdHJpbmc6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHZhciBjb3VudHMgPSB7fSxcbiAgICAgICAgICBkb21haW4gPSBbXTtcblxuICAgICAgICAvLyBMZXQncyBnZXQgdGhlIGNvdW50IGZvciBlYWNoIHZhbHVlIHNvIHRoYXQgd2UgY2FuIHNvcnQgdGhlIGRvbWFpbiBiYXNlZFxuICAgICAgICAvLyBvbiB0aGUgbnVtYmVyIG9mIGl0ZW1zIGZvciBlYWNoIHZhbHVlLlxuICAgICAgICBfXy5kYXRhLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgICAgIGlmIChwW2tdID09PSB1bmRlZmluZWQgJiYgX18ubnVsbFZhbHVlU2VwYXJhdG9yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBudWxsIHZhbHVlcyB3aWxsIGJlIGRyYXduIGJleW9uZCB0aGUgaG9yaXpvbnRhbCBudWxsIHZhbHVlIHNlcGFyYXRvciFcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvdW50c1twW2tdXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb3VudHNbcFtrXV0gPSAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb3VudHNbcFtrXV0gPSBjb3VudHNbcFtrXV0gKyAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZG9tYWluID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY291bnRzKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgcmV0dXJuIGNvdW50c1thXSAtIGNvdW50c1tiXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGQzLnNjYWxlLm9yZGluYWwoKS5kb21haW4oZG9tYWluKS5yYW5nZVBvaW50cyhnZXRSYW5nZSgpKTtcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIF9fLmRpbWVuc2lvbnMuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgeXNjYWxlW2tdID0gZGVmYXVsdFNjYWxlc1tfXy50eXBlc1trXV0oayk7XG4gICAgfSk7XG5cbiAgICBfXy5oaWRlQXhpcy5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICB5c2NhbGVba10gPSBkZWZhdWx0U2NhbGVzW19fLnR5cGVzW2tdXShrKTtcbiAgICB9KTtcblxuICAgIC8vIHhzY2FsZVxuICAgIHhzY2FsZS5yYW5nZVBvaW50cyhbMCwgdygpXSwgMSk7XG5cbiAgICAvLyBjYW52YXMgc2l6ZXNcbiAgICBwYy5zZWxlY3Rpb25cbiAgICAgIC5zZWxlY3RBbGwoJ2NhbnZhcycpXG4gICAgICAuc3R5bGUoJ21hcmdpbi10b3AnLCBfXy5tYXJnaW4udG9wICsgJ3B4JylcbiAgICAgIC5zdHlsZSgnbWFyZ2luLWxlZnQnLCBfXy5tYXJnaW4ubGVmdCArICdweCcpXG4gICAgICAuYXR0cignd2lkdGgnLCB3KCkgKyAyKVxuICAgICAgLmF0dHIoJ2hlaWdodCcsIGgoKSArIDIpO1xuXG4gICAgLy8gZGVmYXVsdCBzdHlsZXMsIG5lZWRzIHRvIGJlIHNldCB3aGVuIGNhbnZhcyB3aWR0aCBjaGFuZ2VzXG4gICAgY3R4LmZvcmVncm91bmQuc3Ryb2tlU3R5bGUgPSBfXy5jb2xvcjtcbiAgICBjdHguZm9yZWdyb3VuZC5saW5lV2lkdGggPSAxLjQ7XG4gICAgY3R4LmZvcmVncm91bmQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gX18uY29tcG9zaXRlO1xuICAgIGN0eC5mb3JlZ3JvdW5kLmdsb2JhbEFscGhhID0gX18uYWxwaGE7XG4gICAgY3R4LmJydXNoZWQuc3Ryb2tlU3R5bGUgPSBfXy5icnVzaGVkQ29sb3I7XG4gICAgY3R4LmJydXNoZWQubGluZVdpZHRoID0gMS40O1xuICAgIGN0eC5icnVzaGVkLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IF9fLmNvbXBvc2l0ZTtcbiAgICBjdHguYnJ1c2hlZC5nbG9iYWxBbHBoYSA9IF9fLmFscGhhO1xuICAgIGN0eC5oaWdobGlnaHQubGluZVdpZHRoID0gMztcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHBjLnNjYWxlID0gZnVuY3Rpb24gKGQsIGRvbWFpbikge1xuICAgIHlzY2FsZVtkXS5kb21haW4oZG9tYWluKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHBjLmZsaXAgPSBmdW5jdGlvbiAoZCkge1xuICAgIC8veXNjYWxlW2RdLmRvbWFpbigpLnJldmVyc2UoKTsgICAgICAgICAvLyBkb2VzIG5vdCB3b3JrXG4gICAgeXNjYWxlW2RdLmRvbWFpbih5c2NhbGVbZF0uZG9tYWluKCkucmV2ZXJzZSgpKTsgLy8gd29ya3NcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHBjLmNvbW1vblNjYWxlID0gZnVuY3Rpb24gKGdsb2JhbCwgdHlwZSkge1xuICAgIHZhciB0ID0gdHlwZSB8fCAnbnVtYmVyJztcbiAgICBpZiAodHlwZW9mIGdsb2JhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGdsb2JhbCA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gc2NhbGVzIG9mIHRoZSBzYW1lIHR5cGVcbiAgICB2YXIgc2NhbGVzID0gX18uZGltZW5zaW9ucy5jb25jYXQoX18uaGlkZUF4aXMpLmZpbHRlcihmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuIF9fLnR5cGVzW3BdID09IHQ7XG4gICAgfSk7XG5cbiAgICBpZiAoZ2xvYmFsKSB7XG4gICAgICB2YXIgZXh0ZW50ID0gZDMuZXh0ZW50KFxuICAgICAgICBzY2FsZXNcbiAgICAgICAgICAubWFwKGZ1bmN0aW9uIChwLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4geXNjYWxlW3BdLmRvbWFpbigpO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEuY29uY2F0KGIpO1xuICAgICAgICAgIH0pLFxuICAgICAgKTtcblxuICAgICAgc2NhbGVzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgeXNjYWxlW2RdLmRvbWFpbihleHRlbnQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjYWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHlzY2FsZVtrXS5kb21haW4oXG4gICAgICAgICAgZDMuZXh0ZW50KF9fLmRhdGEsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gK2Rba107XG4gICAgICAgICAgfSksXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgY2VudHJvaWRzXG4gICAgaWYgKF9fLmJ1bmRsZURpbWVuc2lvbiAhPT0gbnVsbCkge1xuICAgICAgcGMuYnVuZGxlRGltZW5zaW9uKF9fLmJ1bmRsZURpbWVuc2lvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIHBjLmRldGVjdERpbWVuc2lvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcGMudHlwZXMocGMuZGV0ZWN0RGltZW5zaW9uVHlwZXMoX18uZGF0YSkpO1xuICAgIHBjLmRpbWVuc2lvbnMoZDMua2V5cyhwYy50eXBlcygpKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gYSBiZXR0ZXIgXCJ0eXBlb2ZcIiBmcm9tIHRoaXMgcG9zdDogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83MzkwNDI2L2JldHRlci13YXktdG8tZ2V0LXR5cGUtb2YtYS1qYXZhc2NyaXB0LXZhcmlhYmxlXG4gIHBjLnRvVHlwZSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIHt9LnRvU3RyaW5nXG4gICAgICAuY2FsbCh2KVxuICAgICAgLm1hdGNoKC9cXHMoW2EtekEtWl0rKS8pWzFdXG4gICAgICAudG9Mb3dlckNhc2UoKTtcbiAgfTtcblxuICAvLyB0cnkgdG8gY29lcmNlIHRvIG51bWJlciBiZWZvcmUgcmV0dXJuaW5nIHR5cGVcbiAgcGMudG9UeXBlQ29lcmNlTnVtYmVycyA9IGZ1bmN0aW9uICh2KSB7XG4gICAgaWYgKHBhcnNlRmxvYXQodikgPT0gdiAmJiB2ICE9IG51bGwpIHtcbiAgICAgIHJldHVybiAnbnVtYmVyJztcbiAgICB9XG4gICAgcmV0dXJuIHBjLnRvVHlwZSh2KTtcbiAgfTtcblxuICAvLyBhdHRlbXB0IHRvIGRldGVybWluZSB0eXBlcyBvZiBlYWNoIGRpbWVuc2lvbiBiYXNlZCBvbiBmaXJzdCByb3cgb2YgZGF0YVxuICBwYy5kZXRlY3REaW1lbnNpb25UeXBlcyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIHR5cGVzID0ge307XG4gICAgZDMua2V5cyhkYXRhWzBdKS5mb3JFYWNoKGZ1bmN0aW9uIChjb2wpIHtcbiAgICAgIHR5cGVzW2NvbF0gPSBwYy50b1R5cGVDb2VyY2VOdW1iZXJzKGRhdGFbMF1bY29sXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHR5cGVzO1xuICB9O1xuICBwYy5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gdHJ5IHRvIGF1dG9kZXRlY3QgZGltZW5zaW9ucyBhbmQgY3JlYXRlIHNjYWxlc1xuICAgIGlmICghX18uZGltZW5zaW9ucy5sZW5ndGgpIHBjLmRldGVjdERpbWVuc2lvbnMoKTtcbiAgICBpZiAoIShfXy5kaW1lbnNpb25zWzBdIGluIHlzY2FsZSkpIHBjLmF1dG9zY2FsZSgpO1xuXG4gICAgcGMucmVuZGVyW19fLm1vZGVdKCk7XG5cbiAgICBldmVudHMucmVuZGVyLmNhbGwodGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcGMucmVuZGVyQnJ1c2hlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIV9fLmRpbWVuc2lvbnMubGVuZ3RoKSBwYy5kZXRlY3REaW1lbnNpb25zKCk7XG4gICAgaWYgKCEoX18uZGltZW5zaW9uc1swXSBpbiB5c2NhbGUpKSBwYy5hdXRvc2NhbGUoKTtcblxuICAgIHBjLnJlbmRlckJydXNoZWRbX18ubW9kZV0oKTtcblxuICAgIGV2ZW50cy5yZW5kZXIuY2FsbCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBmdW5jdGlvbiBpc0JydXNoZWQoKSB7XG4gICAgaWYgKF9fLmJydXNoZWQgJiYgX18uYnJ1c2hlZC5sZW5ndGggIT09IF9fLmRhdGEubGVuZ3RoKSByZXR1cm4gdHJ1ZTtcblxuICAgIHZhciBvYmplY3QgPSBicnVzaC5jdXJyZW50TW9kZSgpLmJydXNoU3RhdGUoKTtcblxuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcGMucmVuZGVyLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcGMuY2xlYXIoJ2ZvcmVncm91bmQnKTtcbiAgICBwYy5jbGVhcignaGlnaGxpZ2h0Jyk7XG5cbiAgICBwYy5yZW5kZXJCcnVzaGVkLmRlZmF1bHQoKTtcblxuICAgIF9fLmRhdGEuZm9yRWFjaChwYXRoX2ZvcmVncm91bmQpO1xuICB9O1xuXG4gIHZhciBmb3JlZ3JvdW5kUXVldWUgPSBkM1xuICAgIC5yZW5kZXJRdWV1ZShwYXRoX2ZvcmVncm91bmQpXG4gICAgLnJhdGUoNTApXG4gICAgLmNsZWFyKGZ1bmN0aW9uICgpIHtcbiAgICAgIHBjLmNsZWFyKCdmb3JlZ3JvdW5kJyk7XG4gICAgICBwYy5jbGVhcignaGlnaGxpZ2h0Jyk7XG4gICAgfSk7XG5cbiAgcGMucmVuZGVyLnF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICAgIHBjLnJlbmRlckJydXNoZWQucXVldWUoKTtcblxuICAgIGZvcmVncm91bmRRdWV1ZShfXy5kYXRhKTtcbiAgfTtcblxuICBwYy5yZW5kZXJCcnVzaGVkLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcGMuY2xlYXIoJ2JydXNoZWQnKTtcblxuICAgIGlmIChpc0JydXNoZWQoKSkge1xuICAgICAgX18uYnJ1c2hlZC5mb3JFYWNoKHBhdGhfYnJ1c2hlZCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBicnVzaGVkUXVldWUgPSBkM1xuICAgIC5yZW5kZXJRdWV1ZShwYXRoX2JydXNoZWQpXG4gICAgLnJhdGUoNTApXG4gICAgLmNsZWFyKGZ1bmN0aW9uICgpIHtcbiAgICAgIHBjLmNsZWFyKCdicnVzaGVkJyk7XG4gICAgfSk7XG5cbiAgcGMucmVuZGVyQnJ1c2hlZC5xdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaXNCcnVzaGVkKCkpIHtcbiAgICAgIGJydXNoZWRRdWV1ZShfXy5icnVzaGVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJ1c2hlZFF1ZXVlKFtdKTsgLy8gVGhpcyBpcyBuZWVkZWQgdG8gY2xlYXIgdGhlIGN1cnJlbnRseSBicnVzaGVkIGl0ZW1zXG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBjb21wdXRlX2NsdXN0ZXJfY2VudHJvaWRzKGQpIHtcbiAgICB2YXIgY2x1c3RlckNlbnRyb2lkcyA9IGQzLm1hcCgpO1xuICAgIHZhciBjbHVzdGVyQ291bnRzID0gZDMubWFwKCk7XG4gICAgLy8gZGV0ZXJtaW5lIGNsdXN0ZXJDb3VudHNcbiAgICBfXy5kYXRhLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgICAgdmFyIHNjYWxlZCA9IHlzY2FsZVtkXShyb3dbZF0pO1xuICAgICAgaWYgKCFjbHVzdGVyQ291bnRzLmhhcyhzY2FsZWQpKSB7XG4gICAgICAgIGNsdXN0ZXJDb3VudHMuc2V0KHNjYWxlZCwgMCk7XG4gICAgICB9XG4gICAgICB2YXIgY291bnQgPSBjbHVzdGVyQ291bnRzLmdldChzY2FsZWQpO1xuICAgICAgY2x1c3RlckNvdW50cy5zZXQoc2NhbGVkLCBjb3VudCArIDEpO1xuICAgIH0pO1xuXG4gICAgX18uZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgIF9fLmRpbWVuc2lvbnMubWFwKGZ1bmN0aW9uIChwLCBpKSB7XG4gICAgICAgIHZhciBzY2FsZWQgPSB5c2NhbGVbZF0ocm93W2RdKTtcbiAgICAgICAgaWYgKCFjbHVzdGVyQ2VudHJvaWRzLmhhcyhzY2FsZWQpKSB7XG4gICAgICAgICAgdmFyIG1hcCA9IGQzLm1hcCgpO1xuICAgICAgICAgIGNsdXN0ZXJDZW50cm9pZHMuc2V0KHNjYWxlZCwgbWFwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNsdXN0ZXJDZW50cm9pZHMuZ2V0KHNjYWxlZCkuaGFzKHApKSB7XG4gICAgICAgICAgY2x1c3RlckNlbnRyb2lkcy5nZXQoc2NhbGVkKS5zZXQocCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlID0gY2x1c3RlckNlbnRyb2lkcy5nZXQoc2NhbGVkKS5nZXQocCk7XG4gICAgICAgIHZhbHVlICs9IHlzY2FsZVtwXShyb3dbcF0pIC8gY2x1c3RlckNvdW50cy5nZXQoc2NhbGVkKTtcbiAgICAgICAgY2x1c3RlckNlbnRyb2lkcy5nZXQoc2NhbGVkKS5zZXQocCwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY2x1c3RlckNlbnRyb2lkcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXB1dGVfY2VudHJvaWRzKHJvdykge1xuICAgIHZhciBjZW50cm9pZHMgPSBbXTtcblxuICAgIHZhciBwID0gX18uZGltZW5zaW9ucztcbiAgICB2YXIgY29scyA9IHAubGVuZ3RoO1xuICAgIHZhciBhID0gMC41OyAvLyBjZW50ZXIgYmV0d2VlbiBheGVzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xzOyArK2kpIHtcbiAgICAgIC8vIGNlbnRyb2lkcyBvbiAncmVhbCcgYXhlc1xuICAgICAgdmFyIHggPSBwb3NpdGlvbihwW2ldKTtcbiAgICAgIHZhciB5ID0geXNjYWxlW3BbaV1dKHJvd1twW2ldXSk7XG4gICAgICBjZW50cm9pZHMucHVzaCgkVihbeCwgeV0pKTtcblxuICAgICAgLy8gY2VudHJvaWRzIG9uICd2aXJ0dWFsJyBheGVzXG4gICAgICBpZiAoaSA8IGNvbHMgLSAxKSB7XG4gICAgICAgIHZhciBjeCA9IHggKyBhICogKHBvc2l0aW9uKHBbaSArIDFdKSAtIHgpO1xuICAgICAgICB2YXIgY3kgPSB5ICsgYSAqICh5c2NhbGVbcFtpICsgMV1dKHJvd1twW2kgKyAxXV0pIC0geSk7XG4gICAgICAgIGlmIChfXy5idW5kbGVEaW1lbnNpb24gIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgbGVmdENlbnRyb2lkID0gX18uY2x1c3RlckNlbnRyb2lkc1xuICAgICAgICAgICAgLmdldCh5c2NhbGVbX18uYnVuZGxlRGltZW5zaW9uXShyb3dbX18uYnVuZGxlRGltZW5zaW9uXSkpXG4gICAgICAgICAgICAuZ2V0KHBbaV0pO1xuICAgICAgICAgIHZhciByaWdodENlbnRyb2lkID0gX18uY2x1c3RlckNlbnRyb2lkc1xuICAgICAgICAgICAgLmdldCh5c2NhbGVbX18uYnVuZGxlRGltZW5zaW9uXShyb3dbX18uYnVuZGxlRGltZW5zaW9uXSkpXG4gICAgICAgICAgICAuZ2V0KHBbaSArIDFdKTtcbiAgICAgICAgICB2YXIgY2VudHJvaWQgPSAwLjUgKiAobGVmdENlbnRyb2lkICsgcmlnaHRDZW50cm9pZCk7XG4gICAgICAgICAgY3kgPSBjZW50cm9pZCArICgxIC0gX18uYnVuZGxpbmdTdHJlbmd0aCkgKiAoY3kgLSBjZW50cm9pZCk7XG4gICAgICAgIH1cbiAgICAgICAgY2VudHJvaWRzLnB1c2goJFYoW2N4LCBjeV0pKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2VudHJvaWRzO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcHV0ZV9jb250cm9sX3BvaW50cyhjZW50cm9pZHMpIHtcbiAgICB2YXIgY29scyA9IGNlbnRyb2lkcy5sZW5ndGg7XG4gICAgdmFyIGEgPSBfXy5zbW9vdGhuZXNzO1xuICAgIHZhciBjcHMgPSBbXTtcblxuICAgIGNwcy5wdXNoKGNlbnRyb2lkc1swXSk7XG4gICAgY3BzLnB1c2goXG4gICAgICAkVihbY2VudHJvaWRzWzBdLmUoMSkgKyBhICogMiAqIChjZW50cm9pZHNbMV0uZSgxKSAtIGNlbnRyb2lkc1swXS5lKDEpKSwgY2VudHJvaWRzWzBdLmUoMildKSxcbiAgICApO1xuICAgIGZvciAodmFyIGNvbCA9IDE7IGNvbCA8IGNvbHMgLSAxOyArK2NvbCkge1xuICAgICAgdmFyIG1pZCA9IGNlbnRyb2lkc1tjb2xdO1xuICAgICAgdmFyIGxlZnQgPSBjZW50cm9pZHNbY29sIC0gMV07XG4gICAgICB2YXIgcmlnaHQgPSBjZW50cm9pZHNbY29sICsgMV07XG5cbiAgICAgIHZhciBkaWZmID0gbGVmdC5zdWJ0cmFjdChyaWdodCk7XG4gICAgICBjcHMucHVzaChtaWQuYWRkKGRpZmYueChhKSkpO1xuICAgICAgY3BzLnB1c2gobWlkKTtcbiAgICAgIGNwcy5wdXNoKG1pZC5zdWJ0cmFjdChkaWZmLngoYSkpKTtcbiAgICB9XG4gICAgY3BzLnB1c2goXG4gICAgICAkVihbXG4gICAgICAgIGNlbnRyb2lkc1tjb2xzIC0gMV0uZSgxKSArIGEgKiAyICogKGNlbnRyb2lkc1tjb2xzIC0gMl0uZSgxKSAtIGNlbnRyb2lkc1tjb2xzIC0gMV0uZSgxKSksXG4gICAgICAgIGNlbnRyb2lkc1tjb2xzIC0gMV0uZSgyKSxcbiAgICAgIF0pLFxuICAgICk7XG4gICAgY3BzLnB1c2goY2VudHJvaWRzW2NvbHMgLSAxXSk7XG5cbiAgICByZXR1cm4gY3BzO1xuICB9XG5cbiAgcGMuc2hhZG93cyA9IGZ1bmN0aW9uICgpIHtcbiAgICBmbGFncy5zaGFkb3dzID0gdHJ1ZTtcbiAgICBwYy5hbHBoYU9uQnJ1c2hlZCgwLjEpO1xuICAgIHBjLnJlbmRlcigpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIGRyYXcgZG90cyB3aXRoIHJhZGl1cyByIG9uIHRoZSBheGlzIGxpbmUgd2hlcmUgZGF0YSBpbnRlcnNlY3RzXG4gIHBjLmF4aXNEb3RzID0gZnVuY3Rpb24gKHIpIHtcbiAgICB2YXIgciA9IHIgfHwgMC4xO1xuICAgIHZhciBjdHggPSBwYy5jdHgubWFya3M7XG4gICAgdmFyIHN0YXJ0QW5nbGUgPSAwO1xuICAgIHZhciBlbmRBbmdsZSA9IDIgKiBNYXRoLlBJO1xuICAgIGN0eC5nbG9iYWxBbHBoYSA9IGQzLm1pbihbMSAvIE1hdGgucG93KF9fLmRhdGEubGVuZ3RoLCAxIC8gMiksIDFdKTtcbiAgICBfXy5kYXRhLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgIF9fLmRpbWVuc2lvbnMubWFwKGZ1bmN0aW9uIChwLCBpKSB7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LmFyYyhwb3NpdGlvbihwKSwgeXNjYWxlW3BdKGRbcF0pLCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIGRyYXcgc2luZ2xlIGN1YmljIGJlemllciBjdXJ2ZVxuICBmdW5jdGlvbiBzaW5nbGVfY3VydmUoZCwgY3R4KSB7XG4gICAgdmFyIGNlbnRyb2lkcyA9IGNvbXB1dGVfY2VudHJvaWRzKGQpO1xuICAgIHZhciBjcHMgPSBjb21wdXRlX2NvbnRyb2xfcG9pbnRzKGNlbnRyb2lkcyk7XG5cbiAgICBjdHgubW92ZVRvKGNwc1swXS5lKDEpLCBjcHNbMF0uZSgyKSk7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBjcHMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgIGlmIChfXy5zaG93Q29udHJvbFBvaW50cykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDM7IGogKz0gMSkge1xuICAgICAgICAgIGN0eC5maWxsUmVjdChjcHNbaSArIGpdLmUoMSksIGNwc1tpICsgal0uZSgyKSwgMiwgMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICBjcHNbaV0uZSgxKSxcbiAgICAgICAgY3BzW2ldLmUoMiksXG4gICAgICAgIGNwc1tpICsgMV0uZSgxKSxcbiAgICAgICAgY3BzW2kgKyAxXS5lKDIpLFxuICAgICAgICBjcHNbaSArIDJdLmUoMSksXG4gICAgICAgIGNwc1tpICsgMl0uZSgyKSxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLy8gZHJhdyBzaW5nbGUgcG9seWxpbmVcbiAgZnVuY3Rpb24gY29sb3JfcGF0aChkLCBjdHgpIHtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgaWYgKChfXy5idW5kbGVEaW1lbnNpb24gIT09IG51bGwgJiYgX18uYnVuZGxpbmdTdHJlbmd0aCA+IDApIHx8IF9fLnNtb290aG5lc3MgPiAwKSB7XG4gICAgICBzaW5nbGVfY3VydmUoZCwgY3R4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2luZ2xlX3BhdGgoZCwgY3R4KTtcbiAgICB9XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG5cbiAgLy8gZHJhdyBtYW55IHBvbHlsaW5lcyBvZiB0aGUgc2FtZSBjb2xvclxuICBmdW5jdGlvbiBwYXRocyhkYXRhLCBjdHgpIHtcbiAgICBjdHguY2xlYXJSZWN0KC0xLCAtMSwgdygpICsgMiwgaCgpICsgMik7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgaWYgKChfXy5idW5kbGVEaW1lbnNpb24gIT09IG51bGwgJiYgX18uYnVuZGxpbmdTdHJlbmd0aCA+IDApIHx8IF9fLnNtb290aG5lc3MgPiAwKSB7XG4gICAgICAgIHNpbmdsZV9jdXJ2ZShkLCBjdHgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2luZ2xlX3BhdGgoZCwgY3R4KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cblxuICAvLyByZXR1cm5zIHRoZSB5LXBvc2l0aW9uIGp1c3QgYmV5b25kIHRoZSBzZXBhcmF0aW5nIG51bGwgdmFsdWUgbGluZVxuICBmdW5jdGlvbiBnZXROdWxsUG9zaXRpb24oKSB7XG4gICAgaWYgKF9fLm51bGxWYWx1ZVNlcGFyYXRvciA9PSAnYm90dG9tJykge1xuICAgICAgcmV0dXJuIGgoKSArIDE7XG4gICAgfSBlbHNlIGlmIChfXy5udWxsVmFsdWVTZXBhcmF0b3IgPT0gJ3RvcCcpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgXCJBIHZhbHVlIGlzIE5VTEwsIGJ1dCBudWxsVmFsdWVTZXBhcmF0b3IgaXMgbm90IHNldDsgc2V0IGl0IHRvICdib3R0b20nIG9yICd0b3AnLlwiLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGgoKSArIDE7XG4gIH1cblxuICBmdW5jdGlvbiBzaW5nbGVfcGF0aChkLCBjdHgpIHtcbiAgICBfXy5kaW1lbnNpb25zLm1hcChmdW5jdGlvbiAocCwgaSkge1xuICAgICAgaWYgKGkgPT0gMCkge1xuICAgICAgICBjdHgubW92ZVRvKHBvc2l0aW9uKHApLCB0eXBlb2YgZFtwXSA9PSAndW5kZWZpbmVkJyA/IGdldE51bGxQb3NpdGlvbigpIDogeXNjYWxlW3BdKGRbcF0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eC5saW5lVG8ocG9zaXRpb24ocCksIHR5cGVvZiBkW3BdID09ICd1bmRlZmluZWQnID8gZ2V0TnVsbFBvc2l0aW9uKCkgOiB5c2NhbGVbcF0oZFtwXSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcGF0aF9icnVzaGVkKGQsIGkpIHtcbiAgICBpZiAoX18uYnJ1c2hlZENvbG9yICE9PSBudWxsKSB7XG4gICAgICBjdHguYnJ1c2hlZC5zdHJva2VTdHlsZSA9IGQzLmZ1bmN0b3IoX18uYnJ1c2hlZENvbG9yKShkLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LmJydXNoZWQuc3Ryb2tlU3R5bGUgPSBkMy5mdW5jdG9yKF9fLmNvbG9yKShkLCBpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbG9yX3BhdGgoZCwgY3R4LmJydXNoZWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGF0aF9mb3JlZ3JvdW5kKGQsIGkpIHtcbiAgICBjdHguZm9yZWdyb3VuZC5zdHJva2VTdHlsZSA9IGQzLmZ1bmN0b3IoX18uY29sb3IpKGQsIGkpO1xuICAgIHJldHVybiBjb2xvcl9wYXRoKGQsIGN0eC5mb3JlZ3JvdW5kKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdGhfaGlnaGxpZ2h0KGQsIGkpIHtcbiAgICBjdHguaGlnaGxpZ2h0LnN0cm9rZVN0eWxlID0gZDMuZnVuY3RvcihfXy5jb2xvcikoZCwgaSk7XG4gICAgcmV0dXJuIGNvbG9yX3BhdGgoZCwgY3R4LmhpZ2hsaWdodCk7XG4gIH1cbiAgcGMuY2xlYXIgPSBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICBjdHhbbGF5ZXJdLmNsZWFyUmVjdCgwLCAwLCB3KCkgKyAyLCBoKCkgKyAyKTtcblxuICAgIC8vIFRoaXMgd2lsbCBtYWtlIHN1cmUgdGhhdCB0aGUgZm9yZWdyb3VuZCBpdGVtcyBhcmUgdHJhbnNwYXJlbnRcbiAgICAvLyB3aXRob3V0IHRoZSBuZWVkIGZvciBjaGFuZ2luZyB0aGUgb3BhY2l0eSBzdHlsZSBvZiB0aGUgZm9yZWdyb3VuZCBjYW52YXNcbiAgICAvLyBhcyB0aGlzIHdvdWxkIHN0b3AgdGhlIGNzcyBzdHlsaW5nIGZyb20gd29ya2luZ1xuICAgIGlmIChsYXllciA9PT0gJ2JydXNoZWQnICYmIGlzQnJ1c2hlZCgpKSB7XG4gICAgICBjdHguYnJ1c2hlZC5maWxsU3R5bGUgPSBwYy5zZWxlY3Rpb24uc3R5bGUoJ2JhY2tncm91bmQtY29sb3InKTtcbiAgICAgIGN0eC5icnVzaGVkLmdsb2JhbEFscGhhID0gMSAtIF9fLmFscGhhT25CcnVzaGVkO1xuICAgICAgY3R4LmJydXNoZWQuZmlsbFJlY3QoMCwgMCwgdygpICsgMiwgaCgpICsgMik7XG4gICAgICBjdHguYnJ1c2hlZC5nbG9iYWxBbHBoYSA9IF9fLmFscGhhO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBkMy5yZWJpbmQoXG4gICAgcGMsXG4gICAgYXhpcyxcbiAgICAndGlja3MnLFxuICAgICdvcmllbnQnLFxuICAgICd0aWNrVmFsdWVzJyxcbiAgICAndGlja1N1YmRpdmlkZScsXG4gICAgJ3RpY2tTaXplJyxcbiAgICAndGlja1BhZGRpbmcnLFxuICAgICd0aWNrRm9ybWF0JyxcbiAgKTtcblxuICBmdW5jdGlvbiBmbGlwQXhpc0FuZFVwZGF0ZVBDUChkaW1lbnNpb24pIHtcbiAgICB2YXIgZyA9IHBjLnN2Zy5zZWxlY3RBbGwoJy5kaW1lbnNpb24nKTtcblxuICAgIHBjLmZsaXAoZGltZW5zaW9uKTtcblxuICAgIGQzLnNlbGVjdCh0aGlzLnBhcmVudEVsZW1lbnQpLnRyYW5zaXRpb24oKS5kdXJhdGlvbigxMTAwKS5jYWxsKGF4aXMuc2NhbGUoeXNjYWxlW2RpbWVuc2lvbl0pKTtcblxuICAgIHBjLnJlbmRlcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gcm90YXRlTGFiZWxzKCkge1xuICAgIHZhciBkZWx0YSA9IGQzLmV2ZW50LmRlbHRhWTtcbiAgICBkZWx0YSA9IGRlbHRhIDwgMCA/IC01IDogZGVsdGE7XG4gICAgZGVsdGEgPSBkZWx0YSA+IDAgPyA1IDogZGVsdGE7XG5cbiAgICBfXy5kaW1lbnNpb25UaXRsZVJvdGF0aW9uICs9IGRlbHRhO1xuICAgIHBjLnN2Z1xuICAgICAgLnNlbGVjdEFsbCgndGV4dC5sYWJlbCcpXG4gICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLC01KSByb3RhdGUoJyArIF9fLmRpbWVuc2lvblRpdGxlUm90YXRpb24gKyAnKScpO1xuICAgIGQzLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cblxuICBmdW5jdGlvbiBkaW1lbnNpb25MYWJlbHMoZCkge1xuICAgIHJldHVybiBkIGluIF9fLmRpbWVuc2lvblRpdGxlcyA/IF9fLmRpbWVuc2lvblRpdGxlc1tkXSA6IGQ7IC8vIGRpbWVuc2lvbiBkaXNwbGF5IG5hbWVzXG4gIH1cblxuICBwYy5jcmVhdGVBeGVzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChnKSBwYy5yZW1vdmVBeGVzKCk7XG5cbiAgICAvLyBBZGQgYSBncm91cCBlbGVtZW50IGZvciBlYWNoIGRpbWVuc2lvbi5cbiAgICBnID0gcGMuc3ZnXG4gICAgICAuc2VsZWN0QWxsKCcuZGltZW5zaW9uJylcbiAgICAgIC5kYXRhKF9fLmRpbWVuc2lvbnMsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkO1xuICAgICAgfSlcbiAgICAgIC5lbnRlcigpXG4gICAgICAuYXBwZW5kKCdzdmc6ZycpXG4gICAgICAuYXR0cignY2xhc3MnLCAnZGltZW5zaW9uJylcbiAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgeHNjYWxlKGQpICsgJyknO1xuICAgICAgfSk7XG5cbiAgICAvLyBBZGQgYW4gYXhpcyBhbmQgdGl0bGUuXG4gICAgZy5hcHBlbmQoJ3N2ZzpnJylcbiAgICAgIC5hdHRyKCdjbGFzcycsICdheGlzJylcbiAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsMCknKVxuICAgICAgLmVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNhbGwoYXhpcy5zY2FsZSh5c2NhbGVbZF0pKTtcbiAgICAgIH0pXG4gICAgICAuYXBwZW5kKCdzdmc6dGV4dCcpXG4gICAgICAuYXR0cih7XG4gICAgICAgICd0ZXh0LWFuY2hvcic6ICdtaWRkbGUnLFxuICAgICAgICB5OiAwLFxuICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoMCwtNSkgcm90YXRlKCcgKyBfXy5kaW1lbnNpb25UaXRsZVJvdGF0aW9uICsgJyknLFxuICAgICAgICB4OiAwLFxuICAgICAgICBjbGFzczogJ2xhYmVsJyxcbiAgICAgIH0pXG4gICAgICAudGV4dChkaW1lbnNpb25MYWJlbHMpXG4gICAgICAub24oJ2RibGNsaWNrJywgZmxpcEF4aXNBbmRVcGRhdGVQQ1ApXG4gICAgICAub24oJ3doZWVsJywgcm90YXRlTGFiZWxzKTtcblxuICAgIGlmIChfXy5udWxsVmFsdWVTZXBhcmF0b3IgPT0gJ3RvcCcpIHtcbiAgICAgIHBjLnN2Z1xuICAgICAgICAuYXBwZW5kKCdsaW5lJylcbiAgICAgICAgLmF0dHIoJ3gxJywgMClcbiAgICAgICAgLmF0dHIoJ3kxJywgMSArIF9fLm51bGxWYWx1ZVNlcGFyYXRvclBhZGRpbmcudG9wKVxuICAgICAgICAuYXR0cigneDInLCB3KCkpXG4gICAgICAgIC5hdHRyKCd5MicsIDEgKyBfXy5udWxsVmFsdWVTZXBhcmF0b3JQYWRkaW5nLnRvcClcbiAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDEpXG4gICAgICAgIC5hdHRyKCdzdHJva2UnLCAnIzc3NycpXG4gICAgICAgIC5hdHRyKCdmaWxsJywgJ25vbmUnKVxuICAgICAgICAuYXR0cignc2hhcGUtcmVuZGVyaW5nJywgJ2NyaXNwRWRnZXMnKTtcbiAgICB9IGVsc2UgaWYgKF9fLm51bGxWYWx1ZVNlcGFyYXRvciA9PSAnYm90dG9tJykge1xuICAgICAgcGMuc3ZnXG4gICAgICAgIC5hcHBlbmQoJ2xpbmUnKVxuICAgICAgICAuYXR0cigneDEnLCAwKVxuICAgICAgICAuYXR0cigneTEnLCBoKCkgKyAxIC0gX18ubnVsbFZhbHVlU2VwYXJhdG9yUGFkZGluZy5ib3R0b20pXG4gICAgICAgIC5hdHRyKCd4MicsIHcoKSlcbiAgICAgICAgLmF0dHIoJ3kyJywgaCgpICsgMSAtIF9fLm51bGxWYWx1ZVNlcGFyYXRvclBhZGRpbmcuYm90dG9tKVxuICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMSlcbiAgICAgICAgLmF0dHIoJ3N0cm9rZScsICcjNzc3JylcbiAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnbm9uZScpXG4gICAgICAgIC5hdHRyKCdzaGFwZS1yZW5kZXJpbmcnLCAnY3Jpc3BFZGdlcycpO1xuICAgIH1cblxuICAgIGZsYWdzLmF4ZXMgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHBjLnJlbW92ZUF4ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgZy5yZW1vdmUoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBwYy51cGRhdGVBeGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBnX2RhdGEgPSBwYy5zdmcuc2VsZWN0QWxsKCcuZGltZW5zaW9uJykuZGF0YShfXy5kaW1lbnNpb25zKTtcblxuICAgIC8vIEVudGVyXG4gICAgZ19kYXRhXG4gICAgICAuZW50ZXIoKVxuICAgICAgLmFwcGVuZCgnc3ZnOmcnKVxuICAgICAgLmF0dHIoJ2NsYXNzJywgJ2RpbWVuc2lvbicpXG4gICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIHBvc2l0aW9uKHApICsgJyknO1xuICAgICAgfSlcbiAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDApXG4gICAgICAuYXBwZW5kKCdzdmc6ZycpXG4gICAgICAuYXR0cignY2xhc3MnLCAnYXhpcycpXG4gICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLDApJylcbiAgICAgIC5lYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jYWxsKGF4aXMuc2NhbGUoeXNjYWxlW2RdKSk7XG4gICAgICB9KVxuICAgICAgLmFwcGVuZCgnc3ZnOnRleHQnKVxuICAgICAgLmF0dHIoe1xuICAgICAgICAndGV4dC1hbmNob3InOiAnbWlkZGxlJyxcbiAgICAgICAgeTogMCxcbiAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKDAsLTUpIHJvdGF0ZSgnICsgX18uZGltZW5zaW9uVGl0bGVSb3RhdGlvbiArICcpJyxcbiAgICAgICAgeDogMCxcbiAgICAgICAgY2xhc3M6ICdsYWJlbCcsXG4gICAgICB9KVxuICAgICAgLnRleHQoZGltZW5zaW9uTGFiZWxzKVxuICAgICAgLm9uKCdkYmxjbGljaycsIGZsaXBBeGlzQW5kVXBkYXRlUENQKVxuICAgICAgLm9uKCd3aGVlbCcsIHJvdGF0ZUxhYmVscyk7XG5cbiAgICAvLyBVcGRhdGVcbiAgICBnX2RhdGEuYXR0cignb3BhY2l0eScsIDApO1xuICAgIGdfZGF0YVxuICAgICAgLnNlbGVjdCgnLmF4aXMnKVxuICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgLmR1cmF0aW9uKDExMDApXG4gICAgICAuZWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICBkMy5zZWxlY3QodGhpcykuY2FsbChheGlzLnNjYWxlKHlzY2FsZVtkXSkpO1xuICAgICAgfSk7XG4gICAgZ19kYXRhXG4gICAgICAuc2VsZWN0KCcubGFiZWwnKVxuICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgLmR1cmF0aW9uKDExMDApXG4gICAgICAudGV4dChkaW1lbnNpb25MYWJlbHMpXG4gICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLC01KSByb3RhdGUoJyArIF9fLmRpbWVuc2lvblRpdGxlUm90YXRpb24gKyAnKScpO1xuXG4gICAgLy8gRXhpdFxuICAgIGdfZGF0YS5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICBnID0gcGMuc3ZnLnNlbGVjdEFsbCgnLmRpbWVuc2lvbicpO1xuICAgIGcudHJhbnNpdGlvbigpXG4gICAgICAuZHVyYXRpb24oMTEwMClcbiAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgcG9zaXRpb24ocCkgKyAnKSc7XG4gICAgICB9KVxuICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMSk7XG5cbiAgICBwYy5zdmdcbiAgICAgIC5zZWxlY3RBbGwoJy5heGlzJylcbiAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgIC5kdXJhdGlvbigxMTAwKVxuICAgICAgLmVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNhbGwoYXhpcy5zY2FsZSh5c2NhbGVbZF0pKTtcbiAgICAgIH0pO1xuXG4gICAgaWYgKGZsYWdzLmJydXNoYWJsZSkgcGMuYnJ1c2hhYmxlKCk7XG4gICAgaWYgKGZsYWdzLnJlb3JkZXJhYmxlKSBwYy5yZW9yZGVyYWJsZSgpO1xuICAgIGlmIChwYy5icnVzaE1vZGUoKSAhPT0gJ05vbmUnKSB7XG4gICAgICB2YXIgbW9kZSA9IHBjLmJydXNoTW9kZSgpO1xuICAgICAgcGMuYnJ1c2hNb2RlKCdOb25lJyk7XG4gICAgICBwYy5icnVzaE1vZGUobW9kZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIEphc29uIERhdmllcywgaHR0cDovL2JsLm9ja3Mub3JnLzEzNDEyODFcbiAgcGMucmVvcmRlcmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFnKSBwYy5jcmVhdGVBeGVzKCk7XG5cbiAgICBnLnN0eWxlKCdjdXJzb3InLCAnbW92ZScpLmNhbGwoXG4gICAgICBkMy5iZWhhdmlvclxuICAgICAgICAuZHJhZygpXG4gICAgICAgIC5vbignZHJhZ3N0YXJ0JywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICBkcmFnZ2luZ1tkXSA9IHRoaXMuX19vcmlnaW5fXyA9IHhzY2FsZShkKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdkcmFnJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICBkcmFnZ2luZ1tkXSA9IE1hdGgubWluKHcoKSwgTWF0aC5tYXgoMCwgKHRoaXMuX19vcmlnaW5fXyArPSBkMy5ldmVudC5keCkpKTtcbiAgICAgICAgICBfXy5kaW1lbnNpb25zLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBwb3NpdGlvbihhKSAtIHBvc2l0aW9uKGIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHhzY2FsZS5kb21haW4oX18uZGltZW5zaW9ucyk7XG4gICAgICAgICAgcGMucmVuZGVyKCk7XG4gICAgICAgICAgZy5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIHBvc2l0aW9uKGQpICsgJyknO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgICAub24oJ2RyYWdlbmQnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIC8vIExldCdzIHNlZSBpZiB0aGUgb3JkZXIgaGFzIGNoYW5nZWQgYW5kIHNlbmQgb3V0IGFuIGV2ZW50IGlmIHNvLlxuICAgICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgIGogPSBfXy5kaW1lbnNpb25zLmluZGV4T2YoZCksXG4gICAgICAgICAgICBlbGVtID0gdGhpcyxcbiAgICAgICAgICAgIHBhcmVudCA9IHRoaXMucGFyZW50RWxlbWVudDtcblxuICAgICAgICAgIHdoaWxlICgoZWxlbSA9IGVsZW0ucHJldmlvdXNFbGVtZW50U2libGluZykgIT0gbnVsbCkgKytpO1xuICAgICAgICAgIGlmIChpICE9PSBqKSB7XG4gICAgICAgICAgICBldmVudHMuYXhlc3Jlb3JkZXIuY2FsbChwYywgX18uZGltZW5zaW9ucyk7XG4gICAgICAgICAgICAvLyBXZSBub3cgYWxzbyB3YW50IHRvIHJlb3JkZXIgdGhlIGFjdHVhbCBkb20gZWxlbWVudHMgdGhhdCByZXByZXNlbnRcbiAgICAgICAgICAgIC8vIHRoZSBheGVzLiBUaGF0IGlzLCB0aGUgZy5kaW1lbnNpb24gZWxlbWVudHMuIElmIHdlIGRvbid0IGRvIHRoaXMsXG4gICAgICAgICAgICAvLyB3ZSBnZXQgYSB3ZWlyZCBhbmQgY29uZnVzaW5nIHRyYW5zaXRpb24gd2hlbiB1cGRhdGVBeGVzIGlzIGNhbGxlZC5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgZHVlIHRvIHRoZSBmYWN0IHRoYXQsIGluaXRpYWxseSB0aGUgbnRoIGcuZGltZW5zaW9uIGVsZW1lbnRcbiAgICAgICAgICAgIC8vIHJlcHJlc2VudHMgdGhlIG50aCBheGlzLiBIb3dldmVyLCBhZnRlciBhIG1hbnVhbCByZW9yZGVyaW5nLFxuICAgICAgICAgICAgLy8gd2l0aG91dCByZW9yZGVyaW5nIHRoZSBkb20gZWxlbWVudHMsIHRoZSBudGggZG9tIGVsZW1lbnRzIG5vIGxvbmdlclxuICAgICAgICAgICAgLy8gbmVjZXNzYXJpbHkgcmVwcmVzZW50cyB0aGUgbnRoIGF4aXMuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gaSBpcyB0aGUgb3JpZ2luYWwgaW5kZXggb2YgdGhlIGRvbSBlbGVtZW50XG4gICAgICAgICAgICAvLyBqIGlzIHRoZSBuZXcgaW5kZXggb2YgdGhlIGRvbSBlbGVtZW50XG4gICAgICAgICAgICBpZiAoaSA+IGopIHtcbiAgICAgICAgICAgICAgLy8gRWxlbWVudCBtb3ZlZCBsZWZ0XG4gICAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUodGhpcywgcGFyZW50LmNoaWxkcmVuW2ogLSAxXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBFbGVtZW50IG1vdmVkIHJpZ2h0XG4gICAgICAgICAgICAgIGlmIChqICsgMSA8IHBhcmVudC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHRoaXMsIHBhcmVudC5jaGlsZHJlbltqICsgMV0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZCh0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9fb3JpZ2luX187XG4gICAgICAgICAgZGVsZXRlIGRyYWdnaW5nW2RdO1xuICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKVxuICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIHhzY2FsZShkKSArICcpJyk7XG4gICAgICAgICAgcGMucmVuZGVyKCk7XG4gICAgICAgIH0pLFxuICAgICk7XG4gICAgZmxhZ3MucmVvcmRlcmFibGUgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIFJlb3JkZXIgZGltZW5zaW9ucywgc3VjaCB0aGF0IHRoZSBoaWdoZXN0IHZhbHVlICh2aXN1YWxseSkgaXMgb24gdGhlIGxlZnQgYW5kXG4gIC8vIHRoZSBsb3dlc3Qgb24gdGhlIHJpZ2h0LiBWaXN1YWwgdmFsdWVzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBkYXRhIHZhbHVlcyBpblxuICAvLyB0aGUgZ2l2ZW4gcm93LlxuICBwYy5yZW9yZGVyID0gZnVuY3Rpb24gKHJvd2RhdGEpIHtcbiAgICB2YXIgZGltcyA9IF9fLmRpbWVuc2lvbnMuc2xpY2UoMCk7XG4gICAgX18uZGltZW5zaW9ucy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICB2YXIgcGl4ZWxEaWZmZXJlbmNlID0geXNjYWxlW2FdKHJvd2RhdGFbYV0pIC0geXNjYWxlW2JdKHJvd2RhdGFbYl0pO1xuXG4gICAgICAvLyBBcnJheS5zb3J0IGlzIG5vdCBuZWNlc3NhcmlseSBzdGFibGUsIHRoaXMgbWVhbnMgdGhhdCBpZiBwaXhlbERpZmZlcmVuY2UgaXMgemVyb1xuICAgICAgLy8gdGhlIG9yZGVyaW5nIG9mIGRpbWVuc2lvbnMgbWlnaHQgY2hhbmdlIHVuZXhwZWN0ZWRseS4gVGhpcyBpcyBzb2x2ZWQgYnkgc29ydGluZyBvblxuICAgICAgLy8gdmFyaWFibGUgbmFtZSBpbiB0aGF0IGNhc2UuXG4gICAgICBpZiAocGl4ZWxEaWZmZXJlbmNlID09PSAwKSB7XG4gICAgICAgIHJldHVybiBhLmxvY2FsZUNvbXBhcmUoYik7XG4gICAgICB9IC8vIGVsc2VcbiAgICAgIHJldHVybiBwaXhlbERpZmZlcmVuY2U7XG4gICAgfSk7XG5cbiAgICAvLyBOT1RFOiB0aGlzIGlzIHJlbGF0aXZlbHkgY2hlYXAgZ2l2ZW4gdGhhdDpcbiAgICAvLyBudW1iZXIgb2YgZGltZW5zaW9ucyA8IG51bWJlciBvZiBkYXRhIGl0ZW1zXG4gICAgLy8gVGh1cyB3ZSBjaGVjayBlcXVhbGl0eSBvZiBvcmRlciB0byBwcmV2ZW50IHJlcmVuZGVyaW5nIHdoZW4gdGhpcyBpcyB0aGUgY2FzZS5cbiAgICB2YXIgcmVvcmRlcmVkID0gZmFsc2U7XG4gICAgZGltcy5zb21lKGZ1bmN0aW9uICh2YWwsIGluZGV4KSB7XG4gICAgICByZW9yZGVyZWQgPSB2YWwgIT09IF9fLmRpbWVuc2lvbnNbaW5kZXhdO1xuICAgICAgcmV0dXJuIHJlb3JkZXJlZDtcbiAgICB9KTtcblxuICAgIGlmIChyZW9yZGVyZWQpIHtcbiAgICAgIHhzY2FsZS5kb21haW4oX18uZGltZW5zaW9ucyk7XG4gICAgICB2YXIgaGlnaGxpZ2h0ZWQgPSBfXy5oaWdobGlnaHRlZC5zbGljZSgwKTtcbiAgICAgIHBjLnVuaGlnaGxpZ2h0KCk7XG5cbiAgICAgIGcudHJhbnNpdGlvbigpXG4gICAgICAgIC5kdXJhdGlvbigxNTAwKVxuICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgeHNjYWxlKGQpICsgJyknO1xuICAgICAgICB9KTtcbiAgICAgIHBjLnJlbmRlcigpO1xuXG4gICAgICAvLyBwYy5oaWdobGlnaHQoKSBkb2VzIG5vdCBjaGVjayB3aGV0aGVyIGhpZ2hsaWdodGVkIGlzIGxlbmd0aCB6ZXJvLCBzbyB3ZSBkbyB0aGF0IGhlcmUuXG4gICAgICBpZiAoaGlnaGxpZ2h0ZWQubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHBjLmhpZ2hsaWdodChoaWdobGlnaHRlZCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIHBhaXJzIG9mIGFkamFjZW50IGRpbWVuc2lvbnNcbiAgcGMuYWRqYWNlbnRfcGFpcnMgPSBmdW5jdGlvbiAoYXJyKSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aCAtIDE7IGkgKz0gMSkge1xuICAgICAgcmV0LnB1c2goW2FycltpXSwgYXJyW2kgKyAxXV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIHZhciBicnVzaCA9IHtcbiAgICBtb2Rlczoge1xuICAgICAgTm9uZToge1xuICAgICAgICBpbnN0YWxsOiBmdW5jdGlvbiAocGMpIHt9LCAvLyBOb3RoaW5nIHRvIGJlIGRvbmUuXG4gICAgICAgIHVuaW5zdGFsbDogZnVuY3Rpb24gKHBjKSB7fSwgLy8gTm90aGluZyB0byBiZSBkb25lLlxuICAgICAgICBzZWxlY3RlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSwgLy8gTm90aGluZyB0byByZXR1cm5cbiAgICAgICAgYnJ1c2hTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSxcbiAgICBtb2RlOiAnTm9uZScsXG4gICAgcHJlZGljYXRlOiAnQU5EJyxcbiAgICBjdXJyZW50TW9kZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubW9kZXNbdGhpcy5tb2RlXTtcbiAgICB9LFxuICB9O1xuXG4gIC8vIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgZm9yICdsaXZlJyB1cGRhdGVzIG9mIGJydXNoZXMuIFRoYXQgaXMsIGR1cmluZyB0aGVcbiAgLy8gc3BlY2lmaWNhdGlvbiBvZiBhIGJydXNoLCB0aGlzIG1ldGhvZCBjYW4gYmUgY2FsbGVkIHRvIHVwZGF0ZSB0aGUgdmlldy5cbiAgLy9cbiAgLy8gQHBhcmFtIG5ld1NlbGVjdGlvbiAtIFRoZSBuZXcgc2V0IG9mIGRhdGEgaXRlbXMgdGhhdCBpcyBjdXJyZW50bHkgY29udGFpbmVkXG4gIC8vICAgICAgICAgICAgICAgICAgICAgICBieSB0aGUgYnJ1c2hlc1xuICBmdW5jdGlvbiBicnVzaFVwZGF0ZWQobmV3U2VsZWN0aW9uKSB7XG4gICAgX18uYnJ1c2hlZCA9IG5ld1NlbGVjdGlvbjtcbiAgICBldmVudHMuYnJ1c2guY2FsbChwYywgX18uYnJ1c2hlZCk7XG4gICAgcGMucmVuZGVyQnJ1c2hlZCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gYnJ1c2hQcmVkaWNhdGUocHJlZGljYXRlKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gYnJ1c2gucHJlZGljYXRlO1xuICAgIH1cblxuICAgIHByZWRpY2F0ZSA9IFN0cmluZyhwcmVkaWNhdGUpLnRvVXBwZXJDYXNlKCk7XG4gICAgaWYgKHByZWRpY2F0ZSAhPT0gJ0FORCcgJiYgcHJlZGljYXRlICE9PSAnT1InKSB7XG4gICAgICB0aHJvdyAnSW52YWxpZCBwcmVkaWNhdGUgJyArIHByZWRpY2F0ZTtcbiAgICB9XG5cbiAgICBicnVzaC5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgX18uYnJ1c2hlZCA9IGJydXNoLmN1cnJlbnRNb2RlKCkuc2VsZWN0ZWQoKTtcbiAgICBwYy5yZW5kZXJCcnVzaGVkKCk7XG4gICAgcmV0dXJuIHBjO1xuICB9XG5cbiAgcGMuYnJ1c2hNb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYnJ1c2gubW9kZXMpO1xuICB9O1xuXG4gIHBjLmJydXNoTW9kZSA9IGZ1bmN0aW9uIChtb2RlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBicnVzaC5tb2RlO1xuICAgIH1cblxuICAgIGlmIChwYy5icnVzaE1vZGVzKCkuaW5kZXhPZihtb2RlKSA9PT0gLTEpIHtcbiAgICAgIHRocm93ICdwYy5icnVzaG1vZGU6IFVuc3VwcG9ydGVkIGJydXNoIG1vZGU6ICcgKyBtb2RlO1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHdlIGRvbid0IHRyaWdnZXIgdW5uZWNlc3NhcnkgZXZlbnRzIGJ5IGNoZWNraW5nIGlmIHRoZSBtb2RlXG4gICAgLy8gYWN0dWFsbHkgY2hhbmdlcy5cbiAgICBpZiAobW9kZSAhPT0gYnJ1c2gubW9kZSkge1xuICAgICAgLy8gV2hlbiBjaGFuZ2luZyBicnVzaCBtb2RlcywgdGhlIGZpcnN0IHRoaW5nIHdlIG5lZWQgdG8gZG8gaXMgY2xlYXJpbmcgYW55XG4gICAgICAvLyBicnVzaGVzIGZyb20gdGhlIGN1cnJlbnQgbW9kZSwgaWYgYW55LlxuICAgICAgaWYgKGJydXNoLm1vZGUgIT09ICdOb25lJykge1xuICAgICAgICBwYy5icnVzaFJlc2V0KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIE5leHQsIHdlIG5lZWQgdG8gJ3VuaW5zdGFsbCcgdGhlIGN1cnJlbnQgYnJ1c2hNb2RlLlxuICAgICAgYnJ1c2gubW9kZXNbYnJ1c2gubW9kZV0udW5pbnN0YWxsKHBjKTtcbiAgICAgIC8vIEZpbmFsbHksIHdlIGNhbiBpbnN0YWxsIHRoZSByZXF1ZXN0ZWQgb25lLlxuICAgICAgYnJ1c2gubW9kZSA9IG1vZGU7XG4gICAgICBicnVzaC5tb2Rlc1ticnVzaC5tb2RlXS5pbnN0YWxsKCk7XG4gICAgICBpZiAobW9kZSA9PT0gJ05vbmUnKSB7XG4gICAgICAgIGRlbGV0ZSBwYy5icnVzaFByZWRpY2F0ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBjLmJydXNoUHJlZGljYXRlID0gYnJ1c2hQcmVkaWNhdGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBjO1xuICB9O1xuXG4gIC8vIGJydXNoIG1vZGU6IDFELUF4ZXNcblxuICAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBicnVzaGVzID0ge307XG5cbiAgICBmdW5jdGlvbiBpc19icnVzaGVkKHApIHtcbiAgICAgIHJldHVybiAhYnJ1c2hlc1twXS5lbXB0eSgpO1xuICAgIH1cblxuICAgIC8vIGRhdGEgd2l0aGluIGV4dGVudHNcbiAgICBmdW5jdGlvbiBzZWxlY3RlZCgpIHtcbiAgICAgIHZhciBhY3RpdmVzID0gX18uZGltZW5zaW9ucy5maWx0ZXIoaXNfYnJ1c2hlZCksXG4gICAgICAgIGV4dGVudHMgPSBhY3RpdmVzLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgICAgIHJldHVybiBicnVzaGVzW3BdLmV4dGVudCgpO1xuICAgICAgICB9KTtcblxuICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byByZXR1cm4gdGhlIGZ1bGwgZGF0YSBzZXQgd2hlbiB0aGVyZSBhcmUgbm8gYXhlcyBicnVzaGVkLlxuICAgICAgLy8gQWN0dWFsbHksIHdoZW4gdGhlcmUgYXJlIG5vIGF4ZXMgYnJ1c2hlZCwgYnkgZGVmaW5pdGlvbiwgbm8gaXRlbXMgYXJlXG4gICAgICAvLyBzZWxlY3RlZC4gU28sIGxldCdzIGF2b2lkIHRoZSBmaWx0ZXJpbmcgYW5kIGp1c3QgcmV0dXJuIGZhbHNlLlxuICAgICAgLy9pZiAoYWN0aXZlcy5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gUmVzb2x2ZXMgYnJva2VuIGV4YW1wbGVzIGZvciBub3cuIFRoZXkgZXhwZWN0IHRvIGdldCB0aGUgZnVsbCBkYXRhc2V0IGJhY2sgZnJvbSBlbXB0eSBicnVzaGVzXG4gICAgICBpZiAoYWN0aXZlcy5sZW5ndGggPT09IDApIHJldHVybiBfXy5kYXRhO1xuXG4gICAgICAvLyB0ZXN0IGlmIHdpdGhpbiByYW5nZVxuICAgICAgdmFyIHdpdGhpbiA9IHtcbiAgICAgICAgZGF0ZTogZnVuY3Rpb24gKGQsIHAsIGRpbWVuc2lvbikge1xuICAgICAgICAgIGlmICh0eXBlb2YgeXNjYWxlW3BdLnJhbmdlUG9pbnRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBpZiBpdCBpcyBvcmRpbmFsXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICBleHRlbnRzW2RpbWVuc2lvbl1bMF0gPD0geXNjYWxlW3BdKGRbcF0pICYmIHlzY2FsZVtwXShkW3BdKSA8PSBleHRlbnRzW2RpbWVuc2lvbl1bMV1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBleHRlbnRzW2RpbWVuc2lvbl1bMF0gPD0gZFtwXSAmJiBkW3BdIDw9IGV4dGVudHNbZGltZW5zaW9uXVsxXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG51bWJlcjogZnVuY3Rpb24gKGQsIHAsIGRpbWVuc2lvbikge1xuICAgICAgICAgIGlmICh0eXBlb2YgeXNjYWxlW3BdLnJhbmdlUG9pbnRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBpZiBpdCBpcyBvcmRpbmFsXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICBleHRlbnRzW2RpbWVuc2lvbl1bMF0gPD0geXNjYWxlW3BdKGRbcF0pICYmIHlzY2FsZVtwXShkW3BdKSA8PSBleHRlbnRzW2RpbWVuc2lvbl1bMV1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBleHRlbnRzW2RpbWVuc2lvbl1bMF0gPD0gZFtwXSAmJiBkW3BdIDw9IGV4dGVudHNbZGltZW5zaW9uXVsxXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN0cmluZzogZnVuY3Rpb24gKGQsIHAsIGRpbWVuc2lvbikge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBleHRlbnRzW2RpbWVuc2lvbl1bMF0gPD0geXNjYWxlW3BdKGRbcF0pICYmIHlzY2FsZVtwXShkW3BdKSA8PSBleHRlbnRzW2RpbWVuc2lvbl1bMV1cbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIF9fLmRhdGEuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHN3aXRjaCAoYnJ1c2gucHJlZGljYXRlKSB7XG4gICAgICAgICAgY2FzZSAnQU5EJzpcbiAgICAgICAgICAgIHJldHVybiBhY3RpdmVzLmV2ZXJ5KGZ1bmN0aW9uIChwLCBkaW1lbnNpb24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHdpdGhpbltfXy50eXBlc1twXV0oZCwgcCwgZGltZW5zaW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIGNhc2UgJ09SJzpcbiAgICAgICAgICAgIHJldHVybiBhY3RpdmVzLnNvbWUoZnVuY3Rpb24gKHAsIGRpbWVuc2lvbikge1xuICAgICAgICAgICAgICByZXR1cm4gd2l0aGluW19fLnR5cGVzW3BdXShkLCBwLCBkaW1lbnNpb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93ICdVbmtub3duIGJydXNoIHByZWRpY2F0ZSAnICsgX18uYnJ1c2hQcmVkaWNhdGU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJydXNoRXh0ZW50cyhleHRlbnRzKSB7XG4gICAgICBpZiAodHlwZW9mIGV4dGVudHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBleHRlbnRzID0ge307XG4gICAgICAgIF9fLmRpbWVuc2lvbnMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHZhciBicnVzaCA9IGJydXNoZXNbZF07XG4gICAgICAgICAgaWYgKGJydXNoICE9PSB1bmRlZmluZWQgJiYgIWJydXNoLmVtcHR5KCkpIHtcbiAgICAgICAgICAgIHZhciBleHRlbnQgPSBicnVzaC5leHRlbnQoKTtcbiAgICAgICAgICAgIGV4dGVudC5zb3J0KGQzLmFzY2VuZGluZyk7XG4gICAgICAgICAgICBleHRlbnRzW2RdID0gZXh0ZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBleHRlbnRzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy9maXJzdCBnZXQgYWxsIHRoZSBicnVzaCBzZWxlY3Rpb25zXG4gICAgICAgIHZhciBicnVzaFNlbGVjdGlvbnMgPSB7fTtcbiAgICAgICAgZy5zZWxlY3RBbGwoJy5icnVzaCcpLmVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICBicnVzaFNlbGVjdGlvbnNbZF0gPSBkMy5zZWxlY3QodGhpcyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGxvb3Agb3ZlciBlYWNoIGRpbWVuc2lvbiBhbmQgdXBkYXRlIGFwcHJvcHJpYXRlbHkgKGlmIGl0IHdhcyBwYXNzZWQgaW4gdGhyb3VnaCBleHRlbnRzKVxuICAgICAgICBfXy5kaW1lbnNpb25zLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICBpZiAoZXh0ZW50c1tkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGJydXNoID0gYnJ1c2hlc1tkXTtcbiAgICAgICAgICBpZiAoYnJ1c2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy91cGRhdGUgdGhlIGV4dGVudFxuICAgICAgICAgICAgYnJ1c2guZXh0ZW50KGV4dGVudHNbZF0pO1xuXG4gICAgICAgICAgICAvL3JlZHJhdyB0aGUgYnJ1c2hcbiAgICAgICAgICAgIGJydXNoKGJydXNoU2VsZWN0aW9uc1tkXSk7XG5cbiAgICAgICAgICAgIC8vZmlyZSBzb21lIGV2ZW50c1xuICAgICAgICAgICAgYnJ1c2guZXZlbnQoYnJ1c2hTZWxlY3Rpb25zW2RdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vcmVkcmF3IHRoZSBjaGFydFxuICAgICAgICBwYy5yZW5kZXJCcnVzaGVkKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJydXNoRm9yKGF4aXMpIHtcbiAgICAgIHZhciBicnVzaCA9IGQzLnN2Zy5icnVzaCgpO1xuXG4gICAgICBicnVzaFxuICAgICAgICAueSh5c2NhbGVbYXhpc10pXG4gICAgICAgIC5vbignYnJ1c2hzdGFydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoZDMuZXZlbnQuc291cmNlRXZlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGQzLmV2ZW50LnNvdXJjZUV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdicnVzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBicnVzaFVwZGF0ZWQoc2VsZWN0ZWQoKSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignYnJ1c2hlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZXZlbnRzLmJydXNoZW5kLmNhbGwocGMsIF9fLmJydXNoZWQpO1xuICAgICAgICB9KTtcblxuICAgICAgYnJ1c2hlc1theGlzXSA9IGJydXNoO1xuICAgICAgcmV0dXJuIGJydXNoO1xuICAgIH1cbiAgICBmdW5jdGlvbiBicnVzaFJlc2V0KGRpbWVuc2lvbikge1xuICAgICAgX18uYnJ1c2hlZCA9IGZhbHNlO1xuICAgICAgaWYgKGcpIHtcbiAgICAgICAgZy5zZWxlY3RBbGwoJy5icnVzaCcpLmVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICBkMy5zZWxlY3QodGhpcykuY2FsbChicnVzaGVzW2RdLmNsZWFyKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcGMucmVuZGVyQnJ1c2hlZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbCgpIHtcbiAgICAgIGlmICghZykgcGMuY3JlYXRlQXhlcygpO1xuXG4gICAgICAvLyBBZGQgYW5kIHN0b3JlIGEgYnJ1c2ggZm9yIGVhY2ggYXhpcy5cbiAgICAgIGcuYXBwZW5kKCdzdmc6ZycpXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdicnVzaCcpXG4gICAgICAgIC5lYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNhbGwoYnJ1c2hGb3IoZCkpO1xuICAgICAgICB9KVxuICAgICAgICAuc2VsZWN0QWxsKCdyZWN0JylcbiAgICAgICAgLnN0eWxlKCd2aXNpYmlsaXR5JywgbnVsbClcbiAgICAgICAgLmF0dHIoJ3gnLCAtMTUpXG4gICAgICAgIC5hdHRyKCd3aWR0aCcsIDMwKTtcblxuICAgICAgcGMuYnJ1c2hFeHRlbnRzID0gYnJ1c2hFeHRlbnRzO1xuICAgICAgcGMuYnJ1c2hSZXNldCA9IGJydXNoUmVzZXQ7XG4gICAgICByZXR1cm4gcGM7XG4gICAgfVxuXG4gICAgYnJ1c2gubW9kZXNbJzFELWF4ZXMnXSA9IHtcbiAgICAgIGluc3RhbGw6IGluc3RhbGwsXG4gICAgICB1bmluc3RhbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZy5zZWxlY3RBbGwoJy5icnVzaCcpLnJlbW92ZSgpO1xuICAgICAgICBicnVzaGVzID0ge307XG4gICAgICAgIGRlbGV0ZSBwYy5icnVzaEV4dGVudHM7XG4gICAgICAgIGRlbGV0ZSBwYy5icnVzaFJlc2V0O1xuICAgICAgfSxcbiAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZCxcbiAgICAgIGJydXNoU3RhdGU6IGJydXNoRXh0ZW50cyxcbiAgICB9O1xuICB9KSgpO1xuICAvLyBicnVzaCBtb2RlOiAyRC1zdHJ1bXNcbiAgLy8gYmwub2Nrcy5vcmcvc3ludGFnbWF0aWMvNTQ0MTAyMlxuXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0cnVtcyA9IHt9LFxuICAgICAgc3RydW1SZWN0O1xuXG4gICAgZnVuY3Rpb24gZHJhd1N0cnVtKHN0cnVtLCBhY3RpdmVQb2ludCkge1xuICAgICAgdmFyIHN2ZyA9IHBjLnNlbGVjdGlvbi5zZWxlY3QoJ3N2ZycpLnNlbGVjdCgnZyNzdHJ1bXMnKSxcbiAgICAgICAgaWQgPSBzdHJ1bS5kaW1zLmksXG4gICAgICAgIHBvaW50cyA9IFtzdHJ1bS5wMSwgc3RydW0ucDJdLFxuICAgICAgICBsaW5lID0gc3ZnLnNlbGVjdEFsbCgnbGluZSNzdHJ1bS0nICsgaWQpLmRhdGEoW3N0cnVtXSksXG4gICAgICAgIGNpcmNsZXMgPSBzdmcuc2VsZWN0QWxsKCdjaXJjbGUjc3RydW0tJyArIGlkKS5kYXRhKHBvaW50cyksXG4gICAgICAgIGRyYWcgPSBkMy5iZWhhdmlvci5kcmFnKCk7XG5cbiAgICAgIGxpbmVcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZCgnbGluZScpXG4gICAgICAgIC5hdHRyKCdpZCcsICdzdHJ1bS0nICsgaWQpXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdzdHJ1bScpO1xuXG4gICAgICBsaW5lXG4gICAgICAgIC5hdHRyKCd4MScsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIGQucDFbMF07XG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCd5MScsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIGQucDFbMV07XG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCd4MicsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIGQucDJbMF07XG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCd5MicsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIGQucDJbMV07XG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCdzdHJva2UnLCAnYmxhY2snKVxuICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMik7XG5cbiAgICAgIGRyYWdcbiAgICAgICAgLm9uKCdkcmFnJywgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICB2YXIgZXYgPSBkMy5ldmVudDtcbiAgICAgICAgICBpID0gaSArIDE7XG4gICAgICAgICAgc3RydW1bJ3AnICsgaV1bMF0gPSBNYXRoLm1pbihNYXRoLm1heChzdHJ1bS5taW5YICsgMSwgZXYueCksIHN0cnVtLm1heFgpO1xuICAgICAgICAgIHN0cnVtWydwJyArIGldWzFdID0gTWF0aC5taW4oTWF0aC5tYXgoc3RydW0ubWluWSwgZXYueSksIHN0cnVtLm1heFkpO1xuICAgICAgICAgIGRyYXdTdHJ1bShzdHJ1bSwgaSAtIDEpO1xuICAgICAgICB9KVxuICAgICAgICAub24oJ2RyYWdlbmQnLCBvbkRyYWdFbmQoKSk7XG5cbiAgICAgIGNpcmNsZXNcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZCgnY2lyY2xlJylcbiAgICAgICAgLmF0dHIoJ2lkJywgJ3N0cnVtLScgKyBpZClcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3N0cnVtJyk7XG5cbiAgICAgIGNpcmNsZXNcbiAgICAgICAgLmF0dHIoJ2N4JywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gZFswXTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ2N5JywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gZFsxXTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ3InLCA1KVxuICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgIHJldHVybiBhY3RpdmVQb2ludCAhPT0gdW5kZWZpbmVkICYmIGkgPT09IGFjdGl2ZVBvaW50ID8gMC44IDogMDtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnN0eWxlKCdvcGFjaXR5JywgMC44KTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkMy5zZWxlY3QodGhpcykuc3R5bGUoJ29wYWNpdHknLCAwKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhbGwoZHJhZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGltZW5zaW9uc0ZvclBvaW50KHApIHtcbiAgICAgIHZhciBkaW1zID0geyBpOiAtMSwgbGVmdDogdW5kZWZpbmVkLCByaWdodDogdW5kZWZpbmVkIH07XG4gICAgICBfXy5kaW1lbnNpb25zLnNvbWUoZnVuY3Rpb24gKGRpbSwgaSkge1xuICAgICAgICBpZiAoeHNjYWxlKGRpbSkgPCBwWzBdKSB7XG4gICAgICAgICAgdmFyIG5leHQgPSBfXy5kaW1lbnNpb25zW2kgKyAxXTtcbiAgICAgICAgICBkaW1zLmkgPSBpO1xuICAgICAgICAgIGRpbXMubGVmdCA9IGRpbTtcbiAgICAgICAgICBkaW1zLnJpZ2h0ID0gbmV4dDtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGRpbXMubGVmdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIEV2ZW50IG9uIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIGZpcnN0IGF4aXMuXG4gICAgICAgIGRpbXMuaSA9IDA7XG4gICAgICAgIGRpbXMubGVmdCA9IF9fLmRpbWVuc2lvbnNbMF07XG4gICAgICAgIGRpbXMucmlnaHQgPSBfXy5kaW1lbnNpb25zWzFdO1xuICAgICAgfSBlbHNlIGlmIChkaW1zLnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gRXZlbnQgb24gdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGxhc3QgYXhpc1xuICAgICAgICBkaW1zLmkgPSBfXy5kaW1lbnNpb25zLmxlbmd0aCAtIDE7XG4gICAgICAgIGRpbXMucmlnaHQgPSBkaW1zLmxlZnQ7XG4gICAgICAgIGRpbXMubGVmdCA9IF9fLmRpbWVuc2lvbnNbX18uZGltZW5zaW9ucy5sZW5ndGggLSAyXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRpbXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25EcmFnU3RhcnQoKSB7XG4gICAgICAvLyBGaXJzdCB3ZSBuZWVkIHRvIGRldGVybWluZSBiZXR3ZWVuIHdoaWNoIHR3byBheGVzIHRoZSBzdHVybSB3YXMgc3RhcnRlZC5cbiAgICAgIC8vIFRoaXMgd2lsbCBkZXRlcm1pbmUgdGhlIGZyZWVkb20gb2YgbW92ZW1lbnQsIGJlY2F1c2UgYSBzdHJ1bSBjYW5cbiAgICAgIC8vIGxvZ2ljYWxseSBvbmx5IGhhcHBlbiBiZXR3ZWVuIHR3byBheGVzLCBzbyBubyBtb3ZlbWVudCBvdXRzaWRlIHRoZXNlIGF4ZXNcbiAgICAgIC8vIHNob3VsZCBiZSBhbGxvd2VkLlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHAgPSBkMy5tb3VzZShzdHJ1bVJlY3RbMF1bMF0pLFxuICAgICAgICAgIGRpbXMsXG4gICAgICAgICAgc3RydW07XG5cbiAgICAgICAgcFswXSA9IHBbMF0gLSBfXy5tYXJnaW4ubGVmdDtcbiAgICAgICAgcFsxXSA9IHBbMV0gLSBfXy5tYXJnaW4udG9wO1xuXG4gICAgICAgIChkaW1zID0gZGltZW5zaW9uc0ZvclBvaW50KHApKSxcbiAgICAgICAgICAoc3RydW0gPSB7XG4gICAgICAgICAgICBwMTogcCxcbiAgICAgICAgICAgIGRpbXM6IGRpbXMsXG4gICAgICAgICAgICBtaW5YOiB4c2NhbGUoZGltcy5sZWZ0KSxcbiAgICAgICAgICAgIG1heFg6IHhzY2FsZShkaW1zLnJpZ2h0KSxcbiAgICAgICAgICAgIG1pblk6IDAsXG4gICAgICAgICAgICBtYXhZOiBoKCksXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgc3RydW1zW2RpbXMuaV0gPSBzdHJ1bTtcbiAgICAgICAgc3RydW1zLmFjdGl2ZSA9IGRpbXMuaTtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgcG9pbnQgaXMgd2l0aGluIHRoZSBib3VuZHNcbiAgICAgICAgc3RydW0ucDFbMF0gPSBNYXRoLm1pbihNYXRoLm1heChzdHJ1bS5taW5YLCBwWzBdKSwgc3RydW0ubWF4WCk7XG4gICAgICAgIHN0cnVtLnAyID0gc3RydW0ucDEuc2xpY2UoKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25EcmFnKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGV2ID0gZDMuZXZlbnQsXG4gICAgICAgICAgc3RydW0gPSBzdHJ1bXNbc3RydW1zLmFjdGl2ZV07XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIHBvaW50IGlzIHdpdGhpbiB0aGUgYm91bmRzXG4gICAgICAgIHN0cnVtLnAyWzBdID0gTWF0aC5taW4oTWF0aC5tYXgoc3RydW0ubWluWCArIDEsIGV2LnggLSBfXy5tYXJnaW4ubGVmdCksIHN0cnVtLm1heFgpO1xuICAgICAgICBzdHJ1bS5wMlsxXSA9IE1hdGgubWluKE1hdGgubWF4KHN0cnVtLm1pblksIGV2LnkgLSBfXy5tYXJnaW4udG9wKSwgc3RydW0ubWF4WSk7XG4gICAgICAgIGRyYXdTdHJ1bShzdHJ1bSwgMSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnRhaW5tZW50VGVzdChzdHJ1bSwgd2lkdGgpIHtcbiAgICAgIHZhciBwMSA9IFtzdHJ1bS5wMVswXSAtIHN0cnVtLm1pblgsIHN0cnVtLnAxWzFdIC0gc3RydW0ubWluWF0sXG4gICAgICAgIHAyID0gW3N0cnVtLnAyWzBdIC0gc3RydW0ubWluWCwgc3RydW0ucDJbMV0gLSBzdHJ1bS5taW5YXSxcbiAgICAgICAgbTEgPSAxIC0gd2lkdGggLyBwMVswXSxcbiAgICAgICAgYjEgPSBwMVsxXSAqICgxIC0gbTEpLFxuICAgICAgICBtMiA9IDEgLSB3aWR0aCAvIHAyWzBdLFxuICAgICAgICBiMiA9IHAyWzFdICogKDEgLSBtMik7XG5cbiAgICAgIC8vIHRlc3QgaWYgcG9pbnQgZmFsbHMgYmV0d2VlbiBsaW5lc1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciB4ID0gcFswXSxcbiAgICAgICAgICB5ID0gcFsxXSxcbiAgICAgICAgICB5MSA9IG0xICogeCArIGIxLFxuICAgICAgICAgIHkyID0gbTIgKiB4ICsgYjI7XG5cbiAgICAgICAgaWYgKHkgPiBNYXRoLm1pbih5MSwgeTIpICYmIHkgPCBNYXRoLm1heCh5MSwgeTIpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNlbGVjdGVkKCkge1xuICAgICAgdmFyIGlkcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHN0cnVtcyksXG4gICAgICAgIGJydXNoZWQgPSBfXy5kYXRhO1xuXG4gICAgICAvLyBHZXQgdGhlIGlkcyBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZSBzdHJ1bXMuXG4gICAgICBpZHMgPSBpZHMuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiAhaXNOYU4oZCk7XG4gICAgICB9KTtcblxuICAgICAgZnVuY3Rpb24gY3Jvc3Nlc1N0cnVtKGQsIGlkKSB7XG4gICAgICAgIHZhciBzdHJ1bSA9IHN0cnVtc1tpZF0sXG4gICAgICAgICAgdGVzdCA9IGNvbnRhaW5tZW50VGVzdChzdHJ1bSwgc3RydW1zLndpZHRoKGlkKSksXG4gICAgICAgICAgZDEgPSBzdHJ1bS5kaW1zLmxlZnQsXG4gICAgICAgICAgZDIgPSBzdHJ1bS5kaW1zLnJpZ2h0LFxuICAgICAgICAgIHkxID0geXNjYWxlW2QxXSxcbiAgICAgICAgICB5MiA9IHlzY2FsZVtkMl0sXG4gICAgICAgICAgcG9pbnQgPSBbeTEoZFtkMV0pIC0gc3RydW0ubWluWCwgeTIoZFtkMl0pIC0gc3RydW0ubWluWF07XG4gICAgICAgIHJldHVybiB0ZXN0KHBvaW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGJydXNoZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBicnVzaGVkLmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgICAgICBzd2l0Y2ggKGJydXNoLnByZWRpY2F0ZSkge1xuICAgICAgICAgIGNhc2UgJ0FORCc6XG4gICAgICAgICAgICByZXR1cm4gaWRzLmV2ZXJ5KGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICByZXR1cm4gY3Jvc3Nlc1N0cnVtKGQsIGlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIGNhc2UgJ09SJzpcbiAgICAgICAgICAgIHJldHVybiBpZHMuc29tZShmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNyb3NzZXNTdHJ1bShkLCBpZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgJ1Vua25vd24gYnJ1c2ggcHJlZGljYXRlICcgKyBfXy5icnVzaFByZWRpY2F0ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlU3RydW0oKSB7XG4gICAgICB2YXIgc3RydW0gPSBzdHJ1bXNbc3RydW1zLmFjdGl2ZV0sXG4gICAgICAgIHN2ZyA9IHBjLnNlbGVjdGlvbi5zZWxlY3QoJ3N2ZycpLnNlbGVjdCgnZyNzdHJ1bXMnKTtcblxuICAgICAgZGVsZXRlIHN0cnVtc1tzdHJ1bXMuYWN0aXZlXTtcbiAgICAgIHN0cnVtcy5hY3RpdmUgPSB1bmRlZmluZWQ7XG4gICAgICBzdmcuc2VsZWN0QWxsKCdsaW5lI3N0cnVtLScgKyBzdHJ1bS5kaW1zLmkpLnJlbW92ZSgpO1xuICAgICAgc3ZnLnNlbGVjdEFsbCgnY2lyY2xlI3N0cnVtLScgKyBzdHJ1bS5kaW1zLmkpLnJlbW92ZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uRHJhZ0VuZCgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBicnVzaGVkID0gX18uZGF0YSxcbiAgICAgICAgICBzdHJ1bSA9IHN0cnVtc1tzdHJ1bXMuYWN0aXZlXTtcblxuICAgICAgICAvLyBPa2F5LCBzb21ld2hhdCB1bmV4cGVjdGVkLCBidXQgbm90IHRvdGFsbHkgdW5zdXJwcmlzaW5nLCBhIG1vdXNjbGljayBpc1xuICAgICAgICAvLyBjb25zaWRlcmVkIGEgZHJhZyB3aXRob3V0IG1vdmUuIFNvIHdlIGhhdmUgdG8gZGVhbCB3aXRoIHRoYXQgY2FzZVxuICAgICAgICBpZiAoc3RydW0gJiYgc3RydW0ucDFbMF0gPT09IHN0cnVtLnAyWzBdICYmIHN0cnVtLnAxWzFdID09PSBzdHJ1bS5wMlsxXSkge1xuICAgICAgICAgIHJlbW92ZVN0cnVtKHN0cnVtcyk7XG4gICAgICAgIH1cblxuICAgICAgICBicnVzaGVkID0gc2VsZWN0ZWQoc3RydW1zKTtcbiAgICAgICAgc3RydW1zLmFjdGl2ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgX18uYnJ1c2hlZCA9IGJydXNoZWQ7XG4gICAgICAgIHBjLnJlbmRlckJydXNoZWQoKTtcbiAgICAgICAgZXZlbnRzLmJydXNoZW5kLmNhbGwocGMsIF9fLmJydXNoZWQpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBicnVzaFJlc2V0KHN0cnVtcykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlkcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHN0cnVtcykuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuICFpc05hTihkKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWRzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICBzdHJ1bXMuYWN0aXZlID0gZDtcbiAgICAgICAgICByZW1vdmVTdHJ1bShzdHJ1bXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgb25EcmFnRW5kKHN0cnVtcykoKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbCgpIHtcbiAgICAgIHZhciBkcmFnID0gZDMuYmVoYXZpb3IuZHJhZygpO1xuXG4gICAgICAvLyBNYXAgb2YgY3VycmVudCBzdHJ1bXMuIFN0cnVtcyBhcmUgc3RvcmVkIHBlciBzZWdtZW50IG9mIHRoZSBQQy4gQSBzZWdtZW50LFxuICAgICAgLy8gYmVpbmcgdGhlIGFyZWEgYmV0d2VlbiB0d28gYXhlcy4gVGhlIGxlZnQgbW9zdCBhcmVhIGlzIGluZGV4ZWQgYXQgMC5cbiAgICAgIHN0cnVtcy5hY3RpdmUgPSB1bmRlZmluZWQ7XG4gICAgICAvLyBSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGUgUEMgc2VnbWVudCB3aGVyZSBjdXJyZW50bHkgYSBzdHJ1bSBpcyBiZWluZ1xuICAgICAgLy8gcGxhY2VkLiBOT1RFOiBldmVuIHRob3VnaCB0aGV5IGFyZSBldmVubHkgc3BhY2VkIGluIG91ciBjdXJyZW50XG4gICAgICAvLyBpbXBsZW1lbnRhdGlvbiwgd2Uga2VlcCBmb3Igd2hlbiBub24tZXZlbiBzcGFjZWQgc2VnbWVudHMgYXJlIHN1cHBvcnRlZCBhc1xuICAgICAgLy8gd2VsbC5cbiAgICAgIHN0cnVtcy53aWR0aCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgc3RydW0gPSBzdHJ1bXNbaWRdO1xuXG4gICAgICAgIGlmIChzdHJ1bSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHJ1bS5tYXhYIC0gc3RydW0ubWluWDtcbiAgICAgIH07XG5cbiAgICAgIHBjLm9uKCdheGVzcmVvcmRlci5zdHJ1bXMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpZHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzdHJ1bXMpLmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiAhaXNOYU4oZCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIENoZWNrcyBpZiB0aGUgZmlyc3QgZGltZW5zaW9uIGlzIGRpcmVjdGx5IGxlZnQgb2YgdGhlIHNlY29uZCBkaW1lbnNpb24uXG4gICAgICAgIGZ1bmN0aW9uIGNvbnNlY3V0aXZlKGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gX18uZGltZW5zaW9ucy5sZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIF9fLmRpbWVuc2lvbnMuc29tZShmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIGQgPT09IGZpcnN0ID8gaSArIGkgPCBsZW5ndGggJiYgX18uZGltZW5zaW9uc1tpICsgMV0gPT09IHNlY29uZCA6IGZhbHNlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gV2UgaGF2ZSBzb21lIHN0cnVtcywgd2hpY2ggbWlnaHQgbmVlZCB0byBiZSByZW1vdmVkLlxuICAgICAgICAgIGlkcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICB2YXIgZGltcyA9IHN0cnVtc1tkXS5kaW1zO1xuICAgICAgICAgICAgc3RydW1zLmFjdGl2ZSA9IGQ7XG4gICAgICAgICAgICAvLyBJZiB0aGUgdHdvIGRpbWVuc2lvbnMgb2YgdGhlIGN1cnJlbnQgc3RydW0gYXJlIG5vdCBuZXh0IHRvIGVhY2ggb3RoZXJcbiAgICAgICAgICAgIC8vIGFueSBtb3JlLCB0aGFuIHdlJ2xsIG5lZWQgdG8gcmVtb3ZlIHRoZSBzdHJ1bS4gT3RoZXJ3aXNlIHdlIGtlZXAgaXQuXG4gICAgICAgICAgICBpZiAoIWNvbnNlY3V0aXZlKGRpbXMubGVmdCwgZGltcy5yaWdodCkpIHtcbiAgICAgICAgICAgICAgcmVtb3ZlU3RydW0oc3RydW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBvbkRyYWdFbmQoc3RydW1zKSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gQWRkIGEgbmV3IHN2ZyBncm91cCBpbiB3aGljaCB3ZSBkcmF3IHRoZSBzdHJ1bXMuXG4gICAgICBwYy5zZWxlY3Rpb25cbiAgICAgICAgLnNlbGVjdCgnc3ZnJylcbiAgICAgICAgLmFwcGVuZCgnZycpXG4gICAgICAgIC5hdHRyKCdpZCcsICdzdHJ1bXMnKVxuICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgX18ubWFyZ2luLmxlZnQgKyAnLCcgKyBfXy5tYXJnaW4udG9wICsgJyknKTtcblxuICAgICAgLy8gSW5zdGFsbCB0aGUgcmVxdWlyZWQgYnJ1c2hSZXNldCBmdW5jdGlvblxuICAgICAgcGMuYnJ1c2hSZXNldCA9IGJydXNoUmVzZXQoc3RydW1zKTtcblxuICAgICAgZHJhZ1xuICAgICAgICAub24oJ2RyYWdzdGFydCcsIG9uRHJhZ1N0YXJ0KHN0cnVtcykpXG4gICAgICAgIC5vbignZHJhZycsIG9uRHJhZyhzdHJ1bXMpKVxuICAgICAgICAub24oJ2RyYWdlbmQnLCBvbkRyYWdFbmQoc3RydW1zKSk7XG5cbiAgICAgIC8vIE5PVEU6IFRoZSBzdHlsaW5nIG5lZWRzIHRvIGJlIGRvbmUgaGVyZSBhbmQgbm90IGluIHRoZSBjc3MuIFRoaXMgaXMgYmVjYXVzZVxuICAgICAgLy8gICAgICAgZm9yIDFEIGJydXNoaW5nLCB0aGUgY2FudmFzIGxheWVycyBzaG91bGQgbm90IGxpc3RlbiB0b1xuICAgICAgLy8gICAgICAgcG9pbnRlci1ldmVudHMuXG4gICAgICBzdHJ1bVJlY3QgPSBwYy5zZWxlY3Rpb25cbiAgICAgICAgLnNlbGVjdCgnc3ZnJylcbiAgICAgICAgLmluc2VydCgncmVjdCcsICdnI3N0cnVtcycpXG4gICAgICAgIC5hdHRyKCdpZCcsICdzdHJ1bS1ldmVudHMnKVxuICAgICAgICAuYXR0cigneCcsIF9fLm1hcmdpbi5sZWZ0KVxuICAgICAgICAuYXR0cigneScsIF9fLm1hcmdpbi50b3ApXG4gICAgICAgIC5hdHRyKCd3aWR0aCcsIHcoKSlcbiAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGgoKSArIDIpXG4gICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDApXG4gICAgICAgIC5jYWxsKGRyYWcpO1xuICAgIH1cblxuICAgIGJydXNoLm1vZGVzWycyRC1zdHJ1bXMnXSA9IHtcbiAgICAgIGluc3RhbGw6IGluc3RhbGwsXG4gICAgICB1bmluc3RhbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcGMuc2VsZWN0aW9uLnNlbGVjdCgnc3ZnJykuc2VsZWN0KCdnI3N0cnVtcycpLnJlbW92ZSgpO1xuICAgICAgICBwYy5zZWxlY3Rpb24uc2VsZWN0KCdzdmcnKS5zZWxlY3QoJ3JlY3Qjc3RydW0tZXZlbnRzJykucmVtb3ZlKCk7XG4gICAgICAgIHBjLm9uKCdheGVzcmVvcmRlci5zdHJ1bXMnLCB1bmRlZmluZWQpO1xuICAgICAgICBkZWxldGUgcGMuYnJ1c2hSZXNldDtcblxuICAgICAgICBzdHJ1bVJlY3QgPSB1bmRlZmluZWQ7XG4gICAgICB9LFxuICAgICAgc2VsZWN0ZWQ6IHNlbGVjdGVkLFxuICAgICAgYnJ1c2hTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc3RydW1zO1xuICAgICAgfSxcbiAgICB9O1xuICB9KSgpO1xuXG4gIC8vIGJydXNoIG1vZGU6IDFELUF4ZXMgd2l0aCBtdWx0aXBsZSBleHRlbnRzXG4gIC8vIHJlcXVpcmVzIGQzLnN2Zy5tdWx0aWJydXNoXG5cbiAgKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIGQzLnN2Zy5tdWx0aWJydXNoICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBicnVzaGVzID0ge307XG5cbiAgICBmdW5jdGlvbiBpc19icnVzaGVkKHApIHtcbiAgICAgIHJldHVybiAhYnJ1c2hlc1twXS5lbXB0eSgpO1xuICAgIH1cblxuICAgIC8vIGRhdGEgd2l0aGluIGV4dGVudHNcbiAgICBmdW5jdGlvbiBzZWxlY3RlZCgpIHtcbiAgICAgIHZhciBhY3RpdmVzID0gX18uZGltZW5zaW9ucy5maWx0ZXIoaXNfYnJ1c2hlZCksXG4gICAgICAgIGV4dGVudHMgPSBhY3RpdmVzLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgICAgIHJldHVybiBicnVzaGVzW3BdLmV4dGVudCgpO1xuICAgICAgICB9KTtcblxuICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byByZXR1cm4gdGhlIGZ1bGwgZGF0YSBzZXQgd2hlbiB0aGVyZSBhcmUgbm8gYXhlcyBicnVzaGVkLlxuICAgICAgLy8gQWN0dWFsbHksIHdoZW4gdGhlcmUgYXJlIG5vIGF4ZXMgYnJ1c2hlZCwgYnkgZGVmaW5pdGlvbiwgbm8gaXRlbXMgYXJlXG4gICAgICAvLyBzZWxlY3RlZC4gU28sIGxldCdzIGF2b2lkIHRoZSBmaWx0ZXJpbmcgYW5kIGp1c3QgcmV0dXJuIGZhbHNlLlxuICAgICAgLy9pZiAoYWN0aXZlcy5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gUmVzb2x2ZXMgYnJva2VuIGV4YW1wbGVzIGZvciBub3cuIFRoZXkgZXhwZWN0IHRvIGdldCB0aGUgZnVsbCBkYXRhc2V0IGJhY2sgZnJvbSBlbXB0eSBicnVzaGVzXG4gICAgICBpZiAoYWN0aXZlcy5sZW5ndGggPT09IDApIHJldHVybiBfXy5kYXRhO1xuXG4gICAgICAvLyB0ZXN0IGlmIHdpdGhpbiByYW5nZVxuICAgICAgdmFyIHdpdGhpbiA9IHtcbiAgICAgICAgZGF0ZTogZnVuY3Rpb24gKGQsIHAsIGRpbWVuc2lvbiwgYikge1xuICAgICAgICAgIGlmICh0eXBlb2YgeXNjYWxlW3BdLnJhbmdlUG9pbnRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBpZiBpdCBpcyBvcmRpbmFsXG4gICAgICAgICAgICByZXR1cm4gYlswXSA8PSB5c2NhbGVbcF0oZFtwXSkgJiYgeXNjYWxlW3BdKGRbcF0pIDw9IGJbMV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBiWzBdIDw9IGRbcF0gJiYgZFtwXSA8PSBiWzFdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbnVtYmVyOiBmdW5jdGlvbiAoZCwgcCwgZGltZW5zaW9uLCBiKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB5c2NhbGVbcF0ucmFuZ2VQb2ludHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGlmIGl0IGlzIG9yZGluYWxcbiAgICAgICAgICAgIHJldHVybiBiWzBdIDw9IHlzY2FsZVtwXShkW3BdKSAmJiB5c2NhbGVbcF0oZFtwXSkgPD0gYlsxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGJbMF0gPD0gZFtwXSAmJiBkW3BdIDw9IGJbMV07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzdHJpbmc6IGZ1bmN0aW9uIChkLCBwLCBkaW1lbnNpb24sIGIpIHtcbiAgICAgICAgICByZXR1cm4gYlswXSA8PSB5c2NhbGVbcF0oZFtwXSkgJiYgeXNjYWxlW3BdKGRbcF0pIDw9IGJbMV07XG4gICAgICAgIH0sXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gX18uZGF0YS5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgc3dpdGNoIChicnVzaC5wcmVkaWNhdGUpIHtcbiAgICAgICAgICBjYXNlICdBTkQnOlxuICAgICAgICAgICAgcmV0dXJuIGFjdGl2ZXMuZXZlcnkoZnVuY3Rpb24gKHAsIGRpbWVuc2lvbikge1xuICAgICAgICAgICAgICByZXR1cm4gZXh0ZW50c1tkaW1lbnNpb25dLnNvbWUoZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2l0aGluW19fLnR5cGVzW3BdXShkLCBwLCBkaW1lbnNpb24sIGIpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIGNhc2UgJ09SJzpcbiAgICAgICAgICAgIHJldHVybiBhY3RpdmVzLnNvbWUoZnVuY3Rpb24gKHAsIGRpbWVuc2lvbikge1xuICAgICAgICAgICAgICByZXR1cm4gZXh0ZW50c1tkaW1lbnNpb25dLnNvbWUoZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2l0aGluW19fLnR5cGVzW3BdXShkLCBwLCBkaW1lbnNpb24sIGIpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyAnVW5rbm93biBicnVzaCBwcmVkaWNhdGUgJyArIF9fLmJydXNoUHJlZGljYXRlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBicnVzaEV4dGVudHMoKSB7XG4gICAgICB2YXIgZXh0ZW50cyA9IHt9O1xuICAgICAgX18uZGltZW5zaW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHZhciBicnVzaCA9IGJydXNoZXNbZF07XG4gICAgICAgIGlmIChicnVzaCAhPT0gdW5kZWZpbmVkICYmICFicnVzaC5lbXB0eSgpKSB7XG4gICAgICAgICAgdmFyIGV4dGVudCA9IGJydXNoLmV4dGVudCgpO1xuICAgICAgICAgIGV4dGVudHNbZF0gPSBleHRlbnQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGV4dGVudHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnJ1c2hGb3IoYXhpcykge1xuICAgICAgdmFyIGJydXNoID0gZDMuc3ZnLm11bHRpYnJ1c2goKTtcblxuICAgICAgYnJ1c2hcbiAgICAgICAgLnkoeXNjYWxlW2F4aXNdKVxuICAgICAgICAub24oJ2JydXNoc3RhcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGQzLmV2ZW50LnNvdXJjZUV2ZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBkMy5ldmVudC5zb3VyY2VFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignYnJ1c2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgYnJ1c2hVcGRhdGVkKHNlbGVjdGVkKCkpO1xuICAgICAgICB9KVxuICAgICAgICAub24oJ2JydXNoZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIGQzLnN2Zy5tdWx0aWJydXNoIGNsZWFycyBleHRlbnRzIGp1c3QgYmVmb3JlIGNhbGxpbmcgJ2JydXNoZW5kJ1xuICAgICAgICAgIC8vIHNvIHdlIGhhdmUgdG8gdXBkYXRlIGhlcmUgYWdhaW4uXG4gICAgICAgICAgLy8gVGhpcyBmaXhlcyBpc3N1ZSAjMTAzIGZvciBub3csIGJ1dCBzaG91bGQgYmUgY2hhbmdlZCBpbiBkMy5zdmcubXVsdGlicnVzaFxuICAgICAgICAgIC8vIHRvIGF2b2lkIHVubmVjZXNzYXJ5IGNvbXB1dGF0aW9uLlxuICAgICAgICAgIGJydXNoVXBkYXRlZChzZWxlY3RlZCgpKTtcbiAgICAgICAgICBldmVudHMuYnJ1c2hlbmQuY2FsbChwYywgX18uYnJ1c2hlZCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5leHRlbnRBZGFwdGlvbihmdW5jdGlvbiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgc2VsZWN0aW9uLnN0eWxlKCd2aXNpYmlsaXR5JywgbnVsbCkuYXR0cigneCcsIC0xNSkuYXR0cignd2lkdGgnLCAzMCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5yZXNpemVBZGFwdGlvbihmdW5jdGlvbiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgc2VsZWN0aW9uLnNlbGVjdEFsbCgncmVjdCcpLmF0dHIoJ3gnLCAtMTUpLmF0dHIoJ3dpZHRoJywgMzApO1xuICAgICAgICB9KTtcblxuICAgICAgYnJ1c2hlc1theGlzXSA9IGJydXNoO1xuICAgICAgcmV0dXJuIGJydXNoO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJydXNoUmVzZXQoZGltZW5zaW9uKSB7XG4gICAgICBfXy5icnVzaGVkID0gZmFsc2U7XG4gICAgICBpZiAoZykge1xuICAgICAgICBnLnNlbGVjdEFsbCgnLmJydXNoJykuZWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jYWxsKGJydXNoZXNbZF0uY2xlYXIoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBwYy5yZW5kZXJCcnVzaGVkKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsKCkge1xuICAgICAgaWYgKCFnKSBwYy5jcmVhdGVBeGVzKCk7XG5cbiAgICAgIC8vIEFkZCBhbmQgc3RvcmUgYSBicnVzaCBmb3IgZWFjaCBheGlzLlxuICAgICAgZy5hcHBlbmQoJ3N2ZzpnJylcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2JydXNoJylcbiAgICAgICAgLmVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICBkMy5zZWxlY3QodGhpcykuY2FsbChicnVzaEZvcihkKSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5zZWxlY3RBbGwoJ3JlY3QnKVxuICAgICAgICAuc3R5bGUoJ3Zpc2liaWxpdHknLCBudWxsKVxuICAgICAgICAuYXR0cigneCcsIC0xNSlcbiAgICAgICAgLmF0dHIoJ3dpZHRoJywgMzApO1xuXG4gICAgICBwYy5icnVzaEV4dGVudHMgPSBicnVzaEV4dGVudHM7XG4gICAgICBwYy5icnVzaFJlc2V0ID0gYnJ1c2hSZXNldDtcbiAgICAgIHJldHVybiBwYztcbiAgICB9XG5cbiAgICBicnVzaC5tb2Rlc1snMUQtYXhlcy1tdWx0aSddID0ge1xuICAgICAgaW5zdGFsbDogaW5zdGFsbCxcbiAgICAgIHVuaW5zdGFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICBnLnNlbGVjdEFsbCgnLmJydXNoJykucmVtb3ZlKCk7XG4gICAgICAgIGJydXNoZXMgPSB7fTtcbiAgICAgICAgZGVsZXRlIHBjLmJydXNoRXh0ZW50cztcbiAgICAgICAgZGVsZXRlIHBjLmJydXNoUmVzZXQ7XG4gICAgICB9LFxuICAgICAgc2VsZWN0ZWQ6IHNlbGVjdGVkLFxuICAgICAgYnJ1c2hTdGF0ZTogYnJ1c2hFeHRlbnRzLFxuICAgIH07XG4gIH0pKCk7XG4gIC8vIGJydXNoIG1vZGU6IGFuZ3VsYXJcbiAgLy8gY29kZSBiYXNlZCBvbiAyRC5zdHJ1bXMuanNcblxuICAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmNzID0ge30sXG4gICAgICBzdHJ1bVJlY3Q7XG5cbiAgICBmdW5jdGlvbiBkcmF3U3RydW0oYXJjLCBhY3RpdmVQb2ludCkge1xuICAgICAgdmFyIHN2ZyA9IHBjLnNlbGVjdGlvbi5zZWxlY3QoJ3N2ZycpLnNlbGVjdCgnZyNhcmNzJyksXG4gICAgICAgIGlkID0gYXJjLmRpbXMuaSxcbiAgICAgICAgcG9pbnRzID0gW2FyYy5wMiwgYXJjLnAzXSxcbiAgICAgICAgbGluZSA9IHN2Zy5zZWxlY3RBbGwoJ2xpbmUjYXJjLScgKyBpZCkuZGF0YShbXG4gICAgICAgICAgeyBwMTogYXJjLnAxLCBwMjogYXJjLnAyIH0sXG4gICAgICAgICAgeyBwMTogYXJjLnAxLCBwMjogYXJjLnAzIH0sXG4gICAgICAgIF0pLFxuICAgICAgICBjaXJjbGVzID0gc3ZnLnNlbGVjdEFsbCgnY2lyY2xlI2FyYy0nICsgaWQpLmRhdGEocG9pbnRzKSxcbiAgICAgICAgZHJhZyA9IGQzLmJlaGF2aW9yLmRyYWcoKSxcbiAgICAgICAgcGF0aCA9IHN2Zy5zZWxlY3RBbGwoJ3BhdGgjYXJjLScgKyBpZCkuZGF0YShbYXJjXSk7XG5cbiAgICAgIHBhdGhcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZCgncGF0aCcpXG4gICAgICAgIC5hdHRyKCdpZCcsICdhcmMtJyArIGlkKVxuICAgICAgICAuYXR0cignY2xhc3MnLCAnYXJjJylcbiAgICAgICAgLnN0eWxlKCdmaWxsJywgJ29yYW5nZScpXG4gICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDAuNSk7XG5cbiAgICAgIHBhdGguYXR0cignZCcsIGFyYy5hcmMpLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIGFyYy5wMVswXSArICcsJyArIGFyYy5wMVsxXSArICcpJyk7XG5cbiAgICAgIGxpbmVcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZCgnbGluZScpXG4gICAgICAgIC5hdHRyKCdpZCcsICdhcmMtJyArIGlkKVxuICAgICAgICAuYXR0cignY2xhc3MnLCAnYXJjJyk7XG5cbiAgICAgIGxpbmVcbiAgICAgICAgLmF0dHIoJ3gxJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gZC5wMVswXTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ3kxJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gZC5wMVsxXTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ3gyJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gZC5wMlswXTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ3kyJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gZC5wMlsxXTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoJ3N0cm9rZScsICdibGFjaycpXG4gICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAyKTtcblxuICAgICAgZHJhZ1xuICAgICAgICAub24oJ2RyYWcnLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgIHZhciBldiA9IGQzLmV2ZW50LFxuICAgICAgICAgICAgYW5nbGUgPSAwO1xuXG4gICAgICAgICAgaSA9IGkgKyAyO1xuXG4gICAgICAgICAgYXJjWydwJyArIGldWzBdID0gTWF0aC5taW4oTWF0aC5tYXgoYXJjLm1pblggKyAxLCBldi54KSwgYXJjLm1heFgpO1xuICAgICAgICAgIGFyY1sncCcgKyBpXVsxXSA9IE1hdGgubWluKE1hdGgubWF4KGFyYy5taW5ZLCBldi55KSwgYXJjLm1heFkpO1xuXG4gICAgICAgICAgYW5nbGUgPSBpID09PSAzID8gYXJjcy5zdGFydEFuZ2xlKGlkKSA6IGFyY3MuZW5kQW5nbGUoaWQpO1xuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKGFyYy5zdGFydEFuZ2xlIDwgTWF0aC5QSSAmJiBhcmMuZW5kQW5nbGUgPCBNYXRoLlBJICYmIGFuZ2xlIDwgTWF0aC5QSSkgfHxcbiAgICAgICAgICAgIChhcmMuc3RhcnRBbmdsZSA+PSBNYXRoLlBJICYmIGFyYy5lbmRBbmdsZSA+PSBNYXRoLlBJICYmIGFuZ2xlID49IE1hdGguUEkpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMikge1xuICAgICAgICAgICAgICBhcmMuZW5kQW5nbGUgPSBhbmdsZTtcbiAgICAgICAgICAgICAgYXJjLmFyYy5lbmRBbmdsZShhbmdsZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGkgPT09IDMpIHtcbiAgICAgICAgICAgICAgYXJjLnN0YXJ0QW5nbGUgPSBhbmdsZTtcbiAgICAgICAgICAgICAgYXJjLmFyYy5zdGFydEFuZ2xlKGFuZ2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkcmF3U3RydW0oYXJjLCBpIC0gMik7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignZHJhZ2VuZCcsIG9uRHJhZ0VuZCgpKTtcblxuICAgICAgY2lyY2xlc1xuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKCdjaXJjbGUnKVxuICAgICAgICAuYXR0cignaWQnLCAnYXJjLScgKyBpZClcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2FyYycpO1xuXG4gICAgICBjaXJjbGVzXG4gICAgICAgIC5hdHRyKCdjeCcsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIGRbMF07XG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCdjeScsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIGRbMV07XG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKCdyJywgNSlcbiAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICByZXR1cm4gYWN0aXZlUG9pbnQgIT09IHVuZGVmaW5lZCAmJiBpID09PSBhY3RpdmVQb2ludCA/IDAuOCA6IDA7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zdHlsZSgnb3BhY2l0eScsIDAuOCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnN0eWxlKCdvcGFjaXR5JywgMCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYWxsKGRyYWcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpbWVuc2lvbnNGb3JQb2ludChwKSB7XG4gICAgICB2YXIgZGltcyA9IHsgaTogLTEsIGxlZnQ6IHVuZGVmaW5lZCwgcmlnaHQ6IHVuZGVmaW5lZCB9O1xuICAgICAgX18uZGltZW5zaW9ucy5zb21lKGZ1bmN0aW9uIChkaW0sIGkpIHtcbiAgICAgICAgaWYgKHhzY2FsZShkaW0pIDwgcFswXSkge1xuICAgICAgICAgIHZhciBuZXh0ID0gX18uZGltZW5zaW9uc1tpICsgMV07XG4gICAgICAgICAgZGltcy5pID0gaTtcbiAgICAgICAgICBkaW1zLmxlZnQgPSBkaW07XG4gICAgICAgICAgZGltcy5yaWdodCA9IG5leHQ7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChkaW1zLmxlZnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBFdmVudCBvbiB0aGUgbGVmdCBzaWRlIG9mIHRoZSBmaXJzdCBheGlzLlxuICAgICAgICBkaW1zLmkgPSAwO1xuICAgICAgICBkaW1zLmxlZnQgPSBfXy5kaW1lbnNpb25zWzBdO1xuICAgICAgICBkaW1zLnJpZ2h0ID0gX18uZGltZW5zaW9uc1sxXTtcbiAgICAgIH0gZWxzZSBpZiAoZGltcy5yaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIEV2ZW50IG9uIHRoZSByaWdodCBzaWRlIG9mIHRoZSBsYXN0IGF4aXNcbiAgICAgICAgZGltcy5pID0gX18uZGltZW5zaW9ucy5sZW5ndGggLSAxO1xuICAgICAgICBkaW1zLnJpZ2h0ID0gZGltcy5sZWZ0O1xuICAgICAgICBkaW1zLmxlZnQgPSBfXy5kaW1lbnNpb25zW19fLmRpbWVuc2lvbnMubGVuZ3RoIC0gMl07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkaW1zO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uRHJhZ1N0YXJ0KCkge1xuICAgICAgLy8gRmlyc3Qgd2UgbmVlZCB0byBkZXRlcm1pbmUgYmV0d2VlbiB3aGljaCB0d28gYXhlcyB0aGUgYXJjIHdhcyBzdGFydGVkLlxuICAgICAgLy8gVGhpcyB3aWxsIGRldGVybWluZSB0aGUgZnJlZWRvbSBvZiBtb3ZlbWVudCwgYmVjYXVzZSBhIGFyYyBjYW5cbiAgICAgIC8vIGxvZ2ljYWxseSBvbmx5IGhhcHBlbiBiZXR3ZWVuIHR3byBheGVzLCBzbyBubyBtb3ZlbWVudCBvdXRzaWRlIHRoZXNlIGF4ZXNcbiAgICAgIC8vIHNob3VsZCBiZSBhbGxvd2VkLlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHAgPSBkMy5tb3VzZShzdHJ1bVJlY3RbMF1bMF0pLFxuICAgICAgICAgIGRpbXMsXG4gICAgICAgICAgYXJjO1xuXG4gICAgICAgIHBbMF0gPSBwWzBdIC0gX18ubWFyZ2luLmxlZnQ7XG4gICAgICAgIHBbMV0gPSBwWzFdIC0gX18ubWFyZ2luLnRvcDtcblxuICAgICAgICAoZGltcyA9IGRpbWVuc2lvbnNGb3JQb2ludChwKSksXG4gICAgICAgICAgKGFyYyA9IHtcbiAgICAgICAgICAgIHAxOiBwLFxuICAgICAgICAgICAgZGltczogZGltcyxcbiAgICAgICAgICAgIG1pblg6IHhzY2FsZShkaW1zLmxlZnQpLFxuICAgICAgICAgICAgbWF4WDogeHNjYWxlKGRpbXMucmlnaHQpLFxuICAgICAgICAgICAgbWluWTogMCxcbiAgICAgICAgICAgIG1heFk6IGgoKSxcbiAgICAgICAgICAgIHN0YXJ0QW5nbGU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGVuZEFuZ2xlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBhcmM6IGQzLnN2Zy5hcmMoKS5pbm5lclJhZGl1cygwKSxcbiAgICAgICAgICB9KTtcblxuICAgICAgICBhcmNzW2RpbXMuaV0gPSBhcmM7XG4gICAgICAgIGFyY3MuYWN0aXZlID0gZGltcy5pO1xuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBwb2ludCBpcyB3aXRoaW4gdGhlIGJvdW5kc1xuICAgICAgICBhcmMucDFbMF0gPSBNYXRoLm1pbihNYXRoLm1heChhcmMubWluWCwgcFswXSksIGFyYy5tYXhYKTtcbiAgICAgICAgYXJjLnAyID0gYXJjLnAxLnNsaWNlKCk7XG4gICAgICAgIGFyYy5wMyA9IGFyYy5wMS5zbGljZSgpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkRyYWcoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZXYgPSBkMy5ldmVudCxcbiAgICAgICAgICBhcmMgPSBhcmNzW2FyY3MuYWN0aXZlXTtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgcG9pbnQgaXMgd2l0aGluIHRoZSBib3VuZHNcbiAgICAgICAgYXJjLnAyWzBdID0gTWF0aC5taW4oTWF0aC5tYXgoYXJjLm1pblggKyAxLCBldi54IC0gX18ubWFyZ2luLmxlZnQpLCBhcmMubWF4WCk7XG4gICAgICAgIGFyYy5wMlsxXSA9IE1hdGgubWluKE1hdGgubWF4KGFyYy5taW5ZLCBldi55IC0gX18ubWFyZ2luLnRvcCksIGFyYy5tYXhZKTtcbiAgICAgICAgYXJjLnAzID0gYXJjLnAyLnNsaWNlKCk7XG4gICAgICAgIGRyYXdTdHJ1bShhcmMsIDEpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBzb21lIGhlbHBlciBmdW5jdGlvbnNcbiAgICBmdW5jdGlvbiBoeXBvdGhlbnVzZShhLCBiKSB7XG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpO1xuICAgIH1cblxuICAgIHZhciByYWQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGMgPSBNYXRoLlBJIC8gMTgwO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhbmdsZSkge1xuICAgICAgICByZXR1cm4gYW5nbGUgKiBjO1xuICAgICAgfTtcbiAgICB9KSgpO1xuXG4gICAgdmFyIGRlZyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYyA9IDE4MCAvIE1hdGguUEk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGFuZ2xlKSB7XG4gICAgICAgIHJldHVybiBhbmdsZSAqIGM7XG4gICAgICB9O1xuICAgIH0pKCk7XG5cbiAgICAvLyBbMCwgMipQSV0gLT4gWy1QSS8yLCBQSS8yXVxuICAgIHZhciBzaWduZWRBbmdsZSA9IGZ1bmN0aW9uIChhbmdsZSkge1xuICAgICAgdmFyIHJldCA9IGFuZ2xlO1xuICAgICAgaWYgKGFuZ2xlID4gTWF0aC5QSSkge1xuICAgICAgICByZXQgPSBhbmdsZSAtIDEuNSAqIE1hdGguUEk7XG4gICAgICAgIHJldCA9IGFuZ2xlIC0gMS41ICogTWF0aC5QSTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IGFuZ2xlIC0gMC41ICogTWF0aC5QSTtcbiAgICAgICAgcmV0ID0gYW5nbGUgLSAwLjUgKiBNYXRoLlBJO1xuICAgICAgfVxuICAgICAgcmV0dXJuIC1yZXQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGFuZ2xlcyBhcmUgc3RvcmVkIGluIHJhZGlhbnMgZnJvbSBpbiBbMCwgMipQSV0sIHdoZXJlIDAgaW4gMTIgbydjbG9jay5cbiAgICAgKiBIb3dldmVyLCBvbmUgY2FuIG9ubHkgc2VsZWN0IGxpbmVzIGZyb20gMCB0byBQSSwgc28gd2UgY29tcHV0ZSB0aGVcbiAgICAgKiAnc2lnbmVkJyBhbmdsZSwgd2hlcmUgMCBpcyB0aGUgaG9yaXpvbnRhbCBsaW5lICgzIG8nY2xvY2spLCBhbmQgKy8tIFBJLzJcbiAgICAgKiBhcmUgMTIgYW5kIDYgbydjbG9jayByZXNwZWN0aXZlbHkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29udGFpbm1lbnRUZXN0KGFyYykge1xuICAgICAgdmFyIHN0YXJ0QW5nbGUgPSBzaWduZWRBbmdsZShhcmMuc3RhcnRBbmdsZSk7XG4gICAgICB2YXIgZW5kQW5nbGUgPSBzaWduZWRBbmdsZShhcmMuZW5kQW5nbGUpO1xuXG4gICAgICBpZiAoc3RhcnRBbmdsZSA+IGVuZEFuZ2xlKSB7XG4gICAgICAgIHZhciB0bXAgPSBzdGFydEFuZ2xlO1xuICAgICAgICBzdGFydEFuZ2xlID0gZW5kQW5nbGU7XG4gICAgICAgIGVuZEFuZ2xlID0gdG1wO1xuICAgICAgfVxuXG4gICAgICAvLyB0ZXN0IGlmIHNlZ21lbnQgYW5nbGUgaXMgY29udGFpbmVkIGluIGFuZ2xlIGludGVydmFsXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgaWYgKGEgPj0gc3RhcnRBbmdsZSAmJiBhIDw9IGVuZEFuZ2xlKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNlbGVjdGVkKCkge1xuICAgICAgdmFyIGlkcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFyY3MpLFxuICAgICAgICBicnVzaGVkID0gX18uZGF0YTtcblxuICAgICAgLy8gR2V0IHRoZSBpZHMgb2YgdGhlIGN1cnJlbnRseSBhY3RpdmUgYXJjcy5cbiAgICAgIGlkcyA9IGlkcy5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuICFpc05hTihkKTtcbiAgICAgIH0pO1xuXG4gICAgICBmdW5jdGlvbiBjcm9zc2VzU3RydW0oZCwgaWQpIHtcbiAgICAgICAgdmFyIGFyYyA9IGFyY3NbaWRdLFxuICAgICAgICAgIHRlc3QgPSBjb250YWlubWVudFRlc3QoYXJjKSxcbiAgICAgICAgICBkMSA9IGFyYy5kaW1zLmxlZnQsXG4gICAgICAgICAgZDIgPSBhcmMuZGltcy5yaWdodCxcbiAgICAgICAgICB5MSA9IHlzY2FsZVtkMV0sXG4gICAgICAgICAgeTIgPSB5c2NhbGVbZDJdLFxuICAgICAgICAgIGEgPSBhcmNzLndpZHRoKGlkKSxcbiAgICAgICAgICBiID0geTEoZFtkMV0pIC0geTIoZFtkMl0pLFxuICAgICAgICAgIGMgPSBoeXBvdGhlbnVzZShhLCBiKSxcbiAgICAgICAgICBhbmdsZSA9IE1hdGguYXNpbihiIC8gYyk7IC8vIHJhZCBpbiBbLVBJLzIsIFBJLzJdXG4gICAgICAgIHJldHVybiB0ZXN0KGFuZ2xlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGJydXNoZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBicnVzaGVkLmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgICAgICBzd2l0Y2ggKGJydXNoLnByZWRpY2F0ZSkge1xuICAgICAgICAgIGNhc2UgJ0FORCc6XG4gICAgICAgICAgICByZXR1cm4gaWRzLmV2ZXJ5KGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICByZXR1cm4gY3Jvc3Nlc1N0cnVtKGQsIGlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIGNhc2UgJ09SJzpcbiAgICAgICAgICAgIHJldHVybiBpZHMuc29tZShmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNyb3NzZXNTdHJ1bShkLCBpZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgJ1Vua25vd24gYnJ1c2ggcHJlZGljYXRlICcgKyBfXy5icnVzaFByZWRpY2F0ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlU3RydW0oKSB7XG4gICAgICB2YXIgYXJjID0gYXJjc1thcmNzLmFjdGl2ZV0sXG4gICAgICAgIHN2ZyA9IHBjLnNlbGVjdGlvbi5zZWxlY3QoJ3N2ZycpLnNlbGVjdCgnZyNhcmNzJyk7XG5cbiAgICAgIGRlbGV0ZSBhcmNzW2FyY3MuYWN0aXZlXTtcbiAgICAgIGFyY3MuYWN0aXZlID0gdW5kZWZpbmVkO1xuICAgICAgc3ZnLnNlbGVjdEFsbCgnbGluZSNhcmMtJyArIGFyYy5kaW1zLmkpLnJlbW92ZSgpO1xuICAgICAgc3ZnLnNlbGVjdEFsbCgnY2lyY2xlI2FyYy0nICsgYXJjLmRpbXMuaSkucmVtb3ZlKCk7XG4gICAgICBzdmcuc2VsZWN0QWxsKCdwYXRoI2FyYy0nICsgYXJjLmRpbXMuaSkucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25EcmFnRW5kKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJydXNoZWQgPSBfXy5kYXRhLFxuICAgICAgICAgIGFyYyA9IGFyY3NbYXJjcy5hY3RpdmVdO1xuXG4gICAgICAgIC8vIE9rYXksIHNvbWV3aGF0IHVuZXhwZWN0ZWQsIGJ1dCBub3QgdG90YWxseSB1bnN1cnByaXNpbmcsIGEgbW91c2NsaWNrIGlzXG4gICAgICAgIC8vIGNvbnNpZGVyZWQgYSBkcmFnIHdpdGhvdXQgbW92ZS4gU28gd2UgaGF2ZSB0byBkZWFsIHdpdGggdGhhdCBjYXNlXG4gICAgICAgIGlmIChhcmMgJiYgYXJjLnAxWzBdID09PSBhcmMucDJbMF0gJiYgYXJjLnAxWzFdID09PSBhcmMucDJbMV0pIHtcbiAgICAgICAgICByZW1vdmVTdHJ1bShhcmNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcmMpIHtcbiAgICAgICAgICB2YXIgYW5nbGUgPSBhcmNzLnN0YXJ0QW5nbGUoYXJjcy5hY3RpdmUpO1xuXG4gICAgICAgICAgYXJjLnN0YXJ0QW5nbGUgPSBhbmdsZTtcbiAgICAgICAgICBhcmMuZW5kQW5nbGUgPSBhbmdsZTtcbiAgICAgICAgICBhcmMuYXJjLm91dGVyUmFkaXVzKGFyY3MubGVuZ3RoKGFyY3MuYWN0aXZlKSkuc3RhcnRBbmdsZShhbmdsZSkuZW5kQW5nbGUoYW5nbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJ1c2hlZCA9IHNlbGVjdGVkKGFyY3MpO1xuICAgICAgICBhcmNzLmFjdGl2ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgX18uYnJ1c2hlZCA9IGJydXNoZWQ7XG4gICAgICAgIHBjLnJlbmRlckJydXNoZWQoKTtcbiAgICAgICAgZXZlbnRzLmJydXNoZW5kLmNhbGwocGMsIF9fLmJydXNoZWQpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBicnVzaFJlc2V0KGFyY3MpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpZHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcmNzKS5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gIWlzTmFOKGQpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZHMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIGFyY3MuYWN0aXZlID0gZDtcbiAgICAgICAgICByZW1vdmVTdHJ1bShhcmNzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG9uRHJhZ0VuZChhcmNzKSgpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsKCkge1xuICAgICAgdmFyIGRyYWcgPSBkMy5iZWhhdmlvci5kcmFnKCk7XG5cbiAgICAgIC8vIE1hcCBvZiBjdXJyZW50IGFyY3MuIGFyY3MgYXJlIHN0b3JlZCBwZXIgc2VnbWVudCBvZiB0aGUgUEMuIEEgc2VnbWVudCxcbiAgICAgIC8vIGJlaW5nIHRoZSBhcmVhIGJldHdlZW4gdHdvIGF4ZXMuIFRoZSBsZWZ0IG1vc3QgYXJlYSBpcyBpbmRleGVkIGF0IDAuXG4gICAgICBhcmNzLmFjdGl2ZSA9IHVuZGVmaW5lZDtcbiAgICAgIC8vIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSBQQyBzZWdtZW50IHdoZXJlIGN1cnJlbnRseSBhIGFyYyBpcyBiZWluZ1xuICAgICAgLy8gcGxhY2VkLiBOT1RFOiBldmVuIHRob3VnaCB0aGV5IGFyZSBldmVubHkgc3BhY2VkIGluIG91ciBjdXJyZW50XG4gICAgICAvLyBpbXBsZW1lbnRhdGlvbiwgd2Uga2VlcCBmb3Igd2hlbiBub24tZXZlbiBzcGFjZWQgc2VnbWVudHMgYXJlIHN1cHBvcnRlZCBhc1xuICAgICAgLy8gd2VsbC5cbiAgICAgIGFyY3Mud2lkdGggPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIGFyYyA9IGFyY3NbaWRdO1xuXG4gICAgICAgIGlmIChhcmMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXJjLm1heFggLSBhcmMubWluWDtcbiAgICAgIH07XG5cbiAgICAgIC8vIHJldHVybnMgYW5nbGVzIGluIFstUEkvMiwgUEkvMl1cbiAgICAgIGFuZ2xlID0gZnVuY3Rpb24gKHAxLCBwMikge1xuICAgICAgICB2YXIgYSA9IHAxWzBdIC0gcDJbMF0sXG4gICAgICAgICAgYiA9IHAxWzFdIC0gcDJbMV0sXG4gICAgICAgICAgYyA9IGh5cG90aGVudXNlKGEsIGIpO1xuXG4gICAgICAgIHJldHVybiBNYXRoLmFzaW4oYiAvIGMpO1xuICAgICAgfTtcblxuICAgICAgLy8gcmV0dXJucyBhbmdsZXMgaW4gWzAsIDIgKiBQSV1cbiAgICAgIGFyY3MuZW5kQW5nbGUgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIGFyYyA9IGFyY3NbaWRdO1xuICAgICAgICBpZiAoYXJjID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzQW5nbGUgPSBhbmdsZShhcmMucDEsIGFyYy5wMiksXG4gICAgICAgICAgdUFuZ2xlID0gLXNBbmdsZSArIE1hdGguUEkgLyAyO1xuXG4gICAgICAgIGlmIChhcmMucDFbMF0gPiBhcmMucDJbMF0pIHtcbiAgICAgICAgICB1QW5nbGUgPSAyICogTWF0aC5QSSAtIHVBbmdsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1QW5nbGU7XG4gICAgICB9O1xuXG4gICAgICBhcmNzLnN0YXJ0QW5nbGUgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIGFyYyA9IGFyY3NbaWRdO1xuICAgICAgICBpZiAoYXJjID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNBbmdsZSA9IGFuZ2xlKGFyYy5wMSwgYXJjLnAzKSxcbiAgICAgICAgICB1QW5nbGUgPSAtc0FuZ2xlICsgTWF0aC5QSSAvIDI7XG5cbiAgICAgICAgaWYgKGFyYy5wMVswXSA+IGFyYy5wM1swXSkge1xuICAgICAgICAgIHVBbmdsZSA9IDIgKiBNYXRoLlBJIC0gdUFuZ2xlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVBbmdsZTtcbiAgICAgIH07XG5cbiAgICAgIGFyY3MubGVuZ3RoID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBhcmMgPSBhcmNzW2lkXTtcblxuICAgICAgICBpZiAoYXJjID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGEgPSBhcmMucDFbMF0gLSBhcmMucDJbMF0sXG4gICAgICAgICAgYiA9IGFyYy5wMVsxXSAtIGFyYy5wMlsxXSxcbiAgICAgICAgICBjID0gaHlwb3RoZW51c2UoYSwgYik7XG5cbiAgICAgICAgcmV0dXJuIGM7XG4gICAgICB9O1xuXG4gICAgICBwYy5vbignYXhlc3Jlb3JkZXIuYXJjcycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlkcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFyY3MpLmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiAhaXNOYU4oZCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIENoZWNrcyBpZiB0aGUgZmlyc3QgZGltZW5zaW9uIGlzIGRpcmVjdGx5IGxlZnQgb2YgdGhlIHNlY29uZCBkaW1lbnNpb24uXG4gICAgICAgIGZ1bmN0aW9uIGNvbnNlY3V0aXZlKGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gX18uZGltZW5zaW9ucy5sZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIF9fLmRpbWVuc2lvbnMuc29tZShmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIGQgPT09IGZpcnN0ID8gaSArIGkgPCBsZW5ndGggJiYgX18uZGltZW5zaW9uc1tpICsgMV0gPT09IHNlY29uZCA6IGZhbHNlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gV2UgaGF2ZSBzb21lIGFyY3MsIHdoaWNoIG1pZ2h0IG5lZWQgdG8gYmUgcmVtb3ZlZC5cbiAgICAgICAgICBpZHMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgdmFyIGRpbXMgPSBhcmNzW2RdLmRpbXM7XG4gICAgICAgICAgICBhcmNzLmFjdGl2ZSA9IGQ7XG4gICAgICAgICAgICAvLyBJZiB0aGUgdHdvIGRpbWVuc2lvbnMgb2YgdGhlIGN1cnJlbnQgYXJjIGFyZSBub3QgbmV4dCB0byBlYWNoIG90aGVyXG4gICAgICAgICAgICAvLyBhbnkgbW9yZSwgdGhhbiB3ZSdsbCBuZWVkIHRvIHJlbW92ZSB0aGUgYXJjLiBPdGhlcndpc2Ugd2Uga2VlcCBpdC5cbiAgICAgICAgICAgIGlmICghY29uc2VjdXRpdmUoZGltcy5sZWZ0LCBkaW1zLnJpZ2h0KSkge1xuICAgICAgICAgICAgICByZW1vdmVTdHJ1bShhcmNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBvbkRyYWdFbmQoYXJjcykoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIEFkZCBhIG5ldyBzdmcgZ3JvdXAgaW4gd2hpY2ggd2UgZHJhdyB0aGUgYXJjcy5cbiAgICAgIHBjLnNlbGVjdGlvblxuICAgICAgICAuc2VsZWN0KCdzdmcnKVxuICAgICAgICAuYXBwZW5kKCdnJylcbiAgICAgICAgLmF0dHIoJ2lkJywgJ2FyY3MnKVxuICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgX18ubWFyZ2luLmxlZnQgKyAnLCcgKyBfXy5tYXJnaW4udG9wICsgJyknKTtcblxuICAgICAgLy8gSW5zdGFsbCB0aGUgcmVxdWlyZWQgYnJ1c2hSZXNldCBmdW5jdGlvblxuICAgICAgcGMuYnJ1c2hSZXNldCA9IGJydXNoUmVzZXQoYXJjcyk7XG5cbiAgICAgIGRyYWdcbiAgICAgICAgLm9uKCdkcmFnc3RhcnQnLCBvbkRyYWdTdGFydChhcmNzKSlcbiAgICAgICAgLm9uKCdkcmFnJywgb25EcmFnKGFyY3MpKVxuICAgICAgICAub24oJ2RyYWdlbmQnLCBvbkRyYWdFbmQoYXJjcykpO1xuXG4gICAgICAvLyBOT1RFOiBUaGUgc3R5bGluZyBuZWVkcyB0byBiZSBkb25lIGhlcmUgYW5kIG5vdCBpbiB0aGUgY3NzLiBUaGlzIGlzIGJlY2F1c2VcbiAgICAgIC8vICAgICAgIGZvciAxRCBicnVzaGluZywgdGhlIGNhbnZhcyBsYXllcnMgc2hvdWxkIG5vdCBsaXN0ZW4gdG9cbiAgICAgIC8vICAgICAgIHBvaW50ZXItZXZlbnRzLlxuICAgICAgc3RydW1SZWN0ID0gcGMuc2VsZWN0aW9uXG4gICAgICAgIC5zZWxlY3QoJ3N2ZycpXG4gICAgICAgIC5pbnNlcnQoJ3JlY3QnLCAnZyNhcmNzJylcbiAgICAgICAgLmF0dHIoJ2lkJywgJ2FyYy1ldmVudHMnKVxuICAgICAgICAuYXR0cigneCcsIF9fLm1hcmdpbi5sZWZ0KVxuICAgICAgICAuYXR0cigneScsIF9fLm1hcmdpbi50b3ApXG4gICAgICAgIC5hdHRyKCd3aWR0aCcsIHcoKSlcbiAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGgoKSArIDIpXG4gICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDApXG4gICAgICAgIC5jYWxsKGRyYWcpO1xuICAgIH1cblxuICAgIGJydXNoLm1vZGVzWydhbmd1bGFyJ10gPSB7XG4gICAgICBpbnN0YWxsOiBpbnN0YWxsLFxuICAgICAgdW5pbnN0YWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHBjLnNlbGVjdGlvbi5zZWxlY3QoJ3N2ZycpLnNlbGVjdCgnZyNhcmNzJykucmVtb3ZlKCk7XG4gICAgICAgIHBjLnNlbGVjdGlvbi5zZWxlY3QoJ3N2ZycpLnNlbGVjdCgncmVjdCNhcmMtZXZlbnRzJykucmVtb3ZlKCk7XG4gICAgICAgIHBjLm9uKCdheGVzcmVvcmRlci5hcmNzJywgdW5kZWZpbmVkKTtcbiAgICAgICAgZGVsZXRlIHBjLmJydXNoUmVzZXQ7XG5cbiAgICAgICAgc3RydW1SZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgfSxcbiAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZCxcbiAgICAgIGJydXNoU3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyY3M7XG4gICAgICB9LFxuICAgIH07XG4gIH0pKCk7XG5cbiAgcGMuaW50ZXJhY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgZmxhZ3MuaW50ZXJhY3RpdmUgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIGV4cG9zZSBhIGZldyBvYmplY3RzXG4gIHBjLnhzY2FsZSA9IHhzY2FsZTtcbiAgcGMueXNjYWxlID0geXNjYWxlO1xuICBwYy5jdHggPSBjdHg7XG4gIHBjLmNhbnZhcyA9IGNhbnZhcztcbiAgcGMuZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZztcbiAgfTtcblxuICAvLyByZXNjYWxlIGZvciBoZWlnaHQsIHdpZHRoIGFuZCBtYXJnaW5zXG4gIC8vIFRPRE8gY3VycmVudGx5IGFzc3VtZXMgY2hhcnQgaXMgYnJ1c2hhYmxlLCBhbmQgZGVzdHJveXMgb2xkIGJydXNoZXNcbiAgcGMucmVzaXplID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHNlbGVjdGlvbiBzaXplXG4gICAgcGMuc2VsZWN0aW9uLnNlbGVjdCgnc3ZnJykuYXR0cignd2lkdGgnLCBfXy53aWR0aCkuYXR0cignaGVpZ2h0JywgX18uaGVpZ2h0KTtcbiAgICBwYy5zdmcuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgX18ubWFyZ2luLmxlZnQgKyAnLCcgKyBfXy5tYXJnaW4udG9wICsgJyknKTtcblxuICAgIC8vIEZJWE1FOiB0aGUgY3VycmVudCBicnVzaCBzdGF0ZSBzaG91bGQgcGFzcyB0aHJvdWdoXG4gICAgaWYgKGZsYWdzLmJydXNoYWJsZSkgcGMuYnJ1c2hSZXNldCgpO1xuXG4gICAgLy8gc2NhbGVzXG4gICAgcGMuYXV0b3NjYWxlKCk7XG5cbiAgICAvLyBheGVzLCBkZXN0cm95cyBvbGQgYnJ1c2hlcy5cbiAgICBpZiAoZykgcGMuY3JlYXRlQXhlcygpO1xuICAgIGlmIChmbGFncy5icnVzaGFibGUpIHBjLmJydXNoYWJsZSgpO1xuICAgIGlmIChmbGFncy5yZW9yZGVyYWJsZSkgcGMucmVvcmRlcmFibGUoKTtcblxuICAgIGV2ZW50cy5yZXNpemUuY2FsbCh0aGlzLCB7IHdpZHRoOiBfXy53aWR0aCwgaGVpZ2h0OiBfXy5oZWlnaHQsIG1hcmdpbjogX18ubWFyZ2luIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIGhpZ2hsaWdodCBhbiBhcnJheSBvZiBkYXRhXG4gIHBjLmhpZ2hsaWdodCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBfXy5oaWdobGlnaHRlZDtcbiAgICB9XG5cbiAgICBfXy5oaWdobGlnaHRlZCA9IGRhdGE7XG4gICAgcGMuY2xlYXIoJ2hpZ2hsaWdodCcpO1xuICAgIGQzLnNlbGVjdEFsbChbY2FudmFzLmZvcmVncm91bmQsIGNhbnZhcy5icnVzaGVkXSkuY2xhc3NlZCgnZmFkZWQnLCB0cnVlKTtcbiAgICBkYXRhLmZvckVhY2gocGF0aF9oaWdobGlnaHQpO1xuICAgIGV2ZW50cy5oaWdobGlnaHQuY2FsbCh0aGlzLCBkYXRhKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBjbGVhciBoaWdobGlnaHRpbmdcbiAgcGMudW5oaWdobGlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgX18uaGlnaGxpZ2h0ZWQgPSBbXTtcbiAgICBwYy5jbGVhcignaGlnaGxpZ2h0Jyk7XG4gICAgZDMuc2VsZWN0QWxsKFtjYW52YXMuZm9yZWdyb3VuZCwgY2FudmFzLmJydXNoZWRdKS5jbGFzc2VkKCdmYWRlZCcsIGZhbHNlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBjYWxjdWxhdGUgMmQgaW50ZXJzZWN0aW9uIG9mIGxpbmUgYS0+YiB3aXRoIGxpbmUgYy0+ZFxuICAvLyBwb2ludHMgYXJlIG9iamVjdHMgd2l0aCB4IGFuZCB5IHByb3BlcnRpZXNcbiAgcGMuaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDpcbiAgICAgICAgKChhLnggKiBiLnkgLSBhLnkgKiBiLngpICogKGMueCAtIGQueCkgLSAoYS54IC0gYi54KSAqIChjLnggKiBkLnkgLSBjLnkgKiBkLngpKSAvXG4gICAgICAgICgoYS54IC0gYi54KSAqIChjLnkgLSBkLnkpIC0gKGEueSAtIGIueSkgKiAoYy54IC0gZC54KSksXG4gICAgICB5OlxuICAgICAgICAoKGEueCAqIGIueSAtIGEueSAqIGIueCkgKiAoYy55IC0gZC55KSAtIChhLnkgLSBiLnkpICogKGMueCAqIGQueSAtIGMueSAqIGQueCkpIC9cbiAgICAgICAgKChhLnggLSBiLngpICogKGMueSAtIGQueSkgLSAoYS55IC0gYi55KSAqIChjLnggLSBkLngpKSxcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHBvc2l0aW9uKGQpIHtcbiAgICB2YXIgdiA9IGRyYWdnaW5nW2RdO1xuICAgIHJldHVybiB2ID09IG51bGwgPyB4c2NhbGUoZCkgOiB2O1xuICB9XG4gIHBjLnZlcnNpb24gPSAnMC43LjAnO1xuICAvLyB0aGlzIGRlc2NyaXB0aXZlIHRleHQgc2hvdWxkIGxpdmUgd2l0aCBvdGhlciBpbnRyb3NwZWN0aXZlIG1ldGhvZHNcbiAgcGMudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICdQYXJhbGxlbCBDb29yZGluYXRlczogJyArXG4gICAgICBfXy5kaW1lbnNpb25zLmxlbmd0aCArXG4gICAgICAnIGRpbWVuc2lvbnMgKCcgK1xuICAgICAgZDMua2V5cyhfXy5kYXRhWzBdKS5sZW5ndGggK1xuICAgICAgJyB0b3RhbCkgLCAnICtcbiAgICAgIF9fLmRhdGEubGVuZ3RoICtcbiAgICAgICcgcm93cydcbiAgICApO1xuICB9O1xuXG4gIHJldHVybiBwYztcbn1cblxuZDMucmVuZGVyUXVldWUgPSBmdW5jdGlvbiAoZnVuYykge1xuICB2YXIgX3F1ZXVlID0gW10sIC8vIGRhdGEgdG8gYmUgcmVuZGVyZWRcbiAgICBfcmF0ZSA9IDEwLCAvLyBudW1iZXIgb2YgY2FsbHMgcGVyIGZyYW1lXG4gICAgX2NsZWFyID0gZnVuY3Rpb24gKCkge30sIC8vIGNsZWFyaW5nIGZ1bmN0aW9uXG4gICAgX2kgPSAwOyAvLyBjdXJyZW50IGl0ZXJhdGlvblxuXG4gIHZhciBycSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKGRhdGEpIHJxLmRhdGEoZGF0YSk7XG4gICAgcnEuaW52YWxpZGF0ZSgpO1xuICAgIF9jbGVhcigpO1xuICAgIHJxLnJlbmRlcigpO1xuICB9O1xuXG4gIHJxLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBfaSA9IDA7XG4gICAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgICBycS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZG9GcmFtZSgpIHtcbiAgICAgIGlmICghdmFsaWQpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKF9pID4gX3F1ZXVlLmxlbmd0aCkgcmV0dXJuIHRydWU7XG5cbiAgICAgIC8vIFR5cGljYWwgZDMgYmVoYXZpb3IgaXMgdG8gcGFzcyBhIGRhdGEgaXRlbSAqYW5kKiBpdHMgaW5kZXguIEFzIHRoZVxuICAgICAgLy8gcmVuZGVyIHF1ZXVlIHNwbGl0cyB0aGUgb3JpZ2luYWwgZGF0YSBzZXQsIHdlJ2xsIGhhdmUgdG8gYmUgc2xpZ2h0bHlcbiAgICAgIC8vIG1vcmUgY2FyZWZ1bGwgYWJvdXQgcGFzc2luZyB0aGUgY29ycmVjdCBpbmRleCB3aXRoIHRoZSBkYXRhIGl0ZW0uXG4gICAgICB2YXIgZW5kID0gTWF0aC5taW4oX2kgKyBfcmF0ZSwgX3F1ZXVlLmxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gX2k7IGkgPCBlbmQ7IGkgKz0gMSkge1xuICAgICAgICBmdW5jKF9xdWV1ZVtpXSwgaSk7XG4gICAgICB9XG4gICAgICBfaSArPSBfcmF0ZTtcbiAgICB9XG5cbiAgICBkMy50aW1lcihkb0ZyYW1lKTtcbiAgfTtcblxuICBycS5kYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBycS5pbnZhbGlkYXRlKCk7XG4gICAgX3F1ZXVlID0gZGF0YS5zbGljZSgwKTtcbiAgICByZXR1cm4gcnE7XG4gIH07XG5cbiAgcnEucmF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIF9yYXRlO1xuICAgIF9yYXRlID0gdmFsdWU7XG4gICAgcmV0dXJuIHJxO1xuICB9O1xuXG4gIHJxLnJlbWFpbmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3F1ZXVlLmxlbmd0aCAtIF9pO1xuICB9O1xuXG4gIC8vIGNsZWFyIHRoZSBjYW52YXNcbiAgcnEuY2xlYXIgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgX2NsZWFyKCk7XG4gICAgICByZXR1cm4gcnE7XG4gICAgfVxuICAgIF9jbGVhciA9IGZ1bmM7XG4gICAgcmV0dXJuIHJxO1xuICB9O1xuXG4gIHJxLmludmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7fTtcblxuICByZXR1cm4gcnE7XG59O1xuIiwiLyogW0xJQ0VOU0UgVEJEXSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8vIGZyb20gaHR0cDovL2JsLm9ja3Mub3JnLzM2ODc4MjZcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgdmFyIGNvbHVtbnMgPSBbXTtcblxuICB2YXIgZGcgPSBmdW5jdGlvbiAoc2VsZWN0aW9uKSB7XG4gICAgaWYgKGNvbHVtbnMubGVuZ3RoID09IDApIGNvbHVtbnMgPSBkMy5rZXlzKHNlbGVjdGlvbi5kYXRhKClbMF1bMF0pO1xuXG4gICAgLy8gaGVhZGVyXG4gICAgc2VsZWN0aW9uLnNlbGVjdEFsbCgnLmhlYWRlcicpLmRhdGEoW3RydWVdKS5lbnRlcigpLmFwcGVuZCgnZGl2JykuYXR0cignY2xhc3MnLCAnaGVhZGVyJyk7XG5cbiAgICB2YXIgaGVhZGVyID0gc2VsZWN0aW9uLnNlbGVjdCgnLmhlYWRlcicpLnNlbGVjdEFsbCgnLmNlbGwnKS5kYXRhKGNvbHVtbnMpO1xuXG4gICAgaGVhZGVyXG4gICAgICAuZW50ZXIoKVxuICAgICAgLmFwcGVuZCgnZGl2JylcbiAgICAgIC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgIHJldHVybiAnY29sLScgKyBpO1xuICAgICAgfSlcbiAgICAgIC5jbGFzc2VkKCdjZWxsJywgdHJ1ZSk7XG5cbiAgICBzZWxlY3Rpb24uc2VsZWN0QWxsKCcuaGVhZGVyIC5jZWxsJykudGV4dChmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIGQ7XG4gICAgfSk7XG5cbiAgICBoZWFkZXIuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgLy8gcm93c1xuICAgIHZhciByb3dzID0gc2VsZWN0aW9uLnNlbGVjdEFsbCgnLnJvdycpLmRhdGEoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBkO1xuICAgIH0pO1xuXG4gICAgcm93cy5lbnRlcigpLmFwcGVuZCgnZGl2JykuYXR0cignY2xhc3MnLCAncm93Jyk7XG5cbiAgICByb3dzLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgIHZhciBjZWxscyA9IHNlbGVjdGlvblxuICAgICAgLnNlbGVjdEFsbCgnLnJvdycpXG4gICAgICAuc2VsZWN0QWxsKCcuY2VsbCcpXG4gICAgICAuZGF0YShmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gY29sdW1ucy5tYXAoZnVuY3Rpb24gKGNvbCkge1xuICAgICAgICAgIHJldHVybiBkW2NvbF07XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAvLyBjZWxsc1xuICAgIGNlbGxzXG4gICAgICAuZW50ZXIoKVxuICAgICAgLmFwcGVuZCgnZGl2JylcbiAgICAgIC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgIHJldHVybiAnY29sLScgKyBpO1xuICAgICAgfSlcbiAgICAgIC5jbGFzc2VkKCdjZWxsJywgdHJ1ZSk7XG5cbiAgICBjZWxscy5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICBzZWxlY3Rpb24uc2VsZWN0QWxsKCcuY2VsbCcpLnRleHQoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBkO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGRnO1xuICB9O1xuXG4gIGRnLmNvbHVtbnMgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNvbHVtbnM7XG4gICAgY29sdW1ucyA9IF87XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcmV0dXJuIGRnO1xufVxuIiwiLyoqXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgcmVhY3Qvc29ydC1wcm9wLXR5cGVzICovXG5pbXBvcnQgZDMgZnJvbSAnZDMnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IGdldFNlcXVlbnRpYWxTY2hlbWVSZWdpc3RyeSB9IGZyb20gJ0BzdXBlcnNldC11aS9jb3JlJztcblxuaW1wb3J0IHBhcmNvb3JkcyBmcm9tICcuL3ZlbmRvci9wYXJjb29yZHMvZDMucGFyY29vcmRzJztcbmltcG9ydCBkaXZncmlkIGZyb20gJy4vdmVuZG9yL3BhcmNvb3Jkcy9kaXZncmlkJztcbmltcG9ydCAnLi92ZW5kb3IvcGFyY29vcmRzL2QzLnBhcmNvb3Jkcy5jc3MnO1xuXG5jb25zdCBwcm9wVHlwZXMgPSB7XG4gIC8vIFN0YW5kYXJkIHRhYnVsYXIgZGF0YSBbeyBmaWVsZE5hbWUxOiB2YWx1ZTEsIGZpZWxkTmFtZTI6IHZhbHVlMiB9XVxuICBkYXRhOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMub2JqZWN0KSxcbiAgd2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXG4gIGhlaWdodDogUHJvcFR5cGVzLm51bWJlcixcbiAgY29sb3JNZXRyaWM6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGluY2x1ZGVTZXJpZXM6IFByb3BUeXBlcy5ib29sLFxuICBsaW5lYXJDb2xvclNjaGVtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgbWV0cmljczogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLnN0cmluZyksXG4gIHNlcmllczogUHJvcFR5cGVzLnN0cmluZyxcbiAgc2hvd0RhdGF0YWJsZTogUHJvcFR5cGVzLmJvb2wsXG59O1xuXG5mdW5jdGlvbiBQYXJhbGxlbENvb3JkaW5hdGVzKGVsZW1lbnQsIHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBkYXRhLFxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBjb2xvck1ldHJpYyxcbiAgICBpbmNsdWRlU2VyaWVzLFxuICAgIGxpbmVhckNvbG9yU2NoZW1lLFxuICAgIG1ldHJpY3MsXG4gICAgc2VyaWVzLFxuICAgIHNob3dEYXRhdGFibGUsXG4gIH0gPSBwcm9wcztcblxuICBjb25zdCBjb2xzID0gaW5jbHVkZVNlcmllcyA/IFtzZXJpZXNdLmNvbmNhdChtZXRyaWNzKSA6IG1ldHJpY3M7XG5cbiAgY29uc3QgdHR5cGVzID0ge307XG4gIHR0eXBlc1tzZXJpZXNdID0gJ3N0cmluZyc7XG4gIG1ldHJpY3MuZm9yRWFjaCh2ID0+IHtcbiAgICB0dHlwZXNbdl0gPSAnbnVtYmVyJztcbiAgfSk7XG5cbiAgY29uc3QgY29sb3JTY2FsZSA9IGNvbG9yTWV0cmljXG4gICAgPyBnZXRTZXF1ZW50aWFsU2NoZW1lUmVnaXN0cnkoKVxuICAgICAgICAuZ2V0KGxpbmVhckNvbG9yU2NoZW1lKVxuICAgICAgICAuY3JlYXRlTGluZWFyU2NhbGUoZDMuZXh0ZW50KGRhdGEsIGQgPT4gZFtjb2xvck1ldHJpY10pKVxuICAgIDogKCkgPT4gJ2dyZXknO1xuICBjb25zdCBjb2xvciA9IGQgPT4gY29sb3JTY2FsZShkW2NvbG9yTWV0cmljXSk7XG4gIGNvbnN0IGNvbnRhaW5lciA9IGQzLnNlbGVjdChlbGVtZW50KS5jbGFzc2VkKCdzdXBlcnNldC1sZWdhY3ktY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMnLCB0cnVlKTtcbiAgY29udGFpbmVyLnNlbGVjdEFsbCgnKicpLnJlbW92ZSgpO1xuICBjb25zdCBlZmZIZWlnaHQgPSBzaG93RGF0YXRhYmxlID8gaGVpZ2h0IC8gMiA6IGhlaWdodDtcblxuICBjb25zdCBkaXYgPSBjb250YWluZXIuYXBwZW5kKCdkaXYnKS5zdHlsZSgnaGVpZ2h0JywgYCR7ZWZmSGVpZ2h0fXB4YCkuY2xhc3NlZCgncGFyY29vcmRzJywgdHJ1ZSk7XG5cbiAgY29uc3QgY2hhcnQgPSBwYXJjb29yZHMoKShkaXYubm9kZSgpKVxuICAgIC53aWR0aCh3aWR0aClcbiAgICAuY29sb3IoY29sb3IpXG4gICAgLmFscGhhKDAuNSlcbiAgICAuY29tcG9zaXRlKCdkYXJrZW4nKVxuICAgIC5oZWlnaHQoZWZmSGVpZ2h0KVxuICAgIC5kYXRhKGRhdGEpXG4gICAgLmRpbWVuc2lvbnMoY29scylcbiAgICAudHlwZXModHR5cGVzKVxuICAgIC5yZW5kZXIoKVxuICAgIC5jcmVhdGVBeGVzKClcbiAgICAuc2hhZG93cygpXG4gICAgLnJlb3JkZXJhYmxlKClcbiAgICAuYnJ1c2hNb2RlKCcxRC1heGVzJyk7XG5cbiAgaWYgKHNob3dEYXRhdGFibGUpIHtcbiAgICAvLyBjcmVhdGUgZGF0YSB0YWJsZSwgcm93IGhvdmVyIGhpZ2hsaWdodGluZ1xuICAgIGNvbnN0IGdyaWQgPSBkaXZncmlkKCk7XG4gICAgY29udGFpbmVyXG4gICAgICAuYXBwZW5kKCdkaXYnKVxuICAgICAgLnN0eWxlKCdoZWlnaHQnLCBgJHtlZmZIZWlnaHR9cHhgKVxuICAgICAgLmRhdHVtKGRhdGEpXG4gICAgICAuY2FsbChncmlkKVxuICAgICAgLmNsYXNzZWQoJ3BhcmNvb3JkcyBncmlkJywgdHJ1ZSlcbiAgICAgIC5zZWxlY3RBbGwoJy5yb3cnKVxuICAgICAgLm9uKHtcbiAgICAgICAgbW91c2VvdmVyKGQpIHtcbiAgICAgICAgICBjaGFydC5oaWdobGlnaHQoW2RdKTtcbiAgICAgICAgfSxcbiAgICAgICAgbW91c2VvdXQ6IGNoYXJ0LnVuaGlnaGxpZ2h0LFxuICAgICAgfSk7XG4gICAgLy8gdXBkYXRlIGRhdGEgdGFibGUgb24gYnJ1c2ggZXZlbnRcbiAgICBjaGFydC5vbignYnJ1c2gnLCBkID0+IHtcbiAgICAgIGQzLnNlbGVjdCgnLmdyaWQnKVxuICAgICAgICAuZGF0dW0oZClcbiAgICAgICAgLmNhbGwoZ3JpZClcbiAgICAgICAgLnNlbGVjdEFsbCgnLnJvdycpXG4gICAgICAgIC5vbih7XG4gICAgICAgICAgbW91c2VvdmVyKGRkKSB7XG4gICAgICAgICAgICBjaGFydC5oaWdobGlnaHQoW2RkXSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBtb3VzZW91dDogY2hhcnQudW5oaWdobGlnaHQsXG4gICAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5cblBhcmFsbGVsQ29vcmRpbmF0ZXMuZGlzcGxheU5hbWUgPSAnUGFyYWxsZWxDb29yZGluYXRlcyc7XG5QYXJhbGxlbENvb3JkaW5hdGVzLnByb3BUeXBlcyA9IHByb3BUeXBlcztcblxuZXhwb3J0IGRlZmF1bHQgUGFyYWxsZWxDb29yZGluYXRlcztcbiIsIi8qKlxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBzdHlsZWQsIHJlYWN0aWZ5IH0gZnJvbSAnQHN1cGVyc2V0LXVpL2NvcmUnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi9QYXJhbGxlbENvb3JkaW5hdGVzJztcblxuY29uc3QgUmVhY3RDb21wb25lbnQgPSByZWFjdGlmeShDb21wb25lbnQpO1xuXG5jb25zdCBQYXJhbGxlbENvb3JkaWFuZXMgPSAoeyBjbGFzc05hbWUsIC4uLm90aGVyUHJvcHMgfSkgPT4gKFxuICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3NOYW1lfT5cbiAgICA8UmVhY3RDb21wb25lbnQgey4uLm90aGVyUHJvcHN9IC8+XG4gIDwvZGl2PlxuKTtcblxuUGFyYWxsZWxDb29yZGlhbmVzLnByb3BUeXBlcyA9IHtcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBzdHlsZWQoUGFyYWxsZWxDb29yZGlhbmVzKWBcbiAgLnN1cGVyc2V0LWxlZ2FjeS1jaGFydC1wYXJhbGxlbC1jb29yZGluYXRlcyB7XG4gICAgZGl2LmdyaWQge1xuICAgICAgb3ZlcmZsb3c6IGF1dG87XG4gICAgICBkaXYucm93IHtcbiAgICAgICAgJjpob3ZlciB7XG4gICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2NjYztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuYDtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBbUJBO0FBb0JBO0FBTUE7QUFnQ0E7QUEwREE7QUFJQTtBQU1BO0FBSEE7QUEwQ0E7QUFPQTtBQVlBO0FBV0E7QUFDQTtBQUdBO0FBeUJBO0FBR0E7QUFRQTtBQXFCQTtBQUVBO0FBVUE7QUE2QkE7QUFhQTtBQVFBO0FBUUE7QUFTQTtBQTJFQTtBQU1BO0FBa0NBO0FBQUE7QUFPQTtBQTBEQTtBQWtCQTtBQXVCQTtBQXdCQTtBQUNBO0FBNkNBO0FBQ0E7QUFDQTtBQTZDQTtBQU1BO0FBYUE7QUF1REE7QUEyQkE7QUFnQkE7QUE2QkE7QUFzQkE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFxQkE7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBR0E7QUFJQTtBQUNBO0FBQ0E7QUFtQkE7QUFPQTtBQVlBO0FBQ0E7QUFHQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFvQ0E7QUFDQTtBQUVBO0FBQ0E7QUFLQTtBQUVBO0FBY0E7QUFRQTtBQU9BO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUlBO0FBVUE7QUE0Q0E7QUFNQTtBQVFBO0FBR0E7QUFHQTtBQUtBO0FBc0NBO0FBNEJBO0FBRUE7QUFxRkE7QUFLQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBc0JBO0FBV0E7QUFlQTtBQW1CQTtBQW1EQTtBQUNBO0FBOEJBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQWdCQTtBQVNBO0FBSUE7QUFDQTtBQVNBO0FBT0E7QUFRQTtBQUNBO0FBQ0E7QUE4QkE7QUFFQTtBQVdBO0FBT0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBSUE7QUFRQTtBQXlEQTtBQUNBO0FBQ0E7QUFDQTtBQTZCQTtBQTRCQTtBQUVBO0FBc0hBO0FBS0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQXlCQTtBQVlBO0FBUUE7Ozs7O0FBcUNBO0FBV0E7QUFjQTtBQWVBO0FBd0NBO0FBQ0E7QUFzQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBV0E7QUFTQTtBQW1EQTtBQVNBO0FBSUE7QUFDQTtBQVNBO0FBT0E7QUFRQTtBQUNBO0FBQ0E7QUFtQ0E7QUFTQTtBQUNBO0FBRUE7QUFJQTtBQUdBO0FBR0E7QUFTQTtBQWNBO0FBUUE7QUFDQTtBQWlCQTtBQWlCQTtBQUNBO0FBQ0E7QUFTQTtBQVlBO0FBQ0E7QUFFQTtBQTBCQTs7QUM3eUVBO0FBR0E7QUFPQTtBQW1CQTtBQWtCQTs7Ozs7QUMvQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBO0FBV0E7QUE2REE7QUFlQTs7QUN6R0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBOzs7Ozs7Ozs7OztBQWlCQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2509\n')}}]);