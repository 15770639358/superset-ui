(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{1271:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _classCallCheck; });\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError("Cannot call a class as a function");\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI3MS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrLmpzP2MwZTEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1271\n')},1272:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _createClass; });\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if ("value" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI3Mi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzLmpzPzdiNzgiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1272\n')},1275:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _defineProperty; });\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI3NS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5LmpzP2ViMmUiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1275\n')},1278:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _getPrototypeOf; });\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI3OC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2dldFByb3RvdHlwZU9mLmpzPzk4ZmIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1278\n')},1280:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _possibleConstructorReturn; });\n/* harmony import */ var _helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1338);\n/* harmony import */ var _assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1283);\n\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (Object(_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(call) === "object" || typeof call === "function")) {\n    return call;\n  }\n\n  return Object(_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(self);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI4MC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanM/NzVkOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX3R5cGVvZiBmcm9tIFwiLi4vLi4vaGVscGVycy9lc20vdHlwZW9mXCI7XG5pbXBvcnQgYXNzZXJ0VGhpc0luaXRpYWxpemVkIGZyb20gXCIuL2Fzc2VydFRoaXNJbml0aWFsaXplZFwiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9XG5cbiAgcmV0dXJuIGFzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1280\n')},1282:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ _inherits; });\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@babel/runtime/helpers/esm/inherits.js\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== "function" && superClass !== null) {\n    throw new TypeError("Super expression must either be null or a function");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI4Mi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NldFByb3RvdHlwZU9mLmpzP2JhN2EiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHMuanM/NTY0NyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn0iLCJpbXBvcnQgc2V0UHJvdG90eXBlT2YgZnJvbSBcIi4vc2V0UHJvdG90eXBlT2ZcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIHNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn0iXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1282\n')},1283:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _assertThisInitialized; });\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called");\n  }\n\n  return self;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI4My5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2Fzc2VydFRoaXNJbml0aWFsaXplZC5qcz8zZWUzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1283\n')},1338:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _typeof; });\nfunction _typeof(obj) {\n  "@babel/helpers - typeof";\n\n  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMzOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3R5cGVvZi5qcz80ZjQxIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1338\n')},1352:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* unused harmony export numericBinnedDatumShape */\n/* unused harmony export categoricalBinnedDatumShape */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return binnedDataShape; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return axisStylesShape; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return tickStylesShape; });\n/* unused harmony export gridStylesShape */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return themeShape; });\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);\n\nvar numericBinnedDatumShape = prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.shape({\n  id: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string.isRequired,\n  bin0: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number.isRequired,\n  bin1: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number.isRequired,\n  count: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number.isRequired,\n  cumulative: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number,\n  density: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number,\n  cumulativeDensity: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number\n});\nvar categoricalBinnedDatumShape = prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.shape({\n  id: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string.isRequired,\n  bin: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string.isRequired,\n  count: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number.isRequired,\n  cumulative: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number,\n  density: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number,\n  cumulativeDensity: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number\n});\nvar binnedDataShape = prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.oneOfType([numericBinnedDatumShape, categoricalBinnedDatumShape])); // styles ---------------------------------------------------------------------\n\nvar axisStylesShape = prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.shape({\n  stroke: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,\n  strokeWidth: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number,\n  label: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.shape({\n    left: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.object,\n    right: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.object,\n    bottom: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.object,\n    top: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.object\n  })\n});\nvar tickStylesShape = prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.shape({\n  stroke: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,\n  tickLength: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number,\n  label: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.shape({\n    left: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.object,\n    right: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.object,\n    bottom: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.object,\n    top: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.object\n  })\n});\nvar gridStylesShape = prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.shape({\n  stroke: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,\n  strokeWidth: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number\n});\nvar themeShape = prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.shape({\n  gridStyles: gridStylesShape,\n  xAxisStyles: axisStylesShape,\n  xTickStyles: tickStylesShape,\n  yAxisStyles: axisStylesShape,\n  yTickStyles: tickStylesShape\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM1Mi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL2hpc3RvZ3JhbS9lc20vdXRpbHMvcHJvcFNoYXBlcy5qcz9iOWUyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5leHBvcnQgdmFyIG51bWVyaWNCaW5uZWREYXR1bVNoYXBlID0gUHJvcFR5cGVzLnNoYXBlKHtcbiAgaWQ6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgYmluMDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICBiaW4xOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIGNvdW50OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIGN1bXVsYXRpdmU6IFByb3BUeXBlcy5udW1iZXIsXG4gIGRlbnNpdHk6IFByb3BUeXBlcy5udW1iZXIsXG4gIGN1bXVsYXRpdmVEZW5zaXR5OiBQcm9wVHlwZXMubnVtYmVyXG59KTtcbmV4cG9ydCB2YXIgY2F0ZWdvcmljYWxCaW5uZWREYXR1bVNoYXBlID0gUHJvcFR5cGVzLnNoYXBlKHtcbiAgaWQ6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgYmluOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gIGNvdW50OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIGN1bXVsYXRpdmU6IFByb3BUeXBlcy5udW1iZXIsXG4gIGRlbnNpdHk6IFByb3BUeXBlcy5udW1iZXIsXG4gIGN1bXVsYXRpdmVEZW5zaXR5OiBQcm9wVHlwZXMubnVtYmVyXG59KTtcbmV4cG9ydCB2YXIgYmlubmVkRGF0YVNoYXBlID0gUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm9uZU9mVHlwZShbbnVtZXJpY0Jpbm5lZERhdHVtU2hhcGUsIGNhdGVnb3JpY2FsQmlubmVkRGF0dW1TaGFwZV0pKTsgLy8gc3R5bGVzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgdmFyIGF4aXNTdHlsZXNTaGFwZSA9IFByb3BUeXBlcy5zaGFwZSh7XG4gIHN0cm9rZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgc3Ryb2tlV2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXG4gIGxhYmVsOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGxlZnQ6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgcmlnaHQ6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgYm90dG9tOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIHRvcDogUHJvcFR5cGVzLm9iamVjdFxuICB9KVxufSk7XG5leHBvcnQgdmFyIHRpY2tTdHlsZXNTaGFwZSA9IFByb3BUeXBlcy5zaGFwZSh7XG4gIHN0cm9rZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdGlja0xlbmd0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgbGFiZWw6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgbGVmdDogUHJvcFR5cGVzLm9iamVjdCxcbiAgICByaWdodDogUHJvcFR5cGVzLm9iamVjdCxcbiAgICBib3R0b206IFByb3BUeXBlcy5vYmplY3QsXG4gICAgdG9wOiBQcm9wVHlwZXMub2JqZWN0XG4gIH0pXG59KTtcbmV4cG9ydCB2YXIgZ3JpZFN0eWxlc1NoYXBlID0gUHJvcFR5cGVzLnNoYXBlKHtcbiAgc3Ryb2tlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBzdHJva2VXaWR0aDogUHJvcFR5cGVzLm51bWJlclxufSk7XG5leHBvcnQgdmFyIHRoZW1lU2hhcGUgPSBQcm9wVHlwZXMuc2hhcGUoe1xuICBncmlkU3R5bGVzOiBncmlkU3R5bGVzU2hhcGUsXG4gIHhBeGlzU3R5bGVzOiBheGlzU3R5bGVzU2hhcGUsXG4gIHhUaWNrU3R5bGVzOiB0aWNrU3R5bGVzU2hhcGUsXG4gIHlBeGlzU3R5bGVzOiBheGlzU3R5bGVzU2hhcGUsXG4gIHlUaWNrU3R5bGVzOiB0aWNrU3R5bGVzU2hhcGVcbn0pOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1352\n')},1371:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return now; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Timer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return timer; });\n/* unused harmony export timerFlush */\nvar frame = 0, // is an animation frame pending?\n    timeout = 0, // is a timeout pending?\n    interval = 0, // are any timers active?\n    pokeDelay = 1000, // how frequently we check for clock skew\n    taskHead,\n    taskTail,\n    clockLast = 0,\n    clockNow = 0,\n    clockSkew = 0,\n    clock = typeof performance === "object" && performance.now ? performance : Date,\n    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };\n\nfunction now() {\n  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);\n}\n\nfunction clearNow() {\n  clockNow = 0;\n}\n\nfunction Timer() {\n  this._call =\n  this._time =\n  this._next = null;\n}\n\nTimer.prototype = timer.prototype = {\n  constructor: Timer,\n  restart: function(callback, delay, time) {\n    if (typeof callback !== "function") throw new TypeError("callback is not a function");\n    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);\n    if (!this._next && taskTail !== this) {\n      if (taskTail) taskTail._next = this;\n      else taskHead = this;\n      taskTail = this;\n    }\n    this._call = callback;\n    this._time = time;\n    sleep();\n  },\n  stop: function() {\n    if (this._call) {\n      this._call = null;\n      this._time = Infinity;\n      sleep();\n    }\n  }\n};\n\nfunction timer(callback, delay, time) {\n  var t = new Timer;\n  t.restart(callback, delay, time);\n  return t;\n}\n\nfunction timerFlush() {\n  now(); // Get the current time, if not already set.\n  ++frame; // Pretend we’ve set an alarm, if we haven’t already.\n  var t = taskHead, e;\n  while (t) {\n    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);\n    t = t._next;\n  }\n  --frame;\n}\n\nfunction wake() {\n  clockNow = (clockLast = clock.now()) + clockSkew;\n  frame = timeout = 0;\n  try {\n    timerFlush();\n  } finally {\n    frame = 0;\n    nap();\n    clockNow = 0;\n  }\n}\n\nfunction poke() {\n  var now = clock.now(), delay = now - clockLast;\n  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;\n}\n\nfunction nap() {\n  var t0, t1 = taskHead, t2, time = Infinity;\n  while (t1) {\n    if (t1._call) {\n      if (time > t1._time) time = t1._time;\n      t0 = t1, t1 = t1._next;\n    } else {\n      t2 = t1._next, t1._next = null;\n      t1 = t0 ? t0._next = t2 : taskHead = t2;\n    }\n  }\n  taskTail = t0;\n  sleep(time);\n}\n\nfunction sleep(time) {\n  if (frame) return; // Soonest alarm already set, or will be.\n  if (timeout) timeout = clearTimeout(timeout);\n  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.\n  if (delay > 24) {\n    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);\n    if (interval) interval = clearInterval(interval);\n  } else {\n    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);\n    frame = 1, setFrame(wake);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM3MS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2QzLXRpbWVyL3NyYy90aW1lci5qcz9lNjA4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBmcmFtZSA9IDAsIC8vIGlzIGFuIGFuaW1hdGlvbiBmcmFtZSBwZW5kaW5nP1xuICAgIHRpbWVvdXQgPSAwLCAvLyBpcyBhIHRpbWVvdXQgcGVuZGluZz9cbiAgICBpbnRlcnZhbCA9IDAsIC8vIGFyZSBhbnkgdGltZXJzIGFjdGl2ZT9cbiAgICBwb2tlRGVsYXkgPSAxMDAwLCAvLyBob3cgZnJlcXVlbnRseSB3ZSBjaGVjayBmb3IgY2xvY2sgc2tld1xuICAgIHRhc2tIZWFkLFxuICAgIHRhc2tUYWlsLFxuICAgIGNsb2NrTGFzdCA9IDAsXG4gICAgY2xvY2tOb3cgPSAwLFxuICAgIGNsb2NrU2tldyA9IDAsXG4gICAgY2xvY2sgPSB0eXBlb2YgcGVyZm9ybWFuY2UgPT09IFwib2JqZWN0XCIgJiYgcGVyZm9ybWFuY2Uubm93ID8gcGVyZm9ybWFuY2UgOiBEYXRlLFxuICAgIHNldEZyYW1lID0gdHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIiAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdykgOiBmdW5jdGlvbihmKSB7IHNldFRpbWVvdXQoZiwgMTcpOyB9O1xuXG5leHBvcnQgZnVuY3Rpb24gbm93KCkge1xuICByZXR1cm4gY2xvY2tOb3cgfHwgKHNldEZyYW1lKGNsZWFyTm93KSwgY2xvY2tOb3cgPSBjbG9jay5ub3coKSArIGNsb2NrU2tldyk7XG59XG5cbmZ1bmN0aW9uIGNsZWFyTm93KCkge1xuICBjbG9ja05vdyA9IDA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBUaW1lcigpIHtcbiAgdGhpcy5fY2FsbCA9XG4gIHRoaXMuX3RpbWUgPVxuICB0aGlzLl9uZXh0ID0gbnVsbDtcbn1cblxuVGltZXIucHJvdG90eXBlID0gdGltZXIucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogVGltZXIsXG4gIHJlc3RhcnQ6IGZ1bmN0aW9uKGNhbGxiYWNrLCBkZWxheSwgdGltZSkge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbGxiYWNrIGlzIG5vdCBhIGZ1bmN0aW9uXCIpO1xuICAgIHRpbWUgPSAodGltZSA9PSBudWxsID8gbm93KCkgOiArdGltZSkgKyAoZGVsYXkgPT0gbnVsbCA/IDAgOiArZGVsYXkpO1xuICAgIGlmICghdGhpcy5fbmV4dCAmJiB0YXNrVGFpbCAhPT0gdGhpcykge1xuICAgICAgaWYgKHRhc2tUYWlsKSB0YXNrVGFpbC5fbmV4dCA9IHRoaXM7XG4gICAgICBlbHNlIHRhc2tIZWFkID0gdGhpcztcbiAgICAgIHRhc2tUYWlsID0gdGhpcztcbiAgICB9XG4gICAgdGhpcy5fY2FsbCA9IGNhbGxiYWNrO1xuICAgIHRoaXMuX3RpbWUgPSB0aW1lO1xuICAgIHNsZWVwKCk7XG4gIH0sXG4gIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9jYWxsKSB7XG4gICAgICB0aGlzLl9jYWxsID0gbnVsbDtcbiAgICAgIHRoaXMuX3RpbWUgPSBJbmZpbml0eTtcbiAgICAgIHNsZWVwKCk7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gdGltZXIoY2FsbGJhY2ssIGRlbGF5LCB0aW1lKSB7XG4gIHZhciB0ID0gbmV3IFRpbWVyO1xuICB0LnJlc3RhcnQoY2FsbGJhY2ssIGRlbGF5LCB0aW1lKTtcbiAgcmV0dXJuIHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aW1lckZsdXNoKCkge1xuICBub3coKTsgLy8gR2V0IHRoZSBjdXJyZW50IHRpbWUsIGlmIG5vdCBhbHJlYWR5IHNldC5cbiAgKytmcmFtZTsgLy8gUHJldGVuZCB3ZeKAmXZlIHNldCBhbiBhbGFybSwgaWYgd2UgaGF2ZW7igJl0IGFscmVhZHkuXG4gIHZhciB0ID0gdGFza0hlYWQsIGU7XG4gIHdoaWxlICh0KSB7XG4gICAgaWYgKChlID0gY2xvY2tOb3cgLSB0Ll90aW1lKSA+PSAwKSB0Ll9jYWxsLmNhbGwobnVsbCwgZSk7XG4gICAgdCA9IHQuX25leHQ7XG4gIH1cbiAgLS1mcmFtZTtcbn1cblxuZnVuY3Rpb24gd2FrZSgpIHtcbiAgY2xvY2tOb3cgPSAoY2xvY2tMYXN0ID0gY2xvY2subm93KCkpICsgY2xvY2tTa2V3O1xuICBmcmFtZSA9IHRpbWVvdXQgPSAwO1xuICB0cnkge1xuICAgIHRpbWVyRmx1c2goKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBmcmFtZSA9IDA7XG4gICAgbmFwKCk7XG4gICAgY2xvY2tOb3cgPSAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBva2UoKSB7XG4gIHZhciBub3cgPSBjbG9jay5ub3coKSwgZGVsYXkgPSBub3cgLSBjbG9ja0xhc3Q7XG4gIGlmIChkZWxheSA+IHBva2VEZWxheSkgY2xvY2tTa2V3IC09IGRlbGF5LCBjbG9ja0xhc3QgPSBub3c7XG59XG5cbmZ1bmN0aW9uIG5hcCgpIHtcbiAgdmFyIHQwLCB0MSA9IHRhc2tIZWFkLCB0MiwgdGltZSA9IEluZmluaXR5O1xuICB3aGlsZSAodDEpIHtcbiAgICBpZiAodDEuX2NhbGwpIHtcbiAgICAgIGlmICh0aW1lID4gdDEuX3RpbWUpIHRpbWUgPSB0MS5fdGltZTtcbiAgICAgIHQwID0gdDEsIHQxID0gdDEuX25leHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHQyID0gdDEuX25leHQsIHQxLl9uZXh0ID0gbnVsbDtcbiAgICAgIHQxID0gdDAgPyB0MC5fbmV4dCA9IHQyIDogdGFza0hlYWQgPSB0MjtcbiAgICB9XG4gIH1cbiAgdGFza1RhaWwgPSB0MDtcbiAgc2xlZXAodGltZSk7XG59XG5cbmZ1bmN0aW9uIHNsZWVwKHRpbWUpIHtcbiAgaWYgKGZyYW1lKSByZXR1cm47IC8vIFNvb25lc3QgYWxhcm0gYWxyZWFkeSBzZXQsIG9yIHdpbGwgYmUuXG4gIGlmICh0aW1lb3V0KSB0aW1lb3V0ID0gY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICB2YXIgZGVsYXkgPSB0aW1lIC0gY2xvY2tOb3c7IC8vIFN0cmljdGx5IGxlc3MgdGhhbiBpZiB3ZSByZWNvbXB1dGVkIGNsb2NrTm93LlxuICBpZiAoZGVsYXkgPiAyNCkge1xuICAgIGlmICh0aW1lIDwgSW5maW5pdHkpIHRpbWVvdXQgPSBzZXRUaW1lb3V0KHdha2UsIHRpbWUgLSBjbG9jay5ub3coKSAtIGNsb2NrU2tldyk7XG4gICAgaWYgKGludGVydmFsKSBpbnRlcnZhbCA9IGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICB9IGVsc2Uge1xuICAgIGlmICghaW50ZXJ2YWwpIGNsb2NrTGFzdCA9IGNsb2NrLm5vdygpLCBpbnRlcnZhbCA9IHNldEludGVydmFsKHBva2UsIHBva2VEZWxheSk7XG4gICAgZnJhbWUgPSAxLCBzZXRGcmFtZSh3YWtlKTtcbiAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1371\n')},1394:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* unused harmony export Arc */\n/* unused harmony export Pie */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return Line; });\n/* unused harmony export LinePath */\n/* unused harmony export LineRadial */\n/* unused harmony export Area */\n/* unused harmony export AreaClosed */\n/* unused harmony export AreaStack */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Bar; });\n/* unused harmony export BarGroup */\n/* unused harmony export BarGroupHorizontal */\n/* unused harmony export BarStack */\n/* unused harmony export BarStackHorizontal */\n/* unused harmony export Stack */\n/* unused harmony export callOrValue */\n/* unused harmony export stackOffset */\n/* unused harmony export STACK_OFFSETS */\n/* unused harmony export STACK_OFFSET_NAMES */\n/* unused harmony export stackOrder */\n/* unused harmony export STACK_ORDERS */\n/* unused harmony export STACK_ORDER_NAMES */\n/* unused harmony export degreesToRadians */\n/* unused harmony export LinkHorizontal */\n/* unused harmony export pathHorizontalDiagonal */\n/* unused harmony export LinkVertical */\n/* unused harmony export pathVerticalDiagonal */\n/* unused harmony export LinkRadial */\n/* unused harmony export pathRadialDiagonal */\n/* unused harmony export LinkHorizontalCurve */\n/* unused harmony export pathHorizontalCurve */\n/* unused harmony export LinkVerticalCurve */\n/* unused harmony export pathVerticalCurve */\n/* unused harmony export LinkRadialCurve */\n/* unused harmony export pathRadialCurve */\n/* unused harmony export LinkHorizontalLine */\n/* unused harmony export pathHorizontalLine */\n/* unused harmony export LinkVerticalLine */\n/* unused harmony export pathVerticalLine */\n/* unused harmony export LinkRadialLine */\n/* unused harmony export pathRadialLine */\n/* unused harmony export LinkHorizontalStep */\n/* unused harmony export pathHorizontalStep */\n/* unused harmony export LinkVerticalStep */\n/* unused harmony export pathVerticalStep */\n/* unused harmony export LinkRadialStep */\n/* unused harmony export pathRadialStep */\n/* unused harmony export Polygon */\n/* unused harmony export getPoints */\n/* unused harmony export getPoint */\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(130);\n/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2265);\n/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2310);\n/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(1440);\n/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(2325);\n/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(2267);\n/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(2268);\n/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(1442);\n/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(2269);\n/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(2326);\n/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(1368);\n/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(2270);\n/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(2271);\n/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(2272);\n/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(1369);\n/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(2273);\n/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(2274);\n/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(2327);\n/* harmony import */ var _vx_group__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(1336);\n/* harmony import */ var _vx_point__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(1302);\n/* harmony import */ var _vx_curve__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(1395);\n/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(2266);\n\n\n\n\n\n\n\n\n\nfunction callOrValue(maybeFn, data) {\n  if (typeof maybeFn === 'function') {\n    return maybeFn(data);\n  }\n  return maybeFn;\n}\n\nfunction additionalProps(restProps, data) {\n  return Object.keys(restProps).reduce(function (ret, cur) {\n    ret[cur] = callOrValue(restProps[cur], data);\n    return ret;\n  }, {});\n}\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\nArc.propTypes = {\n  className: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string,\n  data: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.any,\n  centroid: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number]),\n  innerRadius: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number]),\n  outerRadius: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number]),\n  cornerRadius: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number]),\n  startAngle: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number]),\n  endAngle: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number]),\n  padAngle: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number]),\n  padRadius: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number])\n};\n\nfunction Arc(_ref) {\n  var className = _ref.className,\n      data = _ref.data,\n      centroid = _ref.centroid,\n      innerRadius = _ref.innerRadius,\n      outerRadius = _ref.outerRadius,\n      cornerRadius = _ref.cornerRadius,\n      startAngle = _ref.startAngle,\n      endAngle = _ref.endAngle,\n      padAngle = _ref.padAngle,\n      padRadius = _ref.padRadius,\n      restProps = objectWithoutProperties(_ref, ['className', 'data', 'centroid', 'innerRadius', 'outerRadius', 'cornerRadius', 'startAngle', 'endAngle', 'padAngle', 'padRadius']);\n\n  var arc$$1 = Object(d3_shape__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])();\n  if (centroid) arc$$1.centroid(centroid);\n  if (innerRadius) arc$$1.innerRadius(innerRadius);\n  if (outerRadius) arc$$1.outerRadius(outerRadius);\n  if (cornerRadius) arc$$1.cornerRadius(cornerRadius);\n  if (startAngle) arc$$1.startAngle(startAngle);\n  if (endAngle) arc$$1.endAngle(endAngle);\n  if (padAngle) arc$$1.padAngle(padAngle);\n  if (padRadius) arc$$1.padRadius(padRadius);\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('path', _extends({ className: classnames__WEBPACK_IMPORTED_MODULE_1___default()('vx-arc', className), d: arc$$1(data) }, additionalProps(restProps, data)));\n}\n\nPie.propTypes = {\n  className: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string,\n  top: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number,\n  left: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number,\n  data: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.array,\n  centroid: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number]),\n  innerRadius: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number]),\n  outerRadius: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number]),\n  cornerRadius: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number]),\n  startAngle: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number]),\n  endAngle: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number]),\n  padAngle: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number]),\n  padRadius: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number]),\n  pieSort: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  pieSortValues: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  pieValue: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number]),\n  children: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func\n};\n\nfunction Pie(_ref) {\n  var _ref$className = _ref.className,\n      className = _ref$className === undefined ? '' : _ref$className,\n      _ref$top = _ref.top,\n      top = _ref$top === undefined ? 0 : _ref$top,\n      _ref$left = _ref.left,\n      left = _ref$left === undefined ? 0 : _ref$left,\n      data = _ref.data,\n      centroid = _ref.centroid,\n      _ref$innerRadius = _ref.innerRadius,\n      innerRadius = _ref$innerRadius === undefined ? 0 : _ref$innerRadius,\n      outerRadius = _ref.outerRadius,\n      cornerRadius = _ref.cornerRadius,\n      _ref$startAngle = _ref.startAngle,\n      startAngle = _ref$startAngle === undefined ? 0 : _ref$startAngle,\n      endAngle = _ref.endAngle,\n      padAngle = _ref.padAngle,\n      padRadius = _ref.padRadius,\n      pieSort = _ref.pieSort,\n      pieSortValues = _ref.pieSortValues,\n      pieValue = _ref.pieValue,\n      children = _ref.children,\n      restProps = objectWithoutProperties(_ref, ['className', 'top', 'left', 'data', 'centroid', 'innerRadius', 'outerRadius', 'cornerRadius', 'startAngle', 'endAngle', 'padAngle', 'padRadius', 'pieSort', 'pieSortValues', 'pieValue', 'children']);\n\n  var path$$1 = Object(d3_shape__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])();\n  path$$1.innerRadius(innerRadius);\n  if (outerRadius) path$$1.outerRadius(outerRadius);\n  if (cornerRadius) path$$1.cornerRadius(cornerRadius);\n  if (padRadius) path$$1.padRadius(padRadius);\n  var pie$$1 = Object(d3_shape__WEBPACK_IMPORTED_MODULE_4__[/* default */ \"a\"])();\n  if (pieSort !== undefined) pie$$1.sort(pieSort);\n  if (pieSortValues !== undefined) pie$$1.sortValues(pieSortValues);\n  if (pieValue) pie$$1.value(pieValue);\n  if (padAngle != null) pie$$1.padAngle(padAngle);\n  if (startAngle != null) pie$$1.startAngle(startAngle);\n  if (endAngle != null) pie$$1.endAngle(endAngle);\n  var arcs = pie$$1(data);\n  var renderFunctionArg = {\n    arcs: arcs,\n    generatePathProps: function generatePathProps(arc$$1, index) {\n      return _extends({\n        className: classnames__WEBPACK_IMPORTED_MODULE_1___default()('vx-pie-arc', className),\n        d: path$$1(arc$$1)\n      }, additionalProps(restProps, _extends({}, arc$$1, {\n        index: index,\n        centroid: centroid ? path$$1.centroid(arc$$1) : undefined\n      })));\n    },\n    generateCentroid: function generateCentroid(arc$$1) {\n      return centroid && centroid(path$$1.centroid(arc$$1), arc$$1);\n    }\n  };\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n    _vx_group__WEBPACK_IMPORTED_MODULE_20__[/* Group */ \"a\"],\n    { className: 'vx-pie-arcs-group', top: top, left: left },\n    children ? children(renderFunctionArg) : arcs.map(function (arc$$1, i) {\n      var pathProps = renderFunctionArg.generatePathProps(arc$$1, i);\n      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n        'g',\n        { key: 'pie-arc-' + i },\n        react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('path', pathProps),\n        renderFunctionArg.generateCentroid(arc$$1)\n      );\n    })\n  );\n}\n\nLine.propTypes = {\n  innerRef: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func\n};\n\nfunction Line(_ref) {\n  var _ref$from = _ref.from,\n      from = _ref$from === undefined ? new _vx_point__WEBPACK_IMPORTED_MODULE_21__[\"Point\"]({ x: 0, y: 0 }) : _ref$from,\n      _ref$to = _ref.to,\n      to = _ref$to === undefined ? new _vx_point__WEBPACK_IMPORTED_MODULE_21__[\"Point\"]({ x: 1, y: 1 }) : _ref$to,\n      _ref$stroke = _ref.stroke,\n      stroke = _ref$stroke === undefined ? 'black' : _ref$stroke,\n      _ref$strokeWidth = _ref.strokeWidth,\n      strokeWidth = _ref$strokeWidth === undefined ? 1 : _ref$strokeWidth,\n      _ref$strokeDasharray = _ref.strokeDasharray,\n      strokeDasharray = _ref$strokeDasharray === undefined ? '' : _ref$strokeDasharray,\n      _ref$transform = _ref.transform,\n      transform = _ref$transform === undefined ? '' : _ref$transform,\n      _ref$className = _ref.className,\n      className = _ref$className === undefined ? '' : _ref$className,\n      data = _ref.data,\n      innerRef = _ref.innerRef,\n      restProps = objectWithoutProperties(_ref, ['from', 'to', 'stroke', 'strokeWidth', 'strokeDasharray', 'transform', 'className', 'data', 'innerRef']);\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('line', _extends({\n    ref: innerRef,\n    className: classnames__WEBPACK_IMPORTED_MODULE_1___default()('vx-line', className),\n    x1: from.x,\n    y1: from.y,\n    x2: to.x,\n    y2: to.y,\n    stroke: stroke,\n    strokeWidth: strokeWidth,\n    strokeDasharray: strokeDasharray,\n    transform: transform\n  }, additionalProps(restProps, data)));\n}\n\nLinePath.propTypes = {\n  innerRef: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  xScale: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  yScale: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  data: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.array,\n  x: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  y: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  defined: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  stroke: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string,\n  strokeWidth: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number,\n  glyph: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  curve: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func\n};\n\nfunction LinePath(_ref) {\n  var children = _ref.children,\n      data = _ref.data,\n      xScale = _ref.xScale,\n      yScale = _ref.yScale,\n      x = _ref.x,\n      y = _ref.y,\n      _ref$defined = _ref.defined,\n      defined = _ref$defined === undefined ? function () {\n    return true;\n  } : _ref$defined,\n      className = _ref.className,\n      _ref$stroke = _ref.stroke,\n      stroke = _ref$stroke === undefined ? 'steelblue' : _ref$stroke,\n      _ref$strokeWidth = _ref.strokeWidth,\n      strokeWidth = _ref$strokeWidth === undefined ? 2 : _ref$strokeWidth,\n      _ref$strokeDasharray = _ref.strokeDasharray,\n      strokeDasharray = _ref$strokeDasharray === undefined ? '' : _ref$strokeDasharray,\n      _ref$strokeDashoffset = _ref.strokeDashoffset,\n      strokeDashoffset = _ref$strokeDashoffset === undefined ? 0 : _ref$strokeDashoffset,\n      _ref$fill = _ref.fill,\n      fill = _ref$fill === undefined ? 'none' : _ref$fill,\n      _ref$curve = _ref.curve,\n      curve = _ref$curve === undefined ? _vx_curve__WEBPACK_IMPORTED_MODULE_22__[/* default */ \"a\"] : _ref$curve,\n      glyph = _ref.glyph,\n      innerRef = _ref.innerRef,\n      restProps = objectWithoutProperties(_ref, ['children', 'data', 'xScale', 'yScale', 'x', 'y', 'defined', 'className', 'stroke', 'strokeWidth', 'strokeDasharray', 'strokeDashoffset', 'fill', 'curve', 'glyph', 'innerRef']);\n\n  var path$$1 = Object(d3_shape__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"])().x(function () {\n    return xScale(x.apply(undefined, arguments));\n  }).y(function () {\n    return yScale(y.apply(undefined, arguments));\n  }).defined(defined).curve(curve);\n  if (children) return children({ path: path$$1 });\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n    'g',\n    null,\n    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('path', _extends({\n      ref: innerRef,\n      className: classnames__WEBPACK_IMPORTED_MODULE_1___default()('vx-linepath', className),\n      d: path$$1(data),\n      stroke: stroke,\n      strokeWidth: strokeWidth,\n      strokeDasharray: strokeDasharray,\n      strokeDashoffset: strokeDashoffset,\n      fill: fill\n    }, additionalProps(restProps, data))),\n    glyph && react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n      'g',\n      { className: 'vx-linepath-glyphs' },\n      data.map(glyph)\n    )\n  );\n}\n\nLineRadial.propTypes = {\n  innerRef: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func\n};\n\nfunction LineRadial(_ref) {\n  var _ref$className = _ref.className,\n      className = _ref$className === undefined ? '' : _ref$className,\n      angle = _ref.angle,\n      radius = _ref.radius,\n      defined = _ref.defined,\n      curve = _ref.curve,\n      data = _ref.data,\n      innerRef = _ref.innerRef,\n      restProps = objectWithoutProperties(_ref, ['className', 'angle', 'radius', 'defined', 'curve', 'data', 'innerRef']);\n\n  var path$$1 = Object(d3_shape__WEBPACK_IMPORTED_MODULE_6__[/* default */ \"a\"])();\n  if (angle) path$$1.angle(angle);\n  if (radius) path$$1.radius(radius);\n  if (defined) path$$1.defined(defined);\n  if (curve) path$$1.curve(curve);\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n    'g',\n    null,\n    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('path', _extends({\n      ref: innerRef,\n      className: classnames__WEBPACK_IMPORTED_MODULE_1___default()('vx-line-radial', className),\n      d: path$$1(data)\n    }, additionalProps(restProps, data)))\n  );\n}\n\nArea.propTypes = {\n  x: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  x0: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  x1: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  y: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  y0: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  y1: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  xScale: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  yScale: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  data: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.array,\n  defined: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  className: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.bool, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.object, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.array]),\n  innerRef: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  strokeDasharray: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string,\n  strokeWidth: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number,\n  stroke: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string,\n  fill: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string,\n  curve: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func\n};\n\nfunction Area(_ref) {\n  var children = _ref.children,\n      x = _ref.x,\n      x0 = _ref.x0,\n      x1 = _ref.x1,\n      y = _ref.y,\n      y0 = _ref.y0,\n      y1 = _ref.y1,\n      xScale = _ref.xScale,\n      yScale = _ref.yScale,\n      _ref$data = _ref.data,\n      data = _ref$data === undefined ? [] : _ref$data,\n      _ref$defined = _ref.defined,\n      defined = _ref$defined === undefined ? function () {\n    return true;\n  } : _ref$defined,\n      className = _ref.className,\n      strokeDasharray = _ref.strokeDasharray,\n      _ref$strokeWidth = _ref.strokeWidth,\n      strokeWidth = _ref$strokeWidth === undefined ? 2 : _ref$strokeWidth,\n      _ref$stroke = _ref.stroke,\n      stroke = _ref$stroke === undefined ? 'black' : _ref$stroke,\n      _ref$fill = _ref.fill,\n      fill = _ref$fill === undefined ? 'rgba(0,0,0,0.3)' : _ref$fill,\n      curve = _ref.curve,\n      innerRef = _ref.innerRef,\n      restProps = objectWithoutProperties(_ref, ['children', 'x', 'x0', 'x1', 'y', 'y0', 'y1', 'xScale', 'yScale', 'data', 'defined', 'className', 'strokeDasharray', 'strokeWidth', 'stroke', 'fill', 'curve', 'innerRef']);\n\n  var path$$1 = Object(d3_shape__WEBPACK_IMPORTED_MODULE_7__[/* default */ \"a\"])();\n  if (x) path$$1.x(function () {\n    return xScale(x.apply(undefined, arguments));\n  });\n  if (x0) path$$1.x0(function () {\n    return xScale(x0.apply(undefined, arguments));\n  });\n  if (x1) path$$1.x1(function () {\n    return xScale(x1.apply(undefined, arguments));\n  });\n  if (y) path$$1.y(function () {\n    return yScale(y.apply(undefined, arguments));\n  });\n  if (y0) path$$1.y0(function () {\n    return yScale(y0.apply(undefined, arguments));\n  });\n  if (y1) path$$1.y1(function () {\n    return yScale(y1.apply(undefined, arguments));\n  });\n  if (defined) path$$1.defined(defined);\n  if (curve) path$$1.curve(curve);\n  if (children) return children({ path: path$$1 });\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n    'g',\n    null,\n    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('path', _extends({\n      ref: innerRef,\n      className: classnames__WEBPACK_IMPORTED_MODULE_1___default()('vx-area', className),\n      d: path$$1(data),\n      stroke: stroke,\n      strokeWidth: strokeWidth,\n      strokeDasharray: strokeDasharray,\n      fill: fill\n    }, additionalProps(restProps, data)))\n  );\n}\n\nAreaClosed.propTypes = {\n  innerRef: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func\n};\n\nfunction AreaClosed(_ref) {\n  var x = _ref.x,\n      y = _ref.y,\n      y0 = _ref.y0,\n      xScale = _ref.xScale,\n      yScale = _ref.yScale,\n      data = _ref.data,\n      _ref$defined = _ref.defined,\n      defined = _ref$defined === undefined ? function () {\n    return true;\n  } : _ref$defined,\n      className = _ref.className,\n      strokeDasharray = _ref.strokeDasharray,\n      _ref$strokeWidth = _ref.strokeWidth,\n      strokeWidth = _ref$strokeWidth === undefined ? 2 : _ref$strokeWidth,\n      _ref$stroke = _ref.stroke,\n      stroke = _ref$stroke === undefined ? 'black' : _ref$stroke,\n      _ref$fill = _ref.fill,\n      fill = _ref$fill === undefined ? 'rgba(0,0,0,0.3)' : _ref$fill,\n      curve = _ref.curve,\n      innerRef = _ref.innerRef,\n      restProps = objectWithoutProperties(_ref, ['x', 'y', 'y0', 'xScale', 'yScale', 'data', 'defined', 'className', 'strokeDasharray', 'strokeWidth', 'stroke', 'fill', 'curve', 'innerRef']);\n\n  var path$$1 = Object(d3_shape__WEBPACK_IMPORTED_MODULE_7__[/* default */ \"a\"])().x(function () {\n    return xScale(x.apply(undefined, arguments));\n  }).y0(y0 || yScale.range()[0]).y1(function () {\n    return yScale(y.apply(undefined, arguments));\n  }).defined(defined);\n  if (curve) path$$1.curve(curve);\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n    'g',\n    null,\n    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('path', _extends({\n      ref: innerRef,\n      className: classnames__WEBPACK_IMPORTED_MODULE_1___default()('vx-area-closed', className),\n      d: path$$1(data),\n      stroke: stroke,\n      strokeWidth: strokeWidth,\n      strokeDasharray: strokeDasharray,\n      fill: fill\n    }, additionalProps(restProps, data)))\n  );\n}\n\nAreaStack.propTypes = {\n  className: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string,\n  top: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number,\n  left: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number,\n  keys: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.array,\n  data: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.array,\n  curve: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  defined: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.bool]),\n  x: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number]),\n  x0: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number]),\n  x1: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number]),\n  y: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number]),\n  y0: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number]),\n  y1: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number]),\n  glyph: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.bool,\n  reverse: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.bool\n};\n\nfunction AreaStack(_ref) {\n  var className = _ref.className,\n      keys = _ref.keys,\n      data = _ref.data,\n      curve = _ref.curve,\n      defined = _ref.defined,\n      x = _ref.x,\n      x0 = _ref.x0,\n      x1 = _ref.x1,\n      y0 = _ref.y0,\n      y1 = _ref.y1,\n      glyph = _ref.glyph,\n      _ref$reverse = _ref.reverse,\n      reverse = _ref$reverse === undefined ? false : _ref$reverse,\n      restProps = objectWithoutProperties(_ref, ['className', 'keys', 'data', 'curve', 'defined', 'x', 'x0', 'x1', 'y0', 'y1', 'glyph', 'reverse']);\n\n  var stack$$1 = Object(d3_shape__WEBPACK_IMPORTED_MODULE_8__[/* default */ \"a\"])();\n  if (keys) stack$$1.keys(keys);\n\n  var path$$1 = Object(d3_shape__WEBPACK_IMPORTED_MODULE_7__[/* default */ \"a\"])();\n  if (x) path$$1.x(x);\n  if (x0) path$$1.x0(x0);\n  if (x1) path$$1.x1(x1);\n  if (y0) path$$1.y0(y0);\n  if (y1) path$$1.y1(y1);\n  if (curve) path$$1.curve(curve);\n  if (defined) path$$1.defined(defined);\n\n  var seriesData = stack$$1(data);\n  if (reverse) seriesData.reverse();\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n    'g',\n    null,\n    seriesData.map(function (series, i) {\n      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('path', _extends({\n        className: classnames__WEBPACK_IMPORTED_MODULE_1___default()('vx-area-stack', className),\n        key: 'area-stack-' + i + '-' + (series.key || ''),\n        d: path$$1(series)\n      }, additionalProps(restProps, {\n        datum: series[i],\n        index: i,\n        series: series\n      })));\n    }),\n    !!glyph && react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n      'g',\n      { className: 'vx-area-stack-glyphs' },\n      data.map(glyph)\n    )\n  );\n}\n\nBar.propTypes = {\n  innerRef: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func\n};\n\nfunction Bar(_ref) {\n  var className = _ref.className,\n      innerRef = _ref.innerRef,\n      data = _ref.data,\n      _ref$x = _ref.x,\n      x = _ref$x === undefined ? 0 : _ref$x,\n      _ref$y = _ref.y,\n      y = _ref$y === undefined ? 0 : _ref$y,\n      width = _ref.width,\n      height = _ref.height,\n      rx = _ref.rx,\n      ry = _ref.ry,\n      _ref$fill = _ref.fill,\n      fill = _ref$fill === undefined ? 'steelblue' : _ref$fill,\n      fillOpacity = _ref.fillOpacity,\n      stroke = _ref.stroke,\n      strokeWidth = _ref.strokeWidth,\n      strokeDasharray = _ref.strokeDasharray,\n      strokeLinecap = _ref.strokeLinecap,\n      strokeLinejoin = _ref.strokeLinejoin,\n      strokeMiterlimit = _ref.strokeMiterlimit,\n      strokeOpacity = _ref.strokeOpacity,\n      restProps = objectWithoutProperties(_ref, ['className', 'innerRef', 'data', 'x', 'y', 'width', 'height', 'rx', 'ry', 'fill', 'fillOpacity', 'stroke', 'strokeWidth', 'strokeDasharray', 'strokeLinecap', 'strokeLinejoin', 'strokeMiterlimit', 'strokeOpacity']);\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('rect', _extends({\n    ref: innerRef,\n    className: classnames__WEBPACK_IMPORTED_MODULE_1___default()('vx-bar', className),\n    x: x,\n    y: y,\n    width: width,\n    height: height,\n    rx: rx,\n    ry: ry,\n    fill: fill,\n    fillOpacity: fillOpacity,\n    stroke: stroke,\n    strokeWidth: strokeWidth,\n    strokeDasharray: strokeDasharray,\n    strokeLinecap: strokeLinecap,\n    strokeLinejoin: strokeLinejoin,\n    strokeMiterlimit: strokeMiterlimit,\n    strokeOpacity: strokeOpacity\n  }, additionalProps(restProps, data)));\n}\n\nBarGroup.propTypes = {\n  data: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.array.isRequired,\n  x0: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func.isRequired,\n  x0Scale: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func.isRequired,\n  x1Scale: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func.isRequired,\n  yScale: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func.isRequired,\n  zScale: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func.isRequired,\n  keys: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.array.isRequired,\n  height: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number.isRequired,\n  className: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string,\n  top: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number,\n  left: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number\n};\n\nfunction BarGroup(_ref) {\n  var data = _ref.data,\n      className = _ref.className,\n      top = _ref.top,\n      left = _ref.left,\n      x0 = _ref.x0,\n      x0Scale = _ref.x0Scale,\n      x1Scale = _ref.x1Scale,\n      yScale = _ref.yScale,\n      zScale = _ref.zScale,\n      keys = _ref.keys,\n      height = _ref.height,\n      restProps = objectWithoutProperties(_ref, ['data', 'className', 'top', 'left', 'x0', 'x0Scale', 'x1Scale', 'yScale', 'zScale', 'keys', 'height']);\n\n  var format = x0Scale.tickFormat ? x0Scale.tickFormat() : function (d) {\n    return d;\n  };\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n    _vx_group__WEBPACK_IMPORTED_MODULE_20__[/* Group */ \"a\"],\n    { className: classnames__WEBPACK_IMPORTED_MODULE_1___default()('vx-bar-group', className), top: top, left: left },\n    data && data.map(function (d, i) {\n      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n        _vx_group__WEBPACK_IMPORTED_MODULE_20__[/* Group */ \"a\"],\n        { key: 'bar-group-' + i + '-' + x0(d), left: x0Scale(x0(d)) },\n        keys && keys.map(function (key, j) {\n          var value = d[key];\n          return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Bar, _extends({\n            key: 'bar-group-bar-' + i + '-' + j + '-' + value + '-' + key,\n            x: x1Scale(key),\n            y: yScale(value),\n            width: x1Scale.bandwidth(),\n            height: height - yScale(value),\n            fill: zScale(key),\n            data: {\n              key: key,\n              value: value,\n              x: format(x0(d)),\n              data: d\n            }\n          }, restProps));\n        })\n      );\n    })\n  );\n}\n\nBarGroupHorizontal.propTypes = {\n  data: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.array.isRequired,\n  y0: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func.isRequired,\n  y0Scale: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func.isRequired,\n  y1Scale: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func.isRequired,\n  xScale: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func.isRequired,\n  zScale: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func.isRequired,\n  keys: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.array.isRequired,\n  width: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number.isRequired,\n  className: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string,\n  top: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number,\n  left: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number\n};\n\nfunction BarGroupHorizontal(_ref) {\n  var data = _ref.data,\n      className = _ref.className,\n      top = _ref.top,\n      left = _ref.left,\n      y0 = _ref.y0,\n      y0Scale = _ref.y0Scale,\n      y1Scale = _ref.y1Scale,\n      xScale = _ref.xScale,\n      zScale = _ref.zScale,\n      keys = _ref.keys,\n      width = _ref.width,\n      restProps = objectWithoutProperties(_ref, ['data', 'className', 'top', 'left', 'y0', 'y0Scale', 'y1Scale', 'xScale', 'zScale', 'keys', 'width']);\n\n  var format = y0Scale.tickFormat ? y0Scale.tickFormat() : function (d) {\n    return d;\n  };\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n    _vx_group__WEBPACK_IMPORTED_MODULE_20__[/* Group */ \"a\"],\n    { className: classnames__WEBPACK_IMPORTED_MODULE_1___default()('vx-bar-group-horizontal', className), top: top, left: left },\n    data && data.map(function (d, i) {\n      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n        _vx_group__WEBPACK_IMPORTED_MODULE_20__[/* Group */ \"a\"],\n        { key: 'bar-group-' + i + '-' + y0(d), top: y0Scale(y0(d)) },\n        keys && keys.map(function (key, j) {\n          var value = d[key];\n          return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Bar, _extends({\n            key: 'bar-group-bar-' + i + '-' + j + '-' + value + '-' + key,\n            x: 0,\n            y: y1Scale(key),\n            width: width - xScale(value),\n            height: y1Scale.bandwidth(),\n            fill: zScale(key),\n            data: {\n              key: key,\n              value: value,\n              y: format(y0(d)),\n              data: d\n            }\n          }, restProps));\n        })\n      );\n    })\n  );\n}\n\nfunction objHasMethod(obj, funcName) {\n  return !!obj[funcName] && typeof obj[funcName] === 'function';\n}\n\nBarStack.propTypes = {\n  data: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.array.isRequired,\n  x: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func.isRequired,\n  xScale: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func.isRequired,\n  yScale: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func.isRequired,\n  zScale: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func.isRequired,\n  keys: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.array.isRequired,\n  className: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string,\n  top: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number,\n  left: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number,\n  width: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number,\n  height: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number\n};\n\nfunction BarStack(_ref) {\n  var data = _ref.data,\n      className = _ref.className,\n      top = _ref.top,\n      left = _ref.left,\n      x = _ref.x,\n      xScale = _ref.xScale,\n      yScale = _ref.yScale,\n      zScale = _ref.zScale,\n      keys = _ref.keys,\n      width = _ref.width,\n      height = _ref.height,\n      restProps = objectWithoutProperties(_ref, ['data', 'className', 'top', 'left', 'x', 'xScale', 'yScale', 'zScale', 'keys', 'width', 'height']);\n\n  var series = Object(d3_shape__WEBPACK_IMPORTED_MODULE_8__[/* default */ \"a\"])().keys(keys)(data);\n  var format = xScale.tickFormat ? xScale.tickFormat() : function (d) {\n    return d;\n  };\n  var xRange = xScale.range();\n  var xDomain = xScale.domain();\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n    _vx_group__WEBPACK_IMPORTED_MODULE_20__[/* Group */ \"a\"],\n    { className: classnames__WEBPACK_IMPORTED_MODULE_1___default()('vx-bar-stack', className), top: top, left: left },\n    series && series.map(function (s, i) {\n      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n        _vx_group__WEBPACK_IMPORTED_MODULE_20__[/* Group */ \"a\"],\n        { key: 'vx-bar-stack-' + i },\n        s.map(function (d, ii) {\n          var barHeight = yScale(d[0]) - yScale(d[1]);\n          var barWidth = width || (objHasMethod(xScale, 'bandwidth') ? xScale.bandwidth() : Math.abs(xRange[xRange.length - 1] - xRange[0]) / xDomain.length);\n\n          var barX = objHasMethod(xScale, 'bandwidth') ? xScale(x(d.data)) : xScale(x(d.data)) - barWidth / 2;\n          return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Bar, _extends({\n            key: 'bar-group-bar-' + i + '-' + ii + '-' + s.key,\n            x: barX,\n            y: yScale(d[1]),\n            width: barWidth,\n            height: barHeight,\n            fill: zScale(s.key),\n            data: {\n              paddingInner: objHasMethod(xScale, 'paddingInner') && xScale.paddingInner(),\n              paddingOuter: objHasMethod(xScale, 'paddingOuter') && xScale.paddingOuter(),\n              step: objHasMethod(xScale, 'step') && xScale.step(),\n              key: s.key,\n              value: d[1],\n              height: barHeight,\n              width: barWidth,\n              x: x(d.data),\n              xFormatted: format(x(d.data)),\n              data: d.data\n            }\n          }, restProps));\n        })\n      );\n    })\n  );\n}\n\nBarStackHorizontal.propTypes = {\n  data: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.array.isRequired,\n  y: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func.isRequired,\n  xScale: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func.isRequired,\n  yScale: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func.isRequired,\n  zScale: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func.isRequired,\n  keys: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.array.isRequired,\n  className: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string,\n  top: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number,\n  left: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number,\n  width: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number,\n  height: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number\n};\n\nfunction BarStackHorizontal(_ref) {\n  var data = _ref.data,\n      className = _ref.className,\n      top = _ref.top,\n      left = _ref.left,\n      y = _ref.y,\n      xScale = _ref.xScale,\n      yScale = _ref.yScale,\n      zScale = _ref.zScale,\n      keys = _ref.keys,\n      width = _ref.width,\n      height = _ref.height,\n      restProps = objectWithoutProperties(_ref, ['data', 'className', 'top', 'left', 'y', 'xScale', 'yScale', 'zScale', 'keys', 'width', 'height']);\n\n  var series = Object(d3_shape__WEBPACK_IMPORTED_MODULE_8__[/* default */ \"a\"])().keys(keys)(data);\n  var format = yScale.tickFormat ? yScale.tickFormat() : function (d) {\n    return d;\n  };\n  var yRange = yScale.range();\n  var yDomain = yScale.domain();\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n    _vx_group__WEBPACK_IMPORTED_MODULE_20__[/* Group */ \"a\"],\n    { className: classnames__WEBPACK_IMPORTED_MODULE_1___default()('vx-bar-stack-horizontal', className), top: top, left: left },\n    series && series.map(function (s, i) {\n      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n        _vx_group__WEBPACK_IMPORTED_MODULE_20__[/* Group */ \"a\"],\n        { key: 'vx-bar-stack-horizontal-' + i },\n        s.map(function (d, ii) {\n          var barWidth = xScale(d[1]) - xScale(d[0]);\n          var barHeight = width || (objHasMethod(yScale, 'bandwidth') ? yScale.bandwidth() : Math.abs(yRange[yRange.length - 1] - yRange[0]) / yDomain.length);\n\n          var barY = objHasMethod(yScale, 'bandwidth') ? yScale(y(d.data)) : yScale(y(d.data)) - barHeight / 2;\n          return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Bar, _extends({\n            key: 'bar-group-bar-' + i + '-' + ii + '-' + s.key,\n            x: xScale(d[0]),\n            y: barY,\n            width: barWidth,\n            height: barHeight,\n            fill: zScale(s.key),\n            data: {\n              paddingInner: objHasMethod(yScale, 'paddingInner') && yScale.paddingInner(),\n              paddingOuter: objHasMethod(yScale, 'paddingOuter') && yScale.paddingOuter(),\n              step: objHasMethod(yScale, 'step') && yScale.step(),\n              key: s.key,\n              value: d[0],\n              height: barHeight,\n              width: barWidth,\n              y: y(d.data),\n              yFormatted: format(y(d.data)),\n              data: d.data\n            }\n          }, restProps));\n        })\n      );\n    })\n  );\n}\n\nvar STACK_ORDERS = {\n  ascending: d3_shape__WEBPACK_IMPORTED_MODULE_9__[/* default */ \"a\"],\n  descending: d3_shape__WEBPACK_IMPORTED_MODULE_10__[/* default */ \"a\"],\n  insideout: d3_shape__WEBPACK_IMPORTED_MODULE_11__[/* default */ \"a\"],\n  none: d3_shape__WEBPACK_IMPORTED_MODULE_12__[/* default */ \"a\"],\n  reverse: d3_shape__WEBPACK_IMPORTED_MODULE_13__[/* default */ \"a\"]\n};\n\nvar STACK_ORDER_NAMES = Object.keys(STACK_ORDERS);\n\nfunction stackOrder(order) {\n  return STACK_ORDERS[order] || STACK_ORDERS.none;\n}\n\nvar STACK_OFFSETS = {\n  expand: d3_shape__WEBPACK_IMPORTED_MODULE_14__[/* default */ \"a\"],\n  diverging: d3_shape__WEBPACK_IMPORTED_MODULE_15__[/* default */ \"a\"],\n  none: d3_shape__WEBPACK_IMPORTED_MODULE_16__[/* default */ \"a\"],\n  silhouette: d3_shape__WEBPACK_IMPORTED_MODULE_17__[/* default */ \"a\"],\n  wiggle: d3_shape__WEBPACK_IMPORTED_MODULE_18__[/* default */ \"a\"]\n};\n\nvar STACK_OFFSET_NAMES = Object.keys(STACK_OFFSETS);\n\nfunction stackOffset(offset) {\n  return STACK_OFFSETS[offset] || STACK_OFFSETS.none;\n}\n\nStack.propTypes = {\n  className: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string,\n  top: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number,\n  left: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number,\n  keys: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.array,\n  data: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.array,\n  curve: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  defined: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.bool]),\n  x: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number]),\n  x0: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number]),\n  x1: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number]),\n  y: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number]),\n  y0: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number]),\n  y1: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number]),\n  value: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number]),\n  order: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.array, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string]),\n  offset: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.array, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string]),\n  render: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  reverse: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.bool\n};\n\nfunction Stack(_ref) {\n  var className = _ref.className,\n      _ref$top = _ref.top,\n      top = _ref$top === undefined ? 0 : _ref$top,\n      _ref$left = _ref.left,\n      left = _ref$left === undefined ? 0 : _ref$left,\n      keys = _ref.keys,\n      data = _ref.data,\n      curve = _ref.curve,\n      defined = _ref.defined,\n      x = _ref.x,\n      x0 = _ref.x0,\n      x1 = _ref.x1,\n      y0 = _ref.y0,\n      y1 = _ref.y1,\n      value = _ref.value,\n      order = _ref.order,\n      offset = _ref.offset,\n      render = _ref.render,\n      _ref$reverse = _ref.reverse,\n      reverse = _ref$reverse === undefined ? false : _ref$reverse,\n      restProps = objectWithoutProperties(_ref, ['className', 'top', 'left', 'keys', 'data', 'curve', 'defined', 'x', 'x0', 'x1', 'y0', 'y1', 'value', 'order', 'offset', 'render', 'reverse']);\n\n  var stack$$1 = Object(d3_shape__WEBPACK_IMPORTED_MODULE_8__[/* default */ \"a\"])();\n  if (keys) stack$$1.keys(keys);\n  if (value) stack$$1.value(value);\n  if (order) stack$$1.order(stackOrder(order));\n  if (offset) stack$$1.offset(stackOffset(offset));\n\n  var path$$1 = Object(d3_shape__WEBPACK_IMPORTED_MODULE_7__[/* default */ \"a\"])();\n  if (x) path$$1.x(x);\n  if (x0) path$$1.x0(x0);\n  if (x1) path$$1.x1(x1);\n  if (y0) path$$1.y0(y0);\n  if (y1) path$$1.y1(y1);\n  if (curve) path$$1.curve(curve);\n  if (defined) path$$1.defined(defined);\n\n  var seriesData = stack$$1(data);\n  if (reverse) seriesData.reverse();\n\n  if (render) {\n    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n      _vx_group__WEBPACK_IMPORTED_MODULE_20__[/* Group */ \"a\"],\n      { top: top, left: left },\n      render({ seriesData: seriesData, path: path$$1 })\n    );\n  }\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n    _vx_group__WEBPACK_IMPORTED_MODULE_20__[/* Group */ \"a\"],\n    { top: top, left: left },\n    seriesData.map(function (series, i) {\n      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('path', _extends({\n        className: classnames__WEBPACK_IMPORTED_MODULE_1___default()('vx-stack', className),\n        key: 'stack-' + i + '-' + (series.key || ''),\n        d: path$$1(series)\n      }, additionalProps(restProps, {\n        datum: series[i],\n        index: i,\n        series: series\n      })));\n    })\n  );\n}\n\nvar degreesToRadians = function degreesToRadians(degrees) {\n  return Math.PI / 180 * degrees;\n};\n\nfunction pathHorizontalDiagonal(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y;\n\n  return function (data) {\n    var link = Object(d3_shape__WEBPACK_IMPORTED_MODULE_19__[/* linkHorizontal */ \"a\"])();\n    link.x(x);\n    link.y(y);\n    link.source(source);\n    link.target(target);\n    return link(data);\n  };\n}\n\nLinkHorizontal.propTypes = {\n  innerRef: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  x: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  y: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  source: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  target: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  path: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func\n};\n\nfunction LinkHorizontal(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.y;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.x;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || pathHorizontalDiagonal({ source: source, target: target, x: x, y: y });\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('path', _extends({\n    ref: innerRef,\n    className: classnames__WEBPACK_IMPORTED_MODULE_1___default()('vx-link-horizontal', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathVerticalDiagonal(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y;\n\n  return function (data) {\n    var link = Object(d3_shape__WEBPACK_IMPORTED_MODULE_19__[/* linkVertical */ \"c\"])();\n    link.x(x);\n    link.y(y);\n    link.source(source);\n    link.target(target);\n    return link(data);\n  };\n}\n\nLinkVertical.propTypes = {\n  innerRef: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  x: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  y: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  source: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  target: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  path: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func\n};\n\nfunction LinkVertical(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.x;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.y;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || pathVerticalDiagonal({ source: source, target: target, x: x, y: y });\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('path', _extends({\n    ref: innerRef,\n    className: classnames__WEBPACK_IMPORTED_MODULE_1___default()('vx-link-vertical', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathRadialDiagonal(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      angle = _ref.angle,\n      radius = _ref.radius;\n\n  return function (data) {\n    var link = Object(d3_shape__WEBPACK_IMPORTED_MODULE_19__[/* linkRadial */ \"b\"])();\n    link.angle(angle);\n    link.radius(radius);\n    link.source(source);\n    link.target(target);\n    return link(data);\n  };\n}\n\nLinkRadial.propTypes = {\n  innerRef: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  angle: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  radius: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  source: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  target: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  path: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func\n};\n\nfunction LinkRadial(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$angle = _ref2.angle,\n      angle = _ref2$angle === undefined ? function (d) {\n    return d.x;\n  } : _ref2$angle,\n      _ref2$radius = _ref2.radius,\n      radius = _ref2$radius === undefined ? function (d) {\n    return d.y;\n  } : _ref2$radius,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'angle', 'radius', 'source', 'target']);\n\n  path$$1 = path$$1 || pathRadialDiagonal({ source: source, target: target, angle: angle, radius: radius });\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('path', _extends({\n    ref: innerRef,\n    className: classnames__WEBPACK_IMPORTED_MODULE_1___default()('vx-link-radius', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathHorizontalCurve(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y,\n      percent = _ref.percent;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sx = x(sourceData);\n    var sy = y(sourceData);\n    var tx = x(targetData);\n    var ty = y(targetData);\n\n    var dx = tx - sx;\n    var dy = ty - sy;\n    var ix = percent * (dx + dy);\n    var iy = percent * (dy - dx);\n\n    var path$$1 = Object(d3_path__WEBPACK_IMPORTED_MODULE_23__[/* default */ \"a\"])();\n    path$$1.moveTo(sx, sy);\n    path$$1.bezierCurveTo(sx + ix, sy + iy, tx + iy, ty - ix, tx, ty);\n\n    return path$$1.toString();\n  };\n}\n\nLinkHorizontalCurve.propTypes = {\n  innerRef: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  percent: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number,\n  x: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  y: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  source: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  target: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  path: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func\n};\n\nfunction LinkHorizontalCurve(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.y;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.x;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      _ref2$percent = _ref2.percent,\n      percent = _ref2$percent === undefined ? 0.2 : _ref2$percent,\n      restProps = objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target', 'percent']);\n\n  path$$1 = path$$1 || pathHorizontalCurve({ source: source, target: target, x: x, y: y, percent: percent });\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('path', _extends({\n    ref: innerRef,\n    className: classnames__WEBPACK_IMPORTED_MODULE_1___default()('vx-link', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathVerticalCurve(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y,\n      percent = _ref.percent;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sx = x(sourceData);\n    var sy = y(sourceData);\n    var tx = x(targetData);\n    var ty = y(targetData);\n\n    var dx = tx - sx;\n    var dy = ty - sy;\n    var ix = percent * (dx + dy);\n    var iy = percent * (dy - dx);\n\n    var path$$1 = Object(d3_path__WEBPACK_IMPORTED_MODULE_23__[/* default */ \"a\"])();\n    path$$1.moveTo(sx, sy);\n    path$$1.bezierCurveTo(sx + ix, sy + iy, tx + iy, ty - ix, tx, ty);\n\n    return path$$1.toString();\n  };\n}\n\nLinkVerticalCurve.propTypes = {\n  innerRef: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  percent: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number,\n  x: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  y: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  source: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  target: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  path: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func\n};\n\nfunction LinkVerticalCurve(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.x;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.y;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      _ref2$percent = _ref2.percent,\n      percent = _ref2$percent === undefined ? 0.2 : _ref2$percent,\n      restProps = objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target', 'percent']);\n\n  path$$1 = path$$1 || pathVerticalCurve({ source: source, target: target, x: x, y: y, percent: percent });\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('path', _extends({\n    ref: innerRef,\n    className: classnames__WEBPACK_IMPORTED_MODULE_1___default()('vx-link', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathRadialCurve(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y,\n      percent = _ref.percent;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sa = x(sourceData) - Math.PI / 2;\n    var sr = y(sourceData);\n    var ta = x(targetData) - Math.PI / 2;\n    var tr = y(targetData);\n\n    var sc = Math.cos(sa);\n    var ss = Math.sin(sa);\n    var tc = Math.cos(ta);\n    var ts = Math.sin(ta);\n\n    var sx = sr * sc;\n    var sy = sr * ss;\n    var tx = tr * tc;\n    var ty = tr * ts;\n\n    var dx = tx - sx;\n    var dy = ty - sy;\n    var ix = percent * (dx + dy);\n    var iy = percent * (dy - dx);\n\n    var path$$1 = Object(d3_path__WEBPACK_IMPORTED_MODULE_23__[/* default */ \"a\"])();\n    path$$1.moveTo(sx, sy);\n    path$$1.bezierCurveTo(sx + ix, sy + iy, tx + iy, ty - ix, tx, ty);\n\n    return path$$1.toString();\n  };\n}\n\nLinkRadialCurve.propTypes = {\n  innerRef: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  percent: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number,\n  x: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  y: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  source: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  target: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  path: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func\n};\n\nfunction LinkRadialCurve(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.x;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.y;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      _ref2$percent = _ref2.percent,\n      percent = _ref2$percent === undefined ? 0.2 : _ref2$percent,\n      restProps = objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target', 'percent']);\n\n  path$$1 = path$$1 || pathRadialCurve({ source: source, target: target, x: x, y: y, percent: percent });\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('path', _extends({\n    ref: innerRef,\n    className: classnames__WEBPACK_IMPORTED_MODULE_1___default()('vx-link', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathHorizontalLine(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sx = x(sourceData);\n    var sy = y(sourceData);\n    var tx = x(targetData);\n    var ty = y(targetData);\n\n    var path$$1 = Object(d3_path__WEBPACK_IMPORTED_MODULE_23__[/* default */ \"a\"])();\n    path$$1.moveTo(sx, sy);\n    path$$1.lineTo(tx, ty);\n\n    return path$$1.toString();\n  };\n}\n\nLinkHorizontalLine.propTypes = {\n  innerRef: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  path: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  x: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  y: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  source: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  target: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func\n};\n\nfunction LinkHorizontalLine(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.y;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.x;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || pathHorizontalLine({ source: source, target: target, x: x, y: y });\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('path', _extends({\n    ref: innerRef,\n    className: classnames__WEBPACK_IMPORTED_MODULE_1___default()('vx-link', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathVerticalLine(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sx = x(sourceData);\n    var sy = y(sourceData);\n    var tx = x(targetData);\n    var ty = y(targetData);\n\n    var path$$1 = Object(d3_path__WEBPACK_IMPORTED_MODULE_23__[/* default */ \"a\"])();\n    path$$1.moveTo(sx, sy);\n    path$$1.lineTo(tx, ty);\n\n    return path$$1.toString();\n  };\n}\n\nLinkVerticalLine.propTypes = {\n  innerRef: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  path: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  x: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  y: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  source: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  target: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func\n};\n\nfunction LinkVerticalLine(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.x;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.y;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || pathVerticalLine({ source: source, target: target, x: x, y: y });\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('path', _extends({\n    ref: innerRef,\n    className: classnames__WEBPACK_IMPORTED_MODULE_1___default()('vx-link', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathRadialLine(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sa = x(sourceData) - Math.PI / 2;\n    var sr = y(sourceData);\n    var ta = x(targetData) - Math.PI / 2;\n    var tr = y(targetData);\n\n    var sc = Math.cos(sa);\n    var ss = Math.sin(sa);\n    var tc = Math.cos(ta);\n    var ts = Math.sin(ta);\n\n    var path$$1 = Object(d3_path__WEBPACK_IMPORTED_MODULE_23__[/* default */ \"a\"])();\n    path$$1.moveTo(sr * sc, sr * ss);\n    path$$1.lineTo(tr * tc, tr * ts);\n\n    return path$$1.toString();\n  };\n}\n\nLinkRadialStep.propTypes = {\n  innerRef: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  path: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  x: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  y: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  source: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  target: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func\n};\n\nfunction LinkRadialStep(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.x;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.y;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || pathRadialLine({ source: source, target: target, x: x, y: y });\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('path', _extends({\n    ref: innerRef,\n    className: classnames__WEBPACK_IMPORTED_MODULE_1___default()('vx-link', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathHorizontalStep(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y,\n      percent = _ref.percent;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sx = x(sourceData);\n    var sy = y(sourceData);\n    var tx = x(targetData);\n    var ty = y(targetData);\n\n    var path$$1 = Object(d3_path__WEBPACK_IMPORTED_MODULE_23__[/* default */ \"a\"])();\n    path$$1.moveTo(sx, sy);\n    path$$1.lineTo(sx + (tx - sx) * percent, sy);\n    path$$1.lineTo(sx + (tx - sx) * percent, ty);\n    path$$1.lineTo(tx, ty);\n\n    return path$$1.toString();\n  };\n}\n\nLinkHorizontalStep.propTypes = {\n  innerRef: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  percent: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number,\n  x: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  y: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  source: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  target: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  path: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func\n};\n\nfunction LinkHorizontalStep(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$percent = _ref2.percent,\n      percent = _ref2$percent === undefined ? 0.5 : _ref2$percent,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.y;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.x;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'percent', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || pathHorizontalStep({ source: source, target: target, x: x, y: y, percent: percent });\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('path', _extends({\n    ref: innerRef,\n    className: classnames__WEBPACK_IMPORTED_MODULE_1___default()('vx-link', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathVerticalStep(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y,\n      percent = _ref.percent;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sx = x(sourceData);\n    var sy = y(sourceData);\n    var tx = x(targetData);\n    var ty = y(targetData);\n\n    var path$$1 = Object(d3_path__WEBPACK_IMPORTED_MODULE_23__[/* default */ \"a\"])();\n    path$$1.moveTo(sx, sy);\n    path$$1.lineTo(sx, sy + (ty - sy) * percent);\n    path$$1.lineTo(tx, sy + (ty - sy) * percent);\n    path$$1.lineTo(tx, ty);\n\n    return path$$1.toString();\n  };\n}\n\nLinkVerticalStep.propTypes = {\n  innerRef: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  percent: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number,\n  x: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  y: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  source: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  target: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  path: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func\n};\n\nfunction LinkVerticalStep(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$percent = _ref2.percent,\n      percent = _ref2$percent === undefined ? 0.5 : _ref2$percent,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.x;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.y;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'percent', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || pathVerticalStep({ source: source, target: target, x: x, y: y, percent: percent });\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('path', _extends({\n    ref: innerRef,\n    className: classnames__WEBPACK_IMPORTED_MODULE_1___default()('vx-link', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nfunction pathRadialStep(_ref) {\n  var source = _ref.source,\n      target = _ref.target,\n      x = _ref.x,\n      y = _ref.y;\n\n  return function (data) {\n    var sourceData = source(data);\n    var targetData = target(data);\n\n    var sx = x(sourceData);\n    var sy = y(sourceData);\n    var tx = x(targetData);\n    var ty = y(targetData);\n\n    var sa = sx - Math.PI / 2;\n    var sr = sy;\n    var ta = tx - Math.PI / 2;\n    var tr = ty;\n\n    var sc = Math.cos(sa);\n    var ss = Math.sin(sa);\n    var tc = Math.cos(ta);\n    var ts = Math.sin(ta);\n    var sf = Math.abs(ta - sa) > Math.PI ? ta <= sa : ta > sa;\n\n    return '\\n      M' + sr * sc + ',' + sr * ss + '\\n      A' + sr + ',' + sr + ',0,0,' + (sf ? 1 : 0) + ',' + sr * tc + ',' + sr * ts + '\\n      L' + tr * tc + ',' + tr * ts + '\\n    ';\n  };\n}\n\nLinkRadialStep$1.propTypes = {\n  innerRef: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  x: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  y: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  source: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  target: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,\n  path: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func\n};\n\nfunction LinkRadialStep$1(_ref2) {\n  var className = _ref2.className,\n      innerRef = _ref2.innerRef,\n      data = _ref2.data,\n      path$$1 = _ref2.path,\n      _ref2$x = _ref2.x,\n      x = _ref2$x === undefined ? function (d) {\n    return d.x;\n  } : _ref2$x,\n      _ref2$y = _ref2.y,\n      y = _ref2$y === undefined ? function (d) {\n    return d.y;\n  } : _ref2$y,\n      _ref2$source = _ref2.source,\n      source = _ref2$source === undefined ? function (d) {\n    return d.source;\n  } : _ref2$source,\n      _ref2$target = _ref2.target,\n      target = _ref2$target === undefined ? function (d) {\n    return d.target;\n  } : _ref2$target,\n      restProps = objectWithoutProperties(_ref2, ['className', 'innerRef', 'data', 'path', 'x', 'y', 'source', 'target']);\n\n  path$$1 = path$$1 || pathRadialStep({ source: source, target: target, x: x, y: y });\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('path', _extends({\n    ref: innerRef,\n    className: classnames__WEBPACK_IMPORTED_MODULE_1___default()('vx-link', className),\n    d: path$$1(data)\n  }, additionalProps(restProps, data)));\n}\n\nPolygon.propTypes = {\n  sides: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number.isRequired,\n  size: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number.isRequired,\n  className: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string,\n  rotate: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number\n};\n\nvar getPoint = function getPoint(_ref) {\n  var sides = _ref.sides,\n      size = _ref.size,\n      center = _ref.center,\n      rotate = _ref.rotate,\n      side = _ref.side;\n\n  var degrees = 360 / sides * side - rotate;\n  var radians = degreesToRadians(degrees);\n\n  return new _vx_point__WEBPACK_IMPORTED_MODULE_21__[\"Point\"]({\n    x: center.x + size * Math.cos(radians),\n    y: center.y + size * Math.sin(radians)\n  });\n};\n\nvar getPoints = function getPoints(_ref2) {\n  var sides = _ref2.sides,\n      size = _ref2.size,\n      center = _ref2.center,\n      rotate = _ref2.rotate;\n\n  return [].concat(toConsumableArray(Array(sides).keys())).map(function (side) {\n    return getPoint({\n      sides: sides,\n      size: size,\n      center: center,\n      rotate: rotate,\n      side: side\n    });\n  });\n};\n\nfunction Polygon(_ref3) {\n  var sides = _ref3.sides,\n      _ref3$size = _ref3.size,\n      size = _ref3$size === undefined ? 25 : _ref3$size,\n      _ref3$center = _ref3.center,\n      center = _ref3$center === undefined ? new _vx_point__WEBPACK_IMPORTED_MODULE_21__[\"Point\"]({ x: 0, y: 0 }) : _ref3$center,\n      _ref3$rotate = _ref3.rotate,\n      rotate = _ref3$rotate === undefined ? 0 : _ref3$rotate,\n      className = _ref3.className,\n      restProps = objectWithoutProperties(_ref3, ['sides', 'size', 'center', 'rotate', 'className']);\n\n  var points = getPoints({\n    sides: sides,\n    size: size,\n    center: center,\n    rotate: rotate\n  }).map(function (p) {\n    return p.toArray();\n  }).join(' ');\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement('polygon', _extends({ points: points, className: classnames__WEBPACK_IMPORTED_MODULE_1___default()('vx-polygon', className) }, restProps));\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM5NC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL2hpc3RvZ3JhbS9ub2RlX21vZHVsZXMvQHZ4L3NoYXBlL2Rpc3Qvdngtc2hhcGUuZXMuanM/YjIyZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IGN4IGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IGFyYywgcGllLCBsaW5lLCByYWRpYWxMaW5lLCBhcmVhLCBzdGFjaywgc3RhY2tPcmRlckFzY2VuZGluZywgc3RhY2tPcmRlckRlc2NlbmRpbmcsIHN0YWNrT3JkZXJJbnNpZGVPdXQsIHN0YWNrT3JkZXJOb25lLCBzdGFja09yZGVyUmV2ZXJzZSwgc3RhY2tPZmZzZXRFeHBhbmQsIHN0YWNrT2Zmc2V0RGl2ZXJnaW5nLCBzdGFja09mZnNldE5vbmUsIHN0YWNrT2Zmc2V0U2lsaG91ZXR0ZSwgc3RhY2tPZmZzZXRXaWdnbGUsIGxpbmtIb3Jpem9udGFsLCBsaW5rVmVydGljYWwsIGxpbmtSYWRpYWwgfSBmcm9tICdkMy1zaGFwZSc7XG5pbXBvcnQgeyBHcm91cCB9IGZyb20gJ0B2eC9ncm91cCc7XG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJ0B2eC9wb2ludCc7XG5pbXBvcnQgeyBjdXJ2ZUxpbmVhciB9IGZyb20gJ0B2eC9jdXJ2ZSc7XG5pbXBvcnQgeyBwYXRoIH0gZnJvbSAnZDMtcGF0aCc7XG5cbmZ1bmN0aW9uIGNhbGxPclZhbHVlKG1heWJlRm4sIGRhdGEpIHtcbiAgaWYgKHR5cGVvZiBtYXliZUZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlRm4oZGF0YSk7XG4gIH1cbiAgcmV0dXJuIG1heWJlRm47XG59XG5cbmZ1bmN0aW9uIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHJlc3RQcm9wcykucmVkdWNlKGZ1bmN0aW9uIChyZXQsIGN1cikge1xuICAgIHJldFtjdXJdID0gY2FsbE9yVmFsdWUocmVzdFByb3BzW2N1cl0sIGRhdGEpO1xuICAgIHJldHVybiByZXQ7XG4gIH0sIHt9KTtcbn1cblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbnZhciBvYmplY3RXaXRob3V0UHJvcGVydGllcyA9IGZ1bmN0aW9uIChvYmosIGtleXMpIHtcbiAgdmFyIHRhcmdldCA9IHt9O1xuXG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTtcbiAgICB0YXJnZXRbaV0gPSBvYmpbaV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxudmFyIHRvQ29uc3VtYWJsZUFycmF5ID0gZnVuY3Rpb24gKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICAgIHJldHVybiBhcnIyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGFycik7XG4gIH1cbn07XG5cbkFyYy5wcm9wVHlwZXMgPSB7XG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgZGF0YTogUHJvcFR5cGVzLmFueSxcbiAgY2VudHJvaWQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gIGlubmVyUmFkaXVzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm51bWJlcl0pLFxuICBvdXRlclJhZGl1czogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgY29ybmVyUmFkaXVzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm51bWJlcl0pLFxuICBzdGFydEFuZ2xlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm51bWJlcl0pLFxuICBlbmRBbmdsZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgcGFkQW5nbGU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gIHBhZFJhZGl1czogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5udW1iZXJdKVxufTtcblxuZnVuY3Rpb24gQXJjKF9yZWYpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgIGNlbnRyb2lkID0gX3JlZi5jZW50cm9pZCxcbiAgICAgIGlubmVyUmFkaXVzID0gX3JlZi5pbm5lclJhZGl1cyxcbiAgICAgIG91dGVyUmFkaXVzID0gX3JlZi5vdXRlclJhZGl1cyxcbiAgICAgIGNvcm5lclJhZGl1cyA9IF9yZWYuY29ybmVyUmFkaXVzLFxuICAgICAgc3RhcnRBbmdsZSA9IF9yZWYuc3RhcnRBbmdsZSxcbiAgICAgIGVuZEFuZ2xlID0gX3JlZi5lbmRBbmdsZSxcbiAgICAgIHBhZEFuZ2xlID0gX3JlZi5wYWRBbmdsZSxcbiAgICAgIHBhZFJhZGl1cyA9IF9yZWYucGFkUmFkaXVzLFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgWydjbGFzc05hbWUnLCAnZGF0YScsICdjZW50cm9pZCcsICdpbm5lclJhZGl1cycsICdvdXRlclJhZGl1cycsICdjb3JuZXJSYWRpdXMnLCAnc3RhcnRBbmdsZScsICdlbmRBbmdsZScsICdwYWRBbmdsZScsICdwYWRSYWRpdXMnXSk7XG5cbiAgdmFyIGFyYyQkMSA9IGFyYygpO1xuICBpZiAoY2VudHJvaWQpIGFyYyQkMS5jZW50cm9pZChjZW50cm9pZCk7XG4gIGlmIChpbm5lclJhZGl1cykgYXJjJCQxLmlubmVyUmFkaXVzKGlubmVyUmFkaXVzKTtcbiAgaWYgKG91dGVyUmFkaXVzKSBhcmMkJDEub3V0ZXJSYWRpdXMob3V0ZXJSYWRpdXMpO1xuICBpZiAoY29ybmVyUmFkaXVzKSBhcmMkJDEuY29ybmVyUmFkaXVzKGNvcm5lclJhZGl1cyk7XG4gIGlmIChzdGFydEFuZ2xlKSBhcmMkJDEuc3RhcnRBbmdsZShzdGFydEFuZ2xlKTtcbiAgaWYgKGVuZEFuZ2xlKSBhcmMkJDEuZW5kQW5nbGUoZW5kQW5nbGUpO1xuICBpZiAocGFkQW5nbGUpIGFyYyQkMS5wYWRBbmdsZShwYWRBbmdsZSk7XG4gIGlmIChwYWRSYWRpdXMpIGFyYyQkMS5wYWRSYWRpdXMocGFkUmFkaXVzKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCBfZXh0ZW5kcyh7IGNsYXNzTmFtZTogY3goJ3Z4LWFyYycsIGNsYXNzTmFtZSksIGQ6IGFyYyQkMShkYXRhKSB9LCBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzLCBkYXRhKSkpO1xufVxuXG5QaWUucHJvcFR5cGVzID0ge1xuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRvcDogUHJvcFR5cGVzLm51bWJlcixcbiAgbGVmdDogUHJvcFR5cGVzLm51bWJlcixcbiAgZGF0YTogUHJvcFR5cGVzLmFycmF5LFxuICBjZW50cm9pZDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgaW5uZXJSYWRpdXM6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gIG91dGVyUmFkaXVzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm51bWJlcl0pLFxuICBjb3JuZXJSYWRpdXM6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gIHN0YXJ0QW5nbGU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gIGVuZEFuZ2xlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm51bWJlcl0pLFxuICBwYWRBbmdsZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgcGFkUmFkaXVzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm51bWJlcl0pLFxuICBwaWVTb3J0OiBQcm9wVHlwZXMuZnVuYyxcbiAgcGllU29ydFZhbHVlczogUHJvcFR5cGVzLmZ1bmMsXG4gIHBpZVZhbHVlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm51bWJlcl0pLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIFBpZShfcmVmKSB7XG4gIHZhciBfcmVmJGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZiRjbGFzc05hbWUgPT09IHVuZGVmaW5lZCA/ICcnIDogX3JlZiRjbGFzc05hbWUsXG4gICAgICBfcmVmJHRvcCA9IF9yZWYudG9wLFxuICAgICAgdG9wID0gX3JlZiR0b3AgPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmJHRvcCxcbiAgICAgIF9yZWYkbGVmdCA9IF9yZWYubGVmdCxcbiAgICAgIGxlZnQgPSBfcmVmJGxlZnQgPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmJGxlZnQsXG4gICAgICBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgY2VudHJvaWQgPSBfcmVmLmNlbnRyb2lkLFxuICAgICAgX3JlZiRpbm5lclJhZGl1cyA9IF9yZWYuaW5uZXJSYWRpdXMsXG4gICAgICBpbm5lclJhZGl1cyA9IF9yZWYkaW5uZXJSYWRpdXMgPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmJGlubmVyUmFkaXVzLFxuICAgICAgb3V0ZXJSYWRpdXMgPSBfcmVmLm91dGVyUmFkaXVzLFxuICAgICAgY29ybmVyUmFkaXVzID0gX3JlZi5jb3JuZXJSYWRpdXMsXG4gICAgICBfcmVmJHN0YXJ0QW5nbGUgPSBfcmVmLnN0YXJ0QW5nbGUsXG4gICAgICBzdGFydEFuZ2xlID0gX3JlZiRzdGFydEFuZ2xlID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiRzdGFydEFuZ2xlLFxuICAgICAgZW5kQW5nbGUgPSBfcmVmLmVuZEFuZ2xlLFxuICAgICAgcGFkQW5nbGUgPSBfcmVmLnBhZEFuZ2xlLFxuICAgICAgcGFkUmFkaXVzID0gX3JlZi5wYWRSYWRpdXMsXG4gICAgICBwaWVTb3J0ID0gX3JlZi5waWVTb3J0LFxuICAgICAgcGllU29ydFZhbHVlcyA9IF9yZWYucGllU29ydFZhbHVlcyxcbiAgICAgIHBpZVZhbHVlID0gX3JlZi5waWVWYWx1ZSxcbiAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnY2xhc3NOYW1lJywgJ3RvcCcsICdsZWZ0JywgJ2RhdGEnLCAnY2VudHJvaWQnLCAnaW5uZXJSYWRpdXMnLCAnb3V0ZXJSYWRpdXMnLCAnY29ybmVyUmFkaXVzJywgJ3N0YXJ0QW5nbGUnLCAnZW5kQW5nbGUnLCAncGFkQW5nbGUnLCAncGFkUmFkaXVzJywgJ3BpZVNvcnQnLCAncGllU29ydFZhbHVlcycsICdwaWVWYWx1ZScsICdjaGlsZHJlbiddKTtcblxuICB2YXIgcGF0aCQkMSA9IGFyYygpO1xuICBwYXRoJCQxLmlubmVyUmFkaXVzKGlubmVyUmFkaXVzKTtcbiAgaWYgKG91dGVyUmFkaXVzKSBwYXRoJCQxLm91dGVyUmFkaXVzKG91dGVyUmFkaXVzKTtcbiAgaWYgKGNvcm5lclJhZGl1cykgcGF0aCQkMS5jb3JuZXJSYWRpdXMoY29ybmVyUmFkaXVzKTtcbiAgaWYgKHBhZFJhZGl1cykgcGF0aCQkMS5wYWRSYWRpdXMocGFkUmFkaXVzKTtcbiAgdmFyIHBpZSQkMSA9IHBpZSgpO1xuICBpZiAocGllU29ydCAhPT0gdW5kZWZpbmVkKSBwaWUkJDEuc29ydChwaWVTb3J0KTtcbiAgaWYgKHBpZVNvcnRWYWx1ZXMgIT09IHVuZGVmaW5lZCkgcGllJCQxLnNvcnRWYWx1ZXMocGllU29ydFZhbHVlcyk7XG4gIGlmIChwaWVWYWx1ZSkgcGllJCQxLnZhbHVlKHBpZVZhbHVlKTtcbiAgaWYgKHBhZEFuZ2xlICE9IG51bGwpIHBpZSQkMS5wYWRBbmdsZShwYWRBbmdsZSk7XG4gIGlmIChzdGFydEFuZ2xlICE9IG51bGwpIHBpZSQkMS5zdGFydEFuZ2xlKHN0YXJ0QW5nbGUpO1xuICBpZiAoZW5kQW5nbGUgIT0gbnVsbCkgcGllJCQxLmVuZEFuZ2xlKGVuZEFuZ2xlKTtcbiAgdmFyIGFyY3MgPSBwaWUkJDEoZGF0YSk7XG4gIHZhciByZW5kZXJGdW5jdGlvbkFyZyA9IHtcbiAgICBhcmNzOiBhcmNzLFxuICAgIGdlbmVyYXRlUGF0aFByb3BzOiBmdW5jdGlvbiBnZW5lcmF0ZVBhdGhQcm9wcyhhcmMkJDEsIGluZGV4KSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgICBjbGFzc05hbWU6IGN4KCd2eC1waWUtYXJjJywgY2xhc3NOYW1lKSxcbiAgICAgICAgZDogcGF0aCQkMShhcmMkJDEpXG4gICAgICB9LCBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzLCBfZXh0ZW5kcyh7fSwgYXJjJCQxLCB7XG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgY2VudHJvaWQ6IGNlbnRyb2lkID8gcGF0aCQkMS5jZW50cm9pZChhcmMkJDEpIDogdW5kZWZpbmVkXG4gICAgICB9KSkpO1xuICAgIH0sXG4gICAgZ2VuZXJhdGVDZW50cm9pZDogZnVuY3Rpb24gZ2VuZXJhdGVDZW50cm9pZChhcmMkJDEpIHtcbiAgICAgIHJldHVybiBjZW50cm9pZCAmJiBjZW50cm9pZChwYXRoJCQxLmNlbnRyb2lkKGFyYyQkMSksIGFyYyQkMSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICBHcm91cCxcbiAgICB7IGNsYXNzTmFtZTogJ3Z4LXBpZS1hcmNzLWdyb3VwJywgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfSxcbiAgICBjaGlsZHJlbiA/IGNoaWxkcmVuKHJlbmRlckZ1bmN0aW9uQXJnKSA6IGFyY3MubWFwKGZ1bmN0aW9uIChhcmMkJDEsIGkpIHtcbiAgICAgIHZhciBwYXRoUHJvcHMgPSByZW5kZXJGdW5jdGlvbkFyZy5nZW5lcmF0ZVBhdGhQcm9wcyhhcmMkJDEsIGkpO1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICdnJyxcbiAgICAgICAgeyBrZXk6ICdwaWUtYXJjLScgKyBpIH0sXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCBwYXRoUHJvcHMpLFxuICAgICAgICByZW5kZXJGdW5jdGlvbkFyZy5nZW5lcmF0ZUNlbnRyb2lkKGFyYyQkMSlcbiAgICAgICk7XG4gICAgfSlcbiAgKTtcbn1cblxuTGluZS5wcm9wVHlwZXMgPSB7XG4gIGlubmVyUmVmOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuZnVuY3Rpb24gTGluZShfcmVmKSB7XG4gIHZhciBfcmVmJGZyb20gPSBfcmVmLmZyb20sXG4gICAgICBmcm9tID0gX3JlZiRmcm9tID09PSB1bmRlZmluZWQgPyBuZXcgUG9pbnQoeyB4OiAwLCB5OiAwIH0pIDogX3JlZiRmcm9tLFxuICAgICAgX3JlZiR0byA9IF9yZWYudG8sXG4gICAgICB0byA9IF9yZWYkdG8gPT09IHVuZGVmaW5lZCA/IG5ldyBQb2ludCh7IHg6IDEsIHk6IDEgfSkgOiBfcmVmJHRvLFxuICAgICAgX3JlZiRzdHJva2UgPSBfcmVmLnN0cm9rZSxcbiAgICAgIHN0cm9rZSA9IF9yZWYkc3Ryb2tlID09PSB1bmRlZmluZWQgPyAnYmxhY2snIDogX3JlZiRzdHJva2UsXG4gICAgICBfcmVmJHN0cm9rZVdpZHRoID0gX3JlZi5zdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZVdpZHRoID0gX3JlZiRzdHJva2VXaWR0aCA9PT0gdW5kZWZpbmVkID8gMSA6IF9yZWYkc3Ryb2tlV2lkdGgsXG4gICAgICBfcmVmJHN0cm9rZURhc2hhcnJheSA9IF9yZWYuc3Ryb2tlRGFzaGFycmF5LFxuICAgICAgc3Ryb2tlRGFzaGFycmF5ID0gX3JlZiRzdHJva2VEYXNoYXJyYXkgPT09IHVuZGVmaW5lZCA/ICcnIDogX3JlZiRzdHJva2VEYXNoYXJyYXksXG4gICAgICBfcmVmJHRyYW5zZm9ybSA9IF9yZWYudHJhbnNmb3JtLFxuICAgICAgdHJhbnNmb3JtID0gX3JlZiR0cmFuc2Zvcm0gPT09IHVuZGVmaW5lZCA/ICcnIDogX3JlZiR0cmFuc2Zvcm0sXG4gICAgICBfcmVmJGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZiRjbGFzc05hbWUgPT09IHVuZGVmaW5lZCA/ICcnIDogX3JlZiRjbGFzc05hbWUsXG4gICAgICBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgaW5uZXJSZWYgPSBfcmVmLmlubmVyUmVmLFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgWydmcm9tJywgJ3RvJywgJ3N0cm9rZScsICdzdHJva2VXaWR0aCcsICdzdHJva2VEYXNoYXJyYXknLCAndHJhbnNmb3JtJywgJ2NsYXNzTmFtZScsICdkYXRhJywgJ2lubmVyUmVmJ10pO1xuXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdsaW5lJywgX2V4dGVuZHMoe1xuICAgIHJlZjogaW5uZXJSZWYsXG4gICAgY2xhc3NOYW1lOiBjeCgndngtbGluZScsIGNsYXNzTmFtZSksXG4gICAgeDE6IGZyb20ueCxcbiAgICB5MTogZnJvbS55LFxuICAgIHgyOiB0by54LFxuICAgIHkyOiB0by55LFxuICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICBzdHJva2VEYXNoYXJyYXk6IHN0cm9rZURhc2hhcnJheSxcbiAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybVxuICB9LCBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzLCBkYXRhKSkpO1xufVxuXG5MaW5lUGF0aC5wcm9wVHlwZXMgPSB7XG4gIGlubmVyUmVmOiBQcm9wVHlwZXMuZnVuYyxcbiAgeFNjYWxlOiBQcm9wVHlwZXMuZnVuYyxcbiAgeVNjYWxlOiBQcm9wVHlwZXMuZnVuYyxcbiAgZGF0YTogUHJvcFR5cGVzLmFycmF5LFxuICB4OiBQcm9wVHlwZXMuZnVuYyxcbiAgeTogUHJvcFR5cGVzLmZ1bmMsXG4gIGRlZmluZWQ6IFByb3BUeXBlcy5mdW5jLFxuICBzdHJva2U6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHN0cm9rZVdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLFxuICBnbHlwaDogUHJvcFR5cGVzLmZ1bmMsXG4gIGN1cnZlOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuZnVuY3Rpb24gTGluZVBhdGgoX3JlZikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgIHhTY2FsZSA9IF9yZWYueFNjYWxlLFxuICAgICAgeVNjYWxlID0gX3JlZi55U2NhbGUsXG4gICAgICB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueSxcbiAgICAgIF9yZWYkZGVmaW5lZCA9IF9yZWYuZGVmaW5lZCxcbiAgICAgIGRlZmluZWQgPSBfcmVmJGRlZmluZWQgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSA6IF9yZWYkZGVmaW5lZCxcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgX3JlZiRzdHJva2UgPSBfcmVmLnN0cm9rZSxcbiAgICAgIHN0cm9rZSA9IF9yZWYkc3Ryb2tlID09PSB1bmRlZmluZWQgPyAnc3RlZWxibHVlJyA6IF9yZWYkc3Ryb2tlLFxuICAgICAgX3JlZiRzdHJva2VXaWR0aCA9IF9yZWYuc3Ryb2tlV2lkdGgsXG4gICAgICBzdHJva2VXaWR0aCA9IF9yZWYkc3Ryb2tlV2lkdGggPT09IHVuZGVmaW5lZCA/IDIgOiBfcmVmJHN0cm9rZVdpZHRoLFxuICAgICAgX3JlZiRzdHJva2VEYXNoYXJyYXkgPSBfcmVmLnN0cm9rZURhc2hhcnJheSxcbiAgICAgIHN0cm9rZURhc2hhcnJheSA9IF9yZWYkc3Ryb2tlRGFzaGFycmF5ID09PSB1bmRlZmluZWQgPyAnJyA6IF9yZWYkc3Ryb2tlRGFzaGFycmF5LFxuICAgICAgX3JlZiRzdHJva2VEYXNob2Zmc2V0ID0gX3JlZi5zdHJva2VEYXNob2Zmc2V0LFxuICAgICAgc3Ryb2tlRGFzaG9mZnNldCA9IF9yZWYkc3Ryb2tlRGFzaG9mZnNldCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkc3Ryb2tlRGFzaG9mZnNldCxcbiAgICAgIF9yZWYkZmlsbCA9IF9yZWYuZmlsbCxcbiAgICAgIGZpbGwgPSBfcmVmJGZpbGwgPT09IHVuZGVmaW5lZCA/ICdub25lJyA6IF9yZWYkZmlsbCxcbiAgICAgIF9yZWYkY3VydmUgPSBfcmVmLmN1cnZlLFxuICAgICAgY3VydmUgPSBfcmVmJGN1cnZlID09PSB1bmRlZmluZWQgPyBjdXJ2ZUxpbmVhciA6IF9yZWYkY3VydmUsXG4gICAgICBnbHlwaCA9IF9yZWYuZ2x5cGgsXG4gICAgICBpbm5lclJlZiA9IF9yZWYuaW5uZXJSZWYsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2NoaWxkcmVuJywgJ2RhdGEnLCAneFNjYWxlJywgJ3lTY2FsZScsICd4JywgJ3knLCAnZGVmaW5lZCcsICdjbGFzc05hbWUnLCAnc3Ryb2tlJywgJ3N0cm9rZVdpZHRoJywgJ3N0cm9rZURhc2hhcnJheScsICdzdHJva2VEYXNob2Zmc2V0JywgJ2ZpbGwnLCAnY3VydmUnLCAnZ2x5cGgnLCAnaW5uZXJSZWYnXSk7XG5cbiAgdmFyIHBhdGgkJDEgPSBsaW5lKCkueChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHhTY2FsZSh4LmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSk7XG4gIH0pLnkoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB5U2NhbGUoeS5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykpO1xuICB9KS5kZWZpbmVkKGRlZmluZWQpLmN1cnZlKGN1cnZlKTtcbiAgaWYgKGNoaWxkcmVuKSByZXR1cm4gY2hpbGRyZW4oeyBwYXRoOiBwYXRoJCQxIH0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAnZycsXG4gICAgbnVsbCxcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgICAgcmVmOiBpbm5lclJlZixcbiAgICAgIGNsYXNzTmFtZTogY3goJ3Z4LWxpbmVwYXRoJywgY2xhc3NOYW1lKSxcbiAgICAgIGQ6IHBhdGgkJDEoZGF0YSksXG4gICAgICBzdHJva2U6IHN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZURhc2hhcnJheTogc3Ryb2tlRGFzaGFycmF5LFxuICAgICAgc3Ryb2tlRGFzaG9mZnNldDogc3Ryb2tlRGFzaG9mZnNldCxcbiAgICAgIGZpbGw6IGZpbGxcbiAgICB9LCBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzLCBkYXRhKSkpLFxuICAgIGdseXBoICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnZycsXG4gICAgICB7IGNsYXNzTmFtZTogJ3Z4LWxpbmVwYXRoLWdseXBocycgfSxcbiAgICAgIGRhdGEubWFwKGdseXBoKVxuICAgIClcbiAgKTtcbn1cblxuTGluZVJhZGlhbC5wcm9wVHlwZXMgPSB7XG4gIGlubmVyUmVmOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuZnVuY3Rpb24gTGluZVJhZGlhbChfcmVmKSB7XG4gIHZhciBfcmVmJGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZiRjbGFzc05hbWUgPT09IHVuZGVmaW5lZCA/ICcnIDogX3JlZiRjbGFzc05hbWUsXG4gICAgICBhbmdsZSA9IF9yZWYuYW5nbGUsXG4gICAgICByYWRpdXMgPSBfcmVmLnJhZGl1cyxcbiAgICAgIGRlZmluZWQgPSBfcmVmLmRlZmluZWQsXG4gICAgICBjdXJ2ZSA9IF9yZWYuY3VydmUsXG4gICAgICBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgaW5uZXJSZWYgPSBfcmVmLmlubmVyUmVmLFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgWydjbGFzc05hbWUnLCAnYW5nbGUnLCAncmFkaXVzJywgJ2RlZmluZWQnLCAnY3VydmUnLCAnZGF0YScsICdpbm5lclJlZiddKTtcblxuICB2YXIgcGF0aCQkMSA9IHJhZGlhbExpbmUoKTtcbiAgaWYgKGFuZ2xlKSBwYXRoJCQxLmFuZ2xlKGFuZ2xlKTtcbiAgaWYgKHJhZGl1cykgcGF0aCQkMS5yYWRpdXMocmFkaXVzKTtcbiAgaWYgKGRlZmluZWQpIHBhdGgkJDEuZGVmaW5lZChkZWZpbmVkKTtcbiAgaWYgKGN1cnZlKSBwYXRoJCQxLmN1cnZlKGN1cnZlKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgJ2cnLFxuICAgIG51bGwsXG4gICAgUmVhY3QuY3JlYXRlRWxlbWVudCgncGF0aCcsIF9leHRlbmRzKHtcbiAgICAgIHJlZjogaW5uZXJSZWYsXG4gICAgICBjbGFzc05hbWU6IGN4KCd2eC1saW5lLXJhZGlhbCcsIGNsYXNzTmFtZSksXG4gICAgICBkOiBwYXRoJCQxKGRhdGEpXG4gICAgfSwgYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcywgZGF0YSkpKVxuICApO1xufVxuXG5BcmVhLnByb3BUeXBlcyA9IHtcbiAgeDogUHJvcFR5cGVzLmZ1bmMsXG4gIHgwOiBQcm9wVHlwZXMuZnVuYyxcbiAgeDE6IFByb3BUeXBlcy5mdW5jLFxuICB5OiBQcm9wVHlwZXMuZnVuYyxcbiAgeTA6IFByb3BUeXBlcy5mdW5jLFxuICB5MTogUHJvcFR5cGVzLmZ1bmMsXG4gIHhTY2FsZTogUHJvcFR5cGVzLmZ1bmMsXG4gIHlTY2FsZTogUHJvcFR5cGVzLmZ1bmMsXG4gIGRhdGE6IFByb3BUeXBlcy5hcnJheSxcbiAgZGVmaW5lZDogUHJvcFR5cGVzLmZ1bmMsXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLmJvb2wsIFByb3BUeXBlcy5vYmplY3QsIFByb3BUeXBlcy5hcnJheV0pLFxuICBpbm5lclJlZjogUHJvcFR5cGVzLmZ1bmMsXG4gIHN0cm9rZURhc2hhcnJheTogUHJvcFR5cGVzLnN0cmluZyxcbiAgc3Ryb2tlV2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXG4gIHN0cm9rZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgZmlsbDogUHJvcFR5cGVzLnN0cmluZyxcbiAgY3VydmU6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5mdW5jdGlvbiBBcmVhKF9yZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIHggPSBfcmVmLngsXG4gICAgICB4MCA9IF9yZWYueDAsXG4gICAgICB4MSA9IF9yZWYueDEsXG4gICAgICB5ID0gX3JlZi55LFxuICAgICAgeTAgPSBfcmVmLnkwLFxuICAgICAgeTEgPSBfcmVmLnkxLFxuICAgICAgeFNjYWxlID0gX3JlZi54U2NhbGUsXG4gICAgICB5U2NhbGUgPSBfcmVmLnlTY2FsZSxcbiAgICAgIF9yZWYkZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgIGRhdGEgPSBfcmVmJGRhdGEgPT09IHVuZGVmaW5lZCA/IFtdIDogX3JlZiRkYXRhLFxuICAgICAgX3JlZiRkZWZpbmVkID0gX3JlZi5kZWZpbmVkLFxuICAgICAgZGVmaW5lZCA9IF9yZWYkZGVmaW5lZCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IDogX3JlZiRkZWZpbmVkLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBzdHJva2VEYXNoYXJyYXkgPSBfcmVmLnN0cm9rZURhc2hhcnJheSxcbiAgICAgIF9yZWYkc3Ryb2tlV2lkdGggPSBfcmVmLnN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlV2lkdGggPSBfcmVmJHN0cm9rZVdpZHRoID09PSB1bmRlZmluZWQgPyAyIDogX3JlZiRzdHJva2VXaWR0aCxcbiAgICAgIF9yZWYkc3Ryb2tlID0gX3JlZi5zdHJva2UsXG4gICAgICBzdHJva2UgPSBfcmVmJHN0cm9rZSA9PT0gdW5kZWZpbmVkID8gJ2JsYWNrJyA6IF9yZWYkc3Ryb2tlLFxuICAgICAgX3JlZiRmaWxsID0gX3JlZi5maWxsLFxuICAgICAgZmlsbCA9IF9yZWYkZmlsbCA9PT0gdW5kZWZpbmVkID8gJ3JnYmEoMCwwLDAsMC4zKScgOiBfcmVmJGZpbGwsXG4gICAgICBjdXJ2ZSA9IF9yZWYuY3VydmUsXG4gICAgICBpbm5lclJlZiA9IF9yZWYuaW5uZXJSZWYsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2NoaWxkcmVuJywgJ3gnLCAneDAnLCAneDEnLCAneScsICd5MCcsICd5MScsICd4U2NhbGUnLCAneVNjYWxlJywgJ2RhdGEnLCAnZGVmaW5lZCcsICdjbGFzc05hbWUnLCAnc3Ryb2tlRGFzaGFycmF5JywgJ3N0cm9rZVdpZHRoJywgJ3N0cm9rZScsICdmaWxsJywgJ2N1cnZlJywgJ2lubmVyUmVmJ10pO1xuXG4gIHZhciBwYXRoJCQxID0gYXJlYSgpO1xuICBpZiAoeCkgcGF0aCQkMS54KGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4geFNjYWxlKHguYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKTtcbiAgfSk7XG4gIGlmICh4MCkgcGF0aCQkMS54MChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHhTY2FsZSh4MC5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykpO1xuICB9KTtcbiAgaWYgKHgxKSBwYXRoJCQxLngxKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4geFNjYWxlKHgxLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSk7XG4gIH0pO1xuICBpZiAoeSkgcGF0aCQkMS55KGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4geVNjYWxlKHkuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKTtcbiAgfSk7XG4gIGlmICh5MCkgcGF0aCQkMS55MChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHlTY2FsZSh5MC5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykpO1xuICB9KTtcbiAgaWYgKHkxKSBwYXRoJCQxLnkxKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4geVNjYWxlKHkxLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSk7XG4gIH0pO1xuICBpZiAoZGVmaW5lZCkgcGF0aCQkMS5kZWZpbmVkKGRlZmluZWQpO1xuICBpZiAoY3VydmUpIHBhdGgkJDEuY3VydmUoY3VydmUpO1xuICBpZiAoY2hpbGRyZW4pIHJldHVybiBjaGlsZHJlbih7IHBhdGg6IHBhdGgkJDEgfSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICdnJyxcbiAgICBudWxsLFxuICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCBfZXh0ZW5kcyh7XG4gICAgICByZWY6IGlubmVyUmVmLFxuICAgICAgY2xhc3NOYW1lOiBjeCgndngtYXJlYScsIGNsYXNzTmFtZSksXG4gICAgICBkOiBwYXRoJCQxKGRhdGEpLFxuICAgICAgc3Ryb2tlOiBzdHJva2UsXG4gICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgICBzdHJva2VEYXNoYXJyYXk6IHN0cm9rZURhc2hhcnJheSxcbiAgICAgIGZpbGw6IGZpbGxcbiAgICB9LCBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzLCBkYXRhKSkpXG4gICk7XG59XG5cbkFyZWFDbG9zZWQucHJvcFR5cGVzID0ge1xuICBpbm5lclJlZjogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIEFyZWFDbG9zZWQoX3JlZikge1xuICB2YXIgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnksXG4gICAgICB5MCA9IF9yZWYueTAsXG4gICAgICB4U2NhbGUgPSBfcmVmLnhTY2FsZSxcbiAgICAgIHlTY2FsZSA9IF9yZWYueVNjYWxlLFxuICAgICAgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgIF9yZWYkZGVmaW5lZCA9IF9yZWYuZGVmaW5lZCxcbiAgICAgIGRlZmluZWQgPSBfcmVmJGRlZmluZWQgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSA6IF9yZWYkZGVmaW5lZCxcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgc3Ryb2tlRGFzaGFycmF5ID0gX3JlZi5zdHJva2VEYXNoYXJyYXksXG4gICAgICBfcmVmJHN0cm9rZVdpZHRoID0gX3JlZi5zdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZVdpZHRoID0gX3JlZiRzdHJva2VXaWR0aCA9PT0gdW5kZWZpbmVkID8gMiA6IF9yZWYkc3Ryb2tlV2lkdGgsXG4gICAgICBfcmVmJHN0cm9rZSA9IF9yZWYuc3Ryb2tlLFxuICAgICAgc3Ryb2tlID0gX3JlZiRzdHJva2UgPT09IHVuZGVmaW5lZCA/ICdibGFjaycgOiBfcmVmJHN0cm9rZSxcbiAgICAgIF9yZWYkZmlsbCA9IF9yZWYuZmlsbCxcbiAgICAgIGZpbGwgPSBfcmVmJGZpbGwgPT09IHVuZGVmaW5lZCA/ICdyZ2JhKDAsMCwwLDAuMyknIDogX3JlZiRmaWxsLFxuICAgICAgY3VydmUgPSBfcmVmLmN1cnZlLFxuICAgICAgaW5uZXJSZWYgPSBfcmVmLmlubmVyUmVmLFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgWyd4JywgJ3knLCAneTAnLCAneFNjYWxlJywgJ3lTY2FsZScsICdkYXRhJywgJ2RlZmluZWQnLCAnY2xhc3NOYW1lJywgJ3N0cm9rZURhc2hhcnJheScsICdzdHJva2VXaWR0aCcsICdzdHJva2UnLCAnZmlsbCcsICdjdXJ2ZScsICdpbm5lclJlZiddKTtcblxuICB2YXIgcGF0aCQkMSA9IGFyZWEoKS54KGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4geFNjYWxlKHguYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKTtcbiAgfSkueTAoeTAgfHwgeVNjYWxlLnJhbmdlKClbMF0pLnkxKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4geVNjYWxlKHkuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKTtcbiAgfSkuZGVmaW5lZChkZWZpbmVkKTtcbiAgaWYgKGN1cnZlKSBwYXRoJCQxLmN1cnZlKGN1cnZlKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgJ2cnLFxuICAgIG51bGwsXG4gICAgUmVhY3QuY3JlYXRlRWxlbWVudCgncGF0aCcsIF9leHRlbmRzKHtcbiAgICAgIHJlZjogaW5uZXJSZWYsXG4gICAgICBjbGFzc05hbWU6IGN4KCd2eC1hcmVhLWNsb3NlZCcsIGNsYXNzTmFtZSksXG4gICAgICBkOiBwYXRoJCQxKGRhdGEpLFxuICAgICAgc3Ryb2tlOiBzdHJva2UsXG4gICAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgICBzdHJva2VEYXNoYXJyYXk6IHN0cm9rZURhc2hhcnJheSxcbiAgICAgIGZpbGw6IGZpbGxcbiAgICB9LCBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzLCBkYXRhKSkpXG4gICk7XG59XG5cbkFyZWFTdGFjay5wcm9wVHlwZXMgPSB7XG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdG9wOiBQcm9wVHlwZXMubnVtYmVyLFxuICBsZWZ0OiBQcm9wVHlwZXMubnVtYmVyLFxuICBrZXlzOiBQcm9wVHlwZXMuYXJyYXksXG4gIGRhdGE6IFByb3BUeXBlcy5hcnJheSxcbiAgY3VydmU6IFByb3BUeXBlcy5mdW5jLFxuICBkZWZpbmVkOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLmJvb2xdKSxcbiAgeDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgeDA6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gIHgxOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm51bWJlcl0pLFxuICB5OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm51bWJlcl0pLFxuICB5MDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgeTE6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gIGdseXBoOiBQcm9wVHlwZXMuYm9vbCxcbiAgcmV2ZXJzZTogUHJvcFR5cGVzLmJvb2xcbn07XG5cbmZ1bmN0aW9uIEFyZWFTdGFjayhfcmVmKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIGtleXMgPSBfcmVmLmtleXMsXG4gICAgICBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgY3VydmUgPSBfcmVmLmN1cnZlLFxuICAgICAgZGVmaW5lZCA9IF9yZWYuZGVmaW5lZCxcbiAgICAgIHggPSBfcmVmLngsXG4gICAgICB4MCA9IF9yZWYueDAsXG4gICAgICB4MSA9IF9yZWYueDEsXG4gICAgICB5MCA9IF9yZWYueTAsXG4gICAgICB5MSA9IF9yZWYueTEsXG4gICAgICBnbHlwaCA9IF9yZWYuZ2x5cGgsXG4gICAgICBfcmVmJHJldmVyc2UgPSBfcmVmLnJldmVyc2UsXG4gICAgICByZXZlcnNlID0gX3JlZiRyZXZlcnNlID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkcmV2ZXJzZSxcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnY2xhc3NOYW1lJywgJ2tleXMnLCAnZGF0YScsICdjdXJ2ZScsICdkZWZpbmVkJywgJ3gnLCAneDAnLCAneDEnLCAneTAnLCAneTEnLCAnZ2x5cGgnLCAncmV2ZXJzZSddKTtcblxuICB2YXIgc3RhY2skJDEgPSBzdGFjaygpO1xuICBpZiAoa2V5cykgc3RhY2skJDEua2V5cyhrZXlzKTtcblxuICB2YXIgcGF0aCQkMSA9IGFyZWEoKTtcbiAgaWYgKHgpIHBhdGgkJDEueCh4KTtcbiAgaWYgKHgwKSBwYXRoJCQxLngwKHgwKTtcbiAgaWYgKHgxKSBwYXRoJCQxLngxKHgxKTtcbiAgaWYgKHkwKSBwYXRoJCQxLnkwKHkwKTtcbiAgaWYgKHkxKSBwYXRoJCQxLnkxKHkxKTtcbiAgaWYgKGN1cnZlKSBwYXRoJCQxLmN1cnZlKGN1cnZlKTtcbiAgaWYgKGRlZmluZWQpIHBhdGgkJDEuZGVmaW5lZChkZWZpbmVkKTtcblxuICB2YXIgc2VyaWVzRGF0YSA9IHN0YWNrJCQxKGRhdGEpO1xuICBpZiAocmV2ZXJzZSkgc2VyaWVzRGF0YS5yZXZlcnNlKCk7XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgJ2cnLFxuICAgIG51bGwsXG4gICAgc2VyaWVzRGF0YS5tYXAoZnVuY3Rpb24gKHNlcmllcywgaSkge1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCBfZXh0ZW5kcyh7XG4gICAgICAgIGNsYXNzTmFtZTogY3goJ3Z4LWFyZWEtc3RhY2snLCBjbGFzc05hbWUpLFxuICAgICAgICBrZXk6ICdhcmVhLXN0YWNrLScgKyBpICsgJy0nICsgKHNlcmllcy5rZXkgfHwgJycpLFxuICAgICAgICBkOiBwYXRoJCQxKHNlcmllcylcbiAgICAgIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIHtcbiAgICAgICAgZGF0dW06IHNlcmllc1tpXSxcbiAgICAgICAgaW5kZXg6IGksXG4gICAgICAgIHNlcmllczogc2VyaWVzXG4gICAgICB9KSkpO1xuICAgIH0pLFxuICAgICEhZ2x5cGggJiYgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICdnJyxcbiAgICAgIHsgY2xhc3NOYW1lOiAndngtYXJlYS1zdGFjay1nbHlwaHMnIH0sXG4gICAgICBkYXRhLm1hcChnbHlwaClcbiAgICApXG4gICk7XG59XG5cbkJhci5wcm9wVHlwZXMgPSB7XG4gIGlubmVyUmVmOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuZnVuY3Rpb24gQmFyKF9yZWYpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgaW5uZXJSZWYgPSBfcmVmLmlubmVyUmVmLFxuICAgICAgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgIF9yZWYkeCA9IF9yZWYueCxcbiAgICAgIHggPSBfcmVmJHggPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmJHgsXG4gICAgICBfcmVmJHkgPSBfcmVmLnksXG4gICAgICB5ID0gX3JlZiR5ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiR5LFxuICAgICAgd2lkdGggPSBfcmVmLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQsXG4gICAgICByeCA9IF9yZWYucngsXG4gICAgICByeSA9IF9yZWYucnksXG4gICAgICBfcmVmJGZpbGwgPSBfcmVmLmZpbGwsXG4gICAgICBmaWxsID0gX3JlZiRmaWxsID09PSB1bmRlZmluZWQgPyAnc3RlZWxibHVlJyA6IF9yZWYkZmlsbCxcbiAgICAgIGZpbGxPcGFjaXR5ID0gX3JlZi5maWxsT3BhY2l0eSxcbiAgICAgIHN0cm9rZSA9IF9yZWYuc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGggPSBfcmVmLnN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlRGFzaGFycmF5ID0gX3JlZi5zdHJva2VEYXNoYXJyYXksXG4gICAgICBzdHJva2VMaW5lY2FwID0gX3JlZi5zdHJva2VMaW5lY2FwLFxuICAgICAgc3Ryb2tlTGluZWpvaW4gPSBfcmVmLnN0cm9rZUxpbmVqb2luLFxuICAgICAgc3Ryb2tlTWl0ZXJsaW1pdCA9IF9yZWYuc3Ryb2tlTWl0ZXJsaW1pdCxcbiAgICAgIHN0cm9rZU9wYWNpdHkgPSBfcmVmLnN0cm9rZU9wYWNpdHksXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2NsYXNzTmFtZScsICdpbm5lclJlZicsICdkYXRhJywgJ3gnLCAneScsICd3aWR0aCcsICdoZWlnaHQnLCAncngnLCAncnknLCAnZmlsbCcsICdmaWxsT3BhY2l0eScsICdzdHJva2UnLCAnc3Ryb2tlV2lkdGgnLCAnc3Ryb2tlRGFzaGFycmF5JywgJ3N0cm9rZUxpbmVjYXAnLCAnc3Ryb2tlTGluZWpvaW4nLCAnc3Ryb2tlTWl0ZXJsaW1pdCcsICdzdHJva2VPcGFjaXR5J10pO1xuXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdyZWN0JywgX2V4dGVuZHMoe1xuICAgIHJlZjogaW5uZXJSZWYsXG4gICAgY2xhc3NOYW1lOiBjeCgndngtYmFyJywgY2xhc3NOYW1lKSxcbiAgICB4OiB4LFxuICAgIHk6IHksXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHJ4OiByeCxcbiAgICByeTogcnksXG4gICAgZmlsbDogZmlsbCxcbiAgICBmaWxsT3BhY2l0eTogZmlsbE9wYWNpdHksXG4gICAgc3Ryb2tlOiBzdHJva2UsXG4gICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgIHN0cm9rZURhc2hhcnJheTogc3Ryb2tlRGFzaGFycmF5LFxuICAgIHN0cm9rZUxpbmVjYXA6IHN0cm9rZUxpbmVjYXAsXG4gICAgc3Ryb2tlTGluZWpvaW46IHN0cm9rZUxpbmVqb2luLFxuICAgIHN0cm9rZU1pdGVybGltaXQ6IHN0cm9rZU1pdGVybGltaXQsXG4gICAgc3Ryb2tlT3BhY2l0eTogc3Ryb2tlT3BhY2l0eVxuICB9LCBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzLCBkYXRhKSkpO1xufVxuXG5CYXJHcm91cC5wcm9wVHlwZXMgPSB7XG4gIGRhdGE6IFByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLFxuICB4MDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgeDBTY2FsZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgeDFTY2FsZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgeVNjYWxlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB6U2NhbGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIGtleXM6IFByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLFxuICBoZWlnaHQ6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICB0b3A6IFByb3BUeXBlcy5udW1iZXIsXG4gIGxlZnQ6IFByb3BUeXBlcy5udW1iZXJcbn07XG5cbmZ1bmN0aW9uIEJhckdyb3VwKF9yZWYpIHtcbiAgdmFyIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIHRvcCA9IF9yZWYudG9wLFxuICAgICAgbGVmdCA9IF9yZWYubGVmdCxcbiAgICAgIHgwID0gX3JlZi54MCxcbiAgICAgIHgwU2NhbGUgPSBfcmVmLngwU2NhbGUsXG4gICAgICB4MVNjYWxlID0gX3JlZi54MVNjYWxlLFxuICAgICAgeVNjYWxlID0gX3JlZi55U2NhbGUsXG4gICAgICB6U2NhbGUgPSBfcmVmLnpTY2FsZSxcbiAgICAgIGtleXMgPSBfcmVmLmtleXMsXG4gICAgICBoZWlnaHQgPSBfcmVmLmhlaWdodCxcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnZGF0YScsICdjbGFzc05hbWUnLCAndG9wJywgJ2xlZnQnLCAneDAnLCAneDBTY2FsZScsICd4MVNjYWxlJywgJ3lTY2FsZScsICd6U2NhbGUnLCAna2V5cycsICdoZWlnaHQnXSk7XG5cbiAgdmFyIGZvcm1hdCA9IHgwU2NhbGUudGlja0Zvcm1hdCA/IHgwU2NhbGUudGlja0Zvcm1hdCgpIDogZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZDtcbiAgfTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgR3JvdXAsXG4gICAgeyBjbGFzc05hbWU6IGN4KCd2eC1iYXItZ3JvdXAnLCBjbGFzc05hbWUpLCB0b3A6IHRvcCwgbGVmdDogbGVmdCB9LFxuICAgIGRhdGEgJiYgZGF0YS5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICBHcm91cCxcbiAgICAgICAgeyBrZXk6ICdiYXItZ3JvdXAtJyArIGkgKyAnLScgKyB4MChkKSwgbGVmdDogeDBTY2FsZSh4MChkKSkgfSxcbiAgICAgICAga2V5cyAmJiBrZXlzLm1hcChmdW5jdGlvbiAoa2V5LCBqKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gZFtrZXldO1xuICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEJhciwgX2V4dGVuZHMoe1xuICAgICAgICAgICAga2V5OiAnYmFyLWdyb3VwLWJhci0nICsgaSArICctJyArIGogKyAnLScgKyB2YWx1ZSArICctJyArIGtleSxcbiAgICAgICAgICAgIHg6IHgxU2NhbGUoa2V5KSxcbiAgICAgICAgICAgIHk6IHlTY2FsZSh2YWx1ZSksXG4gICAgICAgICAgICB3aWR0aDogeDFTY2FsZS5iYW5kd2lkdGgoKSxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0IC0geVNjYWxlKHZhbHVlKSxcbiAgICAgICAgICAgIGZpbGw6IHpTY2FsZShrZXkpLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICB4OiBmb3JtYXQoeDAoZCkpLFxuICAgICAgICAgICAgICBkYXRhOiBkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVzdFByb3BzKSk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pXG4gICk7XG59XG5cbkJhckdyb3VwSG9yaXpvbnRhbC5wcm9wVHlwZXMgPSB7XG4gIGRhdGE6IFByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLFxuICB5MDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgeTBTY2FsZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgeTFTY2FsZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgeFNjYWxlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB6U2NhbGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIGtleXM6IFByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLFxuICB3aWR0aDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRvcDogUHJvcFR5cGVzLm51bWJlcixcbiAgbGVmdDogUHJvcFR5cGVzLm51bWJlclxufTtcblxuZnVuY3Rpb24gQmFyR3JvdXBIb3Jpem9udGFsKF9yZWYpIHtcbiAgdmFyIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIHRvcCA9IF9yZWYudG9wLFxuICAgICAgbGVmdCA9IF9yZWYubGVmdCxcbiAgICAgIHkwID0gX3JlZi55MCxcbiAgICAgIHkwU2NhbGUgPSBfcmVmLnkwU2NhbGUsXG4gICAgICB5MVNjYWxlID0gX3JlZi55MVNjYWxlLFxuICAgICAgeFNjYWxlID0gX3JlZi54U2NhbGUsXG4gICAgICB6U2NhbGUgPSBfcmVmLnpTY2FsZSxcbiAgICAgIGtleXMgPSBfcmVmLmtleXMsXG4gICAgICB3aWR0aCA9IF9yZWYud2lkdGgsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2RhdGEnLCAnY2xhc3NOYW1lJywgJ3RvcCcsICdsZWZ0JywgJ3kwJywgJ3kwU2NhbGUnLCAneTFTY2FsZScsICd4U2NhbGUnLCAnelNjYWxlJywgJ2tleXMnLCAnd2lkdGgnXSk7XG5cbiAgdmFyIGZvcm1hdCA9IHkwU2NhbGUudGlja0Zvcm1hdCA/IHkwU2NhbGUudGlja0Zvcm1hdCgpIDogZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZDtcbiAgfTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgR3JvdXAsXG4gICAgeyBjbGFzc05hbWU6IGN4KCd2eC1iYXItZ3JvdXAtaG9yaXpvbnRhbCcsIGNsYXNzTmFtZSksIHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH0sXG4gICAgZGF0YSAmJiBkYXRhLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIEdyb3VwLFxuICAgICAgICB7IGtleTogJ2Jhci1ncm91cC0nICsgaSArICctJyArIHkwKGQpLCB0b3A6IHkwU2NhbGUoeTAoZCkpIH0sXG4gICAgICAgIGtleXMgJiYga2V5cy5tYXAoZnVuY3Rpb24gKGtleSwgaikge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGRba2V5XTtcbiAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChCYXIsIF9leHRlbmRzKHtcbiAgICAgICAgICAgIGtleTogJ2Jhci1ncm91cC1iYXItJyArIGkgKyAnLScgKyBqICsgJy0nICsgdmFsdWUgKyAnLScgKyBrZXksXG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogeTFTY2FsZShrZXkpLFxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoIC0geFNjYWxlKHZhbHVlKSxcbiAgICAgICAgICAgIGhlaWdodDogeTFTY2FsZS5iYW5kd2lkdGgoKSxcbiAgICAgICAgICAgIGZpbGw6IHpTY2FsZShrZXkpLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICB5OiBmb3JtYXQoeTAoZCkpLFxuICAgICAgICAgICAgICBkYXRhOiBkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVzdFByb3BzKSk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pXG4gICk7XG59XG5cbmZ1bmN0aW9uIG9iakhhc01ldGhvZChvYmosIGZ1bmNOYW1lKSB7XG4gIHJldHVybiAhIW9ialtmdW5jTmFtZV0gJiYgdHlwZW9mIG9ialtmdW5jTmFtZV0gPT09ICdmdW5jdGlvbic7XG59XG5cbkJhclN0YWNrLnByb3BUeXBlcyA9IHtcbiAgZGF0YTogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsXG4gIHg6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHhTY2FsZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgeVNjYWxlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB6U2NhbGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIGtleXM6IFByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLFxuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRvcDogUHJvcFR5cGVzLm51bWJlcixcbiAgbGVmdDogUHJvcFR5cGVzLm51bWJlcixcbiAgd2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXG4gIGhlaWdodDogUHJvcFR5cGVzLm51bWJlclxufTtcblxuZnVuY3Rpb24gQmFyU3RhY2soX3JlZikge1xuICB2YXIgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgdG9wID0gX3JlZi50b3AsXG4gICAgICBsZWZ0ID0gX3JlZi5sZWZ0LFxuICAgICAgeCA9IF9yZWYueCxcbiAgICAgIHhTY2FsZSA9IF9yZWYueFNjYWxlLFxuICAgICAgeVNjYWxlID0gX3JlZi55U2NhbGUsXG4gICAgICB6U2NhbGUgPSBfcmVmLnpTY2FsZSxcbiAgICAgIGtleXMgPSBfcmVmLmtleXMsXG4gICAgICB3aWR0aCA9IF9yZWYud2lkdGgsXG4gICAgICBoZWlnaHQgPSBfcmVmLmhlaWdodCxcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnZGF0YScsICdjbGFzc05hbWUnLCAndG9wJywgJ2xlZnQnLCAneCcsICd4U2NhbGUnLCAneVNjYWxlJywgJ3pTY2FsZScsICdrZXlzJywgJ3dpZHRoJywgJ2hlaWdodCddKTtcblxuICB2YXIgc2VyaWVzID0gc3RhY2soKS5rZXlzKGtleXMpKGRhdGEpO1xuICB2YXIgZm9ybWF0ID0geFNjYWxlLnRpY2tGb3JtYXQgPyB4U2NhbGUudGlja0Zvcm1hdCgpIDogZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZDtcbiAgfTtcbiAgdmFyIHhSYW5nZSA9IHhTY2FsZS5yYW5nZSgpO1xuICB2YXIgeERvbWFpbiA9IHhTY2FsZS5kb21haW4oKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgR3JvdXAsXG4gICAgeyBjbGFzc05hbWU6IGN4KCd2eC1iYXItc3RhY2snLCBjbGFzc05hbWUpLCB0b3A6IHRvcCwgbGVmdDogbGVmdCB9LFxuICAgIHNlcmllcyAmJiBzZXJpZXMubWFwKGZ1bmN0aW9uIChzLCBpKSB7XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgR3JvdXAsXG4gICAgICAgIHsga2V5OiAndngtYmFyLXN0YWNrLScgKyBpIH0sXG4gICAgICAgIHMubWFwKGZ1bmN0aW9uIChkLCBpaSkge1xuICAgICAgICAgIHZhciBiYXJIZWlnaHQgPSB5U2NhbGUoZFswXSkgLSB5U2NhbGUoZFsxXSk7XG4gICAgICAgICAgdmFyIGJhcldpZHRoID0gd2lkdGggfHwgKG9iakhhc01ldGhvZCh4U2NhbGUsICdiYW5kd2lkdGgnKSA/IHhTY2FsZS5iYW5kd2lkdGgoKSA6IE1hdGguYWJzKHhSYW5nZVt4UmFuZ2UubGVuZ3RoIC0gMV0gLSB4UmFuZ2VbMF0pIC8geERvbWFpbi5sZW5ndGgpO1xuXG4gICAgICAgICAgdmFyIGJhclggPSBvYmpIYXNNZXRob2QoeFNjYWxlLCAnYmFuZHdpZHRoJykgPyB4U2NhbGUoeChkLmRhdGEpKSA6IHhTY2FsZSh4KGQuZGF0YSkpIC0gYmFyV2lkdGggLyAyO1xuICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEJhciwgX2V4dGVuZHMoe1xuICAgICAgICAgICAga2V5OiAnYmFyLWdyb3VwLWJhci0nICsgaSArICctJyArIGlpICsgJy0nICsgcy5rZXksXG4gICAgICAgICAgICB4OiBiYXJYLFxuICAgICAgICAgICAgeTogeVNjYWxlKGRbMV0pLFxuICAgICAgICAgICAgd2lkdGg6IGJhcldpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBiYXJIZWlnaHQsXG4gICAgICAgICAgICBmaWxsOiB6U2NhbGUocy5rZXkpLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBwYWRkaW5nSW5uZXI6IG9iakhhc01ldGhvZCh4U2NhbGUsICdwYWRkaW5nSW5uZXInKSAmJiB4U2NhbGUucGFkZGluZ0lubmVyKCksXG4gICAgICAgICAgICAgIHBhZGRpbmdPdXRlcjogb2JqSGFzTWV0aG9kKHhTY2FsZSwgJ3BhZGRpbmdPdXRlcicpICYmIHhTY2FsZS5wYWRkaW5nT3V0ZXIoKSxcbiAgICAgICAgICAgICAgc3RlcDogb2JqSGFzTWV0aG9kKHhTY2FsZSwgJ3N0ZXAnKSAmJiB4U2NhbGUuc3RlcCgpLFxuICAgICAgICAgICAgICBrZXk6IHMua2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogZFsxXSxcbiAgICAgICAgICAgICAgaGVpZ2h0OiBiYXJIZWlnaHQsXG4gICAgICAgICAgICAgIHdpZHRoOiBiYXJXaWR0aCxcbiAgICAgICAgICAgICAgeDogeChkLmRhdGEpLFxuICAgICAgICAgICAgICB4Rm9ybWF0dGVkOiBmb3JtYXQoeChkLmRhdGEpKSxcbiAgICAgICAgICAgICAgZGF0YTogZC5kYXRhXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVzdFByb3BzKSk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pXG4gICk7XG59XG5cbkJhclN0YWNrSG9yaXpvbnRhbC5wcm9wVHlwZXMgPSB7XG4gIGRhdGE6IFByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLFxuICB5OiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB4U2NhbGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHlTY2FsZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgelNjYWxlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBrZXlzOiBQcm9wVHlwZXMuYXJyYXkuaXNSZXF1aXJlZCxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICB0b3A6IFByb3BUeXBlcy5udW1iZXIsXG4gIGxlZnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIHdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLFxuICBoZWlnaHQ6IFByb3BUeXBlcy5udW1iZXJcbn07XG5cbmZ1bmN0aW9uIEJhclN0YWNrSG9yaXpvbnRhbChfcmVmKSB7XG4gIHZhciBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICB0b3AgPSBfcmVmLnRvcCxcbiAgICAgIGxlZnQgPSBfcmVmLmxlZnQsXG4gICAgICB5ID0gX3JlZi55LFxuICAgICAgeFNjYWxlID0gX3JlZi54U2NhbGUsXG4gICAgICB5U2NhbGUgPSBfcmVmLnlTY2FsZSxcbiAgICAgIHpTY2FsZSA9IF9yZWYuelNjYWxlLFxuICAgICAga2V5cyA9IF9yZWYua2V5cyxcbiAgICAgIHdpZHRoID0gX3JlZi53aWR0aCxcbiAgICAgIGhlaWdodCA9IF9yZWYuaGVpZ2h0LFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgWydkYXRhJywgJ2NsYXNzTmFtZScsICd0b3AnLCAnbGVmdCcsICd5JywgJ3hTY2FsZScsICd5U2NhbGUnLCAnelNjYWxlJywgJ2tleXMnLCAnd2lkdGgnLCAnaGVpZ2h0J10pO1xuXG4gIHZhciBzZXJpZXMgPSBzdGFjaygpLmtleXMoa2V5cykoZGF0YSk7XG4gIHZhciBmb3JtYXQgPSB5U2NhbGUudGlja0Zvcm1hdCA/IHlTY2FsZS50aWNrRm9ybWF0KCkgOiBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkO1xuICB9O1xuICB2YXIgeVJhbmdlID0geVNjYWxlLnJhbmdlKCk7XG4gIHZhciB5RG9tYWluID0geVNjYWxlLmRvbWFpbigpO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICBHcm91cCxcbiAgICB7IGNsYXNzTmFtZTogY3goJ3Z4LWJhci1zdGFjay1ob3Jpem9udGFsJywgY2xhc3NOYW1lKSwgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfSxcbiAgICBzZXJpZXMgJiYgc2VyaWVzLm1hcChmdW5jdGlvbiAocywgaSkge1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIEdyb3VwLFxuICAgICAgICB7IGtleTogJ3Z4LWJhci1zdGFjay1ob3Jpem9udGFsLScgKyBpIH0sXG4gICAgICAgIHMubWFwKGZ1bmN0aW9uIChkLCBpaSkge1xuICAgICAgICAgIHZhciBiYXJXaWR0aCA9IHhTY2FsZShkWzFdKSAtIHhTY2FsZShkWzBdKTtcbiAgICAgICAgICB2YXIgYmFySGVpZ2h0ID0gd2lkdGggfHwgKG9iakhhc01ldGhvZCh5U2NhbGUsICdiYW5kd2lkdGgnKSA/IHlTY2FsZS5iYW5kd2lkdGgoKSA6IE1hdGguYWJzKHlSYW5nZVt5UmFuZ2UubGVuZ3RoIC0gMV0gLSB5UmFuZ2VbMF0pIC8geURvbWFpbi5sZW5ndGgpO1xuXG4gICAgICAgICAgdmFyIGJhclkgPSBvYmpIYXNNZXRob2QoeVNjYWxlLCAnYmFuZHdpZHRoJykgPyB5U2NhbGUoeShkLmRhdGEpKSA6IHlTY2FsZSh5KGQuZGF0YSkpIC0gYmFySGVpZ2h0IC8gMjtcbiAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChCYXIsIF9leHRlbmRzKHtcbiAgICAgICAgICAgIGtleTogJ2Jhci1ncm91cC1iYXItJyArIGkgKyAnLScgKyBpaSArICctJyArIHMua2V5LFxuICAgICAgICAgICAgeDogeFNjYWxlKGRbMF0pLFxuICAgICAgICAgICAgeTogYmFyWSxcbiAgICAgICAgICAgIHdpZHRoOiBiYXJXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogYmFySGVpZ2h0LFxuICAgICAgICAgICAgZmlsbDogelNjYWxlKHMua2V5KSxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgcGFkZGluZ0lubmVyOiBvYmpIYXNNZXRob2QoeVNjYWxlLCAncGFkZGluZ0lubmVyJykgJiYgeVNjYWxlLnBhZGRpbmdJbm5lcigpLFxuICAgICAgICAgICAgICBwYWRkaW5nT3V0ZXI6IG9iakhhc01ldGhvZCh5U2NhbGUsICdwYWRkaW5nT3V0ZXInKSAmJiB5U2NhbGUucGFkZGluZ091dGVyKCksXG4gICAgICAgICAgICAgIHN0ZXA6IG9iakhhc01ldGhvZCh5U2NhbGUsICdzdGVwJykgJiYgeVNjYWxlLnN0ZXAoKSxcbiAgICAgICAgICAgICAga2V5OiBzLmtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IGRbMF0sXG4gICAgICAgICAgICAgIGhlaWdodDogYmFySGVpZ2h0LFxuICAgICAgICAgICAgICB3aWR0aDogYmFyV2lkdGgsXG4gICAgICAgICAgICAgIHk6IHkoZC5kYXRhKSxcbiAgICAgICAgICAgICAgeUZvcm1hdHRlZDogZm9ybWF0KHkoZC5kYXRhKSksXG4gICAgICAgICAgICAgIGRhdGE6IGQuZGF0YVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHJlc3RQcm9wcykpO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9KVxuICApO1xufVxuXG52YXIgU1RBQ0tfT1JERVJTID0ge1xuICBhc2NlbmRpbmc6IHN0YWNrT3JkZXJBc2NlbmRpbmcsXG4gIGRlc2NlbmRpbmc6IHN0YWNrT3JkZXJEZXNjZW5kaW5nLFxuICBpbnNpZGVvdXQ6IHN0YWNrT3JkZXJJbnNpZGVPdXQsXG4gIG5vbmU6IHN0YWNrT3JkZXJOb25lLFxuICByZXZlcnNlOiBzdGFja09yZGVyUmV2ZXJzZVxufTtcblxudmFyIFNUQUNLX09SREVSX05BTUVTID0gT2JqZWN0LmtleXMoU1RBQ0tfT1JERVJTKTtcblxuZnVuY3Rpb24gc3RhY2tPcmRlcihvcmRlcikge1xuICByZXR1cm4gU1RBQ0tfT1JERVJTW29yZGVyXSB8fCBTVEFDS19PUkRFUlMubm9uZTtcbn1cblxudmFyIFNUQUNLX09GRlNFVFMgPSB7XG4gIGV4cGFuZDogc3RhY2tPZmZzZXRFeHBhbmQsXG4gIGRpdmVyZ2luZzogc3RhY2tPZmZzZXREaXZlcmdpbmcsXG4gIG5vbmU6IHN0YWNrT2Zmc2V0Tm9uZSxcbiAgc2lsaG91ZXR0ZTogc3RhY2tPZmZzZXRTaWxob3VldHRlLFxuICB3aWdnbGU6IHN0YWNrT2Zmc2V0V2lnZ2xlXG59O1xuXG52YXIgU1RBQ0tfT0ZGU0VUX05BTUVTID0gT2JqZWN0LmtleXMoU1RBQ0tfT0ZGU0VUUyk7XG5cbmZ1bmN0aW9uIHN0YWNrT2Zmc2V0KG9mZnNldCkge1xuICByZXR1cm4gU1RBQ0tfT0ZGU0VUU1tvZmZzZXRdIHx8IFNUQUNLX09GRlNFVFMubm9uZTtcbn1cblxuU3RhY2sucHJvcFR5cGVzID0ge1xuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRvcDogUHJvcFR5cGVzLm51bWJlcixcbiAgbGVmdDogUHJvcFR5cGVzLm51bWJlcixcbiAga2V5czogUHJvcFR5cGVzLmFycmF5LFxuICBkYXRhOiBQcm9wVHlwZXMuYXJyYXksXG4gIGN1cnZlOiBQcm9wVHlwZXMuZnVuYyxcbiAgZGVmaW5lZDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5ib29sXSksXG4gIHg6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gIHgwOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm51bWJlcl0pLFxuICB4MTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgeTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgeTA6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gIHkxOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm51bWJlcl0pLFxuICB2YWx1ZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgb3JkZXI6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMuYXJyYXksIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgb2Zmc2V0OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLmFycmF5LCBQcm9wVHlwZXMuc3RyaW5nXSksXG4gIHJlbmRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gIHJldmVyc2U6IFByb3BUeXBlcy5ib29sXG59O1xuXG5mdW5jdGlvbiBTdGFjayhfcmVmKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIF9yZWYkdG9wID0gX3JlZi50b3AsXG4gICAgICB0b3AgPSBfcmVmJHRvcCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkdG9wLFxuICAgICAgX3JlZiRsZWZ0ID0gX3JlZi5sZWZ0LFxuICAgICAgbGVmdCA9IF9yZWYkbGVmdCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkbGVmdCxcbiAgICAgIGtleXMgPSBfcmVmLmtleXMsXG4gICAgICBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgY3VydmUgPSBfcmVmLmN1cnZlLFxuICAgICAgZGVmaW5lZCA9IF9yZWYuZGVmaW5lZCxcbiAgICAgIHggPSBfcmVmLngsXG4gICAgICB4MCA9IF9yZWYueDAsXG4gICAgICB4MSA9IF9yZWYueDEsXG4gICAgICB5MCA9IF9yZWYueTAsXG4gICAgICB5MSA9IF9yZWYueTEsXG4gICAgICB2YWx1ZSA9IF9yZWYudmFsdWUsXG4gICAgICBvcmRlciA9IF9yZWYub3JkZXIsXG4gICAgICBvZmZzZXQgPSBfcmVmLm9mZnNldCxcbiAgICAgIHJlbmRlciA9IF9yZWYucmVuZGVyLFxuICAgICAgX3JlZiRyZXZlcnNlID0gX3JlZi5yZXZlcnNlLFxuICAgICAgcmV2ZXJzZSA9IF9yZWYkcmV2ZXJzZSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJHJldmVyc2UsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2NsYXNzTmFtZScsICd0b3AnLCAnbGVmdCcsICdrZXlzJywgJ2RhdGEnLCAnY3VydmUnLCAnZGVmaW5lZCcsICd4JywgJ3gwJywgJ3gxJywgJ3kwJywgJ3kxJywgJ3ZhbHVlJywgJ29yZGVyJywgJ29mZnNldCcsICdyZW5kZXInLCAncmV2ZXJzZSddKTtcblxuICB2YXIgc3RhY2skJDEgPSBzdGFjaygpO1xuICBpZiAoa2V5cykgc3RhY2skJDEua2V5cyhrZXlzKTtcbiAgaWYgKHZhbHVlKSBzdGFjayQkMS52YWx1ZSh2YWx1ZSk7XG4gIGlmIChvcmRlcikgc3RhY2skJDEub3JkZXIoc3RhY2tPcmRlcihvcmRlcikpO1xuICBpZiAob2Zmc2V0KSBzdGFjayQkMS5vZmZzZXQoc3RhY2tPZmZzZXQob2Zmc2V0KSk7XG5cbiAgdmFyIHBhdGgkJDEgPSBhcmVhKCk7XG4gIGlmICh4KSBwYXRoJCQxLngoeCk7XG4gIGlmICh4MCkgcGF0aCQkMS54MCh4MCk7XG4gIGlmICh4MSkgcGF0aCQkMS54MSh4MSk7XG4gIGlmICh5MCkgcGF0aCQkMS55MCh5MCk7XG4gIGlmICh5MSkgcGF0aCQkMS55MSh5MSk7XG4gIGlmIChjdXJ2ZSkgcGF0aCQkMS5jdXJ2ZShjdXJ2ZSk7XG4gIGlmIChkZWZpbmVkKSBwYXRoJCQxLmRlZmluZWQoZGVmaW5lZCk7XG5cbiAgdmFyIHNlcmllc0RhdGEgPSBzdGFjayQkMShkYXRhKTtcbiAgaWYgKHJldmVyc2UpIHNlcmllc0RhdGEucmV2ZXJzZSgpO1xuXG4gIGlmIChyZW5kZXIpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgIEdyb3VwLFxuICAgICAgeyB0b3A6IHRvcCwgbGVmdDogbGVmdCB9LFxuICAgICAgcmVuZGVyKHsgc2VyaWVzRGF0YTogc2VyaWVzRGF0YSwgcGF0aDogcGF0aCQkMSB9KVxuICAgICk7XG4gIH1cblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICBHcm91cCxcbiAgICB7IHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH0sXG4gICAgc2VyaWVzRGF0YS5tYXAoZnVuY3Rpb24gKHNlcmllcywgaSkge1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCBfZXh0ZW5kcyh7XG4gICAgICAgIGNsYXNzTmFtZTogY3goJ3Z4LXN0YWNrJywgY2xhc3NOYW1lKSxcbiAgICAgICAga2V5OiAnc3RhY2stJyArIGkgKyAnLScgKyAoc2VyaWVzLmtleSB8fCAnJyksXG4gICAgICAgIGQ6IHBhdGgkJDEoc2VyaWVzKVxuICAgICAgfSwgYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcywge1xuICAgICAgICBkYXR1bTogc2VyaWVzW2ldLFxuICAgICAgICBpbmRleDogaSxcbiAgICAgICAgc2VyaWVzOiBzZXJpZXNcbiAgICAgIH0pKSk7XG4gICAgfSlcbiAgKTtcbn1cblxudmFyIGRlZ3JlZXNUb1JhZGlhbnMgPSBmdW5jdGlvbiBkZWdyZWVzVG9SYWRpYW5zKGRlZ3JlZXMpIHtcbiAgcmV0dXJuIE1hdGguUEkgLyAxODAgKiBkZWdyZWVzO1xufTtcblxuZnVuY3Rpb24gcGF0aEhvcml6b250YWxEaWFnb25hbChfcmVmKSB7XG4gIHZhciBzb3VyY2UgPSBfcmVmLnNvdXJjZSxcbiAgICAgIHRhcmdldCA9IF9yZWYudGFyZ2V0LFxuICAgICAgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIGxpbmsgPSBsaW5rSG9yaXpvbnRhbCgpO1xuICAgIGxpbmsueCh4KTtcbiAgICBsaW5rLnkoeSk7XG4gICAgbGluay5zb3VyY2Uoc291cmNlKTtcbiAgICBsaW5rLnRhcmdldCh0YXJnZXQpO1xuICAgIHJldHVybiBsaW5rKGRhdGEpO1xuICB9O1xufVxuXG5MaW5rSG9yaXpvbnRhbC5wcm9wVHlwZXMgPSB7XG4gIGlubmVyUmVmOiBQcm9wVHlwZXMuZnVuYyxcbiAgeDogUHJvcFR5cGVzLmZ1bmMsXG4gIHk6IFByb3BUeXBlcy5mdW5jLFxuICBzb3VyY2U6IFByb3BUeXBlcy5mdW5jLFxuICB0YXJnZXQ6IFByb3BUeXBlcy5mdW5jLFxuICBwYXRoOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuZnVuY3Rpb24gTGlua0hvcml6b250YWwoX3JlZjIpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYyLmNsYXNzTmFtZSxcbiAgICAgIGlubmVyUmVmID0gX3JlZjIuaW5uZXJSZWYsXG4gICAgICBkYXRhID0gX3JlZjIuZGF0YSxcbiAgICAgIHBhdGgkJDEgPSBfcmVmMi5wYXRoLFxuICAgICAgX3JlZjIkeCA9IF9yZWYyLngsXG4gICAgICB4ID0gX3JlZjIkeCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC55O1xuICB9IDogX3JlZjIkeCxcbiAgICAgIF9yZWYyJHkgPSBfcmVmMi55LFxuICAgICAgeSA9IF9yZWYyJHkgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueDtcbiAgfSA6IF9yZWYyJHksXG4gICAgICBfcmVmMiRzb3VyY2UgPSBfcmVmMi5zb3VyY2UsXG4gICAgICBzb3VyY2UgPSBfcmVmMiRzb3VyY2UgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQuc291cmNlO1xuICB9IDogX3JlZjIkc291cmNlLFxuICAgICAgX3JlZjIkdGFyZ2V0ID0gX3JlZjIudGFyZ2V0LFxuICAgICAgdGFyZ2V0ID0gX3JlZjIkdGFyZ2V0ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnRhcmdldDtcbiAgfSA6IF9yZWYyJHRhcmdldCxcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYyLCBbJ2NsYXNzTmFtZScsICdpbm5lclJlZicsICdkYXRhJywgJ3BhdGgnLCAneCcsICd5JywgJ3NvdXJjZScsICd0YXJnZXQnXSk7XG5cbiAgcGF0aCQkMSA9IHBhdGgkJDEgfHwgcGF0aEhvcml6b250YWxEaWFnb25hbCh7IHNvdXJjZTogc291cmNlLCB0YXJnZXQ6IHRhcmdldCwgeDogeCwgeTogeSB9KTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBpbm5lclJlZixcbiAgICBjbGFzc05hbWU6IGN4KCd2eC1saW5rLWhvcml6b250YWwnLCBjbGFzc05hbWUpLFxuICAgIGQ6IHBhdGgkJDEoZGF0YSlcbiAgfSwgYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcywgZGF0YSkpKTtcbn1cblxuZnVuY3Rpb24gcGF0aFZlcnRpY2FsRGlhZ29uYWwoX3JlZikge1xuICB2YXIgc291cmNlID0gX3JlZi5zb3VyY2UsXG4gICAgICB0YXJnZXQgPSBfcmVmLnRhcmdldCxcbiAgICAgIHggPSBfcmVmLngsXG4gICAgICB5ID0gX3JlZi55O1xuXG4gIHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBsaW5rID0gbGlua1ZlcnRpY2FsKCk7XG4gICAgbGluay54KHgpO1xuICAgIGxpbmsueSh5KTtcbiAgICBsaW5rLnNvdXJjZShzb3VyY2UpO1xuICAgIGxpbmsudGFyZ2V0KHRhcmdldCk7XG4gICAgcmV0dXJuIGxpbmsoZGF0YSk7XG4gIH07XG59XG5cbkxpbmtWZXJ0aWNhbC5wcm9wVHlwZXMgPSB7XG4gIGlubmVyUmVmOiBQcm9wVHlwZXMuZnVuYyxcbiAgeDogUHJvcFR5cGVzLmZ1bmMsXG4gIHk6IFByb3BUeXBlcy5mdW5jLFxuICBzb3VyY2U6IFByb3BUeXBlcy5mdW5jLFxuICB0YXJnZXQ6IFByb3BUeXBlcy5mdW5jLFxuICBwYXRoOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuZnVuY3Rpb24gTGlua1ZlcnRpY2FsKF9yZWYyKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmMi5jbGFzc05hbWUsXG4gICAgICBpbm5lclJlZiA9IF9yZWYyLmlubmVyUmVmLFxuICAgICAgZGF0YSA9IF9yZWYyLmRhdGEsXG4gICAgICBwYXRoJCQxID0gX3JlZjIucGF0aCxcbiAgICAgIF9yZWYyJHggPSBfcmVmMi54LFxuICAgICAgeCA9IF9yZWYyJHggPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueDtcbiAgfSA6IF9yZWYyJHgsXG4gICAgICBfcmVmMiR5ID0gX3JlZjIueSxcbiAgICAgIHkgPSBfcmVmMiR5ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnk7XG4gIH0gOiBfcmVmMiR5LFxuICAgICAgX3JlZjIkc291cmNlID0gX3JlZjIuc291cmNlLFxuICAgICAgc291cmNlID0gX3JlZjIkc291cmNlID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnNvdXJjZTtcbiAgfSA6IF9yZWYyJHNvdXJjZSxcbiAgICAgIF9yZWYyJHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgIHRhcmdldCA9IF9yZWYyJHRhcmdldCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC50YXJnZXQ7XG4gIH0gOiBfcmVmMiR0YXJnZXQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgWydjbGFzc05hbWUnLCAnaW5uZXJSZWYnLCAnZGF0YScsICdwYXRoJywgJ3gnLCAneScsICdzb3VyY2UnLCAndGFyZ2V0J10pO1xuXG4gIHBhdGgkJDEgPSBwYXRoJCQxIHx8IHBhdGhWZXJ0aWNhbERpYWdvbmFsKHsgc291cmNlOiBzb3VyY2UsIHRhcmdldDogdGFyZ2V0LCB4OiB4LCB5OiB5IH0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgncGF0aCcsIF9leHRlbmRzKHtcbiAgICByZWY6IGlubmVyUmVmLFxuICAgIGNsYXNzTmFtZTogY3goJ3Z4LWxpbmstdmVydGljYWwnLCBjbGFzc05hbWUpLFxuICAgIGQ6IHBhdGgkJDEoZGF0YSlcbiAgfSwgYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcywgZGF0YSkpKTtcbn1cblxuZnVuY3Rpb24gcGF0aFJhZGlhbERpYWdvbmFsKF9yZWYpIHtcbiAgdmFyIHNvdXJjZSA9IF9yZWYuc291cmNlLFxuICAgICAgdGFyZ2V0ID0gX3JlZi50YXJnZXQsXG4gICAgICBhbmdsZSA9IF9yZWYuYW5nbGUsXG4gICAgICByYWRpdXMgPSBfcmVmLnJhZGl1cztcblxuICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgbGluayA9IGxpbmtSYWRpYWwoKTtcbiAgICBsaW5rLmFuZ2xlKGFuZ2xlKTtcbiAgICBsaW5rLnJhZGl1cyhyYWRpdXMpO1xuICAgIGxpbmsuc291cmNlKHNvdXJjZSk7XG4gICAgbGluay50YXJnZXQodGFyZ2V0KTtcbiAgICByZXR1cm4gbGluayhkYXRhKTtcbiAgfTtcbn1cblxuTGlua1JhZGlhbC5wcm9wVHlwZXMgPSB7XG4gIGlubmVyUmVmOiBQcm9wVHlwZXMuZnVuYyxcbiAgYW5nbGU6IFByb3BUeXBlcy5mdW5jLFxuICByYWRpdXM6IFByb3BUeXBlcy5mdW5jLFxuICBzb3VyY2U6IFByb3BUeXBlcy5mdW5jLFxuICB0YXJnZXQ6IFByb3BUeXBlcy5mdW5jLFxuICBwYXRoOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuZnVuY3Rpb24gTGlua1JhZGlhbChfcmVmMikge1xuICB2YXIgY2xhc3NOYW1lID0gX3JlZjIuY2xhc3NOYW1lLFxuICAgICAgaW5uZXJSZWYgPSBfcmVmMi5pbm5lclJlZixcbiAgICAgIGRhdGEgPSBfcmVmMi5kYXRhLFxuICAgICAgcGF0aCQkMSA9IF9yZWYyLnBhdGgsXG4gICAgICBfcmVmMiRhbmdsZSA9IF9yZWYyLmFuZ2xlLFxuICAgICAgYW5nbGUgPSBfcmVmMiRhbmdsZSA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC54O1xuICB9IDogX3JlZjIkYW5nbGUsXG4gICAgICBfcmVmMiRyYWRpdXMgPSBfcmVmMi5yYWRpdXMsXG4gICAgICByYWRpdXMgPSBfcmVmMiRyYWRpdXMgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueTtcbiAgfSA6IF9yZWYyJHJhZGl1cyxcbiAgICAgIF9yZWYyJHNvdXJjZSA9IF9yZWYyLnNvdXJjZSxcbiAgICAgIHNvdXJjZSA9IF9yZWYyJHNvdXJjZSA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC5zb3VyY2U7XG4gIH0gOiBfcmVmMiRzb3VyY2UsXG4gICAgICBfcmVmMiR0YXJnZXQgPSBfcmVmMi50YXJnZXQsXG4gICAgICB0YXJnZXQgPSBfcmVmMiR0YXJnZXQgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQudGFyZ2V0O1xuICB9IDogX3JlZjIkdGFyZ2V0LFxuICAgICAgcmVzdFByb3BzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjIsIFsnY2xhc3NOYW1lJywgJ2lubmVyUmVmJywgJ2RhdGEnLCAncGF0aCcsICdhbmdsZScsICdyYWRpdXMnLCAnc291cmNlJywgJ3RhcmdldCddKTtcblxuICBwYXRoJCQxID0gcGF0aCQkMSB8fCBwYXRoUmFkaWFsRGlhZ29uYWwoeyBzb3VyY2U6IHNvdXJjZSwgdGFyZ2V0OiB0YXJnZXQsIGFuZ2xlOiBhbmdsZSwgcmFkaXVzOiByYWRpdXMgfSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgIHJlZjogaW5uZXJSZWYsXG4gICAgY2xhc3NOYW1lOiBjeCgndngtbGluay1yYWRpdXMnLCBjbGFzc05hbWUpLFxuICAgIGQ6IHBhdGgkJDEoZGF0YSlcbiAgfSwgYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcywgZGF0YSkpKTtcbn1cblxuZnVuY3Rpb24gcGF0aEhvcml6b250YWxDdXJ2ZShfcmVmKSB7XG4gIHZhciBzb3VyY2UgPSBfcmVmLnNvdXJjZSxcbiAgICAgIHRhcmdldCA9IF9yZWYudGFyZ2V0LFxuICAgICAgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnksXG4gICAgICBwZXJjZW50ID0gX3JlZi5wZXJjZW50O1xuXG4gIHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBzb3VyY2VEYXRhID0gc291cmNlKGRhdGEpO1xuICAgIHZhciB0YXJnZXREYXRhID0gdGFyZ2V0KGRhdGEpO1xuXG4gICAgdmFyIHN4ID0geChzb3VyY2VEYXRhKTtcbiAgICB2YXIgc3kgPSB5KHNvdXJjZURhdGEpO1xuICAgIHZhciB0eCA9IHgodGFyZ2V0RGF0YSk7XG4gICAgdmFyIHR5ID0geSh0YXJnZXREYXRhKTtcblxuICAgIHZhciBkeCA9IHR4IC0gc3g7XG4gICAgdmFyIGR5ID0gdHkgLSBzeTtcbiAgICB2YXIgaXggPSBwZXJjZW50ICogKGR4ICsgZHkpO1xuICAgIHZhciBpeSA9IHBlcmNlbnQgKiAoZHkgLSBkeCk7XG5cbiAgICB2YXIgcGF0aCQkMSA9IHBhdGgoKTtcbiAgICBwYXRoJCQxLm1vdmVUbyhzeCwgc3kpO1xuICAgIHBhdGgkJDEuYmV6aWVyQ3VydmVUbyhzeCArIGl4LCBzeSArIGl5LCB0eCArIGl5LCB0eSAtIGl4LCB0eCwgdHkpO1xuXG4gICAgcmV0dXJuIHBhdGgkJDEudG9TdHJpbmcoKTtcbiAgfTtcbn1cblxuTGlua0hvcml6b250YWxDdXJ2ZS5wcm9wVHlwZXMgPSB7XG4gIGlubmVyUmVmOiBQcm9wVHlwZXMuZnVuYyxcbiAgcGVyY2VudDogUHJvcFR5cGVzLm51bWJlcixcbiAgeDogUHJvcFR5cGVzLmZ1bmMsXG4gIHk6IFByb3BUeXBlcy5mdW5jLFxuICBzb3VyY2U6IFByb3BUeXBlcy5mdW5jLFxuICB0YXJnZXQ6IFByb3BUeXBlcy5mdW5jLFxuICBwYXRoOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuZnVuY3Rpb24gTGlua0hvcml6b250YWxDdXJ2ZShfcmVmMikge1xuICB2YXIgY2xhc3NOYW1lID0gX3JlZjIuY2xhc3NOYW1lLFxuICAgICAgaW5uZXJSZWYgPSBfcmVmMi5pbm5lclJlZixcbiAgICAgIGRhdGEgPSBfcmVmMi5kYXRhLFxuICAgICAgcGF0aCQkMSA9IF9yZWYyLnBhdGgsXG4gICAgICBfcmVmMiR4ID0gX3JlZjIueCxcbiAgICAgIHggPSBfcmVmMiR4ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnk7XG4gIH0gOiBfcmVmMiR4LFxuICAgICAgX3JlZjIkeSA9IF9yZWYyLnksXG4gICAgICB5ID0gX3JlZjIkeSA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC54O1xuICB9IDogX3JlZjIkeSxcbiAgICAgIF9yZWYyJHNvdXJjZSA9IF9yZWYyLnNvdXJjZSxcbiAgICAgIHNvdXJjZSA9IF9yZWYyJHNvdXJjZSA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC5zb3VyY2U7XG4gIH0gOiBfcmVmMiRzb3VyY2UsXG4gICAgICBfcmVmMiR0YXJnZXQgPSBfcmVmMi50YXJnZXQsXG4gICAgICB0YXJnZXQgPSBfcmVmMiR0YXJnZXQgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQudGFyZ2V0O1xuICB9IDogX3JlZjIkdGFyZ2V0LFxuICAgICAgX3JlZjIkcGVyY2VudCA9IF9yZWYyLnBlcmNlbnQsXG4gICAgICBwZXJjZW50ID0gX3JlZjIkcGVyY2VudCA9PT0gdW5kZWZpbmVkID8gMC4yIDogX3JlZjIkcGVyY2VudCxcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYyLCBbJ2NsYXNzTmFtZScsICdpbm5lclJlZicsICdkYXRhJywgJ3BhdGgnLCAneCcsICd5JywgJ3NvdXJjZScsICd0YXJnZXQnLCAncGVyY2VudCddKTtcblxuICBwYXRoJCQxID0gcGF0aCQkMSB8fCBwYXRoSG9yaXpvbnRhbEN1cnZlKHsgc291cmNlOiBzb3VyY2UsIHRhcmdldDogdGFyZ2V0LCB4OiB4LCB5OiB5LCBwZXJjZW50OiBwZXJjZW50IH0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgncGF0aCcsIF9leHRlbmRzKHtcbiAgICByZWY6IGlubmVyUmVmLFxuICAgIGNsYXNzTmFtZTogY3goJ3Z4LWxpbmsnLCBjbGFzc05hbWUpLFxuICAgIGQ6IHBhdGgkJDEoZGF0YSlcbiAgfSwgYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcywgZGF0YSkpKTtcbn1cblxuZnVuY3Rpb24gcGF0aFZlcnRpY2FsQ3VydmUoX3JlZikge1xuICB2YXIgc291cmNlID0gX3JlZi5zb3VyY2UsXG4gICAgICB0YXJnZXQgPSBfcmVmLnRhcmdldCxcbiAgICAgIHggPSBfcmVmLngsXG4gICAgICB5ID0gX3JlZi55LFxuICAgICAgcGVyY2VudCA9IF9yZWYucGVyY2VudDtcblxuICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgc291cmNlRGF0YSA9IHNvdXJjZShkYXRhKTtcbiAgICB2YXIgdGFyZ2V0RGF0YSA9IHRhcmdldChkYXRhKTtcblxuICAgIHZhciBzeCA9IHgoc291cmNlRGF0YSk7XG4gICAgdmFyIHN5ID0geShzb3VyY2VEYXRhKTtcbiAgICB2YXIgdHggPSB4KHRhcmdldERhdGEpO1xuICAgIHZhciB0eSA9IHkodGFyZ2V0RGF0YSk7XG5cbiAgICB2YXIgZHggPSB0eCAtIHN4O1xuICAgIHZhciBkeSA9IHR5IC0gc3k7XG4gICAgdmFyIGl4ID0gcGVyY2VudCAqIChkeCArIGR5KTtcbiAgICB2YXIgaXkgPSBwZXJjZW50ICogKGR5IC0gZHgpO1xuXG4gICAgdmFyIHBhdGgkJDEgPSBwYXRoKCk7XG4gICAgcGF0aCQkMS5tb3ZlVG8oc3gsIHN5KTtcbiAgICBwYXRoJCQxLmJlemllckN1cnZlVG8oc3ggKyBpeCwgc3kgKyBpeSwgdHggKyBpeSwgdHkgLSBpeCwgdHgsIHR5KTtcblxuICAgIHJldHVybiBwYXRoJCQxLnRvU3RyaW5nKCk7XG4gIH07XG59XG5cbkxpbmtWZXJ0aWNhbEN1cnZlLnByb3BUeXBlcyA9IHtcbiAgaW5uZXJSZWY6IFByb3BUeXBlcy5mdW5jLFxuICBwZXJjZW50OiBQcm9wVHlwZXMubnVtYmVyLFxuICB4OiBQcm9wVHlwZXMuZnVuYyxcbiAgeTogUHJvcFR5cGVzLmZ1bmMsXG4gIHNvdXJjZTogUHJvcFR5cGVzLmZ1bmMsXG4gIHRhcmdldDogUHJvcFR5cGVzLmZ1bmMsXG4gIHBhdGg6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5mdW5jdGlvbiBMaW5rVmVydGljYWxDdXJ2ZShfcmVmMikge1xuICB2YXIgY2xhc3NOYW1lID0gX3JlZjIuY2xhc3NOYW1lLFxuICAgICAgaW5uZXJSZWYgPSBfcmVmMi5pbm5lclJlZixcbiAgICAgIGRhdGEgPSBfcmVmMi5kYXRhLFxuICAgICAgcGF0aCQkMSA9IF9yZWYyLnBhdGgsXG4gICAgICBfcmVmMiR4ID0gX3JlZjIueCxcbiAgICAgIHggPSBfcmVmMiR4ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLng7XG4gIH0gOiBfcmVmMiR4LFxuICAgICAgX3JlZjIkeSA9IF9yZWYyLnksXG4gICAgICB5ID0gX3JlZjIkeSA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC55O1xuICB9IDogX3JlZjIkeSxcbiAgICAgIF9yZWYyJHNvdXJjZSA9IF9yZWYyLnNvdXJjZSxcbiAgICAgIHNvdXJjZSA9IF9yZWYyJHNvdXJjZSA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC5zb3VyY2U7XG4gIH0gOiBfcmVmMiRzb3VyY2UsXG4gICAgICBfcmVmMiR0YXJnZXQgPSBfcmVmMi50YXJnZXQsXG4gICAgICB0YXJnZXQgPSBfcmVmMiR0YXJnZXQgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQudGFyZ2V0O1xuICB9IDogX3JlZjIkdGFyZ2V0LFxuICAgICAgX3JlZjIkcGVyY2VudCA9IF9yZWYyLnBlcmNlbnQsXG4gICAgICBwZXJjZW50ID0gX3JlZjIkcGVyY2VudCA9PT0gdW5kZWZpbmVkID8gMC4yIDogX3JlZjIkcGVyY2VudCxcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYyLCBbJ2NsYXNzTmFtZScsICdpbm5lclJlZicsICdkYXRhJywgJ3BhdGgnLCAneCcsICd5JywgJ3NvdXJjZScsICd0YXJnZXQnLCAncGVyY2VudCddKTtcblxuICBwYXRoJCQxID0gcGF0aCQkMSB8fCBwYXRoVmVydGljYWxDdXJ2ZSh7IHNvdXJjZTogc291cmNlLCB0YXJnZXQ6IHRhcmdldCwgeDogeCwgeTogeSwgcGVyY2VudDogcGVyY2VudCB9KTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBpbm5lclJlZixcbiAgICBjbGFzc05hbWU6IGN4KCd2eC1saW5rJywgY2xhc3NOYW1lKSxcbiAgICBkOiBwYXRoJCQxKGRhdGEpXG4gIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSk7XG59XG5cbmZ1bmN0aW9uIHBhdGhSYWRpYWxDdXJ2ZShfcmVmKSB7XG4gIHZhciBzb3VyY2UgPSBfcmVmLnNvdXJjZSxcbiAgICAgIHRhcmdldCA9IF9yZWYudGFyZ2V0LFxuICAgICAgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnksXG4gICAgICBwZXJjZW50ID0gX3JlZi5wZXJjZW50O1xuXG4gIHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBzb3VyY2VEYXRhID0gc291cmNlKGRhdGEpO1xuICAgIHZhciB0YXJnZXREYXRhID0gdGFyZ2V0KGRhdGEpO1xuXG4gICAgdmFyIHNhID0geChzb3VyY2VEYXRhKSAtIE1hdGguUEkgLyAyO1xuICAgIHZhciBzciA9IHkoc291cmNlRGF0YSk7XG4gICAgdmFyIHRhID0geCh0YXJnZXREYXRhKSAtIE1hdGguUEkgLyAyO1xuICAgIHZhciB0ciA9IHkodGFyZ2V0RGF0YSk7XG5cbiAgICB2YXIgc2MgPSBNYXRoLmNvcyhzYSk7XG4gICAgdmFyIHNzID0gTWF0aC5zaW4oc2EpO1xuICAgIHZhciB0YyA9IE1hdGguY29zKHRhKTtcbiAgICB2YXIgdHMgPSBNYXRoLnNpbih0YSk7XG5cbiAgICB2YXIgc3ggPSBzciAqIHNjO1xuICAgIHZhciBzeSA9IHNyICogc3M7XG4gICAgdmFyIHR4ID0gdHIgKiB0YztcbiAgICB2YXIgdHkgPSB0ciAqIHRzO1xuXG4gICAgdmFyIGR4ID0gdHggLSBzeDtcbiAgICB2YXIgZHkgPSB0eSAtIHN5O1xuICAgIHZhciBpeCA9IHBlcmNlbnQgKiAoZHggKyBkeSk7XG4gICAgdmFyIGl5ID0gcGVyY2VudCAqIChkeSAtIGR4KTtcblxuICAgIHZhciBwYXRoJCQxID0gcGF0aCgpO1xuICAgIHBhdGgkJDEubW92ZVRvKHN4LCBzeSk7XG4gICAgcGF0aCQkMS5iZXppZXJDdXJ2ZVRvKHN4ICsgaXgsIHN5ICsgaXksIHR4ICsgaXksIHR5IC0gaXgsIHR4LCB0eSk7XG5cbiAgICByZXR1cm4gcGF0aCQkMS50b1N0cmluZygpO1xuICB9O1xufVxuXG5MaW5rUmFkaWFsQ3VydmUucHJvcFR5cGVzID0ge1xuICBpbm5lclJlZjogUHJvcFR5cGVzLmZ1bmMsXG4gIHBlcmNlbnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIHg6IFByb3BUeXBlcy5mdW5jLFxuICB5OiBQcm9wVHlwZXMuZnVuYyxcbiAgc291cmNlOiBQcm9wVHlwZXMuZnVuYyxcbiAgdGFyZ2V0OiBQcm9wVHlwZXMuZnVuYyxcbiAgcGF0aDogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIExpbmtSYWRpYWxDdXJ2ZShfcmVmMikge1xuICB2YXIgY2xhc3NOYW1lID0gX3JlZjIuY2xhc3NOYW1lLFxuICAgICAgaW5uZXJSZWYgPSBfcmVmMi5pbm5lclJlZixcbiAgICAgIGRhdGEgPSBfcmVmMi5kYXRhLFxuICAgICAgcGF0aCQkMSA9IF9yZWYyLnBhdGgsXG4gICAgICBfcmVmMiR4ID0gX3JlZjIueCxcbiAgICAgIHggPSBfcmVmMiR4ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLng7XG4gIH0gOiBfcmVmMiR4LFxuICAgICAgX3JlZjIkeSA9IF9yZWYyLnksXG4gICAgICB5ID0gX3JlZjIkeSA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC55O1xuICB9IDogX3JlZjIkeSxcbiAgICAgIF9yZWYyJHNvdXJjZSA9IF9yZWYyLnNvdXJjZSxcbiAgICAgIHNvdXJjZSA9IF9yZWYyJHNvdXJjZSA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC5zb3VyY2U7XG4gIH0gOiBfcmVmMiRzb3VyY2UsXG4gICAgICBfcmVmMiR0YXJnZXQgPSBfcmVmMi50YXJnZXQsXG4gICAgICB0YXJnZXQgPSBfcmVmMiR0YXJnZXQgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQudGFyZ2V0O1xuICB9IDogX3JlZjIkdGFyZ2V0LFxuICAgICAgX3JlZjIkcGVyY2VudCA9IF9yZWYyLnBlcmNlbnQsXG4gICAgICBwZXJjZW50ID0gX3JlZjIkcGVyY2VudCA9PT0gdW5kZWZpbmVkID8gMC4yIDogX3JlZjIkcGVyY2VudCxcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYyLCBbJ2NsYXNzTmFtZScsICdpbm5lclJlZicsICdkYXRhJywgJ3BhdGgnLCAneCcsICd5JywgJ3NvdXJjZScsICd0YXJnZXQnLCAncGVyY2VudCddKTtcblxuICBwYXRoJCQxID0gcGF0aCQkMSB8fCBwYXRoUmFkaWFsQ3VydmUoeyBzb3VyY2U6IHNvdXJjZSwgdGFyZ2V0OiB0YXJnZXQsIHg6IHgsIHk6IHksIHBlcmNlbnQ6IHBlcmNlbnQgfSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgIHJlZjogaW5uZXJSZWYsXG4gICAgY2xhc3NOYW1lOiBjeCgndngtbGluaycsIGNsYXNzTmFtZSksXG4gICAgZDogcGF0aCQkMShkYXRhKVxuICB9LCBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzLCBkYXRhKSkpO1xufVxuXG5mdW5jdGlvbiBwYXRoSG9yaXpvbnRhbExpbmUoX3JlZikge1xuICB2YXIgc291cmNlID0gX3JlZi5zb3VyY2UsXG4gICAgICB0YXJnZXQgPSBfcmVmLnRhcmdldCxcbiAgICAgIHggPSBfcmVmLngsXG4gICAgICB5ID0gX3JlZi55O1xuXG4gIHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBzb3VyY2VEYXRhID0gc291cmNlKGRhdGEpO1xuICAgIHZhciB0YXJnZXREYXRhID0gdGFyZ2V0KGRhdGEpO1xuXG4gICAgdmFyIHN4ID0geChzb3VyY2VEYXRhKTtcbiAgICB2YXIgc3kgPSB5KHNvdXJjZURhdGEpO1xuICAgIHZhciB0eCA9IHgodGFyZ2V0RGF0YSk7XG4gICAgdmFyIHR5ID0geSh0YXJnZXREYXRhKTtcblxuICAgIHZhciBwYXRoJCQxID0gcGF0aCgpO1xuICAgIHBhdGgkJDEubW92ZVRvKHN4LCBzeSk7XG4gICAgcGF0aCQkMS5saW5lVG8odHgsIHR5KTtcblxuICAgIHJldHVybiBwYXRoJCQxLnRvU3RyaW5nKCk7XG4gIH07XG59XG5cbkxpbmtIb3Jpem9udGFsTGluZS5wcm9wVHlwZXMgPSB7XG4gIGlubmVyUmVmOiBQcm9wVHlwZXMuZnVuYyxcbiAgcGF0aDogUHJvcFR5cGVzLmZ1bmMsXG4gIHg6IFByb3BUeXBlcy5mdW5jLFxuICB5OiBQcm9wVHlwZXMuZnVuYyxcbiAgc291cmNlOiBQcm9wVHlwZXMuZnVuYyxcbiAgdGFyZ2V0OiBQcm9wVHlwZXMuZnVuY1xufTtcblxuZnVuY3Rpb24gTGlua0hvcml6b250YWxMaW5lKF9yZWYyKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmMi5jbGFzc05hbWUsXG4gICAgICBpbm5lclJlZiA9IF9yZWYyLmlubmVyUmVmLFxuICAgICAgZGF0YSA9IF9yZWYyLmRhdGEsXG4gICAgICBwYXRoJCQxID0gX3JlZjIucGF0aCxcbiAgICAgIF9yZWYyJHggPSBfcmVmMi54LFxuICAgICAgeCA9IF9yZWYyJHggPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueTtcbiAgfSA6IF9yZWYyJHgsXG4gICAgICBfcmVmMiR5ID0gX3JlZjIueSxcbiAgICAgIHkgPSBfcmVmMiR5ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLng7XG4gIH0gOiBfcmVmMiR5LFxuICAgICAgX3JlZjIkc291cmNlID0gX3JlZjIuc291cmNlLFxuICAgICAgc291cmNlID0gX3JlZjIkc291cmNlID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnNvdXJjZTtcbiAgfSA6IF9yZWYyJHNvdXJjZSxcbiAgICAgIF9yZWYyJHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgIHRhcmdldCA9IF9yZWYyJHRhcmdldCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC50YXJnZXQ7XG4gIH0gOiBfcmVmMiR0YXJnZXQsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgWydjbGFzc05hbWUnLCAnaW5uZXJSZWYnLCAnZGF0YScsICdwYXRoJywgJ3gnLCAneScsICdzb3VyY2UnLCAndGFyZ2V0J10pO1xuXG4gIHBhdGgkJDEgPSBwYXRoJCQxIHx8IHBhdGhIb3Jpem9udGFsTGluZSh7IHNvdXJjZTogc291cmNlLCB0YXJnZXQ6IHRhcmdldCwgeDogeCwgeTogeSB9KTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBpbm5lclJlZixcbiAgICBjbGFzc05hbWU6IGN4KCd2eC1saW5rJywgY2xhc3NOYW1lKSxcbiAgICBkOiBwYXRoJCQxKGRhdGEpXG4gIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSk7XG59XG5cbmZ1bmN0aW9uIHBhdGhWZXJ0aWNhbExpbmUoX3JlZikge1xuICB2YXIgc291cmNlID0gX3JlZi5zb3VyY2UsXG4gICAgICB0YXJnZXQgPSBfcmVmLnRhcmdldCxcbiAgICAgIHggPSBfcmVmLngsXG4gICAgICB5ID0gX3JlZi55O1xuXG4gIHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBzb3VyY2VEYXRhID0gc291cmNlKGRhdGEpO1xuICAgIHZhciB0YXJnZXREYXRhID0gdGFyZ2V0KGRhdGEpO1xuXG4gICAgdmFyIHN4ID0geChzb3VyY2VEYXRhKTtcbiAgICB2YXIgc3kgPSB5KHNvdXJjZURhdGEpO1xuICAgIHZhciB0eCA9IHgodGFyZ2V0RGF0YSk7XG4gICAgdmFyIHR5ID0geSh0YXJnZXREYXRhKTtcblxuICAgIHZhciBwYXRoJCQxID0gcGF0aCgpO1xuICAgIHBhdGgkJDEubW92ZVRvKHN4LCBzeSk7XG4gICAgcGF0aCQkMS5saW5lVG8odHgsIHR5KTtcblxuICAgIHJldHVybiBwYXRoJCQxLnRvU3RyaW5nKCk7XG4gIH07XG59XG5cbkxpbmtWZXJ0aWNhbExpbmUucHJvcFR5cGVzID0ge1xuICBpbm5lclJlZjogUHJvcFR5cGVzLmZ1bmMsXG4gIHBhdGg6IFByb3BUeXBlcy5mdW5jLFxuICB4OiBQcm9wVHlwZXMuZnVuYyxcbiAgeTogUHJvcFR5cGVzLmZ1bmMsXG4gIHNvdXJjZTogUHJvcFR5cGVzLmZ1bmMsXG4gIHRhcmdldDogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIExpbmtWZXJ0aWNhbExpbmUoX3JlZjIpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYyLmNsYXNzTmFtZSxcbiAgICAgIGlubmVyUmVmID0gX3JlZjIuaW5uZXJSZWYsXG4gICAgICBkYXRhID0gX3JlZjIuZGF0YSxcbiAgICAgIHBhdGgkJDEgPSBfcmVmMi5wYXRoLFxuICAgICAgX3JlZjIkeCA9IF9yZWYyLngsXG4gICAgICB4ID0gX3JlZjIkeCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC54O1xuICB9IDogX3JlZjIkeCxcbiAgICAgIF9yZWYyJHkgPSBfcmVmMi55LFxuICAgICAgeSA9IF9yZWYyJHkgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueTtcbiAgfSA6IF9yZWYyJHksXG4gICAgICBfcmVmMiRzb3VyY2UgPSBfcmVmMi5zb3VyY2UsXG4gICAgICBzb3VyY2UgPSBfcmVmMiRzb3VyY2UgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQuc291cmNlO1xuICB9IDogX3JlZjIkc291cmNlLFxuICAgICAgX3JlZjIkdGFyZ2V0ID0gX3JlZjIudGFyZ2V0LFxuICAgICAgdGFyZ2V0ID0gX3JlZjIkdGFyZ2V0ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnRhcmdldDtcbiAgfSA6IF9yZWYyJHRhcmdldCxcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYyLCBbJ2NsYXNzTmFtZScsICdpbm5lclJlZicsICdkYXRhJywgJ3BhdGgnLCAneCcsICd5JywgJ3NvdXJjZScsICd0YXJnZXQnXSk7XG5cbiAgcGF0aCQkMSA9IHBhdGgkJDEgfHwgcGF0aFZlcnRpY2FsTGluZSh7IHNvdXJjZTogc291cmNlLCB0YXJnZXQ6IHRhcmdldCwgeDogeCwgeTogeSB9KTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBpbm5lclJlZixcbiAgICBjbGFzc05hbWU6IGN4KCd2eC1saW5rJywgY2xhc3NOYW1lKSxcbiAgICBkOiBwYXRoJCQxKGRhdGEpXG4gIH0sIGFkZGl0aW9uYWxQcm9wcyhyZXN0UHJvcHMsIGRhdGEpKSk7XG59XG5cbmZ1bmN0aW9uIHBhdGhSYWRpYWxMaW5lKF9yZWYpIHtcbiAgdmFyIHNvdXJjZSA9IF9yZWYuc291cmNlLFxuICAgICAgdGFyZ2V0ID0gX3JlZi50YXJnZXQsXG4gICAgICB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueTtcblxuICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgc291cmNlRGF0YSA9IHNvdXJjZShkYXRhKTtcbiAgICB2YXIgdGFyZ2V0RGF0YSA9IHRhcmdldChkYXRhKTtcblxuICAgIHZhciBzYSA9IHgoc291cmNlRGF0YSkgLSBNYXRoLlBJIC8gMjtcbiAgICB2YXIgc3IgPSB5KHNvdXJjZURhdGEpO1xuICAgIHZhciB0YSA9IHgodGFyZ2V0RGF0YSkgLSBNYXRoLlBJIC8gMjtcbiAgICB2YXIgdHIgPSB5KHRhcmdldERhdGEpO1xuXG4gICAgdmFyIHNjID0gTWF0aC5jb3Moc2EpO1xuICAgIHZhciBzcyA9IE1hdGguc2luKHNhKTtcbiAgICB2YXIgdGMgPSBNYXRoLmNvcyh0YSk7XG4gICAgdmFyIHRzID0gTWF0aC5zaW4odGEpO1xuXG4gICAgdmFyIHBhdGgkJDEgPSBwYXRoKCk7XG4gICAgcGF0aCQkMS5tb3ZlVG8oc3IgKiBzYywgc3IgKiBzcyk7XG4gICAgcGF0aCQkMS5saW5lVG8odHIgKiB0YywgdHIgKiB0cyk7XG5cbiAgICByZXR1cm4gcGF0aCQkMS50b1N0cmluZygpO1xuICB9O1xufVxuXG5MaW5rUmFkaWFsU3RlcC5wcm9wVHlwZXMgPSB7XG4gIGlubmVyUmVmOiBQcm9wVHlwZXMuZnVuYyxcbiAgcGF0aDogUHJvcFR5cGVzLmZ1bmMsXG4gIHg6IFByb3BUeXBlcy5mdW5jLFxuICB5OiBQcm9wVHlwZXMuZnVuYyxcbiAgc291cmNlOiBQcm9wVHlwZXMuZnVuYyxcbiAgdGFyZ2V0OiBQcm9wVHlwZXMuZnVuY1xufTtcblxuZnVuY3Rpb24gTGlua1JhZGlhbFN0ZXAoX3JlZjIpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYyLmNsYXNzTmFtZSxcbiAgICAgIGlubmVyUmVmID0gX3JlZjIuaW5uZXJSZWYsXG4gICAgICBkYXRhID0gX3JlZjIuZGF0YSxcbiAgICAgIHBhdGgkJDEgPSBfcmVmMi5wYXRoLFxuICAgICAgX3JlZjIkeCA9IF9yZWYyLngsXG4gICAgICB4ID0gX3JlZjIkeCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC54O1xuICB9IDogX3JlZjIkeCxcbiAgICAgIF9yZWYyJHkgPSBfcmVmMi55LFxuICAgICAgeSA9IF9yZWYyJHkgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueTtcbiAgfSA6IF9yZWYyJHksXG4gICAgICBfcmVmMiRzb3VyY2UgPSBfcmVmMi5zb3VyY2UsXG4gICAgICBzb3VyY2UgPSBfcmVmMiRzb3VyY2UgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQuc291cmNlO1xuICB9IDogX3JlZjIkc291cmNlLFxuICAgICAgX3JlZjIkdGFyZ2V0ID0gX3JlZjIudGFyZ2V0LFxuICAgICAgdGFyZ2V0ID0gX3JlZjIkdGFyZ2V0ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnRhcmdldDtcbiAgfSA6IF9yZWYyJHRhcmdldCxcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYyLCBbJ2NsYXNzTmFtZScsICdpbm5lclJlZicsICdkYXRhJywgJ3BhdGgnLCAneCcsICd5JywgJ3NvdXJjZScsICd0YXJnZXQnXSk7XG5cbiAgcGF0aCQkMSA9IHBhdGgkJDEgfHwgcGF0aFJhZGlhbExpbmUoeyBzb3VyY2U6IHNvdXJjZSwgdGFyZ2V0OiB0YXJnZXQsIHg6IHgsIHk6IHkgfSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgIHJlZjogaW5uZXJSZWYsXG4gICAgY2xhc3NOYW1lOiBjeCgndngtbGluaycsIGNsYXNzTmFtZSksXG4gICAgZDogcGF0aCQkMShkYXRhKVxuICB9LCBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzLCBkYXRhKSkpO1xufVxuXG5mdW5jdGlvbiBwYXRoSG9yaXpvbnRhbFN0ZXAoX3JlZikge1xuICB2YXIgc291cmNlID0gX3JlZi5zb3VyY2UsXG4gICAgICB0YXJnZXQgPSBfcmVmLnRhcmdldCxcbiAgICAgIHggPSBfcmVmLngsXG4gICAgICB5ID0gX3JlZi55LFxuICAgICAgcGVyY2VudCA9IF9yZWYucGVyY2VudDtcblxuICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgc291cmNlRGF0YSA9IHNvdXJjZShkYXRhKTtcbiAgICB2YXIgdGFyZ2V0RGF0YSA9IHRhcmdldChkYXRhKTtcblxuICAgIHZhciBzeCA9IHgoc291cmNlRGF0YSk7XG4gICAgdmFyIHN5ID0geShzb3VyY2VEYXRhKTtcbiAgICB2YXIgdHggPSB4KHRhcmdldERhdGEpO1xuICAgIHZhciB0eSA9IHkodGFyZ2V0RGF0YSk7XG5cbiAgICB2YXIgcGF0aCQkMSA9IHBhdGgoKTtcbiAgICBwYXRoJCQxLm1vdmVUbyhzeCwgc3kpO1xuICAgIHBhdGgkJDEubGluZVRvKHN4ICsgKHR4IC0gc3gpICogcGVyY2VudCwgc3kpO1xuICAgIHBhdGgkJDEubGluZVRvKHN4ICsgKHR4IC0gc3gpICogcGVyY2VudCwgdHkpO1xuICAgIHBhdGgkJDEubGluZVRvKHR4LCB0eSk7XG5cbiAgICByZXR1cm4gcGF0aCQkMS50b1N0cmluZygpO1xuICB9O1xufVxuXG5MaW5rSG9yaXpvbnRhbFN0ZXAucHJvcFR5cGVzID0ge1xuICBpbm5lclJlZjogUHJvcFR5cGVzLmZ1bmMsXG4gIHBlcmNlbnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIHg6IFByb3BUeXBlcy5mdW5jLFxuICB5OiBQcm9wVHlwZXMuZnVuYyxcbiAgc291cmNlOiBQcm9wVHlwZXMuZnVuYyxcbiAgdGFyZ2V0OiBQcm9wVHlwZXMuZnVuYyxcbiAgcGF0aDogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIExpbmtIb3Jpem9udGFsU3RlcChfcmVmMikge1xuICB2YXIgY2xhc3NOYW1lID0gX3JlZjIuY2xhc3NOYW1lLFxuICAgICAgaW5uZXJSZWYgPSBfcmVmMi5pbm5lclJlZixcbiAgICAgIGRhdGEgPSBfcmVmMi5kYXRhLFxuICAgICAgcGF0aCQkMSA9IF9yZWYyLnBhdGgsXG4gICAgICBfcmVmMiRwZXJjZW50ID0gX3JlZjIucGVyY2VudCxcbiAgICAgIHBlcmNlbnQgPSBfcmVmMiRwZXJjZW50ID09PSB1bmRlZmluZWQgPyAwLjUgOiBfcmVmMiRwZXJjZW50LFxuICAgICAgX3JlZjIkeCA9IF9yZWYyLngsXG4gICAgICB4ID0gX3JlZjIkeCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC55O1xuICB9IDogX3JlZjIkeCxcbiAgICAgIF9yZWYyJHkgPSBfcmVmMi55LFxuICAgICAgeSA9IF9yZWYyJHkgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueDtcbiAgfSA6IF9yZWYyJHksXG4gICAgICBfcmVmMiRzb3VyY2UgPSBfcmVmMi5zb3VyY2UsXG4gICAgICBzb3VyY2UgPSBfcmVmMiRzb3VyY2UgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQuc291cmNlO1xuICB9IDogX3JlZjIkc291cmNlLFxuICAgICAgX3JlZjIkdGFyZ2V0ID0gX3JlZjIudGFyZ2V0LFxuICAgICAgdGFyZ2V0ID0gX3JlZjIkdGFyZ2V0ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnRhcmdldDtcbiAgfSA6IF9yZWYyJHRhcmdldCxcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYyLCBbJ2NsYXNzTmFtZScsICdpbm5lclJlZicsICdkYXRhJywgJ3BhdGgnLCAncGVyY2VudCcsICd4JywgJ3knLCAnc291cmNlJywgJ3RhcmdldCddKTtcblxuICBwYXRoJCQxID0gcGF0aCQkMSB8fCBwYXRoSG9yaXpvbnRhbFN0ZXAoeyBzb3VyY2U6IHNvdXJjZSwgdGFyZ2V0OiB0YXJnZXQsIHg6IHgsIHk6IHksIHBlcmNlbnQ6IHBlcmNlbnQgfSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgIHJlZjogaW5uZXJSZWYsXG4gICAgY2xhc3NOYW1lOiBjeCgndngtbGluaycsIGNsYXNzTmFtZSksXG4gICAgZDogcGF0aCQkMShkYXRhKVxuICB9LCBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzLCBkYXRhKSkpO1xufVxuXG5mdW5jdGlvbiBwYXRoVmVydGljYWxTdGVwKF9yZWYpIHtcbiAgdmFyIHNvdXJjZSA9IF9yZWYuc291cmNlLFxuICAgICAgdGFyZ2V0ID0gX3JlZi50YXJnZXQsXG4gICAgICB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueSxcbiAgICAgIHBlcmNlbnQgPSBfcmVmLnBlcmNlbnQ7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIHNvdXJjZURhdGEgPSBzb3VyY2UoZGF0YSk7XG4gICAgdmFyIHRhcmdldERhdGEgPSB0YXJnZXQoZGF0YSk7XG5cbiAgICB2YXIgc3ggPSB4KHNvdXJjZURhdGEpO1xuICAgIHZhciBzeSA9IHkoc291cmNlRGF0YSk7XG4gICAgdmFyIHR4ID0geCh0YXJnZXREYXRhKTtcbiAgICB2YXIgdHkgPSB5KHRhcmdldERhdGEpO1xuXG4gICAgdmFyIHBhdGgkJDEgPSBwYXRoKCk7XG4gICAgcGF0aCQkMS5tb3ZlVG8oc3gsIHN5KTtcbiAgICBwYXRoJCQxLmxpbmVUbyhzeCwgc3kgKyAodHkgLSBzeSkgKiBwZXJjZW50KTtcbiAgICBwYXRoJCQxLmxpbmVUbyh0eCwgc3kgKyAodHkgLSBzeSkgKiBwZXJjZW50KTtcbiAgICBwYXRoJCQxLmxpbmVUbyh0eCwgdHkpO1xuXG4gICAgcmV0dXJuIHBhdGgkJDEudG9TdHJpbmcoKTtcbiAgfTtcbn1cblxuTGlua1ZlcnRpY2FsU3RlcC5wcm9wVHlwZXMgPSB7XG4gIGlubmVyUmVmOiBQcm9wVHlwZXMuZnVuYyxcbiAgcGVyY2VudDogUHJvcFR5cGVzLm51bWJlcixcbiAgeDogUHJvcFR5cGVzLmZ1bmMsXG4gIHk6IFByb3BUeXBlcy5mdW5jLFxuICBzb3VyY2U6IFByb3BUeXBlcy5mdW5jLFxuICB0YXJnZXQ6IFByb3BUeXBlcy5mdW5jLFxuICBwYXRoOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuZnVuY3Rpb24gTGlua1ZlcnRpY2FsU3RlcChfcmVmMikge1xuICB2YXIgY2xhc3NOYW1lID0gX3JlZjIuY2xhc3NOYW1lLFxuICAgICAgaW5uZXJSZWYgPSBfcmVmMi5pbm5lclJlZixcbiAgICAgIGRhdGEgPSBfcmVmMi5kYXRhLFxuICAgICAgcGF0aCQkMSA9IF9yZWYyLnBhdGgsXG4gICAgICBfcmVmMiRwZXJjZW50ID0gX3JlZjIucGVyY2VudCxcbiAgICAgIHBlcmNlbnQgPSBfcmVmMiRwZXJjZW50ID09PSB1bmRlZmluZWQgPyAwLjUgOiBfcmVmMiRwZXJjZW50LFxuICAgICAgX3JlZjIkeCA9IF9yZWYyLngsXG4gICAgICB4ID0gX3JlZjIkeCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC54O1xuICB9IDogX3JlZjIkeCxcbiAgICAgIF9yZWYyJHkgPSBfcmVmMi55LFxuICAgICAgeSA9IF9yZWYyJHkgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueTtcbiAgfSA6IF9yZWYyJHksXG4gICAgICBfcmVmMiRzb3VyY2UgPSBfcmVmMi5zb3VyY2UsXG4gICAgICBzb3VyY2UgPSBfcmVmMiRzb3VyY2UgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQuc291cmNlO1xuICB9IDogX3JlZjIkc291cmNlLFxuICAgICAgX3JlZjIkdGFyZ2V0ID0gX3JlZjIudGFyZ2V0LFxuICAgICAgdGFyZ2V0ID0gX3JlZjIkdGFyZ2V0ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnRhcmdldDtcbiAgfSA6IF9yZWYyJHRhcmdldCxcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYyLCBbJ2NsYXNzTmFtZScsICdpbm5lclJlZicsICdkYXRhJywgJ3BhdGgnLCAncGVyY2VudCcsICd4JywgJ3knLCAnc291cmNlJywgJ3RhcmdldCddKTtcblxuICBwYXRoJCQxID0gcGF0aCQkMSB8fCBwYXRoVmVydGljYWxTdGVwKHsgc291cmNlOiBzb3VyY2UsIHRhcmdldDogdGFyZ2V0LCB4OiB4LCB5OiB5LCBwZXJjZW50OiBwZXJjZW50IH0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgncGF0aCcsIF9leHRlbmRzKHtcbiAgICByZWY6IGlubmVyUmVmLFxuICAgIGNsYXNzTmFtZTogY3goJ3Z4LWxpbmsnLCBjbGFzc05hbWUpLFxuICAgIGQ6IHBhdGgkJDEoZGF0YSlcbiAgfSwgYWRkaXRpb25hbFByb3BzKHJlc3RQcm9wcywgZGF0YSkpKTtcbn1cblxuZnVuY3Rpb24gcGF0aFJhZGlhbFN0ZXAoX3JlZikge1xuICB2YXIgc291cmNlID0gX3JlZi5zb3VyY2UsXG4gICAgICB0YXJnZXQgPSBfcmVmLnRhcmdldCxcbiAgICAgIHggPSBfcmVmLngsXG4gICAgICB5ID0gX3JlZi55O1xuXG4gIHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBzb3VyY2VEYXRhID0gc291cmNlKGRhdGEpO1xuICAgIHZhciB0YXJnZXREYXRhID0gdGFyZ2V0KGRhdGEpO1xuXG4gICAgdmFyIHN4ID0geChzb3VyY2VEYXRhKTtcbiAgICB2YXIgc3kgPSB5KHNvdXJjZURhdGEpO1xuICAgIHZhciB0eCA9IHgodGFyZ2V0RGF0YSk7XG4gICAgdmFyIHR5ID0geSh0YXJnZXREYXRhKTtcblxuICAgIHZhciBzYSA9IHN4IC0gTWF0aC5QSSAvIDI7XG4gICAgdmFyIHNyID0gc3k7XG4gICAgdmFyIHRhID0gdHggLSBNYXRoLlBJIC8gMjtcbiAgICB2YXIgdHIgPSB0eTtcblxuICAgIHZhciBzYyA9IE1hdGguY29zKHNhKTtcbiAgICB2YXIgc3MgPSBNYXRoLnNpbihzYSk7XG4gICAgdmFyIHRjID0gTWF0aC5jb3ModGEpO1xuICAgIHZhciB0cyA9IE1hdGguc2luKHRhKTtcbiAgICB2YXIgc2YgPSBNYXRoLmFicyh0YSAtIHNhKSA+IE1hdGguUEkgPyB0YSA8PSBzYSA6IHRhID4gc2E7XG5cbiAgICByZXR1cm4gJ1xcbiAgICAgIE0nICsgc3IgKiBzYyArICcsJyArIHNyICogc3MgKyAnXFxuICAgICAgQScgKyBzciArICcsJyArIHNyICsgJywwLDAsJyArIChzZiA/IDEgOiAwKSArICcsJyArIHNyICogdGMgKyAnLCcgKyBzciAqIHRzICsgJ1xcbiAgICAgIEwnICsgdHIgKiB0YyArICcsJyArIHRyICogdHMgKyAnXFxuICAgICc7XG4gIH07XG59XG5cbkxpbmtSYWRpYWxTdGVwJDEucHJvcFR5cGVzID0ge1xuICBpbm5lclJlZjogUHJvcFR5cGVzLmZ1bmMsXG4gIHg6IFByb3BUeXBlcy5mdW5jLFxuICB5OiBQcm9wVHlwZXMuZnVuYyxcbiAgc291cmNlOiBQcm9wVHlwZXMuZnVuYyxcbiAgdGFyZ2V0OiBQcm9wVHlwZXMuZnVuYyxcbiAgcGF0aDogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIExpbmtSYWRpYWxTdGVwJDEoX3JlZjIpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IF9yZWYyLmNsYXNzTmFtZSxcbiAgICAgIGlubmVyUmVmID0gX3JlZjIuaW5uZXJSZWYsXG4gICAgICBkYXRhID0gX3JlZjIuZGF0YSxcbiAgICAgIHBhdGgkJDEgPSBfcmVmMi5wYXRoLFxuICAgICAgX3JlZjIkeCA9IF9yZWYyLngsXG4gICAgICB4ID0gX3JlZjIkeCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC54O1xuICB9IDogX3JlZjIkeCxcbiAgICAgIF9yZWYyJHkgPSBfcmVmMi55LFxuICAgICAgeSA9IF9yZWYyJHkgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQueTtcbiAgfSA6IF9yZWYyJHksXG4gICAgICBfcmVmMiRzb3VyY2UgPSBfcmVmMi5zb3VyY2UsXG4gICAgICBzb3VyY2UgPSBfcmVmMiRzb3VyY2UgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQuc291cmNlO1xuICB9IDogX3JlZjIkc291cmNlLFxuICAgICAgX3JlZjIkdGFyZ2V0ID0gX3JlZjIudGFyZ2V0LFxuICAgICAgdGFyZ2V0ID0gX3JlZjIkdGFyZ2V0ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLnRhcmdldDtcbiAgfSA6IF9yZWYyJHRhcmdldCxcbiAgICAgIHJlc3RQcm9wcyA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYyLCBbJ2NsYXNzTmFtZScsICdpbm5lclJlZicsICdkYXRhJywgJ3BhdGgnLCAneCcsICd5JywgJ3NvdXJjZScsICd0YXJnZXQnXSk7XG5cbiAgcGF0aCQkMSA9IHBhdGgkJDEgfHwgcGF0aFJhZGlhbFN0ZXAoeyBzb3VyY2U6IHNvdXJjZSwgdGFyZ2V0OiB0YXJnZXQsIHg6IHgsIHk6IHkgfSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdwYXRoJywgX2V4dGVuZHMoe1xuICAgIHJlZjogaW5uZXJSZWYsXG4gICAgY2xhc3NOYW1lOiBjeCgndngtbGluaycsIGNsYXNzTmFtZSksXG4gICAgZDogcGF0aCQkMShkYXRhKVxuICB9LCBhZGRpdGlvbmFsUHJvcHMocmVzdFByb3BzLCBkYXRhKSkpO1xufVxuXG5Qb2x5Z29uLnByb3BUeXBlcyA9IHtcbiAgc2lkZXM6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgc2l6ZTogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHJvdGF0ZTogUHJvcFR5cGVzLm51bWJlclxufTtcblxudmFyIGdldFBvaW50ID0gZnVuY3Rpb24gZ2V0UG9pbnQoX3JlZikge1xuICB2YXIgc2lkZXMgPSBfcmVmLnNpZGVzLFxuICAgICAgc2l6ZSA9IF9yZWYuc2l6ZSxcbiAgICAgIGNlbnRlciA9IF9yZWYuY2VudGVyLFxuICAgICAgcm90YXRlID0gX3JlZi5yb3RhdGUsXG4gICAgICBzaWRlID0gX3JlZi5zaWRlO1xuXG4gIHZhciBkZWdyZWVzID0gMzYwIC8gc2lkZXMgKiBzaWRlIC0gcm90YXRlO1xuICB2YXIgcmFkaWFucyA9IGRlZ3JlZXNUb1JhZGlhbnMoZGVncmVlcyk7XG5cbiAgcmV0dXJuIG5ldyBQb2ludCh7XG4gICAgeDogY2VudGVyLnggKyBzaXplICogTWF0aC5jb3MocmFkaWFucyksXG4gICAgeTogY2VudGVyLnkgKyBzaXplICogTWF0aC5zaW4ocmFkaWFucylcbiAgfSk7XG59O1xuXG52YXIgZ2V0UG9pbnRzID0gZnVuY3Rpb24gZ2V0UG9pbnRzKF9yZWYyKSB7XG4gIHZhciBzaWRlcyA9IF9yZWYyLnNpZGVzLFxuICAgICAgc2l6ZSA9IF9yZWYyLnNpemUsXG4gICAgICBjZW50ZXIgPSBfcmVmMi5jZW50ZXIsXG4gICAgICByb3RhdGUgPSBfcmVmMi5yb3RhdGU7XG5cbiAgcmV0dXJuIFtdLmNvbmNhdCh0b0NvbnN1bWFibGVBcnJheShBcnJheShzaWRlcykua2V5cygpKSkubWFwKGZ1bmN0aW9uIChzaWRlKSB7XG4gICAgcmV0dXJuIGdldFBvaW50KHtcbiAgICAgIHNpZGVzOiBzaWRlcyxcbiAgICAgIHNpemU6IHNpemUsXG4gICAgICBjZW50ZXI6IGNlbnRlcixcbiAgICAgIHJvdGF0ZTogcm90YXRlLFxuICAgICAgc2lkZTogc2lkZVxuICAgIH0pO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIFBvbHlnb24oX3JlZjMpIHtcbiAgdmFyIHNpZGVzID0gX3JlZjMuc2lkZXMsXG4gICAgICBfcmVmMyRzaXplID0gX3JlZjMuc2l6ZSxcbiAgICAgIHNpemUgPSBfcmVmMyRzaXplID09PSB1bmRlZmluZWQgPyAyNSA6IF9yZWYzJHNpemUsXG4gICAgICBfcmVmMyRjZW50ZXIgPSBfcmVmMy5jZW50ZXIsXG4gICAgICBjZW50ZXIgPSBfcmVmMyRjZW50ZXIgPT09IHVuZGVmaW5lZCA/IG5ldyBQb2ludCh7IHg6IDAsIHk6IDAgfSkgOiBfcmVmMyRjZW50ZXIsXG4gICAgICBfcmVmMyRyb3RhdGUgPSBfcmVmMy5yb3RhdGUsXG4gICAgICByb3RhdGUgPSBfcmVmMyRyb3RhdGUgPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmMyRyb3RhdGUsXG4gICAgICBjbGFzc05hbWUgPSBfcmVmMy5jbGFzc05hbWUsXG4gICAgICByZXN0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMywgWydzaWRlcycsICdzaXplJywgJ2NlbnRlcicsICdyb3RhdGUnLCAnY2xhc3NOYW1lJ10pO1xuXG4gIHZhciBwb2ludHMgPSBnZXRQb2ludHMoe1xuICAgIHNpZGVzOiBzaWRlcyxcbiAgICBzaXplOiBzaXplLFxuICAgIGNlbnRlcjogY2VudGVyLFxuICAgIHJvdGF0ZTogcm90YXRlXG4gIH0pLm1hcChmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBwLnRvQXJyYXkoKTtcbiAgfSkuam9pbignICcpO1xuXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdwb2x5Z29uJywgX2V4dGVuZHMoeyBwb2ludHM6IHBvaW50cywgY2xhc3NOYW1lOiBjeCgndngtcG9seWdvbicsIGNsYXNzTmFtZSkgfSwgcmVzdFByb3BzKSk7XG59XG5cbmV4cG9ydCB7IEFyYywgUGllLCBMaW5lLCBMaW5lUGF0aCwgTGluZVJhZGlhbCwgQXJlYSwgQXJlYUNsb3NlZCwgQXJlYVN0YWNrLCBCYXIsIEJhckdyb3VwLCBCYXJHcm91cEhvcml6b250YWwsIEJhclN0YWNrLCBCYXJTdGFja0hvcml6b250YWwsIFN0YWNrLCBjYWxsT3JWYWx1ZSwgc3RhY2tPZmZzZXQsIFNUQUNLX09GRlNFVFMsIFNUQUNLX09GRlNFVF9OQU1FUywgc3RhY2tPcmRlciwgU1RBQ0tfT1JERVJTLCBTVEFDS19PUkRFUl9OQU1FUywgZGVncmVlc1RvUmFkaWFucywgTGlua0hvcml6b250YWwsIHBhdGhIb3Jpem9udGFsRGlhZ29uYWwsIExpbmtWZXJ0aWNhbCwgcGF0aFZlcnRpY2FsRGlhZ29uYWwsIExpbmtSYWRpYWwsIHBhdGhSYWRpYWxEaWFnb25hbCwgTGlua0hvcml6b250YWxDdXJ2ZSwgcGF0aEhvcml6b250YWxDdXJ2ZSwgTGlua1ZlcnRpY2FsQ3VydmUsIHBhdGhWZXJ0aWNhbEN1cnZlLCBMaW5rUmFkaWFsQ3VydmUsIHBhdGhSYWRpYWxDdXJ2ZSwgTGlua0hvcml6b250YWxMaW5lLCBwYXRoSG9yaXpvbnRhbExpbmUsIExpbmtWZXJ0aWNhbExpbmUsIHBhdGhWZXJ0aWNhbExpbmUsIExpbmtSYWRpYWxTdGVwIGFzIExpbmtSYWRpYWxMaW5lLCBwYXRoUmFkaWFsTGluZSwgTGlua0hvcml6b250YWxTdGVwLCBwYXRoSG9yaXpvbnRhbFN0ZXAsIExpbmtWZXJ0aWNhbFN0ZXAsIHBhdGhWZXJ0aWNhbFN0ZXAsIExpbmtSYWRpYWxTdGVwJDEgYXMgTGlua1JhZGlhbFN0ZXAsIHBhdGhSYWRpYWxTdGVwLCBQb2x5Z29uLCBnZXRQb2ludHMsIGdldFBvaW50IH07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1394\n")},1439:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* unused harmony export Axis */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return AxisLeft; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return AxisRight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return AxisTop; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return AxisBottom; });\n/* unused harmony export Orientation */\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(130);\n/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _vx_shape__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1394);\n/* harmony import */ var _vx_point__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1302);\n/* harmony import */ var _vx_group__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(1336);\n/* harmony import */ var _vx_text__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(1722);\n\n\n\n\n\n\n\n\nfunction center(scale) {\n  var offset = scale.bandwidth() / 2;\n  if (scale.round()) offset = Math.round(offset);\n  return function (d) {\n    return scale(d) + offset;\n  };\n}\n\nfunction identity(x) {\n  return x;\n}\n\nvar ORIENT = {\n  top: 'top',\n  left: 'left',\n  right: 'right',\n  bottom: 'bottom'\n};\n\nfunction labelTransform(_ref) {\n  var labelOffset = _ref.labelOffset,\n      labelProps = _ref.labelProps,\n      orientation = _ref.orientation,\n      range = _ref.range,\n      tickLabelFontSize = _ref.tickLabelFontSize,\n      tickLength = _ref.tickLength;\n\n  var sign = orientation === ORIENT.left || orientation === ORIENT.top ? -1 : 1;\n\n  var x = void 0;\n  var y = void 0;\n  var transform = null;\n\n  if (orientation === ORIENT.top || orientation === ORIENT.bottom) {\n    x = (range[0] + range[range.length - 1]) / 2;\n    y = sign * (tickLength + labelOffset + tickLabelFontSize + (orientation === ORIENT.bottom ? labelProps.fontSize : 0));\n  } else {\n    x = sign * ((range[0] + range[range.length - 1]) / 2);\n    y = -(tickLength + labelOffset);\n    transform = 'rotate(' + sign * 90 + ')';\n  }\n\n  return { x: x, y: y, transform: transform };\n}\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar propTypes = {\n  axisClassName: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  axisLineClassName: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  hideAxisLine: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,\n  hideTicks: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,\n  hideZero: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,\n  label: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  labelClassName: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  labelOffset: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  labelProps: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object,\n  left: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  numTicks: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  orientation: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.oneOf([ORIENT.top, ORIENT.right, ORIENT.bottom, ORIENT.left]),\n  rangePadding: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  scale: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func.isRequired,\n  stroke: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  strokeWidth: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  strokeDasharray: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  tickClassName: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  tickFormat: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,\n  tickLabelProps: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,\n  tickLength: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  tickStroke: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  tickTransform: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  tickValues: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.array,\n  tickComponent: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,\n  top: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  children: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func\n};\n\nfunction Axis(_ref) {\n  var children = _ref.children,\n      axisClassName = _ref.axisClassName,\n      axisLineClassName = _ref.axisLineClassName,\n      _ref$hideAxisLine = _ref.hideAxisLine,\n      hideAxisLine = _ref$hideAxisLine === undefined ? false : _ref$hideAxisLine,\n      _ref$hideTicks = _ref.hideTicks,\n      hideTicks = _ref$hideTicks === undefined ? false : _ref$hideTicks,\n      _ref$hideZero = _ref.hideZero,\n      hideZero = _ref$hideZero === undefined ? false : _ref$hideZero,\n      _ref$label = _ref.label,\n      label = _ref$label === undefined ? '' : _ref$label,\n      labelClassName = _ref.labelClassName,\n      _ref$labelOffset = _ref.labelOffset,\n      labelOffset = _ref$labelOffset === undefined ? 14 : _ref$labelOffset,\n      _ref$labelProps = _ref.labelProps,\n      labelProps = _ref$labelProps === undefined ? {\n    textAnchor: 'middle',\n    fontFamily: 'Arial',\n    fontSize: 10,\n    fill: 'black'\n  } : _ref$labelProps,\n      _ref$left = _ref.left,\n      left = _ref$left === undefined ? 0 : _ref$left,\n      _ref$numTicks = _ref.numTicks,\n      numTicks = _ref$numTicks === undefined ? 10 : _ref$numTicks,\n      _ref$orientation = _ref.orientation,\n      orientation = _ref$orientation === undefined ? ORIENT.bottom : _ref$orientation,\n      _ref$rangePadding = _ref.rangePadding,\n      rangePadding = _ref$rangePadding === undefined ? 0 : _ref$rangePadding,\n      scale = _ref.scale,\n      _ref$stroke = _ref.stroke,\n      stroke = _ref$stroke === undefined ? 'black' : _ref$stroke,\n      _ref$strokeWidth = _ref.strokeWidth,\n      strokeWidth = _ref$strokeWidth === undefined ? 1 : _ref$strokeWidth,\n      strokeDasharray = _ref.strokeDasharray,\n      tickClassName = _ref.tickClassName,\n      tickFormat = _ref.tickFormat,\n      _ref$tickLabelProps = _ref.tickLabelProps,\n      tickLabelProps = _ref$tickLabelProps === undefined ? function (tickValue, index) {\n    return {\n      textAnchor: 'middle',\n      fontFamily: 'Arial',\n      fontSize: 10,\n      fill: 'black'\n    };\n  } : _ref$tickLabelProps,\n      _ref$tickLength = _ref.tickLength,\n      tickLength = _ref$tickLength === undefined ? 8 : _ref$tickLength,\n      _ref$tickStroke = _ref.tickStroke,\n      tickStroke = _ref$tickStroke === undefined ? 'black' : _ref$tickStroke,\n      tickTransform = _ref.tickTransform,\n      tickValues = _ref.tickValues,\n      tickComponent = _ref.tickComponent,\n      _ref$top = _ref.top,\n      top = _ref$top === undefined ? 0 : _ref$top;\n\n  var values = scale.ticks ? scale.ticks(numTicks) : scale.domain();\n  if (tickValues) values = tickValues;\n  var format = scale.tickFormat ? scale.tickFormat() : identity;\n  if (tickFormat) format = tickFormat;\n\n  var range = scale.range();\n  var range0 = range[0] + 0.5 - rangePadding;\n  var range1 = range[range.length - 1] + 0.5 + rangePadding;\n\n  var horizontal = orientation !== ORIENT.left && orientation !== ORIENT.right;\n  var isLeft = orientation === ORIENT.left;\n  var isTop = orientation === ORIENT.top;\n  var tickSign = isLeft || isTop ? -1 : 1;\n\n  var position = (scale.bandwidth ? center : identity)(scale.copy());\n\n  var axisFromPoint = new _vx_point__WEBPACK_IMPORTED_MODULE_4__[\"Point\"]({\n    x: horizontal ? range0 : 0,\n    y: horizontal ? 0 : range0\n  });\n  var axisToPoint = new _vx_point__WEBPACK_IMPORTED_MODULE_4__[\"Point\"]({\n    x: horizontal ? range1 : 0,\n    y: horizontal ? 0 : range1\n  });\n\n  var tickLabelFontSize = 10; // track the max tick label size to compute label offset\n\n  if (!!children) {\n    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n      _vx_group__WEBPACK_IMPORTED_MODULE_5__[/* Group */ \"a\"],\n      { className: classnames__WEBPACK_IMPORTED_MODULE_2___default()('vx-axis', axisClassName), top: top, left: left },\n      children({\n        axisFromPoint: axisFromPoint,\n        axisToPoint: axisToPoint,\n        horizontal: horizontal,\n        tickSign: tickSign,\n        numTicks: numTicks,\n        label: label,\n        rangePadding: rangePadding,\n        tickLength: tickLength,\n        tickFormat: format,\n        tickPosition: position,\n        ticks: values.map(function (value, index) {\n          var from = new _vx_point__WEBPACK_IMPORTED_MODULE_4__[\"Point\"]({\n            x: horizontal ? position(value) : 0,\n            y: horizontal ? 0 : position(value)\n          });\n          var to = new _vx_point__WEBPACK_IMPORTED_MODULE_4__[\"Point\"]({\n            x: horizontal ? position(value) : tickSign * tickLength,\n            y: horizontal ? tickLength * tickSign : position(value)\n          });\n          return {\n            value: value,\n            index: index,\n            from: from,\n            to: to,\n            formattedValue: format(value, index)\n          };\n        })\n      })\n    );\n  }\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n    _vx_group__WEBPACK_IMPORTED_MODULE_5__[/* Group */ \"a\"],\n    { className: classnames__WEBPACK_IMPORTED_MODULE_2___default()('vx-axis', axisClassName), top: top, left: left },\n    values.map(function (val, index) {\n      if (hideZero && val === 0) return null;\n\n      var tickFromPoint = new _vx_point__WEBPACK_IMPORTED_MODULE_4__[\"Point\"]({\n        x: horizontal ? position(val) : 0,\n        y: horizontal ? 0 : position(val)\n      });\n      var tickToPoint = new _vx_point__WEBPACK_IMPORTED_MODULE_4__[\"Point\"]({\n        x: horizontal ? position(val) : tickSign * tickLength,\n        y: horizontal ? tickLength * tickSign : position(val)\n      });\n\n      var tickLabelPropsObj = tickLabelProps(val, index);\n      tickLabelFontSize = Math.max(tickLabelFontSize, tickLabelPropsObj.fontSize || 0);\n\n      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n        _vx_group__WEBPACK_IMPORTED_MODULE_5__[/* Group */ \"a\"],\n        {\n          key: 'vx-tick-' + val + '-' + index,\n          className: classnames__WEBPACK_IMPORTED_MODULE_2___default()('vx-axis-tick', tickClassName),\n          transform: tickTransform\n        },\n        !hideTicks && react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_vx_shape__WEBPACK_IMPORTED_MODULE_3__[/* Line */ \"b\"], { from: tickFromPoint, to: tickToPoint, stroke: tickStroke }),\n        tickComponent ? tickComponent(_extends({\n          x: tickToPoint.x,\n          y: tickToPoint.y + (horizontal && !isTop ? tickLabelFontSize : 0),\n          formattedValue: format(val, index)\n        }, tickLabelPropsObj)) : react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n          _vx_text__WEBPACK_IMPORTED_MODULE_6__[/* Text */ \"a\"],\n          _extends({\n            x: tickToPoint.x,\n            y: tickToPoint.y + (horizontal && !isTop ? tickLabelFontSize : 0)\n          }, tickLabelPropsObj),\n          format(val, index)\n        )\n      );\n    }),\n    !hideAxisLine && react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_vx_shape__WEBPACK_IMPORTED_MODULE_3__[/* Line */ \"b\"], {\n      className: classnames__WEBPACK_IMPORTED_MODULE_2___default()('vx-axis-line', axisLineClassName),\n      from: axisFromPoint,\n      to: axisToPoint,\n      stroke: stroke,\n      strokeWidth: strokeWidth,\n      strokeDasharray: strokeDasharray\n    }),\n    label && react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\n      _vx_text__WEBPACK_IMPORTED_MODULE_6__[/* Text */ \"a\"],\n      _extends({\n        className: classnames__WEBPACK_IMPORTED_MODULE_2___default()('vx-axis-label', labelClassName)\n      }, labelTransform({\n        labelOffset: labelOffset,\n        labelProps: labelProps,\n        orientation: orientation,\n        range: range,\n        tickLabelFontSize: tickLabelFontSize,\n        tickLength: tickLength\n      }), labelProps),\n      label\n    )\n  );\n}\n\nAxis.propTypes = propTypes;\n\nvar propTypes$1 = {\n  axisClassName: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  axisLineClassName: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  hideAxisLine: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,\n  hideTicks: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,\n  hideZero: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,\n  label: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  labelClassName: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  labelOffset: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  labelProps: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object,\n  left: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  numTicks: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  rangePadding: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  scale: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func.isRequired,\n  stroke: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  strokeWidth: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  strokeDasharray: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  tickClassName: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  tickFormat: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,\n  tickLabelProps: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,\n  tickLength: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  tickStroke: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  tickTransform: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  tickValues: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.array,\n  tickComponent: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,\n  top: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  children: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func\n};\n\nfunction AxisLeft(_ref) {\n  var children = _ref.children,\n      axisClassName = _ref.axisClassName,\n      axisLineClassName = _ref.axisLineClassName,\n      hideAxisLine = _ref.hideAxisLine,\n      hideTicks = _ref.hideTicks,\n      hideZero = _ref.hideZero,\n      label = _ref.label,\n      labelClassName = _ref.labelClassName,\n      _ref$labelOffset = _ref.labelOffset,\n      labelOffset = _ref$labelOffset === undefined ? 36 : _ref$labelOffset,\n      labelProps = _ref.labelProps,\n      left = _ref.left,\n      numTicks = _ref.numTicks,\n      rangePadding = _ref.rangePadding,\n      scale = _ref.scale,\n      stroke = _ref.stroke,\n      strokeWidth = _ref.strokeWidth,\n      strokeDasharray = _ref.strokeDasharray,\n      tickClassName = _ref.tickClassName,\n      tickFormat = _ref.tickFormat,\n      _ref$tickLabelProps = _ref.tickLabelProps,\n      tickLabelProps = _ref$tickLabelProps === undefined ? function (_ref2) {\n    var tick = _ref2.tick,\n        index = _ref2.index;\n    return {\n      dx: '-0.25em',\n      dy: '0.25em',\n      fill: 'black',\n      fontFamily: 'Arial',\n      fontSize: 10,\n      textAnchor: 'end'\n    };\n  } : _ref$tickLabelProps,\n      _ref$tickLength = _ref.tickLength,\n      tickLength = _ref$tickLength === undefined ? 8 : _ref$tickLength,\n      tickStroke = _ref.tickStroke,\n      tickTransform = _ref.tickTransform,\n      tickValues = _ref.tickValues,\n      tickComponent = _ref.tickComponent,\n      top = _ref.top;\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Axis, {\n    axisClassName: classnames__WEBPACK_IMPORTED_MODULE_2___default()('vx-axis-left', axisClassName),\n    axisLineClassName: axisLineClassName,\n    hideAxisLine: hideAxisLine,\n    hideTicks: hideTicks,\n    hideZero: hideZero,\n    label: label,\n    labelClassName: labelClassName,\n    labelOffset: labelOffset,\n    labelProps: labelProps,\n    left: left,\n    numTicks: numTicks,\n    orientation: ORIENT.left,\n    rangePadding: rangePadding,\n    scale: scale,\n    stroke: stroke,\n    strokeWidth: strokeWidth,\n    strokeDasharray: strokeDasharray,\n    tickClassName: tickClassName,\n    tickFormat: tickFormat,\n    tickLabelProps: tickLabelProps,\n    tickLength: tickLength,\n    tickStroke: tickStroke,\n    tickTransform: tickTransform,\n    tickValues: tickValues,\n    tickComponent: tickComponent,\n    top: top,\n    children: children\n  });\n}\n\nAxisLeft.propTypes = propTypes$1;\n\nvar propTypes$2 = {\n  axisClassName: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  axisLineClassName: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  hideAxisLine: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,\n  hideTicks: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,\n  hideZero: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,\n  label: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  labelClassName: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  labelOffset: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  labelProps: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object,\n  left: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  numTicks: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  rangePadding: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  scale: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func.isRequired,\n  stroke: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  strokeWidth: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  strokeDasharray: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  tickClassName: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  tickFormat: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,\n  tickLabelProps: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,\n  tickLength: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  tickStroke: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  tickTransform: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  tickValues: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.array,\n  tickComponent: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,\n  top: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  children: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func\n};\n\nfunction AxisRight(_ref) {\n  var children = _ref.children,\n      axisClassName = _ref.axisClassName,\n      axisLineClassName = _ref.axisLineClassName,\n      hideAxisLine = _ref.hideAxisLine,\n      hideTicks = _ref.hideTicks,\n      hideZero = _ref.hideZero,\n      label = _ref.label,\n      labelClassName = _ref.labelClassName,\n      _ref$labelOffset = _ref.labelOffset,\n      labelOffset = _ref$labelOffset === undefined ? 36 : _ref$labelOffset,\n      labelProps = _ref.labelProps,\n      left = _ref.left,\n      numTicks = _ref.numTicks,\n      rangePadding = _ref.rangePadding,\n      scale = _ref.scale,\n      stroke = _ref.stroke,\n      strokeWidth = _ref.strokeWidth,\n      strokeDasharray = _ref.strokeDasharray,\n      tickClassName = _ref.tickClassName,\n      tickFormat = _ref.tickFormat,\n      _ref$tickLabelProps = _ref.tickLabelProps,\n      tickLabelProps = _ref$tickLabelProps === undefined ? function (_ref2) {\n    var tick = _ref2.tick,\n        index = _ref2.index;\n    return {\n      dx: '0.25em',\n      dy: '0.25em',\n      fill: 'black',\n      fontFamily: 'Arial',\n      fontSize: 10,\n      textAnchor: 'start'\n    };\n  } : _ref$tickLabelProps,\n      _ref$tickLength = _ref.tickLength,\n      tickLength = _ref$tickLength === undefined ? 8 : _ref$tickLength,\n      tickStroke = _ref.tickStroke,\n      tickTransform = _ref.tickTransform,\n      tickValues = _ref.tickValues,\n      tickComponent = _ref.tickComponent,\n      top = _ref.top;\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Axis, {\n    axisClassName: classnames__WEBPACK_IMPORTED_MODULE_2___default()('vx-axis-right', axisClassName),\n    axisLineClassName: axisLineClassName,\n    hideAxisLine: hideAxisLine,\n    hideTicks: hideTicks,\n    hideZero: hideZero,\n    label: label,\n    labelClassName: labelClassName,\n    labelOffset: labelOffset,\n    labelProps: labelProps,\n    left: left,\n    numTicks: numTicks,\n    orientation: ORIENT.right,\n    rangePadding: rangePadding,\n    scale: scale,\n    stroke: stroke,\n    strokeWidth: strokeWidth,\n    strokeDasharray: strokeDasharray,\n    tickClassName: tickClassName,\n    tickFormat: tickFormat,\n    tickLabelProps: tickLabelProps,\n    tickLength: tickLength,\n    tickStroke: tickStroke,\n    tickTransform: tickTransform,\n    tickValues: tickValues,\n    tickComponent: tickComponent,\n    top: top,\n    children: children\n  });\n}\n\nAxisRight.propTypes = propTypes$2;\n\nvar propTypes$3 = {\n  axisClassName: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  axisLineClassName: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  hideAxisLine: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,\n  hideTicks: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,\n  hideZero: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,\n  label: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  labelClassName: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  labelOffset: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  labelProps: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object,\n  left: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  numTicks: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  rangePadding: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  scale: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func.isRequired,\n  stroke: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  strokeWidth: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  strokeDasharray: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  tickClassName: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  tickFormat: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,\n  tickLabelProps: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,\n  tickLength: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  tickStroke: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  tickTransform: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  tickValues: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.array,\n  tickComponent: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,\n  top: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  children: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func\n};\n\nfunction AxisTop(_ref) {\n  var children = _ref.children,\n      axisClassName = _ref.axisClassName,\n      axisLineClassName = _ref.axisLineClassName,\n      hideAxisLine = _ref.hideAxisLine,\n      hideTicks = _ref.hideTicks,\n      hideZero = _ref.hideZero,\n      label = _ref.label,\n      labelClassName = _ref.labelClassName,\n      _ref$labelOffset = _ref.labelOffset,\n      labelOffset = _ref$labelOffset === undefined ? 8 : _ref$labelOffset,\n      labelProps = _ref.labelProps,\n      left = _ref.left,\n      numTicks = _ref.numTicks,\n      rangePadding = _ref.rangePadding,\n      scale = _ref.scale,\n      stroke = _ref.stroke,\n      strokeWidth = _ref.strokeWidth,\n      strokeDasharray = _ref.strokeDasharray,\n      tickClassName = _ref.tickClassName,\n      tickFormat = _ref.tickFormat,\n      _ref$tickLabelProps = _ref.tickLabelProps,\n      tickLabelProps = _ref$tickLabelProps === undefined ? function (_ref2) {\n    var tick = _ref2.tick,\n        index = _ref2.index;\n    return {\n      dy: '-0.25em',\n      fill: 'black',\n      fontFamily: 'Arial',\n      fontSize: 10,\n      textAnchor: 'middle'\n    };\n  } : _ref$tickLabelProps,\n      _ref$tickLength = _ref.tickLength,\n      tickLength = _ref$tickLength === undefined ? 8 : _ref$tickLength,\n      tickStroke = _ref.tickStroke,\n      tickTransform = _ref.tickTransform,\n      tickValues = _ref.tickValues,\n      tickComponent = _ref.tickComponent,\n      top = _ref.top;\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Axis, {\n    axisClassName: classnames__WEBPACK_IMPORTED_MODULE_2___default()('vx-axis-top', axisClassName),\n    axisLineClassName: axisLineClassName,\n    hideAxisLine: hideAxisLine,\n    hideTicks: hideTicks,\n    hideZero: hideZero,\n    label: label,\n    labelClassName: labelClassName,\n    labelOffset: labelOffset,\n    labelProps: labelProps,\n    left: left,\n    numTicks: numTicks,\n    orientation: ORIENT.top,\n    rangePadding: rangePadding,\n    scale: scale,\n    stroke: stroke,\n    strokeWidth: strokeWidth,\n    strokeDasharray: strokeDasharray,\n    tickClassName: tickClassName,\n    tickFormat: tickFormat,\n    tickLabelProps: tickLabelProps,\n    tickLength: tickLength,\n    tickStroke: tickStroke,\n    tickTransform: tickTransform,\n    tickValues: tickValues,\n    tickComponent: tickComponent,\n    top: top,\n    children: children\n  });\n}\n\nAxisTop.propTypes = propTypes$3;\n\nvar propTypes$4 = {\n  axisClassName: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  axisLineClassName: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  hideAxisLine: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,\n  hideTicks: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,\n  hideZero: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,\n  label: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  labelClassName: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  labelOffset: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  labelProps: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object,\n  left: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  numTicks: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  rangePadding: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  scale: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func.isRequired,\n  stroke: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  strokeWidth: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  strokeDasharray: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  tickClassName: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  tickFormat: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,\n  tickLabelProps: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,\n  tickLength: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  tickStroke: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  tickTransform: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  tickValues: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.array,\n  tickComponent: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,\n  top: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  children: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func\n};\n\nfunction AxisBottom(_ref) {\n  var children = _ref.children,\n      axisClassName = _ref.axisClassName,\n      axisLineClassName = _ref.axisLineClassName,\n      hideAxisLine = _ref.hideAxisLine,\n      hideTicks = _ref.hideTicks,\n      hideZero = _ref.hideZero,\n      label = _ref.label,\n      labelClassName = _ref.labelClassName,\n      _ref$labelOffset = _ref.labelOffset,\n      labelOffset = _ref$labelOffset === undefined ? 8 : _ref$labelOffset,\n      labelProps = _ref.labelProps,\n      left = _ref.left,\n      numTicks = _ref.numTicks,\n      rangePadding = _ref.rangePadding,\n      scale = _ref.scale,\n      stroke = _ref.stroke,\n      strokeWidth = _ref.strokeWidth,\n      strokeDasharray = _ref.strokeDasharray,\n      tickClassName = _ref.tickClassName,\n      tickFormat = _ref.tickFormat,\n      _ref$tickLabelProps = _ref.tickLabelProps,\n      tickLabelProps = _ref$tickLabelProps === undefined ? function (_ref2) {\n    var tick = _ref2.tick,\n        index = _ref2.index;\n    return {\n      dy: '0.25em',\n      fill: 'black',\n      fontFamily: 'Arial',\n      fontSize: 10,\n      textAnchor: 'middle'\n    };\n  } : _ref$tickLabelProps,\n      _ref$tickLength = _ref.tickLength,\n      tickLength = _ref$tickLength === undefined ? 8 : _ref$tickLength,\n      tickStroke = _ref.tickStroke,\n      tickTransform = _ref.tickTransform,\n      tickValues = _ref.tickValues,\n      tickComponent = _ref.tickComponent,\n      top = _ref.top;\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Axis, {\n    axisClassName: classnames__WEBPACK_IMPORTED_MODULE_2___default()('vx-axis-bottom', axisClassName),\n    axisLineClassName: axisLineClassName,\n    hideAxisLine: hideAxisLine,\n    hideTicks: hideTicks,\n    hideZero: hideZero,\n    label: label,\n    labelClassName: labelClassName,\n    labelOffset: labelOffset,\n    labelProps: labelProps,\n    left: left,\n    numTicks: numTicks,\n    orientation: ORIENT.bottom,\n    rangePadding: rangePadding,\n    scale: scale,\n    stroke: stroke,\n    strokeWidth: strokeWidth,\n    strokeDasharray: strokeDasharray,\n    tickClassName: tickClassName,\n    tickFormat: tickFormat,\n    tickLabelProps: tickLabelProps,\n    tickLength: tickLength,\n    tickStroke: tickStroke,\n    tickTransform: tickTransform,\n    tickValues: tickValues,\n    tickComponent: tickComponent,\n    top: top,\n    children: children\n  });\n}\n\nAxisBottom.propTypes = propTypes$4;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQzOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL2hpc3RvZ3JhbS9ub2RlX21vZHVsZXMvQHZ4L2F4aXMvZGlzdC92eC1heGlzLmVzLmpzPzRmM2QiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY3ggZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgeyBMaW5lIH0gZnJvbSAnQHZ4L3NoYXBlJztcbmltcG9ydCB7IFBvaW50IH0gZnJvbSAnQHZ4L3BvaW50JztcbmltcG9ydCB7IEdyb3VwIH0gZnJvbSAnQHZ4L2dyb3VwJztcbmltcG9ydCB7IFRleHQgfSBmcm9tICdAdngvdGV4dCc7XG5cbmZ1bmN0aW9uIGNlbnRlcihzY2FsZSkge1xuICB2YXIgb2Zmc2V0ID0gc2NhbGUuYmFuZHdpZHRoKCkgLyAyO1xuICBpZiAoc2NhbGUucm91bmQoKSkgb2Zmc2V0ID0gTWF0aC5yb3VuZChvZmZzZXQpO1xuICByZXR1cm4gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gc2NhbGUoZCkgKyBvZmZzZXQ7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGlkZW50aXR5KHgpIHtcbiAgcmV0dXJuIHg7XG59XG5cbnZhciBPUklFTlQgPSB7XG4gIHRvcDogJ3RvcCcsXG4gIGxlZnQ6ICdsZWZ0JyxcbiAgcmlnaHQ6ICdyaWdodCcsXG4gIGJvdHRvbTogJ2JvdHRvbSdcbn07XG5cbmZ1bmN0aW9uIGxhYmVsVHJhbnNmb3JtKF9yZWYpIHtcbiAgdmFyIGxhYmVsT2Zmc2V0ID0gX3JlZi5sYWJlbE9mZnNldCxcbiAgICAgIGxhYmVsUHJvcHMgPSBfcmVmLmxhYmVsUHJvcHMsXG4gICAgICBvcmllbnRhdGlvbiA9IF9yZWYub3JpZW50YXRpb24sXG4gICAgICByYW5nZSA9IF9yZWYucmFuZ2UsXG4gICAgICB0aWNrTGFiZWxGb250U2l6ZSA9IF9yZWYudGlja0xhYmVsRm9udFNpemUsXG4gICAgICB0aWNrTGVuZ3RoID0gX3JlZi50aWNrTGVuZ3RoO1xuXG4gIHZhciBzaWduID0gb3JpZW50YXRpb24gPT09IE9SSUVOVC5sZWZ0IHx8IG9yaWVudGF0aW9uID09PSBPUklFTlQudG9wID8gLTEgOiAxO1xuXG4gIHZhciB4ID0gdm9pZCAwO1xuICB2YXIgeSA9IHZvaWQgMDtcbiAgdmFyIHRyYW5zZm9ybSA9IG51bGw7XG5cbiAgaWYgKG9yaWVudGF0aW9uID09PSBPUklFTlQudG9wIHx8IG9yaWVudGF0aW9uID09PSBPUklFTlQuYm90dG9tKSB7XG4gICAgeCA9IChyYW5nZVswXSArIHJhbmdlW3JhbmdlLmxlbmd0aCAtIDFdKSAvIDI7XG4gICAgeSA9IHNpZ24gKiAodGlja0xlbmd0aCArIGxhYmVsT2Zmc2V0ICsgdGlja0xhYmVsRm9udFNpemUgKyAob3JpZW50YXRpb24gPT09IE9SSUVOVC5ib3R0b20gPyBsYWJlbFByb3BzLmZvbnRTaXplIDogMCkpO1xuICB9IGVsc2Uge1xuICAgIHggPSBzaWduICogKChyYW5nZVswXSArIHJhbmdlW3JhbmdlLmxlbmd0aCAtIDFdKSAvIDIpO1xuICAgIHkgPSAtKHRpY2tMZW5ndGggKyBsYWJlbE9mZnNldCk7XG4gICAgdHJhbnNmb3JtID0gJ3JvdGF0ZSgnICsgc2lnbiAqIDkwICsgJyknO1xuICB9XG5cbiAgcmV0dXJuIHsgeDogeCwgeTogeSwgdHJhbnNmb3JtOiB0cmFuc2Zvcm0gfTtcbn1cblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbnZhciBwcm9wVHlwZXMgPSB7XG4gIGF4aXNDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGF4aXNMaW5lQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBoaWRlQXhpc0xpbmU6IFByb3BUeXBlcy5ib29sLFxuICBoaWRlVGlja3M6IFByb3BUeXBlcy5ib29sLFxuICBoaWRlWmVybzogUHJvcFR5cGVzLmJvb2wsXG4gIGxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBsYWJlbENsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgbGFiZWxPZmZzZXQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIGxhYmVsUHJvcHM6IFByb3BUeXBlcy5vYmplY3QsXG4gIGxlZnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIG51bVRpY2tzOiBQcm9wVHlwZXMubnVtYmVyLFxuICBvcmllbnRhdGlvbjogUHJvcFR5cGVzLm9uZU9mKFtPUklFTlQudG9wLCBPUklFTlQucmlnaHQsIE9SSUVOVC5ib3R0b20sIE9SSUVOVC5sZWZ0XSksXG4gIHJhbmdlUGFkZGluZzogUHJvcFR5cGVzLm51bWJlcixcbiAgc2NhbGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHN0cm9rZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgc3Ryb2tlV2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXG4gIHN0cm9rZURhc2hhcnJheTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdGlja0NsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdGlja0Zvcm1hdDogUHJvcFR5cGVzLmZ1bmMsXG4gIHRpY2tMYWJlbFByb3BzOiBQcm9wVHlwZXMuZnVuYyxcbiAgdGlja0xlbmd0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgdGlja1N0cm9rZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdGlja1RyYW5zZm9ybTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdGlja1ZhbHVlczogUHJvcFR5cGVzLmFycmF5LFxuICB0aWNrQ29tcG9uZW50OiBQcm9wVHlwZXMuZnVuYyxcbiAgdG9wOiBQcm9wVHlwZXMubnVtYmVyLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIEF4aXMoX3JlZikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgYXhpc0NsYXNzTmFtZSA9IF9yZWYuYXhpc0NsYXNzTmFtZSxcbiAgICAgIGF4aXNMaW5lQ2xhc3NOYW1lID0gX3JlZi5heGlzTGluZUNsYXNzTmFtZSxcbiAgICAgIF9yZWYkaGlkZUF4aXNMaW5lID0gX3JlZi5oaWRlQXhpc0xpbmUsXG4gICAgICBoaWRlQXhpc0xpbmUgPSBfcmVmJGhpZGVBeGlzTGluZSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJGhpZGVBeGlzTGluZSxcbiAgICAgIF9yZWYkaGlkZVRpY2tzID0gX3JlZi5oaWRlVGlja3MsXG4gICAgICBoaWRlVGlja3MgPSBfcmVmJGhpZGVUaWNrcyA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJGhpZGVUaWNrcyxcbiAgICAgIF9yZWYkaGlkZVplcm8gPSBfcmVmLmhpZGVaZXJvLFxuICAgICAgaGlkZVplcm8gPSBfcmVmJGhpZGVaZXJvID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkaGlkZVplcm8sXG4gICAgICBfcmVmJGxhYmVsID0gX3JlZi5sYWJlbCxcbiAgICAgIGxhYmVsID0gX3JlZiRsYWJlbCA9PT0gdW5kZWZpbmVkID8gJycgOiBfcmVmJGxhYmVsLFxuICAgICAgbGFiZWxDbGFzc05hbWUgPSBfcmVmLmxhYmVsQ2xhc3NOYW1lLFxuICAgICAgX3JlZiRsYWJlbE9mZnNldCA9IF9yZWYubGFiZWxPZmZzZXQsXG4gICAgICBsYWJlbE9mZnNldCA9IF9yZWYkbGFiZWxPZmZzZXQgPT09IHVuZGVmaW5lZCA/IDE0IDogX3JlZiRsYWJlbE9mZnNldCxcbiAgICAgIF9yZWYkbGFiZWxQcm9wcyA9IF9yZWYubGFiZWxQcm9wcyxcbiAgICAgIGxhYmVsUHJvcHMgPSBfcmVmJGxhYmVsUHJvcHMgPT09IHVuZGVmaW5lZCA/IHtcbiAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJyxcbiAgICBmb250RmFtaWx5OiAnQXJpYWwnLFxuICAgIGZvbnRTaXplOiAxMCxcbiAgICBmaWxsOiAnYmxhY2snXG4gIH0gOiBfcmVmJGxhYmVsUHJvcHMsXG4gICAgICBfcmVmJGxlZnQgPSBfcmVmLmxlZnQsXG4gICAgICBsZWZ0ID0gX3JlZiRsZWZ0ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiRsZWZ0LFxuICAgICAgX3JlZiRudW1UaWNrcyA9IF9yZWYubnVtVGlja3MsXG4gICAgICBudW1UaWNrcyA9IF9yZWYkbnVtVGlja3MgPT09IHVuZGVmaW5lZCA/IDEwIDogX3JlZiRudW1UaWNrcyxcbiAgICAgIF9yZWYkb3JpZW50YXRpb24gPSBfcmVmLm9yaWVudGF0aW9uLFxuICAgICAgb3JpZW50YXRpb24gPSBfcmVmJG9yaWVudGF0aW9uID09PSB1bmRlZmluZWQgPyBPUklFTlQuYm90dG9tIDogX3JlZiRvcmllbnRhdGlvbixcbiAgICAgIF9yZWYkcmFuZ2VQYWRkaW5nID0gX3JlZi5yYW5nZVBhZGRpbmcsXG4gICAgICByYW5nZVBhZGRpbmcgPSBfcmVmJHJhbmdlUGFkZGluZyA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkcmFuZ2VQYWRkaW5nLFxuICAgICAgc2NhbGUgPSBfcmVmLnNjYWxlLFxuICAgICAgX3JlZiRzdHJva2UgPSBfcmVmLnN0cm9rZSxcbiAgICAgIHN0cm9rZSA9IF9yZWYkc3Ryb2tlID09PSB1bmRlZmluZWQgPyAnYmxhY2snIDogX3JlZiRzdHJva2UsXG4gICAgICBfcmVmJHN0cm9rZVdpZHRoID0gX3JlZi5zdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZVdpZHRoID0gX3JlZiRzdHJva2VXaWR0aCA9PT0gdW5kZWZpbmVkID8gMSA6IF9yZWYkc3Ryb2tlV2lkdGgsXG4gICAgICBzdHJva2VEYXNoYXJyYXkgPSBfcmVmLnN0cm9rZURhc2hhcnJheSxcbiAgICAgIHRpY2tDbGFzc05hbWUgPSBfcmVmLnRpY2tDbGFzc05hbWUsXG4gICAgICB0aWNrRm9ybWF0ID0gX3JlZi50aWNrRm9ybWF0LFxuICAgICAgX3JlZiR0aWNrTGFiZWxQcm9wcyA9IF9yZWYudGlja0xhYmVsUHJvcHMsXG4gICAgICB0aWNrTGFiZWxQcm9wcyA9IF9yZWYkdGlja0xhYmVsUHJvcHMgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uICh0aWNrVmFsdWUsIGluZGV4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHRBbmNob3I6ICdtaWRkbGUnLFxuICAgICAgZm9udEZhbWlseTogJ0FyaWFsJyxcbiAgICAgIGZvbnRTaXplOiAxMCxcbiAgICAgIGZpbGw6ICdibGFjaydcbiAgICB9O1xuICB9IDogX3JlZiR0aWNrTGFiZWxQcm9wcyxcbiAgICAgIF9yZWYkdGlja0xlbmd0aCA9IF9yZWYudGlja0xlbmd0aCxcbiAgICAgIHRpY2tMZW5ndGggPSBfcmVmJHRpY2tMZW5ndGggPT09IHVuZGVmaW5lZCA/IDggOiBfcmVmJHRpY2tMZW5ndGgsXG4gICAgICBfcmVmJHRpY2tTdHJva2UgPSBfcmVmLnRpY2tTdHJva2UsXG4gICAgICB0aWNrU3Ryb2tlID0gX3JlZiR0aWNrU3Ryb2tlID09PSB1bmRlZmluZWQgPyAnYmxhY2snIDogX3JlZiR0aWNrU3Ryb2tlLFxuICAgICAgdGlja1RyYW5zZm9ybSA9IF9yZWYudGlja1RyYW5zZm9ybSxcbiAgICAgIHRpY2tWYWx1ZXMgPSBfcmVmLnRpY2tWYWx1ZXMsXG4gICAgICB0aWNrQ29tcG9uZW50ID0gX3JlZi50aWNrQ29tcG9uZW50LFxuICAgICAgX3JlZiR0b3AgPSBfcmVmLnRvcCxcbiAgICAgIHRvcCA9IF9yZWYkdG9wID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiR0b3A7XG5cbiAgdmFyIHZhbHVlcyA9IHNjYWxlLnRpY2tzID8gc2NhbGUudGlja3MobnVtVGlja3MpIDogc2NhbGUuZG9tYWluKCk7XG4gIGlmICh0aWNrVmFsdWVzKSB2YWx1ZXMgPSB0aWNrVmFsdWVzO1xuICB2YXIgZm9ybWF0ID0gc2NhbGUudGlja0Zvcm1hdCA/IHNjYWxlLnRpY2tGb3JtYXQoKSA6IGlkZW50aXR5O1xuICBpZiAodGlja0Zvcm1hdCkgZm9ybWF0ID0gdGlja0Zvcm1hdDtcblxuICB2YXIgcmFuZ2UgPSBzY2FsZS5yYW5nZSgpO1xuICB2YXIgcmFuZ2UwID0gcmFuZ2VbMF0gKyAwLjUgLSByYW5nZVBhZGRpbmc7XG4gIHZhciByYW5nZTEgPSByYW5nZVtyYW5nZS5sZW5ndGggLSAxXSArIDAuNSArIHJhbmdlUGFkZGluZztcblxuICB2YXIgaG9yaXpvbnRhbCA9IG9yaWVudGF0aW9uICE9PSBPUklFTlQubGVmdCAmJiBvcmllbnRhdGlvbiAhPT0gT1JJRU5ULnJpZ2h0O1xuICB2YXIgaXNMZWZ0ID0gb3JpZW50YXRpb24gPT09IE9SSUVOVC5sZWZ0O1xuICB2YXIgaXNUb3AgPSBvcmllbnRhdGlvbiA9PT0gT1JJRU5ULnRvcDtcbiAgdmFyIHRpY2tTaWduID0gaXNMZWZ0IHx8IGlzVG9wID8gLTEgOiAxO1xuXG4gIHZhciBwb3NpdGlvbiA9IChzY2FsZS5iYW5kd2lkdGggPyBjZW50ZXIgOiBpZGVudGl0eSkoc2NhbGUuY29weSgpKTtcblxuICB2YXIgYXhpc0Zyb21Qb2ludCA9IG5ldyBQb2ludCh7XG4gICAgeDogaG9yaXpvbnRhbCA/IHJhbmdlMCA6IDAsXG4gICAgeTogaG9yaXpvbnRhbCA/IDAgOiByYW5nZTBcbiAgfSk7XG4gIHZhciBheGlzVG9Qb2ludCA9IG5ldyBQb2ludCh7XG4gICAgeDogaG9yaXpvbnRhbCA/IHJhbmdlMSA6IDAsXG4gICAgeTogaG9yaXpvbnRhbCA/IDAgOiByYW5nZTFcbiAgfSk7XG5cbiAgdmFyIHRpY2tMYWJlbEZvbnRTaXplID0gMTA7IC8vIHRyYWNrIHRoZSBtYXggdGljayBsYWJlbCBzaXplIHRvIGNvbXB1dGUgbGFiZWwgb2Zmc2V0XG5cbiAgaWYgKCEhY2hpbGRyZW4pIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgIEdyb3VwLFxuICAgICAgeyBjbGFzc05hbWU6IGN4KCd2eC1heGlzJywgYXhpc0NsYXNzTmFtZSksIHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH0sXG4gICAgICBjaGlsZHJlbih7XG4gICAgICAgIGF4aXNGcm9tUG9pbnQ6IGF4aXNGcm9tUG9pbnQsXG4gICAgICAgIGF4aXNUb1BvaW50OiBheGlzVG9Qb2ludCxcbiAgICAgICAgaG9yaXpvbnRhbDogaG9yaXpvbnRhbCxcbiAgICAgICAgdGlja1NpZ246IHRpY2tTaWduLFxuICAgICAgICBudW1UaWNrczogbnVtVGlja3MsXG4gICAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgICAgcmFuZ2VQYWRkaW5nOiByYW5nZVBhZGRpbmcsXG4gICAgICAgIHRpY2tMZW5ndGg6IHRpY2tMZW5ndGgsXG4gICAgICAgIHRpY2tGb3JtYXQ6IGZvcm1hdCxcbiAgICAgICAgdGlja1Bvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgICAgdGlja3M6IHZhbHVlcy5tYXAoZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgICAgIHZhciBmcm9tID0gbmV3IFBvaW50KHtcbiAgICAgICAgICAgIHg6IGhvcml6b250YWwgPyBwb3NpdGlvbih2YWx1ZSkgOiAwLFxuICAgICAgICAgICAgeTogaG9yaXpvbnRhbCA/IDAgOiBwb3NpdGlvbih2YWx1ZSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgdG8gPSBuZXcgUG9pbnQoe1xuICAgICAgICAgICAgeDogaG9yaXpvbnRhbCA/IHBvc2l0aW9uKHZhbHVlKSA6IHRpY2tTaWduICogdGlja0xlbmd0aCxcbiAgICAgICAgICAgIHk6IGhvcml6b250YWwgPyB0aWNrTGVuZ3RoICogdGlja1NpZ24gOiBwb3NpdGlvbih2YWx1ZSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgZnJvbTogZnJvbSxcbiAgICAgICAgICAgIHRvOiB0byxcbiAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlOiBmb3JtYXQodmFsdWUsIGluZGV4KVxuICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICBHcm91cCxcbiAgICB7IGNsYXNzTmFtZTogY3goJ3Z4LWF4aXMnLCBheGlzQ2xhc3NOYW1lKSwgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfSxcbiAgICB2YWx1ZXMubWFwKGZ1bmN0aW9uICh2YWwsIGluZGV4KSB7XG4gICAgICBpZiAoaGlkZVplcm8gJiYgdmFsID09PSAwKSByZXR1cm4gbnVsbDtcblxuICAgICAgdmFyIHRpY2tGcm9tUG9pbnQgPSBuZXcgUG9pbnQoe1xuICAgICAgICB4OiBob3Jpem9udGFsID8gcG9zaXRpb24odmFsKSA6IDAsXG4gICAgICAgIHk6IGhvcml6b250YWwgPyAwIDogcG9zaXRpb24odmFsKVxuICAgICAgfSk7XG4gICAgICB2YXIgdGlja1RvUG9pbnQgPSBuZXcgUG9pbnQoe1xuICAgICAgICB4OiBob3Jpem9udGFsID8gcG9zaXRpb24odmFsKSA6IHRpY2tTaWduICogdGlja0xlbmd0aCxcbiAgICAgICAgeTogaG9yaXpvbnRhbCA/IHRpY2tMZW5ndGggKiB0aWNrU2lnbiA6IHBvc2l0aW9uKHZhbClcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgdGlja0xhYmVsUHJvcHNPYmogPSB0aWNrTGFiZWxQcm9wcyh2YWwsIGluZGV4KTtcbiAgICAgIHRpY2tMYWJlbEZvbnRTaXplID0gTWF0aC5tYXgodGlja0xhYmVsRm9udFNpemUsIHRpY2tMYWJlbFByb3BzT2JqLmZvbnRTaXplIHx8IDApO1xuXG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgR3JvdXAsXG4gICAgICAgIHtcbiAgICAgICAgICBrZXk6ICd2eC10aWNrLScgKyB2YWwgKyAnLScgKyBpbmRleCxcbiAgICAgICAgICBjbGFzc05hbWU6IGN4KCd2eC1heGlzLXRpY2snLCB0aWNrQ2xhc3NOYW1lKSxcbiAgICAgICAgICB0cmFuc2Zvcm06IHRpY2tUcmFuc2Zvcm1cbiAgICAgICAgfSxcbiAgICAgICAgIWhpZGVUaWNrcyAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KExpbmUsIHsgZnJvbTogdGlja0Zyb21Qb2ludCwgdG86IHRpY2tUb1BvaW50LCBzdHJva2U6IHRpY2tTdHJva2UgfSksXG4gICAgICAgIHRpY2tDb21wb25lbnQgPyB0aWNrQ29tcG9uZW50KF9leHRlbmRzKHtcbiAgICAgICAgICB4OiB0aWNrVG9Qb2ludC54LFxuICAgICAgICAgIHk6IHRpY2tUb1BvaW50LnkgKyAoaG9yaXpvbnRhbCAmJiAhaXNUb3AgPyB0aWNrTGFiZWxGb250U2l6ZSA6IDApLFxuICAgICAgICAgIGZvcm1hdHRlZFZhbHVlOiBmb3JtYXQodmFsLCBpbmRleClcbiAgICAgICAgfSwgdGlja0xhYmVsUHJvcHNPYmopKSA6IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgVGV4dCxcbiAgICAgICAgICBfZXh0ZW5kcyh7XG4gICAgICAgICAgICB4OiB0aWNrVG9Qb2ludC54LFxuICAgICAgICAgICAgeTogdGlja1RvUG9pbnQueSArIChob3Jpem9udGFsICYmICFpc1RvcCA/IHRpY2tMYWJlbEZvbnRTaXplIDogMClcbiAgICAgICAgICB9LCB0aWNrTGFiZWxQcm9wc09iaiksXG4gICAgICAgICAgZm9ybWF0KHZhbCwgaW5kZXgpXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSksXG4gICAgIWhpZGVBeGlzTGluZSAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KExpbmUsIHtcbiAgICAgIGNsYXNzTmFtZTogY3goJ3Z4LWF4aXMtbGluZScsIGF4aXNMaW5lQ2xhc3NOYW1lKSxcbiAgICAgIGZyb206IGF4aXNGcm9tUG9pbnQsXG4gICAgICB0bzogYXhpc1RvUG9pbnQsXG4gICAgICBzdHJva2U6IHN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZURhc2hhcnJheTogc3Ryb2tlRGFzaGFycmF5XG4gICAgfSksXG4gICAgbGFiZWwgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgIFRleHQsXG4gICAgICBfZXh0ZW5kcyh7XG4gICAgICAgIGNsYXNzTmFtZTogY3goJ3Z4LWF4aXMtbGFiZWwnLCBsYWJlbENsYXNzTmFtZSlcbiAgICAgIH0sIGxhYmVsVHJhbnNmb3JtKHtcbiAgICAgICAgbGFiZWxPZmZzZXQ6IGxhYmVsT2Zmc2V0LFxuICAgICAgICBsYWJlbFByb3BzOiBsYWJlbFByb3BzLFxuICAgICAgICBvcmllbnRhdGlvbjogb3JpZW50YXRpb24sXG4gICAgICAgIHJhbmdlOiByYW5nZSxcbiAgICAgICAgdGlja0xhYmVsRm9udFNpemU6IHRpY2tMYWJlbEZvbnRTaXplLFxuICAgICAgICB0aWNrTGVuZ3RoOiB0aWNrTGVuZ3RoXG4gICAgICB9KSwgbGFiZWxQcm9wcyksXG4gICAgICBsYWJlbFxuICAgIClcbiAgKTtcbn1cblxuQXhpcy5wcm9wVHlwZXMgPSBwcm9wVHlwZXM7XG5cbnZhciBwcm9wVHlwZXMkMSA9IHtcbiAgYXhpc0NsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgYXhpc0xpbmVDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGhpZGVBeGlzTGluZTogUHJvcFR5cGVzLmJvb2wsXG4gIGhpZGVUaWNrczogUHJvcFR5cGVzLmJvb2wsXG4gIGhpZGVaZXJvOiBQcm9wVHlwZXMuYm9vbCxcbiAgbGFiZWw6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGxhYmVsQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBsYWJlbE9mZnNldDogUHJvcFR5cGVzLm51bWJlcixcbiAgbGFiZWxQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcbiAgbGVmdDogUHJvcFR5cGVzLm51bWJlcixcbiAgbnVtVGlja3M6IFByb3BUeXBlcy5udW1iZXIsXG4gIHJhbmdlUGFkZGluZzogUHJvcFR5cGVzLm51bWJlcixcbiAgc2NhbGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHN0cm9rZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgc3Ryb2tlV2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXG4gIHN0cm9rZURhc2hhcnJheTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdGlja0NsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdGlja0Zvcm1hdDogUHJvcFR5cGVzLmZ1bmMsXG4gIHRpY2tMYWJlbFByb3BzOiBQcm9wVHlwZXMuZnVuYyxcbiAgdGlja0xlbmd0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgdGlja1N0cm9rZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdGlja1RyYW5zZm9ybTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdGlja1ZhbHVlczogUHJvcFR5cGVzLmFycmF5LFxuICB0aWNrQ29tcG9uZW50OiBQcm9wVHlwZXMuZnVuYyxcbiAgdG9wOiBQcm9wVHlwZXMubnVtYmVyLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIEF4aXNMZWZ0KF9yZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIGF4aXNDbGFzc05hbWUgPSBfcmVmLmF4aXNDbGFzc05hbWUsXG4gICAgICBheGlzTGluZUNsYXNzTmFtZSA9IF9yZWYuYXhpc0xpbmVDbGFzc05hbWUsXG4gICAgICBoaWRlQXhpc0xpbmUgPSBfcmVmLmhpZGVBeGlzTGluZSxcbiAgICAgIGhpZGVUaWNrcyA9IF9yZWYuaGlkZVRpY2tzLFxuICAgICAgaGlkZVplcm8gPSBfcmVmLmhpZGVaZXJvLFxuICAgICAgbGFiZWwgPSBfcmVmLmxhYmVsLFxuICAgICAgbGFiZWxDbGFzc05hbWUgPSBfcmVmLmxhYmVsQ2xhc3NOYW1lLFxuICAgICAgX3JlZiRsYWJlbE9mZnNldCA9IF9yZWYubGFiZWxPZmZzZXQsXG4gICAgICBsYWJlbE9mZnNldCA9IF9yZWYkbGFiZWxPZmZzZXQgPT09IHVuZGVmaW5lZCA/IDM2IDogX3JlZiRsYWJlbE9mZnNldCxcbiAgICAgIGxhYmVsUHJvcHMgPSBfcmVmLmxhYmVsUHJvcHMsXG4gICAgICBsZWZ0ID0gX3JlZi5sZWZ0LFxuICAgICAgbnVtVGlja3MgPSBfcmVmLm51bVRpY2tzLFxuICAgICAgcmFuZ2VQYWRkaW5nID0gX3JlZi5yYW5nZVBhZGRpbmcsXG4gICAgICBzY2FsZSA9IF9yZWYuc2NhbGUsXG4gICAgICBzdHJva2UgPSBfcmVmLnN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoID0gX3JlZi5zdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZURhc2hhcnJheSA9IF9yZWYuc3Ryb2tlRGFzaGFycmF5LFxuICAgICAgdGlja0NsYXNzTmFtZSA9IF9yZWYudGlja0NsYXNzTmFtZSxcbiAgICAgIHRpY2tGb3JtYXQgPSBfcmVmLnRpY2tGb3JtYXQsXG4gICAgICBfcmVmJHRpY2tMYWJlbFByb3BzID0gX3JlZi50aWNrTGFiZWxQcm9wcyxcbiAgICAgIHRpY2tMYWJlbFByb3BzID0gX3JlZiR0aWNrTGFiZWxQcm9wcyA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgdmFyIHRpY2sgPSBfcmVmMi50aWNrLFxuICAgICAgICBpbmRleCA9IF9yZWYyLmluZGV4O1xuICAgIHJldHVybiB7XG4gICAgICBkeDogJy0wLjI1ZW0nLFxuICAgICAgZHk6ICcwLjI1ZW0nLFxuICAgICAgZmlsbDogJ2JsYWNrJyxcbiAgICAgIGZvbnRGYW1pbHk6ICdBcmlhbCcsXG4gICAgICBmb250U2l6ZTogMTAsXG4gICAgICB0ZXh0QW5jaG9yOiAnZW5kJ1xuICAgIH07XG4gIH0gOiBfcmVmJHRpY2tMYWJlbFByb3BzLFxuICAgICAgX3JlZiR0aWNrTGVuZ3RoID0gX3JlZi50aWNrTGVuZ3RoLFxuICAgICAgdGlja0xlbmd0aCA9IF9yZWYkdGlja0xlbmd0aCA9PT0gdW5kZWZpbmVkID8gOCA6IF9yZWYkdGlja0xlbmd0aCxcbiAgICAgIHRpY2tTdHJva2UgPSBfcmVmLnRpY2tTdHJva2UsXG4gICAgICB0aWNrVHJhbnNmb3JtID0gX3JlZi50aWNrVHJhbnNmb3JtLFxuICAgICAgdGlja1ZhbHVlcyA9IF9yZWYudGlja1ZhbHVlcyxcbiAgICAgIHRpY2tDb21wb25lbnQgPSBfcmVmLnRpY2tDb21wb25lbnQsXG4gICAgICB0b3AgPSBfcmVmLnRvcDtcblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChBeGlzLCB7XG4gICAgYXhpc0NsYXNzTmFtZTogY3goJ3Z4LWF4aXMtbGVmdCcsIGF4aXNDbGFzc05hbWUpLFxuICAgIGF4aXNMaW5lQ2xhc3NOYW1lOiBheGlzTGluZUNsYXNzTmFtZSxcbiAgICBoaWRlQXhpc0xpbmU6IGhpZGVBeGlzTGluZSxcbiAgICBoaWRlVGlja3M6IGhpZGVUaWNrcyxcbiAgICBoaWRlWmVybzogaGlkZVplcm8sXG4gICAgbGFiZWw6IGxhYmVsLFxuICAgIGxhYmVsQ2xhc3NOYW1lOiBsYWJlbENsYXNzTmFtZSxcbiAgICBsYWJlbE9mZnNldDogbGFiZWxPZmZzZXQsXG4gICAgbGFiZWxQcm9wczogbGFiZWxQcm9wcyxcbiAgICBsZWZ0OiBsZWZ0LFxuICAgIG51bVRpY2tzOiBudW1UaWNrcyxcbiAgICBvcmllbnRhdGlvbjogT1JJRU5ULmxlZnQsXG4gICAgcmFuZ2VQYWRkaW5nOiByYW5nZVBhZGRpbmcsXG4gICAgc2NhbGU6IHNjYWxlLFxuICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICBzdHJva2VEYXNoYXJyYXk6IHN0cm9rZURhc2hhcnJheSxcbiAgICB0aWNrQ2xhc3NOYW1lOiB0aWNrQ2xhc3NOYW1lLFxuICAgIHRpY2tGb3JtYXQ6IHRpY2tGb3JtYXQsXG4gICAgdGlja0xhYmVsUHJvcHM6IHRpY2tMYWJlbFByb3BzLFxuICAgIHRpY2tMZW5ndGg6IHRpY2tMZW5ndGgsXG4gICAgdGlja1N0cm9rZTogdGlja1N0cm9rZSxcbiAgICB0aWNrVHJhbnNmb3JtOiB0aWNrVHJhbnNmb3JtLFxuICAgIHRpY2tWYWx1ZXM6IHRpY2tWYWx1ZXMsXG4gICAgdGlja0NvbXBvbmVudDogdGlja0NvbXBvbmVudCxcbiAgICB0b3A6IHRvcCxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgfSk7XG59XG5cbkF4aXNMZWZ0LnByb3BUeXBlcyA9IHByb3BUeXBlcyQxO1xuXG52YXIgcHJvcFR5cGVzJDIgPSB7XG4gIGF4aXNDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGF4aXNMaW5lQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBoaWRlQXhpc0xpbmU6IFByb3BUeXBlcy5ib29sLFxuICBoaWRlVGlja3M6IFByb3BUeXBlcy5ib29sLFxuICBoaWRlWmVybzogUHJvcFR5cGVzLmJvb2wsXG4gIGxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBsYWJlbENsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgbGFiZWxPZmZzZXQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIGxhYmVsUHJvcHM6IFByb3BUeXBlcy5vYmplY3QsXG4gIGxlZnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIG51bVRpY2tzOiBQcm9wVHlwZXMubnVtYmVyLFxuICByYW5nZVBhZGRpbmc6IFByb3BUeXBlcy5udW1iZXIsXG4gIHNjYWxlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBzdHJva2U6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHN0cm9rZVdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLFxuICBzdHJva2VEYXNoYXJyYXk6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRpY2tDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRpY2tGb3JtYXQ6IFByb3BUeXBlcy5mdW5jLFxuICB0aWNrTGFiZWxQcm9wczogUHJvcFR5cGVzLmZ1bmMsXG4gIHRpY2tMZW5ndGg6IFByb3BUeXBlcy5udW1iZXIsXG4gIHRpY2tTdHJva2U6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRpY2tUcmFuc2Zvcm06IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRpY2tWYWx1ZXM6IFByb3BUeXBlcy5hcnJheSxcbiAgdGlja0NvbXBvbmVudDogUHJvcFR5cGVzLmZ1bmMsXG4gIHRvcDogUHJvcFR5cGVzLm51bWJlcixcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5mdW5jXG59O1xuXG5mdW5jdGlvbiBBeGlzUmlnaHQoX3JlZikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgYXhpc0NsYXNzTmFtZSA9IF9yZWYuYXhpc0NsYXNzTmFtZSxcbiAgICAgIGF4aXNMaW5lQ2xhc3NOYW1lID0gX3JlZi5heGlzTGluZUNsYXNzTmFtZSxcbiAgICAgIGhpZGVBeGlzTGluZSA9IF9yZWYuaGlkZUF4aXNMaW5lLFxuICAgICAgaGlkZVRpY2tzID0gX3JlZi5oaWRlVGlja3MsXG4gICAgICBoaWRlWmVybyA9IF9yZWYuaGlkZVplcm8sXG4gICAgICBsYWJlbCA9IF9yZWYubGFiZWwsXG4gICAgICBsYWJlbENsYXNzTmFtZSA9IF9yZWYubGFiZWxDbGFzc05hbWUsXG4gICAgICBfcmVmJGxhYmVsT2Zmc2V0ID0gX3JlZi5sYWJlbE9mZnNldCxcbiAgICAgIGxhYmVsT2Zmc2V0ID0gX3JlZiRsYWJlbE9mZnNldCA9PT0gdW5kZWZpbmVkID8gMzYgOiBfcmVmJGxhYmVsT2Zmc2V0LFxuICAgICAgbGFiZWxQcm9wcyA9IF9yZWYubGFiZWxQcm9wcyxcbiAgICAgIGxlZnQgPSBfcmVmLmxlZnQsXG4gICAgICBudW1UaWNrcyA9IF9yZWYubnVtVGlja3MsXG4gICAgICByYW5nZVBhZGRpbmcgPSBfcmVmLnJhbmdlUGFkZGluZyxcbiAgICAgIHNjYWxlID0gX3JlZi5zY2FsZSxcbiAgICAgIHN0cm9rZSA9IF9yZWYuc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGggPSBfcmVmLnN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlRGFzaGFycmF5ID0gX3JlZi5zdHJva2VEYXNoYXJyYXksXG4gICAgICB0aWNrQ2xhc3NOYW1lID0gX3JlZi50aWNrQ2xhc3NOYW1lLFxuICAgICAgdGlja0Zvcm1hdCA9IF9yZWYudGlja0Zvcm1hdCxcbiAgICAgIF9yZWYkdGlja0xhYmVsUHJvcHMgPSBfcmVmLnRpY2tMYWJlbFByb3BzLFxuICAgICAgdGlja0xhYmVsUHJvcHMgPSBfcmVmJHRpY2tMYWJlbFByb3BzID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICB2YXIgdGljayA9IF9yZWYyLnRpY2ssXG4gICAgICAgIGluZGV4ID0gX3JlZjIuaW5kZXg7XG4gICAgcmV0dXJuIHtcbiAgICAgIGR4OiAnMC4yNWVtJyxcbiAgICAgIGR5OiAnMC4yNWVtJyxcbiAgICAgIGZpbGw6ICdibGFjaycsXG4gICAgICBmb250RmFtaWx5OiAnQXJpYWwnLFxuICAgICAgZm9udFNpemU6IDEwLFxuICAgICAgdGV4dEFuY2hvcjogJ3N0YXJ0J1xuICAgIH07XG4gIH0gOiBfcmVmJHRpY2tMYWJlbFByb3BzLFxuICAgICAgX3JlZiR0aWNrTGVuZ3RoID0gX3JlZi50aWNrTGVuZ3RoLFxuICAgICAgdGlja0xlbmd0aCA9IF9yZWYkdGlja0xlbmd0aCA9PT0gdW5kZWZpbmVkID8gOCA6IF9yZWYkdGlja0xlbmd0aCxcbiAgICAgIHRpY2tTdHJva2UgPSBfcmVmLnRpY2tTdHJva2UsXG4gICAgICB0aWNrVHJhbnNmb3JtID0gX3JlZi50aWNrVHJhbnNmb3JtLFxuICAgICAgdGlja1ZhbHVlcyA9IF9yZWYudGlja1ZhbHVlcyxcbiAgICAgIHRpY2tDb21wb25lbnQgPSBfcmVmLnRpY2tDb21wb25lbnQsXG4gICAgICB0b3AgPSBfcmVmLnRvcDtcblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChBeGlzLCB7XG4gICAgYXhpc0NsYXNzTmFtZTogY3goJ3Z4LWF4aXMtcmlnaHQnLCBheGlzQ2xhc3NOYW1lKSxcbiAgICBheGlzTGluZUNsYXNzTmFtZTogYXhpc0xpbmVDbGFzc05hbWUsXG4gICAgaGlkZUF4aXNMaW5lOiBoaWRlQXhpc0xpbmUsXG4gICAgaGlkZVRpY2tzOiBoaWRlVGlja3MsXG4gICAgaGlkZVplcm86IGhpZGVaZXJvLFxuICAgIGxhYmVsOiBsYWJlbCxcbiAgICBsYWJlbENsYXNzTmFtZTogbGFiZWxDbGFzc05hbWUsXG4gICAgbGFiZWxPZmZzZXQ6IGxhYmVsT2Zmc2V0LFxuICAgIGxhYmVsUHJvcHM6IGxhYmVsUHJvcHMsXG4gICAgbGVmdDogbGVmdCxcbiAgICBudW1UaWNrczogbnVtVGlja3MsXG4gICAgb3JpZW50YXRpb246IE9SSUVOVC5yaWdodCxcbiAgICByYW5nZVBhZGRpbmc6IHJhbmdlUGFkZGluZyxcbiAgICBzY2FsZTogc2NhbGUsXG4gICAgc3Ryb2tlOiBzdHJva2UsXG4gICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLFxuICAgIHN0cm9rZURhc2hhcnJheTogc3Ryb2tlRGFzaGFycmF5LFxuICAgIHRpY2tDbGFzc05hbWU6IHRpY2tDbGFzc05hbWUsXG4gICAgdGlja0Zvcm1hdDogdGlja0Zvcm1hdCxcbiAgICB0aWNrTGFiZWxQcm9wczogdGlja0xhYmVsUHJvcHMsXG4gICAgdGlja0xlbmd0aDogdGlja0xlbmd0aCxcbiAgICB0aWNrU3Ryb2tlOiB0aWNrU3Ryb2tlLFxuICAgIHRpY2tUcmFuc2Zvcm06IHRpY2tUcmFuc2Zvcm0sXG4gICAgdGlja1ZhbHVlczogdGlja1ZhbHVlcyxcbiAgICB0aWNrQ29tcG9uZW50OiB0aWNrQ29tcG9uZW50LFxuICAgIHRvcDogdG9wLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICB9KTtcbn1cblxuQXhpc1JpZ2h0LnByb3BUeXBlcyA9IHByb3BUeXBlcyQyO1xuXG52YXIgcHJvcFR5cGVzJDMgPSB7XG4gIGF4aXNDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGF4aXNMaW5lQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBoaWRlQXhpc0xpbmU6IFByb3BUeXBlcy5ib29sLFxuICBoaWRlVGlja3M6IFByb3BUeXBlcy5ib29sLFxuICBoaWRlWmVybzogUHJvcFR5cGVzLmJvb2wsXG4gIGxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBsYWJlbENsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgbGFiZWxPZmZzZXQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIGxhYmVsUHJvcHM6IFByb3BUeXBlcy5vYmplY3QsXG4gIGxlZnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIG51bVRpY2tzOiBQcm9wVHlwZXMubnVtYmVyLFxuICByYW5nZVBhZGRpbmc6IFByb3BUeXBlcy5udW1iZXIsXG4gIHNjYWxlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBzdHJva2U6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHN0cm9rZVdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLFxuICBzdHJva2VEYXNoYXJyYXk6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRpY2tDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRpY2tGb3JtYXQ6IFByb3BUeXBlcy5mdW5jLFxuICB0aWNrTGFiZWxQcm9wczogUHJvcFR5cGVzLmZ1bmMsXG4gIHRpY2tMZW5ndGg6IFByb3BUeXBlcy5udW1iZXIsXG4gIHRpY2tTdHJva2U6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRpY2tUcmFuc2Zvcm06IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRpY2tWYWx1ZXM6IFByb3BUeXBlcy5hcnJheSxcbiAgdGlja0NvbXBvbmVudDogUHJvcFR5cGVzLmZ1bmMsXG4gIHRvcDogUHJvcFR5cGVzLm51bWJlcixcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5mdW5jXG59O1xuXG5mdW5jdGlvbiBBeGlzVG9wKF9yZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIGF4aXNDbGFzc05hbWUgPSBfcmVmLmF4aXNDbGFzc05hbWUsXG4gICAgICBheGlzTGluZUNsYXNzTmFtZSA9IF9yZWYuYXhpc0xpbmVDbGFzc05hbWUsXG4gICAgICBoaWRlQXhpc0xpbmUgPSBfcmVmLmhpZGVBeGlzTGluZSxcbiAgICAgIGhpZGVUaWNrcyA9IF9yZWYuaGlkZVRpY2tzLFxuICAgICAgaGlkZVplcm8gPSBfcmVmLmhpZGVaZXJvLFxuICAgICAgbGFiZWwgPSBfcmVmLmxhYmVsLFxuICAgICAgbGFiZWxDbGFzc05hbWUgPSBfcmVmLmxhYmVsQ2xhc3NOYW1lLFxuICAgICAgX3JlZiRsYWJlbE9mZnNldCA9IF9yZWYubGFiZWxPZmZzZXQsXG4gICAgICBsYWJlbE9mZnNldCA9IF9yZWYkbGFiZWxPZmZzZXQgPT09IHVuZGVmaW5lZCA/IDggOiBfcmVmJGxhYmVsT2Zmc2V0LFxuICAgICAgbGFiZWxQcm9wcyA9IF9yZWYubGFiZWxQcm9wcyxcbiAgICAgIGxlZnQgPSBfcmVmLmxlZnQsXG4gICAgICBudW1UaWNrcyA9IF9yZWYubnVtVGlja3MsXG4gICAgICByYW5nZVBhZGRpbmcgPSBfcmVmLnJhbmdlUGFkZGluZyxcbiAgICAgIHNjYWxlID0gX3JlZi5zY2FsZSxcbiAgICAgIHN0cm9rZSA9IF9yZWYuc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGggPSBfcmVmLnN0cm9rZVdpZHRoLFxuICAgICAgc3Ryb2tlRGFzaGFycmF5ID0gX3JlZi5zdHJva2VEYXNoYXJyYXksXG4gICAgICB0aWNrQ2xhc3NOYW1lID0gX3JlZi50aWNrQ2xhc3NOYW1lLFxuICAgICAgdGlja0Zvcm1hdCA9IF9yZWYudGlja0Zvcm1hdCxcbiAgICAgIF9yZWYkdGlja0xhYmVsUHJvcHMgPSBfcmVmLnRpY2tMYWJlbFByb3BzLFxuICAgICAgdGlja0xhYmVsUHJvcHMgPSBfcmVmJHRpY2tMYWJlbFByb3BzID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICB2YXIgdGljayA9IF9yZWYyLnRpY2ssXG4gICAgICAgIGluZGV4ID0gX3JlZjIuaW5kZXg7XG4gICAgcmV0dXJuIHtcbiAgICAgIGR5OiAnLTAuMjVlbScsXG4gICAgICBmaWxsOiAnYmxhY2snLFxuICAgICAgZm9udEZhbWlseTogJ0FyaWFsJyxcbiAgICAgIGZvbnRTaXplOiAxMCxcbiAgICAgIHRleHRBbmNob3I6ICdtaWRkbGUnXG4gICAgfTtcbiAgfSA6IF9yZWYkdGlja0xhYmVsUHJvcHMsXG4gICAgICBfcmVmJHRpY2tMZW5ndGggPSBfcmVmLnRpY2tMZW5ndGgsXG4gICAgICB0aWNrTGVuZ3RoID0gX3JlZiR0aWNrTGVuZ3RoID09PSB1bmRlZmluZWQgPyA4IDogX3JlZiR0aWNrTGVuZ3RoLFxuICAgICAgdGlja1N0cm9rZSA9IF9yZWYudGlja1N0cm9rZSxcbiAgICAgIHRpY2tUcmFuc2Zvcm0gPSBfcmVmLnRpY2tUcmFuc2Zvcm0sXG4gICAgICB0aWNrVmFsdWVzID0gX3JlZi50aWNrVmFsdWVzLFxuICAgICAgdGlja0NvbXBvbmVudCA9IF9yZWYudGlja0NvbXBvbmVudCxcbiAgICAgIHRvcCA9IF9yZWYudG9wO1xuXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEF4aXMsIHtcbiAgICBheGlzQ2xhc3NOYW1lOiBjeCgndngtYXhpcy10b3AnLCBheGlzQ2xhc3NOYW1lKSxcbiAgICBheGlzTGluZUNsYXNzTmFtZTogYXhpc0xpbmVDbGFzc05hbWUsXG4gICAgaGlkZUF4aXNMaW5lOiBoaWRlQXhpc0xpbmUsXG4gICAgaGlkZVRpY2tzOiBoaWRlVGlja3MsXG4gICAgaGlkZVplcm86IGhpZGVaZXJvLFxuICAgIGxhYmVsOiBsYWJlbCxcbiAgICBsYWJlbENsYXNzTmFtZTogbGFiZWxDbGFzc05hbWUsXG4gICAgbGFiZWxPZmZzZXQ6IGxhYmVsT2Zmc2V0LFxuICAgIGxhYmVsUHJvcHM6IGxhYmVsUHJvcHMsXG4gICAgbGVmdDogbGVmdCxcbiAgICBudW1UaWNrczogbnVtVGlja3MsXG4gICAgb3JpZW50YXRpb246IE9SSUVOVC50b3AsXG4gICAgcmFuZ2VQYWRkaW5nOiByYW5nZVBhZGRpbmcsXG4gICAgc2NhbGU6IHNjYWxlLFxuICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICBzdHJva2VEYXNoYXJyYXk6IHN0cm9rZURhc2hhcnJheSxcbiAgICB0aWNrQ2xhc3NOYW1lOiB0aWNrQ2xhc3NOYW1lLFxuICAgIHRpY2tGb3JtYXQ6IHRpY2tGb3JtYXQsXG4gICAgdGlja0xhYmVsUHJvcHM6IHRpY2tMYWJlbFByb3BzLFxuICAgIHRpY2tMZW5ndGg6IHRpY2tMZW5ndGgsXG4gICAgdGlja1N0cm9rZTogdGlja1N0cm9rZSxcbiAgICB0aWNrVHJhbnNmb3JtOiB0aWNrVHJhbnNmb3JtLFxuICAgIHRpY2tWYWx1ZXM6IHRpY2tWYWx1ZXMsXG4gICAgdGlja0NvbXBvbmVudDogdGlja0NvbXBvbmVudCxcbiAgICB0b3A6IHRvcCxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgfSk7XG59XG5cbkF4aXNUb3AucHJvcFR5cGVzID0gcHJvcFR5cGVzJDM7XG5cbnZhciBwcm9wVHlwZXMkNCA9IHtcbiAgYXhpc0NsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgYXhpc0xpbmVDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGhpZGVBeGlzTGluZTogUHJvcFR5cGVzLmJvb2wsXG4gIGhpZGVUaWNrczogUHJvcFR5cGVzLmJvb2wsXG4gIGhpZGVaZXJvOiBQcm9wVHlwZXMuYm9vbCxcbiAgbGFiZWw6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGxhYmVsQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBsYWJlbE9mZnNldDogUHJvcFR5cGVzLm51bWJlcixcbiAgbGFiZWxQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcbiAgbGVmdDogUHJvcFR5cGVzLm51bWJlcixcbiAgbnVtVGlja3M6IFByb3BUeXBlcy5udW1iZXIsXG4gIHJhbmdlUGFkZGluZzogUHJvcFR5cGVzLm51bWJlcixcbiAgc2NhbGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHN0cm9rZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgc3Ryb2tlV2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXG4gIHN0cm9rZURhc2hhcnJheTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdGlja0NsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdGlja0Zvcm1hdDogUHJvcFR5cGVzLmZ1bmMsXG4gIHRpY2tMYWJlbFByb3BzOiBQcm9wVHlwZXMuZnVuYyxcbiAgdGlja0xlbmd0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgdGlja1N0cm9rZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdGlja1RyYW5zZm9ybTogUHJvcFR5cGVzLnN0cmluZyxcbiAgdGlja1ZhbHVlczogUHJvcFR5cGVzLmFycmF5LFxuICB0aWNrQ29tcG9uZW50OiBQcm9wVHlwZXMuZnVuYyxcbiAgdG9wOiBQcm9wVHlwZXMubnVtYmVyLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmZ1bmN0aW9uIEF4aXNCb3R0b20oX3JlZikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgYXhpc0NsYXNzTmFtZSA9IF9yZWYuYXhpc0NsYXNzTmFtZSxcbiAgICAgIGF4aXNMaW5lQ2xhc3NOYW1lID0gX3JlZi5heGlzTGluZUNsYXNzTmFtZSxcbiAgICAgIGhpZGVBeGlzTGluZSA9IF9yZWYuaGlkZUF4aXNMaW5lLFxuICAgICAgaGlkZVRpY2tzID0gX3JlZi5oaWRlVGlja3MsXG4gICAgICBoaWRlWmVybyA9IF9yZWYuaGlkZVplcm8sXG4gICAgICBsYWJlbCA9IF9yZWYubGFiZWwsXG4gICAgICBsYWJlbENsYXNzTmFtZSA9IF9yZWYubGFiZWxDbGFzc05hbWUsXG4gICAgICBfcmVmJGxhYmVsT2Zmc2V0ID0gX3JlZi5sYWJlbE9mZnNldCxcbiAgICAgIGxhYmVsT2Zmc2V0ID0gX3JlZiRsYWJlbE9mZnNldCA9PT0gdW5kZWZpbmVkID8gOCA6IF9yZWYkbGFiZWxPZmZzZXQsXG4gICAgICBsYWJlbFByb3BzID0gX3JlZi5sYWJlbFByb3BzLFxuICAgICAgbGVmdCA9IF9yZWYubGVmdCxcbiAgICAgIG51bVRpY2tzID0gX3JlZi5udW1UaWNrcyxcbiAgICAgIHJhbmdlUGFkZGluZyA9IF9yZWYucmFuZ2VQYWRkaW5nLFxuICAgICAgc2NhbGUgPSBfcmVmLnNjYWxlLFxuICAgICAgc3Ryb2tlID0gX3JlZi5zdHJva2UsXG4gICAgICBzdHJva2VXaWR0aCA9IF9yZWYuc3Ryb2tlV2lkdGgsXG4gICAgICBzdHJva2VEYXNoYXJyYXkgPSBfcmVmLnN0cm9rZURhc2hhcnJheSxcbiAgICAgIHRpY2tDbGFzc05hbWUgPSBfcmVmLnRpY2tDbGFzc05hbWUsXG4gICAgICB0aWNrRm9ybWF0ID0gX3JlZi50aWNrRm9ybWF0LFxuICAgICAgX3JlZiR0aWNrTGFiZWxQcm9wcyA9IF9yZWYudGlja0xhYmVsUHJvcHMsXG4gICAgICB0aWNrTGFiZWxQcm9wcyA9IF9yZWYkdGlja0xhYmVsUHJvcHMgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChfcmVmMikge1xuICAgIHZhciB0aWNrID0gX3JlZjIudGljayxcbiAgICAgICAgaW5kZXggPSBfcmVmMi5pbmRleDtcbiAgICByZXR1cm4ge1xuICAgICAgZHk6ICcwLjI1ZW0nLFxuICAgICAgZmlsbDogJ2JsYWNrJyxcbiAgICAgIGZvbnRGYW1pbHk6ICdBcmlhbCcsXG4gICAgICBmb250U2l6ZTogMTAsXG4gICAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJ1xuICAgIH07XG4gIH0gOiBfcmVmJHRpY2tMYWJlbFByb3BzLFxuICAgICAgX3JlZiR0aWNrTGVuZ3RoID0gX3JlZi50aWNrTGVuZ3RoLFxuICAgICAgdGlja0xlbmd0aCA9IF9yZWYkdGlja0xlbmd0aCA9PT0gdW5kZWZpbmVkID8gOCA6IF9yZWYkdGlja0xlbmd0aCxcbiAgICAgIHRpY2tTdHJva2UgPSBfcmVmLnRpY2tTdHJva2UsXG4gICAgICB0aWNrVHJhbnNmb3JtID0gX3JlZi50aWNrVHJhbnNmb3JtLFxuICAgICAgdGlja1ZhbHVlcyA9IF9yZWYudGlja1ZhbHVlcyxcbiAgICAgIHRpY2tDb21wb25lbnQgPSBfcmVmLnRpY2tDb21wb25lbnQsXG4gICAgICB0b3AgPSBfcmVmLnRvcDtcblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChBeGlzLCB7XG4gICAgYXhpc0NsYXNzTmFtZTogY3goJ3Z4LWF4aXMtYm90dG9tJywgYXhpc0NsYXNzTmFtZSksXG4gICAgYXhpc0xpbmVDbGFzc05hbWU6IGF4aXNMaW5lQ2xhc3NOYW1lLFxuICAgIGhpZGVBeGlzTGluZTogaGlkZUF4aXNMaW5lLFxuICAgIGhpZGVUaWNrczogaGlkZVRpY2tzLFxuICAgIGhpZGVaZXJvOiBoaWRlWmVybyxcbiAgICBsYWJlbDogbGFiZWwsXG4gICAgbGFiZWxDbGFzc05hbWU6IGxhYmVsQ2xhc3NOYW1lLFxuICAgIGxhYmVsT2Zmc2V0OiBsYWJlbE9mZnNldCxcbiAgICBsYWJlbFByb3BzOiBsYWJlbFByb3BzLFxuICAgIGxlZnQ6IGxlZnQsXG4gICAgbnVtVGlja3M6IG51bVRpY2tzLFxuICAgIG9yaWVudGF0aW9uOiBPUklFTlQuYm90dG9tLFxuICAgIHJhbmdlUGFkZGluZzogcmFuZ2VQYWRkaW5nLFxuICAgIHNjYWxlOiBzY2FsZSxcbiAgICBzdHJva2U6IHN0cm9rZSxcbiAgICBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsXG4gICAgc3Ryb2tlRGFzaGFycmF5OiBzdHJva2VEYXNoYXJyYXksXG4gICAgdGlja0NsYXNzTmFtZTogdGlja0NsYXNzTmFtZSxcbiAgICB0aWNrRm9ybWF0OiB0aWNrRm9ybWF0LFxuICAgIHRpY2tMYWJlbFByb3BzOiB0aWNrTGFiZWxQcm9wcyxcbiAgICB0aWNrTGVuZ3RoOiB0aWNrTGVuZ3RoLFxuICAgIHRpY2tTdHJva2U6IHRpY2tTdHJva2UsXG4gICAgdGlja1RyYW5zZm9ybTogdGlja1RyYW5zZm9ybSxcbiAgICB0aWNrVmFsdWVzOiB0aWNrVmFsdWVzLFxuICAgIHRpY2tDb21wb25lbnQ6IHRpY2tDb21wb25lbnQsXG4gICAgdG9wOiB0b3AsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gIH0pO1xufVxuXG5BeGlzQm90dG9tLnByb3BUeXBlcyA9IHByb3BUeXBlcyQ0O1xuXG5leHBvcnQgeyBBeGlzLCBBeGlzTGVmdCwgQXhpc1JpZ2h0LCBBeGlzVG9wLCBBeGlzQm90dG9tLCBPUklFTlQgYXMgT3JpZW50YXRpb24gfTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1439\n")},1722:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Text; });\n/* unused harmony export getStringWidth */\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var reduce_css_calc__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1397);\n/* harmony import */ var reduce_css_calc__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(reduce_css_calc__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n\nvar commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;\n\nvar _freeGlobal = freeGlobal;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = _freeGlobal || freeSelf || Function('return this')();\n\nvar _root = root;\n\n/** Built-in value references. */\nvar Symbol$1 = _root.Symbol;\n\nvar _Symbol = Symbol$1;\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nvar _getRawTag = getRawTag;\n\n/** Used for built-in method references. */\nvar objectProto$1 = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString$1 = objectProto$1.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString$1.call(value);\n}\n\nvar _objectToString = objectToString;\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag$1 && symToStringTag$1 in Object(value))\n    ? _getRawTag(value)\n    : _objectToString(value);\n}\n\nvar _baseGetTag = baseGetTag;\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nvar isObject_1 = isObject;\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject_1(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = _baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nvar isFunction_1 = isFunction;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = _root['__core-js_shared__'];\n\nvar _coreJsData = coreJsData;\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nvar _isMasked = isMasked;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nvar _toSource = toSource;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto$1 = Function.prototype,\n    objectProto$2 = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString$1 = funcProto$1.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$1 = objectProto$2.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString$1.call(hasOwnProperty$1).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject_1(value) || _isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(_toSource(value));\n}\n\nvar _baseIsNative = baseIsNative;\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nvar _getValue = getValue;\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = _getValue(object, key);\n  return _baseIsNative(value) ? value : undefined;\n}\n\nvar _getNative = getNative;\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = _getNative(Object, 'create');\n\nvar _nativeCreate = nativeCreate;\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = _nativeCreate ? _nativeCreate(null) : {};\n  this.size = 0;\n}\n\nvar _hashClear = hashClear;\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nvar _hashDelete = hashDelete;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto$3 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$2 = objectProto$3.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (_nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty$2.call(data, key) ? data[key] : undefined;\n}\n\nvar _hashGet = hashGet;\n\n/** Used for built-in method references. */\nvar objectProto$4 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$3 = objectProto$4.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return _nativeCreate ? (data[key] !== undefined) : hasOwnProperty$3.call(data, key);\n}\n\nvar _hashHas = hashHas;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED$1 = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (_nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;\n  return this;\n}\n\nvar _hashSet = hashSet;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = _hashClear;\nHash.prototype['delete'] = _hashDelete;\nHash.prototype.get = _hashGet;\nHash.prototype.has = _hashHas;\nHash.prototype.set = _hashSet;\n\nvar _Hash = Hash;\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nvar _listCacheClear = listCacheClear;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nvar eq_1 = eq;\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq_1(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nvar _assocIndexOf = assocIndexOf;\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = _assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nvar _listCacheDelete = listCacheDelete;\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = _assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nvar _listCacheGet = listCacheGet;\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return _assocIndexOf(this.__data__, key) > -1;\n}\n\nvar _listCacheHas = listCacheHas;\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = _assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nvar _listCacheSet = listCacheSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = _listCacheClear;\nListCache.prototype['delete'] = _listCacheDelete;\nListCache.prototype.get = _listCacheGet;\nListCache.prototype.has = _listCacheHas;\nListCache.prototype.set = _listCacheSet;\n\nvar _ListCache = ListCache;\n\n/* Built-in method references that are verified to be native. */\nvar Map = _getNative(_root, 'Map');\n\nvar _Map = Map;\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new _Hash,\n    'map': new (_Map || _ListCache),\n    'string': new _Hash\n  };\n}\n\nvar _mapCacheClear = mapCacheClear;\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nvar _isKeyable = isKeyable;\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return _isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nvar _getMapData = getMapData;\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = _getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nvar _mapCacheDelete = mapCacheDelete;\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return _getMapData(this, key).get(key);\n}\n\nvar _mapCacheGet = mapCacheGet;\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return _getMapData(this, key).has(key);\n}\n\nvar _mapCacheHas = mapCacheHas;\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = _getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nvar _mapCacheSet = mapCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = _mapCacheClear;\nMapCache.prototype['delete'] = _mapCacheDelete;\nMapCache.prototype.get = _mapCacheGet;\nMapCache.prototype.has = _mapCacheHas;\nMapCache.prototype.set = _mapCacheSet;\n\nvar _MapCache = MapCache;\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || _MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = _MapCache;\n\nvar memoize_1 = memoize;\n\nvar MEASUREMENT_ELEMENT_ID = '__react_svg_text_measurement_id';\n\nfunction getStringWidth(str, style) {\n  try {\n    // Calculate length of each word to be used to determine number of words per line\n    var textEl = document.getElementById(MEASUREMENT_ELEMENT_ID);\n    if (!textEl) {\n      var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n      svg.style.width = 0;\n      svg.style.height = 0;\n      svg.style.position = 'absolute';\n      svg.style.top = '-100%';\n      svg.style.left = '-100%';\n      textEl = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n      textEl.setAttribute('id', MEASUREMENT_ELEMENT_ID);\n      svg.appendChild(textEl);\n      document.body.appendChild(svg);\n    }\n\n    Object.assign(textEl.style, style);\n    textEl.textContent = str;\n    return textEl.getComputedTextLength();\n  } catch (e) {\n    return null;\n  }\n}\n\nvar getStringWidth$1 = memoize_1(getStringWidth, function (str, style) {\n  return str + '_' + JSON.stringify(style);\n});\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar Text = function (_Component) {\n  inherits(Text, _Component);\n\n  function Text(props) {\n    classCallCheck(this, Text);\n\n    var _this = possibleConstructorReturn(this, (Text.__proto__ || Object.getPrototypeOf(Text)).call(this, props));\n\n    _this.state = {\n      wordsByLines: []\n    };\n    return _this;\n  }\n\n  createClass(Text, [{\n    key: 'componentWillMount',\n    value: function componentWillMount() {\n      this.updateWordsByLines(this.props, true);\n    }\n  }, {\n    key: 'componentWillReceiveProps',\n    value: function componentWillReceiveProps(nextProps) {\n      var needCalculate = this.props.children !== nextProps.children || this.props.style !== nextProps.style;\n      this.updateWordsByLines(nextProps, needCalculate);\n    }\n  }, {\n    key: 'updateWordsByLines',\n    value: function updateWordsByLines(props, needCalculate) {\n      // Only perform calculations if using features that require them (multiline, scaleToFit)\n      if (props.width || props.scaleToFit) {\n        if (needCalculate) {\n          var words = props.children ? props.children.toString().split(/\\s+/) : [];\n\n          this.wordsWithComputedWidth = words.map(function (word) {\n            return {\n              word: word,\n              width: getStringWidth$1(word, props.style)\n            };\n          });\n          this.spaceWidth = getStringWidth$1('\\xA0', props.style);\n        }\n\n        var wordsByLines = this.calculateWordsByLines(this.wordsWithComputedWidth, this.spaceWidth, props.width);\n        this.setState({ wordsByLines: wordsByLines });\n      } else {\n        this.updateWordsWithoutCalculate(props);\n      }\n    }\n  }, {\n    key: 'updateWordsWithoutCalculate',\n    value: function updateWordsWithoutCalculate(props) {\n      var words = props.children ? props.children.toString().split(/\\s+/) : [];\n      this.setState({ wordsByLines: [{ words: words }] });\n    }\n  }, {\n    key: 'calculateWordsByLines',\n    value: function calculateWordsByLines(wordsWithComputedWidth, spaceWidth, lineWidth) {\n      var scaleToFit = this.props.scaleToFit;\n\n      return wordsWithComputedWidth.reduce(function (result, _ref) {\n        var word = _ref.word,\n            width = _ref.width;\n\n        var currentLine = result[result.length - 1];\n\n        if (currentLine && (lineWidth == null || scaleToFit || currentLine.width + width + spaceWidth < lineWidth)) {\n          // Word can be added to an existing line\n          currentLine.words.push(word);\n          currentLine.width += width + spaceWidth;\n        } else {\n          // Add first word to line or word is too long to scaleToFit on existing line\n          var newLine = { words: [word], width: width };\n          result.push(newLine);\n        }\n\n        return result;\n      }, []);\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props = this.props,\n          dx = _props.dx,\n          dy = _props.dy,\n          textAnchor = _props.textAnchor,\n          verticalAnchor = _props.verticalAnchor,\n          scaleToFit = _props.scaleToFit,\n          angle = _props.angle,\n          lineHeight = _props.lineHeight,\n          capHeight = _props.capHeight,\n          innerRef = _props.innerRef,\n          textProps = objectWithoutProperties(_props, ['dx', 'dy', 'textAnchor', 'verticalAnchor', 'scaleToFit', 'angle', 'lineHeight', 'capHeight', 'innerRef']);\n      var wordsByLines = this.state.wordsByLines;\n      var x = textProps.x,\n          y = textProps.y;\n\n\n      var startDy = void 0;\n      switch (verticalAnchor) {\n        case 'start':\n          startDy = reduce_css_calc__WEBPACK_IMPORTED_MODULE_2___default()('calc(' + capHeight + ')');\n          break;\n        case 'middle':\n          startDy = reduce_css_calc__WEBPACK_IMPORTED_MODULE_2___default()('calc(' + (wordsByLines.length - 1) / 2 + ' * -' + lineHeight + ' + (' + capHeight + ' / 2))');\n          break;\n        default:\n          startDy = reduce_css_calc__WEBPACK_IMPORTED_MODULE_2___default()('calc(' + (wordsByLines.length - 1) + ' * -' + lineHeight + ')');\n          break;\n      }\n\n      var transforms = [];\n      if (scaleToFit && wordsByLines.length) {\n        var lineWidth = wordsByLines[0].width;\n        var sx = this.props.width / lineWidth;\n        var sy = sx;\n        var originX = x - sx * x;\n        var originY = y - sy * y;\n        transforms.push('matrix(' + sx + ', 0, 0, ' + sy + ', ' + originX + ', ' + originY + ')');\n      }\n      if (angle) {\n        transforms.push('rotate(' + angle + ', ' + x + ', ' + y + ')');\n      }\n      if (transforms.length) {\n        textProps.transform = transforms.join(' ');\n      }\n\n      return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(\n        'svg',\n        {\n          ref: innerRef,\n          x: dx,\n          y: dy,\n          fontSize: textProps.fontSize,\n          style: { overflow: 'visible' }\n        },\n        react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(\n          'text',\n          _extends({}, textProps, { textAnchor: textAnchor }),\n          wordsByLines.map(function (line, index) {\n            return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(\n              'tspan',\n              { x: x, dy: index === 0 ? startDy : lineHeight, key: index },\n              line.words.join(' ')\n            );\n          })\n        )\n      );\n    }\n  }]);\n  return Text;\n}(react__WEBPACK_IMPORTED_MODULE_1__[\"Component\"]);\n\nText.defaultProps = {\n  x: 0,\n  y: 0,\n  dx: 0,\n  dy: 0,\n  lineHeight: '1em',\n  capHeight: '0.71em', // Magic number from d3\n  scaleToFit: false,\n  textAnchor: 'start',\n  verticalAnchor: 'end' // default SVG behavior\n};\n\nText.propTypes = {\n  scaleToFit: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.bool,\n  angle: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number,\n  textAnchor: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.oneOf(['start', 'middle', 'end', 'inherit']),\n  verticalAnchor: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.oneOf(['start', 'middle', 'end']),\n  style: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.object,\n  innerRef: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.func,\n  x: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number, prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string]),\n  y: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number, prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string]),\n  dx: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number, prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string]),\n  dy: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number, prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string]),\n  lineHeight: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number, prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string]),\n  capHeight: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number, prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string])\n};\n\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(40)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcyMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL2hpc3RvZ3JhbS9ub2RlX21vZHVsZXMvQHZ4L3RleHQvZGlzdC92eC10ZXh0LmVzLmpzPzg5NmIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgcmVkdWNlQ1NTQ2FsYyBmcm9tICdyZWR1Y2UtY3NzLWNhbGMnO1xuXG52YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgY29tbW9uanNHbG9iYWwgPT0gJ29iamVjdCcgJiYgY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgY29tbW9uanNHbG9iYWw7XG5cbnZhciBfZnJlZUdsb2JhbCA9IGZyZWVHbG9iYWw7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IF9mcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbnZhciBfcm9vdCA9IHJvb3Q7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCQxID0gX3Jvb3QuU3ltYm9sO1xuXG52YXIgX1N5bWJvbCA9IFN5bWJvbCQxO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBfU3ltYm9sID8gX1N5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX2dldFJhd1RhZyA9IGdldFJhd1RhZztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvJDEgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmckMSA9IG9iamVjdFByb3RvJDEudG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmckMS5jYWxsKHZhbHVlKTtcbn1cblxudmFyIF9vYmplY3RUb1N0cmluZyA9IG9iamVjdFRvU3RyaW5nO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWckMSA9IF9TeW1ib2wgPyBfU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnJDEgJiYgc3ltVG9TdHJpbmdUYWckMSBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gX2dldFJhd1RhZyh2YWx1ZSlcbiAgICA6IF9vYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbnZhciBfYmFzZUdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG52YXIgaXNPYmplY3RfMSA9IGlzT2JqZWN0O1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RfMSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gX2Jhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG52YXIgaXNGdW5jdGlvbl8xID0gaXNGdW5jdGlvbjtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSBfcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbnZhciBfY29yZUpzRGF0YSA9IGNvcmVKc0RhdGE7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoX2NvcmVKc0RhdGEgJiYgX2NvcmVKc0RhdGEua2V5cyAmJiBfY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbnZhciBfaXNNYXNrZWQgPSBpc01hc2tlZDtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgX3RvU291cmNlID0gdG9Tb3VyY2U7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvJDEgPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8kMiA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmckMSA9IGZ1bmNQcm90byQxLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSQxID0gb2JqZWN0UHJvdG8kMi5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZyQxLmNhbGwoaGFzT3duUHJvcGVydHkkMSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RfMSh2YWx1ZSkgfHwgX2lzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb25fMSh2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KF90b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG52YXIgX2Jhc2VJc05hdGl2ZSA9IGJhc2VJc05hdGl2ZTtcblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbnZhciBfZ2V0VmFsdWUgPSBnZXRWYWx1ZTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IF9nZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBfYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG52YXIgX2dldE5hdGl2ZSA9IGdldE5hdGl2ZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIG5hdGl2ZUNyZWF0ZSA9IF9nZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbnZhciBfbmF0aXZlQ3JlYXRlID0gbmF0aXZlQ3JlYXRlO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBfbmF0aXZlQ3JlYXRlID8gX25hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG52YXIgX2hhc2hDbGVhciA9IGhhc2hDbGVhcjtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9oYXNoRGVsZXRlID0gaGFzaERlbGV0ZTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8kMyA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5JDIgPSBvYmplY3RQcm90byQzLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoX25hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5JDIuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG52YXIgX2hhc2hHZXQgPSBoYXNoR2V0O1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8kNCA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5JDMgPSBvYmplY3RQcm90byQ0Lmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIF9uYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkkMy5jYWxsKGRhdGEsIGtleSk7XG59XG5cbnZhciBfaGFzaEhhcyA9IGhhc2hIYXM7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCQxID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAoX25hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEJDEgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBfaGFzaFNldCA9IGhhc2hTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBfaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gX2hhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBfaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IF9oYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gX2hhc2hTZXQ7XG5cbnZhciBfSGFzaCA9IEhhc2g7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxudmFyIF9saXN0Q2FjaGVDbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuXG4vKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxudmFyIGVxXzEgPSBlcTtcblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxXzEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG52YXIgX2Fzc29jSW5kZXhPZiA9IGFzc29jSW5kZXhPZjtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gX2Fzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIF9saXN0Q2FjaGVEZWxldGUgPSBsaXN0Q2FjaGVEZWxldGU7XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBfYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG52YXIgX2xpc3RDYWNoZUdldCA9IGxpc3RDYWNoZUdldDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIF9hc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG52YXIgX2xpc3RDYWNoZUhhcyA9IGxpc3RDYWNoZUhhcztcblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IF9hc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxudmFyIF9saXN0Q2FjaGVTZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gX2xpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBfbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBfbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBfbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBfbGlzdENhY2hlU2V0O1xuXG52YXIgX0xpc3RDYWNoZSA9IExpc3RDYWNoZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIE1hcCA9IF9nZXROYXRpdmUoX3Jvb3QsICdNYXAnKTtcblxudmFyIF9NYXAgPSBNYXA7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgX0hhc2gsXG4gICAgJ21hcCc6IG5ldyAoX01hcCB8fCBfTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IF9IYXNoXG4gIH07XG59XG5cbnZhciBfbWFwQ2FjaGVDbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxudmFyIF9pc0tleWFibGUgPSBpc0tleWFibGU7XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBfaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbnZhciBfZ2V0TWFwRGF0YSA9IGdldE1hcERhdGE7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IF9nZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9tYXBDYWNoZURlbGV0ZSA9IG1hcENhY2hlRGVsZXRlO1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBfZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG52YXIgX21hcENhY2hlR2V0ID0gbWFwQ2FjaGVHZXQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBfZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG52YXIgX21hcENhY2hlSGFzID0gbWFwQ2FjaGVIYXM7XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IF9nZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBfbWFwQ2FjaGVTZXQgPSBtYXBDYWNoZVNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IF9tYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IF9tYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBfbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gX21hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IF9tYXBDYWNoZVNldDtcblxudmFyIF9NYXBDYWNoZSA9IE1hcENhY2hlO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAqXG4gKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogdmFsdWVzKG90aGVyKTtcbiAqIC8vID0+IFszLCA0XVxuICpcbiAqIG9iamVjdC5hID0gMjtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBfTWFwQ2FjaGUpO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxubWVtb2l6ZS5DYWNoZSA9IF9NYXBDYWNoZTtcblxudmFyIG1lbW9pemVfMSA9IG1lbW9pemU7XG5cbnZhciBNRUFTVVJFTUVOVF9FTEVNRU5UX0lEID0gJ19fcmVhY3Rfc3ZnX3RleHRfbWVhc3VyZW1lbnRfaWQnO1xuXG5mdW5jdGlvbiBnZXRTdHJpbmdXaWR0aChzdHIsIHN0eWxlKSB7XG4gIHRyeSB7XG4gICAgLy8gQ2FsY3VsYXRlIGxlbmd0aCBvZiBlYWNoIHdvcmQgdG8gYmUgdXNlZCB0byBkZXRlcm1pbmUgbnVtYmVyIG9mIHdvcmRzIHBlciBsaW5lXG4gICAgdmFyIHRleHRFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKE1FQVNVUkVNRU5UX0VMRU1FTlRfSUQpO1xuICAgIGlmICghdGV4dEVsKSB7XG4gICAgICB2YXIgc3ZnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdzdmcnKTtcbiAgICAgIHN2Zy5zdHlsZS53aWR0aCA9IDA7XG4gICAgICBzdmcuc3R5bGUuaGVpZ2h0ID0gMDtcbiAgICAgIHN2Zy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICBzdmcuc3R5bGUudG9wID0gJy0xMDAlJztcbiAgICAgIHN2Zy5zdHlsZS5sZWZ0ID0gJy0xMDAlJztcbiAgICAgIHRleHRFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAndGV4dCcpO1xuICAgICAgdGV4dEVsLnNldEF0dHJpYnV0ZSgnaWQnLCBNRUFTVVJFTUVOVF9FTEVNRU5UX0lEKTtcbiAgICAgIHN2Zy5hcHBlbmRDaGlsZCh0ZXh0RWwpO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzdmcpO1xuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24odGV4dEVsLnN0eWxlLCBzdHlsZSk7XG4gICAgdGV4dEVsLnRleHRDb250ZW50ID0gc3RyO1xuICAgIHJldHVybiB0ZXh0RWwuZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG52YXIgZ2V0U3RyaW5nV2lkdGgkMSA9IG1lbW9pemVfMShnZXRTdHJpbmdXaWR0aCwgZnVuY3Rpb24gKHN0ciwgc3R5bGUpIHtcbiAgcmV0dXJuIHN0ciArICdfJyArIEpTT04uc3RyaW5naWZ5KHN0eWxlKTtcbn0pO1xuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxudmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxudmFyIGluaGVyaXRzID0gZnVuY3Rpb24gKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufTtcblxudmFyIG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG9iaiwga2V5cykge1xuICB2YXIgdGFyZ2V0ID0ge307XG5cbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlO1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlO1xuICAgIHRhcmdldFtpXSA9IG9ialtpXTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG52YXIgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiA9IGZ1bmN0aW9uIChzZWxmLCBjYWxsKSB7XG4gIGlmICghc2VsZikge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmO1xufTtcblxudmFyIFRleHQgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhUZXh0LCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBUZXh0KHByb3BzKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dCk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChUZXh0Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVGV4dCkpLmNhbGwodGhpcywgcHJvcHMpKTtcblxuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgd29yZHNCeUxpbmVzOiBbXVxuICAgIH07XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoVGV4dCwgW3tcbiAgICBrZXk6ICdjb21wb25lbnRXaWxsTW91bnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgICB0aGlzLnVwZGF0ZVdvcmRzQnlMaW5lcyh0aGlzLnByb3BzLCB0cnVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgIHZhciBuZWVkQ2FsY3VsYXRlID0gdGhpcy5wcm9wcy5jaGlsZHJlbiAhPT0gbmV4dFByb3BzLmNoaWxkcmVuIHx8IHRoaXMucHJvcHMuc3R5bGUgIT09IG5leHRQcm9wcy5zdHlsZTtcbiAgICAgIHRoaXMudXBkYXRlV29yZHNCeUxpbmVzKG5leHRQcm9wcywgbmVlZENhbGN1bGF0ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlV29yZHNCeUxpbmVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlV29yZHNCeUxpbmVzKHByb3BzLCBuZWVkQ2FsY3VsYXRlKSB7XG4gICAgICAvLyBPbmx5IHBlcmZvcm0gY2FsY3VsYXRpb25zIGlmIHVzaW5nIGZlYXR1cmVzIHRoYXQgcmVxdWlyZSB0aGVtIChtdWx0aWxpbmUsIHNjYWxlVG9GaXQpXG4gICAgICBpZiAocHJvcHMud2lkdGggfHwgcHJvcHMuc2NhbGVUb0ZpdCkge1xuICAgICAgICBpZiAobmVlZENhbGN1bGF0ZSkge1xuICAgICAgICAgIHZhciB3b3JkcyA9IHByb3BzLmNoaWxkcmVuID8gcHJvcHMuY2hpbGRyZW4udG9TdHJpbmcoKS5zcGxpdCgvXFxzKy8pIDogW107XG5cbiAgICAgICAgICB0aGlzLndvcmRzV2l0aENvbXB1dGVkV2lkdGggPSB3b3Jkcy5tYXAoZnVuY3Rpb24gKHdvcmQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHdvcmQ6IHdvcmQsXG4gICAgICAgICAgICAgIHdpZHRoOiBnZXRTdHJpbmdXaWR0aCQxKHdvcmQsIHByb3BzLnN0eWxlKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLnNwYWNlV2lkdGggPSBnZXRTdHJpbmdXaWR0aCQxKCdcXHhBMCcsIHByb3BzLnN0eWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB3b3Jkc0J5TGluZXMgPSB0aGlzLmNhbGN1bGF0ZVdvcmRzQnlMaW5lcyh0aGlzLndvcmRzV2l0aENvbXB1dGVkV2lkdGgsIHRoaXMuc3BhY2VXaWR0aCwgcHJvcHMud2lkdGgpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgd29yZHNCeUxpbmVzOiB3b3Jkc0J5TGluZXMgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnVwZGF0ZVdvcmRzV2l0aG91dENhbGN1bGF0ZShwcm9wcyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlV29yZHNXaXRob3V0Q2FsY3VsYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlV29yZHNXaXRob3V0Q2FsY3VsYXRlKHByb3BzKSB7XG4gICAgICB2YXIgd29yZHMgPSBwcm9wcy5jaGlsZHJlbiA/IHByb3BzLmNoaWxkcmVuLnRvU3RyaW5nKCkuc3BsaXQoL1xccysvKSA6IFtdO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IHdvcmRzQnlMaW5lczogW3sgd29yZHM6IHdvcmRzIH1dIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NhbGN1bGF0ZVdvcmRzQnlMaW5lcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZVdvcmRzQnlMaW5lcyh3b3Jkc1dpdGhDb21wdXRlZFdpZHRoLCBzcGFjZVdpZHRoLCBsaW5lV2lkdGgpIHtcbiAgICAgIHZhciBzY2FsZVRvRml0ID0gdGhpcy5wcm9wcy5zY2FsZVRvRml0O1xuXG4gICAgICByZXR1cm4gd29yZHNXaXRoQ29tcHV0ZWRXaWR0aC5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgX3JlZikge1xuICAgICAgICB2YXIgd29yZCA9IF9yZWYud29yZCxcbiAgICAgICAgICAgIHdpZHRoID0gX3JlZi53aWR0aDtcblxuICAgICAgICB2YXIgY3VycmVudExpbmUgPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGlmIChjdXJyZW50TGluZSAmJiAobGluZVdpZHRoID09IG51bGwgfHwgc2NhbGVUb0ZpdCB8fCBjdXJyZW50TGluZS53aWR0aCArIHdpZHRoICsgc3BhY2VXaWR0aCA8IGxpbmVXaWR0aCkpIHtcbiAgICAgICAgICAvLyBXb3JkIGNhbiBiZSBhZGRlZCB0byBhbiBleGlzdGluZyBsaW5lXG4gICAgICAgICAgY3VycmVudExpbmUud29yZHMucHVzaCh3b3JkKTtcbiAgICAgICAgICBjdXJyZW50TGluZS53aWR0aCArPSB3aWR0aCArIHNwYWNlV2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQWRkIGZpcnN0IHdvcmQgdG8gbGluZSBvciB3b3JkIGlzIHRvbyBsb25nIHRvIHNjYWxlVG9GaXQgb24gZXhpc3RpbmcgbGluZVxuICAgICAgICAgIHZhciBuZXdMaW5lID0geyB3b3JkczogW3dvcmRdLCB3aWR0aDogd2lkdGggfTtcbiAgICAgICAgICByZXN1bHQucHVzaChuZXdMaW5lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LCBbXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVuZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgZHggPSBfcHJvcHMuZHgsXG4gICAgICAgICAgZHkgPSBfcHJvcHMuZHksXG4gICAgICAgICAgdGV4dEFuY2hvciA9IF9wcm9wcy50ZXh0QW5jaG9yLFxuICAgICAgICAgIHZlcnRpY2FsQW5jaG9yID0gX3Byb3BzLnZlcnRpY2FsQW5jaG9yLFxuICAgICAgICAgIHNjYWxlVG9GaXQgPSBfcHJvcHMuc2NhbGVUb0ZpdCxcbiAgICAgICAgICBhbmdsZSA9IF9wcm9wcy5hbmdsZSxcbiAgICAgICAgICBsaW5lSGVpZ2h0ID0gX3Byb3BzLmxpbmVIZWlnaHQsXG4gICAgICAgICAgY2FwSGVpZ2h0ID0gX3Byb3BzLmNhcEhlaWdodCxcbiAgICAgICAgICBpbm5lclJlZiA9IF9wcm9wcy5pbm5lclJlZixcbiAgICAgICAgICB0ZXh0UHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcHJvcHMsIFsnZHgnLCAnZHknLCAndGV4dEFuY2hvcicsICd2ZXJ0aWNhbEFuY2hvcicsICdzY2FsZVRvRml0JywgJ2FuZ2xlJywgJ2xpbmVIZWlnaHQnLCAnY2FwSGVpZ2h0JywgJ2lubmVyUmVmJ10pO1xuICAgICAgdmFyIHdvcmRzQnlMaW5lcyA9IHRoaXMuc3RhdGUud29yZHNCeUxpbmVzO1xuICAgICAgdmFyIHggPSB0ZXh0UHJvcHMueCxcbiAgICAgICAgICB5ID0gdGV4dFByb3BzLnk7XG5cblxuICAgICAgdmFyIHN0YXJ0RHkgPSB2b2lkIDA7XG4gICAgICBzd2l0Y2ggKHZlcnRpY2FsQW5jaG9yKSB7XG4gICAgICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgICAgICBzdGFydER5ID0gcmVkdWNlQ1NTQ2FsYygnY2FsYygnICsgY2FwSGVpZ2h0ICsgJyknKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgICBzdGFydER5ID0gcmVkdWNlQ1NTQ2FsYygnY2FsYygnICsgKHdvcmRzQnlMaW5lcy5sZW5ndGggLSAxKSAvIDIgKyAnICogLScgKyBsaW5lSGVpZ2h0ICsgJyArICgnICsgY2FwSGVpZ2h0ICsgJyAvIDIpKScpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHN0YXJ0RHkgPSByZWR1Y2VDU1NDYWxjKCdjYWxjKCcgKyAod29yZHNCeUxpbmVzLmxlbmd0aCAtIDEpICsgJyAqIC0nICsgbGluZUhlaWdodCArICcpJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciB0cmFuc2Zvcm1zID0gW107XG4gICAgICBpZiAoc2NhbGVUb0ZpdCAmJiB3b3Jkc0J5TGluZXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBsaW5lV2lkdGggPSB3b3Jkc0J5TGluZXNbMF0ud2lkdGg7XG4gICAgICAgIHZhciBzeCA9IHRoaXMucHJvcHMud2lkdGggLyBsaW5lV2lkdGg7XG4gICAgICAgIHZhciBzeSA9IHN4O1xuICAgICAgICB2YXIgb3JpZ2luWCA9IHggLSBzeCAqIHg7XG4gICAgICAgIHZhciBvcmlnaW5ZID0geSAtIHN5ICogeTtcbiAgICAgICAgdHJhbnNmb3Jtcy5wdXNoKCdtYXRyaXgoJyArIHN4ICsgJywgMCwgMCwgJyArIHN5ICsgJywgJyArIG9yaWdpblggKyAnLCAnICsgb3JpZ2luWSArICcpJyk7XG4gICAgICB9XG4gICAgICBpZiAoYW5nbGUpIHtcbiAgICAgICAgdHJhbnNmb3Jtcy5wdXNoKCdyb3RhdGUoJyArIGFuZ2xlICsgJywgJyArIHggKyAnLCAnICsgeSArICcpJyk7XG4gICAgICB9XG4gICAgICBpZiAodHJhbnNmb3Jtcy5sZW5ndGgpIHtcbiAgICAgICAgdGV4dFByb3BzLnRyYW5zZm9ybSA9IHRyYW5zZm9ybXMuam9pbignICcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgICAgJ3N2ZycsXG4gICAgICAgIHtcbiAgICAgICAgICByZWY6IGlubmVyUmVmLFxuICAgICAgICAgIHg6IGR4LFxuICAgICAgICAgIHk6IGR5LFxuICAgICAgICAgIGZvbnRTaXplOiB0ZXh0UHJvcHMuZm9udFNpemUsXG4gICAgICAgICAgc3R5bGU6IHsgb3ZlcmZsb3c6ICd2aXNpYmxlJyB9XG4gICAgICAgIH0sXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgJ3RleHQnLFxuICAgICAgICAgIF9leHRlbmRzKHt9LCB0ZXh0UHJvcHMsIHsgdGV4dEFuY2hvcjogdGV4dEFuY2hvciB9KSxcbiAgICAgICAgICB3b3Jkc0J5TGluZXMubWFwKGZ1bmN0aW9uIChsaW5lLCBpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICd0c3BhbicsXG4gICAgICAgICAgICAgIHsgeDogeCwgZHk6IGluZGV4ID09PSAwID8gc3RhcnREeSA6IGxpbmVIZWlnaHQsIGtleTogaW5kZXggfSxcbiAgICAgICAgICAgICAgbGluZS53b3Jkcy5qb2luKCcgJylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFRleHQ7XG59KENvbXBvbmVudCk7XG5cblRleHQuZGVmYXVsdFByb3BzID0ge1xuICB4OiAwLFxuICB5OiAwLFxuICBkeDogMCxcbiAgZHk6IDAsXG4gIGxpbmVIZWlnaHQ6ICcxZW0nLFxuICBjYXBIZWlnaHQ6ICcwLjcxZW0nLCAvLyBNYWdpYyBudW1iZXIgZnJvbSBkM1xuICBzY2FsZVRvRml0OiBmYWxzZSxcbiAgdGV4dEFuY2hvcjogJ3N0YXJ0JyxcbiAgdmVydGljYWxBbmNob3I6ICdlbmQnIC8vIGRlZmF1bHQgU1ZHIGJlaGF2aW9yXG59O1xuXG5UZXh0LnByb3BUeXBlcyA9IHtcbiAgc2NhbGVUb0ZpdDogUHJvcFR5cGVzLmJvb2wsXG4gIGFuZ2xlOiBQcm9wVHlwZXMubnVtYmVyLFxuICB0ZXh0QW5jaG9yOiBQcm9wVHlwZXMub25lT2YoWydzdGFydCcsICdtaWRkbGUnLCAnZW5kJywgJ2luaGVyaXQnXSksXG4gIHZlcnRpY2FsQW5jaG9yOiBQcm9wVHlwZXMub25lT2YoWydzdGFydCcsICdtaWRkbGUnLCAnZW5kJ10pLFxuICBzdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgaW5uZXJSZWY6IFByb3BUeXBlcy5mdW5jLFxuICB4OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG4gIHk6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgZHg6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgZHk6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgbGluZUhlaWdodDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxuICBjYXBIZWlnaHQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKVxufTtcblxuZXhwb3J0IHsgVGV4dCwgZ2V0U3RyaW5nV2lkdGgkMSBhcyBnZXRTdHJpbmdXaWR0aCB9O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1722\n")},1732:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _timer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1371);\n\n\n/* harmony default export */ __webpack_exports__["a"] = (function(callback, delay, time) {\n  var t = new _timer_js__WEBPACK_IMPORTED_MODULE_0__[/* Timer */ "a"];\n  delay = delay == null ? 0 : +delay;\n  t.restart(function(elapsed) {\n    t.stop();\n    callback(elapsed + delay);\n  }, delay, time);\n  return t;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTczMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2QzLXRpbWVyL3NyYy90aW1lb3V0LmpzPzBiNmEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtUaW1lcn0gZnJvbSBcIi4vdGltZXIuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY2FsbGJhY2ssIGRlbGF5LCB0aW1lKSB7XG4gIHZhciB0ID0gbmV3IFRpbWVyO1xuICBkZWxheSA9IGRlbGF5ID09IG51bGwgPyAwIDogK2RlbGF5O1xuICB0LnJlc3RhcnQoZnVuY3Rpb24oZWxhcHNlZCkge1xuICAgIHQuc3RvcCgpO1xuICAgIGNhbGxiYWNrKGVsYXBzZWQgKyBkZWxheSk7XG4gIH0sIGRlbGF5LCB0aW1lKTtcbiAgcmV0dXJuIHQ7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1732\n')},2264:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return XAxis; });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _vx_axis__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1439);\n/* harmony import */ var _utils_propShapes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1352);\n\n\n\n\nvar propTypes = {\n  axisStyles: _utils_propShapes__WEBPACK_IMPORTED_MODULE_3__[/* axisStylesShape */ \"a\"],\n  label: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.element]),\n  labelProps: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object,\n  // eslint-disable-line react/forbid-prop-types\n  numTicks: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  orientation: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.oneOf(['bottom', 'top']),\n  tickStyles: _utils_propShapes__WEBPACK_IMPORTED_MODULE_3__[/* tickStylesShape */ \"d\"],\n  tickLabelProps: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,\n  tickFormat: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,\n  tickValues: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number, prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string])),\n  // probably injected by parent\n  top: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  left: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  scale: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func\n};\nvar defaultProps = {\n  axisStyles: {},\n  label: null,\n  labelProps: null,\n  left: 0,\n  numTicks: null,\n  orientation: 'bottom',\n  scale: null,\n  tickFormat: null,\n  tickLabelProps: undefined,\n  tickStyles: {},\n  top: 0,\n  tickValues: undefined\n};\nfunction XAxis(_ref) {\n  var axisStyles = _ref.axisStyles,\n      label = _ref.label,\n      labelProps = _ref.labelProps,\n      top = _ref.top,\n      left = _ref.left,\n      numTicks = _ref.numTicks,\n      orientation = _ref.orientation,\n      scale = _ref.scale,\n      tickFormat = _ref.tickFormat,\n      passedTickLabelProps = _ref.tickLabelProps,\n      tickStyles = _ref.tickStyles,\n      tickValues = _ref.tickValues;\n  if (!scale) return null;\n  var Axis = orientation === 'bottom' ? _vx_axis__WEBPACK_IMPORTED_MODULE_2__[/* AxisBottom */ \"a\"] : _vx_axis__WEBPACK_IMPORTED_MODULE_2__[/* AxisTop */ \"d\"];\n  var tickLabelProps = passedTickLabelProps;\n\n  if (!tickLabelProps) {\n    tickLabelProps = tickStyles.label && tickStyles.label[orientation] ? function () {\n      return tickStyles.label[orientation];\n    } : undefined;\n  }\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Axis, {\n    top: top,\n    left: left,\n    hideTicks: false,\n    hideZero: false,\n    label: label,\n    labelProps: labelProps || (axisStyles.label || {})[orientation],\n    numTicks: numTicks,\n    scale: scale,\n    stroke: axisStyles.stroke,\n    strokeWidth: axisStyles.strokeWidth,\n    tickFormat: tickFormat,\n    tickLength: tickStyles.tickLength,\n    tickLabelProps: tickLabelProps,\n    tickStroke: tickStyles.stroke,\n    tickValues: tickValues\n  });\n}\nXAxis.propTypes = propTypes;\nXAxis.defaultProps = defaultProps;\nXAxis.displayName = 'XAxis';//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjI2NC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL2hpc3RvZ3JhbS9lc20vYXhpcy9YQXhpcy5qcz82ZjEyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgQXhpc0JvdHRvbSwgQXhpc1RvcCB9IGZyb20gJ0B2eC9heGlzJztcbmltcG9ydCB7IGF4aXNTdHlsZXNTaGFwZSwgdGlja1N0eWxlc1NoYXBlIH0gZnJvbSAnLi4vdXRpbHMvcHJvcFNoYXBlcyc7XG52YXIgcHJvcFR5cGVzID0ge1xuICBheGlzU3R5bGVzOiBheGlzU3R5bGVzU2hhcGUsXG4gIGxhYmVsOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuZWxlbWVudF0pLFxuICBsYWJlbFByb3BzOiBQcm9wVHlwZXMub2JqZWN0LFxuICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlYWN0L2ZvcmJpZC1wcm9wLXR5cGVzXG4gIG51bVRpY2tzOiBQcm9wVHlwZXMubnVtYmVyLFxuICBvcmllbnRhdGlvbjogUHJvcFR5cGVzLm9uZU9mKFsnYm90dG9tJywgJ3RvcCddKSxcbiAgdGlja1N0eWxlczogdGlja1N0eWxlc1NoYXBlLFxuICB0aWNrTGFiZWxQcm9wczogUHJvcFR5cGVzLmZ1bmMsXG4gIHRpY2tGb3JtYXQ6IFByb3BUeXBlcy5mdW5jLFxuICB0aWNrVmFsdWVzOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSkpLFxuICAvLyBwcm9iYWJseSBpbmplY3RlZCBieSBwYXJlbnRcbiAgdG9wOiBQcm9wVHlwZXMubnVtYmVyLFxuICBsZWZ0OiBQcm9wVHlwZXMubnVtYmVyLFxuICBzY2FsZTogUHJvcFR5cGVzLmZ1bmNcbn07XG52YXIgZGVmYXVsdFByb3BzID0ge1xuICBheGlzU3R5bGVzOiB7fSxcbiAgbGFiZWw6IG51bGwsXG4gIGxhYmVsUHJvcHM6IG51bGwsXG4gIGxlZnQ6IDAsXG4gIG51bVRpY2tzOiBudWxsLFxuICBvcmllbnRhdGlvbjogJ2JvdHRvbScsXG4gIHNjYWxlOiBudWxsLFxuICB0aWNrRm9ybWF0OiBudWxsLFxuICB0aWNrTGFiZWxQcm9wczogdW5kZWZpbmVkLFxuICB0aWNrU3R5bGVzOiB7fSxcbiAgdG9wOiAwLFxuICB0aWNrVmFsdWVzOiB1bmRlZmluZWRcbn07XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBYQXhpcyhfcmVmKSB7XG4gIHZhciBheGlzU3R5bGVzID0gX3JlZi5heGlzU3R5bGVzLFxuICAgICAgbGFiZWwgPSBfcmVmLmxhYmVsLFxuICAgICAgbGFiZWxQcm9wcyA9IF9yZWYubGFiZWxQcm9wcyxcbiAgICAgIHRvcCA9IF9yZWYudG9wLFxuICAgICAgbGVmdCA9IF9yZWYubGVmdCxcbiAgICAgIG51bVRpY2tzID0gX3JlZi5udW1UaWNrcyxcbiAgICAgIG9yaWVudGF0aW9uID0gX3JlZi5vcmllbnRhdGlvbixcbiAgICAgIHNjYWxlID0gX3JlZi5zY2FsZSxcbiAgICAgIHRpY2tGb3JtYXQgPSBfcmVmLnRpY2tGb3JtYXQsXG4gICAgICBwYXNzZWRUaWNrTGFiZWxQcm9wcyA9IF9yZWYudGlja0xhYmVsUHJvcHMsXG4gICAgICB0aWNrU3R5bGVzID0gX3JlZi50aWNrU3R5bGVzLFxuICAgICAgdGlja1ZhbHVlcyA9IF9yZWYudGlja1ZhbHVlcztcbiAgaWYgKCFzY2FsZSkgcmV0dXJuIG51bGw7XG4gIHZhciBBeGlzID0gb3JpZW50YXRpb24gPT09ICdib3R0b20nID8gQXhpc0JvdHRvbSA6IEF4aXNUb3A7XG4gIHZhciB0aWNrTGFiZWxQcm9wcyA9IHBhc3NlZFRpY2tMYWJlbFByb3BzO1xuXG4gIGlmICghdGlja0xhYmVsUHJvcHMpIHtcbiAgICB0aWNrTGFiZWxQcm9wcyA9IHRpY2tTdHlsZXMubGFiZWwgJiYgdGlja1N0eWxlcy5sYWJlbFtvcmllbnRhdGlvbl0gPyBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGlja1N0eWxlcy5sYWJlbFtvcmllbnRhdGlvbl07XG4gICAgfSA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEF4aXMsIHtcbiAgICB0b3A6IHRvcCxcbiAgICBsZWZ0OiBsZWZ0LFxuICAgIGhpZGVUaWNrczogZmFsc2UsXG4gICAgaGlkZVplcm86IGZhbHNlLFxuICAgIGxhYmVsOiBsYWJlbCxcbiAgICBsYWJlbFByb3BzOiBsYWJlbFByb3BzIHx8IChheGlzU3R5bGVzLmxhYmVsIHx8IHt9KVtvcmllbnRhdGlvbl0sXG4gICAgbnVtVGlja3M6IG51bVRpY2tzLFxuICAgIHNjYWxlOiBzY2FsZSxcbiAgICBzdHJva2U6IGF4aXNTdHlsZXMuc3Ryb2tlLFxuICAgIHN0cm9rZVdpZHRoOiBheGlzU3R5bGVzLnN0cm9rZVdpZHRoLFxuICAgIHRpY2tGb3JtYXQ6IHRpY2tGb3JtYXQsXG4gICAgdGlja0xlbmd0aDogdGlja1N0eWxlcy50aWNrTGVuZ3RoLFxuICAgIHRpY2tMYWJlbFByb3BzOiB0aWNrTGFiZWxQcm9wcyxcbiAgICB0aWNrU3Ryb2tlOiB0aWNrU3R5bGVzLnN0cm9rZSxcbiAgICB0aWNrVmFsdWVzOiB0aWNrVmFsdWVzXG4gIH0pO1xufVxuWEF4aXMucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xuWEF4aXMuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuWEF4aXMuZGlzcGxheU5hbWUgPSAnWEF4aXMnOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2264\n")},2275:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return YAxis; });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _vx_axis__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1439);\n/* harmony import */ var _utils_propShapes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1352);\n\n\n\n\nvar propTypes = {\n  axisStyles: _utils_propShapes__WEBPACK_IMPORTED_MODULE_3__[/* axisStylesShape */ \"a\"],\n  label: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  labelProps: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object,\n  // eslint-disable-line react/forbid-prop-types\n  numTicks: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  orientation: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.oneOf(['left', 'right']),\n  tickStyles: _utils_propShapes__WEBPACK_IMPORTED_MODULE_3__[/* tickStylesShape */ \"d\"],\n  tickLabelProps: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,\n  tickFormat: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,\n  tickValues: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number, prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string])),\n  // probably injected by parent\n  top: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  left: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  scale: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func\n};\nvar defaultProps = {\n  axisStyles: {},\n  label: null,\n  labelProps: null,\n  left: 0,\n  numTicks: 5,\n  orientation: 'left',\n  scale: null,\n  tickFormat: null,\n  tickLabelProps: undefined,\n  tickStyles: {},\n  tickValues: undefined,\n  top: 0\n};\nfunction YAxis(_ref) {\n  var axisStyles = _ref.axisStyles,\n      label = _ref.label,\n      labelProps = _ref.labelProps,\n      top = _ref.top,\n      left = _ref.left,\n      numTicks = _ref.numTicks,\n      orientation = _ref.orientation,\n      scale = _ref.scale,\n      tickFormat = _ref.tickFormat,\n      passedTickLabelProps = _ref.tickLabelProps,\n      tickStyles = _ref.tickStyles,\n      tickValues = _ref.tickValues;\n  if (!scale) return null;\n  var Axis = orientation === 'left' ? _vx_axis__WEBPACK_IMPORTED_MODULE_2__[/* AxisLeft */ \"b\"] : _vx_axis__WEBPACK_IMPORTED_MODULE_2__[/* AxisRight */ \"c\"];\n  var tickLabelProps = passedTickLabelProps;\n\n  if (!tickLabelProps) {\n    tickLabelProps = tickStyles.label && tickStyles.label[orientation] ? function () {\n      return tickStyles.label[orientation];\n    } : undefined;\n  }\n\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Axis, {\n    top: top,\n    left: left,\n    hideTicks: false,\n    hideZero: false,\n    label: label,\n    labelProps: labelProps || (axisStyles.label || {})[orientation],\n    numTicks: numTicks,\n    scale: scale,\n    stroke: axisStyles.stroke,\n    strokeWidth: axisStyles.strokeWidth,\n    tickFormat: tickFormat,\n    tickLabelProps: tickLabelProps,\n    tickLength: tickStyles.tickLength,\n    tickStroke: tickStyles.stroke,\n    tickValues: tickValues\n  });\n}\nYAxis.propTypes = propTypes;\nYAxis.defaultProps = defaultProps;\nYAxis.displayName = 'YAxis';//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjI3NS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL2hpc3RvZ3JhbS9lc20vYXhpcy9ZQXhpcy5qcz80MzcwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgQXhpc0xlZnQsIEF4aXNSaWdodCB9IGZyb20gJ0B2eC9heGlzJztcbmltcG9ydCB7IGF4aXNTdHlsZXNTaGFwZSwgdGlja1N0eWxlc1NoYXBlIH0gZnJvbSAnLi4vdXRpbHMvcHJvcFNoYXBlcyc7XG52YXIgcHJvcFR5cGVzID0ge1xuICBheGlzU3R5bGVzOiBheGlzU3R5bGVzU2hhcGUsXG4gIGxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBsYWJlbFByb3BzOiBQcm9wVHlwZXMub2JqZWN0LFxuICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlYWN0L2ZvcmJpZC1wcm9wLXR5cGVzXG4gIG51bVRpY2tzOiBQcm9wVHlwZXMubnVtYmVyLFxuICBvcmllbnRhdGlvbjogUHJvcFR5cGVzLm9uZU9mKFsnbGVmdCcsICdyaWdodCddKSxcbiAgdGlja1N0eWxlczogdGlja1N0eWxlc1NoYXBlLFxuICB0aWNrTGFiZWxQcm9wczogUHJvcFR5cGVzLmZ1bmMsXG4gIHRpY2tGb3JtYXQ6IFByb3BUeXBlcy5mdW5jLFxuICB0aWNrVmFsdWVzOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSkpLFxuICAvLyBwcm9iYWJseSBpbmplY3RlZCBieSBwYXJlbnRcbiAgdG9wOiBQcm9wVHlwZXMubnVtYmVyLFxuICBsZWZ0OiBQcm9wVHlwZXMubnVtYmVyLFxuICBzY2FsZTogUHJvcFR5cGVzLmZ1bmNcbn07XG52YXIgZGVmYXVsdFByb3BzID0ge1xuICBheGlzU3R5bGVzOiB7fSxcbiAgbGFiZWw6IG51bGwsXG4gIGxhYmVsUHJvcHM6IG51bGwsXG4gIGxlZnQ6IDAsXG4gIG51bVRpY2tzOiA1LFxuICBvcmllbnRhdGlvbjogJ2xlZnQnLFxuICBzY2FsZTogbnVsbCxcbiAgdGlja0Zvcm1hdDogbnVsbCxcbiAgdGlja0xhYmVsUHJvcHM6IHVuZGVmaW5lZCxcbiAgdGlja1N0eWxlczoge30sXG4gIHRpY2tWYWx1ZXM6IHVuZGVmaW5lZCxcbiAgdG9wOiAwXG59O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gWUF4aXMoX3JlZikge1xuICB2YXIgYXhpc1N0eWxlcyA9IF9yZWYuYXhpc1N0eWxlcyxcbiAgICAgIGxhYmVsID0gX3JlZi5sYWJlbCxcbiAgICAgIGxhYmVsUHJvcHMgPSBfcmVmLmxhYmVsUHJvcHMsXG4gICAgICB0b3AgPSBfcmVmLnRvcCxcbiAgICAgIGxlZnQgPSBfcmVmLmxlZnQsXG4gICAgICBudW1UaWNrcyA9IF9yZWYubnVtVGlja3MsXG4gICAgICBvcmllbnRhdGlvbiA9IF9yZWYub3JpZW50YXRpb24sXG4gICAgICBzY2FsZSA9IF9yZWYuc2NhbGUsXG4gICAgICB0aWNrRm9ybWF0ID0gX3JlZi50aWNrRm9ybWF0LFxuICAgICAgcGFzc2VkVGlja0xhYmVsUHJvcHMgPSBfcmVmLnRpY2tMYWJlbFByb3BzLFxuICAgICAgdGlja1N0eWxlcyA9IF9yZWYudGlja1N0eWxlcyxcbiAgICAgIHRpY2tWYWx1ZXMgPSBfcmVmLnRpY2tWYWx1ZXM7XG4gIGlmICghc2NhbGUpIHJldHVybiBudWxsO1xuICB2YXIgQXhpcyA9IG9yaWVudGF0aW9uID09PSAnbGVmdCcgPyBBeGlzTGVmdCA6IEF4aXNSaWdodDtcbiAgdmFyIHRpY2tMYWJlbFByb3BzID0gcGFzc2VkVGlja0xhYmVsUHJvcHM7XG5cbiAgaWYgKCF0aWNrTGFiZWxQcm9wcykge1xuICAgIHRpY2tMYWJlbFByb3BzID0gdGlja1N0eWxlcy5sYWJlbCAmJiB0aWNrU3R5bGVzLmxhYmVsW29yaWVudGF0aW9uXSA/IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aWNrU3R5bGVzLmxhYmVsW29yaWVudGF0aW9uXTtcbiAgICB9IDogdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQXhpcywge1xuICAgIHRvcDogdG9wLFxuICAgIGxlZnQ6IGxlZnQsXG4gICAgaGlkZVRpY2tzOiBmYWxzZSxcbiAgICBoaWRlWmVybzogZmFsc2UsXG4gICAgbGFiZWw6IGxhYmVsLFxuICAgIGxhYmVsUHJvcHM6IGxhYmVsUHJvcHMgfHwgKGF4aXNTdHlsZXMubGFiZWwgfHwge30pW29yaWVudGF0aW9uXSxcbiAgICBudW1UaWNrczogbnVtVGlja3MsXG4gICAgc2NhbGU6IHNjYWxlLFxuICAgIHN0cm9rZTogYXhpc1N0eWxlcy5zdHJva2UsXG4gICAgc3Ryb2tlV2lkdGg6IGF4aXNTdHlsZXMuc3Ryb2tlV2lkdGgsXG4gICAgdGlja0Zvcm1hdDogdGlja0Zvcm1hdCxcbiAgICB0aWNrTGFiZWxQcm9wczogdGlja0xhYmVsUHJvcHMsXG4gICAgdGlja0xlbmd0aDogdGlja1N0eWxlcy50aWNrTGVuZ3RoLFxuICAgIHRpY2tTdHJva2U6IHRpY2tTdHlsZXMuc3Ryb2tlLFxuICAgIHRpY2tWYWx1ZXM6IHRpY2tWYWx1ZXNcbiAgfSk7XG59XG5ZQXhpcy5wcm9wVHlwZXMgPSBwcm9wVHlwZXM7XG5ZQXhpcy5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5ZQXhpcy5kaXNwbGF5TmFtZSA9ICdZQXhpcyc7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2275\n")},2287:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// UNUSED EXPORTS: propTypes\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/prop-types/index.js\nvar prop_types = __webpack_require__(6);\nvar prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react/index.js\nvar react = __webpack_require__(0);\nvar react_default = /*#__PURE__*/__webpack_require__.n(react);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/group/dist/vx-group.es.js\nvar vx_group_es = __webpack_require__(1336);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-array/src/ascending.js\n/* harmony default export */ var ascending = (function(a, b) {\n  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-array/src/bisector.js\n\n\n/* harmony default export */ var bisector = (function(compare) {\n  if (compare.length === 1) compare = ascendingComparator(compare);\n  return {\n    left: function(a, x, lo, hi) {\n      if (lo == null) lo = 0;\n      if (hi == null) hi = a.length;\n      while (lo < hi) {\n        var mid = lo + hi >>> 1;\n        if (compare(a[mid], x) < 0) lo = mid + 1;\n        else hi = mid;\n      }\n      return lo;\n    },\n    right: function(a, x, lo, hi) {\n      if (lo == null) lo = 0;\n      if (hi == null) hi = a.length;\n      while (lo < hi) {\n        var mid = lo + hi >>> 1;\n        if (compare(a[mid], x) > 0) hi = mid;\n        else lo = mid + 1;\n      }\n      return lo;\n    }\n  };\n});\n\nfunction ascendingComparator(f) {\n  return function(d, x) {\n    return ascending(f(d), x);\n  };\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-array/src/bisect.js\n\n\n\nvar ascendingBisect = bisector(ascending);\nvar bisectRight = ascendingBisect.right;\nvar bisectLeft = ascendingBisect.left;\n/* harmony default export */ var bisect = (bisectRight);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-array/src/pairs.js\n/* harmony default export */ var pairs = (function(array, f) {\n  if (f == null) f = pair;\n  var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);\n  while (i < n) pairs[i] = f(p, p = array[++i]);\n  return pairs;\n});\n\nfunction pair(a, b) {\n  return [a, b];\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-array/src/cross.js\n\n\n/* harmony default export */ var cross = (function(values0, values1, reduce) {\n  var n0 = values0.length,\n      n1 = values1.length,\n      values = new Array(n0 * n1),\n      i0,\n      i1,\n      i,\n      value0;\n\n  if (reduce == null) reduce = pair;\n\n  for (i0 = i = 0; i0 < n0; ++i0) {\n    for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {\n      values[i] = reduce(value0, values1[i1]);\n    }\n  }\n\n  return values;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-array/src/descending.js\n/* harmony default export */ var descending = (function(a, b) {\n  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-array/src/number.js\n/* harmony default export */ var number = (function(x) {\n  return x === null ? NaN : +x;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-array/src/variance.js\n\n\n/* harmony default export */ var variance = (function(values, valueof) {\n  var n = values.length,\n      m = 0,\n      i = -1,\n      mean = 0,\n      value,\n      delta,\n      sum = 0;\n\n  if (valueof == null) {\n    while (++i < n) {\n      if (!isNaN(value = number(values[i]))) {\n        delta = value - mean;\n        mean += delta / ++m;\n        sum += delta * (value - mean);\n      }\n    }\n  }\n\n  else {\n    while (++i < n) {\n      if (!isNaN(value = number(valueof(values[i], i, values)))) {\n        delta = value - mean;\n        mean += delta / ++m;\n        sum += delta * (value - mean);\n      }\n    }\n  }\n\n  if (m > 1) return sum / (m - 1);\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-array/src/deviation.js\n\n\n/* harmony default export */ var deviation = (function(array, f) {\n  var v = variance(array, f);\n  return v ? Math.sqrt(v) : v;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-array/src/extent.js\n/* harmony default export */ var src_extent = (function(values, valueof) {\n  var n = values.length,\n      i = -1,\n      value,\n      min,\n      max;\n\n  if (valueof == null) {\n    while (++i < n) { // Find the first comparable value.\n      if ((value = values[i]) != null && value >= value) {\n        min = max = value;\n        while (++i < n) { // Compare the remaining values.\n          if ((value = values[i]) != null) {\n            if (min > value) min = value;\n            if (max < value) max = value;\n          }\n        }\n      }\n    }\n  }\n\n  else {\n    while (++i < n) { // Find the first comparable value.\n      if ((value = valueof(values[i], i, values)) != null && value >= value) {\n        min = max = value;\n        while (++i < n) { // Compare the remaining values.\n          if ((value = valueof(values[i], i, values)) != null) {\n            if (min > value) min = value;\n            if (max < value) max = value;\n          }\n        }\n      }\n    }\n  }\n\n  return [min, max];\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-array/src/array.js\nvar array_array = Array.prototype;\n\nvar slice = array_array.slice;\nvar map = array_array.map;\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-array/src/constant.js\n/* harmony default export */ var constant = (function(x) {\n  return function() {\n    return x;\n  };\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-array/src/identity.js\n/* harmony default export */ var identity = (function(x) {\n  return x;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-array/src/range.js\n/* harmony default export */ var src_range = (function(start, stop, step) {\n  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;\n\n  var i = -1,\n      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,\n      range = new Array(n);\n\n  while (++i < n) {\n    range[i] = start + i * step;\n  }\n\n  return range;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-array/src/ticks.js\nvar e10 = Math.sqrt(50),\n    e5 = Math.sqrt(10),\n    e2 = Math.sqrt(2);\n\n/* harmony default export */ var src_ticks = (function(start, stop, count) {\n  var reverse,\n      i = -1,\n      n,\n      ticks,\n      step;\n\n  stop = +stop, start = +start, count = +count;\n  if (start === stop && count > 0) return [start];\n  if (reverse = stop < start) n = start, start = stop, stop = n;\n  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];\n\n  if (step > 0) {\n    start = Math.ceil(start / step);\n    stop = Math.floor(stop / step);\n    ticks = new Array(n = Math.ceil(stop - start + 1));\n    while (++i < n) ticks[i] = (start + i) * step;\n  } else {\n    start = Math.floor(start * step);\n    stop = Math.ceil(stop * step);\n    ticks = new Array(n = Math.ceil(start - stop + 1));\n    while (++i < n) ticks[i] = (start - i) / step;\n  }\n\n  if (reverse) ticks.reverse();\n\n  return ticks;\n});\n\nfunction tickIncrement(start, stop, count) {\n  var step = (stop - start) / Math.max(0, count),\n      power = Math.floor(Math.log(step) / Math.LN10),\n      error = step / Math.pow(10, power);\n  return power >= 0\n      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)\n      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);\n}\n\nfunction tickStep(start, stop, count) {\n  var step0 = Math.abs(stop - start) / Math.max(0, count),\n      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),\n      error = step0 / step1;\n  if (error >= e10) step1 *= 10;\n  else if (error >= e5) step1 *= 5;\n  else if (error >= e2) step1 *= 2;\n  return stop < start ? -step1 : step1;\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-array/src/threshold/sturges.js\n/* harmony default export */ var sturges = (function(values) {\n  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-array/src/histogram.js\n\n\n\n\n\n\n\n\n\n/* harmony default export */ var src_histogram = (function() {\n  var value = identity,\n      domain = src_extent,\n      threshold = sturges;\n\n  function histogram(data) {\n    var i,\n        n = data.length,\n        x,\n        values = new Array(n);\n\n    for (i = 0; i < n; ++i) {\n      values[i] = value(data[i], i, data);\n    }\n\n    var xz = domain(values),\n        x0 = xz[0],\n        x1 = xz[1],\n        tz = threshold(values, x0, x1);\n\n    // Convert number of thresholds into uniform thresholds.\n    if (!Array.isArray(tz)) {\n      tz = tickStep(x0, x1, tz);\n      tz = src_range(Math.ceil(x0 / tz) * tz, x1, tz); // exclusive\n    }\n\n    // Remove any thresholds outside the domain.\n    var m = tz.length;\n    while (tz[0] <= x0) tz.shift(), --m;\n    while (tz[m - 1] > x1) tz.pop(), --m;\n\n    var bins = new Array(m + 1),\n        bin;\n\n    // Initialize bins.\n    for (i = 0; i <= m; ++i) {\n      bin = bins[i] = [];\n      bin.x0 = i > 0 ? tz[i - 1] : x0;\n      bin.x1 = i < m ? tz[i] : x1;\n    }\n\n    // Assign data to bins by value, ignoring any outside the domain.\n    for (i = 0; i < n; ++i) {\n      x = values[i];\n      if (x0 <= x && x <= x1) {\n        bins[bisect(tz, x, 0, m)].push(data[i]);\n      }\n    }\n\n    return bins;\n  }\n\n  histogram.value = function(_) {\n    return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;\n  };\n\n  histogram.domain = function(_) {\n    return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;\n  };\n\n  histogram.thresholds = function(_) {\n    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;\n  };\n\n  return histogram;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-array/src/quantile.js\n\n\n/* harmony default export */ var quantile = (function(values, p, valueof) {\n  if (valueof == null) valueof = number;\n  if (!(n = values.length)) return;\n  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);\n  if (p >= 1) return +valueof(values[n - 1], n - 1, values);\n  var n,\n      i = (n - 1) * p,\n      i0 = Math.floor(i),\n      value0 = +valueof(values[i0], i0, values),\n      value1 = +valueof(values[i0 + 1], i0 + 1, values);\n  return value0 + (value1 - value0) * (i - i0);\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-array/src/threshold/freedmanDiaconis.js\n\n\n\n\n\n/* harmony default export */ var freedmanDiaconis = (function(values, min, max) {\n  values = map.call(values, number).sort(ascending);\n  return Math.ceil((max - min) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(values.length, -1 / 3)));\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-array/src/threshold/scott.js\n\n\n/* harmony default export */ var scott = (function(values, min, max) {\n  return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-array/src/max.js\n/* harmony default export */ var src_max = (function(values, valueof) {\n  var n = values.length,\n      i = -1,\n      value,\n      max;\n\n  if (valueof == null) {\n    while (++i < n) { // Find the first comparable value.\n      if ((value = values[i]) != null && value >= value) {\n        max = value;\n        while (++i < n) { // Compare the remaining values.\n          if ((value = values[i]) != null && value > max) {\n            max = value;\n          }\n        }\n      }\n    }\n  }\n\n  else {\n    while (++i < n) { // Find the first comparable value.\n      if ((value = valueof(values[i], i, values)) != null && value >= value) {\n        max = value;\n        while (++i < n) { // Compare the remaining values.\n          if ((value = valueof(values[i], i, values)) != null && value > max) {\n            max = value;\n          }\n        }\n      }\n    }\n  }\n\n  return max;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-array/src/mean.js\n\n\n/* harmony default export */ var src_mean = (function(values, valueof) {\n  var n = values.length,\n      m = n,\n      i = -1,\n      value,\n      sum = 0;\n\n  if (valueof == null) {\n    while (++i < n) {\n      if (!isNaN(value = number(values[i]))) sum += value;\n      else --m;\n    }\n  }\n\n  else {\n    while (++i < n) {\n      if (!isNaN(value = number(valueof(values[i], i, values)))) sum += value;\n      else --m;\n    }\n  }\n\n  if (m) return sum / m;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-array/src/median.js\n\n\n\n\n/* harmony default export */ var median = (function(values, valueof) {\n  var n = values.length,\n      i = -1,\n      value,\n      numbers = [];\n\n  if (valueof == null) {\n    while (++i < n) {\n      if (!isNaN(value = number(values[i]))) {\n        numbers.push(value);\n      }\n    }\n  }\n\n  else {\n    while (++i < n) {\n      if (!isNaN(value = number(valueof(values[i], i, values)))) {\n        numbers.push(value);\n      }\n    }\n  }\n\n  return quantile(numbers.sort(ascending), 0.5);\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-array/src/merge.js\n/* harmony default export */ var merge = (function(arrays) {\n  var n = arrays.length,\n      m,\n      i = -1,\n      j = 0,\n      merged,\n      array;\n\n  while (++i < n) j += arrays[i].length;\n  merged = new Array(j);\n\n  while (--n >= 0) {\n    array = arrays[n];\n    m = array.length;\n    while (--m >= 0) {\n      merged[--j] = array[m];\n    }\n  }\n\n  return merged;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-array/src/min.js\n/* harmony default export */ var src_min = (function(values, valueof) {\n  var n = values.length,\n      i = -1,\n      value,\n      min;\n\n  if (valueof == null) {\n    while (++i < n) { // Find the first comparable value.\n      if ((value = values[i]) != null && value >= value) {\n        min = value;\n        while (++i < n) { // Compare the remaining values.\n          if ((value = values[i]) != null && min > value) {\n            min = value;\n          }\n        }\n      }\n    }\n  }\n\n  else {\n    while (++i < n) { // Find the first comparable value.\n      if ((value = valueof(values[i], i, values)) != null && value >= value) {\n        min = value;\n        while (++i < n) { // Compare the remaining values.\n          if ((value = valueof(values[i], i, values)) != null && min > value) {\n            min = value;\n          }\n        }\n      }\n    }\n  }\n\n  return min;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-array/src/permute.js\n/* harmony default export */ var permute = (function(array, indexes) {\n  var i = indexes.length, permutes = new Array(i);\n  while (i--) permutes[i] = array[indexes[i]];\n  return permutes;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-array/src/scan.js\n\n\n/* harmony default export */ var scan = (function(values, compare) {\n  if (!(n = values.length)) return;\n  var n,\n      i = 0,\n      j = 0,\n      xi,\n      xj = values[j];\n\n  if (compare == null) compare = ascending;\n\n  while (++i < n) {\n    if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {\n      xj = xi, j = i;\n    }\n  }\n\n  if (compare(xj, xj) === 0) return j;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-array/src/shuffle.js\n/* harmony default export */ var shuffle = (function(array, i0, i1) {\n  var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),\n      t,\n      i;\n\n  while (m) {\n    i = Math.random() * m-- | 0;\n    t = array[m + i0];\n    array[m + i0] = array[i + i0];\n    array[i + i0] = t;\n  }\n\n  return array;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-array/src/sum.js\n/* harmony default export */ var src_sum = (function(values, valueof) {\n  var n = values.length,\n      i = -1,\n      value,\n      sum = 0;\n\n  if (valueof == null) {\n    while (++i < n) {\n      if (value = +values[i]) sum += value; // Note: zero and null are equivalent.\n    }\n  }\n\n  else {\n    while (++i < n) {\n      if (value = +valueof(values[i], i, values)) sum += value;\n    }\n  }\n\n  return sum;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-array/src/transpose.js\n\n\n/* harmony default export */ var src_transpose = (function(matrix) {\n  if (!(n = matrix.length)) return [];\n  for (var i = -1, m = src_min(matrix, transpose_length), transpose = new Array(m); ++i < m;) {\n    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {\n      row[j] = matrix[j][i];\n    }\n  }\n  return transpose;\n});\n\nfunction transpose_length(d) {\n  return d.length;\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-array/src/zip.js\n\n\n/* harmony default export */ var zip = (function() {\n  return src_transpose(arguments);\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-array/src/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/@vx/scale/node_modules/d3-scale/src/init.js\nfunction initRange(domain, range) {\n  switch (arguments.length) {\n    case 0: break;\n    case 1: this.range(domain); break;\n    default: this.range(range).domain(domain); break;\n  }\n  return this;\n}\n\nfunction initInterpolator(domain, interpolator) {\n  switch (arguments.length) {\n    case 0: break;\n    case 1: this.interpolator(domain); break;\n    default: this.interpolator(interpolator).domain(domain); break;\n  }\n  return this;\n}\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-collection/src/index.js + 6 modules\nvar src = __webpack_require__(407);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/@vx/scale/node_modules/d3-scale/src/array.js\nvar src_array_array = Array.prototype;\n\nvar array_map = src_array_array.map;\nvar array_slice = src_array_array.slice;\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/@vx/scale/node_modules/d3-scale/src/ordinal.js\n\n\n\n\nvar implicit = {name: "implicit"};\n\nfunction ordinal() {\n  var index = Object(src["map"])(),\n      domain = [],\n      range = [],\n      unknown = implicit;\n\n  function scale(d) {\n    var key = d + "", i = index.get(key);\n    if (!i) {\n      if (unknown !== implicit) return unknown;\n      index.set(key, i = domain.push(d));\n    }\n    return range[(i - 1) % range.length];\n  }\n\n  scale.domain = function(_) {\n    if (!arguments.length) return domain.slice();\n    domain = [], index = Object(src["map"])();\n    var i = -1, n = _.length, d, key;\n    while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));\n    return scale;\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = array_slice.call(_), scale) : range.slice();\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  scale.copy = function() {\n    return ordinal(domain, range).unknown(unknown);\n  };\n\n  initRange.apply(scale, arguments);\n\n  return scale;\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/@vx/scale/node_modules/d3-scale/src/band.js\n\n\n\n\nfunction band() {\n  var scale = ordinal().unknown(undefined),\n      domain = scale.domain,\n      ordinalRange = scale.range,\n      range = [0, 1],\n      step,\n      bandwidth,\n      round = false,\n      paddingInner = 0,\n      paddingOuter = 0,\n      align = 0.5;\n\n  delete scale.unknown;\n\n  function rescale() {\n    var n = domain().length,\n        reverse = range[1] < range[0],\n        start = range[reverse - 0],\n        stop = range[1 - reverse];\n    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);\n    if (round) step = Math.floor(step);\n    start += (stop - start - step * (n - paddingInner)) * align;\n    bandwidth = step * (1 - paddingInner);\n    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);\n    var values = src_range(n).map(function(i) { return start + step * i; });\n    return ordinalRange(reverse ? values.reverse() : values);\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain(_), rescale()) : domain();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = [+_[0], +_[1]], rescale()) : range.slice();\n  };\n\n  scale.rangeRound = function(_) {\n    return range = [+_[0], +_[1]], round = true, rescale();\n  };\n\n  scale.bandwidth = function() {\n    return bandwidth;\n  };\n\n  scale.step = function() {\n    return step;\n  };\n\n  scale.round = function(_) {\n    return arguments.length ? (round = !!_, rescale()) : round;\n  };\n\n  scale.padding = function(_) {\n    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;\n  };\n\n  scale.paddingInner = function(_) {\n    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;\n  };\n\n  scale.paddingOuter = function(_) {\n    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;\n  };\n\n  scale.align = function(_) {\n    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;\n  };\n\n  scale.copy = function() {\n    return band(domain(), range)\n        .round(round)\n        .paddingInner(paddingInner)\n        .paddingOuter(paddingOuter)\n        .align(align);\n  };\n\n  return initRange.apply(rescale(), arguments);\n}\n\nfunction pointish(scale) {\n  var copy = scale.copy;\n\n  scale.padding = scale.paddingOuter;\n  delete scale.paddingInner;\n  delete scale.paddingOuter;\n\n  scale.copy = function() {\n    return pointish(copy());\n  };\n\n  return scale;\n}\n\nfunction point() {\n  return pointish(band.apply(null, arguments).paddingInner(1));\n}\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-interpolate/src/value.js\nvar src_value = __webpack_require__(166);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-interpolate/src/number.js\nvar src_number = __webpack_require__(51);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-interpolate/src/round.js\nvar src_round = __webpack_require__(525);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/@vx/scale/node_modules/d3-scale/src/constant.js\n/* harmony default export */ var src_constant = (function(x) {\n  return function() {\n    return x;\n  };\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/@vx/scale/node_modules/d3-scale/src/number.js\n/* harmony default export */ var d3_scale_src_number = (function(x) {\n  return +x;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/@vx/scale/node_modules/d3-scale/src/continuous.js\n\n\n\n\n\n\nvar unit = [0, 1];\n\nfunction continuous_identity(x) {\n  return x;\n}\n\nfunction normalize(a, b) {\n  return (b -= (a = +a))\n      ? function(x) { return (x - a) / b; }\n      : src_constant(isNaN(b) ? NaN : 0.5);\n}\n\nfunction clamper(domain) {\n  var a = domain[0], b = domain[domain.length - 1], t;\n  if (a > b) t = a, a = b, b = t;\n  return function(x) { return Math.max(a, Math.min(b, x)); };\n}\n\n// normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].\n// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].\nfunction bimap(domain, range, interpolate) {\n  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];\n  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);\n  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);\n  return function(x) { return r0(d0(x)); };\n}\n\nfunction polymap(domain, range, interpolate) {\n  var j = Math.min(domain.length, range.length) - 1,\n      d = new Array(j),\n      r = new Array(j),\n      i = -1;\n\n  // Reverse descending domains.\n  if (domain[j] < domain[0]) {\n    domain = domain.slice().reverse();\n    range = range.slice().reverse();\n  }\n\n  while (++i < j) {\n    d[i] = normalize(domain[i], domain[i + 1]);\n    r[i] = interpolate(range[i], range[i + 1]);\n  }\n\n  return function(x) {\n    var i = bisect(domain, x, 1, j) - 1;\n    return r[i](d[i](x));\n  };\n}\n\nfunction copy(source, target) {\n  return target\n      .domain(source.domain())\n      .range(source.range())\n      .interpolate(source.interpolate())\n      .clamp(source.clamp())\n      .unknown(source.unknown());\n}\n\nfunction transformer() {\n  var domain = unit,\n      range = unit,\n      interpolate = src_value["a" /* default */],\n      transform,\n      untransform,\n      unknown,\n      clamp = continuous_identity,\n      piecewise,\n      output,\n      input;\n\n  function rescale() {\n    piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;\n    output = input = null;\n    return scale;\n  }\n\n  function scale(x) {\n    return isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));\n  }\n\n  scale.invert = function(y) {\n    return clamp(untransform((input || (input = piecewise(range, domain.map(transform), src_number["a" /* default */])))(y)));\n  };\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain = array_map.call(_, d3_scale_src_number), clamp === continuous_identity || (clamp = clamper(domain)), rescale()) : domain.slice();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = array_slice.call(_), rescale()) : range.slice();\n  };\n\n  scale.rangeRound = function(_) {\n    return range = array_slice.call(_), interpolate = src_round["a" /* default */], rescale();\n  };\n\n  scale.clamp = function(_) {\n    return arguments.length ? (clamp = _ ? clamper(domain) : continuous_identity, scale) : clamp !== continuous_identity;\n  };\n\n  scale.interpolate = function(_) {\n    return arguments.length ? (interpolate = _, rescale()) : interpolate;\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  return function(t, u) {\n    transform = t, untransform = u;\n    return rescale();\n  };\n}\n\nfunction continuous(transform, untransform) {\n  return transformer()(transform, untransform);\n}\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-format/src/formatSpecifier.js\nvar formatSpecifier = __webpack_require__(267);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-format/src/precisionPrefix.js\nvar precisionPrefix = __webpack_require__(655);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-format/src/defaultLocale.js\nvar defaultLocale = __webpack_require__(312);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-format/src/precisionRound.js\nvar precisionRound = __webpack_require__(656);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-format/src/precisionFixed.js\nvar precisionFixed = __webpack_require__(657);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/@vx/scale/node_modules/d3-scale/src/tickFormat.js\n\n\n\n/* harmony default export */ var src_tickFormat = (function(start, stop, count, specifier) {\n  var step = tickStep(start, stop, count),\n      precision;\n  specifier = Object(formatSpecifier["b" /* default */])(specifier == null ? ",f" : specifier);\n  switch (specifier.type) {\n    case "s": {\n      var value = Math.max(Math.abs(start), Math.abs(stop));\n      if (specifier.precision == null && !isNaN(precision = Object(precisionPrefix["a" /* default */])(step, value))) specifier.precision = precision;\n      return Object(defaultLocale["c" /* formatPrefix */])(specifier, value);\n    }\n    case "":\n    case "e":\n    case "g":\n    case "p":\n    case "r": {\n      if (specifier.precision == null && !isNaN(precision = Object(precisionRound["a" /* default */])(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");\n      break;\n    }\n    case "f":\n    case "%": {\n      if (specifier.precision == null && !isNaN(precision = Object(precisionFixed["a" /* default */])(step))) specifier.precision = precision - (specifier.type === "%") * 2;\n      break;\n    }\n  }\n  return Object(defaultLocale["b" /* format */])(specifier);\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/@vx/scale/node_modules/d3-scale/src/linear.js\n\n\n\n\n\nfunction linearish(scale) {\n  var domain = scale.domain;\n\n  scale.ticks = function(count) {\n    var d = domain();\n    return src_ticks(d[0], d[d.length - 1], count == null ? 10 : count);\n  };\n\n  scale.tickFormat = function(count, specifier) {\n    var d = domain();\n    return src_tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);\n  };\n\n  scale.nice = function(count) {\n    if (count == null) count = 10;\n\n    var d = domain(),\n        i0 = 0,\n        i1 = d.length - 1,\n        start = d[i0],\n        stop = d[i1],\n        step;\n\n    if (stop < start) {\n      step = start, start = stop, stop = step;\n      step = i0, i0 = i1, i1 = step;\n    }\n\n    step = tickIncrement(start, stop, count);\n\n    if (step > 0) {\n      start = Math.floor(start / step) * step;\n      stop = Math.ceil(stop / step) * step;\n      step = tickIncrement(start, stop, count);\n    } else if (step < 0) {\n      start = Math.ceil(start * step) / step;\n      stop = Math.floor(stop * step) / step;\n      step = tickIncrement(start, stop, count);\n    }\n\n    if (step > 0) {\n      d[i0] = Math.floor(start / step) * step;\n      d[i1] = Math.ceil(stop / step) * step;\n      domain(d);\n    } else if (step < 0) {\n      d[i0] = Math.ceil(start * step) / step;\n      d[i1] = Math.floor(stop * step) / step;\n      domain(d);\n    }\n\n    return scale;\n  };\n\n  return scale;\n}\n\nfunction linear() {\n  var scale = continuous(continuous_identity, continuous_identity);\n\n  scale.copy = function() {\n    return copy(scale, linear());\n  };\n\n  initRange.apply(scale, arguments);\n\n  return linearish(scale);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/@vx/scale/node_modules/d3-scale/src/identity.js\n\n\n\n\nfunction identity_identity(domain) {\n  var unknown;\n\n  function scale(x) {\n    return isNaN(x = +x) ? unknown : x;\n  }\n\n  scale.invert = scale;\n\n  scale.domain = scale.range = function(_) {\n    return arguments.length ? (domain = array_map.call(_, d3_scale_src_number), scale) : domain.slice();\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  scale.copy = function() {\n    return identity_identity(domain).unknown(unknown);\n  };\n\n  domain = arguments.length ? array_map.call(domain, d3_scale_src_number) : [0, 1];\n\n  return linearish(scale);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/@vx/scale/node_modules/d3-scale/src/nice.js\n/* harmony default export */ var src_nice = (function(domain, interval) {\n  domain = domain.slice();\n\n  var i0 = 0,\n      i1 = domain.length - 1,\n      x0 = domain[i0],\n      x1 = domain[i1],\n      t;\n\n  if (x1 < x0) {\n    t = i0, i0 = i1, i1 = t;\n    t = x0, x0 = x1, x1 = t;\n  }\n\n  domain[i0] = interval.floor(x0);\n  domain[i1] = interval.ceil(x1);\n  return domain;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/@vx/scale/node_modules/d3-scale/src/log.js\n\n\n\n\n\n\nfunction transformLog(x) {\n  return Math.log(x);\n}\n\nfunction transformExp(x) {\n  return Math.exp(x);\n}\n\nfunction transformLogn(x) {\n  return -Math.log(-x);\n}\n\nfunction transformExpn(x) {\n  return -Math.exp(-x);\n}\n\nfunction pow10(x) {\n  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;\n}\n\nfunction powp(base) {\n  return base === 10 ? pow10\n      : base === Math.E ? Math.exp\n      : function(x) { return Math.pow(base, x); };\n}\n\nfunction logp(base) {\n  return base === Math.E ? Math.log\n      : base === 10 && Math.log10\n      || base === 2 && Math.log2\n      || (base = Math.log(base), function(x) { return Math.log(x) / base; });\n}\n\nfunction reflect(f) {\n  return function(x) {\n    return -f(-x);\n  };\n}\n\nfunction loggish(transform) {\n  var scale = transform(transformLog, transformExp),\n      domain = scale.domain,\n      base = 10,\n      logs,\n      pows;\n\n  function rescale() {\n    logs = logp(base), pows = powp(base);\n    if (domain()[0] < 0) {\n      logs = reflect(logs), pows = reflect(pows);\n      transform(transformLogn, transformExpn);\n    } else {\n      transform(transformLog, transformExp);\n    }\n    return scale;\n  }\n\n  scale.base = function(_) {\n    return arguments.length ? (base = +_, rescale()) : base;\n  };\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain(_), rescale()) : domain();\n  };\n\n  scale.ticks = function(count) {\n    var d = domain(),\n        u = d[0],\n        v = d[d.length - 1],\n        r;\n\n    if (r = v < u) i = u, u = v, v = i;\n\n    var i = logs(u),\n        j = logs(v),\n        p,\n        k,\n        t,\n        n = count == null ? 10 : +count,\n        z = [];\n\n    if (!(base % 1) && j - i < n) {\n      i = Math.round(i) - 1, j = Math.round(j) + 1;\n      if (u > 0) for (; i < j; ++i) {\n        for (k = 1, p = pows(i); k < base; ++k) {\n          t = p * k;\n          if (t < u) continue;\n          if (t > v) break;\n          z.push(t);\n        }\n      } else for (; i < j; ++i) {\n        for (k = base - 1, p = pows(i); k >= 1; --k) {\n          t = p * k;\n          if (t < u) continue;\n          if (t > v) break;\n          z.push(t);\n        }\n      }\n    } else {\n      z = src_ticks(i, j, Math.min(j - i, n)).map(pows);\n    }\n\n    return r ? z.reverse() : z;\n  };\n\n  scale.tickFormat = function(count, specifier) {\n    if (specifier == null) specifier = base === 10 ? ".0e" : ",";\n    if (typeof specifier !== "function") specifier = Object(defaultLocale["b" /* format */])(specifier);\n    if (count === Infinity) return specifier;\n    if (count == null) count = 10;\n    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?\n    return function(d) {\n      var i = d / pows(Math.round(logs(d)));\n      if (i * base < base - 0.5) i *= base;\n      return i <= k ? specifier(d) : "";\n    };\n  };\n\n  scale.nice = function() {\n    return domain(src_nice(domain(), {\n      floor: function(x) { return pows(Math.floor(logs(x))); },\n      ceil: function(x) { return pows(Math.ceil(logs(x))); }\n    }));\n  };\n\n  return scale;\n}\n\nfunction log() {\n  var scale = loggish(transformer()).domain([1, 10]);\n\n  scale.copy = function() {\n    return copy(scale, log()).base(scale.base());\n  };\n\n  initRange.apply(scale, arguments);\n\n  return scale;\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/@vx/scale/node_modules/d3-scale/src/symlog.js\n\n\n\n\nfunction transformSymlog(c) {\n  return function(x) {\n    return Math.sign(x) * Math.log1p(Math.abs(x / c));\n  };\n}\n\nfunction transformSymexp(c) {\n  return function(x) {\n    return Math.sign(x) * Math.expm1(Math.abs(x)) * c;\n  };\n}\n\nfunction symlogish(transform) {\n  var c = 1, scale = transform(transformSymlog(c), transformSymexp(c));\n\n  scale.constant = function(_) {\n    return arguments.length ? transform(transformSymlog(c = +_), transformSymexp(c)) : c;\n  };\n\n  return linearish(scale);\n}\n\nfunction symlog() {\n  var scale = symlogish(transformer());\n\n  scale.copy = function() {\n    return copy(scale, symlog()).constant(scale.constant());\n  };\n\n  return initRange.apply(scale, arguments);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/@vx/scale/node_modules/d3-scale/src/pow.js\n\n\n\n\nfunction transformPow(exponent) {\n  return function(x) {\n    return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);\n  };\n}\n\nfunction transformSqrt(x) {\n  return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);\n}\n\nfunction transformSquare(x) {\n  return x < 0 ? -x * x : x * x;\n}\n\nfunction powish(transform) {\n  var scale = transform(continuous_identity, continuous_identity),\n      exponent = 1;\n\n  function rescale() {\n    return exponent === 1 ? transform(continuous_identity, continuous_identity)\n        : exponent === 0.5 ? transform(transformSqrt, transformSquare)\n        : transform(transformPow(exponent), transformPow(1 / exponent));\n  }\n\n  scale.exponent = function(_) {\n    return arguments.length ? (exponent = +_, rescale()) : exponent;\n  };\n\n  return linearish(scale);\n}\n\nfunction pow() {\n  var scale = powish(transformer());\n\n  scale.copy = function() {\n    return copy(scale, pow()).exponent(scale.exponent());\n  };\n\n  initRange.apply(scale, arguments);\n\n  return scale;\n}\n\nfunction sqrt() {\n  return pow.apply(null, arguments).exponent(0.5);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/@vx/scale/node_modules/d3-scale/src/quantile.js\n\n\n\n\nfunction quantile_quantile() {\n  var domain = [],\n      range = [],\n      thresholds = [],\n      unknown;\n\n  function rescale() {\n    var i = 0, n = Math.max(1, range.length);\n    thresholds = new Array(n - 1);\n    while (++i < n) thresholds[i - 1] = quantile(domain, i / n);\n    return scale;\n  }\n\n  function scale(x) {\n    return isNaN(x = +x) ? unknown : range[bisect(thresholds, x)];\n  }\n\n  scale.invertExtent = function(y) {\n    var i = range.indexOf(y);\n    return i < 0 ? [NaN, NaN] : [\n      i > 0 ? thresholds[i - 1] : domain[0],\n      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]\n    ];\n  };\n\n  scale.domain = function(_) {\n    if (!arguments.length) return domain.slice();\n    domain = [];\n    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);\n    domain.sort(ascending);\n    return rescale();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = array_slice.call(_), rescale()) : range.slice();\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  scale.quantiles = function() {\n    return thresholds.slice();\n  };\n\n  scale.copy = function() {\n    return quantile_quantile()\n        .domain(domain)\n        .range(range)\n        .unknown(unknown);\n  };\n\n  return initRange.apply(scale, arguments);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/@vx/scale/node_modules/d3-scale/src/quantize.js\n\n\n\n\n\nfunction quantize() {\n  var x0 = 0,\n      x1 = 1,\n      n = 1,\n      domain = [0.5],\n      range = [0, 1],\n      unknown;\n\n  function scale(x) {\n    return x <= x ? range[bisect(domain, x, 0, n)] : unknown;\n  }\n\n  function rescale() {\n    var i = -1;\n    domain = new Array(n);\n    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);\n    return scale;\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (n = (range = array_slice.call(_)).length - 1, rescale()) : range.slice();\n  };\n\n  scale.invertExtent = function(y) {\n    var i = range.indexOf(y);\n    return i < 0 ? [NaN, NaN]\n        : i < 1 ? [x0, domain[0]]\n        : i >= n ? [domain[n - 1], x1]\n        : [domain[i - 1], domain[i]];\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : scale;\n  };\n\n  scale.thresholds = function() {\n    return domain.slice();\n  };\n\n  scale.copy = function() {\n    return quantize()\n        .domain([x0, x1])\n        .range(range)\n        .unknown(unknown);\n  };\n\n  return initRange.apply(linearish(scale), arguments);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/@vx/scale/node_modules/d3-scale/src/threshold.js\n\n\n\n\nfunction threshold_threshold() {\n  var domain = [0.5],\n      range = [0, 1],\n      unknown,\n      n = 1;\n\n  function scale(x) {\n    return x <= x ? range[bisect(domain, x, 0, n)] : unknown;\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain = array_slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = array_slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();\n  };\n\n  scale.invertExtent = function(y) {\n    var i = range.indexOf(y);\n    return [domain[i - 1], domain[i]];\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  scale.copy = function() {\n    return threshold_threshold()\n        .domain(domain)\n        .range(range)\n        .unknown(unknown);\n  };\n\n  return initRange.apply(scale, arguments);\n}\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/year.js\nvar src_year = __webpack_require__(125);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/month.js\nvar src_month = __webpack_require__(376);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/week.js\nvar src_week = __webpack_require__(26);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/day.js\nvar src_day = __webpack_require__(224);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/hour.js\nvar src_hour = __webpack_require__(377);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/minute.js\nvar src_minute = __webpack_require__(378);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/second.js\nvar src_second = __webpack_require__(211);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/millisecond.js\nvar src_millisecond = __webpack_require__(212);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time-format/src/defaultLocale.js\nvar src_defaultLocale = __webpack_require__(648);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/@vx/scale/node_modules/d3-scale/src/time.js\n\n\n\n\n\n\n\n\nvar durationSecond = 1000,\n    durationMinute = durationSecond * 60,\n    durationHour = durationMinute * 60,\n    durationDay = durationHour * 24,\n    durationWeek = durationDay * 7,\n    durationMonth = durationDay * 30,\n    durationYear = durationDay * 365;\n\nfunction date(t) {\n  return new Date(t);\n}\n\nfunction time_number(t) {\n  return t instanceof Date ? +t : +new Date(+t);\n}\n\nfunction calendar(year, month, week, day, hour, minute, second, millisecond, format) {\n  var scale = continuous(continuous_identity, continuous_identity),\n      invert = scale.invert,\n      domain = scale.domain;\n\n  var formatMillisecond = format(".%L"),\n      formatSecond = format(":%S"),\n      formatMinute = format("%I:%M"),\n      formatHour = format("%I %p"),\n      formatDay = format("%a %d"),\n      formatWeek = format("%b %d"),\n      formatMonth = format("%B"),\n      formatYear = format("%Y");\n\n  var tickIntervals = [\n    [second,  1,      durationSecond],\n    [second,  5,  5 * durationSecond],\n    [second, 15, 15 * durationSecond],\n    [second, 30, 30 * durationSecond],\n    [minute,  1,      durationMinute],\n    [minute,  5,  5 * durationMinute],\n    [minute, 15, 15 * durationMinute],\n    [minute, 30, 30 * durationMinute],\n    [  hour,  1,      durationHour  ],\n    [  hour,  3,  3 * durationHour  ],\n    [  hour,  6,  6 * durationHour  ],\n    [  hour, 12, 12 * durationHour  ],\n    [   day,  1,      durationDay   ],\n    [   day,  2,  2 * durationDay   ],\n    [  week,  1,      durationWeek  ],\n    [ month,  1,      durationMonth ],\n    [ month,  3,  3 * durationMonth ],\n    [  year,  1,      durationYear  ]\n  ];\n\n  function tickFormat(date) {\n    return (second(date) < date ? formatMillisecond\n        : minute(date) < date ? formatSecond\n        : hour(date) < date ? formatMinute\n        : day(date) < date ? formatHour\n        : month(date) < date ? (week(date) < date ? formatDay : formatWeek)\n        : year(date) < date ? formatMonth\n        : formatYear)(date);\n  }\n\n  function tickInterval(interval, start, stop, step) {\n    if (interval == null) interval = 10;\n\n    // If a desired tick count is specified, pick a reasonable tick interval\n    // based on the extent of the domain and a rough estimate of tick size.\n    // Otherwise, assume interval is already a time interval and use it.\n    if (typeof interval === "number") {\n      var target = Math.abs(stop - start) / interval,\n          i = bisector(function(i) { return i[2]; }).right(tickIntervals, target);\n      if (i === tickIntervals.length) {\n        step = tickStep(start / durationYear, stop / durationYear, interval);\n        interval = year;\n      } else if (i) {\n        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];\n        step = i[1];\n        interval = i[0];\n      } else {\n        step = Math.max(tickStep(start, stop, interval), 1);\n        interval = millisecond;\n      }\n    }\n\n    return step == null ? interval : interval.every(step);\n  }\n\n  scale.invert = function(y) {\n    return new Date(invert(y));\n  };\n\n  scale.domain = function(_) {\n    return arguments.length ? domain(array_map.call(_, time_number)) : domain().map(date);\n  };\n\n  scale.ticks = function(interval, step) {\n    var d = domain(),\n        t0 = d[0],\n        t1 = d[d.length - 1],\n        r = t1 < t0,\n        t;\n    if (r) t = t0, t0 = t1, t1 = t;\n    t = tickInterval(interval, t0, t1, step);\n    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop\n    return r ? t.reverse() : t;\n  };\n\n  scale.tickFormat = function(count, specifier) {\n    return specifier == null ? tickFormat : format(specifier);\n  };\n\n  scale.nice = function(interval, step) {\n    var d = domain();\n    return (interval = tickInterval(interval, d[0], d[d.length - 1], step))\n        ? domain(src_nice(d, interval))\n        : scale;\n  };\n\n  scale.copy = function() {\n    return copy(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));\n  };\n\n  return scale;\n}\n\n/* harmony default export */ var time = (function() {\n  return initRange.apply(calendar(src_year["a" /* default */], src_month["a" /* default */], src_week["g" /* sunday */], src_day["b" /* default */], src_hour["a" /* default */], src_minute["a" /* default */], src_second["a" /* default */], src_millisecond["a" /* default */], src_defaultLocale["a" /* timeFormat */]).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);\n});\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/utcYear.js\nvar utcYear = __webpack_require__(126);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/utcMonth.js\nvar utcMonth = __webpack_require__(379);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/utcWeek.js\nvar utcWeek = __webpack_require__(27);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/utcDay.js\nvar utcDay = __webpack_require__(225);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/utcHour.js\nvar utcHour = __webpack_require__(380);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/utcMinute.js\nvar utcMinute = __webpack_require__(381);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/@vx/scale/node_modules/d3-scale/src/utcTime.js\n\n\n\n\n\n/* harmony default export */ var utcTime = (function() {\n  return initRange.apply(calendar(utcYear["a" /* default */], utcMonth["a" /* default */], utcWeek["g" /* utcSunday */], utcDay["a" /* default */], utcHour["a" /* default */], utcMinute["a" /* default */], src_second["a" /* default */], src_millisecond["a" /* default */], src_defaultLocale["b" /* utcFormat */]).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]), arguments);\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/@vx/scale/node_modules/d3-scale/src/sequential.js\n\n\n\n\n\n\n\nfunction sequential_transformer() {\n  var x0 = 0,\n      x1 = 1,\n      t0,\n      t1,\n      k10,\n      transform,\n      interpolator = continuous_identity,\n      clamp = false,\n      unknown;\n\n  function scale(x) {\n    return isNaN(x = +x) ? unknown : interpolator(k10 === 0 ? 0.5 : (x = (transform(x) - t0) * k10, clamp ? Math.max(0, Math.min(1, x)) : x));\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (t0 = transform(x0 = +_[0]), t1 = transform(x1 = +_[1]), k10 = t0 === t1 ? 0 : 1 / (t1 - t0), scale) : [x0, x1];\n  };\n\n  scale.clamp = function(_) {\n    return arguments.length ? (clamp = !!_, scale) : clamp;\n  };\n\n  scale.interpolator = function(_) {\n    return arguments.length ? (interpolator = _, scale) : interpolator;\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  return function(t) {\n    transform = t, t0 = t(x0), t1 = t(x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0);\n    return scale;\n  };\n}\n\nfunction sequential_copy(source, target) {\n  return target\n      .domain(source.domain())\n      .interpolator(source.interpolator())\n      .clamp(source.clamp())\n      .unknown(source.unknown());\n}\n\nfunction sequential() {\n  var scale = linearish(sequential_transformer()(continuous_identity));\n\n  scale.copy = function() {\n    return sequential_copy(scale, sequential());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction sequentialLog() {\n  var scale = loggish(sequential_transformer()).domain([1, 10]);\n\n  scale.copy = function() {\n    return sequential_copy(scale, sequentialLog()).base(scale.base());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction sequentialSymlog() {\n  var scale = symlogish(sequential_transformer());\n\n  scale.copy = function() {\n    return sequential_copy(scale, sequentialSymlog()).constant(scale.constant());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction sequentialPow() {\n  var scale = powish(sequential_transformer());\n\n  scale.copy = function() {\n    return sequential_copy(scale, sequentialPow()).exponent(scale.exponent());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction sequentialSqrt() {\n  return sequentialPow.apply(null, arguments).exponent(0.5);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/@vx/scale/node_modules/d3-scale/src/sequentialQuantile.js\n\n\n\n\nfunction sequentialQuantile() {\n  var domain = [],\n      interpolator = continuous_identity;\n\n  function scale(x) {\n    if (!isNaN(x = +x)) return interpolator((bisect(domain, x) - 1) / (domain.length - 1));\n  }\n\n  scale.domain = function(_) {\n    if (!arguments.length) return domain.slice();\n    domain = [];\n    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);\n    domain.sort(ascending);\n    return scale;\n  };\n\n  scale.interpolator = function(_) {\n    return arguments.length ? (interpolator = _, scale) : interpolator;\n  };\n\n  scale.copy = function() {\n    return sequentialQuantile(interpolator).domain(domain);\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/@vx/scale/node_modules/d3-scale/src/diverging.js\n\n\n\n\n\n\n\n\nfunction diverging_transformer() {\n  var x0 = 0,\n      x1 = 0.5,\n      x2 = 1,\n      t0,\n      t1,\n      t2,\n      k10,\n      k21,\n      interpolator = continuous_identity,\n      transform,\n      clamp = false,\n      unknown;\n\n  function scale(x) {\n    return isNaN(x = +x) ? unknown : (x = 0.5 + ((x = +transform(x)) - t1) * (x < t1 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x)) : x));\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (t0 = transform(x0 = +_[0]), t1 = transform(x1 = +_[1]), t2 = transform(x2 = +_[2]), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), scale) : [x0, x1, x2];\n  };\n\n  scale.clamp = function(_) {\n    return arguments.length ? (clamp = !!_, scale) : clamp;\n  };\n\n  scale.interpolator = function(_) {\n    return arguments.length ? (interpolator = _, scale) : interpolator;\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  return function(t) {\n    transform = t, t0 = t(x0), t1 = t(x1), t2 = t(x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1);\n    return scale;\n  };\n}\n\nfunction diverging() {\n  var scale = linearish(diverging_transformer()(continuous_identity));\n\n  scale.copy = function() {\n    return sequential_copy(scale, diverging());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction divergingLog() {\n  var scale = loggish(diverging_transformer()).domain([0.1, 1, 10]);\n\n  scale.copy = function() {\n    return sequential_copy(scale, divergingLog()).base(scale.base());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction divergingSymlog() {\n  var scale = symlogish(diverging_transformer());\n\n  scale.copy = function() {\n    return sequential_copy(scale, divergingSymlog()).constant(scale.constant());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction divergingPow() {\n  var scale = powish(diverging_transformer());\n\n  scale.copy = function() {\n    return sequential_copy(scale, divergingPow()).exponent(scale.exponent());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction divergingSqrt() {\n  return divergingPow.apply(null, arguments).exponent(0.5);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/@vx/scale/node_modules/d3-scale/src/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/@vx/scale/dist/vx-scale.es.js\n\n\nvar vx_scale_es_band = (function (_ref) {\n  var range = _ref.range,\n      rangeRound = _ref.rangeRound,\n      domain = _ref.domain,\n      padding = _ref.padding,\n      paddingInner = _ref.paddingInner,\n      paddingOuter = _ref.paddingOuter,\n      align = _ref.align,\n      tickFormat = _ref.tickFormat;\n\n  var scale = band();\n  scale.type = \'band\';\n\n  if (range) scale.range(range);\n  if (rangeRound) scale.rangeRound(rangeRound);\n  if (domain) scale.domain(domain);\n  if (padding) scale.padding(padding);\n  if (paddingInner) scale.paddingInner(paddingInner);\n  if (paddingOuter) scale.paddingOuter(paddingOuter);\n  if (align) scale.align(align);\n  if (tickFormat) scale.tickFormat = tickFormat;\n\n  return scale;\n});\n\nvar vx_scale_es_point = (function (_ref) {\n  var range = _ref.range,\n      rangeRound = _ref.rangeRound,\n      domain = _ref.domain,\n      padding = _ref.padding,\n      align = _ref.align,\n      _ref$nice = _ref.nice,\n      nice = _ref$nice === undefined ? false : _ref$nice;\n\n  var scale = point();\n  scale.type = \'point\';\n\n  if (range) scale.range(range);\n  if (rangeRound) scale.rangeRound(rangeRound);\n  if (domain) scale.domain(domain);\n  if (nice) scale.nice();\n  if (padding) scale.padding(padding);\n  if (align) scale.align(align);\n\n  return scale;\n});\n\nvar vx_scale_es_linear = (function (_ref) {\n  var range = _ref.range,\n      rangeRound = _ref.rangeRound,\n      domain = _ref.domain,\n      _ref$nice = _ref.nice,\n      nice = _ref$nice === undefined ? false : _ref$nice,\n      _ref$clamp = _ref.clamp,\n      clamp = _ref$clamp === undefined ? false : _ref$clamp;\n\n  var scale = linear();\n  scale.type = \'linear\';\n\n  if (range) scale.range(range);\n  if (rangeRound) scale.rangeRound(rangeRound);\n  if (domain) scale.domain(domain);\n  if (nice) scale.nice();\n  if (clamp) scale.clamp(true);\n\n  return scale;\n});\n\nvar vx_scale_es_time = (function (_ref) {\n  var range = _ref.range,\n      rangeRound = _ref.rangeRound,\n      domain = _ref.domain,\n      _ref$nice = _ref.nice,\n      nice = _ref$nice === undefined ? false : _ref$nice,\n      _ref$clamp = _ref.clamp,\n      clamp = _ref$clamp === undefined ? false : _ref$clamp;\n\n  var scale = time();\n  scale.type = \'time\';\n\n  if (range) scale.range(range);\n  if (rangeRound) scale.rangeRound(rangeRound);\n  if (domain) scale.domain(domain);\n  if (nice) scale.nice();\n  if (clamp) scale.clamp(true);\n\n  return scale;\n});\n\nvar utc = (function (_ref) {\n  var range = _ref.range,\n      rangeRound = _ref.rangeRound,\n      domain = _ref.domain,\n      _ref$nice = _ref.nice,\n      nice = _ref$nice === undefined ? false : _ref$nice,\n      _ref$clamp = _ref.clamp,\n      clamp = _ref$clamp === undefined ? false : _ref$clamp;\n\n  var scale = utcTime();\n  scale.type = \'utc\';\n\n  if (range) scale.range(range);\n  if (rangeRound) scale.rangeRound(rangeRound);\n  if (domain) scale.domain(domain);\n  if (nice) scale.nice();\n  if (clamp) scale.clamp(true);\n\n  return scale;\n});\n\nvar vx_scale_es_log = (function (_ref) {\n  var range = _ref.range,\n      rangeRound = _ref.rangeRound,\n      domain = _ref.domain,\n      base = _ref.base,\n      _ref$nice = _ref.nice,\n      nice = _ref$nice === undefined ? false : _ref$nice,\n      _ref$clamp = _ref.clamp,\n      clamp = _ref$clamp === undefined ? false : _ref$clamp;\n\n  var scale = log();\n  scale.type = \'log\';\n\n  if (range) scale.range(range);\n  if (rangeRound) scale.rangeRound(rangeRound);\n  if (domain) scale.domain(domain);\n  if (nice) scale.nice();\n  if (clamp) scale.clamp(true);\n  if (base) scale.base(base);\n\n  return scale;\n});\n\nvar power = (function (_ref) {\n  var range = _ref.range,\n      rangeRound = _ref.rangeRound,\n      domain = _ref.domain,\n      exponent = _ref.exponent,\n      _ref$nice = _ref.nice,\n      nice = _ref$nice === undefined ? false : _ref$nice,\n      _ref$clamp = _ref.clamp,\n      clamp = _ref$clamp === undefined ? false : _ref$clamp;\n\n  var scale = pow();\n  scale.type = \'power\';\n\n  if (range) scale.range(range);\n  if (rangeRound) scale.rangeRound(rangeRound);\n  if (domain) scale.domain(domain);\n  if (nice) scale.nice();\n  if (clamp) scale.clamp(true);\n  if (exponent) scale.exponent(exponent);\n\n  return scale;\n});\n\nvar vx_scale_es_ordinal = (function (_ref) {\n  var range = _ref.range,\n      domain = _ref.domain,\n      unknown = _ref.unknown;\n\n  var scale = ordinal();\n  scale.type = \'ordinal\';\n\n  if (range) scale.range(range);\n  if (domain) scale.domain(domain);\n  if (unknown) scale.unknown(unknown);\n\n  return scale;\n});\n\nvar vx_scale_es_quantize = (function (_ref) {\n  var range = _ref.range,\n      domain = _ref.domain,\n      ticks = _ref.ticks,\n      tickFormat = _ref.tickFormat,\n      _ref$nice = _ref.nice,\n      nice = _ref$nice === undefined ? false : _ref$nice;\n\n  var scale = quantize();\n  scale.type = \'quantize\';\n\n  if (range) scale.range(range);\n  if (domain) scale.domain(domain);\n  if (nice) scale.nice();\n  if (ticks) scale.ticks(ticks);\n  if (tickFormat) scale.tickFormat(tickFormat);\n\n  return scale;\n});\n\nvar vx_scale_es_quantile = (function (_ref) {\n  var range = _ref.range,\n      domain = _ref.domain;\n\n  var scale = quantile_quantile();\n  scale.type = \'quantile\';\n\n  if (range) scale.range(range);\n  if (domain) scale.domain(domain);\n\n  return scale;\n});\n\nvar vx_scale_es_threshold = (function (_ref) {\n  var range = _ref.range,\n      domain = _ref.domain;\n\n  var scale = threshold_threshold();\n  scale.type = \'threshold\';\n\n  if (range) scale.range(range);\n  if (domain) scale.domain(domain);\n\n  return scale;\n});\n\nvar objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nvar has = Object.prototype.hasOwnProperty;\n\nfunction updateScale(scale, _ref) {\n  var args = objectWithoutProperties(_ref, []);\n\n  var nextScale = scale.copy();\n  Object.keys(args).forEach(function (key) {\n    if (has.call(nextScale, key)) nextScale[key](args[key]);\n  });\n  return nextScale;\n}\n\n\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/shared/esm/enhancer/WithTooltip.js\nvar WithTooltip = __webpack_require__(2276);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/esm/utils/componentIsX.js\nfunction isAxis(name) {\n  return /axis/gi.test(name);\n}\nfunction isSeries(name) {\n  return /series/gi.test(name);\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/esm/utils/addDensityAndCumulativeValuesToBins.js\n/* eslint no-param-reassign: 0 */\n// bins should minimally have the shape\n// Array<Object{ count: Number }>\nfunction addDensityAndCumulativeValuesToBins(bins) {\n  var cumulative = 0;\n  bins.forEach(function (bin) {\n    cumulative += isNaN(bin.count) ? 0 : bin.count; // eslint-disable-line no-restricted-globals\n\n    bin.cumulative = cumulative;\n  });\n  var total = cumulative;\n  bins.forEach(function (bin) {\n    bin.density = bin.count / total;\n    bin.cumulativeDensity = bin.cumulative / total;\n  });\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-scale/src/array.js\nvar d3_scale_src_array_array = Array.prototype;\n\nvar src_array_map = d3_scale_src_array_array.map;\nvar src_array_slice = d3_scale_src_array_array.slice;\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-scale/src/ordinal.js\n\n\n\nvar ordinal_implicit = {name: "implicit"};\n\nfunction ordinal_ordinal(range) {\n  var index = Object(src["map"])(),\n      domain = [],\n      unknown = ordinal_implicit;\n\n  range = range == null ? [] : src_array_slice.call(range);\n\n  function scale(d) {\n    var key = d + "", i = index.get(key);\n    if (!i) {\n      if (unknown !== ordinal_implicit) return unknown;\n      index.set(key, i = domain.push(d));\n    }\n    return range[(i - 1) % range.length];\n  }\n\n  scale.domain = function(_) {\n    if (!arguments.length) return domain.slice();\n    domain = [], index = Object(src["map"])();\n    var i = -1, n = _.length, d, key;\n    while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));\n    return scale;\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = src_array_slice.call(_), scale) : range.slice();\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  scale.copy = function() {\n    return ordinal_ordinal()\n        .domain(domain)\n        .range(range)\n        .unknown(unknown);\n  };\n\n  return scale;\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-scale/src/band.js\n\n\n\nfunction band_band() {\n  var scale = ordinal_ordinal().unknown(undefined),\n      domain = scale.domain,\n      ordinalRange = scale.range,\n      range = [0, 1],\n      step,\n      bandwidth,\n      round = false,\n      paddingInner = 0,\n      paddingOuter = 0,\n      align = 0.5;\n\n  delete scale.unknown;\n\n  function rescale() {\n    var n = domain().length,\n        reverse = range[1] < range[0],\n        start = range[reverse - 0],\n        stop = range[1 - reverse];\n    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);\n    if (round) step = Math.floor(step);\n    start += (stop - start - step * (n - paddingInner)) * align;\n    bandwidth = step * (1 - paddingInner);\n    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);\n    var values = src_range(n).map(function(i) { return start + step * i; });\n    return ordinalRange(reverse ? values.reverse() : values);\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain(_), rescale()) : domain();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = [+_[0], +_[1]], rescale()) : range.slice();\n  };\n\n  scale.rangeRound = function(_) {\n    return range = [+_[0], +_[1]], round = true, rescale();\n  };\n\n  scale.bandwidth = function() {\n    return bandwidth;\n  };\n\n  scale.step = function() {\n    return step;\n  };\n\n  scale.round = function(_) {\n    return arguments.length ? (round = !!_, rescale()) : round;\n  };\n\n  scale.padding = function(_) {\n    return arguments.length ? (paddingInner = paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;\n  };\n\n  scale.paddingInner = function(_) {\n    return arguments.length ? (paddingInner = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;\n  };\n\n  scale.paddingOuter = function(_) {\n    return arguments.length ? (paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingOuter;\n  };\n\n  scale.align = function(_) {\n    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;\n  };\n\n  scale.copy = function() {\n    return band_band()\n        .domain(domain())\n        .range(range)\n        .round(round)\n        .paddingInner(paddingInner)\n        .paddingOuter(paddingOuter)\n        .align(align);\n  };\n\n  return rescale();\n}\n\nfunction band_pointish(scale) {\n  var copy = scale.copy;\n\n  scale.padding = scale.paddingOuter;\n  delete scale.paddingInner;\n  delete scale.paddingOuter;\n\n  scale.copy = function() {\n    return band_pointish(copy());\n  };\n\n  return scale;\n}\n\nfunction band_point() {\n  return band_pointish(band_band().paddingInner(1));\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-scale/src/constant.js\n/* harmony default export */ var d3_scale_src_constant = (function(x) {\n  return function() {\n    return x;\n  };\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-scale/src/number.js\n/* harmony default export */ var node_modules_d3_scale_src_number = (function(x) {\n  return +x;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-scale/src/continuous.js\n\n\n\n\n\n\nvar continuous_unit = [0, 1];\n\nfunction deinterpolateLinear(a, b) {\n  return (b -= (a = +a))\n      ? function(x) { return (x - a) / b; }\n      : d3_scale_src_constant(b);\n}\n\nfunction deinterpolateClamp(deinterpolate) {\n  return function(a, b) {\n    var d = deinterpolate(a = +a, b = +b);\n    return function(x) { return x <= a ? 0 : x >= b ? 1 : d(x); };\n  };\n}\n\nfunction reinterpolateClamp(reinterpolate) {\n  return function(a, b) {\n    var r = reinterpolate(a = +a, b = +b);\n    return function(t) { return t <= 0 ? a : t >= 1 ? b : r(t); };\n  };\n}\n\nfunction continuous_bimap(domain, range, deinterpolate, reinterpolate) {\n  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];\n  if (d1 < d0) d0 = deinterpolate(d1, d0), r0 = reinterpolate(r1, r0);\n  else d0 = deinterpolate(d0, d1), r0 = reinterpolate(r0, r1);\n  return function(x) { return r0(d0(x)); };\n}\n\nfunction continuous_polymap(domain, range, deinterpolate, reinterpolate) {\n  var j = Math.min(domain.length, range.length) - 1,\n      d = new Array(j),\n      r = new Array(j),\n      i = -1;\n\n  // Reverse descending domains.\n  if (domain[j] < domain[0]) {\n    domain = domain.slice().reverse();\n    range = range.slice().reverse();\n  }\n\n  while (++i < j) {\n    d[i] = deinterpolate(domain[i], domain[i + 1]);\n    r[i] = reinterpolate(range[i], range[i + 1]);\n  }\n\n  return function(x) {\n    var i = bisect(domain, x, 1, j) - 1;\n    return r[i](d[i](x));\n  };\n}\n\nfunction continuous_copy(source, target) {\n  return target\n      .domain(source.domain())\n      .range(source.range())\n      .interpolate(source.interpolate())\n      .clamp(source.clamp());\n}\n\n// deinterpolate(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].\n// reinterpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding domain value x in [a,b].\nfunction continuous_continuous(deinterpolate, reinterpolate) {\n  var domain = continuous_unit,\n      range = continuous_unit,\n      interpolate = src_value["a" /* default */],\n      clamp = false,\n      piecewise,\n      output,\n      input;\n\n  function rescale() {\n    piecewise = Math.min(domain.length, range.length) > 2 ? continuous_polymap : continuous_bimap;\n    output = input = null;\n    return scale;\n  }\n\n  function scale(x) {\n    return (output || (output = piecewise(domain, range, clamp ? deinterpolateClamp(deinterpolate) : deinterpolate, interpolate)))(+x);\n  }\n\n  scale.invert = function(y) {\n    return (input || (input = piecewise(range, domain, deinterpolateLinear, clamp ? reinterpolateClamp(reinterpolate) : reinterpolate)))(+y);\n  };\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain = src_array_map.call(_, node_modules_d3_scale_src_number), rescale()) : domain.slice();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = src_array_slice.call(_), rescale()) : range.slice();\n  };\n\n  scale.rangeRound = function(_) {\n    return range = src_array_slice.call(_), interpolate = src_round["a" /* default */], rescale();\n  };\n\n  scale.clamp = function(_) {\n    return arguments.length ? (clamp = !!_, rescale()) : clamp;\n  };\n\n  scale.interpolate = function(_) {\n    return arguments.length ? (interpolate = _, rescale()) : interpolate;\n  };\n\n  return rescale();\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-scale/src/tickFormat.js\n\n\n\n/* harmony default export */ var d3_scale_src_tickFormat = (function(domain, count, specifier) {\n  var start = domain[0],\n      stop = domain[domain.length - 1],\n      step = tickStep(start, stop, count == null ? 10 : count),\n      precision;\n  specifier = Object(formatSpecifier["b" /* default */])(specifier == null ? ",f" : specifier);\n  switch (specifier.type) {\n    case "s": {\n      var value = Math.max(Math.abs(start), Math.abs(stop));\n      if (specifier.precision == null && !isNaN(precision = Object(precisionPrefix["a" /* default */])(step, value))) specifier.precision = precision;\n      return Object(defaultLocale["c" /* formatPrefix */])(specifier, value);\n    }\n    case "":\n    case "e":\n    case "g":\n    case "p":\n    case "r": {\n      if (specifier.precision == null && !isNaN(precision = Object(precisionRound["a" /* default */])(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");\n      break;\n    }\n    case "f":\n    case "%": {\n      if (specifier.precision == null && !isNaN(precision = Object(precisionFixed["a" /* default */])(step))) specifier.precision = precision - (specifier.type === "%") * 2;\n      break;\n    }\n  }\n  return Object(defaultLocale["b" /* format */])(specifier);\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-scale/src/linear.js\n\n\n\n\n\nfunction linear_linearish(scale) {\n  var domain = scale.domain;\n\n  scale.ticks = function(count) {\n    var d = domain();\n    return src_ticks(d[0], d[d.length - 1], count == null ? 10 : count);\n  };\n\n  scale.tickFormat = function(count, specifier) {\n    return d3_scale_src_tickFormat(domain(), count, specifier);\n  };\n\n  scale.nice = function(count) {\n    if (count == null) count = 10;\n\n    var d = domain(),\n        i0 = 0,\n        i1 = d.length - 1,\n        start = d[i0],\n        stop = d[i1],\n        step;\n\n    if (stop < start) {\n      step = start, start = stop, stop = step;\n      step = i0, i0 = i1, i1 = step;\n    }\n\n    step = tickIncrement(start, stop, count);\n\n    if (step > 0) {\n      start = Math.floor(start / step) * step;\n      stop = Math.ceil(stop / step) * step;\n      step = tickIncrement(start, stop, count);\n    } else if (step < 0) {\n      start = Math.ceil(start * step) / step;\n      stop = Math.floor(stop * step) / step;\n      step = tickIncrement(start, stop, count);\n    }\n\n    if (step > 0) {\n      d[i0] = Math.floor(start / step) * step;\n      d[i1] = Math.ceil(stop / step) * step;\n      domain(d);\n    } else if (step < 0) {\n      d[i0] = Math.ceil(start * step) / step;\n      d[i1] = Math.floor(stop * step) / step;\n      domain(d);\n    }\n\n    return scale;\n  };\n\n  return scale;\n}\n\nfunction linear_linear() {\n  var scale = continuous_continuous(deinterpolateLinear, src_number["a" /* default */]);\n\n  scale.copy = function() {\n    return continuous_copy(scale, linear_linear());\n  };\n\n  return linear_linearish(scale);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-scale/src/identity.js\n\n\n\n\nfunction src_identity_identity() {\n  var domain = [0, 1];\n\n  function scale(x) {\n    return +x;\n  }\n\n  scale.invert = scale;\n\n  scale.domain = scale.range = function(_) {\n    return arguments.length ? (domain = src_array_map.call(_, node_modules_d3_scale_src_number), scale) : domain.slice();\n  };\n\n  scale.copy = function() {\n    return src_identity_identity().domain(domain);\n  };\n\n  return linear_linearish(scale);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-scale/src/nice.js\n/* harmony default export */ var d3_scale_src_nice = (function(domain, interval) {\n  domain = domain.slice();\n\n  var i0 = 0,\n      i1 = domain.length - 1,\n      x0 = domain[i0],\n      x1 = domain[i1],\n      t;\n\n  if (x1 < x0) {\n    t = i0, i0 = i1, i1 = t;\n    t = x0, x0 = x1, x1 = t;\n  }\n\n  domain[i0] = interval.floor(x0);\n  domain[i1] = interval.ceil(x1);\n  return domain;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-scale/src/log.js\n\n\n\n\n\n\nfunction log_deinterpolate(a, b) {\n  return (b = Math.log(b / a))\n      ? function(x) { return Math.log(x / a) / b; }\n      : d3_scale_src_constant(b);\n}\n\nfunction log_reinterpolate(a, b) {\n  return a < 0\n      ? function(t) { return -Math.pow(-b, t) * Math.pow(-a, 1 - t); }\n      : function(t) { return Math.pow(b, t) * Math.pow(a, 1 - t); };\n}\n\nfunction log_pow10(x) {\n  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;\n}\n\nfunction log_powp(base) {\n  return base === 10 ? log_pow10\n      : base === Math.E ? Math.exp\n      : function(x) { return Math.pow(base, x); };\n}\n\nfunction log_logp(base) {\n  return base === Math.E ? Math.log\n      : base === 10 && Math.log10\n      || base === 2 && Math.log2\n      || (base = Math.log(base), function(x) { return Math.log(x) / base; });\n}\n\nfunction log_reflect(f) {\n  return function(x) {\n    return -f(-x);\n  };\n}\n\nfunction log_log() {\n  var scale = continuous_continuous(log_deinterpolate, log_reinterpolate).domain([1, 10]),\n      domain = scale.domain,\n      base = 10,\n      logs = log_logp(10),\n      pows = log_powp(10);\n\n  function rescale() {\n    logs = log_logp(base), pows = log_powp(base);\n    if (domain()[0] < 0) logs = log_reflect(logs), pows = log_reflect(pows);\n    return scale;\n  }\n\n  scale.base = function(_) {\n    return arguments.length ? (base = +_, rescale()) : base;\n  };\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain(_), rescale()) : domain();\n  };\n\n  scale.ticks = function(count) {\n    var d = domain(),\n        u = d[0],\n        v = d[d.length - 1],\n        r;\n\n    if (r = v < u) i = u, u = v, v = i;\n\n    var i = logs(u),\n        j = logs(v),\n        p,\n        k,\n        t,\n        n = count == null ? 10 : +count,\n        z = [];\n\n    if (!(base % 1) && j - i < n) {\n      i = Math.round(i) - 1, j = Math.round(j) + 1;\n      if (u > 0) for (; i < j; ++i) {\n        for (k = 1, p = pows(i); k < base; ++k) {\n          t = p * k;\n          if (t < u) continue;\n          if (t > v) break;\n          z.push(t);\n        }\n      } else for (; i < j; ++i) {\n        for (k = base - 1, p = pows(i); k >= 1; --k) {\n          t = p * k;\n          if (t < u) continue;\n          if (t > v) break;\n          z.push(t);\n        }\n      }\n    } else {\n      z = src_ticks(i, j, Math.min(j - i, n)).map(pows);\n    }\n\n    return r ? z.reverse() : z;\n  };\n\n  scale.tickFormat = function(count, specifier) {\n    if (specifier == null) specifier = base === 10 ? ".0e" : ",";\n    if (typeof specifier !== "function") specifier = Object(defaultLocale["b" /* format */])(specifier);\n    if (count === Infinity) return specifier;\n    if (count == null) count = 10;\n    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?\n    return function(d) {\n      var i = d / pows(Math.round(logs(d)));\n      if (i * base < base - 0.5) i *= base;\n      return i <= k ? specifier(d) : "";\n    };\n  };\n\n  scale.nice = function() {\n    return domain(d3_scale_src_nice(domain(), {\n      floor: function(x) { return pows(Math.floor(logs(x))); },\n      ceil: function(x) { return pows(Math.ceil(logs(x))); }\n    }));\n  };\n\n  scale.copy = function() {\n    return continuous_copy(scale, log_log().base(base));\n  };\n\n  return scale;\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-scale/src/pow.js\n\n\n\n\nfunction raise(x, exponent) {\n  return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);\n}\n\nfunction pow_pow() {\n  var exponent = 1,\n      scale = continuous_continuous(deinterpolate, reinterpolate),\n      domain = scale.domain;\n\n  function deinterpolate(a, b) {\n    return (b = raise(b, exponent) - (a = raise(a, exponent)))\n        ? function(x) { return (raise(x, exponent) - a) / b; }\n        : d3_scale_src_constant(b);\n  }\n\n  function reinterpolate(a, b) {\n    b = raise(b, exponent) - (a = raise(a, exponent));\n    return function(t) { return raise(a + b * t, 1 / exponent); };\n  }\n\n  scale.exponent = function(_) {\n    return arguments.length ? (exponent = +_, domain(domain())) : exponent;\n  };\n\n  scale.copy = function() {\n    return continuous_copy(scale, pow_pow().exponent(exponent));\n  };\n\n  return linear_linearish(scale);\n}\n\nfunction pow_sqrt() {\n  return pow_pow().exponent(0.5);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-scale/src/quantile.js\n\n\n\nfunction src_quantile_quantile() {\n  var domain = [],\n      range = [],\n      thresholds = [];\n\n  function rescale() {\n    var i = 0, n = Math.max(1, range.length);\n    thresholds = new Array(n - 1);\n    while (++i < n) thresholds[i - 1] = quantile(domain, i / n);\n    return scale;\n  }\n\n  function scale(x) {\n    if (!isNaN(x = +x)) return range[bisect(thresholds, x)];\n  }\n\n  scale.invertExtent = function(y) {\n    var i = range.indexOf(y);\n    return i < 0 ? [NaN, NaN] : [\n      i > 0 ? thresholds[i - 1] : domain[0],\n      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]\n    ];\n  };\n\n  scale.domain = function(_) {\n    if (!arguments.length) return domain.slice();\n    domain = [];\n    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);\n    domain.sort(ascending);\n    return rescale();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = src_array_slice.call(_), rescale()) : range.slice();\n  };\n\n  scale.quantiles = function() {\n    return thresholds.slice();\n  };\n\n  scale.copy = function() {\n    return src_quantile_quantile()\n        .domain(domain)\n        .range(range);\n  };\n\n  return scale;\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-scale/src/quantize.js\n\n\n\n\nfunction quantize_quantize() {\n  var x0 = 0,\n      x1 = 1,\n      n = 1,\n      domain = [0.5],\n      range = [0, 1];\n\n  function scale(x) {\n    if (x <= x) return range[bisect(domain, x, 0, n)];\n  }\n\n  function rescale() {\n    var i = -1;\n    domain = new Array(n);\n    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);\n    return scale;\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (n = (range = src_array_slice.call(_)).length - 1, rescale()) : range.slice();\n  };\n\n  scale.invertExtent = function(y) {\n    var i = range.indexOf(y);\n    return i < 0 ? [NaN, NaN]\n        : i < 1 ? [x0, domain[0]]\n        : i >= n ? [domain[n - 1], x1]\n        : [domain[i - 1], domain[i]];\n  };\n\n  scale.copy = function() {\n    return quantize_quantize()\n        .domain([x0, x1])\n        .range(range);\n  };\n\n  return linear_linearish(scale);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-scale/src/threshold.js\n\n\n\nfunction src_threshold_threshold() {\n  var domain = [0.5],\n      range = [0, 1],\n      n = 1;\n\n  function scale(x) {\n    if (x <= x) return range[bisect(domain, x, 0, n)];\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain = src_array_slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = src_array_slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();\n  };\n\n  scale.invertExtent = function(y) {\n    var i = range.indexOf(y);\n    return [domain[i - 1], domain[i]];\n  };\n\n  scale.copy = function() {\n    return src_threshold_threshold()\n        .domain(domain)\n        .range(range);\n  };\n\n  return scale;\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-scale/src/time.js\n\n\n\n\n\n\n\n\nvar time_durationSecond = 1000,\n    time_durationMinute = time_durationSecond * 60,\n    time_durationHour = time_durationMinute * 60,\n    time_durationDay = time_durationHour * 24,\n    time_durationWeek = time_durationDay * 7,\n    time_durationMonth = time_durationDay * 30,\n    time_durationYear = time_durationDay * 365;\n\nfunction time_date(t) {\n  return new Date(t);\n}\n\nfunction src_time_number(t) {\n  return t instanceof Date ? +t : +new Date(+t);\n}\n\nfunction time_calendar(year, month, week, day, hour, minute, second, millisecond, format) {\n  var scale = continuous_continuous(deinterpolateLinear, src_number["a" /* default */]),\n      invert = scale.invert,\n      domain = scale.domain;\n\n  var formatMillisecond = format(".%L"),\n      formatSecond = format(":%S"),\n      formatMinute = format("%I:%M"),\n      formatHour = format("%I %p"),\n      formatDay = format("%a %d"),\n      formatWeek = format("%b %d"),\n      formatMonth = format("%B"),\n      formatYear = format("%Y");\n\n  var tickIntervals = [\n    [second,  1,      time_durationSecond],\n    [second,  5,  5 * time_durationSecond],\n    [second, 15, 15 * time_durationSecond],\n    [second, 30, 30 * time_durationSecond],\n    [minute,  1,      time_durationMinute],\n    [minute,  5,  5 * time_durationMinute],\n    [minute, 15, 15 * time_durationMinute],\n    [minute, 30, 30 * time_durationMinute],\n    [  hour,  1,      time_durationHour  ],\n    [  hour,  3,  3 * time_durationHour  ],\n    [  hour,  6,  6 * time_durationHour  ],\n    [  hour, 12, 12 * time_durationHour  ],\n    [   day,  1,      time_durationDay   ],\n    [   day,  2,  2 * time_durationDay   ],\n    [  week,  1,      time_durationWeek  ],\n    [ month,  1,      time_durationMonth ],\n    [ month,  3,  3 * time_durationMonth ],\n    [  year,  1,      time_durationYear  ]\n  ];\n\n  function tickFormat(date) {\n    return (second(date) < date ? formatMillisecond\n        : minute(date) < date ? formatSecond\n        : hour(date) < date ? formatMinute\n        : day(date) < date ? formatHour\n        : month(date) < date ? (week(date) < date ? formatDay : formatWeek)\n        : year(date) < date ? formatMonth\n        : formatYear)(date);\n  }\n\n  function tickInterval(interval, start, stop, step) {\n    if (interval == null) interval = 10;\n\n    // If a desired tick count is specified, pick a reasonable tick interval\n    // based on the extent of the domain and a rough estimate of tick size.\n    // Otherwise, assume interval is already a time interval and use it.\n    if (typeof interval === "number") {\n      var target = Math.abs(stop - start) / interval,\n          i = bisector(function(i) { return i[2]; }).right(tickIntervals, target);\n      if (i === tickIntervals.length) {\n        step = tickStep(start / time_durationYear, stop / time_durationYear, interval);\n        interval = year;\n      } else if (i) {\n        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];\n        step = i[1];\n        interval = i[0];\n      } else {\n        step = Math.max(tickStep(start, stop, interval), 1);\n        interval = millisecond;\n      }\n    }\n\n    return step == null ? interval : interval.every(step);\n  }\n\n  scale.invert = function(y) {\n    return new Date(invert(y));\n  };\n\n  scale.domain = function(_) {\n    return arguments.length ? domain(src_array_map.call(_, src_time_number)) : domain().map(time_date);\n  };\n\n  scale.ticks = function(interval, step) {\n    var d = domain(),\n        t0 = d[0],\n        t1 = d[d.length - 1],\n        r = t1 < t0,\n        t;\n    if (r) t = t0, t0 = t1, t1 = t;\n    t = tickInterval(interval, t0, t1, step);\n    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop\n    return r ? t.reverse() : t;\n  };\n\n  scale.tickFormat = function(count, specifier) {\n    return specifier == null ? tickFormat : format(specifier);\n  };\n\n  scale.nice = function(interval, step) {\n    var d = domain();\n    return (interval = tickInterval(interval, d[0], d[d.length - 1], step))\n        ? domain(d3_scale_src_nice(d, interval))\n        : scale;\n  };\n\n  scale.copy = function() {\n    return continuous_copy(scale, time_calendar(year, month, week, day, hour, minute, second, millisecond, format));\n  };\n\n  return scale;\n}\n\n/* harmony default export */ var src_time = (function() {\n  return time_calendar(src_year["a" /* default */], src_month["a" /* default */], src_week["g" /* sunday */], src_day["b" /* default */], src_hour["a" /* default */], src_minute["a" /* default */], src_second["a" /* default */], src_millisecond["a" /* default */], src_defaultLocale["a" /* timeFormat */]).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]);\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-scale/src/utcTime.js\n\n\n\n\n/* harmony default export */ var src_utcTime = (function() {\n  return time_calendar(utcYear["a" /* default */], utcMonth["a" /* default */], utcWeek["g" /* utcSunday */], utcDay["a" /* default */], utcHour["a" /* default */], utcMinute["a" /* default */], src_second["a" /* default */], src_millisecond["a" /* default */], src_defaultLocale["b" /* utcFormat */]).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]);\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-scale/src/colors.js\n/* harmony default export */ var colors = (function(s) {\n  return s.match(/.{6}/g).map(function(x) {\n    return "#" + x;\n  });\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-scale/src/category10.js\n\n\n/* harmony default export */ var category10 = (colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf"));\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-scale/src/category20b.js\n\n\n/* harmony default export */ var category20b = (colors("393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6"));\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-scale/src/category20c.js\n\n\n/* harmony default export */ var category20c = (colors("3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9"));\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-scale/src/category20.js\n\n\n/* harmony default export */ var category20 = (colors("1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5"));\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-color/src/cubehelix.js\nvar cubehelix = __webpack_require__(649);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-interpolate/src/cubehelix.js\nvar src_cubehelix = __webpack_require__(382);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-scale/src/cubehelix.js\n\n\n\n/* harmony default export */ var d3_scale_src_cubehelix = (Object(src_cubehelix["a" /* cubehelixLong */])(Object(cubehelix["a" /* default */])(300, 0.5, 0.0), Object(cubehelix["a" /* default */])(-240, 0.5, 1.0)));\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-scale/src/rainbow.js\n\n\n\nvar warm = Object(src_cubehelix["a" /* cubehelixLong */])(Object(cubehelix["a" /* default */])(-100, 0.75, 0.35), Object(cubehelix["a" /* default */])(80, 1.50, 0.8));\n\nvar cool = Object(src_cubehelix["a" /* cubehelixLong */])(Object(cubehelix["a" /* default */])(260, 0.75, 0.35), Object(cubehelix["a" /* default */])(80, 1.50, 0.8));\n\nvar rainbow = Object(cubehelix["a" /* default */])();\n\n/* harmony default export */ var src_rainbow = (function(t) {\n  if (t < 0 || t > 1) t -= Math.floor(t);\n  var ts = Math.abs(t - 0.5);\n  rainbow.h = 360 * t - 100;\n  rainbow.s = 1.5 - 1.5 * ts;\n  rainbow.l = 0.8 - 0.9 * ts;\n  return rainbow + "";\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-scale/src/viridis.js\n\n\nfunction ramp(range) {\n  var n = range.length;\n  return function(t) {\n    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];\n  };\n}\n\n/* harmony default export */ var viridis = (ramp(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725")));\n\nvar magma = ramp(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));\n\nvar inferno = ramp(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));\n\nvar plasma = ramp(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-scale/src/sequential.js\n\n\nfunction sequential_sequential(interpolator) {\n  var x0 = 0,\n      x1 = 1,\n      clamp = false;\n\n  function scale(x) {\n    var t = (x - x0) / (x1 - x0);\n    return interpolator(clamp ? Math.max(0, Math.min(1, t)) : t);\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (x0 = +_[0], x1 = +_[1], scale) : [x0, x1];\n  };\n\n  scale.clamp = function(_) {\n    return arguments.length ? (clamp = !!_, scale) : clamp;\n  };\n\n  scale.interpolator = function(_) {\n    return arguments.length ? (interpolator = _, scale) : interpolator;\n  };\n\n  scale.copy = function() {\n    return sequential_sequential(interpolator).domain([x0, x1]).clamp(clamp);\n  };\n\n  return linear_linearish(scale);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/d3-scale/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/esm/utils/binNumericData.js\n\n\nvar DEFAULT_BIN_COUNT = 10;\n/*\n * handles binning of numeric data by series index\n * if binValues are passed, ignores other bin values that are encountered\n *\n * returns an object of bins keyed on series index with the following shape\n * {\n *   [seriesIdx]: Array<Object{\n *      bin0: String,\n *      bin1: String,\n *      data: Array<datum>,\n *      count: Number,\n *      id: String,\n *    }>,\n * }\n */\n\nfunction binNumericData(_ref) {\n  var allData = _ref.allData,\n      _ref$binCount = _ref.binCount,\n      userBinCount = _ref$binCount === void 0 ? DEFAULT_BIN_COUNT : _ref$binCount,\n      binValues = _ref.binValues,\n      limits = _ref.limits,\n      rawDataByIndex = _ref.rawDataByIndex,\n      valueAccessor = _ref.valueAccessor;\n  var binCount = Array.isArray(binValues) ? binValues.length : userBinCount;\n  var binsByIndex = {};\n  var histogram = src_histogram();\n  var extent = src_extent(allData, valueAccessor);\n\n  if (binValues) {\n    // account for extent of binValues if passed\n    var binExtent = src_extent(binValues);\n    extent = [Math.min(binExtent[0], extent[0]), Math.max(binExtent[1], extent[1])];\n  }\n\n  var scale = linear_linear().domain(extent).nice(binCount);\n  histogram.domain(limits || scale.domain()).thresholds(binValues || scale.ticks(binCount));\n  Object.keys(rawDataByIndex).forEach(function (index) {\n    var data = rawDataByIndex[index];\n    var seriesBins = histogram.value(valueAccessor)(data); // if the last bin equals the upper bound of the second to last bin, combine them\n    // see https://github.com/d3/d3-array/issues/46#issuecomment-269873644\n\n    var lastBinIndex = seriesBins.length - 1;\n    var lastBin = seriesBins[lastBinIndex];\n    var nextToLastBin = seriesBins[lastBinIndex - 1];\n    var shouldCombineEndBins = nextToLastBin && nextToLastBin.x1 === lastBin.x0 && lastBin.x1 === lastBin.x0;\n    var filteredBins = shouldCombineEndBins ? seriesBins.slice(0, -1) : seriesBins;\n    binsByIndex[index] = filteredBins.map(function (bin, i) {\n      return {\n        bin0: bin.x0,\n        // if the upper limit equals the lower one, use the delta between this bin and the last\n        bin1: bin.x0 === bin.x1 ? i > 0 && bin.x0 + bin.x0 - seriesBins[i - 1].x0 || bin.x1 + 1 : bin.x1,\n        data: [].concat(bin).concat(shouldCombineEndBins && (shouldCombineEndBins && i === lastBinIndex - 1 ? lastBin : [])),\n        // if the last bin was inclusive / omitted, add its count to the last bin\n        count: bin.length + (shouldCombineEndBins && i === lastBinIndex - 1 ? lastBin.length || 0 : 0),\n        id: i.toString()\n      };\n    });\n  });\n  return binsByIndex;\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/esm/utils/caseInsensitiveSort.js\nfunction caseInsensitiveSort(a, b) {\n  if (!a.toLowerCase || !b.toLowerCase) return a - b;\n  if (a.toLowerCase() < b.toLowerCase()) return -1;\n  if (a.toLowerCase() > b.toLowerCase()) return 1;\n  return 0;\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/esm/utils/binCategoricalData.js\n\n\nvar binCategoricalData_sortBins = function sortBins(a, b) {\n  return caseInsensitiveSort(a.bin, b.bin);\n};\n/*\n * handles binning of categorical data by series index\n * if binValues are passed, ignores other bin values that are encountered\n *\n * returns an object of bins keyed on series index with the following shape\n *  {\n *    [seriesIdx]: Array<Object{ bin: String, data: Array<datum>, count: Number }>,\n *  }\n */\n\n\nfunction binCategoricalData(_ref) {\n  var rawDataByIndex = _ref.rawDataByIndex,\n      valueAccessor = _ref.valueAccessor,\n      _ref$binValues = _ref.binValues,\n      binValues = _ref$binValues === void 0 ? null : _ref$binValues;\n  var binsByIndex = {};\n  Object.keys(rawDataByIndex).forEach(function (index) {\n    var data = rawDataByIndex[index];\n    var bins = {};\n    data.forEach(function (datum) {\n      var bin = valueAccessor(datum);\n      bins[bin] = bins[bin] || {\n        bin: bin,\n        data: [],\n        count: 0,\n        id: bin\n      };\n      bins[bin].data.push(datum);\n      bins[bin].count += 1;\n    }); // convert to an array of bins\n\n    if (binValues) {\n      binsByIndex[index] = binValues.map(function (bin) {\n        return bins[bin] || {\n          bin: bin,\n          count: 0,\n          data: []\n        };\n      });\n    } else {\n      binsByIndex[index] = Object.values(bins).sort(binCategoricalData_sortBins);\n    }\n  });\n  return binsByIndex;\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/esm/utils/componentName.js\nfunction componentName(component) {\n  if (component && component.type) {\n    return component.type.displayName || component.type.name || \'Component\';\n  }\n\n  return \'Component\';\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/esm/utils/collectDataFromChildSeries.js\n\n\n\nfunction collectDataFromChildSeries(children) {\n  var allRawData = [];\n  var allBinnedData = [];\n  var rawDataByIndex = {};\n  var binnedDataByIndex = {};\n  react["Children"].forEach(children, function (Child, i) {\n    var name = componentName(Child);\n\n    if (isSeries(name)) {\n      var rawData = Child.props.rawData;\n      var binnedData = Child.props.binnedData;\n\n      if (rawData && rawData.length > 0) {\n        rawDataByIndex[i] = rawData;\n        allRawData = allRawData.concat(rawData);\n      }\n\n      if (binnedData && binnedData.length > 0) {\n        binnedDataByIndex[i] = binnedData;\n        allBinnedData = allBinnedData.concat(binnedData);\n      }\n    }\n  });\n  return {\n    allBinnedData: allBinnedData,\n    allRawData: allRawData,\n    binnedDataByIndex: binnedDataByIndex,\n    rawDataByIndex: rawDataByIndex\n  };\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/esm/utils/collectBinnedDataFromChildSeries.js\n\n\n\n\nfunction collectBinnedDataFromChildSeries(_ref) {\n  var children = _ref.children,\n      binCount = _ref.binCount,\n      binType = _ref.binType,\n      binValues = _ref.binValues,\n      limits = _ref.limits,\n      valueAccessor = _ref.valueAccessor;\n\n  var _collectDataFromChild = collectDataFromChildSeries(children),\n      allRawData = _collectDataFromChild.allRawData,\n      rawDataByIndex = _collectDataFromChild.rawDataByIndex,\n      binnedDataByIndex = _collectDataFromChild.binnedDataByIndex;\n\n  var result = binnedDataByIndex;\n\n  if (Object.keys(binnedDataByIndex).length === 0) {\n    var binningFunc = binType === \'numeric\' ? binNumericData : binCategoricalData;\n    result = binningFunc({\n      allData: allRawData,\n      rawDataByIndex: rawDataByIndex,\n      valueAccessor: valueAccessor,\n      limits: limits,\n      binCount: binCount,\n      binValues: binValues\n    });\n  }\n\n  Object.values(result).forEach(function (bins) {\n    addDensityAndCumulativeValuesToBins(bins);\n  });\n  return result;\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/esm/utils/computeDomainsFromBins.js\n\n\n/*\n * Computes the bin and value domains from numeric or categorical bins\n */\n\nfunction computeDomainsFromBins(_ref) {\n  var binsByIndex = _ref.binsByIndex,\n      binType = _ref.binType,\n      valueKey = _ref.valueKey,\n      binValues = _ref.binValues;\n  var binDomain;\n  var valueDomain;\n  Object.values(binsByIndex).forEach(function (bins) {\n    var currValueMax = src_max(bins, function (d) {\n      return d[valueKey];\n    });\n\n    if (valueDomain) {\n      valueDomain[1] = Math.max(currValueMax, valueDomain[1]);\n    } else {\n      valueDomain = [0, currValueMax];\n    }\n\n    if (binType === \'numeric\') {\n      if (binDomain) {\n        binDomain[0] = Math.min(bins[0].bin0, binDomain[0]);\n        binDomain[1] = Math.max(bins[bins.length - 1].bin1, binDomain[1]);\n      } else {\n        binDomain = [bins[0].bin0, bins[bins.length - 1].bin1];\n      }\n    } else {\n      if (!binDomain) binDomain = {}; // use lookup to avoid lots of Array scans\n\n      bins.forEach(function (bin) {\n        binDomain[bin.bin] = true;\n      });\n    }\n  });\n\n  if (Array.isArray(binValues)) {\n    var providedBinsCoverDomain = true;\n    binValues.forEach(function (binValue) {\n      if (!(binValue in binDomain)) {\n        providedBinsCoverDomain = false;\n      }\n    });\n\n    if (providedBinsCoverDomain) {\n      binDomain = binValues;\n    }\n  }\n\n  if (!Array.isArray(binDomain)) {\n    binDomain = Object.keys(binDomain).sort(caseInsensitiveSort);\n  }\n\n  return {\n    binDomain: binDomain,\n    valueDomain: valueDomain\n  };\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/esm/utils/getValueKey.js\nfunction getValueKey(_ref) {\n  var normalized = _ref.normalized,\n      cumulative = _ref.cumulative;\n  if (normalized && cumulative) return \'cumulativeDensity\';\n  if (cumulative) return \'cumulative\';\n  if (normalized) return \'density\';\n  return \'count\';\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/esm/utils/shallowCompareObjectEntries.js\nfunction shallowCompareObjectEntries(a, b) {\n  var keysA = Object.keys(a);\n  var keysB = Object.keys(b);\n  if (keysA.length !== keysB.length) return false;\n  return keysA.every(function (k) {\n    return a[k] === b[k];\n  });\n}\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/esm/utils/propShapes.js\nvar propShapes = __webpack_require__(1352);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/esm/chart/Histogram.js\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\n/* eslint complexity: [\'error\', 17] */\n\n\n\n\n\n\n\n\n\n\n\n\nvar propTypes = _extends({}, WithTooltip["b" /* withTooltipPropTypes */], {\n  ariaLabel: prop_types_default.a.string.isRequired,\n  binValues: prop_types_default.a.arrayOf(prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string])),\n  binCount: prop_types_default.a.number,\n  binType: prop_types_default.a.oneOf([\'numeric\', \'categorical\']),\n  children: prop_types_default.a.node.isRequired,\n  cumulative: prop_types_default.a.bool,\n  height: prop_types_default.a.number.isRequired,\n  horizontal: prop_types_default.a.bool,\n  limits: prop_types_default.a.arrayOf(prop_types_default.a.number),\n  // values outside the limits are ignored\n  margin: prop_types_default.a.shape({\n    top: prop_types_default.a.number,\n    right: prop_types_default.a.number,\n    bottom: prop_types_default.a.number,\n    left: prop_types_default.a.number\n  }),\n  normalized: prop_types_default.a.bool,\n  renderTooltip: prop_types_default.a.func,\n  theme: propShapes["c" /* themeShape */],\n  width: prop_types_default.a.number.isRequired,\n  valueAccessor: prop_types_default.a.func\n});\nvar defaultProps = {\n  binCount: 10,\n  binType: \'numeric\',\n  binValues: null,\n  cumulative: false,\n  horizontal: false,\n  limits: null,\n  margin: {\n    top: 32,\n    right: 32,\n    bottom: 64,\n    left: 64\n  },\n  normalized: false,\n  renderTooltip: null,\n  theme: {},\n  valueAccessor: function valueAccessor(d) {\n    return d;\n  }\n};\n\nvar Histogram_Histogram =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inheritsLoose(Histogram, _React$PureComponent);\n\n  function Histogram(props) {\n    var _this;\n\n    _this = _React$PureComponent.call(this, props) || this;\n    _this.state = _this.getStateFromProps(props);\n    return _this;\n  }\n\n  var _proto = Histogram.prototype;\n\n  _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    var _this2 = this;\n\n    var shouldComputeBinsAndScales = false; // eslint-disable-next-line react/destructuring-assignment\n\n    if ([\'width\', \'height\', \'children\'].some(function (prop) {\n      return _this2.props[prop] !== nextProps[prop];\n    })) {\n      shouldComputeBinsAndScales = true;\n    }\n\n    if ([\'margin\'].some( // eslint-disable-next-line react/destructuring-assignment\n    function (prop) {\n      return !shallowCompareObjectEntries(_this2.props[prop], nextProps[prop]);\n    })) {\n      shouldComputeBinsAndScales = true;\n    }\n\n    if (shouldComputeBinsAndScales) this.setState(this.getStateFromProps(nextProps));\n  };\n\n  _proto.getStateFromProps = function getStateFromProps(props) {\n    var dimensions = this.getDimmensions(props);\n    var binsByIndex = this.getBinnedData(props);\n    var scales = this.getScales(props, binsByIndex, dimensions);\n    return _extends({\n      binsByIndex: binsByIndex\n    }, dimensions, scales);\n  };\n\n  _proto.getDimmensions = function getDimmensions(props) {\n    var _ref = props || this.props,\n        margin = _ref.margin,\n        width = _ref.width,\n        height = _ref.height;\n\n    var completeMargin = _extends({}, defaultProps.margin, margin);\n\n    return {\n      margin: completeMargin,\n      innerHeight: height - completeMargin.top - completeMargin.bottom,\n      innerWidth: width - completeMargin.left - completeMargin.right\n    };\n  };\n\n  _proto.getBinnedData = function getBinnedData(props) {\n    var _ref2 = props || this.props,\n        children = _ref2.children,\n        binCount = _ref2.binCount,\n        binType = _ref2.binType,\n        binValues = _ref2.binValues,\n        limits = _ref2.limits,\n        valueAccessor = _ref2.valueAccessor;\n\n    return collectBinnedDataFromChildSeries({\n      children: children,\n      binCount: binCount,\n      binType: binType,\n      binValues: binValues,\n      limits: limits,\n      valueAccessor: valueAccessor\n    });\n  };\n\n  _proto.getScales = function getScales(props, binsByIndex, _ref3) {\n    var innerHeight = _ref3.innerHeight,\n        innerWidth = _ref3.innerWidth;\n\n    var _ref4 = props || this.props,\n        binType = _ref4.binType,\n        binValues = _ref4.binValues,\n        cumulative = _ref4.cumulative,\n        horizontal = _ref4.horizontal,\n        normalized = _ref4.normalized;\n\n    var binScaleFunc = binType === \'numeric\' ? vx_scale_es_linear : vx_scale_es_band;\n    var valueKey = getValueKey({\n      normalized: normalized,\n      cumulative: cumulative\n    });\n\n    var _computeDomainsFromBi = computeDomainsFromBins({\n      binsByIndex: binsByIndex,\n      binType: binType,\n      binValues: binValues,\n      valueKey: valueKey\n    }),\n        binDomain = _computeDomainsFromBi.binDomain,\n        valueDomain = _computeDomainsFromBi.valueDomain;\n\n    var binRange = horizontal ? [innerHeight, 0] : [0, innerWidth];\n    var valueRange = horizontal ? [0, innerWidth] : [innerHeight, 0]; // when viewing categorical data horizontally it is more natural to\n    // read alphabetical from top down\n\n    if (horizontal && binType === \'categorical\') binRange.reverse();\n    return {\n      binScale: binScaleFunc({\n        range: binRange,\n        domain: binDomain\n      }),\n      valueScale: vx_scale_es_linear({\n        range: valueRange,\n        domain: valueDomain\n      }),\n      valueKey: valueKey\n    };\n  };\n\n  _proto.render = function render() {\n    var renderTooltip = this.props.renderTooltip;\n\n    if (renderTooltip) {\n      return react_default.a.createElement(WithTooltip["a" /* default */], {\n        renderTooltip: renderTooltip\n      }, react_default.a.createElement(Histogram, _extends({}, this.props, {\n        renderTooltip: null\n      })));\n    }\n\n    var _this$props = this.props,\n        ariaLabel = _this$props.ariaLabel,\n        binType = _this$props.binType,\n        binValues = _this$props.binValues,\n        children = _this$props.children,\n        height = _this$props.height,\n        horizontal = _this$props.horizontal,\n        onMouseLeave = _this$props.onMouseLeave,\n        onMouseMove = _this$props.onMouseMove,\n        theme = _this$props.theme,\n        valueAccessor = _this$props.valueAccessor,\n        width = _this$props.width;\n    var _this$state = this.state,\n        binsByIndex = _this$state.binsByIndex,\n        binScale = _this$state.binScale,\n        innerHeight = _this$state.innerHeight,\n        innerWidth = _this$state.innerWidth,\n        margin = _this$state.margin,\n        valueKey = _this$state.valueKey,\n        valueScale = _this$state.valueScale;\n    return react_default.a.createElement("svg", {\n      "aria-label": ariaLabel,\n      role: "img",\n      width: width,\n      height: height\n    }, react_default.a.createElement(vx_group_es["a" /* Group */], {\n      left: margin.left,\n      top: margin.top\n    }, react_default.a.Children.map(children, function (Child, index) {\n      var name = componentName(Child);\n\n      if (isSeries(name)) {\n        var binnedData = binsByIndex[index];\n        return react_default.a.cloneElement(Child, {\n          binScale: binScale,\n          binType: binType,\n          binnedData: binnedData,\n          horizontal: horizontal,\n          valueAccessor: valueAccessor,\n          valueKey: valueKey,\n          valueScale: valueScale,\n          onMouseLeave: onMouseLeave,\n          onMouseMove: onMouseMove\n        });\n      } else if (isAxis(name)) {\n        var styleKey = name[0].toLowerCase();\n        var binOrValue = name === \'XAxis\' && !horizontal || name === \'YAxis\' && horizontal ? \'bin\' : \'value\';\n        var tickValues = Child.props.tickValues || (binOrValue === \'bin\' && binValues ? binValues : null);\n        return react_default.a.cloneElement(Child, {\n          top: name === \'YAxis\' || Child.props.orientation === \'top\' ? 0 : innerHeight,\n          left: name === \'XAxis\' || Child.props.orientation === \'left\' ? 0 : innerWidth,\n          label: Child.props.label || (binOrValue === \'value\' ? valueKey : null),\n          scale: binOrValue === \'value\' ? valueScale : binScale,\n          axisStyles: _extends({}, theme[styleKey + "AxisStyles"], Child.props.axisStyles),\n          tickStyles: _extends({}, theme[styleKey + "TickStyles"], Child.props.tickStyles),\n          tickValues: tickValues\n        });\n      }\n\n      return Child;\n    })));\n  };\n\n  return Histogram;\n}(react_default.a.PureComponent);\n\nHistogram_Histogram.propTypes = propTypes;\nHistogram_Histogram.defaultProps = defaultProps;\nHistogram_Histogram.displayName = \'Histogram\';\n/* harmony default export */ var chart_Histogram = __webpack_exports__["a"] = (Histogram_Histogram);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjI4Ny5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL2hpc3RvZ3JhbS9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2FzY2VuZGluZy5qcz8zOTZkIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL2hpc3RvZ3JhbS9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2Jpc2VjdG9yLmpzP2I1MGEiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkvaGlzdG9ncmFtL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvYmlzZWN0LmpzPzk3MDMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkvaGlzdG9ncmFtL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvcGFpcnMuanM/NjE0MiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS9oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9jcm9zcy5qcz9hM2Y4Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL2hpc3RvZ3JhbS9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2Rlc2NlbmRpbmcuanM/NWUzYiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS9oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9udW1iZXIuanM/MzI5MyIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS9oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy92YXJpYW5jZS5qcz8xZjY0Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL2hpc3RvZ3JhbS9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2RldmlhdGlvbi5qcz9kNGRmIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL2hpc3RvZ3JhbS9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2V4dGVudC5qcz9jMWVhIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL2hpc3RvZ3JhbS9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2FycmF5LmpzPzQyNDEiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkvaGlzdG9ncmFtL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvY29uc3RhbnQuanM/NGFiNCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS9oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9pZGVudGl0eS5qcz9hOWNmIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL2hpc3RvZ3JhbS9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL3JhbmdlLmpzP2Y3ZTYiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkvaGlzdG9ncmFtL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvdGlja3MuanM/YzkyMiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS9oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy90aHJlc2hvbGQvc3R1cmdlcy5qcz81OTA4Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL2hpc3RvZ3JhbS9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2hpc3RvZ3JhbS5qcz9mYjJiIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL2hpc3RvZ3JhbS9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL3F1YW50aWxlLmpzPzEyZDMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkvaGlzdG9ncmFtL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvdGhyZXNob2xkL2ZyZWVkbWFuRGlhY29uaXMuanM/MmJhNiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS9oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy90aHJlc2hvbGQvc2NvdHQuanM/YjI5MiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS9oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9tYXguanM/NDcwMyIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS9oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9tZWFuLmpzPzI4NmEiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkvaGlzdG9ncmFtL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvbWVkaWFuLmpzPzI2ZjQiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkvaGlzdG9ncmFtL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvbWVyZ2UuanM/YjZhMiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS9oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9taW4uanM/ODhhZCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS9oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9wZXJtdXRlLmpzPzZiMWEiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkvaGlzdG9ncmFtL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvc2Nhbi5qcz81ZGY4Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL2hpc3RvZ3JhbS9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL3NodWZmbGUuanM/NDFkYyIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS9oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9zdW0uanM/YTYzNiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS9oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy90cmFuc3Bvc2UuanM/MzYzNiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS9oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy96aXAuanM/ODM3YiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS9oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9pbmRleC5qcz82ZmE1Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL2hpc3RvZ3JhbS9ub2RlX21vZHVsZXMvQHZ4L3NjYWxlL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvaW5pdC5qcz8zZTE5Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL2hpc3RvZ3JhbS9ub2RlX21vZHVsZXMvQHZ4L3NjYWxlL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvYXJyYXkuanM/MDc1ZCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS9oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL0B2eC9zY2FsZS9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL29yZGluYWwuanM/MDI5ZiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS9oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL0B2eC9zY2FsZS9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL2JhbmQuanM/YjQ3MCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS9oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL0B2eC9zY2FsZS9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL2NvbnN0YW50LmpzPzQ0MWEiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkvaGlzdG9ncmFtL25vZGVfbW9kdWxlcy9Adngvc2NhbGUvbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9udW1iZXIuanM/ZDBiYiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS9oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL0B2eC9zY2FsZS9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL2NvbnRpbnVvdXMuanM/ZGYzMyIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS9oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL0B2eC9zY2FsZS9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL3RpY2tGb3JtYXQuanM/MDZiYiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS9oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL0B2eC9zY2FsZS9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL2xpbmVhci5qcz9kMWE4Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL2hpc3RvZ3JhbS9ub2RlX21vZHVsZXMvQHZ4L3NjYWxlL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvaWRlbnRpdHkuanM/Y2YxZCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS9oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL0B2eC9zY2FsZS9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL25pY2UuanM/OWFlZSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS9oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL0B2eC9zY2FsZS9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL2xvZy5qcz8yYjkxIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL2hpc3RvZ3JhbS9ub2RlX21vZHVsZXMvQHZ4L3NjYWxlL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvc3ltbG9nLmpzP2QwNzQiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkvaGlzdG9ncmFtL25vZGVfbW9kdWxlcy9Adngvc2NhbGUvbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9wb3cuanM/MGY4OSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS9oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL0B2eC9zY2FsZS9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL3F1YW50aWxlLmpzP2M1NGMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkvaGlzdG9ncmFtL25vZGVfbW9kdWxlcy9Adngvc2NhbGUvbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9xdWFudGl6ZS5qcz83MzJkIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL2hpc3RvZ3JhbS9ub2RlX21vZHVsZXMvQHZ4L3NjYWxlL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvdGhyZXNob2xkLmpzP2IwNzIiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkvaGlzdG9ncmFtL25vZGVfbW9kdWxlcy9Adngvc2NhbGUvbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy90aW1lLmpzPzcxMDMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkvaGlzdG9ncmFtL25vZGVfbW9kdWxlcy9Adngvc2NhbGUvbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy91dGNUaW1lLmpzPzk1MmQiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkvaGlzdG9ncmFtL25vZGVfbW9kdWxlcy9Adngvc2NhbGUvbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9zZXF1ZW50aWFsLmpzP2ZkMjciLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkvaGlzdG9ncmFtL25vZGVfbW9kdWxlcy9Adngvc2NhbGUvbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9zZXF1ZW50aWFsUXVhbnRpbGUuanM/NTgxZCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS9oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL0B2eC9zY2FsZS9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL2RpdmVyZ2luZy5qcz9mNTdlIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL2hpc3RvZ3JhbS9ub2RlX21vZHVsZXMvQHZ4L3NjYWxlL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvaW5kZXguanM/YTY5MCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS9oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL0B2eC9zY2FsZS9kaXN0L3Z4LXNjYWxlLmVzLmpzP2QwOTkiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkvaGlzdG9ncmFtL2VzbS91dGlscy9jb21wb25lbnRJc1guanM/YjQzMSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS9oaXN0b2dyYW0vZXNtL3V0aWxzL2FkZERlbnNpdHlBbmRDdW11bGF0aXZlVmFsdWVzVG9CaW5zLmpzP2NkNGMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkvaGlzdG9ncmFtL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvYXJyYXkuanM/YTUwYyIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS9oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9vcmRpbmFsLmpzP2M1ODYiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkvaGlzdG9ncmFtL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvYmFuZC5qcz85OWU0Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL2hpc3RvZ3JhbS9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL2NvbnN0YW50LmpzP2E2Y2IiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkvaGlzdG9ncmFtL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvbnVtYmVyLmpzPzYxOTgiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkvaGlzdG9ncmFtL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvY29udGludW91cy5qcz9kMDE5Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL2hpc3RvZ3JhbS9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL3RpY2tGb3JtYXQuanM/M2NkNyIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS9oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9saW5lYXIuanM/MjQ4NSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS9oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9pZGVudGl0eS5qcz9kM2FmIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL2hpc3RvZ3JhbS9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL25pY2UuanM/MTM1YyIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS9oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9sb2cuanM/MDZkNiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS9oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9wb3cuanM/NGEwOCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS9oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9xdWFudGlsZS5qcz9iODU2Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL2hpc3RvZ3JhbS9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL3F1YW50aXplLmpzPzdhYmQiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkvaGlzdG9ncmFtL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvdGhyZXNob2xkLmpzPzIyZTIiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkvaGlzdG9ncmFtL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvdGltZS5qcz83ODVkIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL2hpc3RvZ3JhbS9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL3V0Y1RpbWUuanM/NGExNSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS9oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9jb2xvcnMuanM/YmI0OSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS9oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9jYXRlZ29yeTEwLmpzPzUwNTMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkvaGlzdG9ncmFtL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvY2F0ZWdvcnkyMGIuanM/MjFkNiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS9oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9jYXRlZ29yeTIwYy5qcz9lZWNjIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL2hpc3RvZ3JhbS9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL2NhdGVnb3J5MjAuanM/MWRlYyIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS9oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9jdWJlaGVsaXguanM/ZTA5OSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS9oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9yYWluYm93LmpzP2MyMGEiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkvaGlzdG9ncmFtL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvdmlyaWRpcy5qcz8yOWFiIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL2hpc3RvZ3JhbS9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL3NlcXVlbnRpYWwuanM/NzkxZiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS9oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL2luZGV4LmpzP2Q0MTAiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkvaGlzdG9ncmFtL2VzbS91dGlscy9iaW5OdW1lcmljRGF0YS5qcz8wOTJkIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL2hpc3RvZ3JhbS9lc20vdXRpbHMvY2FzZUluc2Vuc2l0aXZlU29ydC5qcz84MzEzIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL2hpc3RvZ3JhbS9lc20vdXRpbHMvYmluQ2F0ZWdvcmljYWxEYXRhLmpzPzZkYTQiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkvaGlzdG9ncmFtL2VzbS91dGlscy9jb21wb25lbnROYW1lLmpzPzYxOWUiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkvaGlzdG9ncmFtL2VzbS91dGlscy9jb2xsZWN0RGF0YUZyb21DaGlsZFNlcmllcy5qcz8xMjBmIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL2hpc3RvZ3JhbS9lc20vdXRpbHMvY29sbGVjdEJpbm5lZERhdGFGcm9tQ2hpbGRTZXJpZXMuanM/ODNiYiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS9oaXN0b2dyYW0vZXNtL3V0aWxzL2NvbXB1dGVEb21haW5zRnJvbUJpbnMuanM/MjQ3MiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS9oaXN0b2dyYW0vZXNtL3V0aWxzL2dldFZhbHVlS2V5LmpzPzMxMzciLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkvaGlzdG9ncmFtL2VzbS91dGlscy9zaGFsbG93Q29tcGFyZU9iamVjdEVudHJpZXMuanM/N2JjYSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AZGF0YS11aS9oaXN0b2dyYW0vZXNtL2NoYXJ0L0hpc3RvZ3JhbS5qcz8zZmFkIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiBhID49IGIgPyAwIDogTmFOO1xufVxuIiwiaW1wb3J0IGFzY2VuZGluZyBmcm9tIFwiLi9hc2NlbmRpbmdcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY29tcGFyZSkge1xuICBpZiAoY29tcGFyZS5sZW5ndGggPT09IDEpIGNvbXBhcmUgPSBhc2NlbmRpbmdDb21wYXJhdG9yKGNvbXBhcmUpO1xuICByZXR1cm4ge1xuICAgIGxlZnQ6IGZ1bmN0aW9uKGEsIHgsIGxvLCBoaSkge1xuICAgICAgaWYgKGxvID09IG51bGwpIGxvID0gMDtcbiAgICAgIGlmIChoaSA9PSBudWxsKSBoaSA9IGEubGVuZ3RoO1xuICAgICAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICAgICAgdmFyIG1pZCA9IGxvICsgaGkgPj4+IDE7XG4gICAgICAgIGlmIChjb21wYXJlKGFbbWlkXSwgeCkgPCAwKSBsbyA9IG1pZCArIDE7XG4gICAgICAgIGVsc2UgaGkgPSBtaWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbG87XG4gICAgfSxcbiAgICByaWdodDogZnVuY3Rpb24oYSwgeCwgbG8sIGhpKSB7XG4gICAgICBpZiAobG8gPT0gbnVsbCkgbG8gPSAwO1xuICAgICAgaWYgKGhpID09IG51bGwpIGhpID0gYS5sZW5ndGg7XG4gICAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgICB2YXIgbWlkID0gbG8gKyBoaSA+Pj4gMTtcbiAgICAgICAgaWYgKGNvbXBhcmUoYVttaWRdLCB4KSA+IDApIGhpID0gbWlkO1xuICAgICAgICBlbHNlIGxvID0gbWlkICsgMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsbztcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGFzY2VuZGluZ0NvbXBhcmF0b3IoZikge1xuICByZXR1cm4gZnVuY3Rpb24oZCwgeCkge1xuICAgIHJldHVybiBhc2NlbmRpbmcoZihkKSwgeCk7XG4gIH07XG59XG4iLCJpbXBvcnQgYXNjZW5kaW5nIGZyb20gXCIuL2FzY2VuZGluZ1wiO1xuaW1wb3J0IGJpc2VjdG9yIGZyb20gXCIuL2Jpc2VjdG9yXCI7XG5cbnZhciBhc2NlbmRpbmdCaXNlY3QgPSBiaXNlY3Rvcihhc2NlbmRpbmcpO1xuZXhwb3J0IHZhciBiaXNlY3RSaWdodCA9IGFzY2VuZGluZ0Jpc2VjdC5yaWdodDtcbmV4cG9ydCB2YXIgYmlzZWN0TGVmdCA9IGFzY2VuZGluZ0Jpc2VjdC5sZWZ0O1xuZXhwb3J0IGRlZmF1bHQgYmlzZWN0UmlnaHQ7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhcnJheSwgZikge1xuICBpZiAoZiA9PSBudWxsKSBmID0gcGFpcjtcbiAgdmFyIGkgPSAwLCBuID0gYXJyYXkubGVuZ3RoIC0gMSwgcCA9IGFycmF5WzBdLCBwYWlycyA9IG5ldyBBcnJheShuIDwgMCA/IDAgOiBuKTtcbiAgd2hpbGUgKGkgPCBuKSBwYWlyc1tpXSA9IGYocCwgcCA9IGFycmF5WysraV0pO1xuICByZXR1cm4gcGFpcnM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYWlyKGEsIGIpIHtcbiAgcmV0dXJuIFthLCBiXTtcbn1cbiIsImltcG9ydCB7cGFpcn0gZnJvbSBcIi4vcGFpcnNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWVzMCwgdmFsdWVzMSwgcmVkdWNlKSB7XG4gIHZhciBuMCA9IHZhbHVlczAubGVuZ3RoLFxuICAgICAgbjEgPSB2YWx1ZXMxLmxlbmd0aCxcbiAgICAgIHZhbHVlcyA9IG5ldyBBcnJheShuMCAqIG4xKSxcbiAgICAgIGkwLFxuICAgICAgaTEsXG4gICAgICBpLFxuICAgICAgdmFsdWUwO1xuXG4gIGlmIChyZWR1Y2UgPT0gbnVsbCkgcmVkdWNlID0gcGFpcjtcblxuICBmb3IgKGkwID0gaSA9IDA7IGkwIDwgbjA7ICsraTApIHtcbiAgICBmb3IgKHZhbHVlMCA9IHZhbHVlczBbaTBdLCBpMSA9IDA7IGkxIDwgbjE7ICsraTEsICsraSkge1xuICAgICAgdmFsdWVzW2ldID0gcmVkdWNlKHZhbHVlMCwgdmFsdWVzMVtpMV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2YWx1ZXM7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHJldHVybiBiIDwgYSA/IC0xIDogYiA+IGEgPyAxIDogYiA+PSBhID8gMCA6IE5hTjtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHggPT09IG51bGwgPyBOYU4gOiAreDtcbn1cbiIsImltcG9ydCBudW1iZXIgZnJvbSBcIi4vbnVtYmVyXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlcywgdmFsdWVvZikge1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBtID0gMCxcbiAgICAgIGkgPSAtMSxcbiAgICAgIG1lYW4gPSAwLFxuICAgICAgdmFsdWUsXG4gICAgICBkZWx0YSxcbiAgICAgIHN1bSA9IDA7XG5cbiAgaWYgKHZhbHVlb2YgPT0gbnVsbCkge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBpZiAoIWlzTmFOKHZhbHVlID0gbnVtYmVyKHZhbHVlc1tpXSkpKSB7XG4gICAgICAgIGRlbHRhID0gdmFsdWUgLSBtZWFuO1xuICAgICAgICBtZWFuICs9IGRlbHRhIC8gKyttO1xuICAgICAgICBzdW0gKz0gZGVsdGEgKiAodmFsdWUgLSBtZWFuKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBlbHNlIHtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgaWYgKCFpc05hTih2YWx1ZSA9IG51bWJlcih2YWx1ZW9mKHZhbHVlc1tpXSwgaSwgdmFsdWVzKSkpKSB7XG4gICAgICAgIGRlbHRhID0gdmFsdWUgLSBtZWFuO1xuICAgICAgICBtZWFuICs9IGRlbHRhIC8gKyttO1xuICAgICAgICBzdW0gKz0gZGVsdGEgKiAodmFsdWUgLSBtZWFuKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAobSA+IDEpIHJldHVybiBzdW0gLyAobSAtIDEpO1xufVxuIiwiaW1wb3J0IHZhcmlhbmNlIGZyb20gXCIuL3ZhcmlhbmNlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGFycmF5LCBmKSB7XG4gIHZhciB2ID0gdmFyaWFuY2UoYXJyYXksIGYpO1xuICByZXR1cm4gdiA/IE1hdGguc3FydCh2KSA6IHY7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgaSA9IC0xLFxuICAgICAgdmFsdWUsXG4gICAgICBtaW4sXG4gICAgICBtYXg7XG5cbiAgaWYgKHZhbHVlb2YgPT0gbnVsbCkge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIEZpbmQgdGhlIGZpcnN0IGNvbXBhcmFibGUgdmFsdWUuXG4gICAgICBpZiAoKHZhbHVlID0gdmFsdWVzW2ldKSAhPSBudWxsICYmIHZhbHVlID49IHZhbHVlKSB7XG4gICAgICAgIG1pbiA9IG1heCA9IHZhbHVlO1xuICAgICAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBDb21wYXJlIHRoZSByZW1haW5pbmcgdmFsdWVzLlxuICAgICAgICAgIGlmICgodmFsdWUgPSB2YWx1ZXNbaV0pICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChtaW4gPiB2YWx1ZSkgbWluID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAobWF4IDwgdmFsdWUpIG1heCA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGVsc2Uge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIEZpbmQgdGhlIGZpcnN0IGNvbXBhcmFibGUgdmFsdWUuXG4gICAgICBpZiAoKHZhbHVlID0gdmFsdWVvZih2YWx1ZXNbaV0sIGksIHZhbHVlcykpICE9IG51bGwgJiYgdmFsdWUgPj0gdmFsdWUpIHtcbiAgICAgICAgbWluID0gbWF4ID0gdmFsdWU7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIENvbXBhcmUgdGhlIHJlbWFpbmluZyB2YWx1ZXMuXG4gICAgICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobWluID4gdmFsdWUpIG1pbiA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKG1heCA8IHZhbHVlKSBtYXggPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gW21pbiwgbWF4XTtcbn1cbiIsInZhciBhcnJheSA9IEFycmF5LnByb3RvdHlwZTtcblxuZXhwb3J0IHZhciBzbGljZSA9IGFycmF5LnNsaWNlO1xuZXhwb3J0IHZhciBtYXAgPSBhcnJheS5tYXA7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHg7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzdGFydCwgc3RvcCwgc3RlcCkge1xuICBzdGFydCA9ICtzdGFydCwgc3RvcCA9ICtzdG9wLCBzdGVwID0gKG4gPSBhcmd1bWVudHMubGVuZ3RoKSA8IDIgPyAoc3RvcCA9IHN0YXJ0LCBzdGFydCA9IDAsIDEpIDogbiA8IDMgPyAxIDogK3N0ZXA7XG5cbiAgdmFyIGkgPSAtMSxcbiAgICAgIG4gPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoKHN0b3AgLSBzdGFydCkgLyBzdGVwKSkgfCAwLFxuICAgICAgcmFuZ2UgPSBuZXcgQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICByYW5nZVtpXSA9IHN0YXJ0ICsgaSAqIHN0ZXA7XG4gIH1cblxuICByZXR1cm4gcmFuZ2U7XG59XG4iLCJ2YXIgZTEwID0gTWF0aC5zcXJ0KDUwKSxcbiAgICBlNSA9IE1hdGguc3FydCgxMCksXG4gICAgZTIgPSBNYXRoLnNxcnQoMik7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBjb3VudCkge1xuICB2YXIgcmV2ZXJzZSxcbiAgICAgIGkgPSAtMSxcbiAgICAgIG4sXG4gICAgICB0aWNrcyxcbiAgICAgIHN0ZXA7XG5cbiAgc3RvcCA9ICtzdG9wLCBzdGFydCA9ICtzdGFydCwgY291bnQgPSArY291bnQ7XG4gIGlmIChzdGFydCA9PT0gc3RvcCAmJiBjb3VudCA+IDApIHJldHVybiBbc3RhcnRdO1xuICBpZiAocmV2ZXJzZSA9IHN0b3AgPCBzdGFydCkgbiA9IHN0YXJ0LCBzdGFydCA9IHN0b3AsIHN0b3AgPSBuO1xuICBpZiAoKHN0ZXAgPSB0aWNrSW5jcmVtZW50KHN0YXJ0LCBzdG9wLCBjb3VudCkpID09PSAwIHx8ICFpc0Zpbml0ZShzdGVwKSkgcmV0dXJuIFtdO1xuXG4gIGlmIChzdGVwID4gMCkge1xuICAgIHN0YXJ0ID0gTWF0aC5jZWlsKHN0YXJ0IC8gc3RlcCk7XG4gICAgc3RvcCA9IE1hdGguZmxvb3Ioc3RvcCAvIHN0ZXApO1xuICAgIHRpY2tzID0gbmV3IEFycmF5KG4gPSBNYXRoLmNlaWwoc3RvcCAtIHN0YXJ0ICsgMSkpO1xuICAgIHdoaWxlICgrK2kgPCBuKSB0aWNrc1tpXSA9IChzdGFydCArIGkpICogc3RlcDtcbiAgfSBlbHNlIHtcbiAgICBzdGFydCA9IE1hdGguZmxvb3Ioc3RhcnQgKiBzdGVwKTtcbiAgICBzdG9wID0gTWF0aC5jZWlsKHN0b3AgKiBzdGVwKTtcbiAgICB0aWNrcyA9IG5ldyBBcnJheShuID0gTWF0aC5jZWlsKHN0YXJ0IC0gc3RvcCArIDEpKTtcbiAgICB3aGlsZSAoKytpIDwgbikgdGlja3NbaV0gPSAoc3RhcnQgLSBpKSAvIHN0ZXA7XG4gIH1cblxuICBpZiAocmV2ZXJzZSkgdGlja3MucmV2ZXJzZSgpO1xuXG4gIHJldHVybiB0aWNrcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRpY2tJbmNyZW1lbnQoc3RhcnQsIHN0b3AsIGNvdW50KSB7XG4gIHZhciBzdGVwID0gKHN0b3AgLSBzdGFydCkgLyBNYXRoLm1heCgwLCBjb3VudCksXG4gICAgICBwb3dlciA9IE1hdGguZmxvb3IoTWF0aC5sb2coc3RlcCkgLyBNYXRoLkxOMTApLFxuICAgICAgZXJyb3IgPSBzdGVwIC8gTWF0aC5wb3coMTAsIHBvd2VyKTtcbiAgcmV0dXJuIHBvd2VyID49IDBcbiAgICAgID8gKGVycm9yID49IGUxMCA/IDEwIDogZXJyb3IgPj0gZTUgPyA1IDogZXJyb3IgPj0gZTIgPyAyIDogMSkgKiBNYXRoLnBvdygxMCwgcG93ZXIpXG4gICAgICA6IC1NYXRoLnBvdygxMCwgLXBvd2VyKSAvIChlcnJvciA+PSBlMTAgPyAxMCA6IGVycm9yID49IGU1ID8gNSA6IGVycm9yID49IGUyID8gMiA6IDEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGlja1N0ZXAoc3RhcnQsIHN0b3AsIGNvdW50KSB7XG4gIHZhciBzdGVwMCA9IE1hdGguYWJzKHN0b3AgLSBzdGFydCkgLyBNYXRoLm1heCgwLCBjb3VudCksXG4gICAgICBzdGVwMSA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKE1hdGgubG9nKHN0ZXAwKSAvIE1hdGguTE4xMCkpLFxuICAgICAgZXJyb3IgPSBzdGVwMCAvIHN0ZXAxO1xuICBpZiAoZXJyb3IgPj0gZTEwKSBzdGVwMSAqPSAxMDtcbiAgZWxzZSBpZiAoZXJyb3IgPj0gZTUpIHN0ZXAxICo9IDU7XG4gIGVsc2UgaWYgKGVycm9yID49IGUyKSBzdGVwMSAqPSAyO1xuICByZXR1cm4gc3RvcCA8IHN0YXJ0ID8gLXN0ZXAxIDogc3RlcDE7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgcmV0dXJuIE1hdGguY2VpbChNYXRoLmxvZyh2YWx1ZXMubGVuZ3RoKSAvIE1hdGguTE4yKSArIDE7XG59XG4iLCJpbXBvcnQge3NsaWNlfSBmcm9tIFwiLi9hcnJheVwiO1xuaW1wb3J0IGJpc2VjdCBmcm9tIFwiLi9iaXNlY3RcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudFwiO1xuaW1wb3J0IGV4dGVudCBmcm9tIFwiLi9leHRlbnRcIjtcbmltcG9ydCBpZGVudGl0eSBmcm9tIFwiLi9pZGVudGl0eVwiO1xuaW1wb3J0IHJhbmdlIGZyb20gXCIuL3JhbmdlXCI7XG5pbXBvcnQge3RpY2tTdGVwfSBmcm9tIFwiLi90aWNrc1wiO1xuaW1wb3J0IHN0dXJnZXMgZnJvbSBcIi4vdGhyZXNob2xkL3N0dXJnZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciB2YWx1ZSA9IGlkZW50aXR5LFxuICAgICAgZG9tYWluID0gZXh0ZW50LFxuICAgICAgdGhyZXNob2xkID0gc3R1cmdlcztcblxuICBmdW5jdGlvbiBoaXN0b2dyYW0oZGF0YSkge1xuICAgIHZhciBpLFxuICAgICAgICBuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgIHgsXG4gICAgICAgIHZhbHVlcyA9IG5ldyBBcnJheShuKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHZhbHVlc1tpXSA9IHZhbHVlKGRhdGFbaV0sIGksIGRhdGEpO1xuICAgIH1cblxuICAgIHZhciB4eiA9IGRvbWFpbih2YWx1ZXMpLFxuICAgICAgICB4MCA9IHh6WzBdLFxuICAgICAgICB4MSA9IHh6WzFdLFxuICAgICAgICB0eiA9IHRocmVzaG9sZCh2YWx1ZXMsIHgwLCB4MSk7XG5cbiAgICAvLyBDb252ZXJ0IG51bWJlciBvZiB0aHJlc2hvbGRzIGludG8gdW5pZm9ybSB0aHJlc2hvbGRzLlxuICAgIGlmICghQXJyYXkuaXNBcnJheSh0eikpIHtcbiAgICAgIHR6ID0gdGlja1N0ZXAoeDAsIHgxLCB0eik7XG4gICAgICB0eiA9IHJhbmdlKE1hdGguY2VpbCh4MCAvIHR6KSAqIHR6LCB4MSwgdHopOyAvLyBleGNsdXNpdmVcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgYW55IHRocmVzaG9sZHMgb3V0c2lkZSB0aGUgZG9tYWluLlxuICAgIHZhciBtID0gdHoubGVuZ3RoO1xuICAgIHdoaWxlICh0elswXSA8PSB4MCkgdHouc2hpZnQoKSwgLS1tO1xuICAgIHdoaWxlICh0elttIC0gMV0gPiB4MSkgdHoucG9wKCksIC0tbTtcblxuICAgIHZhciBiaW5zID0gbmV3IEFycmF5KG0gKyAxKSxcbiAgICAgICAgYmluO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBiaW5zLlxuICAgIGZvciAoaSA9IDA7IGkgPD0gbTsgKytpKSB7XG4gICAgICBiaW4gPSBiaW5zW2ldID0gW107XG4gICAgICBiaW4ueDAgPSBpID4gMCA/IHR6W2kgLSAxXSA6IHgwO1xuICAgICAgYmluLngxID0gaSA8IG0gPyB0eltpXSA6IHgxO1xuICAgIH1cblxuICAgIC8vIEFzc2lnbiBkYXRhIHRvIGJpbnMgYnkgdmFsdWUsIGlnbm9yaW5nIGFueSBvdXRzaWRlIHRoZSBkb21haW4uXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgeCA9IHZhbHVlc1tpXTtcbiAgICAgIGlmICh4MCA8PSB4ICYmIHggPD0geDEpIHtcbiAgICAgICAgYmluc1tiaXNlY3QodHosIHgsIDAsIG0pXS5wdXNoKGRhdGFbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBiaW5zO1xuICB9XG5cbiAgaGlzdG9ncmFtLnZhbHVlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHZhbHVlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChfKSwgaGlzdG9ncmFtKSA6IHZhbHVlO1xuICB9O1xuXG4gIGhpc3RvZ3JhbS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZG9tYWluID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChbX1swXSwgX1sxXV0pLCBoaXN0b2dyYW0pIDogZG9tYWluO1xuICB9O1xuXG4gIGhpc3RvZ3JhbS50aHJlc2hvbGRzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRocmVzaG9sZCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogQXJyYXkuaXNBcnJheShfKSA/IGNvbnN0YW50KHNsaWNlLmNhbGwoXykpIDogY29uc3RhbnQoXyksIGhpc3RvZ3JhbSkgOiB0aHJlc2hvbGQ7XG4gIH07XG5cbiAgcmV0dXJuIGhpc3RvZ3JhbTtcbn1cbiIsImltcG9ydCBudW1iZXIgZnJvbSBcIi4vbnVtYmVyXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlcywgcCwgdmFsdWVvZikge1xuICBpZiAodmFsdWVvZiA9PSBudWxsKSB2YWx1ZW9mID0gbnVtYmVyO1xuICBpZiAoIShuID0gdmFsdWVzLmxlbmd0aCkpIHJldHVybjtcbiAgaWYgKChwID0gK3ApIDw9IDAgfHwgbiA8IDIpIHJldHVybiArdmFsdWVvZih2YWx1ZXNbMF0sIDAsIHZhbHVlcyk7XG4gIGlmIChwID49IDEpIHJldHVybiArdmFsdWVvZih2YWx1ZXNbbiAtIDFdLCBuIC0gMSwgdmFsdWVzKTtcbiAgdmFyIG4sXG4gICAgICBpID0gKG4gLSAxKSAqIHAsXG4gICAgICBpMCA9IE1hdGguZmxvb3IoaSksXG4gICAgICB2YWx1ZTAgPSArdmFsdWVvZih2YWx1ZXNbaTBdLCBpMCwgdmFsdWVzKSxcbiAgICAgIHZhbHVlMSA9ICt2YWx1ZW9mKHZhbHVlc1tpMCArIDFdLCBpMCArIDEsIHZhbHVlcyk7XG4gIHJldHVybiB2YWx1ZTAgKyAodmFsdWUxIC0gdmFsdWUwKSAqIChpIC0gaTApO1xufVxuIiwiaW1wb3J0IHttYXB9IGZyb20gXCIuLi9hcnJheVwiO1xuaW1wb3J0IGFzY2VuZGluZyBmcm9tIFwiLi4vYXNjZW5kaW5nXCI7XG5pbXBvcnQgbnVtYmVyIGZyb20gXCIuLi9udW1iZXJcIjtcbmltcG9ydCBxdWFudGlsZSBmcm9tIFwiLi4vcXVhbnRpbGVcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWVzLCBtaW4sIG1heCkge1xuICB2YWx1ZXMgPSBtYXAuY2FsbCh2YWx1ZXMsIG51bWJlcikuc29ydChhc2NlbmRpbmcpO1xuICByZXR1cm4gTWF0aC5jZWlsKChtYXggLSBtaW4pIC8gKDIgKiAocXVhbnRpbGUodmFsdWVzLCAwLjc1KSAtIHF1YW50aWxlKHZhbHVlcywgMC4yNSkpICogTWF0aC5wb3codmFsdWVzLmxlbmd0aCwgLTEgLyAzKSkpO1xufVxuIiwiaW1wb3J0IGRldmlhdGlvbiBmcm9tIFwiLi4vZGV2aWF0aW9uXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlcywgbWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGguY2VpbCgobWF4IC0gbWluKSAvICgzLjUgKiBkZXZpYXRpb24odmFsdWVzKSAqIE1hdGgucG93KHZhbHVlcy5sZW5ndGgsIC0xIC8gMykpKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlcywgdmFsdWVvZikge1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBpID0gLTEsXG4gICAgICB2YWx1ZSxcbiAgICAgIG1heDtcblxuICBpZiAodmFsdWVvZiA9PSBudWxsKSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIHsgLy8gRmluZCB0aGUgZmlyc3QgY29tcGFyYWJsZSB2YWx1ZS5cbiAgICAgIGlmICgodmFsdWUgPSB2YWx1ZXNbaV0pICE9IG51bGwgJiYgdmFsdWUgPj0gdmFsdWUpIHtcbiAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIENvbXBhcmUgdGhlIHJlbWFpbmluZyB2YWx1ZXMuXG4gICAgICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlc1tpXSkgIT0gbnVsbCAmJiB2YWx1ZSA+IG1heCkge1xuICAgICAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZWxzZSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIHsgLy8gRmluZCB0aGUgZmlyc3QgY29tcGFyYWJsZSB2YWx1ZS5cbiAgICAgIGlmICgodmFsdWUgPSB2YWx1ZW9mKHZhbHVlc1tpXSwgaSwgdmFsdWVzKSkgIT0gbnVsbCAmJiB2YWx1ZSA+PSB2YWx1ZSkge1xuICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHsgLy8gQ29tcGFyZSB0aGUgcmVtYWluaW5nIHZhbHVlcy5cbiAgICAgICAgICBpZiAoKHZhbHVlID0gdmFsdWVvZih2YWx1ZXNbaV0sIGksIHZhbHVlcykpICE9IG51bGwgJiYgdmFsdWUgPiBtYXgpIHtcbiAgICAgICAgICAgIG1heCA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXg7XG59XG4iLCJpbXBvcnQgbnVtYmVyIGZyb20gXCIuL251bWJlclwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgbSA9IG4sXG4gICAgICBpID0gLTEsXG4gICAgICB2YWx1ZSxcbiAgICAgIHN1bSA9IDA7XG5cbiAgaWYgKHZhbHVlb2YgPT0gbnVsbCkge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBpZiAoIWlzTmFOKHZhbHVlID0gbnVtYmVyKHZhbHVlc1tpXSkpKSBzdW0gKz0gdmFsdWU7XG4gICAgICBlbHNlIC0tbTtcbiAgICB9XG4gIH1cblxuICBlbHNlIHtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgaWYgKCFpc05hTih2YWx1ZSA9IG51bWJlcih2YWx1ZW9mKHZhbHVlc1tpXSwgaSwgdmFsdWVzKSkpKSBzdW0gKz0gdmFsdWU7XG4gICAgICBlbHNlIC0tbTtcbiAgICB9XG4gIH1cblxuICBpZiAobSkgcmV0dXJuIHN1bSAvIG07XG59XG4iLCJpbXBvcnQgYXNjZW5kaW5nIGZyb20gXCIuL2FzY2VuZGluZ1wiO1xuaW1wb3J0IG51bWJlciBmcm9tIFwiLi9udW1iZXJcIjtcbmltcG9ydCBxdWFudGlsZSBmcm9tIFwiLi9xdWFudGlsZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgaSA9IC0xLFxuICAgICAgdmFsdWUsXG4gICAgICBudW1iZXJzID0gW107XG5cbiAgaWYgKHZhbHVlb2YgPT0gbnVsbCkge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBpZiAoIWlzTmFOKHZhbHVlID0gbnVtYmVyKHZhbHVlc1tpXSkpKSB7XG4gICAgICAgIG51bWJlcnMucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZWxzZSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGlmICghaXNOYU4odmFsdWUgPSBudW1iZXIodmFsdWVvZih2YWx1ZXNbaV0sIGksIHZhbHVlcykpKSkge1xuICAgICAgICBudW1iZXJzLnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBxdWFudGlsZShudW1iZXJzLnNvcnQoYXNjZW5kaW5nKSwgMC41KTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGFycmF5cykge1xuICB2YXIgbiA9IGFycmF5cy5sZW5ndGgsXG4gICAgICBtLFxuICAgICAgaSA9IC0xLFxuICAgICAgaiA9IDAsXG4gICAgICBtZXJnZWQsXG4gICAgICBhcnJheTtcblxuICB3aGlsZSAoKytpIDwgbikgaiArPSBhcnJheXNbaV0ubGVuZ3RoO1xuICBtZXJnZWQgPSBuZXcgQXJyYXkoaik7XG5cbiAgd2hpbGUgKC0tbiA+PSAwKSB7XG4gICAgYXJyYXkgPSBhcnJheXNbbl07XG4gICAgbSA9IGFycmF5Lmxlbmd0aDtcbiAgICB3aGlsZSAoLS1tID49IDApIHtcbiAgICAgIG1lcmdlZFstLWpdID0gYXJyYXlbbV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1lcmdlZDtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlcywgdmFsdWVvZikge1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBpID0gLTEsXG4gICAgICB2YWx1ZSxcbiAgICAgIG1pbjtcblxuICBpZiAodmFsdWVvZiA9PSBudWxsKSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIHsgLy8gRmluZCB0aGUgZmlyc3QgY29tcGFyYWJsZSB2YWx1ZS5cbiAgICAgIGlmICgodmFsdWUgPSB2YWx1ZXNbaV0pICE9IG51bGwgJiYgdmFsdWUgPj0gdmFsdWUpIHtcbiAgICAgICAgbWluID0gdmFsdWU7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIENvbXBhcmUgdGhlIHJlbWFpbmluZyB2YWx1ZXMuXG4gICAgICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlc1tpXSkgIT0gbnVsbCAmJiBtaW4gPiB2YWx1ZSkge1xuICAgICAgICAgICAgbWluID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZWxzZSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIHsgLy8gRmluZCB0aGUgZmlyc3QgY29tcGFyYWJsZSB2YWx1ZS5cbiAgICAgIGlmICgodmFsdWUgPSB2YWx1ZW9mKHZhbHVlc1tpXSwgaSwgdmFsdWVzKSkgIT0gbnVsbCAmJiB2YWx1ZSA+PSB2YWx1ZSkge1xuICAgICAgICBtaW4gPSB2YWx1ZTtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHsgLy8gQ29tcGFyZSB0aGUgcmVtYWluaW5nIHZhbHVlcy5cbiAgICAgICAgICBpZiAoKHZhbHVlID0gdmFsdWVvZih2YWx1ZXNbaV0sIGksIHZhbHVlcykpICE9IG51bGwgJiYgbWluID4gdmFsdWUpIHtcbiAgICAgICAgICAgIG1pbiA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtaW47XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhcnJheSwgaW5kZXhlcykge1xuICB2YXIgaSA9IGluZGV4ZXMubGVuZ3RoLCBwZXJtdXRlcyA9IG5ldyBBcnJheShpKTtcbiAgd2hpbGUgKGktLSkgcGVybXV0ZXNbaV0gPSBhcnJheVtpbmRleGVzW2ldXTtcbiAgcmV0dXJuIHBlcm11dGVzO1xufVxuIiwiaW1wb3J0IGFzY2VuZGluZyBmcm9tIFwiLi9hc2NlbmRpbmdcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWVzLCBjb21wYXJlKSB7XG4gIGlmICghKG4gPSB2YWx1ZXMubGVuZ3RoKSkgcmV0dXJuO1xuICB2YXIgbixcbiAgICAgIGkgPSAwLFxuICAgICAgaiA9IDAsXG4gICAgICB4aSxcbiAgICAgIHhqID0gdmFsdWVzW2pdO1xuXG4gIGlmIChjb21wYXJlID09IG51bGwpIGNvbXBhcmUgPSBhc2NlbmRpbmc7XG5cbiAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICBpZiAoY29tcGFyZSh4aSA9IHZhbHVlc1tpXSwgeGopIDwgMCB8fCBjb21wYXJlKHhqLCB4aikgIT09IDApIHtcbiAgICAgIHhqID0geGksIGogPSBpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjb21wYXJlKHhqLCB4aikgPT09IDApIHJldHVybiBqO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYXJyYXksIGkwLCBpMSkge1xuICB2YXIgbSA9IChpMSA9PSBudWxsID8gYXJyYXkubGVuZ3RoIDogaTEpIC0gKGkwID0gaTAgPT0gbnVsbCA/IDAgOiAraTApLFxuICAgICAgdCxcbiAgICAgIGk7XG5cbiAgd2hpbGUgKG0pIHtcbiAgICBpID0gTWF0aC5yYW5kb20oKSAqIG0tLSB8IDA7XG4gICAgdCA9IGFycmF5W20gKyBpMF07XG4gICAgYXJyYXlbbSArIGkwXSA9IGFycmF5W2kgKyBpMF07XG4gICAgYXJyYXlbaSArIGkwXSA9IHQ7XG4gIH1cblxuICByZXR1cm4gYXJyYXk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgaSA9IC0xLFxuICAgICAgdmFsdWUsXG4gICAgICBzdW0gPSAwO1xuXG4gIGlmICh2YWx1ZW9mID09IG51bGwpIHtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgaWYgKHZhbHVlID0gK3ZhbHVlc1tpXSkgc3VtICs9IHZhbHVlOyAvLyBOb3RlOiB6ZXJvIGFuZCBudWxsIGFyZSBlcXVpdmFsZW50LlxuICAgIH1cbiAgfVxuXG4gIGVsc2Uge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBpZiAodmFsdWUgPSArdmFsdWVvZih2YWx1ZXNbaV0sIGksIHZhbHVlcykpIHN1bSArPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VtO1xufVxuIiwiaW1wb3J0IG1pbiBmcm9tIFwiLi9taW5cIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obWF0cml4KSB7XG4gIGlmICghKG4gPSBtYXRyaXgubGVuZ3RoKSkgcmV0dXJuIFtdO1xuICBmb3IgKHZhciBpID0gLTEsIG0gPSBtaW4obWF0cml4LCBsZW5ndGgpLCB0cmFuc3Bvc2UgPSBuZXcgQXJyYXkobSk7ICsraSA8IG07KSB7XG4gICAgZm9yICh2YXIgaiA9IC0xLCBuLCByb3cgPSB0cmFuc3Bvc2VbaV0gPSBuZXcgQXJyYXkobik7ICsraiA8IG47KSB7XG4gICAgICByb3dbal0gPSBtYXRyaXhbal1baV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0cmFuc3Bvc2U7XG59XG5cbmZ1bmN0aW9uIGxlbmd0aChkKSB7XG4gIHJldHVybiBkLmxlbmd0aDtcbn1cbiIsImltcG9ydCB0cmFuc3Bvc2UgZnJvbSBcIi4vdHJhbnNwb3NlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdHJhbnNwb3NlKGFyZ3VtZW50cyk7XG59XG4iLCJleHBvcnQge2RlZmF1bHQgYXMgYmlzZWN0LCBiaXNlY3RSaWdodCwgYmlzZWN0TGVmdH0gZnJvbSBcIi4vYmlzZWN0XCI7XG5leHBvcnQge2RlZmF1bHQgYXMgYXNjZW5kaW5nfSBmcm9tIFwiLi9hc2NlbmRpbmdcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBiaXNlY3Rvcn0gZnJvbSBcIi4vYmlzZWN0b3JcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBjcm9zc30gZnJvbSBcIi4vY3Jvc3NcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBkZXNjZW5kaW5nfSBmcm9tIFwiLi9kZXNjZW5kaW5nXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgZGV2aWF0aW9ufSBmcm9tIFwiLi9kZXZpYXRpb25cIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBleHRlbnR9IGZyb20gXCIuL2V4dGVudFwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGhpc3RvZ3JhbX0gZnJvbSBcIi4vaGlzdG9ncmFtXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgdGhyZXNob2xkRnJlZWRtYW5EaWFjb25pc30gZnJvbSBcIi4vdGhyZXNob2xkL2ZyZWVkbWFuRGlhY29uaXNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB0aHJlc2hvbGRTY290dH0gZnJvbSBcIi4vdGhyZXNob2xkL3Njb3R0XCI7XG5leHBvcnQge2RlZmF1bHQgYXMgdGhyZXNob2xkU3R1cmdlc30gZnJvbSBcIi4vdGhyZXNob2xkL3N0dXJnZXNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBtYXh9IGZyb20gXCIuL21heFwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIG1lYW59IGZyb20gXCIuL21lYW5cIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBtZWRpYW59IGZyb20gXCIuL21lZGlhblwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIG1lcmdlfSBmcm9tIFwiLi9tZXJnZVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIG1pbn0gZnJvbSBcIi4vbWluXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgcGFpcnN9IGZyb20gXCIuL3BhaXJzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgcGVybXV0ZX0gZnJvbSBcIi4vcGVybXV0ZVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHF1YW50aWxlfSBmcm9tIFwiLi9xdWFudGlsZVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHJhbmdlfSBmcm9tIFwiLi9yYW5nZVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHNjYW59IGZyb20gXCIuL3NjYW5cIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzaHVmZmxlfSBmcm9tIFwiLi9zaHVmZmxlXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc3VtfSBmcm9tIFwiLi9zdW1cIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB0aWNrcywgdGlja0luY3JlbWVudCwgdGlja1N0ZXB9IGZyb20gXCIuL3RpY2tzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgdHJhbnNwb3NlfSBmcm9tIFwiLi90cmFuc3Bvc2VcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB2YXJpYW5jZX0gZnJvbSBcIi4vdmFyaWFuY2VcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB6aXB9IGZyb20gXCIuL3ppcFwiO1xuIiwiZXhwb3J0IGZ1bmN0aW9uIGluaXRSYW5nZShkb21haW4sIHJhbmdlKSB7XG4gIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogYnJlYWs7XG4gICAgY2FzZSAxOiB0aGlzLnJhbmdlKGRvbWFpbik7IGJyZWFrO1xuICAgIGRlZmF1bHQ6IHRoaXMucmFuZ2UocmFuZ2UpLmRvbWFpbihkb21haW4pOyBicmVhaztcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXRJbnRlcnBvbGF0b3IoZG9tYWluLCBpbnRlcnBvbGF0b3IpIHtcbiAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiBicmVhaztcbiAgICBjYXNlIDE6IHRoaXMuaW50ZXJwb2xhdG9yKGRvbWFpbik7IGJyZWFrO1xuICAgIGRlZmF1bHQ6IHRoaXMuaW50ZXJwb2xhdG9yKGludGVycG9sYXRvcikuZG9tYWluKGRvbWFpbik7IGJyZWFrO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuIiwidmFyIGFycmF5ID0gQXJyYXkucHJvdG90eXBlO1xuXG5leHBvcnQgdmFyIG1hcCA9IGFycmF5Lm1hcDtcbmV4cG9ydCB2YXIgc2xpY2UgPSBhcnJheS5zbGljZTtcbiIsImltcG9ydCB7bWFwfSBmcm9tIFwiZDMtY29sbGVjdGlvblwiO1xuaW1wb3J0IHtzbGljZX0gZnJvbSBcIi4vYXJyYXlcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0XCI7XG5cbmV4cG9ydCB2YXIgaW1wbGljaXQgPSB7bmFtZTogXCJpbXBsaWNpdFwifTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gb3JkaW5hbCgpIHtcbiAgdmFyIGluZGV4ID0gbWFwKCksXG4gICAgICBkb21haW4gPSBbXSxcbiAgICAgIHJhbmdlID0gW10sXG4gICAgICB1bmtub3duID0gaW1wbGljaXQ7XG5cbiAgZnVuY3Rpb24gc2NhbGUoZCkge1xuICAgIHZhciBrZXkgPSBkICsgXCJcIiwgaSA9IGluZGV4LmdldChrZXkpO1xuICAgIGlmICghaSkge1xuICAgICAgaWYgKHVua25vd24gIT09IGltcGxpY2l0KSByZXR1cm4gdW5rbm93bjtcbiAgICAgIGluZGV4LnNldChrZXksIGkgPSBkb21haW4ucHVzaChkKSk7XG4gICAgfVxuICAgIHJldHVybiByYW5nZVsoaSAtIDEpICUgcmFuZ2UubGVuZ3RoXTtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkb21haW4uc2xpY2UoKTtcbiAgICBkb21haW4gPSBbXSwgaW5kZXggPSBtYXAoKTtcbiAgICB2YXIgaSA9IC0xLCBuID0gXy5sZW5ndGgsIGQsIGtleTtcbiAgICB3aGlsZSAoKytpIDwgbikgaWYgKCFpbmRleC5oYXMoa2V5ID0gKGQgPSBfW2ldKSArIFwiXCIpKSBpbmRleC5zZXQoa2V5LCBkb21haW4ucHVzaChkKSk7XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmdlID0gc2xpY2UuY2FsbChfKSwgc2NhbGUpIDogcmFuZ2Uuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS51bmtub3duID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHVua25vd24gPSBfLCBzY2FsZSkgOiB1bmtub3duO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gb3JkaW5hbChkb21haW4sIHJhbmdlKS51bmtub3duKHVua25vd24pO1xuICB9O1xuXG4gIGluaXRSYW5nZS5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcblxuICByZXR1cm4gc2NhbGU7XG59XG4iLCJpbXBvcnQge3JhbmdlIGFzIHNlcXVlbmNlfSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0XCI7XG5pbXBvcnQgb3JkaW5hbCBmcm9tIFwiLi9vcmRpbmFsXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJhbmQoKSB7XG4gIHZhciBzY2FsZSA9IG9yZGluYWwoKS51bmtub3duKHVuZGVmaW5lZCksXG4gICAgICBkb21haW4gPSBzY2FsZS5kb21haW4sXG4gICAgICBvcmRpbmFsUmFuZ2UgPSBzY2FsZS5yYW5nZSxcbiAgICAgIHJhbmdlID0gWzAsIDFdLFxuICAgICAgc3RlcCxcbiAgICAgIGJhbmR3aWR0aCxcbiAgICAgIHJvdW5kID0gZmFsc2UsXG4gICAgICBwYWRkaW5nSW5uZXIgPSAwLFxuICAgICAgcGFkZGluZ091dGVyID0gMCxcbiAgICAgIGFsaWduID0gMC41O1xuXG4gIGRlbGV0ZSBzY2FsZS51bmtub3duO1xuXG4gIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgdmFyIG4gPSBkb21haW4oKS5sZW5ndGgsXG4gICAgICAgIHJldmVyc2UgPSByYW5nZVsxXSA8IHJhbmdlWzBdLFxuICAgICAgICBzdGFydCA9IHJhbmdlW3JldmVyc2UgLSAwXSxcbiAgICAgICAgc3RvcCA9IHJhbmdlWzEgLSByZXZlcnNlXTtcbiAgICBzdGVwID0gKHN0b3AgLSBzdGFydCkgLyBNYXRoLm1heCgxLCBuIC0gcGFkZGluZ0lubmVyICsgcGFkZGluZ091dGVyICogMik7XG4gICAgaWYgKHJvdW5kKSBzdGVwID0gTWF0aC5mbG9vcihzdGVwKTtcbiAgICBzdGFydCArPSAoc3RvcCAtIHN0YXJ0IC0gc3RlcCAqIChuIC0gcGFkZGluZ0lubmVyKSkgKiBhbGlnbjtcbiAgICBiYW5kd2lkdGggPSBzdGVwICogKDEgLSBwYWRkaW5nSW5uZXIpO1xuICAgIGlmIChyb3VuZCkgc3RhcnQgPSBNYXRoLnJvdW5kKHN0YXJ0KSwgYmFuZHdpZHRoID0gTWF0aC5yb3VuZChiYW5kd2lkdGgpO1xuICAgIHZhciB2YWx1ZXMgPSBzZXF1ZW5jZShuKS5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gc3RhcnQgKyBzdGVwICogaTsgfSk7XG4gICAgcmV0dXJuIG9yZGluYWxSYW5nZShyZXZlcnNlID8gdmFsdWVzLnJldmVyc2UoKSA6IHZhbHVlcyk7XG4gIH1cblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZG9tYWluKF8pLCByZXNjYWxlKCkpIDogZG9tYWluKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFuZ2UgPSBbK19bMF0sICtfWzFdXSwgcmVzY2FsZSgpKSA6IHJhbmdlLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2VSb3VuZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gcmFuZ2UgPSBbK19bMF0sICtfWzFdXSwgcm91bmQgPSB0cnVlLCByZXNjYWxlKCk7XG4gIH07XG5cbiAgc2NhbGUuYmFuZHdpZHRoID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGJhbmR3aWR0aDtcbiAgfTtcblxuICBzY2FsZS5zdGVwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHN0ZXA7XG4gIH07XG5cbiAgc2NhbGUucm91bmQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocm91bmQgPSAhIV8sIHJlc2NhbGUoKSkgOiByb3VuZDtcbiAgfTtcblxuICBzY2FsZS5wYWRkaW5nID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmdJbm5lciA9IE1hdGgubWluKDEsIHBhZGRpbmdPdXRlciA9ICtfKSwgcmVzY2FsZSgpKSA6IHBhZGRpbmdJbm5lcjtcbiAgfTtcblxuICBzY2FsZS5wYWRkaW5nSW5uZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ0lubmVyID0gTWF0aC5taW4oMSwgXyksIHJlc2NhbGUoKSkgOiBwYWRkaW5nSW5uZXI7XG4gIH07XG5cbiAgc2NhbGUucGFkZGluZ091dGVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmdPdXRlciA9ICtfLCByZXNjYWxlKCkpIDogcGFkZGluZ091dGVyO1xuICB9O1xuXG4gIHNjYWxlLmFsaWduID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGFsaWduID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgXykpLCByZXNjYWxlKCkpIDogYWxpZ247XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBiYW5kKGRvbWFpbigpLCByYW5nZSlcbiAgICAgICAgLnJvdW5kKHJvdW5kKVxuICAgICAgICAucGFkZGluZ0lubmVyKHBhZGRpbmdJbm5lcilcbiAgICAgICAgLnBhZGRpbmdPdXRlcihwYWRkaW5nT3V0ZXIpXG4gICAgICAgIC5hbGlnbihhbGlnbik7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRSYW5nZS5hcHBseShyZXNjYWxlKCksIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIHBvaW50aXNoKHNjYWxlKSB7XG4gIHZhciBjb3B5ID0gc2NhbGUuY29weTtcblxuICBzY2FsZS5wYWRkaW5nID0gc2NhbGUucGFkZGluZ091dGVyO1xuICBkZWxldGUgc2NhbGUucGFkZGluZ0lubmVyO1xuICBkZWxldGUgc2NhbGUucGFkZGluZ091dGVyO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcG9pbnRpc2goY29weSgpKTtcbiAgfTtcblxuICByZXR1cm4gc2NhbGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb2ludCgpIHtcbiAgcmV0dXJuIHBvaW50aXNoKGJhbmQuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5wYWRkaW5nSW5uZXIoMSkpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiAreDtcbn1cbiIsImltcG9ydCB7YmlzZWN0fSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7aW50ZXJwb2xhdGUgYXMgaW50ZXJwb2xhdGVWYWx1ZSwgaW50ZXJwb2xhdGVOdW1iZXIsIGludGVycG9sYXRlUm91bmR9IGZyb20gXCJkMy1pbnRlcnBvbGF0ZVwiO1xuaW1wb3J0IHttYXAsIHNsaWNlfSBmcm9tIFwiLi9hcnJheVwiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50XCI7XG5pbXBvcnQgbnVtYmVyIGZyb20gXCIuL251bWJlclwiO1xuXG52YXIgdW5pdCA9IFswLCAxXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlkZW50aXR5KHgpIHtcbiAgcmV0dXJuIHg7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZShhLCBiKSB7XG4gIHJldHVybiAoYiAtPSAoYSA9ICthKSlcbiAgICAgID8gZnVuY3Rpb24oeCkgeyByZXR1cm4gKHggLSBhKSAvIGI7IH1cbiAgICAgIDogY29uc3RhbnQoaXNOYU4oYikgPyBOYU4gOiAwLjUpO1xufVxuXG5mdW5jdGlvbiBjbGFtcGVyKGRvbWFpbikge1xuICB2YXIgYSA9IGRvbWFpblswXSwgYiA9IGRvbWFpbltkb21haW4ubGVuZ3RoIC0gMV0sIHQ7XG4gIGlmIChhID4gYikgdCA9IGEsIGEgPSBiLCBiID0gdDtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgubWF4KGEsIE1hdGgubWluKGIsIHgpKTsgfTtcbn1cblxuLy8gbm9ybWFsaXplKGEsIGIpKHgpIHRha2VzIGEgZG9tYWluIHZhbHVlIHggaW4gW2EsYl0gYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGFyYW1ldGVyIHQgaW4gWzAsMV0uXG4vLyBpbnRlcnBvbGF0ZShhLCBiKSh0KSB0YWtlcyBhIHBhcmFtZXRlciB0IGluIFswLDFdIGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHJhbmdlIHZhbHVlIHggaW4gW2EsYl0uXG5mdW5jdGlvbiBiaW1hcChkb21haW4sIHJhbmdlLCBpbnRlcnBvbGF0ZSkge1xuICB2YXIgZDAgPSBkb21haW5bMF0sIGQxID0gZG9tYWluWzFdLCByMCA9IHJhbmdlWzBdLCByMSA9IHJhbmdlWzFdO1xuICBpZiAoZDEgPCBkMCkgZDAgPSBub3JtYWxpemUoZDEsIGQwKSwgcjAgPSBpbnRlcnBvbGF0ZShyMSwgcjApO1xuICBlbHNlIGQwID0gbm9ybWFsaXplKGQwLCBkMSksIHIwID0gaW50ZXJwb2xhdGUocjAsIHIxKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHIwKGQwKHgpKTsgfTtcbn1cblxuZnVuY3Rpb24gcG9seW1hcChkb21haW4sIHJhbmdlLCBpbnRlcnBvbGF0ZSkge1xuICB2YXIgaiA9IE1hdGgubWluKGRvbWFpbi5sZW5ndGgsIHJhbmdlLmxlbmd0aCkgLSAxLFxuICAgICAgZCA9IG5ldyBBcnJheShqKSxcbiAgICAgIHIgPSBuZXcgQXJyYXkoaiksXG4gICAgICBpID0gLTE7XG5cbiAgLy8gUmV2ZXJzZSBkZXNjZW5kaW5nIGRvbWFpbnMuXG4gIGlmIChkb21haW5bal0gPCBkb21haW5bMF0pIHtcbiAgICBkb21haW4gPSBkb21haW4uc2xpY2UoKS5yZXZlcnNlKCk7XG4gICAgcmFuZ2UgPSByYW5nZS5zbGljZSgpLnJldmVyc2UoKTtcbiAgfVxuXG4gIHdoaWxlICgrK2kgPCBqKSB7XG4gICAgZFtpXSA9IG5vcm1hbGl6ZShkb21haW5baV0sIGRvbWFpbltpICsgMV0pO1xuICAgIHJbaV0gPSBpbnRlcnBvbGF0ZShyYW5nZVtpXSwgcmFuZ2VbaSArIDFdKTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgdmFyIGkgPSBiaXNlY3QoZG9tYWluLCB4LCAxLCBqKSAtIDE7XG4gICAgcmV0dXJuIHJbaV0oZFtpXSh4KSk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KHNvdXJjZSwgdGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXRcbiAgICAgIC5kb21haW4oc291cmNlLmRvbWFpbigpKVxuICAgICAgLnJhbmdlKHNvdXJjZS5yYW5nZSgpKVxuICAgICAgLmludGVycG9sYXRlKHNvdXJjZS5pbnRlcnBvbGF0ZSgpKVxuICAgICAgLmNsYW1wKHNvdXJjZS5jbGFtcCgpKVxuICAgICAgLnVua25vd24oc291cmNlLnVua25vd24oKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1lcigpIHtcbiAgdmFyIGRvbWFpbiA9IHVuaXQsXG4gICAgICByYW5nZSA9IHVuaXQsXG4gICAgICBpbnRlcnBvbGF0ZSA9IGludGVycG9sYXRlVmFsdWUsXG4gICAgICB0cmFuc2Zvcm0sXG4gICAgICB1bnRyYW5zZm9ybSxcbiAgICAgIHVua25vd24sXG4gICAgICBjbGFtcCA9IGlkZW50aXR5LFxuICAgICAgcGllY2V3aXNlLFxuICAgICAgb3V0cHV0LFxuICAgICAgaW5wdXQ7XG5cbiAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICBwaWVjZXdpc2UgPSBNYXRoLm1pbihkb21haW4ubGVuZ3RoLCByYW5nZS5sZW5ndGgpID4gMiA/IHBvbHltYXAgOiBiaW1hcDtcbiAgICBvdXRwdXQgPSBpbnB1dCA9IG51bGw7XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgIHJldHVybiBpc05hTih4ID0gK3gpID8gdW5rbm93biA6IChvdXRwdXQgfHwgKG91dHB1dCA9IHBpZWNld2lzZShkb21haW4ubWFwKHRyYW5zZm9ybSksIHJhbmdlLCBpbnRlcnBvbGF0ZSkpKSh0cmFuc2Zvcm0oY2xhbXAoeCkpKTtcbiAgfVxuXG4gIHNjYWxlLmludmVydCA9IGZ1bmN0aW9uKHkpIHtcbiAgICByZXR1cm4gY2xhbXAodW50cmFuc2Zvcm0oKGlucHV0IHx8IChpbnB1dCA9IHBpZWNld2lzZShyYW5nZSwgZG9tYWluLm1hcCh0cmFuc2Zvcm0pLCBpbnRlcnBvbGF0ZU51bWJlcikpKSh5KSkpO1xuICB9O1xuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4gPSBtYXAuY2FsbChfLCBudW1iZXIpLCBjbGFtcCA9PT0gaWRlbnRpdHkgfHwgKGNsYW1wID0gY2xhbXBlcihkb21haW4pKSwgcmVzY2FsZSgpKSA6IGRvbWFpbi5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmdlID0gc2xpY2UuY2FsbChfKSwgcmVzY2FsZSgpKSA6IHJhbmdlLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2VSb3VuZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gcmFuZ2UgPSBzbGljZS5jYWxsKF8pLCBpbnRlcnBvbGF0ZSA9IGludGVycG9sYXRlUm91bmQsIHJlc2NhbGUoKTtcbiAgfTtcblxuICBzY2FsZS5jbGFtcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjbGFtcCA9IF8gPyBjbGFtcGVyKGRvbWFpbikgOiBpZGVudGl0eSwgc2NhbGUpIDogY2xhbXAgIT09IGlkZW50aXR5O1xuICB9O1xuXG4gIHNjYWxlLmludGVycG9sYXRlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGludGVycG9sYXRlID0gXywgcmVzY2FsZSgpKSA6IGludGVycG9sYXRlO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHQsIHUpIHtcbiAgICB0cmFuc2Zvcm0gPSB0LCB1bnRyYW5zZm9ybSA9IHU7XG4gICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29udGludW91cyh0cmFuc2Zvcm0sIHVudHJhbnNmb3JtKSB7XG4gIHJldHVybiB0cmFuc2Zvcm1lcigpKHRyYW5zZm9ybSwgdW50cmFuc2Zvcm0pO1xufVxuIiwiaW1wb3J0IHt0aWNrU3RlcH0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge2Zvcm1hdCwgZm9ybWF0UHJlZml4LCBmb3JtYXRTcGVjaWZpZXIsIHByZWNpc2lvbkZpeGVkLCBwcmVjaXNpb25QcmVmaXgsIHByZWNpc2lvblJvdW5kfSBmcm9tIFwiZDMtZm9ybWF0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBjb3VudCwgc3BlY2lmaWVyKSB7XG4gIHZhciBzdGVwID0gdGlja1N0ZXAoc3RhcnQsIHN0b3AsIGNvdW50KSxcbiAgICAgIHByZWNpc2lvbjtcbiAgc3BlY2lmaWVyID0gZm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllciA9PSBudWxsID8gXCIsZlwiIDogc3BlY2lmaWVyKTtcbiAgc3dpdGNoIChzcGVjaWZpZXIudHlwZSkge1xuICAgIGNhc2UgXCJzXCI6IHtcbiAgICAgIHZhciB2YWx1ZSA9IE1hdGgubWF4KE1hdGguYWJzKHN0YXJ0KSwgTWF0aC5hYnMoc3RvcCkpO1xuICAgICAgaWYgKHNwZWNpZmllci5wcmVjaXNpb24gPT0gbnVsbCAmJiAhaXNOYU4ocHJlY2lzaW9uID0gcHJlY2lzaW9uUHJlZml4KHN0ZXAsIHZhbHVlKSkpIHNwZWNpZmllci5wcmVjaXNpb24gPSBwcmVjaXNpb247XG4gICAgICByZXR1cm4gZm9ybWF0UHJlZml4KHNwZWNpZmllciwgdmFsdWUpO1xuICAgIH1cbiAgICBjYXNlIFwiXCI6XG4gICAgY2FzZSBcImVcIjpcbiAgICBjYXNlIFwiZ1wiOlxuICAgIGNhc2UgXCJwXCI6XG4gICAgY2FzZSBcInJcIjoge1xuICAgICAgaWYgKHNwZWNpZmllci5wcmVjaXNpb24gPT0gbnVsbCAmJiAhaXNOYU4ocHJlY2lzaW9uID0gcHJlY2lzaW9uUm91bmQoc3RlcCwgTWF0aC5tYXgoTWF0aC5hYnMoc3RhcnQpLCBNYXRoLmFicyhzdG9wKSkpKSkgc3BlY2lmaWVyLnByZWNpc2lvbiA9IHByZWNpc2lvbiAtIChzcGVjaWZpZXIudHlwZSA9PT0gXCJlXCIpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJmXCI6XG4gICAgY2FzZSBcIiVcIjoge1xuICAgICAgaWYgKHNwZWNpZmllci5wcmVjaXNpb24gPT0gbnVsbCAmJiAhaXNOYU4ocHJlY2lzaW9uID0gcHJlY2lzaW9uRml4ZWQoc3RlcCkpKSBzcGVjaWZpZXIucHJlY2lzaW9uID0gcHJlY2lzaW9uIC0gKHNwZWNpZmllci50eXBlID09PSBcIiVcIikgKiAyO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBmb3JtYXQoc3BlY2lmaWVyKTtcbn1cbiIsImltcG9ydCB7dGlja3MsIHRpY2tJbmNyZW1lbnR9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IGNvbnRpbnVvdXMsIHtjb3B5LCBpZGVudGl0eX0gZnJvbSBcIi4vY29udGludW91c1wiO1xuaW1wb3J0IHtpbml0UmFuZ2V9IGZyb20gXCIuL2luaXRcIjtcbmltcG9ydCB0aWNrRm9ybWF0IGZyb20gXCIuL3RpY2tGb3JtYXRcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhcmlzaChzY2FsZSkge1xuICB2YXIgZG9tYWluID0gc2NhbGUuZG9tYWluO1xuXG4gIHNjYWxlLnRpY2tzID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICB2YXIgZCA9IGRvbWFpbigpO1xuICAgIHJldHVybiB0aWNrcyhkWzBdLCBkW2QubGVuZ3RoIC0gMV0sIGNvdW50ID09IG51bGwgPyAxMCA6IGNvdW50KTtcbiAgfTtcblxuICBzY2FsZS50aWNrRm9ybWF0ID0gZnVuY3Rpb24oY291bnQsIHNwZWNpZmllcikge1xuICAgIHZhciBkID0gZG9tYWluKCk7XG4gICAgcmV0dXJuIHRpY2tGb3JtYXQoZFswXSwgZFtkLmxlbmd0aCAtIDFdLCBjb3VudCA9PSBudWxsID8gMTAgOiBjb3VudCwgc3BlY2lmaWVyKTtcbiAgfTtcblxuICBzY2FsZS5uaWNlID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICBpZiAoY291bnQgPT0gbnVsbCkgY291bnQgPSAxMDtcblxuICAgIHZhciBkID0gZG9tYWluKCksXG4gICAgICAgIGkwID0gMCxcbiAgICAgICAgaTEgPSBkLmxlbmd0aCAtIDEsXG4gICAgICAgIHN0YXJ0ID0gZFtpMF0sXG4gICAgICAgIHN0b3AgPSBkW2kxXSxcbiAgICAgICAgc3RlcDtcblxuICAgIGlmIChzdG9wIDwgc3RhcnQpIHtcbiAgICAgIHN0ZXAgPSBzdGFydCwgc3RhcnQgPSBzdG9wLCBzdG9wID0gc3RlcDtcbiAgICAgIHN0ZXAgPSBpMCwgaTAgPSBpMSwgaTEgPSBzdGVwO1xuICAgIH1cblxuICAgIHN0ZXAgPSB0aWNrSW5jcmVtZW50KHN0YXJ0LCBzdG9wLCBjb3VudCk7XG5cbiAgICBpZiAoc3RlcCA+IDApIHtcbiAgICAgIHN0YXJ0ID0gTWF0aC5mbG9vcihzdGFydCAvIHN0ZXApICogc3RlcDtcbiAgICAgIHN0b3AgPSBNYXRoLmNlaWwoc3RvcCAvIHN0ZXApICogc3RlcDtcbiAgICAgIHN0ZXAgPSB0aWNrSW5jcmVtZW50KHN0YXJ0LCBzdG9wLCBjb3VudCk7XG4gICAgfSBlbHNlIGlmIChzdGVwIDwgMCkge1xuICAgICAgc3RhcnQgPSBNYXRoLmNlaWwoc3RhcnQgKiBzdGVwKSAvIHN0ZXA7XG4gICAgICBzdG9wID0gTWF0aC5mbG9vcihzdG9wICogc3RlcCkgLyBzdGVwO1xuICAgICAgc3RlcCA9IHRpY2tJbmNyZW1lbnQoc3RhcnQsIHN0b3AsIGNvdW50KTtcbiAgICB9XG5cbiAgICBpZiAoc3RlcCA+IDApIHtcbiAgICAgIGRbaTBdID0gTWF0aC5mbG9vcihzdGFydCAvIHN0ZXApICogc3RlcDtcbiAgICAgIGRbaTFdID0gTWF0aC5jZWlsKHN0b3AgLyBzdGVwKSAqIHN0ZXA7XG4gICAgICBkb21haW4oZCk7XG4gICAgfSBlbHNlIGlmIChzdGVwIDwgMCkge1xuICAgICAgZFtpMF0gPSBNYXRoLmNlaWwoc3RhcnQgKiBzdGVwKSAvIHN0ZXA7XG4gICAgICBkW2kxXSA9IE1hdGguZmxvb3Ioc3RvcCAqIHN0ZXApIC8gc3RlcDtcbiAgICAgIGRvbWFpbihkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2NhbGU7XG4gIH07XG5cbiAgcmV0dXJuIHNjYWxlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsaW5lYXIoKSB7XG4gIHZhciBzY2FsZSA9IGNvbnRpbnVvdXMoaWRlbnRpdHksIGlkZW50aXR5KTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIGxpbmVhcigpKTtcbiAgfTtcblxuICBpbml0UmFuZ2UuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG5cbiAgcmV0dXJuIGxpbmVhcmlzaChzY2FsZSk7XG59XG4iLCJpbXBvcnQge21hcH0gZnJvbSBcIi4vYXJyYXlcIjtcbmltcG9ydCB7bGluZWFyaXNofSBmcm9tIFwiLi9saW5lYXJcIjtcbmltcG9ydCBudW1iZXIgZnJvbSBcIi4vbnVtYmVyXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlkZW50aXR5KGRvbWFpbikge1xuICB2YXIgdW5rbm93bjtcblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgcmV0dXJuIGlzTmFOKHggPSAreCkgPyB1bmtub3duIDogeDtcbiAgfVxuXG4gIHNjYWxlLmludmVydCA9IHNjYWxlO1xuXG4gIHNjYWxlLmRvbWFpbiA9IHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRvbWFpbiA9IG1hcC5jYWxsKF8sIG51bWJlciksIHNjYWxlKSA6IGRvbWFpbi5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpZGVudGl0eShkb21haW4pLnVua25vd24odW5rbm93bik7XG4gIH07XG5cbiAgZG9tYWluID0gYXJndW1lbnRzLmxlbmd0aCA/IG1hcC5jYWxsKGRvbWFpbiwgbnVtYmVyKSA6IFswLCAxXTtcblxuICByZXR1cm4gbGluZWFyaXNoKHNjYWxlKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGRvbWFpbiwgaW50ZXJ2YWwpIHtcbiAgZG9tYWluID0gZG9tYWluLnNsaWNlKCk7XG5cbiAgdmFyIGkwID0gMCxcbiAgICAgIGkxID0gZG9tYWluLmxlbmd0aCAtIDEsXG4gICAgICB4MCA9IGRvbWFpbltpMF0sXG4gICAgICB4MSA9IGRvbWFpbltpMV0sXG4gICAgICB0O1xuXG4gIGlmICh4MSA8IHgwKSB7XG4gICAgdCA9IGkwLCBpMCA9IGkxLCBpMSA9IHQ7XG4gICAgdCA9IHgwLCB4MCA9IHgxLCB4MSA9IHQ7XG4gIH1cblxuICBkb21haW5baTBdID0gaW50ZXJ2YWwuZmxvb3IoeDApO1xuICBkb21haW5baTFdID0gaW50ZXJ2YWwuY2VpbCh4MSk7XG4gIHJldHVybiBkb21haW47XG59XG4iLCJpbXBvcnQge3RpY2tzfSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7Zm9ybWF0fSBmcm9tIFwiZDMtZm9ybWF0XCI7XG5pbXBvcnQgbmljZSBmcm9tIFwiLi9uaWNlXCI7XG5pbXBvcnQge2NvcHksIHRyYW5zZm9ybWVyfSBmcm9tIFwiLi9jb250aW51b3VzXCI7XG5pbXBvcnQge2luaXRSYW5nZX0gZnJvbSBcIi4vaW5pdFwiO1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Mb2coeCkge1xuICByZXR1cm4gTWF0aC5sb2coeCk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybUV4cCh4KSB7XG4gIHJldHVybiBNYXRoLmV4cCh4KTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtTG9nbih4KSB7XG4gIHJldHVybiAtTWF0aC5sb2coLXgpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1FeHBuKHgpIHtcbiAgcmV0dXJuIC1NYXRoLmV4cCgteCk7XG59XG5cbmZ1bmN0aW9uIHBvdzEwKHgpIHtcbiAgcmV0dXJuIGlzRmluaXRlKHgpID8gKyhcIjFlXCIgKyB4KSA6IHggPCAwID8gMCA6IHg7XG59XG5cbmZ1bmN0aW9uIHBvd3AoYmFzZSkge1xuICByZXR1cm4gYmFzZSA9PT0gMTAgPyBwb3cxMFxuICAgICAgOiBiYXNlID09PSBNYXRoLkUgPyBNYXRoLmV4cFxuICAgICAgOiBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLnBvdyhiYXNlLCB4KTsgfTtcbn1cblxuZnVuY3Rpb24gbG9ncChiYXNlKSB7XG4gIHJldHVybiBiYXNlID09PSBNYXRoLkUgPyBNYXRoLmxvZ1xuICAgICAgOiBiYXNlID09PSAxMCAmJiBNYXRoLmxvZzEwXG4gICAgICB8fCBiYXNlID09PSAyICYmIE1hdGgubG9nMlxuICAgICAgfHwgKGJhc2UgPSBNYXRoLmxvZyhiYXNlKSwgZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5sb2coeCkgLyBiYXNlOyB9KTtcbn1cblxuZnVuY3Rpb24gcmVmbGVjdChmKSB7XG4gIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIC1mKC14KTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvZ2dpc2godHJhbnNmb3JtKSB7XG4gIHZhciBzY2FsZSA9IHRyYW5zZm9ybSh0cmFuc2Zvcm1Mb2csIHRyYW5zZm9ybUV4cCksXG4gICAgICBkb21haW4gPSBzY2FsZS5kb21haW4sXG4gICAgICBiYXNlID0gMTAsXG4gICAgICBsb2dzLFxuICAgICAgcG93cztcblxuICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgIGxvZ3MgPSBsb2dwKGJhc2UpLCBwb3dzID0gcG93cChiYXNlKTtcbiAgICBpZiAoZG9tYWluKClbMF0gPCAwKSB7XG4gICAgICBsb2dzID0gcmVmbGVjdChsb2dzKSwgcG93cyA9IHJlZmxlY3QocG93cyk7XG4gICAgICB0cmFuc2Zvcm0odHJhbnNmb3JtTG9nbiwgdHJhbnNmb3JtRXhwbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYW5zZm9ybSh0cmFuc2Zvcm1Mb2csIHRyYW5zZm9ybUV4cCk7XG4gICAgfVxuICAgIHJldHVybiBzY2FsZTtcbiAgfVxuXG4gIHNjYWxlLmJhc2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYmFzZSA9ICtfLCByZXNjYWxlKCkpIDogYmFzZTtcbiAgfTtcblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZG9tYWluKF8pLCByZXNjYWxlKCkpIDogZG9tYWluKCk7XG4gIH07XG5cbiAgc2NhbGUudGlja3MgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIHZhciBkID0gZG9tYWluKCksXG4gICAgICAgIHUgPSBkWzBdLFxuICAgICAgICB2ID0gZFtkLmxlbmd0aCAtIDFdLFxuICAgICAgICByO1xuXG4gICAgaWYgKHIgPSB2IDwgdSkgaSA9IHUsIHUgPSB2LCB2ID0gaTtcblxuICAgIHZhciBpID0gbG9ncyh1KSxcbiAgICAgICAgaiA9IGxvZ3ModiksXG4gICAgICAgIHAsXG4gICAgICAgIGssXG4gICAgICAgIHQsXG4gICAgICAgIG4gPSBjb3VudCA9PSBudWxsID8gMTAgOiArY291bnQsXG4gICAgICAgIHogPSBbXTtcblxuICAgIGlmICghKGJhc2UgJSAxKSAmJiBqIC0gaSA8IG4pIHtcbiAgICAgIGkgPSBNYXRoLnJvdW5kKGkpIC0gMSwgaiA9IE1hdGgucm91bmQoaikgKyAxO1xuICAgICAgaWYgKHUgPiAwKSBmb3IgKDsgaSA8IGo7ICsraSkge1xuICAgICAgICBmb3IgKGsgPSAxLCBwID0gcG93cyhpKTsgayA8IGJhc2U7ICsraykge1xuICAgICAgICAgIHQgPSBwICogaztcbiAgICAgICAgICBpZiAodCA8IHUpIGNvbnRpbnVlO1xuICAgICAgICAgIGlmICh0ID4gdikgYnJlYWs7XG4gICAgICAgICAgei5wdXNoKHQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgZm9yICg7IGkgPCBqOyArK2kpIHtcbiAgICAgICAgZm9yIChrID0gYmFzZSAtIDEsIHAgPSBwb3dzKGkpOyBrID49IDE7IC0taykge1xuICAgICAgICAgIHQgPSBwICogaztcbiAgICAgICAgICBpZiAodCA8IHUpIGNvbnRpbnVlO1xuICAgICAgICAgIGlmICh0ID4gdikgYnJlYWs7XG4gICAgICAgICAgei5wdXNoKHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHogPSB0aWNrcyhpLCBqLCBNYXRoLm1pbihqIC0gaSwgbikpLm1hcChwb3dzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gciA/IHoucmV2ZXJzZSgpIDogejtcbiAgfTtcblxuICBzY2FsZS50aWNrRm9ybWF0ID0gZnVuY3Rpb24oY291bnQsIHNwZWNpZmllcikge1xuICAgIGlmIChzcGVjaWZpZXIgPT0gbnVsbCkgc3BlY2lmaWVyID0gYmFzZSA9PT0gMTAgPyBcIi4wZVwiIDogXCIsXCI7XG4gICAgaWYgKHR5cGVvZiBzcGVjaWZpZXIgIT09IFwiZnVuY3Rpb25cIikgc3BlY2lmaWVyID0gZm9ybWF0KHNwZWNpZmllcik7XG4gICAgaWYgKGNvdW50ID09PSBJbmZpbml0eSkgcmV0dXJuIHNwZWNpZmllcjtcbiAgICBpZiAoY291bnQgPT0gbnVsbCkgY291bnQgPSAxMDtcbiAgICB2YXIgayA9IE1hdGgubWF4KDEsIGJhc2UgKiBjb3VudCAvIHNjYWxlLnRpY2tzKCkubGVuZ3RoKTsgLy8gVE9ETyBmYXN0IGVzdGltYXRlP1xuICAgIHJldHVybiBmdW5jdGlvbihkKSB7XG4gICAgICB2YXIgaSA9IGQgLyBwb3dzKE1hdGgucm91bmQobG9ncyhkKSkpO1xuICAgICAgaWYgKGkgKiBiYXNlIDwgYmFzZSAtIDAuNSkgaSAqPSBiYXNlO1xuICAgICAgcmV0dXJuIGkgPD0gayA/IHNwZWNpZmllcihkKSA6IFwiXCI7XG4gICAgfTtcbiAgfTtcblxuICBzY2FsZS5uaWNlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRvbWFpbihuaWNlKGRvbWFpbigpLCB7XG4gICAgICBmbG9vcjogZnVuY3Rpb24oeCkgeyByZXR1cm4gcG93cyhNYXRoLmZsb29yKGxvZ3MoeCkpKTsgfSxcbiAgICAgIGNlaWw6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHBvd3MoTWF0aC5jZWlsKGxvZ3MoeCkpKTsgfVxuICAgIH0pKTtcbiAgfTtcblxuICByZXR1cm4gc2NhbGU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxvZygpIHtcbiAgdmFyIHNjYWxlID0gbG9nZ2lzaCh0cmFuc2Zvcm1lcigpKS5kb21haW4oWzEsIDEwXSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBsb2coKSkuYmFzZShzY2FsZS5iYXNlKCkpO1xuICB9O1xuXG4gIGluaXRSYW5nZS5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcblxuICByZXR1cm4gc2NhbGU7XG59XG4iLCJpbXBvcnQge2xpbmVhcmlzaH0gZnJvbSBcIi4vbGluZWFyXCI7XG5pbXBvcnQge2NvcHksIHRyYW5zZm9ybWVyfSBmcm9tIFwiLi9jb250aW51b3VzXCI7XG5pbXBvcnQge2luaXRSYW5nZX0gZnJvbSBcIi4vaW5pdFwiO1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TeW1sb2coYykge1xuICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBNYXRoLnNpZ24oeCkgKiBNYXRoLmxvZzFwKE1hdGguYWJzKHggLyBjKSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN5bWV4cChjKSB7XG4gIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIE1hdGguc2lnbih4KSAqIE1hdGguZXhwbTEoTWF0aC5hYnMoeCkpICogYztcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN5bWxvZ2lzaCh0cmFuc2Zvcm0pIHtcbiAgdmFyIGMgPSAxLCBzY2FsZSA9IHRyYW5zZm9ybSh0cmFuc2Zvcm1TeW1sb2coYyksIHRyYW5zZm9ybVN5bWV4cChjKSk7XG5cbiAgc2NhbGUuY29uc3RhbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0cmFuc2Zvcm0odHJhbnNmb3JtU3ltbG9nKGMgPSArXyksIHRyYW5zZm9ybVN5bWV4cChjKSkgOiBjO1xuICB9O1xuXG4gIHJldHVybiBsaW5lYXJpc2goc2NhbGUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzeW1sb2coKSB7XG4gIHZhciBzY2FsZSA9IHN5bWxvZ2lzaCh0cmFuc2Zvcm1lcigpKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIHN5bWxvZygpKS5jb25zdGFudChzY2FsZS5jb25zdGFudCgpKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdFJhbmdlLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuIiwiaW1wb3J0IHtsaW5lYXJpc2h9IGZyb20gXCIuL2xpbmVhclwiO1xuaW1wb3J0IHtjb3B5LCBpZGVudGl0eSwgdHJhbnNmb3JtZXJ9IGZyb20gXCIuL2NvbnRpbnVvdXNcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0XCI7XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVBvdyhleHBvbmVudCkge1xuICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB4IDwgMCA/IC1NYXRoLnBvdygteCwgZXhwb25lbnQpIDogTWF0aC5wb3coeCwgZXhwb25lbnQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TcXJ0KHgpIHtcbiAgcmV0dXJuIHggPCAwID8gLU1hdGguc3FydCgteCkgOiBNYXRoLnNxcnQoeCk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVNxdWFyZSh4KSB7XG4gIHJldHVybiB4IDwgMCA/IC14ICogeCA6IHggKiB4O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG93aXNoKHRyYW5zZm9ybSkge1xuICB2YXIgc2NhbGUgPSB0cmFuc2Zvcm0oaWRlbnRpdHksIGlkZW50aXR5KSxcbiAgICAgIGV4cG9uZW50ID0gMTtcblxuICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgIHJldHVybiBleHBvbmVudCA9PT0gMSA/IHRyYW5zZm9ybShpZGVudGl0eSwgaWRlbnRpdHkpXG4gICAgICAgIDogZXhwb25lbnQgPT09IDAuNSA/IHRyYW5zZm9ybSh0cmFuc2Zvcm1TcXJ0LCB0cmFuc2Zvcm1TcXVhcmUpXG4gICAgICAgIDogdHJhbnNmb3JtKHRyYW5zZm9ybVBvdyhleHBvbmVudCksIHRyYW5zZm9ybVBvdygxIC8gZXhwb25lbnQpKTtcbiAgfVxuXG4gIHNjYWxlLmV4cG9uZW50ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGV4cG9uZW50ID0gK18sIHJlc2NhbGUoKSkgOiBleHBvbmVudDtcbiAgfTtcblxuICByZXR1cm4gbGluZWFyaXNoKHNjYWxlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcG93KCkge1xuICB2YXIgc2NhbGUgPSBwb3dpc2godHJhbnNmb3JtZXIoKSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBwb3coKSkuZXhwb25lbnQoc2NhbGUuZXhwb25lbnQoKSk7XG4gIH07XG5cbiAgaW5pdFJhbmdlLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xuXG4gIHJldHVybiBzY2FsZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNxcnQoKSB7XG4gIHJldHVybiBwb3cuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5leHBvbmVudCgwLjUpO1xufVxuIiwiaW1wb3J0IHthc2NlbmRpbmcsIGJpc2VjdCwgcXVhbnRpbGUgYXMgdGhyZXNob2xkfSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7c2xpY2V9IGZyb20gXCIuL2FycmF5XCI7XG5pbXBvcnQge2luaXRSYW5nZX0gZnJvbSBcIi4vaW5pdFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBxdWFudGlsZSgpIHtcbiAgdmFyIGRvbWFpbiA9IFtdLFxuICAgICAgcmFuZ2UgPSBbXSxcbiAgICAgIHRocmVzaG9sZHMgPSBbXSxcbiAgICAgIHVua25vd247XG5cbiAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICB2YXIgaSA9IDAsIG4gPSBNYXRoLm1heCgxLCByYW5nZS5sZW5ndGgpO1xuICAgIHRocmVzaG9sZHMgPSBuZXcgQXJyYXkobiAtIDEpO1xuICAgIHdoaWxlICgrK2kgPCBuKSB0aHJlc2hvbGRzW2kgLSAxXSA9IHRocmVzaG9sZChkb21haW4sIGkgLyBuKTtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH1cblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgcmV0dXJuIGlzTmFOKHggPSAreCkgPyB1bmtub3duIDogcmFuZ2VbYmlzZWN0KHRocmVzaG9sZHMsIHgpXTtcbiAgfVxuXG4gIHNjYWxlLmludmVydEV4dGVudCA9IGZ1bmN0aW9uKHkpIHtcbiAgICB2YXIgaSA9IHJhbmdlLmluZGV4T2YoeSk7XG4gICAgcmV0dXJuIGkgPCAwID8gW05hTiwgTmFOXSA6IFtcbiAgICAgIGkgPiAwID8gdGhyZXNob2xkc1tpIC0gMV0gOiBkb21haW5bMF0sXG4gICAgICBpIDwgdGhyZXNob2xkcy5sZW5ndGggPyB0aHJlc2hvbGRzW2ldIDogZG9tYWluW2RvbWFpbi5sZW5ndGggLSAxXVxuICAgIF07XG4gIH07XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbi5zbGljZSgpO1xuICAgIGRvbWFpbiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gXy5sZW5ndGgsIGQ7IGkgPCBuOyArK2kpIGlmIChkID0gX1tpXSwgZCAhPSBudWxsICYmICFpc05hTihkID0gK2QpKSBkb21haW4ucHVzaChkKTtcbiAgICBkb21haW4uc29ydChhc2NlbmRpbmcpO1xuICAgIHJldHVybiByZXNjYWxlKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFuZ2UgPSBzbGljZS5jYWxsKF8pLCByZXNjYWxlKCkpIDogcmFuZ2Uuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS51bmtub3duID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHVua25vd24gPSBfLCBzY2FsZSkgOiB1bmtub3duO1xuICB9O1xuXG4gIHNjYWxlLnF1YW50aWxlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aHJlc2hvbGRzLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBxdWFudGlsZSgpXG4gICAgICAgIC5kb21haW4oZG9tYWluKVxuICAgICAgICAucmFuZ2UocmFuZ2UpXG4gICAgICAgIC51bmtub3duKHVua25vd24pO1xuICB9O1xuXG4gIHJldHVybiBpbml0UmFuZ2UuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG4iLCJpbXBvcnQge2Jpc2VjdH0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge3NsaWNlfSBmcm9tIFwiLi9hcnJheVwiO1xuaW1wb3J0IHtsaW5lYXJpc2h9IGZyb20gXCIuL2xpbmVhclwiO1xuaW1wb3J0IHtpbml0UmFuZ2V9IGZyb20gXCIuL2luaXRcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcXVhbnRpemUoKSB7XG4gIHZhciB4MCA9IDAsXG4gICAgICB4MSA9IDEsXG4gICAgICBuID0gMSxcbiAgICAgIGRvbWFpbiA9IFswLjVdLFxuICAgICAgcmFuZ2UgPSBbMCwgMV0sXG4gICAgICB1bmtub3duO1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICByZXR1cm4geCA8PSB4ID8gcmFuZ2VbYmlzZWN0KGRvbWFpbiwgeCwgMCwgbildIDogdW5rbm93bjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgdmFyIGkgPSAtMTtcbiAgICBkb21haW4gPSBuZXcgQXJyYXkobik7XG4gICAgd2hpbGUgKCsraSA8IG4pIGRvbWFpbltpXSA9ICgoaSArIDEpICogeDEgLSAoaSAtIG4pICogeDApIC8gKG4gKyAxKTtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH1cblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeDAgPSArX1swXSwgeDEgPSArX1sxXSwgcmVzY2FsZSgpKSA6IFt4MCwgeDFdO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG4gPSAocmFuZ2UgPSBzbGljZS5jYWxsKF8pKS5sZW5ndGggLSAxLCByZXNjYWxlKCkpIDogcmFuZ2Uuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS5pbnZlcnRFeHRlbnQgPSBmdW5jdGlvbih5KSB7XG4gICAgdmFyIGkgPSByYW5nZS5pbmRleE9mKHkpO1xuICAgIHJldHVybiBpIDwgMCA/IFtOYU4sIE5hTl1cbiAgICAgICAgOiBpIDwgMSA/IFt4MCwgZG9tYWluWzBdXVxuICAgICAgICA6IGkgPj0gbiA/IFtkb21haW5bbiAtIDFdLCB4MV1cbiAgICAgICAgOiBbZG9tYWluW2kgLSAxXSwgZG9tYWluW2ldXTtcbiAgfTtcblxuICBzY2FsZS51bmtub3duID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHVua25vd24gPSBfLCBzY2FsZSkgOiBzY2FsZTtcbiAgfTtcblxuICBzY2FsZS50aHJlc2hvbGRzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRvbWFpbi5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcXVhbnRpemUoKVxuICAgICAgICAuZG9tYWluKFt4MCwgeDFdKVxuICAgICAgICAucmFuZ2UocmFuZ2UpXG4gICAgICAgIC51bmtub3duKHVua25vd24pO1xuICB9O1xuXG4gIHJldHVybiBpbml0UmFuZ2UuYXBwbHkobGluZWFyaXNoKHNjYWxlKSwgYXJndW1lbnRzKTtcbn1cbiIsImltcG9ydCB7YmlzZWN0fSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7c2xpY2V9IGZyb20gXCIuL2FycmF5XCI7XG5pbXBvcnQge2luaXRSYW5nZX0gZnJvbSBcIi4vaW5pdFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0aHJlc2hvbGQoKSB7XG4gIHZhciBkb21haW4gPSBbMC41XSxcbiAgICAgIHJhbmdlID0gWzAsIDFdLFxuICAgICAgdW5rbm93bixcbiAgICAgIG4gPSAxO1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICByZXR1cm4geCA8PSB4ID8gcmFuZ2VbYmlzZWN0KGRvbWFpbiwgeCwgMCwgbildIDogdW5rbm93bjtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4gPSBzbGljZS5jYWxsKF8pLCBuID0gTWF0aC5taW4oZG9tYWluLmxlbmd0aCwgcmFuZ2UubGVuZ3RoIC0gMSksIHNjYWxlKSA6IGRvbWFpbi5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmdlID0gc2xpY2UuY2FsbChfKSwgbiA9IE1hdGgubWluKGRvbWFpbi5sZW5ndGgsIHJhbmdlLmxlbmd0aCAtIDEpLCBzY2FsZSkgOiByYW5nZS5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLmludmVydEV4dGVudCA9IGZ1bmN0aW9uKHkpIHtcbiAgICB2YXIgaSA9IHJhbmdlLmluZGV4T2YoeSk7XG4gICAgcmV0dXJuIFtkb21haW5baSAtIDFdLCBkb21haW5baV1dO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aHJlc2hvbGQoKVxuICAgICAgICAuZG9tYWluKGRvbWFpbilcbiAgICAgICAgLnJhbmdlKHJhbmdlKVxuICAgICAgICAudW5rbm93bih1bmtub3duKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdFJhbmdlLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuIiwiaW1wb3J0IHtiaXNlY3RvciwgdGlja1N0ZXB9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHt0aW1lWWVhciwgdGltZU1vbnRoLCB0aW1lV2VlaywgdGltZURheSwgdGltZUhvdXIsIHRpbWVNaW51dGUsIHRpbWVTZWNvbmQsIHRpbWVNaWxsaXNlY29uZH0gZnJvbSBcImQzLXRpbWVcIjtcbmltcG9ydCB7dGltZUZvcm1hdH0gZnJvbSBcImQzLXRpbWUtZm9ybWF0XCI7XG5pbXBvcnQge21hcH0gZnJvbSBcIi4vYXJyYXlcIjtcbmltcG9ydCBjb250aW51b3VzLCB7Y29weSwgaWRlbnRpdHl9IGZyb20gXCIuL2NvbnRpbnVvdXNcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0XCI7XG5pbXBvcnQgbmljZSBmcm9tIFwiLi9uaWNlXCI7XG5cbnZhciBkdXJhdGlvblNlY29uZCA9IDEwMDAsXG4gICAgZHVyYXRpb25NaW51dGUgPSBkdXJhdGlvblNlY29uZCAqIDYwLFxuICAgIGR1cmF0aW9uSG91ciA9IGR1cmF0aW9uTWludXRlICogNjAsXG4gICAgZHVyYXRpb25EYXkgPSBkdXJhdGlvbkhvdXIgKiAyNCxcbiAgICBkdXJhdGlvbldlZWsgPSBkdXJhdGlvbkRheSAqIDcsXG4gICAgZHVyYXRpb25Nb250aCA9IGR1cmF0aW9uRGF5ICogMzAsXG4gICAgZHVyYXRpb25ZZWFyID0gZHVyYXRpb25EYXkgKiAzNjU7XG5cbmZ1bmN0aW9uIGRhdGUodCkge1xuICByZXR1cm4gbmV3IERhdGUodCk7XG59XG5cbmZ1bmN0aW9uIG51bWJlcih0KSB7XG4gIHJldHVybiB0IGluc3RhbmNlb2YgRGF0ZSA/ICt0IDogK25ldyBEYXRlKCt0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGVuZGFyKHllYXIsIG1vbnRoLCB3ZWVrLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgZm9ybWF0KSB7XG4gIHZhciBzY2FsZSA9IGNvbnRpbnVvdXMoaWRlbnRpdHksIGlkZW50aXR5KSxcbiAgICAgIGludmVydCA9IHNjYWxlLmludmVydCxcbiAgICAgIGRvbWFpbiA9IHNjYWxlLmRvbWFpbjtcblxuICB2YXIgZm9ybWF0TWlsbGlzZWNvbmQgPSBmb3JtYXQoXCIuJUxcIiksXG4gICAgICBmb3JtYXRTZWNvbmQgPSBmb3JtYXQoXCI6JVNcIiksXG4gICAgICBmb3JtYXRNaW51dGUgPSBmb3JtYXQoXCIlSTolTVwiKSxcbiAgICAgIGZvcm1hdEhvdXIgPSBmb3JtYXQoXCIlSSAlcFwiKSxcbiAgICAgIGZvcm1hdERheSA9IGZvcm1hdChcIiVhICVkXCIpLFxuICAgICAgZm9ybWF0V2VlayA9IGZvcm1hdChcIiViICVkXCIpLFxuICAgICAgZm9ybWF0TW9udGggPSBmb3JtYXQoXCIlQlwiKSxcbiAgICAgIGZvcm1hdFllYXIgPSBmb3JtYXQoXCIlWVwiKTtcblxuICB2YXIgdGlja0ludGVydmFscyA9IFtcbiAgICBbc2Vjb25kLCAgMSwgICAgICBkdXJhdGlvblNlY29uZF0sXG4gICAgW3NlY29uZCwgIDUsICA1ICogZHVyYXRpb25TZWNvbmRdLFxuICAgIFtzZWNvbmQsIDE1LCAxNSAqIGR1cmF0aW9uU2Vjb25kXSxcbiAgICBbc2Vjb25kLCAzMCwgMzAgKiBkdXJhdGlvblNlY29uZF0sXG4gICAgW21pbnV0ZSwgIDEsICAgICAgZHVyYXRpb25NaW51dGVdLFxuICAgIFttaW51dGUsICA1LCAgNSAqIGR1cmF0aW9uTWludXRlXSxcbiAgICBbbWludXRlLCAxNSwgMTUgKiBkdXJhdGlvbk1pbnV0ZV0sXG4gICAgW21pbnV0ZSwgMzAsIDMwICogZHVyYXRpb25NaW51dGVdLFxuICAgIFsgIGhvdXIsICAxLCAgICAgIGR1cmF0aW9uSG91ciAgXSxcbiAgICBbICBob3VyLCAgMywgIDMgKiBkdXJhdGlvbkhvdXIgIF0sXG4gICAgWyAgaG91ciwgIDYsICA2ICogZHVyYXRpb25Ib3VyICBdLFxuICAgIFsgIGhvdXIsIDEyLCAxMiAqIGR1cmF0aW9uSG91ciAgXSxcbiAgICBbICAgZGF5LCAgMSwgICAgICBkdXJhdGlvbkRheSAgIF0sXG4gICAgWyAgIGRheSwgIDIsICAyICogZHVyYXRpb25EYXkgICBdLFxuICAgIFsgIHdlZWssICAxLCAgICAgIGR1cmF0aW9uV2VlayAgXSxcbiAgICBbIG1vbnRoLCAgMSwgICAgICBkdXJhdGlvbk1vbnRoIF0sXG4gICAgWyBtb250aCwgIDMsICAzICogZHVyYXRpb25Nb250aCBdLFxuICAgIFsgIHllYXIsICAxLCAgICAgIGR1cmF0aW9uWWVhciAgXVxuICBdO1xuXG4gIGZ1bmN0aW9uIHRpY2tGb3JtYXQoZGF0ZSkge1xuICAgIHJldHVybiAoc2Vjb25kKGRhdGUpIDwgZGF0ZSA/IGZvcm1hdE1pbGxpc2Vjb25kXG4gICAgICAgIDogbWludXRlKGRhdGUpIDwgZGF0ZSA/IGZvcm1hdFNlY29uZFxuICAgICAgICA6IGhvdXIoZGF0ZSkgPCBkYXRlID8gZm9ybWF0TWludXRlXG4gICAgICAgIDogZGF5KGRhdGUpIDwgZGF0ZSA/IGZvcm1hdEhvdXJcbiAgICAgICAgOiBtb250aChkYXRlKSA8IGRhdGUgPyAod2VlayhkYXRlKSA8IGRhdGUgPyBmb3JtYXREYXkgOiBmb3JtYXRXZWVrKVxuICAgICAgICA6IHllYXIoZGF0ZSkgPCBkYXRlID8gZm9ybWF0TW9udGhcbiAgICAgICAgOiBmb3JtYXRZZWFyKShkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRpY2tJbnRlcnZhbChpbnRlcnZhbCwgc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICBpZiAoaW50ZXJ2YWwgPT0gbnVsbCkgaW50ZXJ2YWwgPSAxMDtcblxuICAgIC8vIElmIGEgZGVzaXJlZCB0aWNrIGNvdW50IGlzIHNwZWNpZmllZCwgcGljayBhIHJlYXNvbmFibGUgdGljayBpbnRlcnZhbFxuICAgIC8vIGJhc2VkIG9uIHRoZSBleHRlbnQgb2YgdGhlIGRvbWFpbiBhbmQgYSByb3VnaCBlc3RpbWF0ZSBvZiB0aWNrIHNpemUuXG4gICAgLy8gT3RoZXJ3aXNlLCBhc3N1bWUgaW50ZXJ2YWwgaXMgYWxyZWFkeSBhIHRpbWUgaW50ZXJ2YWwgYW5kIHVzZSBpdC5cbiAgICBpZiAodHlwZW9mIGludGVydmFsID09PSBcIm51bWJlclwiKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gTWF0aC5hYnMoc3RvcCAtIHN0YXJ0KSAvIGludGVydmFsLFxuICAgICAgICAgIGkgPSBiaXNlY3RvcihmdW5jdGlvbihpKSB7IHJldHVybiBpWzJdOyB9KS5yaWdodCh0aWNrSW50ZXJ2YWxzLCB0YXJnZXQpO1xuICAgICAgaWYgKGkgPT09IHRpY2tJbnRlcnZhbHMubGVuZ3RoKSB7XG4gICAgICAgIHN0ZXAgPSB0aWNrU3RlcChzdGFydCAvIGR1cmF0aW9uWWVhciwgc3RvcCAvIGR1cmF0aW9uWWVhciwgaW50ZXJ2YWwpO1xuICAgICAgICBpbnRlcnZhbCA9IHllYXI7XG4gICAgICB9IGVsc2UgaWYgKGkpIHtcbiAgICAgICAgaSA9IHRpY2tJbnRlcnZhbHNbdGFyZ2V0IC8gdGlja0ludGVydmFsc1tpIC0gMV1bMl0gPCB0aWNrSW50ZXJ2YWxzW2ldWzJdIC8gdGFyZ2V0ID8gaSAtIDEgOiBpXTtcbiAgICAgICAgc3RlcCA9IGlbMV07XG4gICAgICAgIGludGVydmFsID0gaVswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ZXAgPSBNYXRoLm1heCh0aWNrU3RlcChzdGFydCwgc3RvcCwgaW50ZXJ2YWwpLCAxKTtcbiAgICAgICAgaW50ZXJ2YWwgPSBtaWxsaXNlY29uZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3RlcCA9PSBudWxsID8gaW50ZXJ2YWwgOiBpbnRlcnZhbC5ldmVyeShzdGVwKTtcbiAgfVxuXG4gIHNjYWxlLmludmVydCA9IGZ1bmN0aW9uKHkpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoaW52ZXJ0KHkpKTtcbiAgfTtcblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBkb21haW4obWFwLmNhbGwoXywgbnVtYmVyKSkgOiBkb21haW4oKS5tYXAoZGF0ZSk7XG4gIH07XG5cbiAgc2NhbGUudGlja3MgPSBmdW5jdGlvbihpbnRlcnZhbCwgc3RlcCkge1xuICAgIHZhciBkID0gZG9tYWluKCksXG4gICAgICAgIHQwID0gZFswXSxcbiAgICAgICAgdDEgPSBkW2QubGVuZ3RoIC0gMV0sXG4gICAgICAgIHIgPSB0MSA8IHQwLFxuICAgICAgICB0O1xuICAgIGlmIChyKSB0ID0gdDAsIHQwID0gdDEsIHQxID0gdDtcbiAgICB0ID0gdGlja0ludGVydmFsKGludGVydmFsLCB0MCwgdDEsIHN0ZXApO1xuICAgIHQgPSB0ID8gdC5yYW5nZSh0MCwgdDEgKyAxKSA6IFtdOyAvLyBpbmNsdXNpdmUgc3RvcFxuICAgIHJldHVybiByID8gdC5yZXZlcnNlKCkgOiB0O1xuICB9O1xuXG4gIHNjYWxlLnRpY2tGb3JtYXQgPSBmdW5jdGlvbihjb3VudCwgc3BlY2lmaWVyKSB7XG4gICAgcmV0dXJuIHNwZWNpZmllciA9PSBudWxsID8gdGlja0Zvcm1hdCA6IGZvcm1hdChzcGVjaWZpZXIpO1xuICB9O1xuXG4gIHNjYWxlLm5pY2UgPSBmdW5jdGlvbihpbnRlcnZhbCwgc3RlcCkge1xuICAgIHZhciBkID0gZG9tYWluKCk7XG4gICAgcmV0dXJuIChpbnRlcnZhbCA9IHRpY2tJbnRlcnZhbChpbnRlcnZhbCwgZFswXSwgZFtkLmxlbmd0aCAtIDFdLCBzdGVwKSlcbiAgICAgICAgPyBkb21haW4obmljZShkLCBpbnRlcnZhbCkpXG4gICAgICAgIDogc2NhbGU7XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBjYWxlbmRhcih5ZWFyLCBtb250aCwgd2VlaywgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIGZvcm1hdCkpO1xuICB9O1xuXG4gIHJldHVybiBzY2FsZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBpbml0UmFuZ2UuYXBwbHkoY2FsZW5kYXIodGltZVllYXIsIHRpbWVNb250aCwgdGltZVdlZWssIHRpbWVEYXksIHRpbWVIb3VyLCB0aW1lTWludXRlLCB0aW1lU2Vjb25kLCB0aW1lTWlsbGlzZWNvbmQsIHRpbWVGb3JtYXQpLmRvbWFpbihbbmV3IERhdGUoMjAwMCwgMCwgMSksIG5ldyBEYXRlKDIwMDAsIDAsIDIpXSksIGFyZ3VtZW50cyk7XG59XG4iLCJpbXBvcnQge2NhbGVuZGFyfSBmcm9tIFwiLi90aW1lXCI7XG5pbXBvcnQge3V0Y0Zvcm1hdH0gZnJvbSBcImQzLXRpbWUtZm9ybWF0XCI7XG5pbXBvcnQge3V0Y1llYXIsIHV0Y01vbnRoLCB1dGNXZWVrLCB1dGNEYXksIHV0Y0hvdXIsIHV0Y01pbnV0ZSwgdXRjU2Vjb25kLCB1dGNNaWxsaXNlY29uZH0gZnJvbSBcImQzLXRpbWVcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gaW5pdFJhbmdlLmFwcGx5KGNhbGVuZGFyKHV0Y1llYXIsIHV0Y01vbnRoLCB1dGNXZWVrLCB1dGNEYXksIHV0Y0hvdXIsIHV0Y01pbnV0ZSwgdXRjU2Vjb25kLCB1dGNNaWxsaXNlY29uZCwgdXRjRm9ybWF0KS5kb21haW4oW0RhdGUuVVRDKDIwMDAsIDAsIDEpLCBEYXRlLlVUQygyMDAwLCAwLCAyKV0pLCBhcmd1bWVudHMpO1xufVxuIiwiaW1wb3J0IHtpZGVudGl0eX0gZnJvbSBcIi4vY29udGludW91c1wiO1xuaW1wb3J0IHtpbml0SW50ZXJwb2xhdG9yfSBmcm9tIFwiLi9pbml0XCI7XG5pbXBvcnQge2xpbmVhcmlzaH0gZnJvbSBcIi4vbGluZWFyXCI7XG5pbXBvcnQge2xvZ2dpc2h9IGZyb20gXCIuL2xvZ1wiO1xuaW1wb3J0IHtzeW1sb2dpc2h9IGZyb20gXCIuL3N5bWxvZ1wiO1xuaW1wb3J0IHtwb3dpc2h9IGZyb20gXCIuL3Bvd1wiO1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1lcigpIHtcbiAgdmFyIHgwID0gMCxcbiAgICAgIHgxID0gMSxcbiAgICAgIHQwLFxuICAgICAgdDEsXG4gICAgICBrMTAsXG4gICAgICB0cmFuc2Zvcm0sXG4gICAgICBpbnRlcnBvbGF0b3IgPSBpZGVudGl0eSxcbiAgICAgIGNsYW1wID0gZmFsc2UsXG4gICAgICB1bmtub3duO1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICByZXR1cm4gaXNOYU4oeCA9ICt4KSA/IHVua25vd24gOiBpbnRlcnBvbGF0b3IoazEwID09PSAwID8gMC41IDogKHggPSAodHJhbnNmb3JtKHgpIC0gdDApICogazEwLCBjbGFtcCA/IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHgpKSA6IHgpKTtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0MCA9IHRyYW5zZm9ybSh4MCA9ICtfWzBdKSwgdDEgPSB0cmFuc2Zvcm0oeDEgPSArX1sxXSksIGsxMCA9IHQwID09PSB0MSA/IDAgOiAxIC8gKHQxIC0gdDApLCBzY2FsZSkgOiBbeDAsIHgxXTtcbiAgfTtcblxuICBzY2FsZS5jbGFtcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjbGFtcCA9ICEhXywgc2NhbGUpIDogY2xhbXA7XG4gIH07XG5cbiAgc2NhbGUuaW50ZXJwb2xhdG9yID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGludGVycG9sYXRvciA9IF8sIHNjYWxlKSA6IGludGVycG9sYXRvcjtcbiAgfTtcblxuICBzY2FsZS51bmtub3duID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHVua25vd24gPSBfLCBzY2FsZSkgOiB1bmtub3duO1xuICB9O1xuXG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdHJhbnNmb3JtID0gdCwgdDAgPSB0KHgwKSwgdDEgPSB0KHgxKSwgazEwID0gdDAgPT09IHQxID8gMCA6IDEgLyAodDEgLSB0MCk7XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29weShzb3VyY2UsIHRhcmdldCkge1xuICByZXR1cm4gdGFyZ2V0XG4gICAgICAuZG9tYWluKHNvdXJjZS5kb21haW4oKSlcbiAgICAgIC5pbnRlcnBvbGF0b3Ioc291cmNlLmludGVycG9sYXRvcigpKVxuICAgICAgLmNsYW1wKHNvdXJjZS5jbGFtcCgpKVxuICAgICAgLnVua25vd24oc291cmNlLnVua25vd24oKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNlcXVlbnRpYWwoKSB7XG4gIHZhciBzY2FsZSA9IGxpbmVhcmlzaCh0cmFuc2Zvcm1lcigpKGlkZW50aXR5KSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBzZXF1ZW50aWFsKCkpO1xuICB9O1xuXG4gIHJldHVybiBpbml0SW50ZXJwb2xhdG9yLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VxdWVudGlhbExvZygpIHtcbiAgdmFyIHNjYWxlID0gbG9nZ2lzaCh0cmFuc2Zvcm1lcigpKS5kb21haW4oWzEsIDEwXSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBzZXF1ZW50aWFsTG9nKCkpLmJhc2Uoc2NhbGUuYmFzZSgpKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdEludGVycG9sYXRvci5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlcXVlbnRpYWxTeW1sb2coKSB7XG4gIHZhciBzY2FsZSA9IHN5bWxvZ2lzaCh0cmFuc2Zvcm1lcigpKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIHNlcXVlbnRpYWxTeW1sb2coKSkuY29uc3RhbnQoc2NhbGUuY29uc3RhbnQoKSk7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRJbnRlcnBvbGF0b3IuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXF1ZW50aWFsUG93KCkge1xuICB2YXIgc2NhbGUgPSBwb3dpc2godHJhbnNmb3JtZXIoKSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBzZXF1ZW50aWFsUG93KCkpLmV4cG9uZW50KHNjYWxlLmV4cG9uZW50KCkpO1xuICB9O1xuXG4gIHJldHVybiBpbml0SW50ZXJwb2xhdG9yLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VxdWVudGlhbFNxcnQoKSB7XG4gIHJldHVybiBzZXF1ZW50aWFsUG93LmFwcGx5KG51bGwsIGFyZ3VtZW50cykuZXhwb25lbnQoMC41KTtcbn1cbiIsImltcG9ydCB7YXNjZW5kaW5nLCBiaXNlY3R9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHtpZGVudGl0eX0gZnJvbSBcIi4vY29udGludW91c1wiO1xuaW1wb3J0IHtpbml0SW50ZXJwb2xhdG9yfSBmcm9tIFwiLi9pbml0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNlcXVlbnRpYWxRdWFudGlsZSgpIHtcbiAgdmFyIGRvbWFpbiA9IFtdLFxuICAgICAgaW50ZXJwb2xhdG9yID0gaWRlbnRpdHk7XG5cbiAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgIGlmICghaXNOYU4oeCA9ICt4KSkgcmV0dXJuIGludGVycG9sYXRvcigoYmlzZWN0KGRvbWFpbiwgeCkgLSAxKSAvIChkb21haW4ubGVuZ3RoIC0gMSkpO1xuICB9XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbi5zbGljZSgpO1xuICAgIGRvbWFpbiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gXy5sZW5ndGgsIGQ7IGkgPCBuOyArK2kpIGlmIChkID0gX1tpXSwgZCAhPSBudWxsICYmICFpc05hTihkID0gK2QpKSBkb21haW4ucHVzaChkKTtcbiAgICBkb21haW4uc29ydChhc2NlbmRpbmcpO1xuICAgIHJldHVybiBzY2FsZTtcbiAgfTtcblxuICBzY2FsZS5pbnRlcnBvbGF0b3IgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaW50ZXJwb2xhdG9yID0gXywgc2NhbGUpIDogaW50ZXJwb2xhdG9yO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2VxdWVudGlhbFF1YW50aWxlKGludGVycG9sYXRvcikuZG9tYWluKGRvbWFpbik7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRJbnRlcnBvbGF0b3IuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG4iLCJpbXBvcnQge2lkZW50aXR5fSBmcm9tIFwiLi9jb250aW51b3VzXCI7XG5pbXBvcnQge2luaXRJbnRlcnBvbGF0b3J9IGZyb20gXCIuL2luaXRcIjtcbmltcG9ydCB7bGluZWFyaXNofSBmcm9tIFwiLi9saW5lYXJcIjtcbmltcG9ydCB7bG9nZ2lzaH0gZnJvbSBcIi4vbG9nXCI7XG5pbXBvcnQge2NvcHl9IGZyb20gXCIuL3NlcXVlbnRpYWxcIjtcbmltcG9ydCB7c3ltbG9naXNofSBmcm9tIFwiLi9zeW1sb2dcIjtcbmltcG9ydCB7cG93aXNofSBmcm9tIFwiLi9wb3dcIjtcblxuZnVuY3Rpb24gdHJhbnNmb3JtZXIoKSB7XG4gIHZhciB4MCA9IDAsXG4gICAgICB4MSA9IDAuNSxcbiAgICAgIHgyID0gMSxcbiAgICAgIHQwLFxuICAgICAgdDEsXG4gICAgICB0MixcbiAgICAgIGsxMCxcbiAgICAgIGsyMSxcbiAgICAgIGludGVycG9sYXRvciA9IGlkZW50aXR5LFxuICAgICAgdHJhbnNmb3JtLFxuICAgICAgY2xhbXAgPSBmYWxzZSxcbiAgICAgIHVua25vd247XG5cbiAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgIHJldHVybiBpc05hTih4ID0gK3gpID8gdW5rbm93biA6ICh4ID0gMC41ICsgKCh4ID0gK3RyYW5zZm9ybSh4KSkgLSB0MSkgKiAoeCA8IHQxID8gazEwIDogazIxKSwgaW50ZXJwb2xhdG9yKGNsYW1wID8gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgeCkpIDogeCkpO1xuICB9XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHQwID0gdHJhbnNmb3JtKHgwID0gK19bMF0pLCB0MSA9IHRyYW5zZm9ybSh4MSA9ICtfWzFdKSwgdDIgPSB0cmFuc2Zvcm0oeDIgPSArX1syXSksIGsxMCA9IHQwID09PSB0MSA/IDAgOiAwLjUgLyAodDEgLSB0MCksIGsyMSA9IHQxID09PSB0MiA/IDAgOiAwLjUgLyAodDIgLSB0MSksIHNjYWxlKSA6IFt4MCwgeDEsIHgyXTtcbiAgfTtcblxuICBzY2FsZS5jbGFtcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjbGFtcCA9ICEhXywgc2NhbGUpIDogY2xhbXA7XG4gIH07XG5cbiAgc2NhbGUuaW50ZXJwb2xhdG9yID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGludGVycG9sYXRvciA9IF8sIHNjYWxlKSA6IGludGVycG9sYXRvcjtcbiAgfTtcblxuICBzY2FsZS51bmtub3duID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHVua25vd24gPSBfLCBzY2FsZSkgOiB1bmtub3duO1xuICB9O1xuXG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdHJhbnNmb3JtID0gdCwgdDAgPSB0KHgwKSwgdDEgPSB0KHgxKSwgdDIgPSB0KHgyKSwgazEwID0gdDAgPT09IHQxID8gMCA6IDAuNSAvICh0MSAtIHQwKSwgazIxID0gdDEgPT09IHQyID8gMCA6IDAuNSAvICh0MiAtIHQxKTtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRpdmVyZ2luZygpIHtcbiAgdmFyIHNjYWxlID0gbGluZWFyaXNoKHRyYW5zZm9ybWVyKCkoaWRlbnRpdHkpKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIGRpdmVyZ2luZygpKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdEludGVycG9sYXRvci5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpdmVyZ2luZ0xvZygpIHtcbiAgdmFyIHNjYWxlID0gbG9nZ2lzaCh0cmFuc2Zvcm1lcigpKS5kb21haW4oWzAuMSwgMSwgMTBdKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIGRpdmVyZ2luZ0xvZygpKS5iYXNlKHNjYWxlLmJhc2UoKSk7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRJbnRlcnBvbGF0b3IuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXZlcmdpbmdTeW1sb2coKSB7XG4gIHZhciBzY2FsZSA9IHN5bWxvZ2lzaCh0cmFuc2Zvcm1lcigpKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIGRpdmVyZ2luZ1N5bWxvZygpKS5jb25zdGFudChzY2FsZS5jb25zdGFudCgpKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdEludGVycG9sYXRvci5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpdmVyZ2luZ1BvdygpIHtcbiAgdmFyIHNjYWxlID0gcG93aXNoKHRyYW5zZm9ybWVyKCkpO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgZGl2ZXJnaW5nUG93KCkpLmV4cG9uZW50KHNjYWxlLmV4cG9uZW50KCkpO1xuICB9O1xuXG4gIHJldHVybiBpbml0SW50ZXJwb2xhdG9yLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGl2ZXJnaW5nU3FydCgpIHtcbiAgcmV0dXJuIGRpdmVyZ2luZ1Bvdy5hcHBseShudWxsLCBhcmd1bWVudHMpLmV4cG9uZW50KDAuNSk7XG59XG4iLCJleHBvcnQge1xuICBkZWZhdWx0IGFzIHNjYWxlQmFuZCxcbiAgcG9pbnQgYXMgc2NhbGVQb2ludFxufSBmcm9tIFwiLi9iYW5kXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgc2NhbGVJZGVudGl0eVxufSBmcm9tIFwiLi9pZGVudGl0eVwiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIHNjYWxlTGluZWFyXG59IGZyb20gXCIuL2xpbmVhclwiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIHNjYWxlTG9nXG59IGZyb20gXCIuL2xvZ1wiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIHNjYWxlU3ltbG9nXG59IGZyb20gXCIuL3N5bWxvZ1wiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIHNjYWxlT3JkaW5hbCxcbiAgaW1wbGljaXQgYXMgc2NhbGVJbXBsaWNpdFxufSBmcm9tIFwiLi9vcmRpbmFsXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgc2NhbGVQb3csXG4gIHNxcnQgYXMgc2NhbGVTcXJ0XG59IGZyb20gXCIuL3Bvd1wiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIHNjYWxlUXVhbnRpbGVcbn0gZnJvbSBcIi4vcXVhbnRpbGVcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyBzY2FsZVF1YW50aXplXG59IGZyb20gXCIuL3F1YW50aXplXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgc2NhbGVUaHJlc2hvbGRcbn0gZnJvbSBcIi4vdGhyZXNob2xkXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgc2NhbGVUaW1lXG59IGZyb20gXCIuL3RpbWVcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyBzY2FsZVV0Y1xufSBmcm9tIFwiLi91dGNUaW1lXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgc2NhbGVTZXF1ZW50aWFsLFxuICBzZXF1ZW50aWFsTG9nIGFzIHNjYWxlU2VxdWVudGlhbExvZyxcbiAgc2VxdWVudGlhbFBvdyBhcyBzY2FsZVNlcXVlbnRpYWxQb3csXG4gIHNlcXVlbnRpYWxTcXJ0IGFzIHNjYWxlU2VxdWVudGlhbFNxcnQsXG4gIHNlcXVlbnRpYWxTeW1sb2cgYXMgc2NhbGVTZXF1ZW50aWFsU3ltbG9nXG59IGZyb20gXCIuL3NlcXVlbnRpYWxcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyBzY2FsZVNlcXVlbnRpYWxRdWFudGlsZVxufSBmcm9tIFwiLi9zZXF1ZW50aWFsUXVhbnRpbGVcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyBzY2FsZURpdmVyZ2luZyxcbiAgZGl2ZXJnaW5nTG9nIGFzIHNjYWxlRGl2ZXJnaW5nTG9nLFxuICBkaXZlcmdpbmdQb3cgYXMgc2NhbGVEaXZlcmdpbmdQb3csXG4gIGRpdmVyZ2luZ1NxcnQgYXMgc2NhbGVEaXZlcmdpbmdTcXJ0LFxuICBkaXZlcmdpbmdTeW1sb2cgYXMgc2NhbGVEaXZlcmdpbmdTeW1sb2dcbn0gZnJvbSBcIi4vZGl2ZXJnaW5nXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgdGlja0Zvcm1hdFxufSBmcm9tIFwiLi90aWNrRm9ybWF0XCI7XG4iLCJpbXBvcnQgeyBzY2FsZUJhbmQsIHNjYWxlUG9pbnQsIHNjYWxlTGluZWFyLCBzY2FsZVRpbWUsIHNjYWxlVXRjLCBzY2FsZUxvZywgc2NhbGVQb3csIHNjYWxlT3JkaW5hbCwgc2NhbGVRdWFudGl6ZSwgc2NhbGVRdWFudGlsZSwgc2NhbGVUaHJlc2hvbGQgfSBmcm9tICdkMy1zY2FsZSc7XG5cbnZhciBiYW5kID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciByYW5nZSA9IF9yZWYucmFuZ2UsXG4gICAgICByYW5nZVJvdW5kID0gX3JlZi5yYW5nZVJvdW5kLFxuICAgICAgZG9tYWluID0gX3JlZi5kb21haW4sXG4gICAgICBwYWRkaW5nID0gX3JlZi5wYWRkaW5nLFxuICAgICAgcGFkZGluZ0lubmVyID0gX3JlZi5wYWRkaW5nSW5uZXIsXG4gICAgICBwYWRkaW5nT3V0ZXIgPSBfcmVmLnBhZGRpbmdPdXRlcixcbiAgICAgIGFsaWduID0gX3JlZi5hbGlnbixcbiAgICAgIHRpY2tGb3JtYXQgPSBfcmVmLnRpY2tGb3JtYXQ7XG5cbiAgdmFyIHNjYWxlID0gc2NhbGVCYW5kKCk7XG4gIHNjYWxlLnR5cGUgPSAnYmFuZCc7XG5cbiAgaWYgKHJhbmdlKSBzY2FsZS5yYW5nZShyYW5nZSk7XG4gIGlmIChyYW5nZVJvdW5kKSBzY2FsZS5yYW5nZVJvdW5kKHJhbmdlUm91bmQpO1xuICBpZiAoZG9tYWluKSBzY2FsZS5kb21haW4oZG9tYWluKTtcbiAgaWYgKHBhZGRpbmcpIHNjYWxlLnBhZGRpbmcocGFkZGluZyk7XG4gIGlmIChwYWRkaW5nSW5uZXIpIHNjYWxlLnBhZGRpbmdJbm5lcihwYWRkaW5nSW5uZXIpO1xuICBpZiAocGFkZGluZ091dGVyKSBzY2FsZS5wYWRkaW5nT3V0ZXIocGFkZGluZ091dGVyKTtcbiAgaWYgKGFsaWduKSBzY2FsZS5hbGlnbihhbGlnbik7XG4gIGlmICh0aWNrRm9ybWF0KSBzY2FsZS50aWNrRm9ybWF0ID0gdGlja0Zvcm1hdDtcblxuICByZXR1cm4gc2NhbGU7XG59KTtcblxudmFyIHBvaW50ID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciByYW5nZSA9IF9yZWYucmFuZ2UsXG4gICAgICByYW5nZVJvdW5kID0gX3JlZi5yYW5nZVJvdW5kLFxuICAgICAgZG9tYWluID0gX3JlZi5kb21haW4sXG4gICAgICBwYWRkaW5nID0gX3JlZi5wYWRkaW5nLFxuICAgICAgYWxpZ24gPSBfcmVmLmFsaWduLFxuICAgICAgX3JlZiRuaWNlID0gX3JlZi5uaWNlLFxuICAgICAgbmljZSA9IF9yZWYkbmljZSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJG5pY2U7XG5cbiAgdmFyIHNjYWxlID0gc2NhbGVQb2ludCgpO1xuICBzY2FsZS50eXBlID0gJ3BvaW50JztcblxuICBpZiAocmFuZ2UpIHNjYWxlLnJhbmdlKHJhbmdlKTtcbiAgaWYgKHJhbmdlUm91bmQpIHNjYWxlLnJhbmdlUm91bmQocmFuZ2VSb3VuZCk7XG4gIGlmIChkb21haW4pIHNjYWxlLmRvbWFpbihkb21haW4pO1xuICBpZiAobmljZSkgc2NhbGUubmljZSgpO1xuICBpZiAocGFkZGluZykgc2NhbGUucGFkZGluZyhwYWRkaW5nKTtcbiAgaWYgKGFsaWduKSBzY2FsZS5hbGlnbihhbGlnbik7XG5cbiAgcmV0dXJuIHNjYWxlO1xufSk7XG5cbnZhciBsaW5lYXIgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHJhbmdlID0gX3JlZi5yYW5nZSxcbiAgICAgIHJhbmdlUm91bmQgPSBfcmVmLnJhbmdlUm91bmQsXG4gICAgICBkb21haW4gPSBfcmVmLmRvbWFpbixcbiAgICAgIF9yZWYkbmljZSA9IF9yZWYubmljZSxcbiAgICAgIG5pY2UgPSBfcmVmJG5pY2UgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiRuaWNlLFxuICAgICAgX3JlZiRjbGFtcCA9IF9yZWYuY2xhbXAsXG4gICAgICBjbGFtcCA9IF9yZWYkY2xhbXAgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiRjbGFtcDtcblxuICB2YXIgc2NhbGUgPSBzY2FsZUxpbmVhcigpO1xuICBzY2FsZS50eXBlID0gJ2xpbmVhcic7XG5cbiAgaWYgKHJhbmdlKSBzY2FsZS5yYW5nZShyYW5nZSk7XG4gIGlmIChyYW5nZVJvdW5kKSBzY2FsZS5yYW5nZVJvdW5kKHJhbmdlUm91bmQpO1xuICBpZiAoZG9tYWluKSBzY2FsZS5kb21haW4oZG9tYWluKTtcbiAgaWYgKG5pY2UpIHNjYWxlLm5pY2UoKTtcbiAgaWYgKGNsYW1wKSBzY2FsZS5jbGFtcCh0cnVlKTtcblxuICByZXR1cm4gc2NhbGU7XG59KTtcblxudmFyIHRpbWUgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHJhbmdlID0gX3JlZi5yYW5nZSxcbiAgICAgIHJhbmdlUm91bmQgPSBfcmVmLnJhbmdlUm91bmQsXG4gICAgICBkb21haW4gPSBfcmVmLmRvbWFpbixcbiAgICAgIF9yZWYkbmljZSA9IF9yZWYubmljZSxcbiAgICAgIG5pY2UgPSBfcmVmJG5pY2UgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiRuaWNlLFxuICAgICAgX3JlZiRjbGFtcCA9IF9yZWYuY2xhbXAsXG4gICAgICBjbGFtcCA9IF9yZWYkY2xhbXAgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiRjbGFtcDtcblxuICB2YXIgc2NhbGUgPSBzY2FsZVRpbWUoKTtcbiAgc2NhbGUudHlwZSA9ICd0aW1lJztcblxuICBpZiAocmFuZ2UpIHNjYWxlLnJhbmdlKHJhbmdlKTtcbiAgaWYgKHJhbmdlUm91bmQpIHNjYWxlLnJhbmdlUm91bmQocmFuZ2VSb3VuZCk7XG4gIGlmIChkb21haW4pIHNjYWxlLmRvbWFpbihkb21haW4pO1xuICBpZiAobmljZSkgc2NhbGUubmljZSgpO1xuICBpZiAoY2xhbXApIHNjYWxlLmNsYW1wKHRydWUpO1xuXG4gIHJldHVybiBzY2FsZTtcbn0pO1xuXG52YXIgdXRjID0gKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciByYW5nZSA9IF9yZWYucmFuZ2UsXG4gICAgICByYW5nZVJvdW5kID0gX3JlZi5yYW5nZVJvdW5kLFxuICAgICAgZG9tYWluID0gX3JlZi5kb21haW4sXG4gICAgICBfcmVmJG5pY2UgPSBfcmVmLm5pY2UsXG4gICAgICBuaWNlID0gX3JlZiRuaWNlID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkbmljZSxcbiAgICAgIF9yZWYkY2xhbXAgPSBfcmVmLmNsYW1wLFxuICAgICAgY2xhbXAgPSBfcmVmJGNsYW1wID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkY2xhbXA7XG5cbiAgdmFyIHNjYWxlID0gc2NhbGVVdGMoKTtcbiAgc2NhbGUudHlwZSA9ICd1dGMnO1xuXG4gIGlmIChyYW5nZSkgc2NhbGUucmFuZ2UocmFuZ2UpO1xuICBpZiAocmFuZ2VSb3VuZCkgc2NhbGUucmFuZ2VSb3VuZChyYW5nZVJvdW5kKTtcbiAgaWYgKGRvbWFpbikgc2NhbGUuZG9tYWluKGRvbWFpbik7XG4gIGlmIChuaWNlKSBzY2FsZS5uaWNlKCk7XG4gIGlmIChjbGFtcCkgc2NhbGUuY2xhbXAodHJ1ZSk7XG5cbiAgcmV0dXJuIHNjYWxlO1xufSk7XG5cbnZhciBsb2cgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHJhbmdlID0gX3JlZi5yYW5nZSxcbiAgICAgIHJhbmdlUm91bmQgPSBfcmVmLnJhbmdlUm91bmQsXG4gICAgICBkb21haW4gPSBfcmVmLmRvbWFpbixcbiAgICAgIGJhc2UgPSBfcmVmLmJhc2UsXG4gICAgICBfcmVmJG5pY2UgPSBfcmVmLm5pY2UsXG4gICAgICBuaWNlID0gX3JlZiRuaWNlID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkbmljZSxcbiAgICAgIF9yZWYkY2xhbXAgPSBfcmVmLmNsYW1wLFxuICAgICAgY2xhbXAgPSBfcmVmJGNsYW1wID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkY2xhbXA7XG5cbiAgdmFyIHNjYWxlID0gc2NhbGVMb2coKTtcbiAgc2NhbGUudHlwZSA9ICdsb2cnO1xuXG4gIGlmIChyYW5nZSkgc2NhbGUucmFuZ2UocmFuZ2UpO1xuICBpZiAocmFuZ2VSb3VuZCkgc2NhbGUucmFuZ2VSb3VuZChyYW5nZVJvdW5kKTtcbiAgaWYgKGRvbWFpbikgc2NhbGUuZG9tYWluKGRvbWFpbik7XG4gIGlmIChuaWNlKSBzY2FsZS5uaWNlKCk7XG4gIGlmIChjbGFtcCkgc2NhbGUuY2xhbXAodHJ1ZSk7XG4gIGlmIChiYXNlKSBzY2FsZS5iYXNlKGJhc2UpO1xuXG4gIHJldHVybiBzY2FsZTtcbn0pO1xuXG52YXIgcG93ZXIgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHJhbmdlID0gX3JlZi5yYW5nZSxcbiAgICAgIHJhbmdlUm91bmQgPSBfcmVmLnJhbmdlUm91bmQsXG4gICAgICBkb21haW4gPSBfcmVmLmRvbWFpbixcbiAgICAgIGV4cG9uZW50ID0gX3JlZi5leHBvbmVudCxcbiAgICAgIF9yZWYkbmljZSA9IF9yZWYubmljZSxcbiAgICAgIG5pY2UgPSBfcmVmJG5pY2UgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiRuaWNlLFxuICAgICAgX3JlZiRjbGFtcCA9IF9yZWYuY2xhbXAsXG4gICAgICBjbGFtcCA9IF9yZWYkY2xhbXAgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiRjbGFtcDtcblxuICB2YXIgc2NhbGUgPSBzY2FsZVBvdygpO1xuICBzY2FsZS50eXBlID0gJ3Bvd2VyJztcblxuICBpZiAocmFuZ2UpIHNjYWxlLnJhbmdlKHJhbmdlKTtcbiAgaWYgKHJhbmdlUm91bmQpIHNjYWxlLnJhbmdlUm91bmQocmFuZ2VSb3VuZCk7XG4gIGlmIChkb21haW4pIHNjYWxlLmRvbWFpbihkb21haW4pO1xuICBpZiAobmljZSkgc2NhbGUubmljZSgpO1xuICBpZiAoY2xhbXApIHNjYWxlLmNsYW1wKHRydWUpO1xuICBpZiAoZXhwb25lbnQpIHNjYWxlLmV4cG9uZW50KGV4cG9uZW50KTtcblxuICByZXR1cm4gc2NhbGU7XG59KTtcblxudmFyIG9yZGluYWwgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHJhbmdlID0gX3JlZi5yYW5nZSxcbiAgICAgIGRvbWFpbiA9IF9yZWYuZG9tYWluLFxuICAgICAgdW5rbm93biA9IF9yZWYudW5rbm93bjtcblxuICB2YXIgc2NhbGUgPSBzY2FsZU9yZGluYWwoKTtcbiAgc2NhbGUudHlwZSA9ICdvcmRpbmFsJztcblxuICBpZiAocmFuZ2UpIHNjYWxlLnJhbmdlKHJhbmdlKTtcbiAgaWYgKGRvbWFpbikgc2NhbGUuZG9tYWluKGRvbWFpbik7XG4gIGlmICh1bmtub3duKSBzY2FsZS51bmtub3duKHVua25vd24pO1xuXG4gIHJldHVybiBzY2FsZTtcbn0pO1xuXG52YXIgcXVhbnRpemUgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHJhbmdlID0gX3JlZi5yYW5nZSxcbiAgICAgIGRvbWFpbiA9IF9yZWYuZG9tYWluLFxuICAgICAgdGlja3MgPSBfcmVmLnRpY2tzLFxuICAgICAgdGlja0Zvcm1hdCA9IF9yZWYudGlja0Zvcm1hdCxcbiAgICAgIF9yZWYkbmljZSA9IF9yZWYubmljZSxcbiAgICAgIG5pY2UgPSBfcmVmJG5pY2UgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiRuaWNlO1xuXG4gIHZhciBzY2FsZSA9IHNjYWxlUXVhbnRpemUoKTtcbiAgc2NhbGUudHlwZSA9ICdxdWFudGl6ZSc7XG5cbiAgaWYgKHJhbmdlKSBzY2FsZS5yYW5nZShyYW5nZSk7XG4gIGlmIChkb21haW4pIHNjYWxlLmRvbWFpbihkb21haW4pO1xuICBpZiAobmljZSkgc2NhbGUubmljZSgpO1xuICBpZiAodGlja3MpIHNjYWxlLnRpY2tzKHRpY2tzKTtcbiAgaWYgKHRpY2tGb3JtYXQpIHNjYWxlLnRpY2tGb3JtYXQodGlja0Zvcm1hdCk7XG5cbiAgcmV0dXJuIHNjYWxlO1xufSk7XG5cbnZhciBxdWFudGlsZSA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgcmFuZ2UgPSBfcmVmLnJhbmdlLFxuICAgICAgZG9tYWluID0gX3JlZi5kb21haW47XG5cbiAgdmFyIHNjYWxlID0gc2NhbGVRdWFudGlsZSgpO1xuICBzY2FsZS50eXBlID0gJ3F1YW50aWxlJztcblxuICBpZiAocmFuZ2UpIHNjYWxlLnJhbmdlKHJhbmdlKTtcbiAgaWYgKGRvbWFpbikgc2NhbGUuZG9tYWluKGRvbWFpbik7XG5cbiAgcmV0dXJuIHNjYWxlO1xufSk7XG5cbnZhciB0aHJlc2hvbGQgPSAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHJhbmdlID0gX3JlZi5yYW5nZSxcbiAgICAgIGRvbWFpbiA9IF9yZWYuZG9tYWluO1xuXG4gIHZhciBzY2FsZSA9IHNjYWxlVGhyZXNob2xkKCk7XG4gIHNjYWxlLnR5cGUgPSAndGhyZXNob2xkJztcblxuICBpZiAocmFuZ2UpIHNjYWxlLnJhbmdlKHJhbmdlKTtcbiAgaWYgKGRvbWFpbikgc2NhbGUuZG9tYWluKGRvbWFpbik7XG5cbiAgcmV0dXJuIHNjYWxlO1xufSk7XG5cbnZhciBvYmplY3RXaXRob3V0UHJvcGVydGllcyA9IGZ1bmN0aW9uIChvYmosIGtleXMpIHtcbiAgdmFyIHRhcmdldCA9IHt9O1xuXG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTtcbiAgICB0YXJnZXRbaV0gPSBvYmpbaV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIHVwZGF0ZVNjYWxlKHNjYWxlLCBfcmVmKSB7XG4gIHZhciBhcmdzID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgW10pO1xuXG4gIHZhciBuZXh0U2NhbGUgPSBzY2FsZS5jb3B5KCk7XG4gIE9iamVjdC5rZXlzKGFyZ3MpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGlmIChoYXMuY2FsbChuZXh0U2NhbGUsIGtleSkpIG5leHRTY2FsZVtrZXldKGFyZ3Nba2V5XSk7XG4gIH0pO1xuICByZXR1cm4gbmV4dFNjYWxlO1xufVxuXG5leHBvcnQgeyBiYW5kIGFzIHNjYWxlQmFuZCwgcG9pbnQgYXMgc2NhbGVQb2ludCwgbGluZWFyIGFzIHNjYWxlTGluZWFyLCB0aW1lIGFzIHNjYWxlVGltZSwgdXRjIGFzIHNjYWxlVXRjLCBsb2cgYXMgc2NhbGVMb2csIHBvd2VyIGFzIHNjYWxlUG93ZXIsIG9yZGluYWwgYXMgc2NhbGVPcmRpbmFsLCBxdWFudGl6ZSBhcyBzY2FsZVF1YW50aXplLCBxdWFudGlsZSBhcyBzY2FsZVF1YW50aWxlLCB0aHJlc2hvbGQgYXMgc2NhbGVUaHJlc2hvbGQsIHVwZGF0ZVNjYWxlIH07XG4iLCJleHBvcnQgZnVuY3Rpb24gaXNBeGlzKG5hbWUpIHtcbiAgcmV0dXJuIC9heGlzL2dpLnRlc3QobmFtZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNTZXJpZXMobmFtZSkge1xuICByZXR1cm4gL3Nlcmllcy9naS50ZXN0KG5hbWUpO1xufSIsIi8qIGVzbGludCBuby1wYXJhbS1yZWFzc2lnbjogMCAqL1xuLy8gYmlucyBzaG91bGQgbWluaW1hbGx5IGhhdmUgdGhlIHNoYXBlXG4vLyBBcnJheTxPYmplY3R7IGNvdW50OiBOdW1iZXIgfT5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFkZERlbnNpdHlBbmRDdW11bGF0aXZlVmFsdWVzVG9CaW5zKGJpbnMpIHtcbiAgdmFyIGN1bXVsYXRpdmUgPSAwO1xuICBiaW5zLmZvckVhY2goZnVuY3Rpb24gKGJpbikge1xuICAgIGN1bXVsYXRpdmUgKz0gaXNOYU4oYmluLmNvdW50KSA/IDAgOiBiaW4uY291bnQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG5cbiAgICBiaW4uY3VtdWxhdGl2ZSA9IGN1bXVsYXRpdmU7XG4gIH0pO1xuICB2YXIgdG90YWwgPSBjdW11bGF0aXZlO1xuICBiaW5zLmZvckVhY2goZnVuY3Rpb24gKGJpbikge1xuICAgIGJpbi5kZW5zaXR5ID0gYmluLmNvdW50IC8gdG90YWw7XG4gICAgYmluLmN1bXVsYXRpdmVEZW5zaXR5ID0gYmluLmN1bXVsYXRpdmUgLyB0b3RhbDtcbiAgfSk7XG59IiwidmFyIGFycmF5ID0gQXJyYXkucHJvdG90eXBlO1xuXG5leHBvcnQgdmFyIG1hcCA9IGFycmF5Lm1hcDtcbmV4cG9ydCB2YXIgc2xpY2UgPSBhcnJheS5zbGljZTtcbiIsImltcG9ydCB7bWFwfSBmcm9tIFwiZDMtY29sbGVjdGlvblwiO1xuaW1wb3J0IHtzbGljZX0gZnJvbSBcIi4vYXJyYXlcIjtcblxuZXhwb3J0IHZhciBpbXBsaWNpdCA9IHtuYW1lOiBcImltcGxpY2l0XCJ9O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBvcmRpbmFsKHJhbmdlKSB7XG4gIHZhciBpbmRleCA9IG1hcCgpLFxuICAgICAgZG9tYWluID0gW10sXG4gICAgICB1bmtub3duID0gaW1wbGljaXQ7XG5cbiAgcmFuZ2UgPSByYW5nZSA9PSBudWxsID8gW10gOiBzbGljZS5jYWxsKHJhbmdlKTtcblxuICBmdW5jdGlvbiBzY2FsZShkKSB7XG4gICAgdmFyIGtleSA9IGQgKyBcIlwiLCBpID0gaW5kZXguZ2V0KGtleSk7XG4gICAgaWYgKCFpKSB7XG4gICAgICBpZiAodW5rbm93biAhPT0gaW1wbGljaXQpIHJldHVybiB1bmtub3duO1xuICAgICAgaW5kZXguc2V0KGtleSwgaSA9IGRvbWFpbi5wdXNoKGQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlWyhpIC0gMSkgJSByYW5nZS5sZW5ndGhdO1xuICB9XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbi5zbGljZSgpO1xuICAgIGRvbWFpbiA9IFtdLCBpbmRleCA9IG1hcCgpO1xuICAgIHZhciBpID0gLTEsIG4gPSBfLmxlbmd0aCwgZCwga2V5O1xuICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoIWluZGV4LmhhcyhrZXkgPSAoZCA9IF9baV0pICsgXCJcIikpIGluZGV4LnNldChrZXksIGRvbWFpbi5wdXNoKGQpKTtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFuZ2UgPSBzbGljZS5jYWxsKF8pLCBzY2FsZSkgOiByYW5nZS5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBvcmRpbmFsKClcbiAgICAgICAgLmRvbWFpbihkb21haW4pXG4gICAgICAgIC5yYW5nZShyYW5nZSlcbiAgICAgICAgLnVua25vd24odW5rbm93bik7XG4gIH07XG5cbiAgcmV0dXJuIHNjYWxlO1xufVxuIiwiaW1wb3J0IHtyYW5nZSBhcyBzZXF1ZW5jZX0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQgb3JkaW5hbCBmcm9tIFwiLi9vcmRpbmFsXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJhbmQoKSB7XG4gIHZhciBzY2FsZSA9IG9yZGluYWwoKS51bmtub3duKHVuZGVmaW5lZCksXG4gICAgICBkb21haW4gPSBzY2FsZS5kb21haW4sXG4gICAgICBvcmRpbmFsUmFuZ2UgPSBzY2FsZS5yYW5nZSxcbiAgICAgIHJhbmdlID0gWzAsIDFdLFxuICAgICAgc3RlcCxcbiAgICAgIGJhbmR3aWR0aCxcbiAgICAgIHJvdW5kID0gZmFsc2UsXG4gICAgICBwYWRkaW5nSW5uZXIgPSAwLFxuICAgICAgcGFkZGluZ091dGVyID0gMCxcbiAgICAgIGFsaWduID0gMC41O1xuXG4gIGRlbGV0ZSBzY2FsZS51bmtub3duO1xuXG4gIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgdmFyIG4gPSBkb21haW4oKS5sZW5ndGgsXG4gICAgICAgIHJldmVyc2UgPSByYW5nZVsxXSA8IHJhbmdlWzBdLFxuICAgICAgICBzdGFydCA9IHJhbmdlW3JldmVyc2UgLSAwXSxcbiAgICAgICAgc3RvcCA9IHJhbmdlWzEgLSByZXZlcnNlXTtcbiAgICBzdGVwID0gKHN0b3AgLSBzdGFydCkgLyBNYXRoLm1heCgxLCBuIC0gcGFkZGluZ0lubmVyICsgcGFkZGluZ091dGVyICogMik7XG4gICAgaWYgKHJvdW5kKSBzdGVwID0gTWF0aC5mbG9vcihzdGVwKTtcbiAgICBzdGFydCArPSAoc3RvcCAtIHN0YXJ0IC0gc3RlcCAqIChuIC0gcGFkZGluZ0lubmVyKSkgKiBhbGlnbjtcbiAgICBiYW5kd2lkdGggPSBzdGVwICogKDEgLSBwYWRkaW5nSW5uZXIpO1xuICAgIGlmIChyb3VuZCkgc3RhcnQgPSBNYXRoLnJvdW5kKHN0YXJ0KSwgYmFuZHdpZHRoID0gTWF0aC5yb3VuZChiYW5kd2lkdGgpO1xuICAgIHZhciB2YWx1ZXMgPSBzZXF1ZW5jZShuKS5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gc3RhcnQgKyBzdGVwICogaTsgfSk7XG4gICAgcmV0dXJuIG9yZGluYWxSYW5nZShyZXZlcnNlID8gdmFsdWVzLnJldmVyc2UoKSA6IHZhbHVlcyk7XG4gIH1cblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZG9tYWluKF8pLCByZXNjYWxlKCkpIDogZG9tYWluKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFuZ2UgPSBbK19bMF0sICtfWzFdXSwgcmVzY2FsZSgpKSA6IHJhbmdlLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2VSb3VuZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gcmFuZ2UgPSBbK19bMF0sICtfWzFdXSwgcm91bmQgPSB0cnVlLCByZXNjYWxlKCk7XG4gIH07XG5cbiAgc2NhbGUuYmFuZHdpZHRoID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGJhbmR3aWR0aDtcbiAgfTtcblxuICBzY2FsZS5zdGVwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHN0ZXA7XG4gIH07XG5cbiAgc2NhbGUucm91bmQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocm91bmQgPSAhIV8sIHJlc2NhbGUoKSkgOiByb3VuZDtcbiAgfTtcblxuICBzY2FsZS5wYWRkaW5nID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmdJbm5lciA9IHBhZGRpbmdPdXRlciA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIF8pKSwgcmVzY2FsZSgpKSA6IHBhZGRpbmdJbm5lcjtcbiAgfTtcblxuICBzY2FsZS5wYWRkaW5nSW5uZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ0lubmVyID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgXykpLCByZXNjYWxlKCkpIDogcGFkZGluZ0lubmVyO1xuICB9O1xuXG4gIHNjYWxlLnBhZGRpbmdPdXRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nT3V0ZXIgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBfKSksIHJlc2NhbGUoKSkgOiBwYWRkaW5nT3V0ZXI7XG4gIH07XG5cbiAgc2NhbGUuYWxpZ24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYWxpZ24gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBfKSksIHJlc2NhbGUoKSkgOiBhbGlnbjtcbiAgfTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGJhbmQoKVxuICAgICAgICAuZG9tYWluKGRvbWFpbigpKVxuICAgICAgICAucmFuZ2UocmFuZ2UpXG4gICAgICAgIC5yb3VuZChyb3VuZClcbiAgICAgICAgLnBhZGRpbmdJbm5lcihwYWRkaW5nSW5uZXIpXG4gICAgICAgIC5wYWRkaW5nT3V0ZXIocGFkZGluZ091dGVyKVxuICAgICAgICAuYWxpZ24oYWxpZ24pO1xuICB9O1xuXG4gIHJldHVybiByZXNjYWxlKCk7XG59XG5cbmZ1bmN0aW9uIHBvaW50aXNoKHNjYWxlKSB7XG4gIHZhciBjb3B5ID0gc2NhbGUuY29weTtcblxuICBzY2FsZS5wYWRkaW5nID0gc2NhbGUucGFkZGluZ091dGVyO1xuICBkZWxldGUgc2NhbGUucGFkZGluZ0lubmVyO1xuICBkZWxldGUgc2NhbGUucGFkZGluZ091dGVyO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcG9pbnRpc2goY29weSgpKTtcbiAgfTtcblxuICByZXR1cm4gc2NhbGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb2ludCgpIHtcbiAgcmV0dXJuIHBvaW50aXNoKGJhbmQoKS5wYWRkaW5nSW5uZXIoMSkpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiAreDtcbn1cbiIsImltcG9ydCB7YmlzZWN0fSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7aW50ZXJwb2xhdGUgYXMgaW50ZXJwb2xhdGVWYWx1ZSwgaW50ZXJwb2xhdGVSb3VuZH0gZnJvbSBcImQzLWludGVycG9sYXRlXCI7XG5pbXBvcnQge21hcCwgc2xpY2V9IGZyb20gXCIuL2FycmF5XCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnRcIjtcbmltcG9ydCBudW1iZXIgZnJvbSBcIi4vbnVtYmVyXCI7XG5cbnZhciB1bml0ID0gWzAsIDFdO1xuXG5leHBvcnQgZnVuY3Rpb24gZGVpbnRlcnBvbGF0ZUxpbmVhcihhLCBiKSB7XG4gIHJldHVybiAoYiAtPSAoYSA9ICthKSlcbiAgICAgID8gZnVuY3Rpb24oeCkgeyByZXR1cm4gKHggLSBhKSAvIGI7IH1cbiAgICAgIDogY29uc3RhbnQoYik7XG59XG5cbmZ1bmN0aW9uIGRlaW50ZXJwb2xhdGVDbGFtcChkZWludGVycG9sYXRlKSB7XG4gIHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIGQgPSBkZWludGVycG9sYXRlKGEgPSArYSwgYiA9ICtiKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkgeyByZXR1cm4geCA8PSBhID8gMCA6IHggPj0gYiA/IDEgOiBkKHgpOyB9O1xuICB9O1xufVxuXG5mdW5jdGlvbiByZWludGVycG9sYXRlQ2xhbXAocmVpbnRlcnBvbGF0ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciByID0gcmVpbnRlcnBvbGF0ZShhID0gK2EsIGIgPSArYik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHsgcmV0dXJuIHQgPD0gMCA/IGEgOiB0ID49IDEgPyBiIDogcih0KTsgfTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYmltYXAoZG9tYWluLCByYW5nZSwgZGVpbnRlcnBvbGF0ZSwgcmVpbnRlcnBvbGF0ZSkge1xuICB2YXIgZDAgPSBkb21haW5bMF0sIGQxID0gZG9tYWluWzFdLCByMCA9IHJhbmdlWzBdLCByMSA9IHJhbmdlWzFdO1xuICBpZiAoZDEgPCBkMCkgZDAgPSBkZWludGVycG9sYXRlKGQxLCBkMCksIHIwID0gcmVpbnRlcnBvbGF0ZShyMSwgcjApO1xuICBlbHNlIGQwID0gZGVpbnRlcnBvbGF0ZShkMCwgZDEpLCByMCA9IHJlaW50ZXJwb2xhdGUocjAsIHIxKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHIwKGQwKHgpKTsgfTtcbn1cblxuZnVuY3Rpb24gcG9seW1hcChkb21haW4sIHJhbmdlLCBkZWludGVycG9sYXRlLCByZWludGVycG9sYXRlKSB7XG4gIHZhciBqID0gTWF0aC5taW4oZG9tYWluLmxlbmd0aCwgcmFuZ2UubGVuZ3RoKSAtIDEsXG4gICAgICBkID0gbmV3IEFycmF5KGopLFxuICAgICAgciA9IG5ldyBBcnJheShqKSxcbiAgICAgIGkgPSAtMTtcblxuICAvLyBSZXZlcnNlIGRlc2NlbmRpbmcgZG9tYWlucy5cbiAgaWYgKGRvbWFpbltqXSA8IGRvbWFpblswXSkge1xuICAgIGRvbWFpbiA9IGRvbWFpbi5zbGljZSgpLnJldmVyc2UoKTtcbiAgICByYW5nZSA9IHJhbmdlLnNsaWNlKCkucmV2ZXJzZSgpO1xuICB9XG5cbiAgd2hpbGUgKCsraSA8IGopIHtcbiAgICBkW2ldID0gZGVpbnRlcnBvbGF0ZShkb21haW5baV0sIGRvbWFpbltpICsgMV0pO1xuICAgIHJbaV0gPSByZWludGVycG9sYXRlKHJhbmdlW2ldLCByYW5nZVtpICsgMV0pO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgaSA9IGJpc2VjdChkb21haW4sIHgsIDEsIGopIC0gMTtcbiAgICByZXR1cm4gcltpXShkW2ldKHgpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkoc291cmNlLCB0YXJnZXQpIHtcbiAgcmV0dXJuIHRhcmdldFxuICAgICAgLmRvbWFpbihzb3VyY2UuZG9tYWluKCkpXG4gICAgICAucmFuZ2Uoc291cmNlLnJhbmdlKCkpXG4gICAgICAuaW50ZXJwb2xhdGUoc291cmNlLmludGVycG9sYXRlKCkpXG4gICAgICAuY2xhbXAoc291cmNlLmNsYW1wKCkpO1xufVxuXG4vLyBkZWludGVycG9sYXRlKGEsIGIpKHgpIHRha2VzIGEgZG9tYWluIHZhbHVlIHggaW4gW2EsYl0gYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGFyYW1ldGVyIHQgaW4gWzAsMV0uXG4vLyByZWludGVycG9sYXRlKGEsIGIpKHQpIHRha2VzIGEgcGFyYW1ldGVyIHQgaW4gWzAsMV0gYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgZG9tYWluIHZhbHVlIHggaW4gW2EsYl0uXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb250aW51b3VzKGRlaW50ZXJwb2xhdGUsIHJlaW50ZXJwb2xhdGUpIHtcbiAgdmFyIGRvbWFpbiA9IHVuaXQsXG4gICAgICByYW5nZSA9IHVuaXQsXG4gICAgICBpbnRlcnBvbGF0ZSA9IGludGVycG9sYXRlVmFsdWUsXG4gICAgICBjbGFtcCA9IGZhbHNlLFxuICAgICAgcGllY2V3aXNlLFxuICAgICAgb3V0cHV0LFxuICAgICAgaW5wdXQ7XG5cbiAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICBwaWVjZXdpc2UgPSBNYXRoLm1pbihkb21haW4ubGVuZ3RoLCByYW5nZS5sZW5ndGgpID4gMiA/IHBvbHltYXAgOiBiaW1hcDtcbiAgICBvdXRwdXQgPSBpbnB1dCA9IG51bGw7XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgIHJldHVybiAob3V0cHV0IHx8IChvdXRwdXQgPSBwaWVjZXdpc2UoZG9tYWluLCByYW5nZSwgY2xhbXAgPyBkZWludGVycG9sYXRlQ2xhbXAoZGVpbnRlcnBvbGF0ZSkgOiBkZWludGVycG9sYXRlLCBpbnRlcnBvbGF0ZSkpKSgreCk7XG4gIH1cblxuICBzY2FsZS5pbnZlcnQgPSBmdW5jdGlvbih5KSB7XG4gICAgcmV0dXJuIChpbnB1dCB8fCAoaW5wdXQgPSBwaWVjZXdpc2UocmFuZ2UsIGRvbWFpbiwgZGVpbnRlcnBvbGF0ZUxpbmVhciwgY2xhbXAgPyByZWludGVycG9sYXRlQ2xhbXAocmVpbnRlcnBvbGF0ZSkgOiByZWludGVycG9sYXRlKSkpKCt5KTtcbiAgfTtcblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZG9tYWluID0gbWFwLmNhbGwoXywgbnVtYmVyKSwgcmVzY2FsZSgpKSA6IGRvbWFpbi5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmdlID0gc2xpY2UuY2FsbChfKSwgcmVzY2FsZSgpKSA6IHJhbmdlLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2VSb3VuZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gcmFuZ2UgPSBzbGljZS5jYWxsKF8pLCBpbnRlcnBvbGF0ZSA9IGludGVycG9sYXRlUm91bmQsIHJlc2NhbGUoKTtcbiAgfTtcblxuICBzY2FsZS5jbGFtcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjbGFtcCA9ICEhXywgcmVzY2FsZSgpKSA6IGNsYW1wO1xuICB9O1xuXG4gIHNjYWxlLmludGVycG9sYXRlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGludGVycG9sYXRlID0gXywgcmVzY2FsZSgpKSA6IGludGVycG9sYXRlO1xuICB9O1xuXG4gIHJldHVybiByZXNjYWxlKCk7XG59XG4iLCJpbXBvcnQge3RpY2tTdGVwfSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7Zm9ybWF0LCBmb3JtYXRQcmVmaXgsIGZvcm1hdFNwZWNpZmllciwgcHJlY2lzaW9uRml4ZWQsIHByZWNpc2lvblByZWZpeCwgcHJlY2lzaW9uUm91bmR9IGZyb20gXCJkMy1mb3JtYXRcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZG9tYWluLCBjb3VudCwgc3BlY2lmaWVyKSB7XG4gIHZhciBzdGFydCA9IGRvbWFpblswXSxcbiAgICAgIHN0b3AgPSBkb21haW5bZG9tYWluLmxlbmd0aCAtIDFdLFxuICAgICAgc3RlcCA9IHRpY2tTdGVwKHN0YXJ0LCBzdG9wLCBjb3VudCA9PSBudWxsID8gMTAgOiBjb3VudCksXG4gICAgICBwcmVjaXNpb247XG4gIHNwZWNpZmllciA9IGZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIgPT0gbnVsbCA/IFwiLGZcIiA6IHNwZWNpZmllcik7XG4gIHN3aXRjaCAoc3BlY2lmaWVyLnR5cGUpIHtcbiAgICBjYXNlIFwic1wiOiB7XG4gICAgICB2YXIgdmFsdWUgPSBNYXRoLm1heChNYXRoLmFicyhzdGFydCksIE1hdGguYWJzKHN0b3ApKTtcbiAgICAgIGlmIChzcGVjaWZpZXIucHJlY2lzaW9uID09IG51bGwgJiYgIWlzTmFOKHByZWNpc2lvbiA9IHByZWNpc2lvblByZWZpeChzdGVwLCB2YWx1ZSkpKSBzcGVjaWZpZXIucHJlY2lzaW9uID0gcHJlY2lzaW9uO1xuICAgICAgcmV0dXJuIGZvcm1hdFByZWZpeChzcGVjaWZpZXIsIHZhbHVlKTtcbiAgICB9XG4gICAgY2FzZSBcIlwiOlxuICAgIGNhc2UgXCJlXCI6XG4gICAgY2FzZSBcImdcIjpcbiAgICBjYXNlIFwicFwiOlxuICAgIGNhc2UgXCJyXCI6IHtcbiAgICAgIGlmIChzcGVjaWZpZXIucHJlY2lzaW9uID09IG51bGwgJiYgIWlzTmFOKHByZWNpc2lvbiA9IHByZWNpc2lvblJvdW5kKHN0ZXAsIE1hdGgubWF4KE1hdGguYWJzKHN0YXJ0KSwgTWF0aC5hYnMoc3RvcCkpKSkpIHNwZWNpZmllci5wcmVjaXNpb24gPSBwcmVjaXNpb24gLSAoc3BlY2lmaWVyLnR5cGUgPT09IFwiZVwiKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiZlwiOlxuICAgIGNhc2UgXCIlXCI6IHtcbiAgICAgIGlmIChzcGVjaWZpZXIucHJlY2lzaW9uID09IG51bGwgJiYgIWlzTmFOKHByZWNpc2lvbiA9IHByZWNpc2lvbkZpeGVkKHN0ZXApKSkgc3BlY2lmaWVyLnByZWNpc2lvbiA9IHByZWNpc2lvbiAtIChzcGVjaWZpZXIudHlwZSA9PT0gXCIlXCIpICogMjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZm9ybWF0KHNwZWNpZmllcik7XG59XG4iLCJpbXBvcnQge3RpY2tzLCB0aWNrSW5jcmVtZW50fSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7aW50ZXJwb2xhdGVOdW1iZXIgYXMgcmVpbnRlcnBvbGF0ZX0gZnJvbSBcImQzLWludGVycG9sYXRlXCI7XG5pbXBvcnQge2RlZmF1bHQgYXMgY29udGludW91cywgY29weSwgZGVpbnRlcnBvbGF0ZUxpbmVhciBhcyBkZWludGVycG9sYXRlfSBmcm9tIFwiLi9jb250aW51b3VzXCI7XG5pbXBvcnQgdGlja0Zvcm1hdCBmcm9tIFwiLi90aWNrRm9ybWF0XCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJpc2goc2NhbGUpIHtcbiAgdmFyIGRvbWFpbiA9IHNjYWxlLmRvbWFpbjtcblxuICBzY2FsZS50aWNrcyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgdmFyIGQgPSBkb21haW4oKTtcbiAgICByZXR1cm4gdGlja3MoZFswXSwgZFtkLmxlbmd0aCAtIDFdLCBjb3VudCA9PSBudWxsID8gMTAgOiBjb3VudCk7XG4gIH07XG5cbiAgc2NhbGUudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKGNvdW50LCBzcGVjaWZpZXIpIHtcbiAgICByZXR1cm4gdGlja0Zvcm1hdChkb21haW4oKSwgY291bnQsIHNwZWNpZmllcik7XG4gIH07XG5cbiAgc2NhbGUubmljZSA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgaWYgKGNvdW50ID09IG51bGwpIGNvdW50ID0gMTA7XG5cbiAgICB2YXIgZCA9IGRvbWFpbigpLFxuICAgICAgICBpMCA9IDAsXG4gICAgICAgIGkxID0gZC5sZW5ndGggLSAxLFxuICAgICAgICBzdGFydCA9IGRbaTBdLFxuICAgICAgICBzdG9wID0gZFtpMV0sXG4gICAgICAgIHN0ZXA7XG5cbiAgICBpZiAoc3RvcCA8IHN0YXJ0KSB7XG4gICAgICBzdGVwID0gc3RhcnQsIHN0YXJ0ID0gc3RvcCwgc3RvcCA9IHN0ZXA7XG4gICAgICBzdGVwID0gaTAsIGkwID0gaTEsIGkxID0gc3RlcDtcbiAgICB9XG5cbiAgICBzdGVwID0gdGlja0luY3JlbWVudChzdGFydCwgc3RvcCwgY291bnQpO1xuXG4gICAgaWYgKHN0ZXAgPiAwKSB7XG4gICAgICBzdGFydCA9IE1hdGguZmxvb3Ioc3RhcnQgLyBzdGVwKSAqIHN0ZXA7XG4gICAgICBzdG9wID0gTWF0aC5jZWlsKHN0b3AgLyBzdGVwKSAqIHN0ZXA7XG4gICAgICBzdGVwID0gdGlja0luY3JlbWVudChzdGFydCwgc3RvcCwgY291bnQpO1xuICAgIH0gZWxzZSBpZiAoc3RlcCA8IDApIHtcbiAgICAgIHN0YXJ0ID0gTWF0aC5jZWlsKHN0YXJ0ICogc3RlcCkgLyBzdGVwO1xuICAgICAgc3RvcCA9IE1hdGguZmxvb3Ioc3RvcCAqIHN0ZXApIC8gc3RlcDtcbiAgICAgIHN0ZXAgPSB0aWNrSW5jcmVtZW50KHN0YXJ0LCBzdG9wLCBjb3VudCk7XG4gICAgfVxuXG4gICAgaWYgKHN0ZXAgPiAwKSB7XG4gICAgICBkW2kwXSA9IE1hdGguZmxvb3Ioc3RhcnQgLyBzdGVwKSAqIHN0ZXA7XG4gICAgICBkW2kxXSA9IE1hdGguY2VpbChzdG9wIC8gc3RlcCkgKiBzdGVwO1xuICAgICAgZG9tYWluKGQpO1xuICAgIH0gZWxzZSBpZiAoc3RlcCA8IDApIHtcbiAgICAgIGRbaTBdID0gTWF0aC5jZWlsKHN0YXJ0ICogc3RlcCkgLyBzdGVwO1xuICAgICAgZFtpMV0gPSBNYXRoLmZsb29yKHN0b3AgKiBzdGVwKSAvIHN0ZXA7XG4gICAgICBkb21haW4oZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjYWxlO1xuICB9O1xuXG4gIHJldHVybiBzY2FsZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGluZWFyKCkge1xuICB2YXIgc2NhbGUgPSBjb250aW51b3VzKGRlaW50ZXJwb2xhdGUsIHJlaW50ZXJwb2xhdGUpO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgbGluZWFyKCkpO1xuICB9O1xuXG4gIHJldHVybiBsaW5lYXJpc2goc2NhbGUpO1xufVxuIiwiaW1wb3J0IHttYXB9IGZyb20gXCIuL2FycmF5XCI7XG5pbXBvcnQge2xpbmVhcmlzaH0gZnJvbSBcIi4vbGluZWFyXCI7XG5pbXBvcnQgbnVtYmVyIGZyb20gXCIuL251bWJlclwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpZGVudGl0eSgpIHtcbiAgdmFyIGRvbWFpbiA9IFswLCAxXTtcblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgcmV0dXJuICt4O1xuICB9XG5cbiAgc2NhbGUuaW52ZXJ0ID0gc2NhbGU7XG5cbiAgc2NhbGUuZG9tYWluID0gc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZG9tYWluID0gbWFwLmNhbGwoXywgbnVtYmVyKSwgc2NhbGUpIDogZG9tYWluLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpZGVudGl0eSgpLmRvbWFpbihkb21haW4pO1xuICB9O1xuXG4gIHJldHVybiBsaW5lYXJpc2goc2NhbGUpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZG9tYWluLCBpbnRlcnZhbCkge1xuICBkb21haW4gPSBkb21haW4uc2xpY2UoKTtcblxuICB2YXIgaTAgPSAwLFxuICAgICAgaTEgPSBkb21haW4ubGVuZ3RoIC0gMSxcbiAgICAgIHgwID0gZG9tYWluW2kwXSxcbiAgICAgIHgxID0gZG9tYWluW2kxXSxcbiAgICAgIHQ7XG5cbiAgaWYgKHgxIDwgeDApIHtcbiAgICB0ID0gaTAsIGkwID0gaTEsIGkxID0gdDtcbiAgICB0ID0geDAsIHgwID0geDEsIHgxID0gdDtcbiAgfVxuXG4gIGRvbWFpbltpMF0gPSBpbnRlcnZhbC5mbG9vcih4MCk7XG4gIGRvbWFpbltpMV0gPSBpbnRlcnZhbC5jZWlsKHgxKTtcbiAgcmV0dXJuIGRvbWFpbjtcbn1cbiIsImltcG9ydCB7dGlja3N9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHtmb3JtYXR9IGZyb20gXCJkMy1mb3JtYXRcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudFwiO1xuaW1wb3J0IG5pY2UgZnJvbSBcIi4vbmljZVwiO1xuaW1wb3J0IHtkZWZhdWx0IGFzIGNvbnRpbnVvdXMsIGNvcHl9IGZyb20gXCIuL2NvbnRpbnVvdXNcIjtcblxuZnVuY3Rpb24gZGVpbnRlcnBvbGF0ZShhLCBiKSB7XG4gIHJldHVybiAoYiA9IE1hdGgubG9nKGIgLyBhKSlcbiAgICAgID8gZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5sb2coeCAvIGEpIC8gYjsgfVxuICAgICAgOiBjb25zdGFudChiKTtcbn1cblxuZnVuY3Rpb24gcmVpbnRlcnBvbGF0ZShhLCBiKSB7XG4gIHJldHVybiBhIDwgMFxuICAgICAgPyBmdW5jdGlvbih0KSB7IHJldHVybiAtTWF0aC5wb3coLWIsIHQpICogTWF0aC5wb3coLWEsIDEgLSB0KTsgfVxuICAgICAgOiBmdW5jdGlvbih0KSB7IHJldHVybiBNYXRoLnBvdyhiLCB0KSAqIE1hdGgucG93KGEsIDEgLSB0KTsgfTtcbn1cblxuZnVuY3Rpb24gcG93MTAoeCkge1xuICByZXR1cm4gaXNGaW5pdGUoeCkgPyArKFwiMWVcIiArIHgpIDogeCA8IDAgPyAwIDogeDtcbn1cblxuZnVuY3Rpb24gcG93cChiYXNlKSB7XG4gIHJldHVybiBiYXNlID09PSAxMCA/IHBvdzEwXG4gICAgICA6IGJhc2UgPT09IE1hdGguRSA/IE1hdGguZXhwXG4gICAgICA6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgucG93KGJhc2UsIHgpOyB9O1xufVxuXG5mdW5jdGlvbiBsb2dwKGJhc2UpIHtcbiAgcmV0dXJuIGJhc2UgPT09IE1hdGguRSA/IE1hdGgubG9nXG4gICAgICA6IGJhc2UgPT09IDEwICYmIE1hdGgubG9nMTBcbiAgICAgIHx8IGJhc2UgPT09IDIgJiYgTWF0aC5sb2cyXG4gICAgICB8fCAoYmFzZSA9IE1hdGgubG9nKGJhc2UpLCBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLmxvZyh4KSAvIGJhc2U7IH0pO1xufVxuXG5mdW5jdGlvbiByZWZsZWN0KGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gLWYoLXgpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsb2coKSB7XG4gIHZhciBzY2FsZSA9IGNvbnRpbnVvdXMoZGVpbnRlcnBvbGF0ZSwgcmVpbnRlcnBvbGF0ZSkuZG9tYWluKFsxLCAxMF0pLFxuICAgICAgZG9tYWluID0gc2NhbGUuZG9tYWluLFxuICAgICAgYmFzZSA9IDEwLFxuICAgICAgbG9ncyA9IGxvZ3AoMTApLFxuICAgICAgcG93cyA9IHBvd3AoMTApO1xuXG4gIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgbG9ncyA9IGxvZ3AoYmFzZSksIHBvd3MgPSBwb3dwKGJhc2UpO1xuICAgIGlmIChkb21haW4oKVswXSA8IDApIGxvZ3MgPSByZWZsZWN0KGxvZ3MpLCBwb3dzID0gcmVmbGVjdChwb3dzKTtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH1cblxuICBzY2FsZS5iYXNlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGJhc2UgPSArXywgcmVzY2FsZSgpKSA6IGJhc2U7XG4gIH07XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRvbWFpbihfKSwgcmVzY2FsZSgpKSA6IGRvbWFpbigpO1xuICB9O1xuXG4gIHNjYWxlLnRpY2tzID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICB2YXIgZCA9IGRvbWFpbigpLFxuICAgICAgICB1ID0gZFswXSxcbiAgICAgICAgdiA9IGRbZC5sZW5ndGggLSAxXSxcbiAgICAgICAgcjtcblxuICAgIGlmIChyID0gdiA8IHUpIGkgPSB1LCB1ID0gdiwgdiA9IGk7XG5cbiAgICB2YXIgaSA9IGxvZ3ModSksXG4gICAgICAgIGogPSBsb2dzKHYpLFxuICAgICAgICBwLFxuICAgICAgICBrLFxuICAgICAgICB0LFxuICAgICAgICBuID0gY291bnQgPT0gbnVsbCA/IDEwIDogK2NvdW50LFxuICAgICAgICB6ID0gW107XG5cbiAgICBpZiAoIShiYXNlICUgMSkgJiYgaiAtIGkgPCBuKSB7XG4gICAgICBpID0gTWF0aC5yb3VuZChpKSAtIDEsIGogPSBNYXRoLnJvdW5kKGopICsgMTtcbiAgICAgIGlmICh1ID4gMCkgZm9yICg7IGkgPCBqOyArK2kpIHtcbiAgICAgICAgZm9yIChrID0gMSwgcCA9IHBvd3MoaSk7IGsgPCBiYXNlOyArK2spIHtcbiAgICAgICAgICB0ID0gcCAqIGs7XG4gICAgICAgICAgaWYgKHQgPCB1KSBjb250aW51ZTtcbiAgICAgICAgICBpZiAodCA+IHYpIGJyZWFrO1xuICAgICAgICAgIHoucHVzaCh0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGZvciAoOyBpIDwgajsgKytpKSB7XG4gICAgICAgIGZvciAoayA9IGJhc2UgLSAxLCBwID0gcG93cyhpKTsgayA+PSAxOyAtLWspIHtcbiAgICAgICAgICB0ID0gcCAqIGs7XG4gICAgICAgICAgaWYgKHQgPCB1KSBjb250aW51ZTtcbiAgICAgICAgICBpZiAodCA+IHYpIGJyZWFrO1xuICAgICAgICAgIHoucHVzaCh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB6ID0gdGlja3MoaSwgaiwgTWF0aC5taW4oaiAtIGksIG4pKS5tYXAocG93cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHIgPyB6LnJldmVyc2UoKSA6IHo7XG4gIH07XG5cbiAgc2NhbGUudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKGNvdW50LCBzcGVjaWZpZXIpIHtcbiAgICBpZiAoc3BlY2lmaWVyID09IG51bGwpIHNwZWNpZmllciA9IGJhc2UgPT09IDEwID8gXCIuMGVcIiA6IFwiLFwiO1xuICAgIGlmICh0eXBlb2Ygc3BlY2lmaWVyICE9PSBcImZ1bmN0aW9uXCIpIHNwZWNpZmllciA9IGZvcm1hdChzcGVjaWZpZXIpO1xuICAgIGlmIChjb3VudCA9PT0gSW5maW5pdHkpIHJldHVybiBzcGVjaWZpZXI7XG4gICAgaWYgKGNvdW50ID09IG51bGwpIGNvdW50ID0gMTA7XG4gICAgdmFyIGsgPSBNYXRoLm1heCgxLCBiYXNlICogY291bnQgLyBzY2FsZS50aWNrcygpLmxlbmd0aCk7IC8vIFRPRE8gZmFzdCBlc3RpbWF0ZT9cbiAgICByZXR1cm4gZnVuY3Rpb24oZCkge1xuICAgICAgdmFyIGkgPSBkIC8gcG93cyhNYXRoLnJvdW5kKGxvZ3MoZCkpKTtcbiAgICAgIGlmIChpICogYmFzZSA8IGJhc2UgLSAwLjUpIGkgKj0gYmFzZTtcbiAgICAgIHJldHVybiBpIDw9IGsgPyBzcGVjaWZpZXIoZCkgOiBcIlwiO1xuICAgIH07XG4gIH07XG5cbiAgc2NhbGUubmljZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkb21haW4obmljZShkb21haW4oKSwge1xuICAgICAgZmxvb3I6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHBvd3MoTWF0aC5mbG9vcihsb2dzKHgpKSk7IH0sXG4gICAgICBjZWlsOiBmdW5jdGlvbih4KSB7IHJldHVybiBwb3dzKE1hdGguY2VpbChsb2dzKHgpKSk7IH1cbiAgICB9KSk7XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBsb2coKS5iYXNlKGJhc2UpKTtcbiAgfTtcblxuICByZXR1cm4gc2NhbGU7XG59XG4iLCJpbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnRcIjtcbmltcG9ydCB7bGluZWFyaXNofSBmcm9tIFwiLi9saW5lYXJcIjtcbmltcG9ydCB7ZGVmYXVsdCBhcyBjb250aW51b3VzLCBjb3B5fSBmcm9tIFwiLi9jb250aW51b3VzXCI7XG5cbmZ1bmN0aW9uIHJhaXNlKHgsIGV4cG9uZW50KSB7XG4gIHJldHVybiB4IDwgMCA/IC1NYXRoLnBvdygteCwgZXhwb25lbnQpIDogTWF0aC5wb3coeCwgZXhwb25lbnQpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwb3coKSB7XG4gIHZhciBleHBvbmVudCA9IDEsXG4gICAgICBzY2FsZSA9IGNvbnRpbnVvdXMoZGVpbnRlcnBvbGF0ZSwgcmVpbnRlcnBvbGF0ZSksXG4gICAgICBkb21haW4gPSBzY2FsZS5kb21haW47XG5cbiAgZnVuY3Rpb24gZGVpbnRlcnBvbGF0ZShhLCBiKSB7XG4gICAgcmV0dXJuIChiID0gcmFpc2UoYiwgZXhwb25lbnQpIC0gKGEgPSByYWlzZShhLCBleHBvbmVudCkpKVxuICAgICAgICA/IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIChyYWlzZSh4LCBleHBvbmVudCkgLSBhKSAvIGI7IH1cbiAgICAgICAgOiBjb25zdGFudChiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlaW50ZXJwb2xhdGUoYSwgYikge1xuICAgIGIgPSByYWlzZShiLCBleHBvbmVudCkgLSAoYSA9IHJhaXNlKGEsIGV4cG9uZW50KSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHsgcmV0dXJuIHJhaXNlKGEgKyBiICogdCwgMSAvIGV4cG9uZW50KTsgfTtcbiAgfVxuXG4gIHNjYWxlLmV4cG9uZW50ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGV4cG9uZW50ID0gK18sIGRvbWFpbihkb21haW4oKSkpIDogZXhwb25lbnQ7XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBwb3coKS5leHBvbmVudChleHBvbmVudCkpO1xuICB9O1xuXG4gIHJldHVybiBsaW5lYXJpc2goc2NhbGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3FydCgpIHtcbiAgcmV0dXJuIHBvdygpLmV4cG9uZW50KDAuNSk7XG59XG4iLCJpbXBvcnQge2FzY2VuZGluZywgYmlzZWN0LCBxdWFudGlsZSBhcyB0aHJlc2hvbGR9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHtzbGljZX0gZnJvbSBcIi4vYXJyYXlcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcXVhbnRpbGUoKSB7XG4gIHZhciBkb21haW4gPSBbXSxcbiAgICAgIHJhbmdlID0gW10sXG4gICAgICB0aHJlc2hvbGRzID0gW107XG5cbiAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICB2YXIgaSA9IDAsIG4gPSBNYXRoLm1heCgxLCByYW5nZS5sZW5ndGgpO1xuICAgIHRocmVzaG9sZHMgPSBuZXcgQXJyYXkobiAtIDEpO1xuICAgIHdoaWxlICgrK2kgPCBuKSB0aHJlc2hvbGRzW2kgLSAxXSA9IHRocmVzaG9sZChkb21haW4sIGkgLyBuKTtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH1cblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgaWYgKCFpc05hTih4ID0gK3gpKSByZXR1cm4gcmFuZ2VbYmlzZWN0KHRocmVzaG9sZHMsIHgpXTtcbiAgfVxuXG4gIHNjYWxlLmludmVydEV4dGVudCA9IGZ1bmN0aW9uKHkpIHtcbiAgICB2YXIgaSA9IHJhbmdlLmluZGV4T2YoeSk7XG4gICAgcmV0dXJuIGkgPCAwID8gW05hTiwgTmFOXSA6IFtcbiAgICAgIGkgPiAwID8gdGhyZXNob2xkc1tpIC0gMV0gOiBkb21haW5bMF0sXG4gICAgICBpIDwgdGhyZXNob2xkcy5sZW5ndGggPyB0aHJlc2hvbGRzW2ldIDogZG9tYWluW2RvbWFpbi5sZW5ndGggLSAxXVxuICAgIF07XG4gIH07XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbi5zbGljZSgpO1xuICAgIGRvbWFpbiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gXy5sZW5ndGgsIGQ7IGkgPCBuOyArK2kpIGlmIChkID0gX1tpXSwgZCAhPSBudWxsICYmICFpc05hTihkID0gK2QpKSBkb21haW4ucHVzaChkKTtcbiAgICBkb21haW4uc29ydChhc2NlbmRpbmcpO1xuICAgIHJldHVybiByZXNjYWxlKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFuZ2UgPSBzbGljZS5jYWxsKF8pLCByZXNjYWxlKCkpIDogcmFuZ2Uuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS5xdWFudGlsZXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhyZXNob2xkcy5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcXVhbnRpbGUoKVxuICAgICAgICAuZG9tYWluKGRvbWFpbilcbiAgICAgICAgLnJhbmdlKHJhbmdlKTtcbiAgfTtcblxuICByZXR1cm4gc2NhbGU7XG59XG4iLCJpbXBvcnQge2Jpc2VjdH0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge3NsaWNlfSBmcm9tIFwiLi9hcnJheVwiO1xuaW1wb3J0IHtsaW5lYXJpc2h9IGZyb20gXCIuL2xpbmVhclwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBxdWFudGl6ZSgpIHtcbiAgdmFyIHgwID0gMCxcbiAgICAgIHgxID0gMSxcbiAgICAgIG4gPSAxLFxuICAgICAgZG9tYWluID0gWzAuNV0sXG4gICAgICByYW5nZSA9IFswLCAxXTtcblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgaWYgKHggPD0geCkgcmV0dXJuIHJhbmdlW2Jpc2VjdChkb21haW4sIHgsIDAsIG4pXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgdmFyIGkgPSAtMTtcbiAgICBkb21haW4gPSBuZXcgQXJyYXkobik7XG4gICAgd2hpbGUgKCsraSA8IG4pIGRvbWFpbltpXSA9ICgoaSArIDEpICogeDEgLSAoaSAtIG4pICogeDApIC8gKG4gKyAxKTtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH1cblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeDAgPSArX1swXSwgeDEgPSArX1sxXSwgcmVzY2FsZSgpKSA6IFt4MCwgeDFdO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG4gPSAocmFuZ2UgPSBzbGljZS5jYWxsKF8pKS5sZW5ndGggLSAxLCByZXNjYWxlKCkpIDogcmFuZ2Uuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS5pbnZlcnRFeHRlbnQgPSBmdW5jdGlvbih5KSB7XG4gICAgdmFyIGkgPSByYW5nZS5pbmRleE9mKHkpO1xuICAgIHJldHVybiBpIDwgMCA/IFtOYU4sIE5hTl1cbiAgICAgICAgOiBpIDwgMSA/IFt4MCwgZG9tYWluWzBdXVxuICAgICAgICA6IGkgPj0gbiA/IFtkb21haW5bbiAtIDFdLCB4MV1cbiAgICAgICAgOiBbZG9tYWluW2kgLSAxXSwgZG9tYWluW2ldXTtcbiAgfTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHF1YW50aXplKClcbiAgICAgICAgLmRvbWFpbihbeDAsIHgxXSlcbiAgICAgICAgLnJhbmdlKHJhbmdlKTtcbiAgfTtcblxuICByZXR1cm4gbGluZWFyaXNoKHNjYWxlKTtcbn1cbiIsImltcG9ydCB7YmlzZWN0fSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7c2xpY2V9IGZyb20gXCIuL2FycmF5XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRocmVzaG9sZCgpIHtcbiAgdmFyIGRvbWFpbiA9IFswLjVdLFxuICAgICAgcmFuZ2UgPSBbMCwgMV0sXG4gICAgICBuID0gMTtcblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgaWYgKHggPD0geCkgcmV0dXJuIHJhbmdlW2Jpc2VjdChkb21haW4sIHgsIDAsIG4pXTtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4gPSBzbGljZS5jYWxsKF8pLCBuID0gTWF0aC5taW4oZG9tYWluLmxlbmd0aCwgcmFuZ2UubGVuZ3RoIC0gMSksIHNjYWxlKSA6IGRvbWFpbi5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmdlID0gc2xpY2UuY2FsbChfKSwgbiA9IE1hdGgubWluKGRvbWFpbi5sZW5ndGgsIHJhbmdlLmxlbmd0aCAtIDEpLCBzY2FsZSkgOiByYW5nZS5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLmludmVydEV4dGVudCA9IGZ1bmN0aW9uKHkpIHtcbiAgICB2YXIgaSA9IHJhbmdlLmluZGV4T2YoeSk7XG4gICAgcmV0dXJuIFtkb21haW5baSAtIDFdLCBkb21haW5baV1dO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhyZXNob2xkKClcbiAgICAgICAgLmRvbWFpbihkb21haW4pXG4gICAgICAgIC5yYW5nZShyYW5nZSk7XG4gIH07XG5cbiAgcmV0dXJuIHNjYWxlO1xufVxuIiwiaW1wb3J0IHtiaXNlY3RvciwgdGlja1N0ZXB9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHtpbnRlcnBvbGF0ZU51bWJlciBhcyByZWludGVycG9sYXRlfSBmcm9tIFwiZDMtaW50ZXJwb2xhdGVcIjtcbmltcG9ydCB7dGltZVllYXIsIHRpbWVNb250aCwgdGltZVdlZWssIHRpbWVEYXksIHRpbWVIb3VyLCB0aW1lTWludXRlLCB0aW1lU2Vjb25kLCB0aW1lTWlsbGlzZWNvbmR9IGZyb20gXCJkMy10aW1lXCI7XG5pbXBvcnQge3RpbWVGb3JtYXR9IGZyb20gXCJkMy10aW1lLWZvcm1hdFwiO1xuaW1wb3J0IHttYXB9IGZyb20gXCIuL2FycmF5XCI7XG5pbXBvcnQge2RlZmF1bHQgYXMgY29udGludW91cywgY29weSwgZGVpbnRlcnBvbGF0ZUxpbmVhciBhcyBkZWludGVycG9sYXRlfSBmcm9tIFwiLi9jb250aW51b3VzXCI7XG5pbXBvcnQgbmljZSBmcm9tIFwiLi9uaWNlXCI7XG5cbnZhciBkdXJhdGlvblNlY29uZCA9IDEwMDAsXG4gICAgZHVyYXRpb25NaW51dGUgPSBkdXJhdGlvblNlY29uZCAqIDYwLFxuICAgIGR1cmF0aW9uSG91ciA9IGR1cmF0aW9uTWludXRlICogNjAsXG4gICAgZHVyYXRpb25EYXkgPSBkdXJhdGlvbkhvdXIgKiAyNCxcbiAgICBkdXJhdGlvbldlZWsgPSBkdXJhdGlvbkRheSAqIDcsXG4gICAgZHVyYXRpb25Nb250aCA9IGR1cmF0aW9uRGF5ICogMzAsXG4gICAgZHVyYXRpb25ZZWFyID0gZHVyYXRpb25EYXkgKiAzNjU7XG5cbmZ1bmN0aW9uIGRhdGUodCkge1xuICByZXR1cm4gbmV3IERhdGUodCk7XG59XG5cbmZ1bmN0aW9uIG51bWJlcih0KSB7XG4gIHJldHVybiB0IGluc3RhbmNlb2YgRGF0ZSA/ICt0IDogK25ldyBEYXRlKCt0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGVuZGFyKHllYXIsIG1vbnRoLCB3ZWVrLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgZm9ybWF0KSB7XG4gIHZhciBzY2FsZSA9IGNvbnRpbnVvdXMoZGVpbnRlcnBvbGF0ZSwgcmVpbnRlcnBvbGF0ZSksXG4gICAgICBpbnZlcnQgPSBzY2FsZS5pbnZlcnQsXG4gICAgICBkb21haW4gPSBzY2FsZS5kb21haW47XG5cbiAgdmFyIGZvcm1hdE1pbGxpc2Vjb25kID0gZm9ybWF0KFwiLiVMXCIpLFxuICAgICAgZm9ybWF0U2Vjb25kID0gZm9ybWF0KFwiOiVTXCIpLFxuICAgICAgZm9ybWF0TWludXRlID0gZm9ybWF0KFwiJUk6JU1cIiksXG4gICAgICBmb3JtYXRIb3VyID0gZm9ybWF0KFwiJUkgJXBcIiksXG4gICAgICBmb3JtYXREYXkgPSBmb3JtYXQoXCIlYSAlZFwiKSxcbiAgICAgIGZvcm1hdFdlZWsgPSBmb3JtYXQoXCIlYiAlZFwiKSxcbiAgICAgIGZvcm1hdE1vbnRoID0gZm9ybWF0KFwiJUJcIiksXG4gICAgICBmb3JtYXRZZWFyID0gZm9ybWF0KFwiJVlcIik7XG5cbiAgdmFyIHRpY2tJbnRlcnZhbHMgPSBbXG4gICAgW3NlY29uZCwgIDEsICAgICAgZHVyYXRpb25TZWNvbmRdLFxuICAgIFtzZWNvbmQsICA1LCAgNSAqIGR1cmF0aW9uU2Vjb25kXSxcbiAgICBbc2Vjb25kLCAxNSwgMTUgKiBkdXJhdGlvblNlY29uZF0sXG4gICAgW3NlY29uZCwgMzAsIDMwICogZHVyYXRpb25TZWNvbmRdLFxuICAgIFttaW51dGUsICAxLCAgICAgIGR1cmF0aW9uTWludXRlXSxcbiAgICBbbWludXRlLCAgNSwgIDUgKiBkdXJhdGlvbk1pbnV0ZV0sXG4gICAgW21pbnV0ZSwgMTUsIDE1ICogZHVyYXRpb25NaW51dGVdLFxuICAgIFttaW51dGUsIDMwLCAzMCAqIGR1cmF0aW9uTWludXRlXSxcbiAgICBbICBob3VyLCAgMSwgICAgICBkdXJhdGlvbkhvdXIgIF0sXG4gICAgWyAgaG91ciwgIDMsICAzICogZHVyYXRpb25Ib3VyICBdLFxuICAgIFsgIGhvdXIsICA2LCAgNiAqIGR1cmF0aW9uSG91ciAgXSxcbiAgICBbICBob3VyLCAxMiwgMTIgKiBkdXJhdGlvbkhvdXIgIF0sXG4gICAgWyAgIGRheSwgIDEsICAgICAgZHVyYXRpb25EYXkgICBdLFxuICAgIFsgICBkYXksICAyLCAgMiAqIGR1cmF0aW9uRGF5ICAgXSxcbiAgICBbICB3ZWVrLCAgMSwgICAgICBkdXJhdGlvbldlZWsgIF0sXG4gICAgWyBtb250aCwgIDEsICAgICAgZHVyYXRpb25Nb250aCBdLFxuICAgIFsgbW9udGgsICAzLCAgMyAqIGR1cmF0aW9uTW9udGggXSxcbiAgICBbICB5ZWFyLCAgMSwgICAgICBkdXJhdGlvblllYXIgIF1cbiAgXTtcblxuICBmdW5jdGlvbiB0aWNrRm9ybWF0KGRhdGUpIHtcbiAgICByZXR1cm4gKHNlY29uZChkYXRlKSA8IGRhdGUgPyBmb3JtYXRNaWxsaXNlY29uZFxuICAgICAgICA6IG1pbnV0ZShkYXRlKSA8IGRhdGUgPyBmb3JtYXRTZWNvbmRcbiAgICAgICAgOiBob3VyKGRhdGUpIDwgZGF0ZSA/IGZvcm1hdE1pbnV0ZVxuICAgICAgICA6IGRheShkYXRlKSA8IGRhdGUgPyBmb3JtYXRIb3VyXG4gICAgICAgIDogbW9udGgoZGF0ZSkgPCBkYXRlID8gKHdlZWsoZGF0ZSkgPCBkYXRlID8gZm9ybWF0RGF5IDogZm9ybWF0V2VlaylcbiAgICAgICAgOiB5ZWFyKGRhdGUpIDwgZGF0ZSA/IGZvcm1hdE1vbnRoXG4gICAgICAgIDogZm9ybWF0WWVhcikoZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiB0aWNrSW50ZXJ2YWwoaW50ZXJ2YWwsIHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgaWYgKGludGVydmFsID09IG51bGwpIGludGVydmFsID0gMTA7XG5cbiAgICAvLyBJZiBhIGRlc2lyZWQgdGljayBjb3VudCBpcyBzcGVjaWZpZWQsIHBpY2sgYSByZWFzb25hYmxlIHRpY2sgaW50ZXJ2YWxcbiAgICAvLyBiYXNlZCBvbiB0aGUgZXh0ZW50IG9mIHRoZSBkb21haW4gYW5kIGEgcm91Z2ggZXN0aW1hdGUgb2YgdGljayBzaXplLlxuICAgIC8vIE90aGVyd2lzZSwgYXNzdW1lIGludGVydmFsIGlzIGFscmVhZHkgYSB0aW1lIGludGVydmFsIGFuZCB1c2UgaXQuXG4gICAgaWYgKHR5cGVvZiBpbnRlcnZhbCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgdmFyIHRhcmdldCA9IE1hdGguYWJzKHN0b3AgLSBzdGFydCkgLyBpbnRlcnZhbCxcbiAgICAgICAgICBpID0gYmlzZWN0b3IoZnVuY3Rpb24oaSkgeyByZXR1cm4gaVsyXTsgfSkucmlnaHQodGlja0ludGVydmFscywgdGFyZ2V0KTtcbiAgICAgIGlmIChpID09PSB0aWNrSW50ZXJ2YWxzLmxlbmd0aCkge1xuICAgICAgICBzdGVwID0gdGlja1N0ZXAoc3RhcnQgLyBkdXJhdGlvblllYXIsIHN0b3AgLyBkdXJhdGlvblllYXIsIGludGVydmFsKTtcbiAgICAgICAgaW50ZXJ2YWwgPSB5ZWFyO1xuICAgICAgfSBlbHNlIGlmIChpKSB7XG4gICAgICAgIGkgPSB0aWNrSW50ZXJ2YWxzW3RhcmdldCAvIHRpY2tJbnRlcnZhbHNbaSAtIDFdWzJdIDwgdGlja0ludGVydmFsc1tpXVsyXSAvIHRhcmdldCA/IGkgLSAxIDogaV07XG4gICAgICAgIHN0ZXAgPSBpWzFdO1xuICAgICAgICBpbnRlcnZhbCA9IGlbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGVwID0gTWF0aC5tYXgodGlja1N0ZXAoc3RhcnQsIHN0b3AsIGludGVydmFsKSwgMSk7XG4gICAgICAgIGludGVydmFsID0gbWlsbGlzZWNvbmQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0ZXAgPT0gbnVsbCA/IGludGVydmFsIDogaW50ZXJ2YWwuZXZlcnkoc3RlcCk7XG4gIH1cblxuICBzY2FsZS5pbnZlcnQgPSBmdW5jdGlvbih5KSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKGludmVydCh5KSk7XG4gIH07XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gZG9tYWluKG1hcC5jYWxsKF8sIG51bWJlcikpIDogZG9tYWluKCkubWFwKGRhdGUpO1xuICB9O1xuXG4gIHNjYWxlLnRpY2tzID0gZnVuY3Rpb24oaW50ZXJ2YWwsIHN0ZXApIHtcbiAgICB2YXIgZCA9IGRvbWFpbigpLFxuICAgICAgICB0MCA9IGRbMF0sXG4gICAgICAgIHQxID0gZFtkLmxlbmd0aCAtIDFdLFxuICAgICAgICByID0gdDEgPCB0MCxcbiAgICAgICAgdDtcbiAgICBpZiAocikgdCA9IHQwLCB0MCA9IHQxLCB0MSA9IHQ7XG4gICAgdCA9IHRpY2tJbnRlcnZhbChpbnRlcnZhbCwgdDAsIHQxLCBzdGVwKTtcbiAgICB0ID0gdCA/IHQucmFuZ2UodDAsIHQxICsgMSkgOiBbXTsgLy8gaW5jbHVzaXZlIHN0b3BcbiAgICByZXR1cm4gciA/IHQucmV2ZXJzZSgpIDogdDtcbiAgfTtcblxuICBzY2FsZS50aWNrRm9ybWF0ID0gZnVuY3Rpb24oY291bnQsIHNwZWNpZmllcikge1xuICAgIHJldHVybiBzcGVjaWZpZXIgPT0gbnVsbCA/IHRpY2tGb3JtYXQgOiBmb3JtYXQoc3BlY2lmaWVyKTtcbiAgfTtcblxuICBzY2FsZS5uaWNlID0gZnVuY3Rpb24oaW50ZXJ2YWwsIHN0ZXApIHtcbiAgICB2YXIgZCA9IGRvbWFpbigpO1xuICAgIHJldHVybiAoaW50ZXJ2YWwgPSB0aWNrSW50ZXJ2YWwoaW50ZXJ2YWwsIGRbMF0sIGRbZC5sZW5ndGggLSAxXSwgc3RlcCkpXG4gICAgICAgID8gZG9tYWluKG5pY2UoZCwgaW50ZXJ2YWwpKVxuICAgICAgICA6IHNjYWxlO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgY2FsZW5kYXIoeWVhciwgbW9udGgsIHdlZWssIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBmb3JtYXQpKTtcbiAgfTtcblxuICByZXR1cm4gc2NhbGU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gY2FsZW5kYXIodGltZVllYXIsIHRpbWVNb250aCwgdGltZVdlZWssIHRpbWVEYXksIHRpbWVIb3VyLCB0aW1lTWludXRlLCB0aW1lU2Vjb25kLCB0aW1lTWlsbGlzZWNvbmQsIHRpbWVGb3JtYXQpLmRvbWFpbihbbmV3IERhdGUoMjAwMCwgMCwgMSksIG5ldyBEYXRlKDIwMDAsIDAsIDIpXSk7XG59XG4iLCJpbXBvcnQge2NhbGVuZGFyfSBmcm9tIFwiLi90aW1lXCI7XG5pbXBvcnQge3V0Y0Zvcm1hdH0gZnJvbSBcImQzLXRpbWUtZm9ybWF0XCI7XG5pbXBvcnQge3V0Y1llYXIsIHV0Y01vbnRoLCB1dGNXZWVrLCB1dGNEYXksIHV0Y0hvdXIsIHV0Y01pbnV0ZSwgdXRjU2Vjb25kLCB1dGNNaWxsaXNlY29uZH0gZnJvbSBcImQzLXRpbWVcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBjYWxlbmRhcih1dGNZZWFyLCB1dGNNb250aCwgdXRjV2VlaywgdXRjRGF5LCB1dGNIb3VyLCB1dGNNaW51dGUsIHV0Y1NlY29uZCwgdXRjTWlsbGlzZWNvbmQsIHV0Y0Zvcm1hdCkuZG9tYWluKFtEYXRlLlVUQygyMDAwLCAwLCAxKSwgRGF0ZS5VVEMoMjAwMCwgMCwgMildKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHMpIHtcbiAgcmV0dXJuIHMubWF0Y2goLy57Nn0vZykubWFwKGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gXCIjXCIgKyB4O1xuICB9KTtcbn1cbiIsImltcG9ydCBjb2xvcnMgZnJvbSBcIi4vY29sb3JzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNvbG9ycyhcIjFmNzdiNGZmN2YwZTJjYTAyY2Q2MjcyODk0NjdiZDhjNTY0YmUzNzdjMjdmN2Y3ZmJjYmQyMjE3YmVjZlwiKTtcbiIsImltcG9ydCBjb2xvcnMgZnJvbSBcIi4vY29sb3JzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNvbG9ycyhcIjM5M2I3OTUyNTRhMzZiNmVjZjljOWVkZTYzNzkzOThjYTI1MmI1Y2Y2YmNlZGI5YzhjNmQzMWJkOWUzOWU3YmE1MmU3Y2I5NDg0M2MzOWFkNDk0YWQ2NjE2YmU3OTY5YzdiNDE3M2E1NTE5NGNlNmRiZGRlOWVkNlwiKTtcbiIsImltcG9ydCBjb2xvcnMgZnJvbSBcIi4vY29sb3JzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNvbG9ycyhcIjMxODJiZDZiYWVkNjllY2FlMWM2ZGJlZmU2NTUwZGZkOGQzY2ZkYWU2YmZkZDBhMjMxYTM1NDc0YzQ3NmExZDk5YmM3ZTljMDc1NmJiMTllOWFjOGJjYmRkY2RhZGFlYjYzNjM2Mzk2OTY5NmJkYmRiZGQ5ZDlkOVwiKTtcbiIsImltcG9ydCBjb2xvcnMgZnJvbSBcIi4vY29sb3JzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNvbG9ycyhcIjFmNzdiNGFlYzdlOGZmN2YwZWZmYmI3ODJjYTAyYzk4ZGY4YWQ2MjcyOGZmOTg5Njk0NjdiZGM1YjBkNThjNTY0YmM0OWM5NGUzNzdjMmY3YjZkMjdmN2Y3ZmM3YzdjN2JjYmQyMmRiZGI4ZDE3YmVjZjllZGFlNVwiKTtcbiIsImltcG9ydCB7Y3ViZWhlbGl4fSBmcm9tIFwiZDMtY29sb3JcIjtcbmltcG9ydCB7aW50ZXJwb2xhdGVDdWJlaGVsaXhMb25nfSBmcm9tIFwiZDMtaW50ZXJwb2xhdGVcIjtcblxuZXhwb3J0IGRlZmF1bHQgaW50ZXJwb2xhdGVDdWJlaGVsaXhMb25nKGN1YmVoZWxpeCgzMDAsIDAuNSwgMC4wKSwgY3ViZWhlbGl4KC0yNDAsIDAuNSwgMS4wKSk7XG4iLCJpbXBvcnQge2N1YmVoZWxpeH0gZnJvbSBcImQzLWNvbG9yXCI7XG5pbXBvcnQge2ludGVycG9sYXRlQ3ViZWhlbGl4TG9uZ30gZnJvbSBcImQzLWludGVycG9sYXRlXCI7XG5cbmV4cG9ydCB2YXIgd2FybSA9IGludGVycG9sYXRlQ3ViZWhlbGl4TG9uZyhjdWJlaGVsaXgoLTEwMCwgMC43NSwgMC4zNSksIGN1YmVoZWxpeCg4MCwgMS41MCwgMC44KSk7XG5cbmV4cG9ydCB2YXIgY29vbCA9IGludGVycG9sYXRlQ3ViZWhlbGl4TG9uZyhjdWJlaGVsaXgoMjYwLCAwLjc1LCAwLjM1KSwgY3ViZWhlbGl4KDgwLCAxLjUwLCAwLjgpKTtcblxudmFyIHJhaW5ib3cgPSBjdWJlaGVsaXgoKTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odCkge1xuICBpZiAodCA8IDAgfHwgdCA+IDEpIHQgLT0gTWF0aC5mbG9vcih0KTtcbiAgdmFyIHRzID0gTWF0aC5hYnModCAtIDAuNSk7XG4gIHJhaW5ib3cuaCA9IDM2MCAqIHQgLSAxMDA7XG4gIHJhaW5ib3cucyA9IDEuNSAtIDEuNSAqIHRzO1xuICByYWluYm93LmwgPSAwLjggLSAwLjkgKiB0cztcbiAgcmV0dXJuIHJhaW5ib3cgKyBcIlwiO1xufVxuIiwiaW1wb3J0IGNvbG9ycyBmcm9tIFwiLi9jb2xvcnNcIjtcblxuZnVuY3Rpb24gcmFtcChyYW5nZSkge1xuICB2YXIgbiA9IHJhbmdlLmxlbmd0aDtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gcmFuZ2VbTWF0aC5tYXgoMCwgTWF0aC5taW4obiAtIDEsIE1hdGguZmxvb3IodCAqIG4pKSldO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCByYW1wKGNvbG9ycyhcIjQ0MDE1NDQ0MDI1NjQ1MDQ1NzQ1MDU1OTQ2MDc1YTQ2MDg1YzQ2MGE1ZDQ2MGI1ZTQ3MGQ2MDQ3MGU2MTQ3MTA2MzQ3MTE2NDQ3MTM2NTQ4MTQ2NzQ4MTY2ODQ4MTc2OTQ4MTg2YTQ4MWE2YzQ4MWI2ZDQ4MWM2ZTQ4MWQ2ZjQ4MWY3MDQ4MjA3MTQ4MjE3MzQ4MjM3NDQ4MjQ3NTQ4MjU3NjQ4MjY3NzQ4Mjg3ODQ4Mjk3OTQ3MmE3YTQ3MmM3YTQ3MmQ3YjQ3MmU3YzQ3MmY3ZDQ2MzA3ZTQ2MzI3ZTQ2MzM3ZjQ2MzQ4MDQ1MzU4MTQ1Mzc4MTQ1Mzg4MjQ0Mzk4MzQ0M2E4MzQ0M2I4NDQzM2Q4NDQzM2U4NTQyM2Y4NTQyNDA4NjQyNDE4NjQxNDI4NzQxNDQ4NzQwNDU4ODQwNDY4ODNmNDc4ODNmNDg4OTNlNDk4OTNlNGE4OTNlNGM4YTNkNGQ4YTNkNGU4YTNjNGY4YTNjNTA4YjNiNTE4YjNiNTI4YjNhNTM4YjNhNTQ4YzM5NTU4YzM5NTY4YzM4NTg4YzM4NTk4YzM3NWE4YzM3NWI4ZDM2NWM4ZDM2NWQ4ZDM1NWU4ZDM1NWY4ZDM0NjA4ZDM0NjE4ZDMzNjI4ZDMzNjM4ZDMyNjQ4ZTMyNjU4ZTMxNjY4ZTMxNjc4ZTMxNjg4ZTMwNjk4ZTMwNmE4ZTJmNmI4ZTJmNmM4ZTJlNmQ4ZTJlNmU4ZTJlNmY4ZTJkNzA4ZTJkNzE4ZTJjNzE4ZTJjNzI4ZTJjNzM4ZTJiNzQ4ZTJiNzU4ZTJhNzY4ZTJhNzc4ZTJhNzg4ZTI5Nzk4ZTI5N2E4ZTI5N2I4ZTI4N2M4ZTI4N2Q4ZTI3N2U4ZTI3N2Y4ZTI3ODA4ZTI2ODE4ZTI2ODI4ZTI2ODI4ZTI1ODM4ZTI1ODQ4ZTI1ODU4ZTI0ODY4ZTI0ODc4ZTIzODg4ZTIzODk4ZTIzOGE4ZDIyOGI4ZDIyOGM4ZDIyOGQ4ZDIxOGU4ZDIxOGY4ZDIxOTA4ZDIxOTE4YzIwOTI4YzIwOTI4YzIwOTM4YzFmOTQ4YzFmOTU4YjFmOTY4YjFmOTc4YjFmOTg4YjFmOTk4YTFmOWE4YTFlOWI4YTFlOWM4OTFlOWQ4OTFmOWU4OTFmOWY4ODFmYTA4ODFmYTE4ODFmYTE4NzFmYTI4NzIwYTM4NjIwYTQ4NjIxYTU4NTIxYTY4NTIyYTc4NTIyYTg4NDIzYTk4MzI0YWE4MzI1YWI4MjI1YWM4MjI2YWQ4MTI3YWQ4MTI4YWU4MDI5YWY3ZjJhYjA3ZjJjYjE3ZTJkYjI3ZDJlYjM3YzJmYjQ3YzMxYjU3YjMyYjY3YTM0YjY3OTM1Yjc3OTM3Yjg3ODM4Yjk3NzNhYmE3NjNiYmI3NTNkYmM3NDNmYmM3MzQwYmQ3MjQyYmU3MTQ0YmY3MDQ2YzA2ZjQ4YzE2ZTRhYzE2ZDRjYzI2YzRlYzM2YjUwYzQ2YTUyYzU2OTU0YzU2ODU2YzY2NzU4Yzc2NTVhYzg2NDVjYzg2MzVlYzk2MjYwY2E2MDYzY2I1ZjY1Y2I1ZTY3Y2M1YzY5Y2Q1YjZjY2Q1YTZlY2U1ODcwY2Y1NzczZDA1Njc1ZDA1NDc3ZDE1MzdhZDE1MTdjZDI1MDdmZDM0ZTgxZDM0ZDg0ZDQ0Yjg2ZDU0OTg5ZDU0ODhiZDY0NjhlZDY0NTkwZDc0MzkzZDc0MTk1ZDg0MDk4ZDgzZTliZDkzYzlkZDkzYmEwZGEzOWEyZGEzN2E1ZGIzNmE4ZGIzNGFhZGMzMmFkZGMzMGIwZGQyZmIyZGQyZGI1ZGUyYmI4ZGUyOWJhZGUyOGJkZGYyNmMwZGYyNWMyZGYyM2M1ZTAyMWM4ZTAyMGNhZTExZmNkZTExZGQwZTExY2QyZTIxYmQ1ZTIxYWQ4ZTIxOWRhZTMxOWRkZTMxOGRmZTMxOGUyZTQxOGU1ZTQxOWU3ZTQxOWVhZTUxYWVjZTUxYmVmZTUxY2YxZTUxZGY0ZTYxZWY2ZTYyMGY4ZTYyMWZiZTcyM2ZkZTcyNVwiKSk7XG5cbmV4cG9ydCB2YXIgbWFnbWEgPSByYW1wKGNvbG9ycyhcIjAwMDAwNDAxMDAwNTAxMDEwNjAxMDEwODAyMDEwOTAyMDIwYjAyMDIwZDAzMDMwZjAzMDMxMjA0MDQxNDA1MDQxNjA2MDUxODA2MDUxYTA3MDYxYzA4MDcxZTA5MDcyMDBhMDgyMjBiMDkyNDBjMDkyNjBkMGEyOTBlMGIyYjEwMGIyZDExMGMyZjEyMGQzMTEzMGQzNDE0MGUzNjE1MGUzODE2MGYzYjE4MGYzZDE5MTAzZjFhMTA0MjFjMTA0NDFkMTE0NzFlMTE0OTIwMTE0YjIxMTE0ZTIyMTE1MDI0MTI1MzI1MTI1NTI3MTI1ODI5MTE1YTJhMTE1YzJjMTE1ZjJkMTE2MTJmMTE2MzMxMTE2NTMzMTA2NzM0MTA2OTM2MTA2YjM4MTA2YzM5MGY2ZTNiMGY3MDNkMGY3MTNmMGY3MjQwMGY3NDQyMGY3NTQ0MGY3NjQ1MTA3NzQ3MTA3ODQ5MTA3ODRhMTA3OTRjMTE3YTRlMTE3YjRmMTI3YjUxMTI3YzUyMTM3YzU0MTM3ZDU2MTQ3ZDU3MTU3ZTU5MTU3ZTVhMTY3ZTVjMTY3ZjVkMTc3ZjVmMTg3ZjYwMTg4MDYyMTk4MDY0MWE4MDY1MWE4MDY3MWI4MDY4MWM4MTZhMWM4MTZiMWQ4MTZkMWQ4MTZlMWU4MTcwMWY4MTcyMWY4MTczMjA4MTc1MjE4MTc2MjE4MTc4MjI4MTc5MjI4MjdiMjM4MjdjMjM4MjdlMjQ4MjgwMjU4MjgxMjU4MTgzMjY4MTg0MjY4MTg2Mjc4MTg4Mjc4MTg5Mjg4MThiMjk4MThjMjk4MThlMmE4MTkwMmE4MTkxMmI4MTkzMmI4MDk0MmM4MDk2MmM4MDk4MmQ4MDk5MmQ4MDliMmU3ZjljMmU3ZjllMmY3ZmEwMmY3ZmExMzA3ZWEzMzA3ZWE1MzE3ZWE2MzE3ZGE4MzI3ZGFhMzM3ZGFiMzM3Y2FkMzQ3Y2FlMzQ3YmIwMzU3YmIyMzU3YmIzMzY3YWI1MzY3YWI3Mzc3OWI4Mzc3OWJhMzg3OGJjMzk3OGJkMzk3N2JmM2E3N2MwM2E3NmMyM2I3NWM0M2M3NWM1M2M3NGM3M2Q3M2M4M2U3M2NhM2U3MmNjM2Y3MWNkNDA3MWNmNDA3MGQwNDE2ZmQyNDI2ZmQzNDM2ZWQ1NDQ2ZGQ2NDU2Y2Q4NDU2Y2Q5NDY2YmRiNDc2YWRjNDg2OWRlNDk2OGRmNGE2OGUwNGM2N2UyNGQ2NmUzNGU2NWU0NGY2NGU1NTA2NGU3NTI2M2U4NTM2MmU5NTQ2MmVhNTY2MWViNTc2MGVjNTg2MGVkNWE1ZmVlNWI1ZWVmNWQ1ZWYwNWY1ZWYxNjA1ZGYyNjI1ZGYyNjQ1Y2YzNjU1Y2Y0Njc1Y2Y0Njk1Y2Y1NmI1Y2Y2NmM1Y2Y2NmU1Y2Y3NzA1Y2Y3NzI1Y2Y4NzQ1Y2Y4NzY1Y2Y5Nzg1ZGY5Nzk1ZGY5N2I1ZGZhN2Q1ZWZhN2Y1ZWZhODE1ZmZiODM1ZmZiODU2MGZiODc2MWZjODk2MWZjOGE2MmZjOGM2M2ZjOGU2NGZjOTA2NWZkOTI2NmZkOTQ2N2ZkOTY2OGZkOTg2OWZkOWE2YWZkOWI2YmZlOWQ2Y2ZlOWY2ZGZlYTE2ZWZlYTM2ZmZlYTU3MWZlYTc3MmZlYTk3M2ZlYWE3NGZlYWM3NmZlYWU3N2ZlYjA3OGZlYjI3YWZlYjQ3YmZlYjY3Y2ZlYjc3ZWZlYjk3ZmZlYmI4MWZlYmQ4MmZlYmY4NGZlYzE4NWZlYzI4N2ZlYzQ4OGZlYzY4YWZlYzg4Y2ZlY2E4ZGZlY2M4ZmZlY2Q5MGZlY2Y5MmZlZDE5NGZlZDM5NWZlZDU5N2ZlZDc5OWZlZDg5YWZkZGE5Y2ZkZGM5ZWZkZGVhMGZkZTBhMWZkZTJhM2ZkZTNhNWZkZTVhN2ZkZTdhOWZkZTlhYWZkZWJhY2ZjZWNhZWZjZWViMGZjZjBiMmZjZjJiNGZjZjRiNmZjZjZiOGZjZjdiOWZjZjliYmZjZmJiZGZjZmRiZlwiKSk7XG5cbmV4cG9ydCB2YXIgaW5mZXJubyA9IHJhbXAoY29sb3JzKFwiMDAwMDA0MDEwMDA1MDEwMTA2MDEwMTA4MDIwMTBhMDIwMjBjMDIwMjBlMDMwMjEwMDQwMzEyMDQwMzE0MDUwNDE3MDYwNDE5MDcwNTFiMDgwNTFkMDkwNjFmMGEwNzIyMGIwNzI0MGMwODI2MGQwODI5MGUwOTJiMTAwOTJkMTEwYTMwMTIwYTMyMTQwYjM0MTUwYjM3MTYwYjM5MTgwYzNjMTkwYzNlMWIwYzQxMWMwYzQzMWUwYzQ1MWYwYzQ4MjEwYzRhMjMwYzRjMjQwYzRmMjYwYzUxMjgwYjUzMjkwYjU1MmIwYjU3MmQwYjU5MmYwYTViMzEwYTVjMzIwYTVlMzQwYTVmMzYwOTYxMzgwOTYyMzkwOTYzM2IwOTY0M2QwOTY1M2UwOTY2NDAwYTY3NDIwYTY4NDQwYTY4NDUwYTY5NDcwYjZhNDkwYjZhNGEwYzZiNGMwYzZiNGQwZDZjNGYwZDZjNTEwZTZjNTIwZTZkNTQwZjZkNTUwZjZkNTcxMDZlNTkxMDZlNWExMTZlNWMxMjZlNWQxMjZlNWYxMzZlNjExMzZlNjIxNDZlNjQxNTZlNjUxNTZlNjcxNjZlNjkxNjZlNmExNzZlNmMxODZlNmQxODZlNmYxOTZlNzExOTZlNzIxYTZlNzQxYTZlNzUxYjZlNzcxYzZkNzgxYzZkN2ExZDZkN2MxZDZkN2QxZTZkN2YxZTZjODAxZjZjODIyMDZjODQyMDZiODUyMTZiODcyMTZiODgyMjZhOGEyMjZhOGMyMzY5OGQyMzY5OGYyNDY5OTAyNTY4OTIyNTY4OTMyNjY3OTUyNjY3OTcyNzY2OTgyNzY2OWEyODY1OWIyOTY0OWQyOTY0OWYyYTYzYTAyYTYzYTIyYjYyYTMyYzYxYTUyYzYwYTYyZDYwYTgyZTVmYTkyZTVlYWIyZjVlYWQzMDVkYWUzMDVjYjAzMTViYjEzMjVhYjMzMjVhYjQzMzU5YjYzNDU4YjczNTU3YjkzNTU2YmEzNjU1YmMzNzU0YmQzODUzYmYzOTUyYzAzYTUxYzEzYTUwYzMzYjRmYzQzYzRlYzYzZDRkYzczZTRjYzgzZjRiY2E0MDRhY2I0MTQ5Y2M0MjQ4Y2U0MzQ3Y2Y0NDQ2ZDA0NTQ1ZDI0NjQ0ZDM0NzQzZDQ0ODQyZDU0YTQxZDc0YjNmZDg0YzNlZDk0ZDNkZGE0ZTNjZGI1MDNiZGQ1MTNhZGU1MjM4ZGY1MzM3ZTA1NTM2ZTE1NjM1ZTI1NzM0ZTM1OTMzZTQ1YTMxZTU1YzMwZTY1ZDJmZTc1ZTJlZTg2MDJkZTk2MTJiZWE2MzJhZWI2NDI5ZWI2NjI4ZWM2NzI2ZWQ2OTI1ZWU2YTI0ZWY2YzIzZWY2ZTIxZjA2ZjIwZjE3MTFmZjE3MzFkZjI3NDFjZjM3NjFiZjM3ODE5ZjQ3OTE4ZjU3YjE3ZjU3ZDE1ZjY3ZTE0ZjY4MDEzZjc4MjEyZjc4NDEwZjg4NTBmZjg4NzBlZjg4OTBjZjk4YjBiZjk4YzBhZjk4ZTA5ZmE5MDA4ZmE5MjA3ZmE5NDA3ZmI5NjA2ZmI5NzA2ZmI5OTA2ZmI5YjA2ZmI5ZDA3ZmM5ZjA3ZmNhMTA4ZmNhMzA5ZmNhNTBhZmNhNjBjZmNhODBkZmNhYTBmZmNhYzExZmNhZTEyZmNiMDE0ZmNiMjE2ZmNiNDE4ZmJiNjFhZmJiODFkZmJiYTFmZmJiYzIxZmJiZTIzZmFjMDI2ZmFjMjI4ZmFjNDJhZmFjNjJkZjljNzJmZjljOTMyZjljYjM1ZjhjZDM3ZjhjZjNhZjdkMTNkZjdkMzQwZjZkNTQzZjZkNzQ2ZjVkOTQ5ZjVkYjRjZjRkZDRmZjRkZjUzZjRlMTU2ZjNlMzVhZjNlNTVkZjJlNjYxZjJlODY1ZjJlYTY5ZjFlYzZkZjFlZDcxZjFlZjc1ZjFmMTc5ZjJmMjdkZjJmNDgyZjNmNTg2ZjNmNjhhZjRmODhlZjVmOTkyZjZmYTk2ZjhmYjlhZjlmYzlkZmFmZGExZmNmZmE0XCIpKTtcblxuZXhwb3J0IHZhciBwbGFzbWEgPSByYW1wKGNvbG9ycyhcIjBkMDg4NzEwMDc4ODEzMDc4OTE2MDc4YTE5MDY4YzFiMDY4ZDFkMDY4ZTIwMDY4ZjIyMDY5MDI0MDY5MTI2MDU5MTI4MDU5MjJhMDU5MzJjMDU5NDJlMDU5NTJmMDU5NjMxMDU5NzMzMDU5NzM1MDQ5ODM3MDQ5OTM4MDQ5YTNhMDQ5YTNjMDQ5YjNlMDQ5YzNmMDQ5YzQxMDQ5ZDQzMDM5ZTQ0MDM5ZTQ2MDM5ZjQ4MDM5ZjQ5MDNhMDRiMDNhMTRjMDJhMTRlMDJhMjUwMDJhMjUxMDJhMzUzMDJhMzU1MDJhNDU2MDFhNDU4MDFhNDU5MDFhNTViMDFhNTVjMDFhNjVlMDFhNjYwMDFhNjYxMDBhNzYzMDBhNzY0MDBhNzY2MDBhNzY3MDBhODY5MDBhODZhMDBhODZjMDBhODZlMDBhODZmMDBhODcxMDBhODcyMDFhODc0MDFhODc1MDFhODc3MDFhODc4MDFhODdhMDJhODdiMDJhODdkMDNhODdlMDNhODgwMDRhODgxMDRhNzgzMDVhNzg0MDVhNzg2MDZhNjg3MDdhNjg4MDhhNjhhMDlhNThiMGFhNThkMGJhNThlMGNhNDhmMGRhNDkxMGVhMzkyMGZhMzk0MTBhMjk1MTFhMTk2MTNhMTk4MTRhMDk5MTU5ZjlhMTY5ZjljMTc5ZTlkMTg5ZDllMTk5ZGEwMWE5Y2ExMWI5YmEyMWQ5YWEzMWU5YWE1MWY5OWE2MjA5OGE3MjE5N2E4MjI5NmFhMjM5NWFiMjQ5NGFjMjY5NGFkMjc5M2FlMjg5MmIwMjk5MWIxMmE5MGIyMmI4ZmIzMmM4ZWI0MmU4ZGI1MmY4Y2I2MzA4YmI3MzE4YWI4MzI4OWJhMzM4OGJiMzQ4OGJjMzU4N2JkMzc4NmJlMzg4NWJmMzk4NGMwM2E4M2MxM2I4MmMyM2M4MWMzM2Q4MGM0M2U3ZmM1NDA3ZWM2NDE3ZGM3NDI3Y2M4NDM3YmM5NDQ3YWNhNDU3YWNiNDY3OWNjNDc3OGNjNDk3N2NkNGE3NmNlNGI3NWNmNGM3NGQwNGQ3M2QxNGU3MmQyNGY3MWQzNTE3MWQ0NTI3MGQ1NTM2ZmQ1NTQ2ZWQ2NTU2ZGQ3NTY2Y2Q4NTc2YmQ5NTg2YWRhNWE2YWRhNWI2OWRiNWM2OGRjNWQ2N2RkNWU2NmRlNWY2NWRlNjE2NGRmNjI2M2UwNjM2M2UxNjQ2MmUyNjU2MWUyNjY2MGUzNjg1ZmU0Njk1ZWU1NmE1ZGU1NmI1ZGU2NmM1Y2U3NmU1YmU3NmY1YWU4NzA1OWU5NzE1OGU5NzI1N2VhNzQ1N2ViNzU1NmViNzY1NWVjNzc1NGVkNzk1M2VkN2E1MmVlN2I1MWVmN2M1MWVmN2U1MGYwN2Y0ZmYwODA0ZWYxODE0ZGYxODM0Y2YyODQ0YmYzODU0YmYzODc0YWY0ODg0OWY0ODk0OGY1OGI0N2Y1OGM0NmY2OGQ0NWY2OGY0NGY3OTA0NGY3OTE0M2Y3OTM0MmY4OTQ0MWY4OTU0MGY5OTczZmY5OTgzZWY5OWEzZWZhOWIzZGZhOWMzY2ZhOWUzYmZiOWYzYWZiYTEzOWZiYTIzOGZjYTMzOGZjYTUzN2ZjYTYzNmZjYTgzNWZjYTkzNGZkYWIzM2ZkYWMzM2ZkYWUzMmZkYWYzMWZkYjEzMGZkYjIyZmZkYjQyZmZkYjUyZWZlYjcyZGZlYjgyY2ZlYmEyY2ZlYmIyYmZlYmQyYWZlYmUyYWZlYzAyOWZkYzIyOWZkYzMyOGZkYzUyN2ZkYzYyN2ZkYzgyN2ZkY2EyNmZkY2IyNmZjY2QyNWZjY2UyNWZjZDAyNWZjZDIyNWZiZDMyNGZiZDUyNGZiZDcyNGZhZDgyNGZhZGEyNGY5ZGMyNGY5ZGQyNWY4ZGYyNWY4ZTEyNWY3ZTIyNWY3ZTQyNWY2ZTYyNmY2ZTgyNmY1ZTkyNmY1ZWIyN2Y0ZWQyN2YzZWUyN2YzZjAyN2YyZjIyN2YxZjQyNmYxZjUyNWYwZjcyNGYwZjkyMVwiKSk7XG4iLCJpbXBvcnQge2xpbmVhcmlzaH0gZnJvbSBcIi4vbGluZWFyXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNlcXVlbnRpYWwoaW50ZXJwb2xhdG9yKSB7XG4gIHZhciB4MCA9IDAsXG4gICAgICB4MSA9IDEsXG4gICAgICBjbGFtcCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICB2YXIgdCA9ICh4IC0geDApIC8gKHgxIC0geDApO1xuICAgIHJldHVybiBpbnRlcnBvbGF0b3IoY2xhbXAgPyBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCB0KSkgOiB0KTtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4MCA9ICtfWzBdLCB4MSA9ICtfWzFdLCBzY2FsZSkgOiBbeDAsIHgxXTtcbiAgfTtcblxuICBzY2FsZS5jbGFtcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjbGFtcCA9ICEhXywgc2NhbGUpIDogY2xhbXA7XG4gIH07XG5cbiAgc2NhbGUuaW50ZXJwb2xhdG9yID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGludGVycG9sYXRvciA9IF8sIHNjYWxlKSA6IGludGVycG9sYXRvcjtcbiAgfTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNlcXVlbnRpYWwoaW50ZXJwb2xhdG9yKS5kb21haW4oW3gwLCB4MV0pLmNsYW1wKGNsYW1wKTtcbiAgfTtcblxuICByZXR1cm4gbGluZWFyaXNoKHNjYWxlKTtcbn1cbiIsImV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgc2NhbGVCYW5kLFxuICBwb2ludCBhcyBzY2FsZVBvaW50XG59IGZyb20gXCIuL3NyYy9iYW5kXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgc2NhbGVJZGVudGl0eVxufSBmcm9tIFwiLi9zcmMvaWRlbnRpdHlcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyBzY2FsZUxpbmVhclxufSBmcm9tIFwiLi9zcmMvbGluZWFyXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgc2NhbGVMb2dcbn0gZnJvbSBcIi4vc3JjL2xvZ1wiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIHNjYWxlT3JkaW5hbCxcbiAgaW1wbGljaXQgYXMgc2NhbGVJbXBsaWNpdFxufSBmcm9tIFwiLi9zcmMvb3JkaW5hbFwiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIHNjYWxlUG93LFxuICBzcXJ0IGFzIHNjYWxlU3FydFxufSBmcm9tIFwiLi9zcmMvcG93XCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgc2NhbGVRdWFudGlsZVxufSBmcm9tIFwiLi9zcmMvcXVhbnRpbGVcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyBzY2FsZVF1YW50aXplXG59IGZyb20gXCIuL3NyYy9xdWFudGl6ZVwiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIHNjYWxlVGhyZXNob2xkXG59IGZyb20gXCIuL3NyYy90aHJlc2hvbGRcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyBzY2FsZVRpbWVcbn0gZnJvbSBcIi4vc3JjL3RpbWVcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyBzY2FsZVV0Y1xufSBmcm9tIFwiLi9zcmMvdXRjVGltZVwiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIHNjaGVtZUNhdGVnb3J5MTBcbn0gZnJvbSBcIi4vc3JjL2NhdGVnb3J5MTBcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyBzY2hlbWVDYXRlZ29yeTIwYlxufSBmcm9tIFwiLi9zcmMvY2F0ZWdvcnkyMGJcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyBzY2hlbWVDYXRlZ29yeTIwY1xufSBmcm9tIFwiLi9zcmMvY2F0ZWdvcnkyMGNcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyBzY2hlbWVDYXRlZ29yeTIwXG59IGZyb20gXCIuL3NyYy9jYXRlZ29yeTIwXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgaW50ZXJwb2xhdGVDdWJlaGVsaXhEZWZhdWx0XG59IGZyb20gXCIuL3NyYy9jdWJlaGVsaXhcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZVJhaW5ib3csXG4gIHdhcm0gYXMgaW50ZXJwb2xhdGVXYXJtLFxuICBjb29sIGFzIGludGVycG9sYXRlQ29vbFxufSBmcm9tIFwiLi9zcmMvcmFpbmJvd1wiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIGludGVycG9sYXRlVmlyaWRpcyxcbiAgbWFnbWEgYXMgaW50ZXJwb2xhdGVNYWdtYSxcbiAgaW5mZXJubyBhcyBpbnRlcnBvbGF0ZUluZmVybm8sXG4gIHBsYXNtYSBhcyBpbnRlcnBvbGF0ZVBsYXNtYVxufSBmcm9tIFwiLi9zcmMvdmlyaWRpc1wiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIHNjYWxlU2VxdWVudGlhbFxufSBmcm9tIFwiLi9zcmMvc2VxdWVudGlhbFwiO1xuIiwiaW1wb3J0IHsgaGlzdG9ncmFtIGFzIGQzSGlzdG9ncmFtLCBleHRlbnQgYXMgZDNFeHRlbnQgfSBmcm9tICdkMy1hcnJheSc7XG5pbXBvcnQgeyBzY2FsZUxpbmVhciB9IGZyb20gJ2QzLXNjYWxlJztcbnZhciBERUZBVUxUX0JJTl9DT1VOVCA9IDEwO1xuLypcbiAqIGhhbmRsZXMgYmlubmluZyBvZiBudW1lcmljIGRhdGEgYnkgc2VyaWVzIGluZGV4XG4gKiBpZiBiaW5WYWx1ZXMgYXJlIHBhc3NlZCwgaWdub3JlcyBvdGhlciBiaW4gdmFsdWVzIHRoYXQgYXJlIGVuY291bnRlcmVkXG4gKlxuICogcmV0dXJucyBhbiBvYmplY3Qgb2YgYmlucyBrZXllZCBvbiBzZXJpZXMgaW5kZXggd2l0aCB0aGUgZm9sbG93aW5nIHNoYXBlXG4gKiB7XG4gKiAgIFtzZXJpZXNJZHhdOiBBcnJheTxPYmplY3R7XG4gKiAgICAgIGJpbjA6IFN0cmluZyxcbiAqICAgICAgYmluMTogU3RyaW5nLFxuICogICAgICBkYXRhOiBBcnJheTxkYXR1bT4sXG4gKiAgICAgIGNvdW50OiBOdW1iZXIsXG4gKiAgICAgIGlkOiBTdHJpbmcsXG4gKiAgICB9PixcbiAqIH1cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBiaW5OdW1lcmljRGF0YShfcmVmKSB7XG4gIHZhciBhbGxEYXRhID0gX3JlZi5hbGxEYXRhLFxuICAgICAgX3JlZiRiaW5Db3VudCA9IF9yZWYuYmluQ291bnQsXG4gICAgICB1c2VyQmluQ291bnQgPSBfcmVmJGJpbkNvdW50ID09PSB2b2lkIDAgPyBERUZBVUxUX0JJTl9DT1VOVCA6IF9yZWYkYmluQ291bnQsXG4gICAgICBiaW5WYWx1ZXMgPSBfcmVmLmJpblZhbHVlcyxcbiAgICAgIGxpbWl0cyA9IF9yZWYubGltaXRzLFxuICAgICAgcmF3RGF0YUJ5SW5kZXggPSBfcmVmLnJhd0RhdGFCeUluZGV4LFxuICAgICAgdmFsdWVBY2Nlc3NvciA9IF9yZWYudmFsdWVBY2Nlc3NvcjtcbiAgdmFyIGJpbkNvdW50ID0gQXJyYXkuaXNBcnJheShiaW5WYWx1ZXMpID8gYmluVmFsdWVzLmxlbmd0aCA6IHVzZXJCaW5Db3VudDtcbiAgdmFyIGJpbnNCeUluZGV4ID0ge307XG4gIHZhciBoaXN0b2dyYW0gPSBkM0hpc3RvZ3JhbSgpO1xuICB2YXIgZXh0ZW50ID0gZDNFeHRlbnQoYWxsRGF0YSwgdmFsdWVBY2Nlc3Nvcik7XG5cbiAgaWYgKGJpblZhbHVlcykge1xuICAgIC8vIGFjY291bnQgZm9yIGV4dGVudCBvZiBiaW5WYWx1ZXMgaWYgcGFzc2VkXG4gICAgdmFyIGJpbkV4dGVudCA9IGQzRXh0ZW50KGJpblZhbHVlcyk7XG4gICAgZXh0ZW50ID0gW01hdGgubWluKGJpbkV4dGVudFswXSwgZXh0ZW50WzBdKSwgTWF0aC5tYXgoYmluRXh0ZW50WzFdLCBleHRlbnRbMV0pXTtcbiAgfVxuXG4gIHZhciBzY2FsZSA9IHNjYWxlTGluZWFyKCkuZG9tYWluKGV4dGVudCkubmljZShiaW5Db3VudCk7XG4gIGhpc3RvZ3JhbS5kb21haW4obGltaXRzIHx8IHNjYWxlLmRvbWFpbigpKS50aHJlc2hvbGRzKGJpblZhbHVlcyB8fCBzY2FsZS50aWNrcyhiaW5Db3VudCkpO1xuICBPYmplY3Qua2V5cyhyYXdEYXRhQnlJbmRleCkuZm9yRWFjaChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICB2YXIgZGF0YSA9IHJhd0RhdGFCeUluZGV4W2luZGV4XTtcbiAgICB2YXIgc2VyaWVzQmlucyA9IGhpc3RvZ3JhbS52YWx1ZSh2YWx1ZUFjY2Vzc29yKShkYXRhKTsgLy8gaWYgdGhlIGxhc3QgYmluIGVxdWFscyB0aGUgdXBwZXIgYm91bmQgb2YgdGhlIHNlY29uZCB0byBsYXN0IGJpbiwgY29tYmluZSB0aGVtXG4gICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1hcnJheS9pc3N1ZXMvNDYjaXNzdWVjb21tZW50LTI2OTg3MzY0NFxuXG4gICAgdmFyIGxhc3RCaW5JbmRleCA9IHNlcmllc0JpbnMubGVuZ3RoIC0gMTtcbiAgICB2YXIgbGFzdEJpbiA9IHNlcmllc0JpbnNbbGFzdEJpbkluZGV4XTtcbiAgICB2YXIgbmV4dFRvTGFzdEJpbiA9IHNlcmllc0JpbnNbbGFzdEJpbkluZGV4IC0gMV07XG4gICAgdmFyIHNob3VsZENvbWJpbmVFbmRCaW5zID0gbmV4dFRvTGFzdEJpbiAmJiBuZXh0VG9MYXN0QmluLngxID09PSBsYXN0QmluLngwICYmIGxhc3RCaW4ueDEgPT09IGxhc3RCaW4ueDA7XG4gICAgdmFyIGZpbHRlcmVkQmlucyA9IHNob3VsZENvbWJpbmVFbmRCaW5zID8gc2VyaWVzQmlucy5zbGljZSgwLCAtMSkgOiBzZXJpZXNCaW5zO1xuICAgIGJpbnNCeUluZGV4W2luZGV4XSA9IGZpbHRlcmVkQmlucy5tYXAoZnVuY3Rpb24gKGJpbiwgaSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYmluMDogYmluLngwLFxuICAgICAgICAvLyBpZiB0aGUgdXBwZXIgbGltaXQgZXF1YWxzIHRoZSBsb3dlciBvbmUsIHVzZSB0aGUgZGVsdGEgYmV0d2VlbiB0aGlzIGJpbiBhbmQgdGhlIGxhc3RcbiAgICAgICAgYmluMTogYmluLngwID09PSBiaW4ueDEgPyBpID4gMCAmJiBiaW4ueDAgKyBiaW4ueDAgLSBzZXJpZXNCaW5zW2kgLSAxXS54MCB8fCBiaW4ueDEgKyAxIDogYmluLngxLFxuICAgICAgICBkYXRhOiBbXS5jb25jYXQoYmluKS5jb25jYXQoc2hvdWxkQ29tYmluZUVuZEJpbnMgJiYgKHNob3VsZENvbWJpbmVFbmRCaW5zICYmIGkgPT09IGxhc3RCaW5JbmRleCAtIDEgPyBsYXN0QmluIDogW10pKSxcbiAgICAgICAgLy8gaWYgdGhlIGxhc3QgYmluIHdhcyBpbmNsdXNpdmUgLyBvbWl0dGVkLCBhZGQgaXRzIGNvdW50IHRvIHRoZSBsYXN0IGJpblxuICAgICAgICBjb3VudDogYmluLmxlbmd0aCArIChzaG91bGRDb21iaW5lRW5kQmlucyAmJiBpID09PSBsYXN0QmluSW5kZXggLSAxID8gbGFzdEJpbi5sZW5ndGggfHwgMCA6IDApLFxuICAgICAgICBpZDogaS50b1N0cmluZygpXG4gICAgICB9O1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGJpbnNCeUluZGV4O1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNhc2VJbnNlbnNpdGl2ZVNvcnQoYSwgYikge1xuICBpZiAoIWEudG9Mb3dlckNhc2UgfHwgIWIudG9Mb3dlckNhc2UpIHJldHVybiBhIC0gYjtcbiAgaWYgKGEudG9Mb3dlckNhc2UoKSA8IGIudG9Mb3dlckNhc2UoKSkgcmV0dXJuIC0xO1xuICBpZiAoYS50b0xvd2VyQ2FzZSgpID4gYi50b0xvd2VyQ2FzZSgpKSByZXR1cm4gMTtcbiAgcmV0dXJuIDA7XG59IiwiaW1wb3J0IGNhc2VJbnNlbnNpdGl2ZVNvcnQgZnJvbSAnLi9jYXNlSW5zZW5zaXRpdmVTb3J0JztcblxudmFyIHNvcnRCaW5zID0gZnVuY3Rpb24gc29ydEJpbnMoYSwgYikge1xuICByZXR1cm4gY2FzZUluc2Vuc2l0aXZlU29ydChhLmJpbiwgYi5iaW4pO1xufTtcbi8qXG4gKiBoYW5kbGVzIGJpbm5pbmcgb2YgY2F0ZWdvcmljYWwgZGF0YSBieSBzZXJpZXMgaW5kZXhcbiAqIGlmIGJpblZhbHVlcyBhcmUgcGFzc2VkLCBpZ25vcmVzIG90aGVyIGJpbiB2YWx1ZXMgdGhhdCBhcmUgZW5jb3VudGVyZWRcbiAqXG4gKiByZXR1cm5zIGFuIG9iamVjdCBvZiBiaW5zIGtleWVkIG9uIHNlcmllcyBpbmRleCB3aXRoIHRoZSBmb2xsb3dpbmcgc2hhcGVcbiAqICB7XG4gKiAgICBbc2VyaWVzSWR4XTogQXJyYXk8T2JqZWN0eyBiaW46IFN0cmluZywgZGF0YTogQXJyYXk8ZGF0dW0+LCBjb3VudDogTnVtYmVyIH0+LFxuICogIH1cbiAqL1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJpbkNhdGVnb3JpY2FsRGF0YShfcmVmKSB7XG4gIHZhciByYXdEYXRhQnlJbmRleCA9IF9yZWYucmF3RGF0YUJ5SW5kZXgsXG4gICAgICB2YWx1ZUFjY2Vzc29yID0gX3JlZi52YWx1ZUFjY2Vzc29yLFxuICAgICAgX3JlZiRiaW5WYWx1ZXMgPSBfcmVmLmJpblZhbHVlcyxcbiAgICAgIGJpblZhbHVlcyA9IF9yZWYkYmluVmFsdWVzID09PSB2b2lkIDAgPyBudWxsIDogX3JlZiRiaW5WYWx1ZXM7XG4gIHZhciBiaW5zQnlJbmRleCA9IHt9O1xuICBPYmplY3Qua2V5cyhyYXdEYXRhQnlJbmRleCkuZm9yRWFjaChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICB2YXIgZGF0YSA9IHJhd0RhdGFCeUluZGV4W2luZGV4XTtcbiAgICB2YXIgYmlucyA9IHt9O1xuICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAoZGF0dW0pIHtcbiAgICAgIHZhciBiaW4gPSB2YWx1ZUFjY2Vzc29yKGRhdHVtKTtcbiAgICAgIGJpbnNbYmluXSA9IGJpbnNbYmluXSB8fCB7XG4gICAgICAgIGJpbjogYmluLFxuICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgY291bnQ6IDAsXG4gICAgICAgIGlkOiBiaW5cbiAgICAgIH07XG4gICAgICBiaW5zW2Jpbl0uZGF0YS5wdXNoKGRhdHVtKTtcbiAgICAgIGJpbnNbYmluXS5jb3VudCArPSAxO1xuICAgIH0pOyAvLyBjb252ZXJ0IHRvIGFuIGFycmF5IG9mIGJpbnNcblxuICAgIGlmIChiaW5WYWx1ZXMpIHtcbiAgICAgIGJpbnNCeUluZGV4W2luZGV4XSA9IGJpblZhbHVlcy5tYXAoZnVuY3Rpb24gKGJpbikge1xuICAgICAgICByZXR1cm4gYmluc1tiaW5dIHx8IHtcbiAgICAgICAgICBiaW46IGJpbixcbiAgICAgICAgICBjb3VudDogMCxcbiAgICAgICAgICBkYXRhOiBbXVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJpbnNCeUluZGV4W2luZGV4XSA9IE9iamVjdC52YWx1ZXMoYmlucykuc29ydChzb3J0Qmlucyk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGJpbnNCeUluZGV4O1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXBvbmVudE5hbWUoY29tcG9uZW50KSB7XG4gIGlmIChjb21wb25lbnQgJiYgY29tcG9uZW50LnR5cGUpIHtcbiAgICByZXR1cm4gY29tcG9uZW50LnR5cGUuZGlzcGxheU5hbWUgfHwgY29tcG9uZW50LnR5cGUubmFtZSB8fCAnQ29tcG9uZW50JztcbiAgfVxuXG4gIHJldHVybiAnQ29tcG9uZW50Jztcbn0iLCJpbXBvcnQgeyBDaGlsZHJlbiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjb21wb25lbnROYW1lIGZyb20gJy4vY29tcG9uZW50TmFtZSc7XG5pbXBvcnQgeyBpc1NlcmllcyB9IGZyb20gJy4vY29tcG9uZW50SXNYJztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbGxlY3REYXRhRnJvbUNoaWxkU2VyaWVzKGNoaWxkcmVuKSB7XG4gIHZhciBhbGxSYXdEYXRhID0gW107XG4gIHZhciBhbGxCaW5uZWREYXRhID0gW107XG4gIHZhciByYXdEYXRhQnlJbmRleCA9IHt9O1xuICB2YXIgYmlubmVkRGF0YUJ5SW5kZXggPSB7fTtcbiAgQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKENoaWxkLCBpKSB7XG4gICAgdmFyIG5hbWUgPSBjb21wb25lbnROYW1lKENoaWxkKTtcblxuICAgIGlmIChpc1NlcmllcyhuYW1lKSkge1xuICAgICAgdmFyIHJhd0RhdGEgPSBDaGlsZC5wcm9wcy5yYXdEYXRhO1xuICAgICAgdmFyIGJpbm5lZERhdGEgPSBDaGlsZC5wcm9wcy5iaW5uZWREYXRhO1xuXG4gICAgICBpZiAocmF3RGF0YSAmJiByYXdEYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmF3RGF0YUJ5SW5kZXhbaV0gPSByYXdEYXRhO1xuICAgICAgICBhbGxSYXdEYXRhID0gYWxsUmF3RGF0YS5jb25jYXQocmF3RGF0YSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChiaW5uZWREYXRhICYmIGJpbm5lZERhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICBiaW5uZWREYXRhQnlJbmRleFtpXSA9IGJpbm5lZERhdGE7XG4gICAgICAgIGFsbEJpbm5lZERhdGEgPSBhbGxCaW5uZWREYXRhLmNvbmNhdChiaW5uZWREYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGFsbEJpbm5lZERhdGE6IGFsbEJpbm5lZERhdGEsXG4gICAgYWxsUmF3RGF0YTogYWxsUmF3RGF0YSxcbiAgICBiaW5uZWREYXRhQnlJbmRleDogYmlubmVkRGF0YUJ5SW5kZXgsXG4gICAgcmF3RGF0YUJ5SW5kZXg6IHJhd0RhdGFCeUluZGV4XG4gIH07XG59IiwiaW1wb3J0IGFkZERlbnNpdHlBbmRDdW11bGF0aXZlVmFsdWVzVG9CaW5zIGZyb20gJy4vYWRkRGVuc2l0eUFuZEN1bXVsYXRpdmVWYWx1ZXNUb0JpbnMnO1xuaW1wb3J0IGJpbk51bWVyaWNEYXRhIGZyb20gJy4vYmluTnVtZXJpY0RhdGEnO1xuaW1wb3J0IGJpbkNhdGVnb3JpY2FsRGF0YSBmcm9tICcuL2JpbkNhdGVnb3JpY2FsRGF0YSc7XG5pbXBvcnQgY29sbGVjdERhdGFGcm9tQ2hpbGRTZXJpZXMgZnJvbSAnLi9jb2xsZWN0RGF0YUZyb21DaGlsZFNlcmllcyc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb2xsZWN0QmlubmVkRGF0YUZyb21DaGlsZFNlcmllcyhfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICBiaW5Db3VudCA9IF9yZWYuYmluQ291bnQsXG4gICAgICBiaW5UeXBlID0gX3JlZi5iaW5UeXBlLFxuICAgICAgYmluVmFsdWVzID0gX3JlZi5iaW5WYWx1ZXMsXG4gICAgICBsaW1pdHMgPSBfcmVmLmxpbWl0cyxcbiAgICAgIHZhbHVlQWNjZXNzb3IgPSBfcmVmLnZhbHVlQWNjZXNzb3I7XG5cbiAgdmFyIF9jb2xsZWN0RGF0YUZyb21DaGlsZCA9IGNvbGxlY3REYXRhRnJvbUNoaWxkU2VyaWVzKGNoaWxkcmVuKSxcbiAgICAgIGFsbFJhd0RhdGEgPSBfY29sbGVjdERhdGFGcm9tQ2hpbGQuYWxsUmF3RGF0YSxcbiAgICAgIHJhd0RhdGFCeUluZGV4ID0gX2NvbGxlY3REYXRhRnJvbUNoaWxkLnJhd0RhdGFCeUluZGV4LFxuICAgICAgYmlubmVkRGF0YUJ5SW5kZXggPSBfY29sbGVjdERhdGFGcm9tQ2hpbGQuYmlubmVkRGF0YUJ5SW5kZXg7XG5cbiAgdmFyIHJlc3VsdCA9IGJpbm5lZERhdGFCeUluZGV4O1xuXG4gIGlmIChPYmplY3Qua2V5cyhiaW5uZWREYXRhQnlJbmRleCkubGVuZ3RoID09PSAwKSB7XG4gICAgdmFyIGJpbm5pbmdGdW5jID0gYmluVHlwZSA9PT0gJ251bWVyaWMnID8gYmluTnVtZXJpY0RhdGEgOiBiaW5DYXRlZ29yaWNhbERhdGE7XG4gICAgcmVzdWx0ID0gYmlubmluZ0Z1bmMoe1xuICAgICAgYWxsRGF0YTogYWxsUmF3RGF0YSxcbiAgICAgIHJhd0RhdGFCeUluZGV4OiByYXdEYXRhQnlJbmRleCxcbiAgICAgIHZhbHVlQWNjZXNzb3I6IHZhbHVlQWNjZXNzb3IsXG4gICAgICBsaW1pdHM6IGxpbWl0cyxcbiAgICAgIGJpbkNvdW50OiBiaW5Db3VudCxcbiAgICAgIGJpblZhbHVlczogYmluVmFsdWVzXG4gICAgfSk7XG4gIH1cblxuICBPYmplY3QudmFsdWVzKHJlc3VsdCkuZm9yRWFjaChmdW5jdGlvbiAoYmlucykge1xuICAgIGFkZERlbnNpdHlBbmRDdW11bGF0aXZlVmFsdWVzVG9CaW5zKGJpbnMpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0iLCJpbXBvcnQgeyBtYXggYXMgZDNNYXggfSBmcm9tICdkMy1hcnJheSc7XG5pbXBvcnQgY2FzZUluc2Vuc2l0aXZlU29ydCBmcm9tICcuL2Nhc2VJbnNlbnNpdGl2ZVNvcnQnO1xuLypcbiAqIENvbXB1dGVzIHRoZSBiaW4gYW5kIHZhbHVlIGRvbWFpbnMgZnJvbSBudW1lcmljIG9yIGNhdGVnb3JpY2FsIGJpbnNcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wdXRlRG9tYWluc0Zyb21CaW5zKF9yZWYpIHtcbiAgdmFyIGJpbnNCeUluZGV4ID0gX3JlZi5iaW5zQnlJbmRleCxcbiAgICAgIGJpblR5cGUgPSBfcmVmLmJpblR5cGUsXG4gICAgICB2YWx1ZUtleSA9IF9yZWYudmFsdWVLZXksXG4gICAgICBiaW5WYWx1ZXMgPSBfcmVmLmJpblZhbHVlcztcbiAgdmFyIGJpbkRvbWFpbjtcbiAgdmFyIHZhbHVlRG9tYWluO1xuICBPYmplY3QudmFsdWVzKGJpbnNCeUluZGV4KS5mb3JFYWNoKGZ1bmN0aW9uIChiaW5zKSB7XG4gICAgdmFyIGN1cnJWYWx1ZU1heCA9IGQzTWF4KGJpbnMsIGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gZFt2YWx1ZUtleV07XG4gICAgfSk7XG5cbiAgICBpZiAodmFsdWVEb21haW4pIHtcbiAgICAgIHZhbHVlRG9tYWluWzFdID0gTWF0aC5tYXgoY3VyclZhbHVlTWF4LCB2YWx1ZURvbWFpblsxXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlRG9tYWluID0gWzAsIGN1cnJWYWx1ZU1heF07XG4gICAgfVxuXG4gICAgaWYgKGJpblR5cGUgPT09ICdudW1lcmljJykge1xuICAgICAgaWYgKGJpbkRvbWFpbikge1xuICAgICAgICBiaW5Eb21haW5bMF0gPSBNYXRoLm1pbihiaW5zWzBdLmJpbjAsIGJpbkRvbWFpblswXSk7XG4gICAgICAgIGJpbkRvbWFpblsxXSA9IE1hdGgubWF4KGJpbnNbYmlucy5sZW5ndGggLSAxXS5iaW4xLCBiaW5Eb21haW5bMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmluRG9tYWluID0gW2JpbnNbMF0uYmluMCwgYmluc1tiaW5zLmxlbmd0aCAtIDFdLmJpbjFdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWJpbkRvbWFpbikgYmluRG9tYWluID0ge307IC8vIHVzZSBsb29rdXAgdG8gYXZvaWQgbG90cyBvZiBBcnJheSBzY2Fuc1xuXG4gICAgICBiaW5zLmZvckVhY2goZnVuY3Rpb24gKGJpbikge1xuICAgICAgICBiaW5Eb21haW5bYmluLmJpbl0gPSB0cnVlO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShiaW5WYWx1ZXMpKSB7XG4gICAgdmFyIHByb3ZpZGVkQmluc0NvdmVyRG9tYWluID0gdHJ1ZTtcbiAgICBiaW5WYWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAoYmluVmFsdWUpIHtcbiAgICAgIGlmICghKGJpblZhbHVlIGluIGJpbkRvbWFpbikpIHtcbiAgICAgICAgcHJvdmlkZWRCaW5zQ292ZXJEb21haW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChwcm92aWRlZEJpbnNDb3ZlckRvbWFpbikge1xuICAgICAgYmluRG9tYWluID0gYmluVmFsdWVzO1xuICAgIH1cbiAgfVxuXG4gIGlmICghQXJyYXkuaXNBcnJheShiaW5Eb21haW4pKSB7XG4gICAgYmluRG9tYWluID0gT2JqZWN0LmtleXMoYmluRG9tYWluKS5zb3J0KGNhc2VJbnNlbnNpdGl2ZVNvcnQpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBiaW5Eb21haW46IGJpbkRvbWFpbixcbiAgICB2YWx1ZURvbWFpbjogdmFsdWVEb21haW5cbiAgfTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRWYWx1ZUtleShfcmVmKSB7XG4gIHZhciBub3JtYWxpemVkID0gX3JlZi5ub3JtYWxpemVkLFxuICAgICAgY3VtdWxhdGl2ZSA9IF9yZWYuY3VtdWxhdGl2ZTtcbiAgaWYgKG5vcm1hbGl6ZWQgJiYgY3VtdWxhdGl2ZSkgcmV0dXJuICdjdW11bGF0aXZlRGVuc2l0eSc7XG4gIGlmIChjdW11bGF0aXZlKSByZXR1cm4gJ2N1bXVsYXRpdmUnO1xuICBpZiAobm9ybWFsaXplZCkgcmV0dXJuICdkZW5zaXR5JztcbiAgcmV0dXJuICdjb3VudCc7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2hhbGxvd0NvbXBhcmVPYmplY3RFbnRyaWVzKGEsIGIpIHtcbiAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMoYSk7XG4gIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKGIpO1xuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGtleXNBLmV2ZXJ5KGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIGFba10gPT09IGJba107XG4gIH0pO1xufSIsImZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG4vKiBlc2xpbnQgY29tcGxleGl0eTogWydlcnJvcicsIDE3XSAqL1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBHcm91cCB9IGZyb20gJ0B2eC9ncm91cCc7XG5pbXBvcnQgeyBzY2FsZUJhbmQsIHNjYWxlTGluZWFyIH0gZnJvbSAnQHZ4L3NjYWxlJztcbmltcG9ydCB7IFdpdGhUb29sdGlwLCB3aXRoVG9vbHRpcFByb3BUeXBlcyB9IGZyb20gJ0BkYXRhLXVpL3NoYXJlZCc7XG5pbXBvcnQgeyBpc0F4aXMsIGlzU2VyaWVzIH0gZnJvbSAnLi4vdXRpbHMvY29tcG9uZW50SXNYJztcbmltcG9ydCBjb2xsZWN0QmlubmVkRGF0YUZyb21DaGlsZFNlcmllcyBmcm9tICcuLi91dGlscy9jb2xsZWN0QmlubmVkRGF0YUZyb21DaGlsZFNlcmllcyc7XG5pbXBvcnQgY29tcG9uZW50TmFtZSBmcm9tICcuLi91dGlscy9jb21wb25lbnROYW1lJztcbmltcG9ydCBjb21wdXRlRG9tYWluc0Zyb21CaW5zIGZyb20gJy4uL3V0aWxzL2NvbXB1dGVEb21haW5zRnJvbUJpbnMnO1xuaW1wb3J0IGdldFZhbHVlS2V5IGZyb20gJy4uL3V0aWxzL2dldFZhbHVlS2V5JztcbmltcG9ydCBzaGFsbG93Q29tcGFyZU9iamVjdEVudHJpZXMgZnJvbSAnLi4vdXRpbHMvc2hhbGxvd0NvbXBhcmVPYmplY3RFbnRyaWVzJztcbmltcG9ydCB7IHRoZW1lU2hhcGUgfSBmcm9tICcuLi91dGlscy9wcm9wU2hhcGVzJztcbmV4cG9ydCB2YXIgcHJvcFR5cGVzID0gX2V4dGVuZHMoe30sIHdpdGhUb29sdGlwUHJvcFR5cGVzLCB7XG4gIGFyaWFMYWJlbDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICBiaW5WYWx1ZXM6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSksXG4gIGJpbkNvdW50OiBQcm9wVHlwZXMubnVtYmVyLFxuICBiaW5UeXBlOiBQcm9wVHlwZXMub25lT2YoWydudW1lcmljJywgJ2NhdGVnb3JpY2FsJ10pLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUuaXNSZXF1aXJlZCxcbiAgY3VtdWxhdGl2ZTogUHJvcFR5cGVzLmJvb2wsXG4gIGhlaWdodDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICBob3Jpem9udGFsOiBQcm9wVHlwZXMuYm9vbCxcbiAgbGltaXRzOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMubnVtYmVyKSxcbiAgLy8gdmFsdWVzIG91dHNpZGUgdGhlIGxpbWl0cyBhcmUgaWdub3JlZFxuICBtYXJnaW46IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgdG9wOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIHJpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIGJvdHRvbTogUHJvcFR5cGVzLm51bWJlcixcbiAgICBsZWZ0OiBQcm9wVHlwZXMubnVtYmVyXG4gIH0pLFxuICBub3JtYWxpemVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgcmVuZGVyVG9vbHRpcDogUHJvcFR5cGVzLmZ1bmMsXG4gIHRoZW1lOiB0aGVtZVNoYXBlLFxuICB3aWR0aDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICB2YWx1ZUFjY2Vzc29yOiBQcm9wVHlwZXMuZnVuY1xufSk7XG52YXIgZGVmYXVsdFByb3BzID0ge1xuICBiaW5Db3VudDogMTAsXG4gIGJpblR5cGU6ICdudW1lcmljJyxcbiAgYmluVmFsdWVzOiBudWxsLFxuICBjdW11bGF0aXZlOiBmYWxzZSxcbiAgaG9yaXpvbnRhbDogZmFsc2UsXG4gIGxpbWl0czogbnVsbCxcbiAgbWFyZ2luOiB7XG4gICAgdG9wOiAzMixcbiAgICByaWdodDogMzIsXG4gICAgYm90dG9tOiA2NCxcbiAgICBsZWZ0OiA2NFxuICB9LFxuICBub3JtYWxpemVkOiBmYWxzZSxcbiAgcmVuZGVyVG9vbHRpcDogbnVsbCxcbiAgdGhlbWU6IHt9LFxuICB2YWx1ZUFjY2Vzc29yOiBmdW5jdGlvbiB2YWx1ZUFjY2Vzc29yKGQpIHtcbiAgICByZXR1cm4gZDtcbiAgfVxufTtcblxudmFyIEhpc3RvZ3JhbSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1JlYWN0JFB1cmVDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoSGlzdG9ncmFtLCBfUmVhY3QkUHVyZUNvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gSGlzdG9ncmFtKHByb3BzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfUmVhY3QkUHVyZUNvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgIF90aGlzLnN0YXRlID0gX3RoaXMuZ2V0U3RhdGVGcm9tUHJvcHMocHJvcHMpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBIaXN0b2dyYW0ucHJvdG90eXBlO1xuXG4gIF9wcm90by5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciBzaG91bGRDb21wdXRlQmluc0FuZFNjYWxlcyA9IGZhbHNlOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvZGVzdHJ1Y3R1cmluZy1hc3NpZ25tZW50XG5cbiAgICBpZiAoWyd3aWR0aCcsICdoZWlnaHQnLCAnY2hpbGRyZW4nXS5zb21lKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICByZXR1cm4gX3RoaXMyLnByb3BzW3Byb3BdICE9PSBuZXh0UHJvcHNbcHJvcF07XG4gICAgfSkpIHtcbiAgICAgIHNob3VsZENvbXB1dGVCaW5zQW5kU2NhbGVzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoWydtYXJnaW4nXS5zb21lKCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvZGVzdHJ1Y3R1cmluZy1hc3NpZ25tZW50XG4gICAgZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIHJldHVybiAhc2hhbGxvd0NvbXBhcmVPYmplY3RFbnRyaWVzKF90aGlzMi5wcm9wc1twcm9wXSwgbmV4dFByb3BzW3Byb3BdKTtcbiAgICB9KSkge1xuICAgICAgc2hvdWxkQ29tcHV0ZUJpbnNBbmRTY2FsZXMgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChzaG91bGRDb21wdXRlQmluc0FuZFNjYWxlcykgdGhpcy5zZXRTdGF0ZSh0aGlzLmdldFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcykpO1xuICB9O1xuXG4gIF9wcm90by5nZXRTdGF0ZUZyb21Qcm9wcyA9IGZ1bmN0aW9uIGdldFN0YXRlRnJvbVByb3BzKHByb3BzKSB7XG4gICAgdmFyIGRpbWVuc2lvbnMgPSB0aGlzLmdldERpbW1lbnNpb25zKHByb3BzKTtcbiAgICB2YXIgYmluc0J5SW5kZXggPSB0aGlzLmdldEJpbm5lZERhdGEocHJvcHMpO1xuICAgIHZhciBzY2FsZXMgPSB0aGlzLmdldFNjYWxlcyhwcm9wcywgYmluc0J5SW5kZXgsIGRpbWVuc2lvbnMpO1xuICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICBiaW5zQnlJbmRleDogYmluc0J5SW5kZXhcbiAgICB9LCBkaW1lbnNpb25zLCBzY2FsZXMpO1xuICB9O1xuXG4gIF9wcm90by5nZXREaW1tZW5zaW9ucyA9IGZ1bmN0aW9uIGdldERpbW1lbnNpb25zKHByb3BzKSB7XG4gICAgdmFyIF9yZWYgPSBwcm9wcyB8fCB0aGlzLnByb3BzLFxuICAgICAgICBtYXJnaW4gPSBfcmVmLm1hcmdpbixcbiAgICAgICAgd2lkdGggPSBfcmVmLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBfcmVmLmhlaWdodDtcblxuICAgIHZhciBjb21wbGV0ZU1hcmdpbiA9IF9leHRlbmRzKHt9LCBkZWZhdWx0UHJvcHMubWFyZ2luLCBtYXJnaW4pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG1hcmdpbjogY29tcGxldGVNYXJnaW4sXG4gICAgICBpbm5lckhlaWdodDogaGVpZ2h0IC0gY29tcGxldGVNYXJnaW4udG9wIC0gY29tcGxldGVNYXJnaW4uYm90dG9tLFxuICAgICAgaW5uZXJXaWR0aDogd2lkdGggLSBjb21wbGV0ZU1hcmdpbi5sZWZ0IC0gY29tcGxldGVNYXJnaW4ucmlnaHRcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5nZXRCaW5uZWREYXRhID0gZnVuY3Rpb24gZ2V0QmlubmVkRGF0YShwcm9wcykge1xuICAgIHZhciBfcmVmMiA9IHByb3BzIHx8IHRoaXMucHJvcHMsXG4gICAgICAgIGNoaWxkcmVuID0gX3JlZjIuY2hpbGRyZW4sXG4gICAgICAgIGJpbkNvdW50ID0gX3JlZjIuYmluQ291bnQsXG4gICAgICAgIGJpblR5cGUgPSBfcmVmMi5iaW5UeXBlLFxuICAgICAgICBiaW5WYWx1ZXMgPSBfcmVmMi5iaW5WYWx1ZXMsXG4gICAgICAgIGxpbWl0cyA9IF9yZWYyLmxpbWl0cyxcbiAgICAgICAgdmFsdWVBY2Nlc3NvciA9IF9yZWYyLnZhbHVlQWNjZXNzb3I7XG5cbiAgICByZXR1cm4gY29sbGVjdEJpbm5lZERhdGFGcm9tQ2hpbGRTZXJpZXMoe1xuICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgYmluQ291bnQ6IGJpbkNvdW50LFxuICAgICAgYmluVHlwZTogYmluVHlwZSxcbiAgICAgIGJpblZhbHVlczogYmluVmFsdWVzLFxuICAgICAgbGltaXRzOiBsaW1pdHMsXG4gICAgICB2YWx1ZUFjY2Vzc29yOiB2YWx1ZUFjY2Vzc29yXG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmdldFNjYWxlcyA9IGZ1bmN0aW9uIGdldFNjYWxlcyhwcm9wcywgYmluc0J5SW5kZXgsIF9yZWYzKSB7XG4gICAgdmFyIGlubmVySGVpZ2h0ID0gX3JlZjMuaW5uZXJIZWlnaHQsXG4gICAgICAgIGlubmVyV2lkdGggPSBfcmVmMy5pbm5lcldpZHRoO1xuXG4gICAgdmFyIF9yZWY0ID0gcHJvcHMgfHwgdGhpcy5wcm9wcyxcbiAgICAgICAgYmluVHlwZSA9IF9yZWY0LmJpblR5cGUsXG4gICAgICAgIGJpblZhbHVlcyA9IF9yZWY0LmJpblZhbHVlcyxcbiAgICAgICAgY3VtdWxhdGl2ZSA9IF9yZWY0LmN1bXVsYXRpdmUsXG4gICAgICAgIGhvcml6b250YWwgPSBfcmVmNC5ob3Jpem9udGFsLFxuICAgICAgICBub3JtYWxpemVkID0gX3JlZjQubm9ybWFsaXplZDtcblxuICAgIHZhciBiaW5TY2FsZUZ1bmMgPSBiaW5UeXBlID09PSAnbnVtZXJpYycgPyBzY2FsZUxpbmVhciA6IHNjYWxlQmFuZDtcbiAgICB2YXIgdmFsdWVLZXkgPSBnZXRWYWx1ZUtleSh7XG4gICAgICBub3JtYWxpemVkOiBub3JtYWxpemVkLFxuICAgICAgY3VtdWxhdGl2ZTogY3VtdWxhdGl2ZVxuICAgIH0pO1xuXG4gICAgdmFyIF9jb21wdXRlRG9tYWluc0Zyb21CaSA9IGNvbXB1dGVEb21haW5zRnJvbUJpbnMoe1xuICAgICAgYmluc0J5SW5kZXg6IGJpbnNCeUluZGV4LFxuICAgICAgYmluVHlwZTogYmluVHlwZSxcbiAgICAgIGJpblZhbHVlczogYmluVmFsdWVzLFxuICAgICAgdmFsdWVLZXk6IHZhbHVlS2V5XG4gICAgfSksXG4gICAgICAgIGJpbkRvbWFpbiA9IF9jb21wdXRlRG9tYWluc0Zyb21CaS5iaW5Eb21haW4sXG4gICAgICAgIHZhbHVlRG9tYWluID0gX2NvbXB1dGVEb21haW5zRnJvbUJpLnZhbHVlRG9tYWluO1xuXG4gICAgdmFyIGJpblJhbmdlID0gaG9yaXpvbnRhbCA/IFtpbm5lckhlaWdodCwgMF0gOiBbMCwgaW5uZXJXaWR0aF07XG4gICAgdmFyIHZhbHVlUmFuZ2UgPSBob3Jpem9udGFsID8gWzAsIGlubmVyV2lkdGhdIDogW2lubmVySGVpZ2h0LCAwXTsgLy8gd2hlbiB2aWV3aW5nIGNhdGVnb3JpY2FsIGRhdGEgaG9yaXpvbnRhbGx5IGl0IGlzIG1vcmUgbmF0dXJhbCB0b1xuICAgIC8vIHJlYWQgYWxwaGFiZXRpY2FsIGZyb20gdG9wIGRvd25cblxuICAgIGlmIChob3Jpem9udGFsICYmIGJpblR5cGUgPT09ICdjYXRlZ29yaWNhbCcpIGJpblJhbmdlLnJldmVyc2UoKTtcbiAgICByZXR1cm4ge1xuICAgICAgYmluU2NhbGU6IGJpblNjYWxlRnVuYyh7XG4gICAgICAgIHJhbmdlOiBiaW5SYW5nZSxcbiAgICAgICAgZG9tYWluOiBiaW5Eb21haW5cbiAgICAgIH0pLFxuICAgICAgdmFsdWVTY2FsZTogc2NhbGVMaW5lYXIoe1xuICAgICAgICByYW5nZTogdmFsdWVSYW5nZSxcbiAgICAgICAgZG9tYWluOiB2YWx1ZURvbWFpblxuICAgICAgfSksXG4gICAgICB2YWx1ZUtleTogdmFsdWVLZXlcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIHJlbmRlclRvb2x0aXAgPSB0aGlzLnByb3BzLnJlbmRlclRvb2x0aXA7XG5cbiAgICBpZiAocmVuZGVyVG9vbHRpcCkge1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoV2l0aFRvb2x0aXAsIHtcbiAgICAgICAgcmVuZGVyVG9vbHRpcDogcmVuZGVyVG9vbHRpcFxuICAgICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChIaXN0b2dyYW0sIF9leHRlbmRzKHt9LCB0aGlzLnByb3BzLCB7XG4gICAgICAgIHJlbmRlclRvb2x0aXA6IG51bGxcbiAgICAgIH0pKSk7XG4gICAgfVxuXG4gICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgYXJpYUxhYmVsID0gX3RoaXMkcHJvcHMuYXJpYUxhYmVsLFxuICAgICAgICBiaW5UeXBlID0gX3RoaXMkcHJvcHMuYmluVHlwZSxcbiAgICAgICAgYmluVmFsdWVzID0gX3RoaXMkcHJvcHMuYmluVmFsdWVzLFxuICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzLmNoaWxkcmVuLFxuICAgICAgICBoZWlnaHQgPSBfdGhpcyRwcm9wcy5oZWlnaHQsXG4gICAgICAgIGhvcml6b250YWwgPSBfdGhpcyRwcm9wcy5ob3Jpem9udGFsLFxuICAgICAgICBvbk1vdXNlTGVhdmUgPSBfdGhpcyRwcm9wcy5vbk1vdXNlTGVhdmUsXG4gICAgICAgIG9uTW91c2VNb3ZlID0gX3RoaXMkcHJvcHMub25Nb3VzZU1vdmUsXG4gICAgICAgIHRoZW1lID0gX3RoaXMkcHJvcHMudGhlbWUsXG4gICAgICAgIHZhbHVlQWNjZXNzb3IgPSBfdGhpcyRwcm9wcy52YWx1ZUFjY2Vzc29yLFxuICAgICAgICB3aWR0aCA9IF90aGlzJHByb3BzLndpZHRoO1xuICAgIHZhciBfdGhpcyRzdGF0ZSA9IHRoaXMuc3RhdGUsXG4gICAgICAgIGJpbnNCeUluZGV4ID0gX3RoaXMkc3RhdGUuYmluc0J5SW5kZXgsXG4gICAgICAgIGJpblNjYWxlID0gX3RoaXMkc3RhdGUuYmluU2NhbGUsXG4gICAgICAgIGlubmVySGVpZ2h0ID0gX3RoaXMkc3RhdGUuaW5uZXJIZWlnaHQsXG4gICAgICAgIGlubmVyV2lkdGggPSBfdGhpcyRzdGF0ZS5pbm5lcldpZHRoLFxuICAgICAgICBtYXJnaW4gPSBfdGhpcyRzdGF0ZS5tYXJnaW4sXG4gICAgICAgIHZhbHVlS2V5ID0gX3RoaXMkc3RhdGUudmFsdWVLZXksXG4gICAgICAgIHZhbHVlU2NhbGUgPSBfdGhpcyRzdGF0ZS52YWx1ZVNjYWxlO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHtcbiAgICAgIFwiYXJpYS1sYWJlbFwiOiBhcmlhTGFiZWwsXG4gICAgICByb2xlOiBcImltZ1wiLFxuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KEdyb3VwLCB7XG4gICAgICBsZWZ0OiBtYXJnaW4ubGVmdCxcbiAgICAgIHRvcDogbWFyZ2luLnRvcFxuICAgIH0sIFJlYWN0LkNoaWxkcmVuLm1hcChjaGlsZHJlbiwgZnVuY3Rpb24gKENoaWxkLCBpbmRleCkge1xuICAgICAgdmFyIG5hbWUgPSBjb21wb25lbnROYW1lKENoaWxkKTtcblxuICAgICAgaWYgKGlzU2VyaWVzKG5hbWUpKSB7XG4gICAgICAgIHZhciBiaW5uZWREYXRhID0gYmluc0J5SW5kZXhbaW5kZXhdO1xuICAgICAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KENoaWxkLCB7XG4gICAgICAgICAgYmluU2NhbGU6IGJpblNjYWxlLFxuICAgICAgICAgIGJpblR5cGU6IGJpblR5cGUsXG4gICAgICAgICAgYmlubmVkRGF0YTogYmlubmVkRGF0YSxcbiAgICAgICAgICBob3Jpem9udGFsOiBob3Jpem9udGFsLFxuICAgICAgICAgIHZhbHVlQWNjZXNzb3I6IHZhbHVlQWNjZXNzb3IsXG4gICAgICAgICAgdmFsdWVLZXk6IHZhbHVlS2V5LFxuICAgICAgICAgIHZhbHVlU2NhbGU6IHZhbHVlU2NhbGUsXG4gICAgICAgICAgb25Nb3VzZUxlYXZlOiBvbk1vdXNlTGVhdmUsXG4gICAgICAgICAgb25Nb3VzZU1vdmU6IG9uTW91c2VNb3ZlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChpc0F4aXMobmFtZSkpIHtcbiAgICAgICAgdmFyIHN0eWxlS2V5ID0gbmFtZVswXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB2YXIgYmluT3JWYWx1ZSA9IG5hbWUgPT09ICdYQXhpcycgJiYgIWhvcml6b250YWwgfHwgbmFtZSA9PT0gJ1lBeGlzJyAmJiBob3Jpem9udGFsID8gJ2JpbicgOiAndmFsdWUnO1xuICAgICAgICB2YXIgdGlja1ZhbHVlcyA9IENoaWxkLnByb3BzLnRpY2tWYWx1ZXMgfHwgKGJpbk9yVmFsdWUgPT09ICdiaW4nICYmIGJpblZhbHVlcyA/IGJpblZhbHVlcyA6IG51bGwpO1xuICAgICAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KENoaWxkLCB7XG4gICAgICAgICAgdG9wOiBuYW1lID09PSAnWUF4aXMnIHx8IENoaWxkLnByb3BzLm9yaWVudGF0aW9uID09PSAndG9wJyA/IDAgOiBpbm5lckhlaWdodCxcbiAgICAgICAgICBsZWZ0OiBuYW1lID09PSAnWEF4aXMnIHx8IENoaWxkLnByb3BzLm9yaWVudGF0aW9uID09PSAnbGVmdCcgPyAwIDogaW5uZXJXaWR0aCxcbiAgICAgICAgICBsYWJlbDogQ2hpbGQucHJvcHMubGFiZWwgfHwgKGJpbk9yVmFsdWUgPT09ICd2YWx1ZScgPyB2YWx1ZUtleSA6IG51bGwpLFxuICAgICAgICAgIHNjYWxlOiBiaW5PclZhbHVlID09PSAndmFsdWUnID8gdmFsdWVTY2FsZSA6IGJpblNjYWxlLFxuICAgICAgICAgIGF4aXNTdHlsZXM6IF9leHRlbmRzKHt9LCB0aGVtZVtzdHlsZUtleSArIFwiQXhpc1N0eWxlc1wiXSwgQ2hpbGQucHJvcHMuYXhpc1N0eWxlcyksXG4gICAgICAgICAgdGlja1N0eWxlczogX2V4dGVuZHMoe30sIHRoZW1lW3N0eWxlS2V5ICsgXCJUaWNrU3R5bGVzXCJdLCBDaGlsZC5wcm9wcy50aWNrU3R5bGVzKSxcbiAgICAgICAgICB0aWNrVmFsdWVzOiB0aWNrVmFsdWVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ2hpbGQ7XG4gICAgfSkpKTtcbiAgfTtcblxuICByZXR1cm4gSGlzdG9ncmFtO1xufShSZWFjdC5QdXJlQ29tcG9uZW50KTtcblxuSGlzdG9ncmFtLnByb3BUeXBlcyA9IHByb3BUeXBlcztcbkhpc3RvZ3JhbS5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5IaXN0b2dyYW0uZGlzcGxheU5hbWUgPSAnSGlzdG9ncmFtJztcbmV4cG9ydCBkZWZhdWx0IEhpc3RvZ3JhbTsiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BCQTtBQUNBO0FBQ0E7OztBQ0ZBO0FBQ0E7QUFDQTs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBOzs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNKQTtBQUNBO0FBQ0E7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xEQTtBQUNBO0FBQ0E7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBOzs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0pBO0FBQ0E7QUFDQTs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2RkE7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFJQTtBQUNBO0FBSUE7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBT0E7QUFDQTtBQUdBO0FBQ0E7QUFPQTtBQUNBO0FBR0E7OztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDblBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDSkE7QUFDQTtBQUNBOzs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNKQTtBQUNBO0FBQ0E7OztBQ0ZBO0FBQ0E7QUFDQTs7O0FDRkE7QUFDQTtBQUNBOzs7QUNGQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBOzs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUJBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFJQTtBQUNBO0FBSUE7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFLQTtBQUNBO0FBTUE7QUFDQTtBQUdBOzs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2287\n')},2289:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ ordinalScale; });\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-array/src/ascending.js\n/* harmony default export */ var ascending = (function(a, b) {\n  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-array/src/bisector.js\n\n\n/* harmony default export */ var bisector = (function(compare) {\n  if (compare.length === 1) compare = ascendingComparator(compare);\n  return {\n    left: function(a, x, lo, hi) {\n      if (lo == null) lo = 0;\n      if (hi == null) hi = a.length;\n      while (lo < hi) {\n        var mid = lo + hi >>> 1;\n        if (compare(a[mid], x) < 0) lo = mid + 1;\n        else hi = mid;\n      }\n      return lo;\n    },\n    right: function(a, x, lo, hi) {\n      if (lo == null) lo = 0;\n      if (hi == null) hi = a.length;\n      while (lo < hi) {\n        var mid = lo + hi >>> 1;\n        if (compare(a[mid], x) > 0) hi = mid;\n        else lo = mid + 1;\n      }\n      return lo;\n    }\n  };\n});\n\nfunction ascendingComparator(f) {\n  return function(d, x) {\n    return ascending(f(d), x);\n  };\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-array/src/bisect.js\n\n\n\nvar ascendingBisect = bisector(ascending);\nvar bisectRight = ascendingBisect.right;\nvar bisectLeft = ascendingBisect.left;\n/* harmony default export */ var bisect = (bisectRight);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-array/src/pairs.js\n/* harmony default export */ var pairs = (function(array, f) {\n  if (f == null) f = pair;\n  var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);\n  while (i < n) pairs[i] = f(p, p = array[++i]);\n  return pairs;\n});\n\nfunction pair(a, b) {\n  return [a, b];\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-array/src/cross.js\n\n\n/* harmony default export */ var cross = (function(values0, values1, reduce) {\n  var n0 = values0.length,\n      n1 = values1.length,\n      values = new Array(n0 * n1),\n      i0,\n      i1,\n      i,\n      value0;\n\n  if (reduce == null) reduce = pair;\n\n  for (i0 = i = 0; i0 < n0; ++i0) {\n    for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {\n      values[i] = reduce(value0, values1[i1]);\n    }\n  }\n\n  return values;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-array/src/descending.js\n/* harmony default export */ var descending = (function(a, b) {\n  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-array/src/number.js\n/* harmony default export */ var number = (function(x) {\n  return x === null ? NaN : +x;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-array/src/variance.js\n\n\n/* harmony default export */ var variance = (function(values, valueof) {\n  var n = values.length,\n      m = 0,\n      i = -1,\n      mean = 0,\n      value,\n      delta,\n      sum = 0;\n\n  if (valueof == null) {\n    while (++i < n) {\n      if (!isNaN(value = number(values[i]))) {\n        delta = value - mean;\n        mean += delta / ++m;\n        sum += delta * (value - mean);\n      }\n    }\n  }\n\n  else {\n    while (++i < n) {\n      if (!isNaN(value = number(valueof(values[i], i, values)))) {\n        delta = value - mean;\n        mean += delta / ++m;\n        sum += delta * (value - mean);\n      }\n    }\n  }\n\n  if (m > 1) return sum / (m - 1);\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-array/src/deviation.js\n\n\n/* harmony default export */ var deviation = (function(array, f) {\n  var v = variance(array, f);\n  return v ? Math.sqrt(v) : v;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-array/src/extent.js\n/* harmony default export */ var extent = (function(values, valueof) {\n  var n = values.length,\n      i = -1,\n      value,\n      min,\n      max;\n\n  if (valueof == null) {\n    while (++i < n) { // Find the first comparable value.\n      if ((value = values[i]) != null && value >= value) {\n        min = max = value;\n        while (++i < n) { // Compare the remaining values.\n          if ((value = values[i]) != null) {\n            if (min > value) min = value;\n            if (max < value) max = value;\n          }\n        }\n      }\n    }\n  }\n\n  else {\n    while (++i < n) { // Find the first comparable value.\n      if ((value = valueof(values[i], i, values)) != null && value >= value) {\n        min = max = value;\n        while (++i < n) { // Compare the remaining values.\n          if ((value = valueof(values[i], i, values)) != null) {\n            if (min > value) min = value;\n            if (max < value) max = value;\n          }\n        }\n      }\n    }\n  }\n\n  return [min, max];\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-array/src/array.js\nvar array_array = Array.prototype;\n\nvar slice = array_array.slice;\nvar map = array_array.map;\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-array/src/constant.js\n/* harmony default export */ var constant = (function(x) {\n  return function() {\n    return x;\n  };\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-array/src/identity.js\n/* harmony default export */ var identity = (function(x) {\n  return x;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-array/src/range.js\n/* harmony default export */ var src_range = (function(start, stop, step) {\n  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;\n\n  var i = -1,\n      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,\n      range = new Array(n);\n\n  while (++i < n) {\n    range[i] = start + i * step;\n  }\n\n  return range;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-array/src/ticks.js\nvar e10 = Math.sqrt(50),\n    e5 = Math.sqrt(10),\n    e2 = Math.sqrt(2);\n\n/* harmony default export */ var ticks = (function(start, stop, count) {\n  var reverse,\n      i = -1,\n      n,\n      ticks,\n      step;\n\n  stop = +stop, start = +start, count = +count;\n  if (start === stop && count > 0) return [start];\n  if (reverse = stop < start) n = start, start = stop, stop = n;\n  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];\n\n  if (step > 0) {\n    start = Math.ceil(start / step);\n    stop = Math.floor(stop / step);\n    ticks = new Array(n = Math.ceil(stop - start + 1));\n    while (++i < n) ticks[i] = (start + i) * step;\n  } else {\n    start = Math.floor(start * step);\n    stop = Math.ceil(stop * step);\n    ticks = new Array(n = Math.ceil(start - stop + 1));\n    while (++i < n) ticks[i] = (start - i) / step;\n  }\n\n  if (reverse) ticks.reverse();\n\n  return ticks;\n});\n\nfunction tickIncrement(start, stop, count) {\n  var step = (stop - start) / Math.max(0, count),\n      power = Math.floor(Math.log(step) / Math.LN10),\n      error = step / Math.pow(10, power);\n  return power >= 0\n      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)\n      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);\n}\n\nfunction tickStep(start, stop, count) {\n  var step0 = Math.abs(stop - start) / Math.max(0, count),\n      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),\n      error = step0 / step1;\n  if (error >= e10) step1 *= 10;\n  else if (error >= e5) step1 *= 5;\n  else if (error >= e2) step1 *= 2;\n  return stop < start ? -step1 : step1;\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-array/src/threshold/sturges.js\n/* harmony default export */ var sturges = (function(values) {\n  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-array/src/histogram.js\n\n\n\n\n\n\n\n\n\n/* harmony default export */ var src_histogram = (function() {\n  var value = identity,\n      domain = extent,\n      threshold = sturges;\n\n  function histogram(data) {\n    var i,\n        n = data.length,\n        x,\n        values = new Array(n);\n\n    for (i = 0; i < n; ++i) {\n      values[i] = value(data[i], i, data);\n    }\n\n    var xz = domain(values),\n        x0 = xz[0],\n        x1 = xz[1],\n        tz = threshold(values, x0, x1);\n\n    // Convert number of thresholds into uniform thresholds.\n    if (!Array.isArray(tz)) {\n      tz = tickStep(x0, x1, tz);\n      tz = src_range(Math.ceil(x0 / tz) * tz, x1, tz); // exclusive\n    }\n\n    // Remove any thresholds outside the domain.\n    var m = tz.length;\n    while (tz[0] <= x0) tz.shift(), --m;\n    while (tz[m - 1] > x1) tz.pop(), --m;\n\n    var bins = new Array(m + 1),\n        bin;\n\n    // Initialize bins.\n    for (i = 0; i <= m; ++i) {\n      bin = bins[i] = [];\n      bin.x0 = i > 0 ? tz[i - 1] : x0;\n      bin.x1 = i < m ? tz[i] : x1;\n    }\n\n    // Assign data to bins by value, ignoring any outside the domain.\n    for (i = 0; i < n; ++i) {\n      x = values[i];\n      if (x0 <= x && x <= x1) {\n        bins[bisect(tz, x, 0, m)].push(data[i]);\n      }\n    }\n\n    return bins;\n  }\n\n  histogram.value = function(_) {\n    return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;\n  };\n\n  histogram.domain = function(_) {\n    return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;\n  };\n\n  histogram.thresholds = function(_) {\n    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;\n  };\n\n  return histogram;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-array/src/quantile.js\n\n\n/* harmony default export */ var quantile = (function(values, p, valueof) {\n  if (valueof == null) valueof = number;\n  if (!(n = values.length)) return;\n  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);\n  if (p >= 1) return +valueof(values[n - 1], n - 1, values);\n  var n,\n      i = (n - 1) * p,\n      i0 = Math.floor(i),\n      value0 = +valueof(values[i0], i0, values),\n      value1 = +valueof(values[i0 + 1], i0 + 1, values);\n  return value0 + (value1 - value0) * (i - i0);\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-array/src/threshold/freedmanDiaconis.js\n\n\n\n\n\n/* harmony default export */ var freedmanDiaconis = (function(values, min, max) {\n  values = map.call(values, number).sort(ascending);\n  return Math.ceil((max - min) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(values.length, -1 / 3)));\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-array/src/threshold/scott.js\n\n\n/* harmony default export */ var scott = (function(values, min, max) {\n  return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-array/src/max.js\n/* harmony default export */ var src_max = (function(values, valueof) {\n  var n = values.length,\n      i = -1,\n      value,\n      max;\n\n  if (valueof == null) {\n    while (++i < n) { // Find the first comparable value.\n      if ((value = values[i]) != null && value >= value) {\n        max = value;\n        while (++i < n) { // Compare the remaining values.\n          if ((value = values[i]) != null && value > max) {\n            max = value;\n          }\n        }\n      }\n    }\n  }\n\n  else {\n    while (++i < n) { // Find the first comparable value.\n      if ((value = valueof(values[i], i, values)) != null && value >= value) {\n        max = value;\n        while (++i < n) { // Compare the remaining values.\n          if ((value = valueof(values[i], i, values)) != null && value > max) {\n            max = value;\n          }\n        }\n      }\n    }\n  }\n\n  return max;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-array/src/mean.js\n\n\n/* harmony default export */ var src_mean = (function(values, valueof) {\n  var n = values.length,\n      m = n,\n      i = -1,\n      value,\n      sum = 0;\n\n  if (valueof == null) {\n    while (++i < n) {\n      if (!isNaN(value = number(values[i]))) sum += value;\n      else --m;\n    }\n  }\n\n  else {\n    while (++i < n) {\n      if (!isNaN(value = number(valueof(values[i], i, values)))) sum += value;\n      else --m;\n    }\n  }\n\n  if (m) return sum / m;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-array/src/median.js\n\n\n\n\n/* harmony default export */ var median = (function(values, valueof) {\n  var n = values.length,\n      i = -1,\n      value,\n      numbers = [];\n\n  if (valueof == null) {\n    while (++i < n) {\n      if (!isNaN(value = number(values[i]))) {\n        numbers.push(value);\n      }\n    }\n  }\n\n  else {\n    while (++i < n) {\n      if (!isNaN(value = number(valueof(values[i], i, values)))) {\n        numbers.push(value);\n      }\n    }\n  }\n\n  return quantile(numbers.sort(ascending), 0.5);\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-array/src/merge.js\n/* harmony default export */ var merge = (function(arrays) {\n  var n = arrays.length,\n      m,\n      i = -1,\n      j = 0,\n      merged,\n      array;\n\n  while (++i < n) j += arrays[i].length;\n  merged = new Array(j);\n\n  while (--n >= 0) {\n    array = arrays[n];\n    m = array.length;\n    while (--m >= 0) {\n      merged[--j] = array[m];\n    }\n  }\n\n  return merged;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-array/src/min.js\n/* harmony default export */ var src_min = (function(values, valueof) {\n  var n = values.length,\n      i = -1,\n      value,\n      min;\n\n  if (valueof == null) {\n    while (++i < n) { // Find the first comparable value.\n      if ((value = values[i]) != null && value >= value) {\n        min = value;\n        while (++i < n) { // Compare the remaining values.\n          if ((value = values[i]) != null && min > value) {\n            min = value;\n          }\n        }\n      }\n    }\n  }\n\n  else {\n    while (++i < n) { // Find the first comparable value.\n      if ((value = valueof(values[i], i, values)) != null && value >= value) {\n        min = value;\n        while (++i < n) { // Compare the remaining values.\n          if ((value = valueof(values[i], i, values)) != null && min > value) {\n            min = value;\n          }\n        }\n      }\n    }\n  }\n\n  return min;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-array/src/permute.js\n/* harmony default export */ var permute = (function(array, indexes) {\n  var i = indexes.length, permutes = new Array(i);\n  while (i--) permutes[i] = array[indexes[i]];\n  return permutes;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-array/src/scan.js\n\n\n/* harmony default export */ var scan = (function(values, compare) {\n  if (!(n = values.length)) return;\n  var n,\n      i = 0,\n      j = 0,\n      xi,\n      xj = values[j];\n\n  if (compare == null) compare = ascending;\n\n  while (++i < n) {\n    if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {\n      xj = xi, j = i;\n    }\n  }\n\n  if (compare(xj, xj) === 0) return j;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-array/src/shuffle.js\n/* harmony default export */ var shuffle = (function(array, i0, i1) {\n  var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),\n      t,\n      i;\n\n  while (m) {\n    i = Math.random() * m-- | 0;\n    t = array[m + i0];\n    array[m + i0] = array[i + i0];\n    array[i + i0] = t;\n  }\n\n  return array;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-array/src/sum.js\n/* harmony default export */ var src_sum = (function(values, valueof) {\n  var n = values.length,\n      i = -1,\n      value,\n      sum = 0;\n\n  if (valueof == null) {\n    while (++i < n) {\n      if (value = +values[i]) sum += value; // Note: zero and null are equivalent.\n    }\n  }\n\n  else {\n    while (++i < n) {\n      if (value = +valueof(values[i], i, values)) sum += value;\n    }\n  }\n\n  return sum;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-array/src/transpose.js\n\n\n/* harmony default export */ var src_transpose = (function(matrix) {\n  if (!(n = matrix.length)) return [];\n  for (var i = -1, m = src_min(matrix, transpose_length), transpose = new Array(m); ++i < m;) {\n    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {\n      row[j] = matrix[j][i];\n    }\n  }\n  return transpose;\n});\n\nfunction transpose_length(d) {\n  return d.length;\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-array/src/zip.js\n\n\n/* harmony default export */ var zip = (function() {\n  return src_transpose(arguments);\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-array/src/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-scale/src/init.js\nfunction initRange(domain, range) {\n  switch (arguments.length) {\n    case 0: break;\n    case 1: this.range(domain); break;\n    default: this.range(range).domain(domain); break;\n  }\n  return this;\n}\n\nfunction initInterpolator(domain, interpolator) {\n  switch (arguments.length) {\n    case 0: break;\n    case 1: this.interpolator(domain); break;\n    default: this.interpolator(interpolator).domain(domain); break;\n  }\n  return this;\n}\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-collection/src/index.js + 6 modules\nvar src = __webpack_require__(407);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-scale/src/array.js\nvar src_array_array = Array.prototype;\n\nvar array_map = src_array_array.map;\nvar array_slice = src_array_array.slice;\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-scale/src/ordinal.js\n\n\n\n\nvar implicit = {name: "implicit"};\n\nfunction ordinal() {\n  var index = Object(src["map"])(),\n      domain = [],\n      range = [],\n      unknown = implicit;\n\n  function scale(d) {\n    var key = d + "", i = index.get(key);\n    if (!i) {\n      if (unknown !== implicit) return unknown;\n      index.set(key, i = domain.push(d));\n    }\n    return range[(i - 1) % range.length];\n  }\n\n  scale.domain = function(_) {\n    if (!arguments.length) return domain.slice();\n    domain = [], index = Object(src["map"])();\n    var i = -1, n = _.length, d, key;\n    while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));\n    return scale;\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = array_slice.call(_), scale) : range.slice();\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  scale.copy = function() {\n    return ordinal(domain, range).unknown(unknown);\n  };\n\n  initRange.apply(scale, arguments);\n\n  return scale;\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-scale/src/band.js\n\n\n\n\nfunction band() {\n  var scale = ordinal().unknown(undefined),\n      domain = scale.domain,\n      ordinalRange = scale.range,\n      range = [0, 1],\n      step,\n      bandwidth,\n      round = false,\n      paddingInner = 0,\n      paddingOuter = 0,\n      align = 0.5;\n\n  delete scale.unknown;\n\n  function rescale() {\n    var n = domain().length,\n        reverse = range[1] < range[0],\n        start = range[reverse - 0],\n        stop = range[1 - reverse];\n    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);\n    if (round) step = Math.floor(step);\n    start += (stop - start - step * (n - paddingInner)) * align;\n    bandwidth = step * (1 - paddingInner);\n    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);\n    var values = src_range(n).map(function(i) { return start + step * i; });\n    return ordinalRange(reverse ? values.reverse() : values);\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain(_), rescale()) : domain();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = [+_[0], +_[1]], rescale()) : range.slice();\n  };\n\n  scale.rangeRound = function(_) {\n    return range = [+_[0], +_[1]], round = true, rescale();\n  };\n\n  scale.bandwidth = function() {\n    return bandwidth;\n  };\n\n  scale.step = function() {\n    return step;\n  };\n\n  scale.round = function(_) {\n    return arguments.length ? (round = !!_, rescale()) : round;\n  };\n\n  scale.padding = function(_) {\n    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;\n  };\n\n  scale.paddingInner = function(_) {\n    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;\n  };\n\n  scale.paddingOuter = function(_) {\n    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;\n  };\n\n  scale.align = function(_) {\n    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;\n  };\n\n  scale.copy = function() {\n    return band(domain(), range)\n        .round(round)\n        .paddingInner(paddingInner)\n        .paddingOuter(paddingOuter)\n        .align(align);\n  };\n\n  return initRange.apply(rescale(), arguments);\n}\n\nfunction pointish(scale) {\n  var copy = scale.copy;\n\n  scale.padding = scale.paddingOuter;\n  delete scale.paddingInner;\n  delete scale.paddingOuter;\n\n  scale.copy = function() {\n    return pointish(copy());\n  };\n\n  return scale;\n}\n\nfunction point() {\n  return pointish(band.apply(null, arguments).paddingInner(1));\n}\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-interpolate/src/value.js\nvar src_value = __webpack_require__(166);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-interpolate/src/number.js\nvar src_number = __webpack_require__(51);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-interpolate/src/round.js\nvar src_round = __webpack_require__(525);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-scale/src/constant.js\n/* harmony default export */ var src_constant = (function(x) {\n  return function() {\n    return x;\n  };\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-scale/src/number.js\n/* harmony default export */ var d3_scale_src_number = (function(x) {\n  return +x;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-scale/src/continuous.js\n\n\n\n\n\n\nvar unit = [0, 1];\n\nfunction continuous_identity(x) {\n  return x;\n}\n\nfunction normalize(a, b) {\n  return (b -= (a = +a))\n      ? function(x) { return (x - a) / b; }\n      : src_constant(isNaN(b) ? NaN : 0.5);\n}\n\nfunction clamper(domain) {\n  var a = domain[0], b = domain[domain.length - 1], t;\n  if (a > b) t = a, a = b, b = t;\n  return function(x) { return Math.max(a, Math.min(b, x)); };\n}\n\n// normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].\n// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].\nfunction bimap(domain, range, interpolate) {\n  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];\n  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);\n  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);\n  return function(x) { return r0(d0(x)); };\n}\n\nfunction polymap(domain, range, interpolate) {\n  var j = Math.min(domain.length, range.length) - 1,\n      d = new Array(j),\n      r = new Array(j),\n      i = -1;\n\n  // Reverse descending domains.\n  if (domain[j] < domain[0]) {\n    domain = domain.slice().reverse();\n    range = range.slice().reverse();\n  }\n\n  while (++i < j) {\n    d[i] = normalize(domain[i], domain[i + 1]);\n    r[i] = interpolate(range[i], range[i + 1]);\n  }\n\n  return function(x) {\n    var i = bisect(domain, x, 1, j) - 1;\n    return r[i](d[i](x));\n  };\n}\n\nfunction copy(source, target) {\n  return target\n      .domain(source.domain())\n      .range(source.range())\n      .interpolate(source.interpolate())\n      .clamp(source.clamp())\n      .unknown(source.unknown());\n}\n\nfunction transformer() {\n  var domain = unit,\n      range = unit,\n      interpolate = src_value["a" /* default */],\n      transform,\n      untransform,\n      unknown,\n      clamp = continuous_identity,\n      piecewise,\n      output,\n      input;\n\n  function rescale() {\n    piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;\n    output = input = null;\n    return scale;\n  }\n\n  function scale(x) {\n    return isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));\n  }\n\n  scale.invert = function(y) {\n    return clamp(untransform((input || (input = piecewise(range, domain.map(transform), src_number["a" /* default */])))(y)));\n  };\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain = array_map.call(_, d3_scale_src_number), clamp === continuous_identity || (clamp = clamper(domain)), rescale()) : domain.slice();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = array_slice.call(_), rescale()) : range.slice();\n  };\n\n  scale.rangeRound = function(_) {\n    return range = array_slice.call(_), interpolate = src_round["a" /* default */], rescale();\n  };\n\n  scale.clamp = function(_) {\n    return arguments.length ? (clamp = _ ? clamper(domain) : continuous_identity, scale) : clamp !== continuous_identity;\n  };\n\n  scale.interpolate = function(_) {\n    return arguments.length ? (interpolate = _, rescale()) : interpolate;\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  return function(t, u) {\n    transform = t, untransform = u;\n    return rescale();\n  };\n}\n\nfunction continuous(transform, untransform) {\n  return transformer()(transform, untransform);\n}\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-format/src/formatSpecifier.js\nvar formatSpecifier = __webpack_require__(267);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-format/src/precisionPrefix.js\nvar precisionPrefix = __webpack_require__(655);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-format/src/defaultLocale.js\nvar defaultLocale = __webpack_require__(312);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-format/src/precisionRound.js\nvar precisionRound = __webpack_require__(656);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-format/src/precisionFixed.js\nvar precisionFixed = __webpack_require__(657);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-scale/src/tickFormat.js\n\n\n\n/* harmony default export */ var src_tickFormat = (function(start, stop, count, specifier) {\n  var step = tickStep(start, stop, count),\n      precision;\n  specifier = Object(formatSpecifier["b" /* default */])(specifier == null ? ",f" : specifier);\n  switch (specifier.type) {\n    case "s": {\n      var value = Math.max(Math.abs(start), Math.abs(stop));\n      if (specifier.precision == null && !isNaN(precision = Object(precisionPrefix["a" /* default */])(step, value))) specifier.precision = precision;\n      return Object(defaultLocale["c" /* formatPrefix */])(specifier, value);\n    }\n    case "":\n    case "e":\n    case "g":\n    case "p":\n    case "r": {\n      if (specifier.precision == null && !isNaN(precision = Object(precisionRound["a" /* default */])(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");\n      break;\n    }\n    case "f":\n    case "%": {\n      if (specifier.precision == null && !isNaN(precision = Object(precisionFixed["a" /* default */])(step))) specifier.precision = precision - (specifier.type === "%") * 2;\n      break;\n    }\n  }\n  return Object(defaultLocale["b" /* format */])(specifier);\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-scale/src/linear.js\n\n\n\n\n\nfunction linearish(scale) {\n  var domain = scale.domain;\n\n  scale.ticks = function(count) {\n    var d = domain();\n    return ticks(d[0], d[d.length - 1], count == null ? 10 : count);\n  };\n\n  scale.tickFormat = function(count, specifier) {\n    var d = domain();\n    return src_tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);\n  };\n\n  scale.nice = function(count) {\n    if (count == null) count = 10;\n\n    var d = domain(),\n        i0 = 0,\n        i1 = d.length - 1,\n        start = d[i0],\n        stop = d[i1],\n        step;\n\n    if (stop < start) {\n      step = start, start = stop, stop = step;\n      step = i0, i0 = i1, i1 = step;\n    }\n\n    step = tickIncrement(start, stop, count);\n\n    if (step > 0) {\n      start = Math.floor(start / step) * step;\n      stop = Math.ceil(stop / step) * step;\n      step = tickIncrement(start, stop, count);\n    } else if (step < 0) {\n      start = Math.ceil(start * step) / step;\n      stop = Math.floor(stop * step) / step;\n      step = tickIncrement(start, stop, count);\n    }\n\n    if (step > 0) {\n      d[i0] = Math.floor(start / step) * step;\n      d[i1] = Math.ceil(stop / step) * step;\n      domain(d);\n    } else if (step < 0) {\n      d[i0] = Math.ceil(start * step) / step;\n      d[i1] = Math.floor(stop * step) / step;\n      domain(d);\n    }\n\n    return scale;\n  };\n\n  return scale;\n}\n\nfunction linear() {\n  var scale = continuous(continuous_identity, continuous_identity);\n\n  scale.copy = function() {\n    return copy(scale, linear());\n  };\n\n  initRange.apply(scale, arguments);\n\n  return linearish(scale);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-scale/src/identity.js\n\n\n\n\nfunction identity_identity(domain) {\n  var unknown;\n\n  function scale(x) {\n    return isNaN(x = +x) ? unknown : x;\n  }\n\n  scale.invert = scale;\n\n  scale.domain = scale.range = function(_) {\n    return arguments.length ? (domain = array_map.call(_, d3_scale_src_number), scale) : domain.slice();\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  scale.copy = function() {\n    return identity_identity(domain).unknown(unknown);\n  };\n\n  domain = arguments.length ? array_map.call(domain, d3_scale_src_number) : [0, 1];\n\n  return linearish(scale);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-scale/src/nice.js\n/* harmony default export */ var nice = (function(domain, interval) {\n  domain = domain.slice();\n\n  var i0 = 0,\n      i1 = domain.length - 1,\n      x0 = domain[i0],\n      x1 = domain[i1],\n      t;\n\n  if (x1 < x0) {\n    t = i0, i0 = i1, i1 = t;\n    t = x0, x0 = x1, x1 = t;\n  }\n\n  domain[i0] = interval.floor(x0);\n  domain[i1] = interval.ceil(x1);\n  return domain;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-scale/src/log.js\n\n\n\n\n\n\nfunction transformLog(x) {\n  return Math.log(x);\n}\n\nfunction transformExp(x) {\n  return Math.exp(x);\n}\n\nfunction transformLogn(x) {\n  return -Math.log(-x);\n}\n\nfunction transformExpn(x) {\n  return -Math.exp(-x);\n}\n\nfunction pow10(x) {\n  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;\n}\n\nfunction powp(base) {\n  return base === 10 ? pow10\n      : base === Math.E ? Math.exp\n      : function(x) { return Math.pow(base, x); };\n}\n\nfunction logp(base) {\n  return base === Math.E ? Math.log\n      : base === 10 && Math.log10\n      || base === 2 && Math.log2\n      || (base = Math.log(base), function(x) { return Math.log(x) / base; });\n}\n\nfunction reflect(f) {\n  return function(x) {\n    return -f(-x);\n  };\n}\n\nfunction loggish(transform) {\n  var scale = transform(transformLog, transformExp),\n      domain = scale.domain,\n      base = 10,\n      logs,\n      pows;\n\n  function rescale() {\n    logs = logp(base), pows = powp(base);\n    if (domain()[0] < 0) {\n      logs = reflect(logs), pows = reflect(pows);\n      transform(transformLogn, transformExpn);\n    } else {\n      transform(transformLog, transformExp);\n    }\n    return scale;\n  }\n\n  scale.base = function(_) {\n    return arguments.length ? (base = +_, rescale()) : base;\n  };\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain(_), rescale()) : domain();\n  };\n\n  scale.ticks = function(count) {\n    var d = domain(),\n        u = d[0],\n        v = d[d.length - 1],\n        r;\n\n    if (r = v < u) i = u, u = v, v = i;\n\n    var i = logs(u),\n        j = logs(v),\n        p,\n        k,\n        t,\n        n = count == null ? 10 : +count,\n        z = [];\n\n    if (!(base % 1) && j - i < n) {\n      i = Math.round(i) - 1, j = Math.round(j) + 1;\n      if (u > 0) for (; i < j; ++i) {\n        for (k = 1, p = pows(i); k < base; ++k) {\n          t = p * k;\n          if (t < u) continue;\n          if (t > v) break;\n          z.push(t);\n        }\n      } else for (; i < j; ++i) {\n        for (k = base - 1, p = pows(i); k >= 1; --k) {\n          t = p * k;\n          if (t < u) continue;\n          if (t > v) break;\n          z.push(t);\n        }\n      }\n    } else {\n      z = ticks(i, j, Math.min(j - i, n)).map(pows);\n    }\n\n    return r ? z.reverse() : z;\n  };\n\n  scale.tickFormat = function(count, specifier) {\n    if (specifier == null) specifier = base === 10 ? ".0e" : ",";\n    if (typeof specifier !== "function") specifier = Object(defaultLocale["b" /* format */])(specifier);\n    if (count === Infinity) return specifier;\n    if (count == null) count = 10;\n    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?\n    return function(d) {\n      var i = d / pows(Math.round(logs(d)));\n      if (i * base < base - 0.5) i *= base;\n      return i <= k ? specifier(d) : "";\n    };\n  };\n\n  scale.nice = function() {\n    return domain(nice(domain(), {\n      floor: function(x) { return pows(Math.floor(logs(x))); },\n      ceil: function(x) { return pows(Math.ceil(logs(x))); }\n    }));\n  };\n\n  return scale;\n}\n\nfunction log() {\n  var scale = loggish(transformer()).domain([1, 10]);\n\n  scale.copy = function() {\n    return copy(scale, log()).base(scale.base());\n  };\n\n  initRange.apply(scale, arguments);\n\n  return scale;\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-scale/src/symlog.js\n\n\n\n\nfunction transformSymlog(c) {\n  return function(x) {\n    return Math.sign(x) * Math.log1p(Math.abs(x / c));\n  };\n}\n\nfunction transformSymexp(c) {\n  return function(x) {\n    return Math.sign(x) * Math.expm1(Math.abs(x)) * c;\n  };\n}\n\nfunction symlogish(transform) {\n  var c = 1, scale = transform(transformSymlog(c), transformSymexp(c));\n\n  scale.constant = function(_) {\n    return arguments.length ? transform(transformSymlog(c = +_), transformSymexp(c)) : c;\n  };\n\n  return linearish(scale);\n}\n\nfunction symlog() {\n  var scale = symlogish(transformer());\n\n  scale.copy = function() {\n    return copy(scale, symlog()).constant(scale.constant());\n  };\n\n  return initRange.apply(scale, arguments);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-scale/src/pow.js\n\n\n\n\nfunction transformPow(exponent) {\n  return function(x) {\n    return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);\n  };\n}\n\nfunction transformSqrt(x) {\n  return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);\n}\n\nfunction transformSquare(x) {\n  return x < 0 ? -x * x : x * x;\n}\n\nfunction powish(transform) {\n  var scale = transform(continuous_identity, continuous_identity),\n      exponent = 1;\n\n  function rescale() {\n    return exponent === 1 ? transform(continuous_identity, continuous_identity)\n        : exponent === 0.5 ? transform(transformSqrt, transformSquare)\n        : transform(transformPow(exponent), transformPow(1 / exponent));\n  }\n\n  scale.exponent = function(_) {\n    return arguments.length ? (exponent = +_, rescale()) : exponent;\n  };\n\n  return linearish(scale);\n}\n\nfunction pow() {\n  var scale = powish(transformer());\n\n  scale.copy = function() {\n    return copy(scale, pow()).exponent(scale.exponent());\n  };\n\n  initRange.apply(scale, arguments);\n\n  return scale;\n}\n\nfunction sqrt() {\n  return pow.apply(null, arguments).exponent(0.5);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-scale/src/quantile.js\n\n\n\n\nfunction quantile_quantile() {\n  var domain = [],\n      range = [],\n      thresholds = [],\n      unknown;\n\n  function rescale() {\n    var i = 0, n = Math.max(1, range.length);\n    thresholds = new Array(n - 1);\n    while (++i < n) thresholds[i - 1] = quantile(domain, i / n);\n    return scale;\n  }\n\n  function scale(x) {\n    return isNaN(x = +x) ? unknown : range[bisect(thresholds, x)];\n  }\n\n  scale.invertExtent = function(y) {\n    var i = range.indexOf(y);\n    return i < 0 ? [NaN, NaN] : [\n      i > 0 ? thresholds[i - 1] : domain[0],\n      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]\n    ];\n  };\n\n  scale.domain = function(_) {\n    if (!arguments.length) return domain.slice();\n    domain = [];\n    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);\n    domain.sort(ascending);\n    return rescale();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = array_slice.call(_), rescale()) : range.slice();\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  scale.quantiles = function() {\n    return thresholds.slice();\n  };\n\n  scale.copy = function() {\n    return quantile_quantile()\n        .domain(domain)\n        .range(range)\n        .unknown(unknown);\n  };\n\n  return initRange.apply(scale, arguments);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-scale/src/quantize.js\n\n\n\n\n\nfunction quantize() {\n  var x0 = 0,\n      x1 = 1,\n      n = 1,\n      domain = [0.5],\n      range = [0, 1],\n      unknown;\n\n  function scale(x) {\n    return x <= x ? range[bisect(domain, x, 0, n)] : unknown;\n  }\n\n  function rescale() {\n    var i = -1;\n    domain = new Array(n);\n    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);\n    return scale;\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (n = (range = array_slice.call(_)).length - 1, rescale()) : range.slice();\n  };\n\n  scale.invertExtent = function(y) {\n    var i = range.indexOf(y);\n    return i < 0 ? [NaN, NaN]\n        : i < 1 ? [x0, domain[0]]\n        : i >= n ? [domain[n - 1], x1]\n        : [domain[i - 1], domain[i]];\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : scale;\n  };\n\n  scale.thresholds = function() {\n    return domain.slice();\n  };\n\n  scale.copy = function() {\n    return quantize()\n        .domain([x0, x1])\n        .range(range)\n        .unknown(unknown);\n  };\n\n  return initRange.apply(linearish(scale), arguments);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-scale/src/threshold.js\n\n\n\n\nfunction threshold_threshold() {\n  var domain = [0.5],\n      range = [0, 1],\n      unknown,\n      n = 1;\n\n  function scale(x) {\n    return x <= x ? range[bisect(domain, x, 0, n)] : unknown;\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain = array_slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = array_slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();\n  };\n\n  scale.invertExtent = function(y) {\n    var i = range.indexOf(y);\n    return [domain[i - 1], domain[i]];\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  scale.copy = function() {\n    return threshold_threshold()\n        .domain(domain)\n        .range(range)\n        .unknown(unknown);\n  };\n\n  return initRange.apply(scale, arguments);\n}\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/year.js\nvar src_year = __webpack_require__(125);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/month.js\nvar src_month = __webpack_require__(376);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/week.js\nvar src_week = __webpack_require__(26);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/day.js\nvar src_day = __webpack_require__(224);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/hour.js\nvar src_hour = __webpack_require__(377);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/minute.js\nvar src_minute = __webpack_require__(378);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/second.js\nvar src_second = __webpack_require__(211);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/millisecond.js\nvar src_millisecond = __webpack_require__(212);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time-format/src/defaultLocale.js\nvar src_defaultLocale = __webpack_require__(648);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-scale/src/time.js\n\n\n\n\n\n\n\n\nvar durationSecond = 1000,\n    durationMinute = durationSecond * 60,\n    durationHour = durationMinute * 60,\n    durationDay = durationHour * 24,\n    durationWeek = durationDay * 7,\n    durationMonth = durationDay * 30,\n    durationYear = durationDay * 365;\n\nfunction date(t) {\n  return new Date(t);\n}\n\nfunction time_number(t) {\n  return t instanceof Date ? +t : +new Date(+t);\n}\n\nfunction calendar(year, month, week, day, hour, minute, second, millisecond, format) {\n  var scale = continuous(continuous_identity, continuous_identity),\n      invert = scale.invert,\n      domain = scale.domain;\n\n  var formatMillisecond = format(".%L"),\n      formatSecond = format(":%S"),\n      formatMinute = format("%I:%M"),\n      formatHour = format("%I %p"),\n      formatDay = format("%a %d"),\n      formatWeek = format("%b %d"),\n      formatMonth = format("%B"),\n      formatYear = format("%Y");\n\n  var tickIntervals = [\n    [second,  1,      durationSecond],\n    [second,  5,  5 * durationSecond],\n    [second, 15, 15 * durationSecond],\n    [second, 30, 30 * durationSecond],\n    [minute,  1,      durationMinute],\n    [minute,  5,  5 * durationMinute],\n    [minute, 15, 15 * durationMinute],\n    [minute, 30, 30 * durationMinute],\n    [  hour,  1,      durationHour  ],\n    [  hour,  3,  3 * durationHour  ],\n    [  hour,  6,  6 * durationHour  ],\n    [  hour, 12, 12 * durationHour  ],\n    [   day,  1,      durationDay   ],\n    [   day,  2,  2 * durationDay   ],\n    [  week,  1,      durationWeek  ],\n    [ month,  1,      durationMonth ],\n    [ month,  3,  3 * durationMonth ],\n    [  year,  1,      durationYear  ]\n  ];\n\n  function tickFormat(date) {\n    return (second(date) < date ? formatMillisecond\n        : minute(date) < date ? formatSecond\n        : hour(date) < date ? formatMinute\n        : day(date) < date ? formatHour\n        : month(date) < date ? (week(date) < date ? formatDay : formatWeek)\n        : year(date) < date ? formatMonth\n        : formatYear)(date);\n  }\n\n  function tickInterval(interval, start, stop, step) {\n    if (interval == null) interval = 10;\n\n    // If a desired tick count is specified, pick a reasonable tick interval\n    // based on the extent of the domain and a rough estimate of tick size.\n    // Otherwise, assume interval is already a time interval and use it.\n    if (typeof interval === "number") {\n      var target = Math.abs(stop - start) / interval,\n          i = bisector(function(i) { return i[2]; }).right(tickIntervals, target);\n      if (i === tickIntervals.length) {\n        step = tickStep(start / durationYear, stop / durationYear, interval);\n        interval = year;\n      } else if (i) {\n        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];\n        step = i[1];\n        interval = i[0];\n      } else {\n        step = Math.max(tickStep(start, stop, interval), 1);\n        interval = millisecond;\n      }\n    }\n\n    return step == null ? interval : interval.every(step);\n  }\n\n  scale.invert = function(y) {\n    return new Date(invert(y));\n  };\n\n  scale.domain = function(_) {\n    return arguments.length ? domain(array_map.call(_, time_number)) : domain().map(date);\n  };\n\n  scale.ticks = function(interval, step) {\n    var d = domain(),\n        t0 = d[0],\n        t1 = d[d.length - 1],\n        r = t1 < t0,\n        t;\n    if (r) t = t0, t0 = t1, t1 = t;\n    t = tickInterval(interval, t0, t1, step);\n    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop\n    return r ? t.reverse() : t;\n  };\n\n  scale.tickFormat = function(count, specifier) {\n    return specifier == null ? tickFormat : format(specifier);\n  };\n\n  scale.nice = function(interval, step) {\n    var d = domain();\n    return (interval = tickInterval(interval, d[0], d[d.length - 1], step))\n        ? domain(nice(d, interval))\n        : scale;\n  };\n\n  scale.copy = function() {\n    return copy(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));\n  };\n\n  return scale;\n}\n\n/* harmony default export */ var time = (function() {\n  return initRange.apply(calendar(src_year["a" /* default */], src_month["a" /* default */], src_week["g" /* sunday */], src_day["b" /* default */], src_hour["a" /* default */], src_minute["a" /* default */], src_second["a" /* default */], src_millisecond["a" /* default */], src_defaultLocale["a" /* timeFormat */]).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);\n});\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/utcYear.js\nvar utcYear = __webpack_require__(126);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/utcMonth.js\nvar utcMonth = __webpack_require__(379);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/utcWeek.js\nvar utcWeek = __webpack_require__(27);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/utcDay.js\nvar utcDay = __webpack_require__(225);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/utcHour.js\nvar utcHour = __webpack_require__(380);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-time/src/utcMinute.js\nvar utcMinute = __webpack_require__(381);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-scale/src/utcTime.js\n\n\n\n\n\n/* harmony default export */ var utcTime = (function() {\n  return initRange.apply(calendar(utcYear["a" /* default */], utcMonth["a" /* default */], utcWeek["g" /* utcSunday */], utcDay["a" /* default */], utcHour["a" /* default */], utcMinute["a" /* default */], src_second["a" /* default */], src_millisecond["a" /* default */], src_defaultLocale["b" /* utcFormat */]).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]), arguments);\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-scale/src/sequential.js\n\n\n\n\n\n\n\nfunction sequential_transformer() {\n  var x0 = 0,\n      x1 = 1,\n      t0,\n      t1,\n      k10,\n      transform,\n      interpolator = continuous_identity,\n      clamp = false,\n      unknown;\n\n  function scale(x) {\n    return isNaN(x = +x) ? unknown : interpolator(k10 === 0 ? 0.5 : (x = (transform(x) - t0) * k10, clamp ? Math.max(0, Math.min(1, x)) : x));\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (t0 = transform(x0 = +_[0]), t1 = transform(x1 = +_[1]), k10 = t0 === t1 ? 0 : 1 / (t1 - t0), scale) : [x0, x1];\n  };\n\n  scale.clamp = function(_) {\n    return arguments.length ? (clamp = !!_, scale) : clamp;\n  };\n\n  scale.interpolator = function(_) {\n    return arguments.length ? (interpolator = _, scale) : interpolator;\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  return function(t) {\n    transform = t, t0 = t(x0), t1 = t(x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0);\n    return scale;\n  };\n}\n\nfunction sequential_copy(source, target) {\n  return target\n      .domain(source.domain())\n      .interpolator(source.interpolator())\n      .clamp(source.clamp())\n      .unknown(source.unknown());\n}\n\nfunction sequential() {\n  var scale = linearish(sequential_transformer()(continuous_identity));\n\n  scale.copy = function() {\n    return sequential_copy(scale, sequential());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction sequentialLog() {\n  var scale = loggish(sequential_transformer()).domain([1, 10]);\n\n  scale.copy = function() {\n    return sequential_copy(scale, sequentialLog()).base(scale.base());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction sequentialSymlog() {\n  var scale = symlogish(sequential_transformer());\n\n  scale.copy = function() {\n    return sequential_copy(scale, sequentialSymlog()).constant(scale.constant());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction sequentialPow() {\n  var scale = powish(sequential_transformer());\n\n  scale.copy = function() {\n    return sequential_copy(scale, sequentialPow()).exponent(scale.exponent());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction sequentialSqrt() {\n  return sequentialPow.apply(null, arguments).exponent(0.5);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-scale/src/sequentialQuantile.js\n\n\n\n\nfunction sequentialQuantile() {\n  var domain = [],\n      interpolator = continuous_identity;\n\n  function scale(x) {\n    if (!isNaN(x = +x)) return interpolator((bisect(domain, x) - 1) / (domain.length - 1));\n  }\n\n  scale.domain = function(_) {\n    if (!arguments.length) return domain.slice();\n    domain = [];\n    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);\n    domain.sort(ascending);\n    return scale;\n  };\n\n  scale.interpolator = function(_) {\n    return arguments.length ? (interpolator = _, scale) : interpolator;\n  };\n\n  scale.copy = function() {\n    return sequentialQuantile(interpolator).domain(domain);\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-scale/src/diverging.js\n\n\n\n\n\n\n\n\nfunction diverging_transformer() {\n  var x0 = 0,\n      x1 = 0.5,\n      x2 = 1,\n      t0,\n      t1,\n      t2,\n      k10,\n      k21,\n      interpolator = continuous_identity,\n      transform,\n      clamp = false,\n      unknown;\n\n  function scale(x) {\n    return isNaN(x = +x) ? unknown : (x = 0.5 + ((x = +transform(x)) - t1) * (x < t1 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x)) : x));\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (t0 = transform(x0 = +_[0]), t1 = transform(x1 = +_[1]), t2 = transform(x2 = +_[2]), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), scale) : [x0, x1, x2];\n  };\n\n  scale.clamp = function(_) {\n    return arguments.length ? (clamp = !!_, scale) : clamp;\n  };\n\n  scale.interpolator = function(_) {\n    return arguments.length ? (interpolator = _, scale) : interpolator;\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  return function(t) {\n    transform = t, t0 = t(x0), t1 = t(x1), t2 = t(x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1);\n    return scale;\n  };\n}\n\nfunction diverging() {\n  var scale = linearish(diverging_transformer()(continuous_identity));\n\n  scale.copy = function() {\n    return sequential_copy(scale, diverging());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction divergingLog() {\n  var scale = loggish(diverging_transformer()).domain([0.1, 1, 10]);\n\n  scale.copy = function() {\n    return sequential_copy(scale, divergingLog()).base(scale.base());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction divergingSymlog() {\n  var scale = symlogish(diverging_transformer());\n\n  scale.copy = function() {\n    return sequential_copy(scale, divergingSymlog()).constant(scale.constant());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction divergingPow() {\n  var scale = powish(diverging_transformer());\n\n  scale.copy = function() {\n    return sequential_copy(scale, divergingPow()).exponent(scale.exponent());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nfunction divergingSqrt() {\n  return divergingPow.apply(null, arguments).exponent(0.5);\n}\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/d3-scale/src/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/plugins/legacy-plugin-chart-histogram/node_modules/@vx/scale/esm/scales/ordinal.js\n\nfunction ordinalScale(_ref) {\n  var range = _ref.range,\n      domain = _ref.domain,\n      unknown = _ref.unknown;\n  var scale = ordinal();\n  if (range) scale.range(range);\n  if (domain) scale.domain(domain);\n  if (unknown) scale.unknown(unknown); // @ts-ignore\n\n  scale.type = \'ordinal\';\n  return scale;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjI4OS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9sZWdhY3ktcGx1Z2luLWNoYXJ0LWhpc3RvZ3JhbS9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2FzY2VuZGluZy5qcz9iZDJhIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9sZWdhY3ktcGx1Z2luLWNoYXJ0LWhpc3RvZ3JhbS9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2Jpc2VjdG9yLmpzP2Q4NzciLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtaGlzdG9ncmFtL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvYmlzZWN0LmpzPzc0ZTAiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtaGlzdG9ncmFtL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvcGFpcnMuanM/NzJjMCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvbGVnYWN5LXBsdWdpbi1jaGFydC1oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9jcm9zcy5qcz80YTM3Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9sZWdhY3ktcGx1Z2luLWNoYXJ0LWhpc3RvZ3JhbS9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2Rlc2NlbmRpbmcuanM/NmY0YyIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvbGVnYWN5LXBsdWdpbi1jaGFydC1oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9udW1iZXIuanM/ODdmOCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvbGVnYWN5LXBsdWdpbi1jaGFydC1oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy92YXJpYW5jZS5qcz9hNzEyIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9sZWdhY3ktcGx1Z2luLWNoYXJ0LWhpc3RvZ3JhbS9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2RldmlhdGlvbi5qcz8xNDgyIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9sZWdhY3ktcGx1Z2luLWNoYXJ0LWhpc3RvZ3JhbS9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2V4dGVudC5qcz82NjJhIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9sZWdhY3ktcGx1Z2luLWNoYXJ0LWhpc3RvZ3JhbS9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2FycmF5LmpzPzg2YTIiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtaGlzdG9ncmFtL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvY29uc3RhbnQuanM/YWI2OCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvbGVnYWN5LXBsdWdpbi1jaGFydC1oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9pZGVudGl0eS5qcz81MzdiIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9sZWdhY3ktcGx1Z2luLWNoYXJ0LWhpc3RvZ3JhbS9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL3JhbmdlLmpzPzg4ZmEiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtaGlzdG9ncmFtL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvdGlja3MuanM/Y2EwOCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvbGVnYWN5LXBsdWdpbi1jaGFydC1oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy90aHJlc2hvbGQvc3R1cmdlcy5qcz9jYzhmIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9sZWdhY3ktcGx1Z2luLWNoYXJ0LWhpc3RvZ3JhbS9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2hpc3RvZ3JhbS5qcz8zMjQ5Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9sZWdhY3ktcGx1Z2luLWNoYXJ0LWhpc3RvZ3JhbS9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL3F1YW50aWxlLmpzP2MwMzAiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtaGlzdG9ncmFtL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvdGhyZXNob2xkL2ZyZWVkbWFuRGlhY29uaXMuanM/YzU1OCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvbGVnYWN5LXBsdWdpbi1jaGFydC1oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy90aHJlc2hvbGQvc2NvdHQuanM/ODRlNSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvbGVnYWN5LXBsdWdpbi1jaGFydC1oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9tYXguanM/NGZjMiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvbGVnYWN5LXBsdWdpbi1jaGFydC1oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9tZWFuLmpzPzI4MGUiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtaGlzdG9ncmFtL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvbWVkaWFuLmpzPzgwMWYiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtaGlzdG9ncmFtL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvbWVyZ2UuanM/YmIzZiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvbGVnYWN5LXBsdWdpbi1jaGFydC1oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9taW4uanM/OTg2ZSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvbGVnYWN5LXBsdWdpbi1jaGFydC1oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9wZXJtdXRlLmpzPzU5NGEiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtaGlzdG9ncmFtL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvc2Nhbi5qcz8xZGZlIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9sZWdhY3ktcGx1Z2luLWNoYXJ0LWhpc3RvZ3JhbS9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL3NodWZmbGUuanM/NmZlZCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvbGVnYWN5LXBsdWdpbi1jaGFydC1oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9zdW0uanM/YTA3OSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvbGVnYWN5LXBsdWdpbi1jaGFydC1oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy90cmFuc3Bvc2UuanM/NWQ5YiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvbGVnYWN5LXBsdWdpbi1jaGFydC1oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy96aXAuanM/NDEzZiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvbGVnYWN5LXBsdWdpbi1jaGFydC1oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9pbmRleC5qcz81ZWJjIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9sZWdhY3ktcGx1Z2luLWNoYXJ0LWhpc3RvZ3JhbS9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL2luaXQuanM/YTI0MCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvbGVnYWN5LXBsdWdpbi1jaGFydC1oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9hcnJheS5qcz9jNTMwIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9sZWdhY3ktcGx1Z2luLWNoYXJ0LWhpc3RvZ3JhbS9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL29yZGluYWwuanM/OWNkNSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvbGVnYWN5LXBsdWdpbi1jaGFydC1oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9iYW5kLmpzPzYzOWIiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtaGlzdG9ncmFtL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvY29uc3RhbnQuanM/NzEwNiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvbGVnYWN5LXBsdWdpbi1jaGFydC1oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9udW1iZXIuanM/ZjYzNyIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvbGVnYWN5LXBsdWdpbi1jaGFydC1oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9jb250aW51b3VzLmpzPzBlYTQiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtaGlzdG9ncmFtL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvdGlja0Zvcm1hdC5qcz82NmVkIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9sZWdhY3ktcGx1Z2luLWNoYXJ0LWhpc3RvZ3JhbS9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL2xpbmVhci5qcz80MWM2Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9sZWdhY3ktcGx1Z2luLWNoYXJ0LWhpc3RvZ3JhbS9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL2lkZW50aXR5LmpzP2FhNzEiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtaGlzdG9ncmFtL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvbmljZS5qcz9jMjg4Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9sZWdhY3ktcGx1Z2luLWNoYXJ0LWhpc3RvZ3JhbS9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL2xvZy5qcz85MjhjIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9sZWdhY3ktcGx1Z2luLWNoYXJ0LWhpc3RvZ3JhbS9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL3N5bWxvZy5qcz85ZWMzIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9sZWdhY3ktcGx1Z2luLWNoYXJ0LWhpc3RvZ3JhbS9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL3Bvdy5qcz80Y2RlIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9sZWdhY3ktcGx1Z2luLWNoYXJ0LWhpc3RvZ3JhbS9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL3F1YW50aWxlLmpzPzU5Y2QiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtaGlzdG9ncmFtL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvcXVhbnRpemUuanM/YTY5YSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvbGVnYWN5LXBsdWdpbi1jaGFydC1oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy90aHJlc2hvbGQuanM/NDQ0NiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvbGVnYWN5LXBsdWdpbi1jaGFydC1oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy90aW1lLmpzPzY5NmEiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtaGlzdG9ncmFtL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvdXRjVGltZS5qcz8wOTc2Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9sZWdhY3ktcGx1Z2luLWNoYXJ0LWhpc3RvZ3JhbS9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL3NlcXVlbnRpYWwuanM/OGFjNiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvbGVnYWN5LXBsdWdpbi1jaGFydC1oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9zZXF1ZW50aWFsUXVhbnRpbGUuanM/MDEyMCIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvbGVnYWN5LXBsdWdpbi1jaGFydC1oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9kaXZlcmdpbmcuanM/YjYxYSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL3BsdWdpbnMvbGVnYWN5LXBsdWdpbi1jaGFydC1oaXN0b2dyYW0vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9pbmRleC5qcz8wN2YyIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvcGx1Z2lucy9sZWdhY3ktcGx1Z2luLWNoYXJ0LWhpc3RvZ3JhbS9ub2RlX21vZHVsZXMvQHZ4L3NjYWxlL2VzbS9zY2FsZXMvb3JkaW5hbC5qcz9mNTEwIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiBhID49IGIgPyAwIDogTmFOO1xufVxuIiwiaW1wb3J0IGFzY2VuZGluZyBmcm9tIFwiLi9hc2NlbmRpbmdcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY29tcGFyZSkge1xuICBpZiAoY29tcGFyZS5sZW5ndGggPT09IDEpIGNvbXBhcmUgPSBhc2NlbmRpbmdDb21wYXJhdG9yKGNvbXBhcmUpO1xuICByZXR1cm4ge1xuICAgIGxlZnQ6IGZ1bmN0aW9uKGEsIHgsIGxvLCBoaSkge1xuICAgICAgaWYgKGxvID09IG51bGwpIGxvID0gMDtcbiAgICAgIGlmIChoaSA9PSBudWxsKSBoaSA9IGEubGVuZ3RoO1xuICAgICAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICAgICAgdmFyIG1pZCA9IGxvICsgaGkgPj4+IDE7XG4gICAgICAgIGlmIChjb21wYXJlKGFbbWlkXSwgeCkgPCAwKSBsbyA9IG1pZCArIDE7XG4gICAgICAgIGVsc2UgaGkgPSBtaWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbG87XG4gICAgfSxcbiAgICByaWdodDogZnVuY3Rpb24oYSwgeCwgbG8sIGhpKSB7XG4gICAgICBpZiAobG8gPT0gbnVsbCkgbG8gPSAwO1xuICAgICAgaWYgKGhpID09IG51bGwpIGhpID0gYS5sZW5ndGg7XG4gICAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgICB2YXIgbWlkID0gbG8gKyBoaSA+Pj4gMTtcbiAgICAgICAgaWYgKGNvbXBhcmUoYVttaWRdLCB4KSA+IDApIGhpID0gbWlkO1xuICAgICAgICBlbHNlIGxvID0gbWlkICsgMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsbztcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGFzY2VuZGluZ0NvbXBhcmF0b3IoZikge1xuICByZXR1cm4gZnVuY3Rpb24oZCwgeCkge1xuICAgIHJldHVybiBhc2NlbmRpbmcoZihkKSwgeCk7XG4gIH07XG59XG4iLCJpbXBvcnQgYXNjZW5kaW5nIGZyb20gXCIuL2FzY2VuZGluZ1wiO1xuaW1wb3J0IGJpc2VjdG9yIGZyb20gXCIuL2Jpc2VjdG9yXCI7XG5cbnZhciBhc2NlbmRpbmdCaXNlY3QgPSBiaXNlY3Rvcihhc2NlbmRpbmcpO1xuZXhwb3J0IHZhciBiaXNlY3RSaWdodCA9IGFzY2VuZGluZ0Jpc2VjdC5yaWdodDtcbmV4cG9ydCB2YXIgYmlzZWN0TGVmdCA9IGFzY2VuZGluZ0Jpc2VjdC5sZWZ0O1xuZXhwb3J0IGRlZmF1bHQgYmlzZWN0UmlnaHQ7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhcnJheSwgZikge1xuICBpZiAoZiA9PSBudWxsKSBmID0gcGFpcjtcbiAgdmFyIGkgPSAwLCBuID0gYXJyYXkubGVuZ3RoIC0gMSwgcCA9IGFycmF5WzBdLCBwYWlycyA9IG5ldyBBcnJheShuIDwgMCA/IDAgOiBuKTtcbiAgd2hpbGUgKGkgPCBuKSBwYWlyc1tpXSA9IGYocCwgcCA9IGFycmF5WysraV0pO1xuICByZXR1cm4gcGFpcnM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYWlyKGEsIGIpIHtcbiAgcmV0dXJuIFthLCBiXTtcbn1cbiIsImltcG9ydCB7cGFpcn0gZnJvbSBcIi4vcGFpcnNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWVzMCwgdmFsdWVzMSwgcmVkdWNlKSB7XG4gIHZhciBuMCA9IHZhbHVlczAubGVuZ3RoLFxuICAgICAgbjEgPSB2YWx1ZXMxLmxlbmd0aCxcbiAgICAgIHZhbHVlcyA9IG5ldyBBcnJheShuMCAqIG4xKSxcbiAgICAgIGkwLFxuICAgICAgaTEsXG4gICAgICBpLFxuICAgICAgdmFsdWUwO1xuXG4gIGlmIChyZWR1Y2UgPT0gbnVsbCkgcmVkdWNlID0gcGFpcjtcblxuICBmb3IgKGkwID0gaSA9IDA7IGkwIDwgbjA7ICsraTApIHtcbiAgICBmb3IgKHZhbHVlMCA9IHZhbHVlczBbaTBdLCBpMSA9IDA7IGkxIDwgbjE7ICsraTEsICsraSkge1xuICAgICAgdmFsdWVzW2ldID0gcmVkdWNlKHZhbHVlMCwgdmFsdWVzMVtpMV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2YWx1ZXM7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHJldHVybiBiIDwgYSA/IC0xIDogYiA+IGEgPyAxIDogYiA+PSBhID8gMCA6IE5hTjtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHggPT09IG51bGwgPyBOYU4gOiAreDtcbn1cbiIsImltcG9ydCBudW1iZXIgZnJvbSBcIi4vbnVtYmVyXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlcywgdmFsdWVvZikge1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBtID0gMCxcbiAgICAgIGkgPSAtMSxcbiAgICAgIG1lYW4gPSAwLFxuICAgICAgdmFsdWUsXG4gICAgICBkZWx0YSxcbiAgICAgIHN1bSA9IDA7XG5cbiAgaWYgKHZhbHVlb2YgPT0gbnVsbCkge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBpZiAoIWlzTmFOKHZhbHVlID0gbnVtYmVyKHZhbHVlc1tpXSkpKSB7XG4gICAgICAgIGRlbHRhID0gdmFsdWUgLSBtZWFuO1xuICAgICAgICBtZWFuICs9IGRlbHRhIC8gKyttO1xuICAgICAgICBzdW0gKz0gZGVsdGEgKiAodmFsdWUgLSBtZWFuKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBlbHNlIHtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgaWYgKCFpc05hTih2YWx1ZSA9IG51bWJlcih2YWx1ZW9mKHZhbHVlc1tpXSwgaSwgdmFsdWVzKSkpKSB7XG4gICAgICAgIGRlbHRhID0gdmFsdWUgLSBtZWFuO1xuICAgICAgICBtZWFuICs9IGRlbHRhIC8gKyttO1xuICAgICAgICBzdW0gKz0gZGVsdGEgKiAodmFsdWUgLSBtZWFuKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAobSA+IDEpIHJldHVybiBzdW0gLyAobSAtIDEpO1xufVxuIiwiaW1wb3J0IHZhcmlhbmNlIGZyb20gXCIuL3ZhcmlhbmNlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGFycmF5LCBmKSB7XG4gIHZhciB2ID0gdmFyaWFuY2UoYXJyYXksIGYpO1xuICByZXR1cm4gdiA/IE1hdGguc3FydCh2KSA6IHY7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgaSA9IC0xLFxuICAgICAgdmFsdWUsXG4gICAgICBtaW4sXG4gICAgICBtYXg7XG5cbiAgaWYgKHZhbHVlb2YgPT0gbnVsbCkge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIEZpbmQgdGhlIGZpcnN0IGNvbXBhcmFibGUgdmFsdWUuXG4gICAgICBpZiAoKHZhbHVlID0gdmFsdWVzW2ldKSAhPSBudWxsICYmIHZhbHVlID49IHZhbHVlKSB7XG4gICAgICAgIG1pbiA9IG1heCA9IHZhbHVlO1xuICAgICAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBDb21wYXJlIHRoZSByZW1haW5pbmcgdmFsdWVzLlxuICAgICAgICAgIGlmICgodmFsdWUgPSB2YWx1ZXNbaV0pICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChtaW4gPiB2YWx1ZSkgbWluID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAobWF4IDwgdmFsdWUpIG1heCA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGVsc2Uge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIEZpbmQgdGhlIGZpcnN0IGNvbXBhcmFibGUgdmFsdWUuXG4gICAgICBpZiAoKHZhbHVlID0gdmFsdWVvZih2YWx1ZXNbaV0sIGksIHZhbHVlcykpICE9IG51bGwgJiYgdmFsdWUgPj0gdmFsdWUpIHtcbiAgICAgICAgbWluID0gbWF4ID0gdmFsdWU7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIENvbXBhcmUgdGhlIHJlbWFpbmluZyB2YWx1ZXMuXG4gICAgICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobWluID4gdmFsdWUpIG1pbiA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKG1heCA8IHZhbHVlKSBtYXggPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gW21pbiwgbWF4XTtcbn1cbiIsInZhciBhcnJheSA9IEFycmF5LnByb3RvdHlwZTtcblxuZXhwb3J0IHZhciBzbGljZSA9IGFycmF5LnNsaWNlO1xuZXhwb3J0IHZhciBtYXAgPSBhcnJheS5tYXA7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHg7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzdGFydCwgc3RvcCwgc3RlcCkge1xuICBzdGFydCA9ICtzdGFydCwgc3RvcCA9ICtzdG9wLCBzdGVwID0gKG4gPSBhcmd1bWVudHMubGVuZ3RoKSA8IDIgPyAoc3RvcCA9IHN0YXJ0LCBzdGFydCA9IDAsIDEpIDogbiA8IDMgPyAxIDogK3N0ZXA7XG5cbiAgdmFyIGkgPSAtMSxcbiAgICAgIG4gPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoKHN0b3AgLSBzdGFydCkgLyBzdGVwKSkgfCAwLFxuICAgICAgcmFuZ2UgPSBuZXcgQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICByYW5nZVtpXSA9IHN0YXJ0ICsgaSAqIHN0ZXA7XG4gIH1cblxuICByZXR1cm4gcmFuZ2U7XG59XG4iLCJ2YXIgZTEwID0gTWF0aC5zcXJ0KDUwKSxcbiAgICBlNSA9IE1hdGguc3FydCgxMCksXG4gICAgZTIgPSBNYXRoLnNxcnQoMik7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBjb3VudCkge1xuICB2YXIgcmV2ZXJzZSxcbiAgICAgIGkgPSAtMSxcbiAgICAgIG4sXG4gICAgICB0aWNrcyxcbiAgICAgIHN0ZXA7XG5cbiAgc3RvcCA9ICtzdG9wLCBzdGFydCA9ICtzdGFydCwgY291bnQgPSArY291bnQ7XG4gIGlmIChzdGFydCA9PT0gc3RvcCAmJiBjb3VudCA+IDApIHJldHVybiBbc3RhcnRdO1xuICBpZiAocmV2ZXJzZSA9IHN0b3AgPCBzdGFydCkgbiA9IHN0YXJ0LCBzdGFydCA9IHN0b3AsIHN0b3AgPSBuO1xuICBpZiAoKHN0ZXAgPSB0aWNrSW5jcmVtZW50KHN0YXJ0LCBzdG9wLCBjb3VudCkpID09PSAwIHx8ICFpc0Zpbml0ZShzdGVwKSkgcmV0dXJuIFtdO1xuXG4gIGlmIChzdGVwID4gMCkge1xuICAgIHN0YXJ0ID0gTWF0aC5jZWlsKHN0YXJ0IC8gc3RlcCk7XG4gICAgc3RvcCA9IE1hdGguZmxvb3Ioc3RvcCAvIHN0ZXApO1xuICAgIHRpY2tzID0gbmV3IEFycmF5KG4gPSBNYXRoLmNlaWwoc3RvcCAtIHN0YXJ0ICsgMSkpO1xuICAgIHdoaWxlICgrK2kgPCBuKSB0aWNrc1tpXSA9IChzdGFydCArIGkpICogc3RlcDtcbiAgfSBlbHNlIHtcbiAgICBzdGFydCA9IE1hdGguZmxvb3Ioc3RhcnQgKiBzdGVwKTtcbiAgICBzdG9wID0gTWF0aC5jZWlsKHN0b3AgKiBzdGVwKTtcbiAgICB0aWNrcyA9IG5ldyBBcnJheShuID0gTWF0aC5jZWlsKHN0YXJ0IC0gc3RvcCArIDEpKTtcbiAgICB3aGlsZSAoKytpIDwgbikgdGlja3NbaV0gPSAoc3RhcnQgLSBpKSAvIHN0ZXA7XG4gIH1cblxuICBpZiAocmV2ZXJzZSkgdGlja3MucmV2ZXJzZSgpO1xuXG4gIHJldHVybiB0aWNrcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRpY2tJbmNyZW1lbnQoc3RhcnQsIHN0b3AsIGNvdW50KSB7XG4gIHZhciBzdGVwID0gKHN0b3AgLSBzdGFydCkgLyBNYXRoLm1heCgwLCBjb3VudCksXG4gICAgICBwb3dlciA9IE1hdGguZmxvb3IoTWF0aC5sb2coc3RlcCkgLyBNYXRoLkxOMTApLFxuICAgICAgZXJyb3IgPSBzdGVwIC8gTWF0aC5wb3coMTAsIHBvd2VyKTtcbiAgcmV0dXJuIHBvd2VyID49IDBcbiAgICAgID8gKGVycm9yID49IGUxMCA/IDEwIDogZXJyb3IgPj0gZTUgPyA1IDogZXJyb3IgPj0gZTIgPyAyIDogMSkgKiBNYXRoLnBvdygxMCwgcG93ZXIpXG4gICAgICA6IC1NYXRoLnBvdygxMCwgLXBvd2VyKSAvIChlcnJvciA+PSBlMTAgPyAxMCA6IGVycm9yID49IGU1ID8gNSA6IGVycm9yID49IGUyID8gMiA6IDEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGlja1N0ZXAoc3RhcnQsIHN0b3AsIGNvdW50KSB7XG4gIHZhciBzdGVwMCA9IE1hdGguYWJzKHN0b3AgLSBzdGFydCkgLyBNYXRoLm1heCgwLCBjb3VudCksXG4gICAgICBzdGVwMSA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKE1hdGgubG9nKHN0ZXAwKSAvIE1hdGguTE4xMCkpLFxuICAgICAgZXJyb3IgPSBzdGVwMCAvIHN0ZXAxO1xuICBpZiAoZXJyb3IgPj0gZTEwKSBzdGVwMSAqPSAxMDtcbiAgZWxzZSBpZiAoZXJyb3IgPj0gZTUpIHN0ZXAxICo9IDU7XG4gIGVsc2UgaWYgKGVycm9yID49IGUyKSBzdGVwMSAqPSAyO1xuICByZXR1cm4gc3RvcCA8IHN0YXJ0ID8gLXN0ZXAxIDogc3RlcDE7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgcmV0dXJuIE1hdGguY2VpbChNYXRoLmxvZyh2YWx1ZXMubGVuZ3RoKSAvIE1hdGguTE4yKSArIDE7XG59XG4iLCJpbXBvcnQge3NsaWNlfSBmcm9tIFwiLi9hcnJheVwiO1xuaW1wb3J0IGJpc2VjdCBmcm9tIFwiLi9iaXNlY3RcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudFwiO1xuaW1wb3J0IGV4dGVudCBmcm9tIFwiLi9leHRlbnRcIjtcbmltcG9ydCBpZGVudGl0eSBmcm9tIFwiLi9pZGVudGl0eVwiO1xuaW1wb3J0IHJhbmdlIGZyb20gXCIuL3JhbmdlXCI7XG5pbXBvcnQge3RpY2tTdGVwfSBmcm9tIFwiLi90aWNrc1wiO1xuaW1wb3J0IHN0dXJnZXMgZnJvbSBcIi4vdGhyZXNob2xkL3N0dXJnZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciB2YWx1ZSA9IGlkZW50aXR5LFxuICAgICAgZG9tYWluID0gZXh0ZW50LFxuICAgICAgdGhyZXNob2xkID0gc3R1cmdlcztcblxuICBmdW5jdGlvbiBoaXN0b2dyYW0oZGF0YSkge1xuICAgIHZhciBpLFxuICAgICAgICBuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgIHgsXG4gICAgICAgIHZhbHVlcyA9IG5ldyBBcnJheShuKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHZhbHVlc1tpXSA9IHZhbHVlKGRhdGFbaV0sIGksIGRhdGEpO1xuICAgIH1cblxuICAgIHZhciB4eiA9IGRvbWFpbih2YWx1ZXMpLFxuICAgICAgICB4MCA9IHh6WzBdLFxuICAgICAgICB4MSA9IHh6WzFdLFxuICAgICAgICB0eiA9IHRocmVzaG9sZCh2YWx1ZXMsIHgwLCB4MSk7XG5cbiAgICAvLyBDb252ZXJ0IG51bWJlciBvZiB0aHJlc2hvbGRzIGludG8gdW5pZm9ybSB0aHJlc2hvbGRzLlxuICAgIGlmICghQXJyYXkuaXNBcnJheSh0eikpIHtcbiAgICAgIHR6ID0gdGlja1N0ZXAoeDAsIHgxLCB0eik7XG4gICAgICB0eiA9IHJhbmdlKE1hdGguY2VpbCh4MCAvIHR6KSAqIHR6LCB4MSwgdHopOyAvLyBleGNsdXNpdmVcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgYW55IHRocmVzaG9sZHMgb3V0c2lkZSB0aGUgZG9tYWluLlxuICAgIHZhciBtID0gdHoubGVuZ3RoO1xuICAgIHdoaWxlICh0elswXSA8PSB4MCkgdHouc2hpZnQoKSwgLS1tO1xuICAgIHdoaWxlICh0elttIC0gMV0gPiB4MSkgdHoucG9wKCksIC0tbTtcblxuICAgIHZhciBiaW5zID0gbmV3IEFycmF5KG0gKyAxKSxcbiAgICAgICAgYmluO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBiaW5zLlxuICAgIGZvciAoaSA9IDA7IGkgPD0gbTsgKytpKSB7XG4gICAgICBiaW4gPSBiaW5zW2ldID0gW107XG4gICAgICBiaW4ueDAgPSBpID4gMCA/IHR6W2kgLSAxXSA6IHgwO1xuICAgICAgYmluLngxID0gaSA8IG0gPyB0eltpXSA6IHgxO1xuICAgIH1cblxuICAgIC8vIEFzc2lnbiBkYXRhIHRvIGJpbnMgYnkgdmFsdWUsIGlnbm9yaW5nIGFueSBvdXRzaWRlIHRoZSBkb21haW4uXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgeCA9IHZhbHVlc1tpXTtcbiAgICAgIGlmICh4MCA8PSB4ICYmIHggPD0geDEpIHtcbiAgICAgICAgYmluc1tiaXNlY3QodHosIHgsIDAsIG0pXS5wdXNoKGRhdGFbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBiaW5zO1xuICB9XG5cbiAgaGlzdG9ncmFtLnZhbHVlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHZhbHVlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChfKSwgaGlzdG9ncmFtKSA6IHZhbHVlO1xuICB9O1xuXG4gIGhpc3RvZ3JhbS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZG9tYWluID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChbX1swXSwgX1sxXV0pLCBoaXN0b2dyYW0pIDogZG9tYWluO1xuICB9O1xuXG4gIGhpc3RvZ3JhbS50aHJlc2hvbGRzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRocmVzaG9sZCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogQXJyYXkuaXNBcnJheShfKSA/IGNvbnN0YW50KHNsaWNlLmNhbGwoXykpIDogY29uc3RhbnQoXyksIGhpc3RvZ3JhbSkgOiB0aHJlc2hvbGQ7XG4gIH07XG5cbiAgcmV0dXJuIGhpc3RvZ3JhbTtcbn1cbiIsImltcG9ydCBudW1iZXIgZnJvbSBcIi4vbnVtYmVyXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlcywgcCwgdmFsdWVvZikge1xuICBpZiAodmFsdWVvZiA9PSBudWxsKSB2YWx1ZW9mID0gbnVtYmVyO1xuICBpZiAoIShuID0gdmFsdWVzLmxlbmd0aCkpIHJldHVybjtcbiAgaWYgKChwID0gK3ApIDw9IDAgfHwgbiA8IDIpIHJldHVybiArdmFsdWVvZih2YWx1ZXNbMF0sIDAsIHZhbHVlcyk7XG4gIGlmIChwID49IDEpIHJldHVybiArdmFsdWVvZih2YWx1ZXNbbiAtIDFdLCBuIC0gMSwgdmFsdWVzKTtcbiAgdmFyIG4sXG4gICAgICBpID0gKG4gLSAxKSAqIHAsXG4gICAgICBpMCA9IE1hdGguZmxvb3IoaSksXG4gICAgICB2YWx1ZTAgPSArdmFsdWVvZih2YWx1ZXNbaTBdLCBpMCwgdmFsdWVzKSxcbiAgICAgIHZhbHVlMSA9ICt2YWx1ZW9mKHZhbHVlc1tpMCArIDFdLCBpMCArIDEsIHZhbHVlcyk7XG4gIHJldHVybiB2YWx1ZTAgKyAodmFsdWUxIC0gdmFsdWUwKSAqIChpIC0gaTApO1xufVxuIiwiaW1wb3J0IHttYXB9IGZyb20gXCIuLi9hcnJheVwiO1xuaW1wb3J0IGFzY2VuZGluZyBmcm9tIFwiLi4vYXNjZW5kaW5nXCI7XG5pbXBvcnQgbnVtYmVyIGZyb20gXCIuLi9udW1iZXJcIjtcbmltcG9ydCBxdWFudGlsZSBmcm9tIFwiLi4vcXVhbnRpbGVcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWVzLCBtaW4sIG1heCkge1xuICB2YWx1ZXMgPSBtYXAuY2FsbCh2YWx1ZXMsIG51bWJlcikuc29ydChhc2NlbmRpbmcpO1xuICByZXR1cm4gTWF0aC5jZWlsKChtYXggLSBtaW4pIC8gKDIgKiAocXVhbnRpbGUodmFsdWVzLCAwLjc1KSAtIHF1YW50aWxlKHZhbHVlcywgMC4yNSkpICogTWF0aC5wb3codmFsdWVzLmxlbmd0aCwgLTEgLyAzKSkpO1xufVxuIiwiaW1wb3J0IGRldmlhdGlvbiBmcm9tIFwiLi4vZGV2aWF0aW9uXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlcywgbWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGguY2VpbCgobWF4IC0gbWluKSAvICgzLjUgKiBkZXZpYXRpb24odmFsdWVzKSAqIE1hdGgucG93KHZhbHVlcy5sZW5ndGgsIC0xIC8gMykpKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlcywgdmFsdWVvZikge1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBpID0gLTEsXG4gICAgICB2YWx1ZSxcbiAgICAgIG1heDtcblxuICBpZiAodmFsdWVvZiA9PSBudWxsKSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIHsgLy8gRmluZCB0aGUgZmlyc3QgY29tcGFyYWJsZSB2YWx1ZS5cbiAgICAgIGlmICgodmFsdWUgPSB2YWx1ZXNbaV0pICE9IG51bGwgJiYgdmFsdWUgPj0gdmFsdWUpIHtcbiAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIENvbXBhcmUgdGhlIHJlbWFpbmluZyB2YWx1ZXMuXG4gICAgICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlc1tpXSkgIT0gbnVsbCAmJiB2YWx1ZSA+IG1heCkge1xuICAgICAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZWxzZSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIHsgLy8gRmluZCB0aGUgZmlyc3QgY29tcGFyYWJsZSB2YWx1ZS5cbiAgICAgIGlmICgodmFsdWUgPSB2YWx1ZW9mKHZhbHVlc1tpXSwgaSwgdmFsdWVzKSkgIT0gbnVsbCAmJiB2YWx1ZSA+PSB2YWx1ZSkge1xuICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHsgLy8gQ29tcGFyZSB0aGUgcmVtYWluaW5nIHZhbHVlcy5cbiAgICAgICAgICBpZiAoKHZhbHVlID0gdmFsdWVvZih2YWx1ZXNbaV0sIGksIHZhbHVlcykpICE9IG51bGwgJiYgdmFsdWUgPiBtYXgpIHtcbiAgICAgICAgICAgIG1heCA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXg7XG59XG4iLCJpbXBvcnQgbnVtYmVyIGZyb20gXCIuL251bWJlclwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgbSA9IG4sXG4gICAgICBpID0gLTEsXG4gICAgICB2YWx1ZSxcbiAgICAgIHN1bSA9IDA7XG5cbiAgaWYgKHZhbHVlb2YgPT0gbnVsbCkge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBpZiAoIWlzTmFOKHZhbHVlID0gbnVtYmVyKHZhbHVlc1tpXSkpKSBzdW0gKz0gdmFsdWU7XG4gICAgICBlbHNlIC0tbTtcbiAgICB9XG4gIH1cblxuICBlbHNlIHtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgaWYgKCFpc05hTih2YWx1ZSA9IG51bWJlcih2YWx1ZW9mKHZhbHVlc1tpXSwgaSwgdmFsdWVzKSkpKSBzdW0gKz0gdmFsdWU7XG4gICAgICBlbHNlIC0tbTtcbiAgICB9XG4gIH1cblxuICBpZiAobSkgcmV0dXJuIHN1bSAvIG07XG59XG4iLCJpbXBvcnQgYXNjZW5kaW5nIGZyb20gXCIuL2FzY2VuZGluZ1wiO1xuaW1wb3J0IG51bWJlciBmcm9tIFwiLi9udW1iZXJcIjtcbmltcG9ydCBxdWFudGlsZSBmcm9tIFwiLi9xdWFudGlsZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgaSA9IC0xLFxuICAgICAgdmFsdWUsXG4gICAgICBudW1iZXJzID0gW107XG5cbiAgaWYgKHZhbHVlb2YgPT0gbnVsbCkge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBpZiAoIWlzTmFOKHZhbHVlID0gbnVtYmVyKHZhbHVlc1tpXSkpKSB7XG4gICAgICAgIG51bWJlcnMucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZWxzZSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGlmICghaXNOYU4odmFsdWUgPSBudW1iZXIodmFsdWVvZih2YWx1ZXNbaV0sIGksIHZhbHVlcykpKSkge1xuICAgICAgICBudW1iZXJzLnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBxdWFudGlsZShudW1iZXJzLnNvcnQoYXNjZW5kaW5nKSwgMC41KTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGFycmF5cykge1xuICB2YXIgbiA9IGFycmF5cy5sZW5ndGgsXG4gICAgICBtLFxuICAgICAgaSA9IC0xLFxuICAgICAgaiA9IDAsXG4gICAgICBtZXJnZWQsXG4gICAgICBhcnJheTtcblxuICB3aGlsZSAoKytpIDwgbikgaiArPSBhcnJheXNbaV0ubGVuZ3RoO1xuICBtZXJnZWQgPSBuZXcgQXJyYXkoaik7XG5cbiAgd2hpbGUgKC0tbiA+PSAwKSB7XG4gICAgYXJyYXkgPSBhcnJheXNbbl07XG4gICAgbSA9IGFycmF5Lmxlbmd0aDtcbiAgICB3aGlsZSAoLS1tID49IDApIHtcbiAgICAgIG1lcmdlZFstLWpdID0gYXJyYXlbbV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1lcmdlZDtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlcywgdmFsdWVvZikge1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBpID0gLTEsXG4gICAgICB2YWx1ZSxcbiAgICAgIG1pbjtcblxuICBpZiAodmFsdWVvZiA9PSBudWxsKSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIHsgLy8gRmluZCB0aGUgZmlyc3QgY29tcGFyYWJsZSB2YWx1ZS5cbiAgICAgIGlmICgodmFsdWUgPSB2YWx1ZXNbaV0pICE9IG51bGwgJiYgdmFsdWUgPj0gdmFsdWUpIHtcbiAgICAgICAgbWluID0gdmFsdWU7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIENvbXBhcmUgdGhlIHJlbWFpbmluZyB2YWx1ZXMuXG4gICAgICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlc1tpXSkgIT0gbnVsbCAmJiBtaW4gPiB2YWx1ZSkge1xuICAgICAgICAgICAgbWluID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZWxzZSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIHsgLy8gRmluZCB0aGUgZmlyc3QgY29tcGFyYWJsZSB2YWx1ZS5cbiAgICAgIGlmICgodmFsdWUgPSB2YWx1ZW9mKHZhbHVlc1tpXSwgaSwgdmFsdWVzKSkgIT0gbnVsbCAmJiB2YWx1ZSA+PSB2YWx1ZSkge1xuICAgICAgICBtaW4gPSB2YWx1ZTtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHsgLy8gQ29tcGFyZSB0aGUgcmVtYWluaW5nIHZhbHVlcy5cbiAgICAgICAgICBpZiAoKHZhbHVlID0gdmFsdWVvZih2YWx1ZXNbaV0sIGksIHZhbHVlcykpICE9IG51bGwgJiYgbWluID4gdmFsdWUpIHtcbiAgICAgICAgICAgIG1pbiA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtaW47XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhcnJheSwgaW5kZXhlcykge1xuICB2YXIgaSA9IGluZGV4ZXMubGVuZ3RoLCBwZXJtdXRlcyA9IG5ldyBBcnJheShpKTtcbiAgd2hpbGUgKGktLSkgcGVybXV0ZXNbaV0gPSBhcnJheVtpbmRleGVzW2ldXTtcbiAgcmV0dXJuIHBlcm11dGVzO1xufVxuIiwiaW1wb3J0IGFzY2VuZGluZyBmcm9tIFwiLi9hc2NlbmRpbmdcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24odmFsdWVzLCBjb21wYXJlKSB7XG4gIGlmICghKG4gPSB2YWx1ZXMubGVuZ3RoKSkgcmV0dXJuO1xuICB2YXIgbixcbiAgICAgIGkgPSAwLFxuICAgICAgaiA9IDAsXG4gICAgICB4aSxcbiAgICAgIHhqID0gdmFsdWVzW2pdO1xuXG4gIGlmIChjb21wYXJlID09IG51bGwpIGNvbXBhcmUgPSBhc2NlbmRpbmc7XG5cbiAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICBpZiAoY29tcGFyZSh4aSA9IHZhbHVlc1tpXSwgeGopIDwgMCB8fCBjb21wYXJlKHhqLCB4aikgIT09IDApIHtcbiAgICAgIHhqID0geGksIGogPSBpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjb21wYXJlKHhqLCB4aikgPT09IDApIHJldHVybiBqO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYXJyYXksIGkwLCBpMSkge1xuICB2YXIgbSA9IChpMSA9PSBudWxsID8gYXJyYXkubGVuZ3RoIDogaTEpIC0gKGkwID0gaTAgPT0gbnVsbCA/IDAgOiAraTApLFxuICAgICAgdCxcbiAgICAgIGk7XG5cbiAgd2hpbGUgKG0pIHtcbiAgICBpID0gTWF0aC5yYW5kb20oKSAqIG0tLSB8IDA7XG4gICAgdCA9IGFycmF5W20gKyBpMF07XG4gICAgYXJyYXlbbSArIGkwXSA9IGFycmF5W2kgKyBpMF07XG4gICAgYXJyYXlbaSArIGkwXSA9IHQ7XG4gIH1cblxuICByZXR1cm4gYXJyYXk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgaSA9IC0xLFxuICAgICAgdmFsdWUsXG4gICAgICBzdW0gPSAwO1xuXG4gIGlmICh2YWx1ZW9mID09IG51bGwpIHtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgaWYgKHZhbHVlID0gK3ZhbHVlc1tpXSkgc3VtICs9IHZhbHVlOyAvLyBOb3RlOiB6ZXJvIGFuZCBudWxsIGFyZSBlcXVpdmFsZW50LlxuICAgIH1cbiAgfVxuXG4gIGVsc2Uge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBpZiAodmFsdWUgPSArdmFsdWVvZih2YWx1ZXNbaV0sIGksIHZhbHVlcykpIHN1bSArPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VtO1xufVxuIiwiaW1wb3J0IG1pbiBmcm9tIFwiLi9taW5cIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obWF0cml4KSB7XG4gIGlmICghKG4gPSBtYXRyaXgubGVuZ3RoKSkgcmV0dXJuIFtdO1xuICBmb3IgKHZhciBpID0gLTEsIG0gPSBtaW4obWF0cml4LCBsZW5ndGgpLCB0cmFuc3Bvc2UgPSBuZXcgQXJyYXkobSk7ICsraSA8IG07KSB7XG4gICAgZm9yICh2YXIgaiA9IC0xLCBuLCByb3cgPSB0cmFuc3Bvc2VbaV0gPSBuZXcgQXJyYXkobik7ICsraiA8IG47KSB7XG4gICAgICByb3dbal0gPSBtYXRyaXhbal1baV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0cmFuc3Bvc2U7XG59XG5cbmZ1bmN0aW9uIGxlbmd0aChkKSB7XG4gIHJldHVybiBkLmxlbmd0aDtcbn1cbiIsImltcG9ydCB0cmFuc3Bvc2UgZnJvbSBcIi4vdHJhbnNwb3NlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdHJhbnNwb3NlKGFyZ3VtZW50cyk7XG59XG4iLCJleHBvcnQge2RlZmF1bHQgYXMgYmlzZWN0LCBiaXNlY3RSaWdodCwgYmlzZWN0TGVmdH0gZnJvbSBcIi4vYmlzZWN0XCI7XG5leHBvcnQge2RlZmF1bHQgYXMgYXNjZW5kaW5nfSBmcm9tIFwiLi9hc2NlbmRpbmdcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBiaXNlY3Rvcn0gZnJvbSBcIi4vYmlzZWN0b3JcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBjcm9zc30gZnJvbSBcIi4vY3Jvc3NcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBkZXNjZW5kaW5nfSBmcm9tIFwiLi9kZXNjZW5kaW5nXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgZGV2aWF0aW9ufSBmcm9tIFwiLi9kZXZpYXRpb25cIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBleHRlbnR9IGZyb20gXCIuL2V4dGVudFwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGhpc3RvZ3JhbX0gZnJvbSBcIi4vaGlzdG9ncmFtXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgdGhyZXNob2xkRnJlZWRtYW5EaWFjb25pc30gZnJvbSBcIi4vdGhyZXNob2xkL2ZyZWVkbWFuRGlhY29uaXNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB0aHJlc2hvbGRTY290dH0gZnJvbSBcIi4vdGhyZXNob2xkL3Njb3R0XCI7XG5leHBvcnQge2RlZmF1bHQgYXMgdGhyZXNob2xkU3R1cmdlc30gZnJvbSBcIi4vdGhyZXNob2xkL3N0dXJnZXNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBtYXh9IGZyb20gXCIuL21heFwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIG1lYW59IGZyb20gXCIuL21lYW5cIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBtZWRpYW59IGZyb20gXCIuL21lZGlhblwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIG1lcmdlfSBmcm9tIFwiLi9tZXJnZVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIG1pbn0gZnJvbSBcIi4vbWluXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgcGFpcnN9IGZyb20gXCIuL3BhaXJzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgcGVybXV0ZX0gZnJvbSBcIi4vcGVybXV0ZVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHF1YW50aWxlfSBmcm9tIFwiLi9xdWFudGlsZVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHJhbmdlfSBmcm9tIFwiLi9yYW5nZVwiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHNjYW59IGZyb20gXCIuL3NjYW5cIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBzaHVmZmxlfSBmcm9tIFwiLi9zaHVmZmxlXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgc3VtfSBmcm9tIFwiLi9zdW1cIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB0aWNrcywgdGlja0luY3JlbWVudCwgdGlja1N0ZXB9IGZyb20gXCIuL3RpY2tzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgdHJhbnNwb3NlfSBmcm9tIFwiLi90cmFuc3Bvc2VcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB2YXJpYW5jZX0gZnJvbSBcIi4vdmFyaWFuY2VcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB6aXB9IGZyb20gXCIuL3ppcFwiO1xuIiwiZXhwb3J0IGZ1bmN0aW9uIGluaXRSYW5nZShkb21haW4sIHJhbmdlKSB7XG4gIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogYnJlYWs7XG4gICAgY2FzZSAxOiB0aGlzLnJhbmdlKGRvbWFpbik7IGJyZWFrO1xuICAgIGRlZmF1bHQ6IHRoaXMucmFuZ2UocmFuZ2UpLmRvbWFpbihkb21haW4pOyBicmVhaztcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXRJbnRlcnBvbGF0b3IoZG9tYWluLCBpbnRlcnBvbGF0b3IpIHtcbiAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiBicmVhaztcbiAgICBjYXNlIDE6IHRoaXMuaW50ZXJwb2xhdG9yKGRvbWFpbik7IGJyZWFrO1xuICAgIGRlZmF1bHQ6IHRoaXMuaW50ZXJwb2xhdG9yKGludGVycG9sYXRvcikuZG9tYWluKGRvbWFpbik7IGJyZWFrO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuIiwidmFyIGFycmF5ID0gQXJyYXkucHJvdG90eXBlO1xuXG5leHBvcnQgdmFyIG1hcCA9IGFycmF5Lm1hcDtcbmV4cG9ydCB2YXIgc2xpY2UgPSBhcnJheS5zbGljZTtcbiIsImltcG9ydCB7bWFwfSBmcm9tIFwiZDMtY29sbGVjdGlvblwiO1xuaW1wb3J0IHtzbGljZX0gZnJvbSBcIi4vYXJyYXlcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0XCI7XG5cbmV4cG9ydCB2YXIgaW1wbGljaXQgPSB7bmFtZTogXCJpbXBsaWNpdFwifTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gb3JkaW5hbCgpIHtcbiAgdmFyIGluZGV4ID0gbWFwKCksXG4gICAgICBkb21haW4gPSBbXSxcbiAgICAgIHJhbmdlID0gW10sXG4gICAgICB1bmtub3duID0gaW1wbGljaXQ7XG5cbiAgZnVuY3Rpb24gc2NhbGUoZCkge1xuICAgIHZhciBrZXkgPSBkICsgXCJcIiwgaSA9IGluZGV4LmdldChrZXkpO1xuICAgIGlmICghaSkge1xuICAgICAgaWYgKHVua25vd24gIT09IGltcGxpY2l0KSByZXR1cm4gdW5rbm93bjtcbiAgICAgIGluZGV4LnNldChrZXksIGkgPSBkb21haW4ucHVzaChkKSk7XG4gICAgfVxuICAgIHJldHVybiByYW5nZVsoaSAtIDEpICUgcmFuZ2UubGVuZ3RoXTtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkb21haW4uc2xpY2UoKTtcbiAgICBkb21haW4gPSBbXSwgaW5kZXggPSBtYXAoKTtcbiAgICB2YXIgaSA9IC0xLCBuID0gXy5sZW5ndGgsIGQsIGtleTtcbiAgICB3aGlsZSAoKytpIDwgbikgaWYgKCFpbmRleC5oYXMoa2V5ID0gKGQgPSBfW2ldKSArIFwiXCIpKSBpbmRleC5zZXQoa2V5LCBkb21haW4ucHVzaChkKSk7XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmdlID0gc2xpY2UuY2FsbChfKSwgc2NhbGUpIDogcmFuZ2Uuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS51bmtub3duID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHVua25vd24gPSBfLCBzY2FsZSkgOiB1bmtub3duO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gb3JkaW5hbChkb21haW4sIHJhbmdlKS51bmtub3duKHVua25vd24pO1xuICB9O1xuXG4gIGluaXRSYW5nZS5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcblxuICByZXR1cm4gc2NhbGU7XG59XG4iLCJpbXBvcnQge3JhbmdlIGFzIHNlcXVlbmNlfSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0XCI7XG5pbXBvcnQgb3JkaW5hbCBmcm9tIFwiLi9vcmRpbmFsXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJhbmQoKSB7XG4gIHZhciBzY2FsZSA9IG9yZGluYWwoKS51bmtub3duKHVuZGVmaW5lZCksXG4gICAgICBkb21haW4gPSBzY2FsZS5kb21haW4sXG4gICAgICBvcmRpbmFsUmFuZ2UgPSBzY2FsZS5yYW5nZSxcbiAgICAgIHJhbmdlID0gWzAsIDFdLFxuICAgICAgc3RlcCxcbiAgICAgIGJhbmR3aWR0aCxcbiAgICAgIHJvdW5kID0gZmFsc2UsXG4gICAgICBwYWRkaW5nSW5uZXIgPSAwLFxuICAgICAgcGFkZGluZ091dGVyID0gMCxcbiAgICAgIGFsaWduID0gMC41O1xuXG4gIGRlbGV0ZSBzY2FsZS51bmtub3duO1xuXG4gIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgdmFyIG4gPSBkb21haW4oKS5sZW5ndGgsXG4gICAgICAgIHJldmVyc2UgPSByYW5nZVsxXSA8IHJhbmdlWzBdLFxuICAgICAgICBzdGFydCA9IHJhbmdlW3JldmVyc2UgLSAwXSxcbiAgICAgICAgc3RvcCA9IHJhbmdlWzEgLSByZXZlcnNlXTtcbiAgICBzdGVwID0gKHN0b3AgLSBzdGFydCkgLyBNYXRoLm1heCgxLCBuIC0gcGFkZGluZ0lubmVyICsgcGFkZGluZ091dGVyICogMik7XG4gICAgaWYgKHJvdW5kKSBzdGVwID0gTWF0aC5mbG9vcihzdGVwKTtcbiAgICBzdGFydCArPSAoc3RvcCAtIHN0YXJ0IC0gc3RlcCAqIChuIC0gcGFkZGluZ0lubmVyKSkgKiBhbGlnbjtcbiAgICBiYW5kd2lkdGggPSBzdGVwICogKDEgLSBwYWRkaW5nSW5uZXIpO1xuICAgIGlmIChyb3VuZCkgc3RhcnQgPSBNYXRoLnJvdW5kKHN0YXJ0KSwgYmFuZHdpZHRoID0gTWF0aC5yb3VuZChiYW5kd2lkdGgpO1xuICAgIHZhciB2YWx1ZXMgPSBzZXF1ZW5jZShuKS5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gc3RhcnQgKyBzdGVwICogaTsgfSk7XG4gICAgcmV0dXJuIG9yZGluYWxSYW5nZShyZXZlcnNlID8gdmFsdWVzLnJldmVyc2UoKSA6IHZhbHVlcyk7XG4gIH1cblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZG9tYWluKF8pLCByZXNjYWxlKCkpIDogZG9tYWluKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFuZ2UgPSBbK19bMF0sICtfWzFdXSwgcmVzY2FsZSgpKSA6IHJhbmdlLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2VSb3VuZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gcmFuZ2UgPSBbK19bMF0sICtfWzFdXSwgcm91bmQgPSB0cnVlLCByZXNjYWxlKCk7XG4gIH07XG5cbiAgc2NhbGUuYmFuZHdpZHRoID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGJhbmR3aWR0aDtcbiAgfTtcblxuICBzY2FsZS5zdGVwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHN0ZXA7XG4gIH07XG5cbiAgc2NhbGUucm91bmQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocm91bmQgPSAhIV8sIHJlc2NhbGUoKSkgOiByb3VuZDtcbiAgfTtcblxuICBzY2FsZS5wYWRkaW5nID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmdJbm5lciA9IE1hdGgubWluKDEsIHBhZGRpbmdPdXRlciA9ICtfKSwgcmVzY2FsZSgpKSA6IHBhZGRpbmdJbm5lcjtcbiAgfTtcblxuICBzY2FsZS5wYWRkaW5nSW5uZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ0lubmVyID0gTWF0aC5taW4oMSwgXyksIHJlc2NhbGUoKSkgOiBwYWRkaW5nSW5uZXI7XG4gIH07XG5cbiAgc2NhbGUucGFkZGluZ091dGVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmdPdXRlciA9ICtfLCByZXNjYWxlKCkpIDogcGFkZGluZ091dGVyO1xuICB9O1xuXG4gIHNjYWxlLmFsaWduID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGFsaWduID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgXykpLCByZXNjYWxlKCkpIDogYWxpZ247XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBiYW5kKGRvbWFpbigpLCByYW5nZSlcbiAgICAgICAgLnJvdW5kKHJvdW5kKVxuICAgICAgICAucGFkZGluZ0lubmVyKHBhZGRpbmdJbm5lcilcbiAgICAgICAgLnBhZGRpbmdPdXRlcihwYWRkaW5nT3V0ZXIpXG4gICAgICAgIC5hbGlnbihhbGlnbik7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRSYW5nZS5hcHBseShyZXNjYWxlKCksIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIHBvaW50aXNoKHNjYWxlKSB7XG4gIHZhciBjb3B5ID0gc2NhbGUuY29weTtcblxuICBzY2FsZS5wYWRkaW5nID0gc2NhbGUucGFkZGluZ091dGVyO1xuICBkZWxldGUgc2NhbGUucGFkZGluZ0lubmVyO1xuICBkZWxldGUgc2NhbGUucGFkZGluZ091dGVyO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcG9pbnRpc2goY29weSgpKTtcbiAgfTtcblxuICByZXR1cm4gc2NhbGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb2ludCgpIHtcbiAgcmV0dXJuIHBvaW50aXNoKGJhbmQuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5wYWRkaW5nSW5uZXIoMSkpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiAreDtcbn1cbiIsImltcG9ydCB7YmlzZWN0fSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7aW50ZXJwb2xhdGUgYXMgaW50ZXJwb2xhdGVWYWx1ZSwgaW50ZXJwb2xhdGVOdW1iZXIsIGludGVycG9sYXRlUm91bmR9IGZyb20gXCJkMy1pbnRlcnBvbGF0ZVwiO1xuaW1wb3J0IHttYXAsIHNsaWNlfSBmcm9tIFwiLi9hcnJheVwiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50XCI7XG5pbXBvcnQgbnVtYmVyIGZyb20gXCIuL251bWJlclwiO1xuXG52YXIgdW5pdCA9IFswLCAxXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlkZW50aXR5KHgpIHtcbiAgcmV0dXJuIHg7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZShhLCBiKSB7XG4gIHJldHVybiAoYiAtPSAoYSA9ICthKSlcbiAgICAgID8gZnVuY3Rpb24oeCkgeyByZXR1cm4gKHggLSBhKSAvIGI7IH1cbiAgICAgIDogY29uc3RhbnQoaXNOYU4oYikgPyBOYU4gOiAwLjUpO1xufVxuXG5mdW5jdGlvbiBjbGFtcGVyKGRvbWFpbikge1xuICB2YXIgYSA9IGRvbWFpblswXSwgYiA9IGRvbWFpbltkb21haW4ubGVuZ3RoIC0gMV0sIHQ7XG4gIGlmIChhID4gYikgdCA9IGEsIGEgPSBiLCBiID0gdDtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgubWF4KGEsIE1hdGgubWluKGIsIHgpKTsgfTtcbn1cblxuLy8gbm9ybWFsaXplKGEsIGIpKHgpIHRha2VzIGEgZG9tYWluIHZhbHVlIHggaW4gW2EsYl0gYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGFyYW1ldGVyIHQgaW4gWzAsMV0uXG4vLyBpbnRlcnBvbGF0ZShhLCBiKSh0KSB0YWtlcyBhIHBhcmFtZXRlciB0IGluIFswLDFdIGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHJhbmdlIHZhbHVlIHggaW4gW2EsYl0uXG5mdW5jdGlvbiBiaW1hcChkb21haW4sIHJhbmdlLCBpbnRlcnBvbGF0ZSkge1xuICB2YXIgZDAgPSBkb21haW5bMF0sIGQxID0gZG9tYWluWzFdLCByMCA9IHJhbmdlWzBdLCByMSA9IHJhbmdlWzFdO1xuICBpZiAoZDEgPCBkMCkgZDAgPSBub3JtYWxpemUoZDEsIGQwKSwgcjAgPSBpbnRlcnBvbGF0ZShyMSwgcjApO1xuICBlbHNlIGQwID0gbm9ybWFsaXplKGQwLCBkMSksIHIwID0gaW50ZXJwb2xhdGUocjAsIHIxKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHIwKGQwKHgpKTsgfTtcbn1cblxuZnVuY3Rpb24gcG9seW1hcChkb21haW4sIHJhbmdlLCBpbnRlcnBvbGF0ZSkge1xuICB2YXIgaiA9IE1hdGgubWluKGRvbWFpbi5sZW5ndGgsIHJhbmdlLmxlbmd0aCkgLSAxLFxuICAgICAgZCA9IG5ldyBBcnJheShqKSxcbiAgICAgIHIgPSBuZXcgQXJyYXkoaiksXG4gICAgICBpID0gLTE7XG5cbiAgLy8gUmV2ZXJzZSBkZXNjZW5kaW5nIGRvbWFpbnMuXG4gIGlmIChkb21haW5bal0gPCBkb21haW5bMF0pIHtcbiAgICBkb21haW4gPSBkb21haW4uc2xpY2UoKS5yZXZlcnNlKCk7XG4gICAgcmFuZ2UgPSByYW5nZS5zbGljZSgpLnJldmVyc2UoKTtcbiAgfVxuXG4gIHdoaWxlICgrK2kgPCBqKSB7XG4gICAgZFtpXSA9IG5vcm1hbGl6ZShkb21haW5baV0sIGRvbWFpbltpICsgMV0pO1xuICAgIHJbaV0gPSBpbnRlcnBvbGF0ZShyYW5nZVtpXSwgcmFuZ2VbaSArIDFdKTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgdmFyIGkgPSBiaXNlY3QoZG9tYWluLCB4LCAxLCBqKSAtIDE7XG4gICAgcmV0dXJuIHJbaV0oZFtpXSh4KSk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KHNvdXJjZSwgdGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXRcbiAgICAgIC5kb21haW4oc291cmNlLmRvbWFpbigpKVxuICAgICAgLnJhbmdlKHNvdXJjZS5yYW5nZSgpKVxuICAgICAgLmludGVycG9sYXRlKHNvdXJjZS5pbnRlcnBvbGF0ZSgpKVxuICAgICAgLmNsYW1wKHNvdXJjZS5jbGFtcCgpKVxuICAgICAgLnVua25vd24oc291cmNlLnVua25vd24oKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1lcigpIHtcbiAgdmFyIGRvbWFpbiA9IHVuaXQsXG4gICAgICByYW5nZSA9IHVuaXQsXG4gICAgICBpbnRlcnBvbGF0ZSA9IGludGVycG9sYXRlVmFsdWUsXG4gICAgICB0cmFuc2Zvcm0sXG4gICAgICB1bnRyYW5zZm9ybSxcbiAgICAgIHVua25vd24sXG4gICAgICBjbGFtcCA9IGlkZW50aXR5LFxuICAgICAgcGllY2V3aXNlLFxuICAgICAgb3V0cHV0LFxuICAgICAgaW5wdXQ7XG5cbiAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICBwaWVjZXdpc2UgPSBNYXRoLm1pbihkb21haW4ubGVuZ3RoLCByYW5nZS5sZW5ndGgpID4gMiA/IHBvbHltYXAgOiBiaW1hcDtcbiAgICBvdXRwdXQgPSBpbnB1dCA9IG51bGw7XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgIHJldHVybiBpc05hTih4ID0gK3gpID8gdW5rbm93biA6IChvdXRwdXQgfHwgKG91dHB1dCA9IHBpZWNld2lzZShkb21haW4ubWFwKHRyYW5zZm9ybSksIHJhbmdlLCBpbnRlcnBvbGF0ZSkpKSh0cmFuc2Zvcm0oY2xhbXAoeCkpKTtcbiAgfVxuXG4gIHNjYWxlLmludmVydCA9IGZ1bmN0aW9uKHkpIHtcbiAgICByZXR1cm4gY2xhbXAodW50cmFuc2Zvcm0oKGlucHV0IHx8IChpbnB1dCA9IHBpZWNld2lzZShyYW5nZSwgZG9tYWluLm1hcCh0cmFuc2Zvcm0pLCBpbnRlcnBvbGF0ZU51bWJlcikpKSh5KSkpO1xuICB9O1xuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4gPSBtYXAuY2FsbChfLCBudW1iZXIpLCBjbGFtcCA9PT0gaWRlbnRpdHkgfHwgKGNsYW1wID0gY2xhbXBlcihkb21haW4pKSwgcmVzY2FsZSgpKSA6IGRvbWFpbi5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmdlID0gc2xpY2UuY2FsbChfKSwgcmVzY2FsZSgpKSA6IHJhbmdlLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2VSb3VuZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gcmFuZ2UgPSBzbGljZS5jYWxsKF8pLCBpbnRlcnBvbGF0ZSA9IGludGVycG9sYXRlUm91bmQsIHJlc2NhbGUoKTtcbiAgfTtcblxuICBzY2FsZS5jbGFtcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjbGFtcCA9IF8gPyBjbGFtcGVyKGRvbWFpbikgOiBpZGVudGl0eSwgc2NhbGUpIDogY2xhbXAgIT09IGlkZW50aXR5O1xuICB9O1xuXG4gIHNjYWxlLmludGVycG9sYXRlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGludGVycG9sYXRlID0gXywgcmVzY2FsZSgpKSA6IGludGVycG9sYXRlO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHQsIHUpIHtcbiAgICB0cmFuc2Zvcm0gPSB0LCB1bnRyYW5zZm9ybSA9IHU7XG4gICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29udGludW91cyh0cmFuc2Zvcm0sIHVudHJhbnNmb3JtKSB7XG4gIHJldHVybiB0cmFuc2Zvcm1lcigpKHRyYW5zZm9ybSwgdW50cmFuc2Zvcm0pO1xufVxuIiwiaW1wb3J0IHt0aWNrU3RlcH0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge2Zvcm1hdCwgZm9ybWF0UHJlZml4LCBmb3JtYXRTcGVjaWZpZXIsIHByZWNpc2lvbkZpeGVkLCBwcmVjaXNpb25QcmVmaXgsIHByZWNpc2lvblJvdW5kfSBmcm9tIFwiZDMtZm9ybWF0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBjb3VudCwgc3BlY2lmaWVyKSB7XG4gIHZhciBzdGVwID0gdGlja1N0ZXAoc3RhcnQsIHN0b3AsIGNvdW50KSxcbiAgICAgIHByZWNpc2lvbjtcbiAgc3BlY2lmaWVyID0gZm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllciA9PSBudWxsID8gXCIsZlwiIDogc3BlY2lmaWVyKTtcbiAgc3dpdGNoIChzcGVjaWZpZXIudHlwZSkge1xuICAgIGNhc2UgXCJzXCI6IHtcbiAgICAgIHZhciB2YWx1ZSA9IE1hdGgubWF4KE1hdGguYWJzKHN0YXJ0KSwgTWF0aC5hYnMoc3RvcCkpO1xuICAgICAgaWYgKHNwZWNpZmllci5wcmVjaXNpb24gPT0gbnVsbCAmJiAhaXNOYU4ocHJlY2lzaW9uID0gcHJlY2lzaW9uUHJlZml4KHN0ZXAsIHZhbHVlKSkpIHNwZWNpZmllci5wcmVjaXNpb24gPSBwcmVjaXNpb247XG4gICAgICByZXR1cm4gZm9ybWF0UHJlZml4KHNwZWNpZmllciwgdmFsdWUpO1xuICAgIH1cbiAgICBjYXNlIFwiXCI6XG4gICAgY2FzZSBcImVcIjpcbiAgICBjYXNlIFwiZ1wiOlxuICAgIGNhc2UgXCJwXCI6XG4gICAgY2FzZSBcInJcIjoge1xuICAgICAgaWYgKHNwZWNpZmllci5wcmVjaXNpb24gPT0gbnVsbCAmJiAhaXNOYU4ocHJlY2lzaW9uID0gcHJlY2lzaW9uUm91bmQoc3RlcCwgTWF0aC5tYXgoTWF0aC5hYnMoc3RhcnQpLCBNYXRoLmFicyhzdG9wKSkpKSkgc3BlY2lmaWVyLnByZWNpc2lvbiA9IHByZWNpc2lvbiAtIChzcGVjaWZpZXIudHlwZSA9PT0gXCJlXCIpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJmXCI6XG4gICAgY2FzZSBcIiVcIjoge1xuICAgICAgaWYgKHNwZWNpZmllci5wcmVjaXNpb24gPT0gbnVsbCAmJiAhaXNOYU4ocHJlY2lzaW9uID0gcHJlY2lzaW9uRml4ZWQoc3RlcCkpKSBzcGVjaWZpZXIucHJlY2lzaW9uID0gcHJlY2lzaW9uIC0gKHNwZWNpZmllci50eXBlID09PSBcIiVcIikgKiAyO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBmb3JtYXQoc3BlY2lmaWVyKTtcbn1cbiIsImltcG9ydCB7dGlja3MsIHRpY2tJbmNyZW1lbnR9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IGNvbnRpbnVvdXMsIHtjb3B5LCBpZGVudGl0eX0gZnJvbSBcIi4vY29udGludW91c1wiO1xuaW1wb3J0IHtpbml0UmFuZ2V9IGZyb20gXCIuL2luaXRcIjtcbmltcG9ydCB0aWNrRm9ybWF0IGZyb20gXCIuL3RpY2tGb3JtYXRcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhcmlzaChzY2FsZSkge1xuICB2YXIgZG9tYWluID0gc2NhbGUuZG9tYWluO1xuXG4gIHNjYWxlLnRpY2tzID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICB2YXIgZCA9IGRvbWFpbigpO1xuICAgIHJldHVybiB0aWNrcyhkWzBdLCBkW2QubGVuZ3RoIC0gMV0sIGNvdW50ID09IG51bGwgPyAxMCA6IGNvdW50KTtcbiAgfTtcblxuICBzY2FsZS50aWNrRm9ybWF0ID0gZnVuY3Rpb24oY291bnQsIHNwZWNpZmllcikge1xuICAgIHZhciBkID0gZG9tYWluKCk7XG4gICAgcmV0dXJuIHRpY2tGb3JtYXQoZFswXSwgZFtkLmxlbmd0aCAtIDFdLCBjb3VudCA9PSBudWxsID8gMTAgOiBjb3VudCwgc3BlY2lmaWVyKTtcbiAgfTtcblxuICBzY2FsZS5uaWNlID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICBpZiAoY291bnQgPT0gbnVsbCkgY291bnQgPSAxMDtcblxuICAgIHZhciBkID0gZG9tYWluKCksXG4gICAgICAgIGkwID0gMCxcbiAgICAgICAgaTEgPSBkLmxlbmd0aCAtIDEsXG4gICAgICAgIHN0YXJ0ID0gZFtpMF0sXG4gICAgICAgIHN0b3AgPSBkW2kxXSxcbiAgICAgICAgc3RlcDtcblxuICAgIGlmIChzdG9wIDwgc3RhcnQpIHtcbiAgICAgIHN0ZXAgPSBzdGFydCwgc3RhcnQgPSBzdG9wLCBzdG9wID0gc3RlcDtcbiAgICAgIHN0ZXAgPSBpMCwgaTAgPSBpMSwgaTEgPSBzdGVwO1xuICAgIH1cblxuICAgIHN0ZXAgPSB0aWNrSW5jcmVtZW50KHN0YXJ0LCBzdG9wLCBjb3VudCk7XG5cbiAgICBpZiAoc3RlcCA+IDApIHtcbiAgICAgIHN0YXJ0ID0gTWF0aC5mbG9vcihzdGFydCAvIHN0ZXApICogc3RlcDtcbiAgICAgIHN0b3AgPSBNYXRoLmNlaWwoc3RvcCAvIHN0ZXApICogc3RlcDtcbiAgICAgIHN0ZXAgPSB0aWNrSW5jcmVtZW50KHN0YXJ0LCBzdG9wLCBjb3VudCk7XG4gICAgfSBlbHNlIGlmIChzdGVwIDwgMCkge1xuICAgICAgc3RhcnQgPSBNYXRoLmNlaWwoc3RhcnQgKiBzdGVwKSAvIHN0ZXA7XG4gICAgICBzdG9wID0gTWF0aC5mbG9vcihzdG9wICogc3RlcCkgLyBzdGVwO1xuICAgICAgc3RlcCA9IHRpY2tJbmNyZW1lbnQoc3RhcnQsIHN0b3AsIGNvdW50KTtcbiAgICB9XG5cbiAgICBpZiAoc3RlcCA+IDApIHtcbiAgICAgIGRbaTBdID0gTWF0aC5mbG9vcihzdGFydCAvIHN0ZXApICogc3RlcDtcbiAgICAgIGRbaTFdID0gTWF0aC5jZWlsKHN0b3AgLyBzdGVwKSAqIHN0ZXA7XG4gICAgICBkb21haW4oZCk7XG4gICAgfSBlbHNlIGlmIChzdGVwIDwgMCkge1xuICAgICAgZFtpMF0gPSBNYXRoLmNlaWwoc3RhcnQgKiBzdGVwKSAvIHN0ZXA7XG4gICAgICBkW2kxXSA9IE1hdGguZmxvb3Ioc3RvcCAqIHN0ZXApIC8gc3RlcDtcbiAgICAgIGRvbWFpbihkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2NhbGU7XG4gIH07XG5cbiAgcmV0dXJuIHNjYWxlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsaW5lYXIoKSB7XG4gIHZhciBzY2FsZSA9IGNvbnRpbnVvdXMoaWRlbnRpdHksIGlkZW50aXR5KTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIGxpbmVhcigpKTtcbiAgfTtcblxuICBpbml0UmFuZ2UuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG5cbiAgcmV0dXJuIGxpbmVhcmlzaChzY2FsZSk7XG59XG4iLCJpbXBvcnQge21hcH0gZnJvbSBcIi4vYXJyYXlcIjtcbmltcG9ydCB7bGluZWFyaXNofSBmcm9tIFwiLi9saW5lYXJcIjtcbmltcG9ydCBudW1iZXIgZnJvbSBcIi4vbnVtYmVyXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlkZW50aXR5KGRvbWFpbikge1xuICB2YXIgdW5rbm93bjtcblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgcmV0dXJuIGlzTmFOKHggPSAreCkgPyB1bmtub3duIDogeDtcbiAgfVxuXG4gIHNjYWxlLmludmVydCA9IHNjYWxlO1xuXG4gIHNjYWxlLmRvbWFpbiA9IHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRvbWFpbiA9IG1hcC5jYWxsKF8sIG51bWJlciksIHNjYWxlKSA6IGRvbWFpbi5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpZGVudGl0eShkb21haW4pLnVua25vd24odW5rbm93bik7XG4gIH07XG5cbiAgZG9tYWluID0gYXJndW1lbnRzLmxlbmd0aCA/IG1hcC5jYWxsKGRvbWFpbiwgbnVtYmVyKSA6IFswLCAxXTtcblxuICByZXR1cm4gbGluZWFyaXNoKHNjYWxlKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGRvbWFpbiwgaW50ZXJ2YWwpIHtcbiAgZG9tYWluID0gZG9tYWluLnNsaWNlKCk7XG5cbiAgdmFyIGkwID0gMCxcbiAgICAgIGkxID0gZG9tYWluLmxlbmd0aCAtIDEsXG4gICAgICB4MCA9IGRvbWFpbltpMF0sXG4gICAgICB4MSA9IGRvbWFpbltpMV0sXG4gICAgICB0O1xuXG4gIGlmICh4MSA8IHgwKSB7XG4gICAgdCA9IGkwLCBpMCA9IGkxLCBpMSA9IHQ7XG4gICAgdCA9IHgwLCB4MCA9IHgxLCB4MSA9IHQ7XG4gIH1cblxuICBkb21haW5baTBdID0gaW50ZXJ2YWwuZmxvb3IoeDApO1xuICBkb21haW5baTFdID0gaW50ZXJ2YWwuY2VpbCh4MSk7XG4gIHJldHVybiBkb21haW47XG59XG4iLCJpbXBvcnQge3RpY2tzfSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7Zm9ybWF0fSBmcm9tIFwiZDMtZm9ybWF0XCI7XG5pbXBvcnQgbmljZSBmcm9tIFwiLi9uaWNlXCI7XG5pbXBvcnQge2NvcHksIHRyYW5zZm9ybWVyfSBmcm9tIFwiLi9jb250aW51b3VzXCI7XG5pbXBvcnQge2luaXRSYW5nZX0gZnJvbSBcIi4vaW5pdFwiO1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Mb2coeCkge1xuICByZXR1cm4gTWF0aC5sb2coeCk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybUV4cCh4KSB7XG4gIHJldHVybiBNYXRoLmV4cCh4KTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtTG9nbih4KSB7XG4gIHJldHVybiAtTWF0aC5sb2coLXgpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1FeHBuKHgpIHtcbiAgcmV0dXJuIC1NYXRoLmV4cCgteCk7XG59XG5cbmZ1bmN0aW9uIHBvdzEwKHgpIHtcbiAgcmV0dXJuIGlzRmluaXRlKHgpID8gKyhcIjFlXCIgKyB4KSA6IHggPCAwID8gMCA6IHg7XG59XG5cbmZ1bmN0aW9uIHBvd3AoYmFzZSkge1xuICByZXR1cm4gYmFzZSA9PT0gMTAgPyBwb3cxMFxuICAgICAgOiBiYXNlID09PSBNYXRoLkUgPyBNYXRoLmV4cFxuICAgICAgOiBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLnBvdyhiYXNlLCB4KTsgfTtcbn1cblxuZnVuY3Rpb24gbG9ncChiYXNlKSB7XG4gIHJldHVybiBiYXNlID09PSBNYXRoLkUgPyBNYXRoLmxvZ1xuICAgICAgOiBiYXNlID09PSAxMCAmJiBNYXRoLmxvZzEwXG4gICAgICB8fCBiYXNlID09PSAyICYmIE1hdGgubG9nMlxuICAgICAgfHwgKGJhc2UgPSBNYXRoLmxvZyhiYXNlKSwgZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5sb2coeCkgLyBiYXNlOyB9KTtcbn1cblxuZnVuY3Rpb24gcmVmbGVjdChmKSB7XG4gIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIC1mKC14KTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvZ2dpc2godHJhbnNmb3JtKSB7XG4gIHZhciBzY2FsZSA9IHRyYW5zZm9ybSh0cmFuc2Zvcm1Mb2csIHRyYW5zZm9ybUV4cCksXG4gICAgICBkb21haW4gPSBzY2FsZS5kb21haW4sXG4gICAgICBiYXNlID0gMTAsXG4gICAgICBsb2dzLFxuICAgICAgcG93cztcblxuICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgIGxvZ3MgPSBsb2dwKGJhc2UpLCBwb3dzID0gcG93cChiYXNlKTtcbiAgICBpZiAoZG9tYWluKClbMF0gPCAwKSB7XG4gICAgICBsb2dzID0gcmVmbGVjdChsb2dzKSwgcG93cyA9IHJlZmxlY3QocG93cyk7XG4gICAgICB0cmFuc2Zvcm0odHJhbnNmb3JtTG9nbiwgdHJhbnNmb3JtRXhwbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYW5zZm9ybSh0cmFuc2Zvcm1Mb2csIHRyYW5zZm9ybUV4cCk7XG4gICAgfVxuICAgIHJldHVybiBzY2FsZTtcbiAgfVxuXG4gIHNjYWxlLmJhc2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYmFzZSA9ICtfLCByZXNjYWxlKCkpIDogYmFzZTtcbiAgfTtcblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZG9tYWluKF8pLCByZXNjYWxlKCkpIDogZG9tYWluKCk7XG4gIH07XG5cbiAgc2NhbGUudGlja3MgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIHZhciBkID0gZG9tYWluKCksXG4gICAgICAgIHUgPSBkWzBdLFxuICAgICAgICB2ID0gZFtkLmxlbmd0aCAtIDFdLFxuICAgICAgICByO1xuXG4gICAgaWYgKHIgPSB2IDwgdSkgaSA9IHUsIHUgPSB2LCB2ID0gaTtcblxuICAgIHZhciBpID0gbG9ncyh1KSxcbiAgICAgICAgaiA9IGxvZ3ModiksXG4gICAgICAgIHAsXG4gICAgICAgIGssXG4gICAgICAgIHQsXG4gICAgICAgIG4gPSBjb3VudCA9PSBudWxsID8gMTAgOiArY291bnQsXG4gICAgICAgIHogPSBbXTtcblxuICAgIGlmICghKGJhc2UgJSAxKSAmJiBqIC0gaSA8IG4pIHtcbiAgICAgIGkgPSBNYXRoLnJvdW5kKGkpIC0gMSwgaiA9IE1hdGgucm91bmQoaikgKyAxO1xuICAgICAgaWYgKHUgPiAwKSBmb3IgKDsgaSA8IGo7ICsraSkge1xuICAgICAgICBmb3IgKGsgPSAxLCBwID0gcG93cyhpKTsgayA8IGJhc2U7ICsraykge1xuICAgICAgICAgIHQgPSBwICogaztcbiAgICAgICAgICBpZiAodCA8IHUpIGNvbnRpbnVlO1xuICAgICAgICAgIGlmICh0ID4gdikgYnJlYWs7XG4gICAgICAgICAgei5wdXNoKHQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgZm9yICg7IGkgPCBqOyArK2kpIHtcbiAgICAgICAgZm9yIChrID0gYmFzZSAtIDEsIHAgPSBwb3dzKGkpOyBrID49IDE7IC0taykge1xuICAgICAgICAgIHQgPSBwICogaztcbiAgICAgICAgICBpZiAodCA8IHUpIGNvbnRpbnVlO1xuICAgICAgICAgIGlmICh0ID4gdikgYnJlYWs7XG4gICAgICAgICAgei5wdXNoKHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHogPSB0aWNrcyhpLCBqLCBNYXRoLm1pbihqIC0gaSwgbikpLm1hcChwb3dzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gciA/IHoucmV2ZXJzZSgpIDogejtcbiAgfTtcblxuICBzY2FsZS50aWNrRm9ybWF0ID0gZnVuY3Rpb24oY291bnQsIHNwZWNpZmllcikge1xuICAgIGlmIChzcGVjaWZpZXIgPT0gbnVsbCkgc3BlY2lmaWVyID0gYmFzZSA9PT0gMTAgPyBcIi4wZVwiIDogXCIsXCI7XG4gICAgaWYgKHR5cGVvZiBzcGVjaWZpZXIgIT09IFwiZnVuY3Rpb25cIikgc3BlY2lmaWVyID0gZm9ybWF0KHNwZWNpZmllcik7XG4gICAgaWYgKGNvdW50ID09PSBJbmZpbml0eSkgcmV0dXJuIHNwZWNpZmllcjtcbiAgICBpZiAoY291bnQgPT0gbnVsbCkgY291bnQgPSAxMDtcbiAgICB2YXIgayA9IE1hdGgubWF4KDEsIGJhc2UgKiBjb3VudCAvIHNjYWxlLnRpY2tzKCkubGVuZ3RoKTsgLy8gVE9ETyBmYXN0IGVzdGltYXRlP1xuICAgIHJldHVybiBmdW5jdGlvbihkKSB7XG4gICAgICB2YXIgaSA9IGQgLyBwb3dzKE1hdGgucm91bmQobG9ncyhkKSkpO1xuICAgICAgaWYgKGkgKiBiYXNlIDwgYmFzZSAtIDAuNSkgaSAqPSBiYXNlO1xuICAgICAgcmV0dXJuIGkgPD0gayA/IHNwZWNpZmllcihkKSA6IFwiXCI7XG4gICAgfTtcbiAgfTtcblxuICBzY2FsZS5uaWNlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRvbWFpbihuaWNlKGRvbWFpbigpLCB7XG4gICAgICBmbG9vcjogZnVuY3Rpb24oeCkgeyByZXR1cm4gcG93cyhNYXRoLmZsb29yKGxvZ3MoeCkpKTsgfSxcbiAgICAgIGNlaWw6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHBvd3MoTWF0aC5jZWlsKGxvZ3MoeCkpKTsgfVxuICAgIH0pKTtcbiAgfTtcblxuICByZXR1cm4gc2NhbGU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxvZygpIHtcbiAgdmFyIHNjYWxlID0gbG9nZ2lzaCh0cmFuc2Zvcm1lcigpKS5kb21haW4oWzEsIDEwXSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBsb2coKSkuYmFzZShzY2FsZS5iYXNlKCkpO1xuICB9O1xuXG4gIGluaXRSYW5nZS5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcblxuICByZXR1cm4gc2NhbGU7XG59XG4iLCJpbXBvcnQge2xpbmVhcmlzaH0gZnJvbSBcIi4vbGluZWFyXCI7XG5pbXBvcnQge2NvcHksIHRyYW5zZm9ybWVyfSBmcm9tIFwiLi9jb250aW51b3VzXCI7XG5pbXBvcnQge2luaXRSYW5nZX0gZnJvbSBcIi4vaW5pdFwiO1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TeW1sb2coYykge1xuICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBNYXRoLnNpZ24oeCkgKiBNYXRoLmxvZzFwKE1hdGguYWJzKHggLyBjKSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN5bWV4cChjKSB7XG4gIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIE1hdGguc2lnbih4KSAqIE1hdGguZXhwbTEoTWF0aC5hYnMoeCkpICogYztcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN5bWxvZ2lzaCh0cmFuc2Zvcm0pIHtcbiAgdmFyIGMgPSAxLCBzY2FsZSA9IHRyYW5zZm9ybSh0cmFuc2Zvcm1TeW1sb2coYyksIHRyYW5zZm9ybVN5bWV4cChjKSk7XG5cbiAgc2NhbGUuY29uc3RhbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0cmFuc2Zvcm0odHJhbnNmb3JtU3ltbG9nKGMgPSArXyksIHRyYW5zZm9ybVN5bWV4cChjKSkgOiBjO1xuICB9O1xuXG4gIHJldHVybiBsaW5lYXJpc2goc2NhbGUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzeW1sb2coKSB7XG4gIHZhciBzY2FsZSA9IHN5bWxvZ2lzaCh0cmFuc2Zvcm1lcigpKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIHN5bWxvZygpKS5jb25zdGFudChzY2FsZS5jb25zdGFudCgpKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdFJhbmdlLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuIiwiaW1wb3J0IHtsaW5lYXJpc2h9IGZyb20gXCIuL2xpbmVhclwiO1xuaW1wb3J0IHtjb3B5LCBpZGVudGl0eSwgdHJhbnNmb3JtZXJ9IGZyb20gXCIuL2NvbnRpbnVvdXNcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0XCI7XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVBvdyhleHBvbmVudCkge1xuICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB4IDwgMCA/IC1NYXRoLnBvdygteCwgZXhwb25lbnQpIDogTWF0aC5wb3coeCwgZXhwb25lbnQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TcXJ0KHgpIHtcbiAgcmV0dXJuIHggPCAwID8gLU1hdGguc3FydCgteCkgOiBNYXRoLnNxcnQoeCk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVNxdWFyZSh4KSB7XG4gIHJldHVybiB4IDwgMCA/IC14ICogeCA6IHggKiB4O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG93aXNoKHRyYW5zZm9ybSkge1xuICB2YXIgc2NhbGUgPSB0cmFuc2Zvcm0oaWRlbnRpdHksIGlkZW50aXR5KSxcbiAgICAgIGV4cG9uZW50ID0gMTtcblxuICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgIHJldHVybiBleHBvbmVudCA9PT0gMSA/IHRyYW5zZm9ybShpZGVudGl0eSwgaWRlbnRpdHkpXG4gICAgICAgIDogZXhwb25lbnQgPT09IDAuNSA/IHRyYW5zZm9ybSh0cmFuc2Zvcm1TcXJ0LCB0cmFuc2Zvcm1TcXVhcmUpXG4gICAgICAgIDogdHJhbnNmb3JtKHRyYW5zZm9ybVBvdyhleHBvbmVudCksIHRyYW5zZm9ybVBvdygxIC8gZXhwb25lbnQpKTtcbiAgfVxuXG4gIHNjYWxlLmV4cG9uZW50ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGV4cG9uZW50ID0gK18sIHJlc2NhbGUoKSkgOiBleHBvbmVudDtcbiAgfTtcblxuICByZXR1cm4gbGluZWFyaXNoKHNjYWxlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcG93KCkge1xuICB2YXIgc2NhbGUgPSBwb3dpc2godHJhbnNmb3JtZXIoKSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBwb3coKSkuZXhwb25lbnQoc2NhbGUuZXhwb25lbnQoKSk7XG4gIH07XG5cbiAgaW5pdFJhbmdlLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xuXG4gIHJldHVybiBzY2FsZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNxcnQoKSB7XG4gIHJldHVybiBwb3cuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5leHBvbmVudCgwLjUpO1xufVxuIiwiaW1wb3J0IHthc2NlbmRpbmcsIGJpc2VjdCwgcXVhbnRpbGUgYXMgdGhyZXNob2xkfSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7c2xpY2V9IGZyb20gXCIuL2FycmF5XCI7XG5pbXBvcnQge2luaXRSYW5nZX0gZnJvbSBcIi4vaW5pdFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBxdWFudGlsZSgpIHtcbiAgdmFyIGRvbWFpbiA9IFtdLFxuICAgICAgcmFuZ2UgPSBbXSxcbiAgICAgIHRocmVzaG9sZHMgPSBbXSxcbiAgICAgIHVua25vd247XG5cbiAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICB2YXIgaSA9IDAsIG4gPSBNYXRoLm1heCgxLCByYW5nZS5sZW5ndGgpO1xuICAgIHRocmVzaG9sZHMgPSBuZXcgQXJyYXkobiAtIDEpO1xuICAgIHdoaWxlICgrK2kgPCBuKSB0aHJlc2hvbGRzW2kgLSAxXSA9IHRocmVzaG9sZChkb21haW4sIGkgLyBuKTtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH1cblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgcmV0dXJuIGlzTmFOKHggPSAreCkgPyB1bmtub3duIDogcmFuZ2VbYmlzZWN0KHRocmVzaG9sZHMsIHgpXTtcbiAgfVxuXG4gIHNjYWxlLmludmVydEV4dGVudCA9IGZ1bmN0aW9uKHkpIHtcbiAgICB2YXIgaSA9IHJhbmdlLmluZGV4T2YoeSk7XG4gICAgcmV0dXJuIGkgPCAwID8gW05hTiwgTmFOXSA6IFtcbiAgICAgIGkgPiAwID8gdGhyZXNob2xkc1tpIC0gMV0gOiBkb21haW5bMF0sXG4gICAgICBpIDwgdGhyZXNob2xkcy5sZW5ndGggPyB0aHJlc2hvbGRzW2ldIDogZG9tYWluW2RvbWFpbi5sZW5ndGggLSAxXVxuICAgIF07XG4gIH07XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbi5zbGljZSgpO1xuICAgIGRvbWFpbiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gXy5sZW5ndGgsIGQ7IGkgPCBuOyArK2kpIGlmIChkID0gX1tpXSwgZCAhPSBudWxsICYmICFpc05hTihkID0gK2QpKSBkb21haW4ucHVzaChkKTtcbiAgICBkb21haW4uc29ydChhc2NlbmRpbmcpO1xuICAgIHJldHVybiByZXNjYWxlKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFuZ2UgPSBzbGljZS5jYWxsKF8pLCByZXNjYWxlKCkpIDogcmFuZ2Uuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS51bmtub3duID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHVua25vd24gPSBfLCBzY2FsZSkgOiB1bmtub3duO1xuICB9O1xuXG4gIHNjYWxlLnF1YW50aWxlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aHJlc2hvbGRzLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBxdWFudGlsZSgpXG4gICAgICAgIC5kb21haW4oZG9tYWluKVxuICAgICAgICAucmFuZ2UocmFuZ2UpXG4gICAgICAgIC51bmtub3duKHVua25vd24pO1xuICB9O1xuXG4gIHJldHVybiBpbml0UmFuZ2UuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG4iLCJpbXBvcnQge2Jpc2VjdH0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge3NsaWNlfSBmcm9tIFwiLi9hcnJheVwiO1xuaW1wb3J0IHtsaW5lYXJpc2h9IGZyb20gXCIuL2xpbmVhclwiO1xuaW1wb3J0IHtpbml0UmFuZ2V9IGZyb20gXCIuL2luaXRcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcXVhbnRpemUoKSB7XG4gIHZhciB4MCA9IDAsXG4gICAgICB4MSA9IDEsXG4gICAgICBuID0gMSxcbiAgICAgIGRvbWFpbiA9IFswLjVdLFxuICAgICAgcmFuZ2UgPSBbMCwgMV0sXG4gICAgICB1bmtub3duO1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICByZXR1cm4geCA8PSB4ID8gcmFuZ2VbYmlzZWN0KGRvbWFpbiwgeCwgMCwgbildIDogdW5rbm93bjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgdmFyIGkgPSAtMTtcbiAgICBkb21haW4gPSBuZXcgQXJyYXkobik7XG4gICAgd2hpbGUgKCsraSA8IG4pIGRvbWFpbltpXSA9ICgoaSArIDEpICogeDEgLSAoaSAtIG4pICogeDApIC8gKG4gKyAxKTtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH1cblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeDAgPSArX1swXSwgeDEgPSArX1sxXSwgcmVzY2FsZSgpKSA6IFt4MCwgeDFdO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG4gPSAocmFuZ2UgPSBzbGljZS5jYWxsKF8pKS5sZW5ndGggLSAxLCByZXNjYWxlKCkpIDogcmFuZ2Uuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS5pbnZlcnRFeHRlbnQgPSBmdW5jdGlvbih5KSB7XG4gICAgdmFyIGkgPSByYW5nZS5pbmRleE9mKHkpO1xuICAgIHJldHVybiBpIDwgMCA/IFtOYU4sIE5hTl1cbiAgICAgICAgOiBpIDwgMSA/IFt4MCwgZG9tYWluWzBdXVxuICAgICAgICA6IGkgPj0gbiA/IFtkb21haW5bbiAtIDFdLCB4MV1cbiAgICAgICAgOiBbZG9tYWluW2kgLSAxXSwgZG9tYWluW2ldXTtcbiAgfTtcblxuICBzY2FsZS51bmtub3duID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHVua25vd24gPSBfLCBzY2FsZSkgOiBzY2FsZTtcbiAgfTtcblxuICBzY2FsZS50aHJlc2hvbGRzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRvbWFpbi5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcXVhbnRpemUoKVxuICAgICAgICAuZG9tYWluKFt4MCwgeDFdKVxuICAgICAgICAucmFuZ2UocmFuZ2UpXG4gICAgICAgIC51bmtub3duKHVua25vd24pO1xuICB9O1xuXG4gIHJldHVybiBpbml0UmFuZ2UuYXBwbHkobGluZWFyaXNoKHNjYWxlKSwgYXJndW1lbnRzKTtcbn1cbiIsImltcG9ydCB7YmlzZWN0fSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7c2xpY2V9IGZyb20gXCIuL2FycmF5XCI7XG5pbXBvcnQge2luaXRSYW5nZX0gZnJvbSBcIi4vaW5pdFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0aHJlc2hvbGQoKSB7XG4gIHZhciBkb21haW4gPSBbMC41XSxcbiAgICAgIHJhbmdlID0gWzAsIDFdLFxuICAgICAgdW5rbm93bixcbiAgICAgIG4gPSAxO1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICByZXR1cm4geCA8PSB4ID8gcmFuZ2VbYmlzZWN0KGRvbWFpbiwgeCwgMCwgbildIDogdW5rbm93bjtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4gPSBzbGljZS5jYWxsKF8pLCBuID0gTWF0aC5taW4oZG9tYWluLmxlbmd0aCwgcmFuZ2UubGVuZ3RoIC0gMSksIHNjYWxlKSA6IGRvbWFpbi5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmdlID0gc2xpY2UuY2FsbChfKSwgbiA9IE1hdGgubWluKGRvbWFpbi5sZW5ndGgsIHJhbmdlLmxlbmd0aCAtIDEpLCBzY2FsZSkgOiByYW5nZS5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLmludmVydEV4dGVudCA9IGZ1bmN0aW9uKHkpIHtcbiAgICB2YXIgaSA9IHJhbmdlLmluZGV4T2YoeSk7XG4gICAgcmV0dXJuIFtkb21haW5baSAtIDFdLCBkb21haW5baV1dO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aHJlc2hvbGQoKVxuICAgICAgICAuZG9tYWluKGRvbWFpbilcbiAgICAgICAgLnJhbmdlKHJhbmdlKVxuICAgICAgICAudW5rbm93bih1bmtub3duKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdFJhbmdlLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuIiwiaW1wb3J0IHtiaXNlY3RvciwgdGlja1N0ZXB9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHt0aW1lWWVhciwgdGltZU1vbnRoLCB0aW1lV2VlaywgdGltZURheSwgdGltZUhvdXIsIHRpbWVNaW51dGUsIHRpbWVTZWNvbmQsIHRpbWVNaWxsaXNlY29uZH0gZnJvbSBcImQzLXRpbWVcIjtcbmltcG9ydCB7dGltZUZvcm1hdH0gZnJvbSBcImQzLXRpbWUtZm9ybWF0XCI7XG5pbXBvcnQge21hcH0gZnJvbSBcIi4vYXJyYXlcIjtcbmltcG9ydCBjb250aW51b3VzLCB7Y29weSwgaWRlbnRpdHl9IGZyb20gXCIuL2NvbnRpbnVvdXNcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0XCI7XG5pbXBvcnQgbmljZSBmcm9tIFwiLi9uaWNlXCI7XG5cbnZhciBkdXJhdGlvblNlY29uZCA9IDEwMDAsXG4gICAgZHVyYXRpb25NaW51dGUgPSBkdXJhdGlvblNlY29uZCAqIDYwLFxuICAgIGR1cmF0aW9uSG91ciA9IGR1cmF0aW9uTWludXRlICogNjAsXG4gICAgZHVyYXRpb25EYXkgPSBkdXJhdGlvbkhvdXIgKiAyNCxcbiAgICBkdXJhdGlvbldlZWsgPSBkdXJhdGlvbkRheSAqIDcsXG4gICAgZHVyYXRpb25Nb250aCA9IGR1cmF0aW9uRGF5ICogMzAsXG4gICAgZHVyYXRpb25ZZWFyID0gZHVyYXRpb25EYXkgKiAzNjU7XG5cbmZ1bmN0aW9uIGRhdGUodCkge1xuICByZXR1cm4gbmV3IERhdGUodCk7XG59XG5cbmZ1bmN0aW9uIG51bWJlcih0KSB7XG4gIHJldHVybiB0IGluc3RhbmNlb2YgRGF0ZSA/ICt0IDogK25ldyBEYXRlKCt0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGVuZGFyKHllYXIsIG1vbnRoLCB3ZWVrLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgZm9ybWF0KSB7XG4gIHZhciBzY2FsZSA9IGNvbnRpbnVvdXMoaWRlbnRpdHksIGlkZW50aXR5KSxcbiAgICAgIGludmVydCA9IHNjYWxlLmludmVydCxcbiAgICAgIGRvbWFpbiA9IHNjYWxlLmRvbWFpbjtcblxuICB2YXIgZm9ybWF0TWlsbGlzZWNvbmQgPSBmb3JtYXQoXCIuJUxcIiksXG4gICAgICBmb3JtYXRTZWNvbmQgPSBmb3JtYXQoXCI6JVNcIiksXG4gICAgICBmb3JtYXRNaW51dGUgPSBmb3JtYXQoXCIlSTolTVwiKSxcbiAgICAgIGZvcm1hdEhvdXIgPSBmb3JtYXQoXCIlSSAlcFwiKSxcbiAgICAgIGZvcm1hdERheSA9IGZvcm1hdChcIiVhICVkXCIpLFxuICAgICAgZm9ybWF0V2VlayA9IGZvcm1hdChcIiViICVkXCIpLFxuICAgICAgZm9ybWF0TW9udGggPSBmb3JtYXQoXCIlQlwiKSxcbiAgICAgIGZvcm1hdFllYXIgPSBmb3JtYXQoXCIlWVwiKTtcblxuICB2YXIgdGlja0ludGVydmFscyA9IFtcbiAgICBbc2Vjb25kLCAgMSwgICAgICBkdXJhdGlvblNlY29uZF0sXG4gICAgW3NlY29uZCwgIDUsICA1ICogZHVyYXRpb25TZWNvbmRdLFxuICAgIFtzZWNvbmQsIDE1LCAxNSAqIGR1cmF0aW9uU2Vjb25kXSxcbiAgICBbc2Vjb25kLCAzMCwgMzAgKiBkdXJhdGlvblNlY29uZF0sXG4gICAgW21pbnV0ZSwgIDEsICAgICAgZHVyYXRpb25NaW51dGVdLFxuICAgIFttaW51dGUsICA1LCAgNSAqIGR1cmF0aW9uTWludXRlXSxcbiAgICBbbWludXRlLCAxNSwgMTUgKiBkdXJhdGlvbk1pbnV0ZV0sXG4gICAgW21pbnV0ZSwgMzAsIDMwICogZHVyYXRpb25NaW51dGVdLFxuICAgIFsgIGhvdXIsICAxLCAgICAgIGR1cmF0aW9uSG91ciAgXSxcbiAgICBbICBob3VyLCAgMywgIDMgKiBkdXJhdGlvbkhvdXIgIF0sXG4gICAgWyAgaG91ciwgIDYsICA2ICogZHVyYXRpb25Ib3VyICBdLFxuICAgIFsgIGhvdXIsIDEyLCAxMiAqIGR1cmF0aW9uSG91ciAgXSxcbiAgICBbICAgZGF5LCAgMSwgICAgICBkdXJhdGlvbkRheSAgIF0sXG4gICAgWyAgIGRheSwgIDIsICAyICogZHVyYXRpb25EYXkgICBdLFxuICAgIFsgIHdlZWssICAxLCAgICAgIGR1cmF0aW9uV2VlayAgXSxcbiAgICBbIG1vbnRoLCAgMSwgICAgICBkdXJhdGlvbk1vbnRoIF0sXG4gICAgWyBtb250aCwgIDMsICAzICogZHVyYXRpb25Nb250aCBdLFxuICAgIFsgIHllYXIsICAxLCAgICAgIGR1cmF0aW9uWWVhciAgXVxuICBdO1xuXG4gIGZ1bmN0aW9uIHRpY2tGb3JtYXQoZGF0ZSkge1xuICAgIHJldHVybiAoc2Vjb25kKGRhdGUpIDwgZGF0ZSA/IGZvcm1hdE1pbGxpc2Vjb25kXG4gICAgICAgIDogbWludXRlKGRhdGUpIDwgZGF0ZSA/IGZvcm1hdFNlY29uZFxuICAgICAgICA6IGhvdXIoZGF0ZSkgPCBkYXRlID8gZm9ybWF0TWludXRlXG4gICAgICAgIDogZGF5KGRhdGUpIDwgZGF0ZSA/IGZvcm1hdEhvdXJcbiAgICAgICAgOiBtb250aChkYXRlKSA8IGRhdGUgPyAod2VlayhkYXRlKSA8IGRhdGUgPyBmb3JtYXREYXkgOiBmb3JtYXRXZWVrKVxuICAgICAgICA6IHllYXIoZGF0ZSkgPCBkYXRlID8gZm9ybWF0TW9udGhcbiAgICAgICAgOiBmb3JtYXRZZWFyKShkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRpY2tJbnRlcnZhbChpbnRlcnZhbCwgc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICBpZiAoaW50ZXJ2YWwgPT0gbnVsbCkgaW50ZXJ2YWwgPSAxMDtcblxuICAgIC8vIElmIGEgZGVzaXJlZCB0aWNrIGNvdW50IGlzIHNwZWNpZmllZCwgcGljayBhIHJlYXNvbmFibGUgdGljayBpbnRlcnZhbFxuICAgIC8vIGJhc2VkIG9uIHRoZSBleHRlbnQgb2YgdGhlIGRvbWFpbiBhbmQgYSByb3VnaCBlc3RpbWF0ZSBvZiB0aWNrIHNpemUuXG4gICAgLy8gT3RoZXJ3aXNlLCBhc3N1bWUgaW50ZXJ2YWwgaXMgYWxyZWFkeSBhIHRpbWUgaW50ZXJ2YWwgYW5kIHVzZSBpdC5cbiAgICBpZiAodHlwZW9mIGludGVydmFsID09PSBcIm51bWJlclwiKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gTWF0aC5hYnMoc3RvcCAtIHN0YXJ0KSAvIGludGVydmFsLFxuICAgICAgICAgIGkgPSBiaXNlY3RvcihmdW5jdGlvbihpKSB7IHJldHVybiBpWzJdOyB9KS5yaWdodCh0aWNrSW50ZXJ2YWxzLCB0YXJnZXQpO1xuICAgICAgaWYgKGkgPT09IHRpY2tJbnRlcnZhbHMubGVuZ3RoKSB7XG4gICAgICAgIHN0ZXAgPSB0aWNrU3RlcChzdGFydCAvIGR1cmF0aW9uWWVhciwgc3RvcCAvIGR1cmF0aW9uWWVhciwgaW50ZXJ2YWwpO1xuICAgICAgICBpbnRlcnZhbCA9IHllYXI7XG4gICAgICB9IGVsc2UgaWYgKGkpIHtcbiAgICAgICAgaSA9IHRpY2tJbnRlcnZhbHNbdGFyZ2V0IC8gdGlja0ludGVydmFsc1tpIC0gMV1bMl0gPCB0aWNrSW50ZXJ2YWxzW2ldWzJdIC8gdGFyZ2V0ID8gaSAtIDEgOiBpXTtcbiAgICAgICAgc3RlcCA9IGlbMV07XG4gICAgICAgIGludGVydmFsID0gaVswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ZXAgPSBNYXRoLm1heCh0aWNrU3RlcChzdGFydCwgc3RvcCwgaW50ZXJ2YWwpLCAxKTtcbiAgICAgICAgaW50ZXJ2YWwgPSBtaWxsaXNlY29uZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3RlcCA9PSBudWxsID8gaW50ZXJ2YWwgOiBpbnRlcnZhbC5ldmVyeShzdGVwKTtcbiAgfVxuXG4gIHNjYWxlLmludmVydCA9IGZ1bmN0aW9uKHkpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoaW52ZXJ0KHkpKTtcbiAgfTtcblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBkb21haW4obWFwLmNhbGwoXywgbnVtYmVyKSkgOiBkb21haW4oKS5tYXAoZGF0ZSk7XG4gIH07XG5cbiAgc2NhbGUudGlja3MgPSBmdW5jdGlvbihpbnRlcnZhbCwgc3RlcCkge1xuICAgIHZhciBkID0gZG9tYWluKCksXG4gICAgICAgIHQwID0gZFswXSxcbiAgICAgICAgdDEgPSBkW2QubGVuZ3RoIC0gMV0sXG4gICAgICAgIHIgPSB0MSA8IHQwLFxuICAgICAgICB0O1xuICAgIGlmIChyKSB0ID0gdDAsIHQwID0gdDEsIHQxID0gdDtcbiAgICB0ID0gdGlja0ludGVydmFsKGludGVydmFsLCB0MCwgdDEsIHN0ZXApO1xuICAgIHQgPSB0ID8gdC5yYW5nZSh0MCwgdDEgKyAxKSA6IFtdOyAvLyBpbmNsdXNpdmUgc3RvcFxuICAgIHJldHVybiByID8gdC5yZXZlcnNlKCkgOiB0O1xuICB9O1xuXG4gIHNjYWxlLnRpY2tGb3JtYXQgPSBmdW5jdGlvbihjb3VudCwgc3BlY2lmaWVyKSB7XG4gICAgcmV0dXJuIHNwZWNpZmllciA9PSBudWxsID8gdGlja0Zvcm1hdCA6IGZvcm1hdChzcGVjaWZpZXIpO1xuICB9O1xuXG4gIHNjYWxlLm5pY2UgPSBmdW5jdGlvbihpbnRlcnZhbCwgc3RlcCkge1xuICAgIHZhciBkID0gZG9tYWluKCk7XG4gICAgcmV0dXJuIChpbnRlcnZhbCA9IHRpY2tJbnRlcnZhbChpbnRlcnZhbCwgZFswXSwgZFtkLmxlbmd0aCAtIDFdLCBzdGVwKSlcbiAgICAgICAgPyBkb21haW4obmljZShkLCBpbnRlcnZhbCkpXG4gICAgICAgIDogc2NhbGU7XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBjYWxlbmRhcih5ZWFyLCBtb250aCwgd2VlaywgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIGZvcm1hdCkpO1xuICB9O1xuXG4gIHJldHVybiBzY2FsZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBpbml0UmFuZ2UuYXBwbHkoY2FsZW5kYXIodGltZVllYXIsIHRpbWVNb250aCwgdGltZVdlZWssIHRpbWVEYXksIHRpbWVIb3VyLCB0aW1lTWludXRlLCB0aW1lU2Vjb25kLCB0aW1lTWlsbGlzZWNvbmQsIHRpbWVGb3JtYXQpLmRvbWFpbihbbmV3IERhdGUoMjAwMCwgMCwgMSksIG5ldyBEYXRlKDIwMDAsIDAsIDIpXSksIGFyZ3VtZW50cyk7XG59XG4iLCJpbXBvcnQge2NhbGVuZGFyfSBmcm9tIFwiLi90aW1lXCI7XG5pbXBvcnQge3V0Y0Zvcm1hdH0gZnJvbSBcImQzLXRpbWUtZm9ybWF0XCI7XG5pbXBvcnQge3V0Y1llYXIsIHV0Y01vbnRoLCB1dGNXZWVrLCB1dGNEYXksIHV0Y0hvdXIsIHV0Y01pbnV0ZSwgdXRjU2Vjb25kLCB1dGNNaWxsaXNlY29uZH0gZnJvbSBcImQzLXRpbWVcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gaW5pdFJhbmdlLmFwcGx5KGNhbGVuZGFyKHV0Y1llYXIsIHV0Y01vbnRoLCB1dGNXZWVrLCB1dGNEYXksIHV0Y0hvdXIsIHV0Y01pbnV0ZSwgdXRjU2Vjb25kLCB1dGNNaWxsaXNlY29uZCwgdXRjRm9ybWF0KS5kb21haW4oW0RhdGUuVVRDKDIwMDAsIDAsIDEpLCBEYXRlLlVUQygyMDAwLCAwLCAyKV0pLCBhcmd1bWVudHMpO1xufVxuIiwiaW1wb3J0IHtpZGVudGl0eX0gZnJvbSBcIi4vY29udGludW91c1wiO1xuaW1wb3J0IHtpbml0SW50ZXJwb2xhdG9yfSBmcm9tIFwiLi9pbml0XCI7XG5pbXBvcnQge2xpbmVhcmlzaH0gZnJvbSBcIi4vbGluZWFyXCI7XG5pbXBvcnQge2xvZ2dpc2h9IGZyb20gXCIuL2xvZ1wiO1xuaW1wb3J0IHtzeW1sb2dpc2h9IGZyb20gXCIuL3N5bWxvZ1wiO1xuaW1wb3J0IHtwb3dpc2h9IGZyb20gXCIuL3Bvd1wiO1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1lcigpIHtcbiAgdmFyIHgwID0gMCxcbiAgICAgIHgxID0gMSxcbiAgICAgIHQwLFxuICAgICAgdDEsXG4gICAgICBrMTAsXG4gICAgICB0cmFuc2Zvcm0sXG4gICAgICBpbnRlcnBvbGF0b3IgPSBpZGVudGl0eSxcbiAgICAgIGNsYW1wID0gZmFsc2UsXG4gICAgICB1bmtub3duO1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICByZXR1cm4gaXNOYU4oeCA9ICt4KSA/IHVua25vd24gOiBpbnRlcnBvbGF0b3IoazEwID09PSAwID8gMC41IDogKHggPSAodHJhbnNmb3JtKHgpIC0gdDApICogazEwLCBjbGFtcCA/IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHgpKSA6IHgpKTtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0MCA9IHRyYW5zZm9ybSh4MCA9ICtfWzBdKSwgdDEgPSB0cmFuc2Zvcm0oeDEgPSArX1sxXSksIGsxMCA9IHQwID09PSB0MSA/IDAgOiAxIC8gKHQxIC0gdDApLCBzY2FsZSkgOiBbeDAsIHgxXTtcbiAgfTtcblxuICBzY2FsZS5jbGFtcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjbGFtcCA9ICEhXywgc2NhbGUpIDogY2xhbXA7XG4gIH07XG5cbiAgc2NhbGUuaW50ZXJwb2xhdG9yID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGludGVycG9sYXRvciA9IF8sIHNjYWxlKSA6IGludGVycG9sYXRvcjtcbiAgfTtcblxuICBzY2FsZS51bmtub3duID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHVua25vd24gPSBfLCBzY2FsZSkgOiB1bmtub3duO1xuICB9O1xuXG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdHJhbnNmb3JtID0gdCwgdDAgPSB0KHgwKSwgdDEgPSB0KHgxKSwgazEwID0gdDAgPT09IHQxID8gMCA6IDEgLyAodDEgLSB0MCk7XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29weShzb3VyY2UsIHRhcmdldCkge1xuICByZXR1cm4gdGFyZ2V0XG4gICAgICAuZG9tYWluKHNvdXJjZS5kb21haW4oKSlcbiAgICAgIC5pbnRlcnBvbGF0b3Ioc291cmNlLmludGVycG9sYXRvcigpKVxuICAgICAgLmNsYW1wKHNvdXJjZS5jbGFtcCgpKVxuICAgICAgLnVua25vd24oc291cmNlLnVua25vd24oKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNlcXVlbnRpYWwoKSB7XG4gIHZhciBzY2FsZSA9IGxpbmVhcmlzaCh0cmFuc2Zvcm1lcigpKGlkZW50aXR5KSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBzZXF1ZW50aWFsKCkpO1xuICB9O1xuXG4gIHJldHVybiBpbml0SW50ZXJwb2xhdG9yLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VxdWVudGlhbExvZygpIHtcbiAgdmFyIHNjYWxlID0gbG9nZ2lzaCh0cmFuc2Zvcm1lcigpKS5kb21haW4oWzEsIDEwXSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBzZXF1ZW50aWFsTG9nKCkpLmJhc2Uoc2NhbGUuYmFzZSgpKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdEludGVycG9sYXRvci5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlcXVlbnRpYWxTeW1sb2coKSB7XG4gIHZhciBzY2FsZSA9IHN5bWxvZ2lzaCh0cmFuc2Zvcm1lcigpKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIHNlcXVlbnRpYWxTeW1sb2coKSkuY29uc3RhbnQoc2NhbGUuY29uc3RhbnQoKSk7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRJbnRlcnBvbGF0b3IuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXF1ZW50aWFsUG93KCkge1xuICB2YXIgc2NhbGUgPSBwb3dpc2godHJhbnNmb3JtZXIoKSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBzZXF1ZW50aWFsUG93KCkpLmV4cG9uZW50KHNjYWxlLmV4cG9uZW50KCkpO1xuICB9O1xuXG4gIHJldHVybiBpbml0SW50ZXJwb2xhdG9yLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VxdWVudGlhbFNxcnQoKSB7XG4gIHJldHVybiBzZXF1ZW50aWFsUG93LmFwcGx5KG51bGwsIGFyZ3VtZW50cykuZXhwb25lbnQoMC41KTtcbn1cbiIsImltcG9ydCB7YXNjZW5kaW5nLCBiaXNlY3R9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHtpZGVudGl0eX0gZnJvbSBcIi4vY29udGludW91c1wiO1xuaW1wb3J0IHtpbml0SW50ZXJwb2xhdG9yfSBmcm9tIFwiLi9pbml0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNlcXVlbnRpYWxRdWFudGlsZSgpIHtcbiAgdmFyIGRvbWFpbiA9IFtdLFxuICAgICAgaW50ZXJwb2xhdG9yID0gaWRlbnRpdHk7XG5cbiAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgIGlmICghaXNOYU4oeCA9ICt4KSkgcmV0dXJuIGludGVycG9sYXRvcigoYmlzZWN0KGRvbWFpbiwgeCkgLSAxKSAvIChkb21haW4ubGVuZ3RoIC0gMSkpO1xuICB9XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbi5zbGljZSgpO1xuICAgIGRvbWFpbiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gXy5sZW5ndGgsIGQ7IGkgPCBuOyArK2kpIGlmIChkID0gX1tpXSwgZCAhPSBudWxsICYmICFpc05hTihkID0gK2QpKSBkb21haW4ucHVzaChkKTtcbiAgICBkb21haW4uc29ydChhc2NlbmRpbmcpO1xuICAgIHJldHVybiBzY2FsZTtcbiAgfTtcblxuICBzY2FsZS5pbnRlcnBvbGF0b3IgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaW50ZXJwb2xhdG9yID0gXywgc2NhbGUpIDogaW50ZXJwb2xhdG9yO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2VxdWVudGlhbFF1YW50aWxlKGludGVycG9sYXRvcikuZG9tYWluKGRvbWFpbik7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRJbnRlcnBvbGF0b3IuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG4iLCJpbXBvcnQge2lkZW50aXR5fSBmcm9tIFwiLi9jb250aW51b3VzXCI7XG5pbXBvcnQge2luaXRJbnRlcnBvbGF0b3J9IGZyb20gXCIuL2luaXRcIjtcbmltcG9ydCB7bGluZWFyaXNofSBmcm9tIFwiLi9saW5lYXJcIjtcbmltcG9ydCB7bG9nZ2lzaH0gZnJvbSBcIi4vbG9nXCI7XG5pbXBvcnQge2NvcHl9IGZyb20gXCIuL3NlcXVlbnRpYWxcIjtcbmltcG9ydCB7c3ltbG9naXNofSBmcm9tIFwiLi9zeW1sb2dcIjtcbmltcG9ydCB7cG93aXNofSBmcm9tIFwiLi9wb3dcIjtcblxuZnVuY3Rpb24gdHJhbnNmb3JtZXIoKSB7XG4gIHZhciB4MCA9IDAsXG4gICAgICB4MSA9IDAuNSxcbiAgICAgIHgyID0gMSxcbiAgICAgIHQwLFxuICAgICAgdDEsXG4gICAgICB0MixcbiAgICAgIGsxMCxcbiAgICAgIGsyMSxcbiAgICAgIGludGVycG9sYXRvciA9IGlkZW50aXR5LFxuICAgICAgdHJhbnNmb3JtLFxuICAgICAgY2xhbXAgPSBmYWxzZSxcbiAgICAgIHVua25vd247XG5cbiAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgIHJldHVybiBpc05hTih4ID0gK3gpID8gdW5rbm93biA6ICh4ID0gMC41ICsgKCh4ID0gK3RyYW5zZm9ybSh4KSkgLSB0MSkgKiAoeCA8IHQxID8gazEwIDogazIxKSwgaW50ZXJwb2xhdG9yKGNsYW1wID8gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgeCkpIDogeCkpO1xuICB9XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHQwID0gdHJhbnNmb3JtKHgwID0gK19bMF0pLCB0MSA9IHRyYW5zZm9ybSh4MSA9ICtfWzFdKSwgdDIgPSB0cmFuc2Zvcm0oeDIgPSArX1syXSksIGsxMCA9IHQwID09PSB0MSA/IDAgOiAwLjUgLyAodDEgLSB0MCksIGsyMSA9IHQxID09PSB0MiA/IDAgOiAwLjUgLyAodDIgLSB0MSksIHNjYWxlKSA6IFt4MCwgeDEsIHgyXTtcbiAgfTtcblxuICBzY2FsZS5jbGFtcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjbGFtcCA9ICEhXywgc2NhbGUpIDogY2xhbXA7XG4gIH07XG5cbiAgc2NhbGUuaW50ZXJwb2xhdG9yID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGludGVycG9sYXRvciA9IF8sIHNjYWxlKSA6IGludGVycG9sYXRvcjtcbiAgfTtcblxuICBzY2FsZS51bmtub3duID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHVua25vd24gPSBfLCBzY2FsZSkgOiB1bmtub3duO1xuICB9O1xuXG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdHJhbnNmb3JtID0gdCwgdDAgPSB0KHgwKSwgdDEgPSB0KHgxKSwgdDIgPSB0KHgyKSwgazEwID0gdDAgPT09IHQxID8gMCA6IDAuNSAvICh0MSAtIHQwKSwgazIxID0gdDEgPT09IHQyID8gMCA6IDAuNSAvICh0MiAtIHQxKTtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRpdmVyZ2luZygpIHtcbiAgdmFyIHNjYWxlID0gbGluZWFyaXNoKHRyYW5zZm9ybWVyKCkoaWRlbnRpdHkpKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIGRpdmVyZ2luZygpKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdEludGVycG9sYXRvci5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpdmVyZ2luZ0xvZygpIHtcbiAgdmFyIHNjYWxlID0gbG9nZ2lzaCh0cmFuc2Zvcm1lcigpKS5kb21haW4oWzAuMSwgMSwgMTBdKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIGRpdmVyZ2luZ0xvZygpKS5iYXNlKHNjYWxlLmJhc2UoKSk7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRJbnRlcnBvbGF0b3IuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXZlcmdpbmdTeW1sb2coKSB7XG4gIHZhciBzY2FsZSA9IHN5bWxvZ2lzaCh0cmFuc2Zvcm1lcigpKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIGRpdmVyZ2luZ1N5bWxvZygpKS5jb25zdGFudChzY2FsZS5jb25zdGFudCgpKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdEludGVycG9sYXRvci5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpdmVyZ2luZ1BvdygpIHtcbiAgdmFyIHNjYWxlID0gcG93aXNoKHRyYW5zZm9ybWVyKCkpO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgZGl2ZXJnaW5nUG93KCkpLmV4cG9uZW50KHNjYWxlLmV4cG9uZW50KCkpO1xuICB9O1xuXG4gIHJldHVybiBpbml0SW50ZXJwb2xhdG9yLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGl2ZXJnaW5nU3FydCgpIHtcbiAgcmV0dXJuIGRpdmVyZ2luZ1Bvdy5hcHBseShudWxsLCBhcmd1bWVudHMpLmV4cG9uZW50KDAuNSk7XG59XG4iLCJleHBvcnQge1xuICBkZWZhdWx0IGFzIHNjYWxlQmFuZCxcbiAgcG9pbnQgYXMgc2NhbGVQb2ludFxufSBmcm9tIFwiLi9iYW5kXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgc2NhbGVJZGVudGl0eVxufSBmcm9tIFwiLi9pZGVudGl0eVwiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIHNjYWxlTGluZWFyXG59IGZyb20gXCIuL2xpbmVhclwiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIHNjYWxlTG9nXG59IGZyb20gXCIuL2xvZ1wiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIHNjYWxlU3ltbG9nXG59IGZyb20gXCIuL3N5bWxvZ1wiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIHNjYWxlT3JkaW5hbCxcbiAgaW1wbGljaXQgYXMgc2NhbGVJbXBsaWNpdFxufSBmcm9tIFwiLi9vcmRpbmFsXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgc2NhbGVQb3csXG4gIHNxcnQgYXMgc2NhbGVTcXJ0XG59IGZyb20gXCIuL3Bvd1wiO1xuXG5leHBvcnQge1xuICBkZWZhdWx0IGFzIHNjYWxlUXVhbnRpbGVcbn0gZnJvbSBcIi4vcXVhbnRpbGVcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyBzY2FsZVF1YW50aXplXG59IGZyb20gXCIuL3F1YW50aXplXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgc2NhbGVUaHJlc2hvbGRcbn0gZnJvbSBcIi4vdGhyZXNob2xkXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgc2NhbGVUaW1lXG59IGZyb20gXCIuL3RpbWVcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyBzY2FsZVV0Y1xufSBmcm9tIFwiLi91dGNUaW1lXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgc2NhbGVTZXF1ZW50aWFsLFxuICBzZXF1ZW50aWFsTG9nIGFzIHNjYWxlU2VxdWVudGlhbExvZyxcbiAgc2VxdWVudGlhbFBvdyBhcyBzY2FsZVNlcXVlbnRpYWxQb3csXG4gIHNlcXVlbnRpYWxTcXJ0IGFzIHNjYWxlU2VxdWVudGlhbFNxcnQsXG4gIHNlcXVlbnRpYWxTeW1sb2cgYXMgc2NhbGVTZXF1ZW50aWFsU3ltbG9nXG59IGZyb20gXCIuL3NlcXVlbnRpYWxcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyBzY2FsZVNlcXVlbnRpYWxRdWFudGlsZVxufSBmcm9tIFwiLi9zZXF1ZW50aWFsUXVhbnRpbGVcIjtcblxuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyBzY2FsZURpdmVyZ2luZyxcbiAgZGl2ZXJnaW5nTG9nIGFzIHNjYWxlRGl2ZXJnaW5nTG9nLFxuICBkaXZlcmdpbmdQb3cgYXMgc2NhbGVEaXZlcmdpbmdQb3csXG4gIGRpdmVyZ2luZ1NxcnQgYXMgc2NhbGVEaXZlcmdpbmdTcXJ0LFxuICBkaXZlcmdpbmdTeW1sb2cgYXMgc2NhbGVEaXZlcmdpbmdTeW1sb2dcbn0gZnJvbSBcIi4vZGl2ZXJnaW5nXCI7XG5cbmV4cG9ydCB7XG4gIGRlZmF1bHQgYXMgdGlja0Zvcm1hdFxufSBmcm9tIFwiLi90aWNrRm9ybWF0XCI7XG4iLCJpbXBvcnQgeyBzY2FsZU9yZGluYWwgfSBmcm9tICdkMy1zY2FsZSc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBvcmRpbmFsU2NhbGUoX3JlZikge1xuICB2YXIgcmFuZ2UgPSBfcmVmLnJhbmdlLFxuICAgICAgZG9tYWluID0gX3JlZi5kb21haW4sXG4gICAgICB1bmtub3duID0gX3JlZi51bmtub3duO1xuICB2YXIgc2NhbGUgPSBzY2FsZU9yZGluYWwoKTtcbiAgaWYgKHJhbmdlKSBzY2FsZS5yYW5nZShyYW5nZSk7XG4gIGlmIChkb21haW4pIHNjYWxlLmRvbWFpbihkb21haW4pO1xuICBpZiAodW5rbm93bikgc2NhbGUudW5rbm93bih1bmtub3duKTsgLy8gQHRzLWlnbm9yZVxuXG4gIHNjYWxlLnR5cGUgPSAnb3JkaW5hbCc7XG4gIHJldHVybiBzY2FsZTtcbn0iXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBOzs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcEJBO0FBQ0E7QUFDQTs7O0FDRkE7QUFDQTtBQUNBOzs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0pBO0FBQ0E7QUFDQTs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbERBO0FBQ0E7QUFDQTs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNuR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDSkE7QUFDQTtBQUNBOzs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZGQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUlBO0FBQ0E7QUFJQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFPQTtBQUNBO0FBR0E7QUFDQTtBQU9BO0FBQ0E7QUFHQTs7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2289\n')},2292:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// UNUSED EXPORTS: propTypes, defaultProps\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/prop-types/index.js\nvar prop_types = __webpack_require__(6);\nvar prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react/index.js\nvar react = __webpack_require__(0);\nvar react_default = /*#__PURE__*/__webpack_require__.n(react);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/theme/esm/chartTheme.js + 2 modules\nvar chartTheme = __webpack_require__(2309);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/group/dist/vx-group.es.js\nvar vx_group_es = __webpack_require__(1336);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/node_modules/@vx/shape/dist/vx-shape.es.js\nvar vx_shape_es = __webpack_require__(1394);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\nvar classCallCheck = __webpack_require__(1271);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@babel/runtime/helpers/esm/createClass.js\nvar createClass = __webpack_require__(1272);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\nvar possibleConstructorReturn = __webpack_require__(1280);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\nvar getPrototypeOf = __webpack_require__(1278);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@babel/runtime/helpers/esm/inherits.js + 1 modules\nvar inherits = __webpack_require__(1282);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\nvar assertThisInitialized = __webpack_require__(1283);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@babel/runtime/helpers/esm/defineProperty.js\nvar defineProperty = __webpack_require__(1275);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react-lifecycles-compat/react-lifecycles-compat.es.js\nvar react_lifecycles_compat_es = __webpack_require__(658);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-timer/src/timer.js\nvar timer = __webpack_require__(1371);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-timer/src/interval.js\n\n\n/* harmony default export */ var interval = (function(callback, delay, time) {\n  var t = new timer["a" /* Timer */], total = delay;\n  if (delay == null) return t.restart(callback, delay, time), t;\n  delay = +delay, time = time == null ? Object(timer["b" /* now */])() : +time;\n  t.restart(function tick(elapsed) {\n    elapsed += total;\n    t.restart(tick, total += delay, time);\n    callback(elapsed);\n  }, delay, time);\n  return t;\n});\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react-move/es/Node/Node.js\nfunction extend(obj, props) {\n  for (var i in props) {\n    obj[i] = props[i]; // eslint-disable-line no-param-reassign\n  }\n\n  return obj;\n}\n\nfunction Node(key, data, type) {\n  this.key = key;\n  this.data = data;\n  this.type = type;\n  this.state = {};\n}\n\nextend(Node.prototype, {\n  setState: function setState(state) {\n    var s = this.state;\n    extend(s, typeof state === \'function\' ? state(s) : state);\n  },\n  updateData: function updateData(data) {\n    this.data = data;\n    return this;\n  },\n  updateType: function updateType(type) {\n    this.type = type;\n    return this;\n  }\n});\n/* harmony default export */ var Node_Node = (Node);\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react-move/es/Node/index.js\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react-move/es/core/mergeKeys.js\n/* based on react-motion\'s mergeDiff (https://github.com/chenglou/react-motion) */\nfunction mergeKeys(currNodeKeys, currKeyIndex, nextNodeKeys, nextKeyIndex) {\n  var allKeys = [];\n\n  for (var i = 0; i < nextNodeKeys.length; i++) {\n    allKeys[i] = nextNodeKeys[i];\n  }\n\n  for (var _i = 0; _i < currNodeKeys.length; _i++) {\n    if (nextKeyIndex[currNodeKeys[_i]] === undefined) {\n      allKeys.push(currNodeKeys[_i]);\n    }\n  }\n\n  return allKeys.sort(function (a, b) {\n    var nextOrderA = nextKeyIndex[a];\n    var nextOrderB = nextKeyIndex[b];\n    var currOrderA = currKeyIndex[a];\n    var currOrderB = currKeyIndex[b];\n\n    if (nextOrderA != null && nextOrderB != null) {\n      return nextKeyIndex[a] - nextKeyIndex[b];\n    } else if (currOrderA != null && currOrderB != null) {\n      return currKeyIndex[a] - currKeyIndex[b];\n    } else if (nextOrderA != null) {\n      for (var _i2 = 0; _i2 < nextNodeKeys.length; _i2++) {\n        var pivot = nextNodeKeys[_i2];\n\n        if (!currKeyIndex[pivot]) {\n          continue;\n        }\n\n        if (nextOrderA < nextKeyIndex[pivot] && currOrderB > currKeyIndex[pivot]) {\n          return -1;\n        } else if (nextOrderA > nextKeyIndex[pivot] && currOrderB < currKeyIndex[pivot]) {\n          return 1;\n        }\n      }\n\n      return 1;\n    }\n\n    for (var _i3 = 0; _i3 < nextNodeKeys.length; _i3++) {\n      var _pivot = nextNodeKeys[_i3];\n\n      if (!currKeyIndex[_pivot]) {\n        continue;\n      }\n\n      if (nextOrderB < nextKeyIndex[_pivot] && currOrderA > currKeyIndex[_pivot]) {\n        return 1;\n      } else if (nextOrderB > nextKeyIndex[_pivot] && currOrderA < currKeyIndex[_pivot]) {\n        return -1;\n      }\n    }\n\n    return -1;\n  });\n}\n\n/* harmony default export */ var core_mergeKeys = (mergeKeys);\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react-move/es/core/types.js\nvar ENTER = \'ENTER\';\nvar UPDATE = \'UPDATE\';\nvar LEAVE = \'LEAVE\';\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@babel/runtime/helpers/esm/typeof.js\nvar esm_typeof = __webpack_require__(1338);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@babel/runtime/helpers/esm/objectSpread.js\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? Object(arguments[i]) : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === \'function\') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      Object(defineProperty["a" /* default */])(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-interpolate/src/transform/index.js + 2 modules\nvar transform = __webpack_require__(395);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-interpolate/src/value.js\nvar value = __webpack_require__(166);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react-move/es/core/transition/tween.js\n\n\n\nfunction getInterpolator(attr) {\n  if (attr === \'transform\') {\n    return transform["b" /* interpolateTransformSvg */];\n  }\n\n  return value["a" /* default */];\n}\n\nfunction getTween(nameSpace, attr, value1) {\n  return function tween() {\n    var _this = this;\n\n    var value0 = nameSpace ? this.state[nameSpace][attr] : this.state[attr];\n\n    if (value0 === value1) {\n      return null;\n    }\n\n    var i = getInterpolator(attr)(value0, value1);\n    var stateTween;\n\n    if (nameSpace === null) {\n      stateTween = function stateTween(t) {\n        _this.setState(function () {\n          return Object(defineProperty["a" /* default */])({}, attr, i(t));\n        });\n      };\n    } else {\n      stateTween = function stateTween(t) {\n        _this.setState(function (state) {\n          return Object(defineProperty["a" /* default */])({}, nameSpace, _objectSpread({}, state[nameSpace], Object(defineProperty["a" /* default */])({}, attr, i(t))));\n        });\n      };\n    }\n\n    return stateTween;\n  };\n}\n\n/* harmony default export */ var transition_tween = (function (nameSpace, attr, value) {\n  return getTween.call(this, nameSpace, attr, value);\n});\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/d3-timer/src/timeout.js\nvar timeout = __webpack_require__(1732);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react-move/es/core/transition/schedule.js\n\n// Apapted from https://github.com/d3/d3-transition/blob/master/src/transition/schedule.js\n\nvar CREATED = 0;\nvar SCHEDULED = 1;\nvar STARTING = 2;\nvar STARTED = 3;\nvar RUNNING = 4;\nvar ENDING = 5;\nvar ENDED = 6;\n/* harmony default export */ var transition_schedule = (function (node, stateKey, id, timing, tweens) {\n  var events = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n  var schedules = node.TRANSITION_SCHEDULES;\n\n  if (!schedules) {\n    node.TRANSITION_SCHEDULES = {}; // eslint-disable-line no-param-reassign\n  } else if (id in schedules) {\n    return;\n  }\n\n  var config = _objectSpread({\n    stateKey: stateKey,\n    events: events,\n    tweens: tweens\n  }, timing, {\n    timer: null,\n    state: CREATED\n  });\n\n  create(node, id, config);\n});\n\nfunction create(node, id, config) {\n  var schedules = node.TRANSITION_SCHEDULES; // Initialize the transition timer when the transition is created.\n  // Note the actual delay is not known until the first callback!\n\n  var transition = _objectSpread({}, config);\n\n  var n = transition.tweens.length;\n  var tweens = new Array(n);\n  schedules[id] = transition;\n  transition.timer = Object(timer["c" /* timer */])(schedule, 0, transition.time);\n\n  function schedule(elapsed) {\n    transition.state = SCHEDULED;\n    transition.timer.restart(start, transition.delay, transition.time); // If the elapsed delay is less than our first sleep, start immediately.\n\n    if (transition.delay <= elapsed) {\n      start(elapsed - transition.delay);\n    }\n  }\n\n  function start(elapsed) {\n    // eslint-disable-line consistent-return\n    // If the state is not SCHEDULED, then we previously errored on start.\n    if (transition.state !== SCHEDULED) return stop();\n\n    for (var sid in schedules) {\n      // eslint-disable-line\n      var s = schedules[sid];\n\n      if (s.stateKey !== transition.stateKey) {\n        continue; // eslint-disable-line no-continue\n      } // While this element already has a starting transition during this frame,\n      // defer starting an interrupting transition until that transition has a\n      // chance to tick (and possibly end); see d3/d3-transition#54!\n\n\n      if (s.state === STARTED) return Object(timeout["a" /* default */])(start); // 1. Interrupt the active transition, if any. dispatch the interrupt event.\n      // 2. Cancel any pre-empted transitions. No interrupt event is dispatched\n      // because the cancelled transitions never started. Note that this also\n      // removes this transition from the pending list!\n\n      if (s.state === RUNNING) {\n        s.state = ENDED;\n        s.timer.stop();\n\n        if (s.events.interrupt && typeof s.events.interrupt === \'function\') {\n          s.events.interrupt.call(this);\n        }\n\n        delete schedules[sid];\n      } else if (+sid < id) {\n        s.state = ENDED;\n        s.timer.stop();\n        delete schedules[sid];\n      }\n    } // Defer the first tick to end of the current frame; see d3/d3#1576.\n    // Note the transition may be canceled after start and before the first tick!\n    // Note this must be scheduled before the start event; see d3/d3-transition#16!\n    // Assuming this is successful, subsequent callbacks go straight to tick.\n\n\n    Object(timeout["a" /* default */])(function () {\n      if (transition.state === STARTED) {\n        transition.state = RUNNING;\n        transition.timer.restart(tick, transition.delay, transition.time);\n        tick(elapsed);\n      }\n    });\n    transition.state = STARTING;\n\n    if (transition.events.start && typeof transition.events.start === \'function\') {\n      transition.events.start.call(node);\n    }\n\n    if (transition.state !== STARTING) {\n      // interrupted\n      return; // eslint-disable-line consistent-return\n    }\n\n    transition.state = STARTED; // Initialize the tween, deleting null tween.\n\n    var j = -1;\n\n    for (var i = 0; i < n; ++i) {\n      var res = transition.tweens[i].call(node);\n\n      if (res) {\n        tweens[++j] = res;\n      }\n    }\n\n    tweens.length = j + 1;\n  }\n\n  function tick(elapsed) {\n    var t = 1;\n\n    if (elapsed < transition.duration) {\n      t = transition.ease.call(null, elapsed / transition.duration);\n    } else {\n      transition.timer.restart(stop);\n      transition.state = ENDING;\n    }\n\n    var i = -1;\n\n    while (++i < tweens.length) {\n      tweens[i].call(null, t);\n    }\n\n    if (transition.state === ENDING) {\n      if (transition.events.end && typeof transition.events.end === \'function\') {\n        transition.events.end.call(node);\n      }\n\n      stop();\n    }\n  }\n\n  function stop() {\n    transition.state = ENDED;\n    transition.timer.stop();\n    delete schedules[id];\n\n    for (var i in schedules) {\n      return;\n    } // eslint-disable-line guard-for-in, no-restricted-syntax\n\n\n    delete node.TRANSITION_SCHEDULES; // eslint-disable-line no-param-reassign\n  }\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react-move/es/core/transition/transition.js\n\n\n\n\n\n\n\nfunction once(func) {\n  var called = false;\n  return function transitionEvent() {\n    if (!called) {\n      called = true;\n      func.call(this);\n    }\n  };\n}\n\nvar transition_id = 0;\nfunction newId() {\n  return ++transition_id;\n} // from https://github.com/d3/d3-ease/blob/master/src/linear.js\n\nfunction linear(t) {\n  return +t;\n}\n\nvar preset = {\n  time: null,\n  delay: 0,\n  duration: 250,\n  ease: linear\n};\n\nfunction scheduleTransitions() {\n  var _this = this;\n\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var transitions = _objectSpread({}, config);\n\n  var events = transitions.events || {};\n  delete transitions.events; // each event handler should be called only once\n\n  Object.keys(events).forEach(function (d) {\n    if (typeof events[d] !== \'function\') {\n      throw new Error(\'Event handlers must be a function\');\n    } else {\n      events[d] = once(events[d]);\n    }\n  });\n  var timing = transitions.timing || {};\n  delete transitions.timing;\n  Object.keys(transitions).forEach(function (stateKey) {\n    var tweens = [];\n\n    if (Object(esm_typeof["a" /* default */])(transitions[stateKey]) === \'object\' && Array.isArray(transitions[stateKey]) === false) {\n      Object.keys(transitions[stateKey]).forEach(function (attr) {\n        var val = transitions[stateKey][attr];\n\n        if (Array.isArray(val)) {\n          if (val.length === 1) {\n            tweens.push(transition_tween.call(_this, stateKey, attr, val[0]));\n          } else {\n            _this.setState(function (state) {\n              return Object(defineProperty["a" /* default */])({}, stateKey, _objectSpread({}, state[stateKey], Object(defineProperty["a" /* default */])({}, attr, val[0])));\n            });\n\n            tweens.push(transition_tween.call(_this, stateKey, attr, val[1]));\n          }\n        } else if (typeof val === \'function\') {\n          var getResonanceCustomTween = function getResonanceCustomTween() {\n            var resonanceCustomTween = function resonanceCustomTween(t) {\n              _this.setState(function (state) {\n                return Object(defineProperty["a" /* default */])({}, stateKey, _objectSpread({}, state[stateKey], Object(defineProperty["a" /* default */])({}, attr, val(t))));\n              });\n            };\n\n            return resonanceCustomTween;\n          };\n\n          tweens.push(getResonanceCustomTween);\n        } else {\n          _this.setState(function (state) {\n            return Object(defineProperty["a" /* default */])({}, stateKey, _objectSpread({}, state[stateKey], Object(defineProperty["a" /* default */])({}, attr, val)));\n          }); // This assures any existing transitions are stopped\n\n\n          tweens.push(transition_tween.call(_this, stateKey, attr, val));\n        }\n      });\n    } else {\n      var val = transitions[stateKey];\n\n      if (Array.isArray(val)) {\n        if (val.length === 1) {\n          tweens.push(transition_tween.call(_this, null, stateKey, val[0]));\n        } else {\n          _this.setState(function () {\n            return Object(defineProperty["a" /* default */])({}, stateKey, val[0]);\n          });\n\n          tweens.push(transition_tween.call(_this, null, stateKey, val[1]));\n        }\n      } else if (typeof val === \'function\') {\n        var getResonanceCustomTween = function getResonanceCustomTween() {\n          var resonanceCustomTween = function resonanceCustomTween(t) {\n            _this.setState(function () {\n              return Object(defineProperty["a" /* default */])({}, stateKey, val(t));\n            });\n          };\n\n          return resonanceCustomTween;\n        };\n\n        tweens.push(getResonanceCustomTween);\n      } else {\n        _this.setState(function () {\n          return Object(defineProperty["a" /* default */])({}, stateKey, val);\n        }); // This assures any existing transitions are stopped\n\n\n        tweens.push(transition_tween.call(_this, null, stateKey, val));\n      }\n    }\n\n    var timingConfig = _objectSpread({}, preset, timing, {\n      time: Object(timer["b" /* now */])()\n    });\n\n    transition_schedule(_this, stateKey, newId(), timingConfig, tweens, events);\n  });\n}\n\nfunction transition_transition(config) {\n  var _this2 = this;\n\n  if (Array.isArray(config)) {\n    config.forEach(function (c) {\n      scheduleTransitions.call(_this2, c);\n    });\n  } else {\n    scheduleTransitions.call(this, config);\n  }\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react-move/es/core/transition/stop.js\nfunction stop_stop() {\n  var ts = this.TRANSITION_SCHEDULES;\n\n  if (ts) {\n    Object.keys(ts).forEach(function (s) {\n      ts[s].timer.stop();\n    });\n  }\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react-move/es/core/transition/index.js\n\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react-move/es/NodeGroup/NodeGroup.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar NodeGroup_NodeGroup =\n/*#__PURE__*/\nfunction (_Component) {\n  Object(inherits["a" /* default */])(NodeGroup, _Component);\n\n  function NodeGroup() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    Object(classCallCheck["a" /* default */])(this, NodeGroup);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = Object(possibleConstructorReturn["a" /* default */])(this, (_getPrototypeOf2 = Object(getPrototypeOf["a" /* default */])(NodeGroup)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n    Object(defineProperty["a" /* default */])(Object(assertThisInitialized["a" /* default */])(Object(assertThisInitialized["a" /* default */])(_this)), "state", {\n      nodeKeys: [],\n      nodeHash: {},\n      nodes: [],\n      data: null\n    });\n\n    Object(defineProperty["a" /* default */])(Object(assertThisInitialized["a" /* default */])(Object(assertThisInitialized["a" /* default */])(_this)), "animate", function () {\n      var _this$state = _this.state,\n          nodeKeys = _this$state.nodeKeys,\n          nodeHash = _this$state.nodeHash;\n\n      if (_this.unmounting) {\n        return;\n      }\n\n      var pending = false;\n      var nextNodeKeys = [];\n      var length = nodeKeys.length;\n\n      for (var i = 0; i < length; i++) {\n        var k = nodeKeys[i];\n        var n = nodeHash[k];\n\n        if (n.TRANSITION_SCHEDULES) {\n          pending = true;\n        }\n\n        if (n.type === LEAVE && !n.TRANSITION_SCHEDULES) {\n          delete nodeHash[k];\n        } else {\n          nextNodeKeys.push(k);\n        }\n      }\n\n      if (!pending) {\n        _this.interval.stop();\n      }\n\n      _this.setState(function () {\n        return {\n          nodeKeys: nextNodeKeys,\n          nodes: nextNodeKeys.map(function (key) {\n            return nodeHash[key];\n          })\n        };\n      });\n    });\n\n    Object(defineProperty["a" /* default */])(Object(assertThisInitialized["a" /* default */])(Object(assertThisInitialized["a" /* default */])(_this)), "interval", null);\n\n    Object(defineProperty["a" /* default */])(Object(assertThisInitialized["a" /* default */])(Object(assertThisInitialized["a" /* default */])(_this)), "unmounting", false);\n\n    return _this;\n  }\n\n  Object(createClass["a" /* default */])(NodeGroup, [{\n    key: "componentDidMount",\n    value: function componentDidMount() {\n      this.startInterval();\n    }\n  }, {\n    key: "componentDidUpdate",\n    value: function componentDidUpdate(prevProps) {\n      if (prevProps.data !== this.props.data && !this.unmounting) {\n        this.startInterval();\n      }\n    }\n  }, {\n    key: "startInterval",\n    value: function startInterval() {\n      if (!this.interval) {\n        this.interval = interval(this.animate);\n      } else {\n        this.interval.restart(this.animate);\n      }\n    }\n  }, {\n    key: "componentWillUnmount",\n    value: function componentWillUnmount() {\n      var _this$state2 = this.state,\n          nodeKeys = _this$state2.nodeKeys,\n          nodeHash = _this$state2.nodeHash;\n      this.unmounting = true;\n\n      if (this.interval) {\n        this.interval.stop();\n      }\n\n      nodeKeys.forEach(function (key) {\n        stop_stop.call(nodeHash[key]);\n      });\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      var renderedChildren = this.props.children(this.state.nodes);\n      return renderedChildren && react_default.a.Children.only(renderedChildren);\n    }\n  }], [{\n    key: "getDerivedStateFromProps",\n    value: function getDerivedStateFromProps(nextProps, prevState) {\n      if (nextProps.data !== prevState.data) {\n        var data = nextProps.data,\n            keyAccessor = nextProps.keyAccessor,\n            start = nextProps.start,\n            enter = nextProps.enter,\n            update = nextProps.update,\n            leave = nextProps.leave;\n        var nodeKeys = prevState.nodeKeys,\n            nodeHash = prevState.nodeHash;\n        var keyIndex = {};\n\n        for (var i = 0; i < nodeKeys.length; i++) {\n          keyIndex[nodeKeys[i]] = i;\n        }\n\n        var nextKeyIndex = {};\n        var nextNodeKeys = [];\n\n        for (var _i = 0; _i < data.length; _i++) {\n          var d = data[_i];\n          var k = keyAccessor(d, _i);\n          nextKeyIndex[k] = _i;\n          nextNodeKeys.push(k);\n\n          if (keyIndex[k] === undefined) {\n            nodeHash[k] = new Node_Node(k, d, ENTER);\n          }\n        }\n\n        for (var _i2 = 0; _i2 < nodeKeys.length; _i2++) {\n          var _k = nodeKeys[_i2];\n          var n = nodeHash[_k];\n\n          if (nextKeyIndex[_k] !== undefined) {\n            n.updateData(data[nextKeyIndex[_k]]);\n            n.updateType(UPDATE);\n          } else {\n            n.updateType(LEAVE);\n          }\n        }\n\n        var mergedNodeKeys = core_mergeKeys(nodeKeys, keyIndex, nextNodeKeys, nextKeyIndex);\n\n        for (var _i3 = 0; _i3 < mergedNodeKeys.length; _i3++) {\n          var _k2 = mergedNodeKeys[_i3];\n          var _n = nodeHash[_k2];\n          var _d = _n.data;\n\n          if (_n.type === ENTER) {\n            _n.setState(start(_d, nextKeyIndex[_k2]));\n\n            transition_transition.call(_n, enter(_d, nextKeyIndex[_k2]));\n          } else if (_n.type === LEAVE) {\n            transition_transition.call(_n, leave(_d, keyIndex[_k2]));\n          } else {\n            transition_transition.call(_n, update(_d, nextKeyIndex[_k2]));\n          }\n        }\n\n        return {\n          data: data,\n          nodes: mergedNodeKeys.map(function (key) {\n            return nodeHash[key];\n          }),\n          nodeHash: nodeHash,\n          nodeKeys: mergedNodeKeys\n        };\n      }\n\n      return null;\n    }\n  }]);\n\n  return NodeGroup;\n}(react["Component"]);\n\nNodeGroup_NodeGroup.propTypes =  false ? undefined : {};\nNodeGroup_NodeGroup.defaultProps = {\n  enter: function enter() {},\n  update: function update() {},\n  leave: function leave() {}\n};\nObject(react_lifecycles_compat_es["polyfill"])(NodeGroup_NodeGroup);\n/* harmony default export */ var es_NodeGroup_NodeGroup = (NodeGroup_NodeGroup);\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react-move/es/NodeGroup/index.js\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react-move/es/Animate/Animate.js\n\n\n\n\nvar Animate_keyAccessor = function keyAccessor() {\n  return \'$$key$$\';\n};\n\nfunction Animate(props) {\n  var show = props.show,\n      start = props.start,\n      enter = props.enter,\n      update = props.update,\n      leave = props.leave,\n      children = props.children;\n  var data = typeof start === \'function\' ? start() : start;\n  return react_default.a.createElement(es_NodeGroup_NodeGroup, {\n    data: show ? [data] : [],\n    start: function start() {\n      return data;\n    },\n    keyAccessor: Animate_keyAccessor,\n    enter: typeof enter === \'function\' ? enter : function () {\n      return enter;\n    },\n    update: typeof update === \'function\' ? update : function () {\n      return update;\n    },\n    leave: typeof leave === \'function\' ? leave : function () {\n      return leave;\n    }\n  }, function (nodes) {\n    if (!nodes[0]) {\n      return null;\n    }\n\n    var renderedChildren = children(nodes[0].state);\n    return renderedChildren && react_default.a.Children.only(renderedChildren);\n  });\n}\n\nAnimate.propTypes =  false ? undefined : {};\nAnimate.defaultProps = {\n  show: true\n};\n/* harmony default export */ var Animate_Animate = (Animate);\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react-move/es/Animate/index.js\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react-move/es/index.js\n\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/esm/utils/callOrValue.js\nfunction callOrValue(maybeFn) {\n  if (typeof maybeFn === \'function\') {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    return maybeFn.apply(void 0, args);\n  }\n\n  return maybeFn;\n}\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/esm/utils/propShapes.js\nvar propShapes = __webpack_require__(1352);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/esm/series/animated/AnimatedBarSeries.js\n\n\n\n\n\n\n\n\nvar propTypes = {\n  rawData: prop_types_default.a.arrayOf(prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string])),\n  // eslint-disable-line react/no-unused-prop-types\n  binnedData: propShapes["b" /* binnedDataShape */],\n  fill: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.string]),\n  fillOpacity: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  horizontal: prop_types_default.a.bool,\n  stroke: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.string]),\n  strokeWidth: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  valueKey: prop_types_default.a.string,\n  onClick: prop_types_default.a.func,\n  // likely injected by parent Histogram\n  binScale: prop_types_default.a.func,\n  valueScale: prop_types_default.a.func,\n  onMouseMove: prop_types_default.a.func,\n  onMouseLeave: prop_types_default.a.func,\n  keyAccessor: prop_types_default.a.func\n};\nvar defaultProps = {\n  rawData: [],\n  binnedData: [],\n  binScale: null,\n  fill: chartTheme["a" /* default */].colors.default,\n  fillOpacity: 0.7,\n  horizontal: false,\n  onClick: null,\n  onMouseMove: null,\n  onMouseLeave: null,\n  stroke: \'#FFFFFF\',\n  strokeWidth: 1,\n  valueKey: \'count\',\n  valueScale: null,\n  keyAccessor: function keyAccessor(d) {\n    return d.id;\n  }\n};\nvar INDEX_DELAY_MULTIPLIER = 10;\n\nvar getBin = function getBin(d) {\n  return typeof d.bin === \'undefined\' ? d.bin0 : d.bin;\n};\n\nvar getBin1 = function getBin1(d) {\n  return typeof d.bin === \'undefined\' ? d.bin1 : d.bin;\n};\n\nfunction AnimatedBarSeries(_ref) {\n  var binnedData = _ref.binnedData,\n      valueScale = _ref.valueScale,\n      binScale = _ref.binScale,\n      horizontal = _ref.horizontal,\n      keyAccessor = _ref.keyAccessor,\n      fill = _ref.fill,\n      fillOpacity = _ref.fillOpacity,\n      onClick = _ref.onClick,\n      onMouseMove = _ref.onMouseMove,\n      onMouseLeave = _ref.onMouseLeave,\n      stroke = _ref.stroke,\n      strokeWidth = _ref.strokeWidth,\n      valueKey = _ref.valueKey;\n  var maxBarLength = Math.max.apply(Math, valueScale.range()); // compute once and use throughout\n\n  var barWidths = binnedData.map(function (_, i) {\n    return binScale.bandwidth ? binScale.bandwidth() // categorical\n    : Math.abs(binScale(binnedData[i].bin1) - binScale(binnedData[i].bin0));\n  } // numeric\n  );\n\n  var getValue = function getValue(d) {\n    return d[valueKey];\n  };\n\n  var getX = horizontal ? getValue : getBin;\n  var getY = horizontal ? getBin1 : getValue;\n  var xScale = horizontal ? valueScale : binScale;\n  var yScale = horizontal ? binScale : valueScale;\n  return react_default.a.createElement(es_NodeGroup_NodeGroup, {\n    data: binnedData,\n    keyAccessor: keyAccessor,\n    start: function start(d, i) {\n      return {\n        x: horizontal ? 0 : xScale(getX(d)),\n        y: horizontal ? yScale(getY(d)) : maxBarLength,\n        fill: d.fill || callOrValue(fill, d, i),\n        width: horizontal ? 0 : barWidths[i],\n        height: horizontal ? barWidths[i] : 0\n      };\n    },\n    enter: function enter(d, i) {\n      return {\n        x: [horizontal ? 0 : xScale(getX(d))],\n        y: [yScale(getY(d))],\n        width: [horizontal ? xScale(getX(d)) : barWidths[i]],\n        height: [horizontal ? barWidths[i] : maxBarLength - yScale(getY(d))],\n        fill: [d.fill || callOrValue(fill, d, i)],\n        stroke: [d.stroke || callOrValue(stroke, d, i)],\n        timing: {\n          duration: 300,\n          delay: INDEX_DELAY_MULTIPLIER * i\n        }\n      };\n    },\n    update: function update(d, i) {\n      return {\n        x: [horizontal ? 0 : xScale(getX(d))],\n        y: [yScale(getY(d))],\n        width: [horizontal ? xScale(getX(d)) : barWidths[i]],\n        height: [horizontal ? barWidths[i] : maxBarLength - yScale(getY(d))],\n        fill: [d.fill || callOrValue(fill, d, i)],\n        stroke: [d.stroke || callOrValue(stroke, d, i)],\n        timing: {\n          duration: 300,\n          delay: INDEX_DELAY_MULTIPLIER * i\n        }\n      };\n    },\n    leave: function leave(d, i) {\n      return {\n        x: horizontal ? 0 : xScale(getX(d)),\n        y: horizontal ? yScale(getY(d)) : maxBarLength,\n        width: horizontal ? 0 : barWidths[i],\n        height: horizontal ? barWidths[i] : 0,\n        timing: {\n          duration: 300,\n          delay: INDEX_DELAY_MULTIPLIER / 2 * i\n        }\n      };\n    }\n  }, function (data) {\n    return react_default.a.createElement(vx_group_es["a" /* Group */], null, data.map(function (modifiedDatum, i) {\n      var key = modifiedDatum.key,\n          rawDatum = modifiedDatum.data,\n          d = modifiedDatum.state;\n      return react_default.a.createElement(vx_shape_es["a" /* Bar */], {\n        key: "bar" + key,\n        x: d.x,\n        y: d.y,\n        width: d.width,\n        height: d.height,\n        fill: d.fill,\n        stroke: d.stroke,\n        fillOpacity: typeof fillOpacity === \'undefined\' ? callOrValue(fillOpacity, rawDatum, i) : fillOpacity,\n        strokeWidth: rawDatum.strokeWidth || callOrValue(strokeWidth, rawDatum, i),\n        onClick: onClick && function () {\n          return function (event) {\n            onClick({\n              event: event,\n              datum: rawDatum,\n              data: binnedData,\n              color: d.fill,\n              index: i\n            });\n          };\n        },\n        onMouseMove: onMouseMove && function () {\n          return function (event) {\n            onMouseMove({\n              event: event,\n              datum: rawDatum,\n              data: binnedData,\n              color: d.fill,\n              index: i\n            });\n          };\n        },\n        onMouseLeave: onMouseLeave && function () {\n          return onMouseLeave;\n        }\n      });\n    }));\n  });\n}\n\nAnimatedBarSeries.propTypes = propTypes;\nAnimatedBarSeries.defaultProps = defaultProps;\n/* harmony default export */ var animated_AnimatedBarSeries = (AnimatedBarSeries);\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@data-ui/histogram/esm/series/BarSeries.js\n\n\n\n\n\n\n\n\nvar BarSeries_propTypes = {\n  animated: prop_types_default.a.bool,\n  rawData: prop_types_default.a.arrayOf(prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string])),\n  // eslint-disable-line react/no-unused-prop-types\n  binnedData: propShapes["b" /* binnedDataShape */],\n  fill: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.string]),\n  fillOpacity: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  horizontal: prop_types_default.a.bool,\n  stroke: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.string]),\n  strokeWidth: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.number]),\n  valueKey: prop_types_default.a.string,\n  onClick: prop_types_default.a.func,\n  // likely injected by parent Histogram\n  binScale: prop_types_default.a.func,\n  valueScale: prop_types_default.a.func,\n  onMouseMove: prop_types_default.a.func,\n  onMouseLeave: prop_types_default.a.func\n};\nvar BarSeries_defaultProps = {\n  animated: true,\n  rawData: [],\n  binnedData: [],\n  binScale: null,\n  fill: chartTheme["a" /* default */].colors.default,\n  fillOpacity: 0.7,\n  horizontal: false,\n  onClick: null,\n  onMouseMove: null,\n  onMouseLeave: null,\n  stroke: \'#FFFFFF\',\n  strokeWidth: 1,\n  valueKey: \'count\',\n  valueScale: null\n};\n\nfunction BarSeries(_ref) {\n  var animated = _ref.animated,\n      binnedData = _ref.binnedData,\n      binScale = _ref.binScale,\n      fill = _ref.fill,\n      fillOpacity = _ref.fillOpacity,\n      horizontal = _ref.horizontal,\n      onClick = _ref.onClick,\n      onMouseMove = _ref.onMouseMove,\n      onMouseLeave = _ref.onMouseLeave,\n      stroke = _ref.stroke,\n      strokeWidth = _ref.strokeWidth,\n      valueKey = _ref.valueKey,\n      valueScale = _ref.valueScale;\n  if (!binScale || !valueScale || !binnedData || binnedData.length === 0) return null;\n  var maxBarLength = Math.max.apply(Math, valueScale.range());\n  return react_default.a.createElement(vx_group_es["a" /* Group */], null, animated && react_default.a.createElement(animated_AnimatedBarSeries, {\n    binnedData: binnedData,\n    binScale: binScale,\n    horizontal: horizontal,\n    fill: fill,\n    fillOpacity: fillOpacity,\n    onClick: onClick,\n    onMouseMove: onMouseMove,\n    onMouseLeave: onMouseLeave,\n    stroke: stroke,\n    strokeWidth: strokeWidth,\n    valueKey: valueKey,\n    valueScale: valueScale\n  }), !animated && binnedData.map(function (d, i) {\n    var binPosition = binScale(d.bin || (horizontal ? d.bin1 : d.bin0));\n    var barLength = horizontal ? valueScale(d[valueKey]) : maxBarLength - valueScale(d[valueKey]);\n    var barWidth = binScale.bandwidth ? binScale.bandwidth() // categorical\n    : Math.abs(binScale(binnedData[i].bin1) - binScale(binnedData[i].bin0)); // numeric\n\n    var color = d.fill || callOrValue(fill, d, i);\n    return react_default.a.createElement(vx_shape_es["a" /* Bar */], {\n      key: "bar-" + binPosition,\n      x: horizontal ? 0 : binPosition,\n      y: horizontal ? binPosition : maxBarLength - barLength,\n      width: horizontal ? barLength : barWidth,\n      height: horizontal ? barWidth : barLength,\n      fill: color,\n      fillOpacity: typeof fillOpacity === \'undefined\' ? callOrValue(fillOpacity, d, i) : fillOpacity,\n      stroke: d.stroke || callOrValue(stroke, d, i),\n      strokeWidth: d.strokeWidth || callOrValue(strokeWidth, d, i),\n      onClick: onClick && function () {\n        return function (event) {\n          onClick({\n            event: event,\n            data: binnedData,\n            datum: d,\n            color: color,\n            index: i\n          });\n        };\n      },\n      onMouseMove: onMouseMove && function () {\n        return function (event) {\n          onMouseMove({\n            event: event,\n            data: binnedData,\n            datum: d,\n            color: color,\n            index: i\n          });\n        };\n      },\n      onMouseLeave: onMouseLeave && function () {\n        return onMouseLeave;\n      }\n    });\n  }));\n}\n\nBarSeries.propTypes = BarSeries_propTypes;\nBarSeries.defaultProps = BarSeries_defaultProps;\nBarSeries.displayName = \'BarSeries\';\n/* harmony default export */ var series_BarSeries = __webpack_exports__["a"] = (BarSeries);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjI5Mi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL2QzLXRpbWVyL3NyYy9pbnRlcnZhbC5qcz8zYWUxIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL3JlYWN0LW1vdmUvZXMvTm9kZS9Ob2RlLmpzP2JmMjkiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvcmVhY3QtbW92ZS9lcy9jb3JlL21lcmdlS2V5cy5qcz85MjE1Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL3JlYWN0LW1vdmUvZXMvY29yZS90eXBlcy5qcz8xNzIyIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFNwcmVhZC5qcz81NzIzIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL3JlYWN0LW1vdmUvZXMvY29yZS90cmFuc2l0aW9uL3R3ZWVuLmpzP2Y1NzMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvcmVhY3QtbW92ZS9lcy9jb3JlL3RyYW5zaXRpb24vc2NoZWR1bGUuanM/NDE2YSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9yZWFjdC1tb3ZlL2VzL2NvcmUvdHJhbnNpdGlvbi90cmFuc2l0aW9uLmpzPzBhNDEiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvcmVhY3QtbW92ZS9lcy9jb3JlL3RyYW5zaXRpb24vc3RvcC5qcz8zNTVhIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL3JlYWN0LW1vdmUvZXMvY29yZS90cmFuc2l0aW9uL2luZGV4LmpzP2NhMjgiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvcmVhY3QtbW92ZS9lcy9Ob2RlR3JvdXAvTm9kZUdyb3VwLmpzPzBjYjAiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvcmVhY3QtbW92ZS9lcy9BbmltYXRlL0FuaW1hdGUuanM/YTliMiIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9yZWFjdC1tb3ZlL2VzL2luZGV4LmpzP2EwYWYiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkvaGlzdG9ncmFtL2VzbS91dGlscy9jYWxsT3JWYWx1ZS5qcz82Yjg0Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0BkYXRhLXVpL2hpc3RvZ3JhbS9lc20vc2VyaWVzL2FuaW1hdGVkL0FuaW1hdGVkQmFyU2VyaWVzLmpzPzM3NDgiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQGRhdGEtdWkvaGlzdG9ncmFtL2VzbS9zZXJpZXMvQmFyU2VyaWVzLmpzPzk1NGIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtUaW1lciwgbm93fSBmcm9tIFwiLi90aW1lci5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjYWxsYmFjaywgZGVsYXksIHRpbWUpIHtcbiAgdmFyIHQgPSBuZXcgVGltZXIsIHRvdGFsID0gZGVsYXk7XG4gIGlmIChkZWxheSA9PSBudWxsKSByZXR1cm4gdC5yZXN0YXJ0KGNhbGxiYWNrLCBkZWxheSwgdGltZSksIHQ7XG4gIGRlbGF5ID0gK2RlbGF5LCB0aW1lID0gdGltZSA9PSBudWxsID8gbm93KCkgOiArdGltZTtcbiAgdC5yZXN0YXJ0KGZ1bmN0aW9uIHRpY2soZWxhcHNlZCkge1xuICAgIGVsYXBzZWQgKz0gdG90YWw7XG4gICAgdC5yZXN0YXJ0KHRpY2ssIHRvdGFsICs9IGRlbGF5LCB0aW1lKTtcbiAgICBjYWxsYmFjayhlbGFwc2VkKTtcbiAgfSwgZGVsYXksIHRpbWUpO1xuICByZXR1cm4gdDtcbn1cbiIsImZ1bmN0aW9uIGV4dGVuZChvYmosIHByb3BzKSB7XG4gIGZvciAodmFyIGkgaW4gcHJvcHMpIHtcbiAgICBvYmpbaV0gPSBwcm9wc1tpXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gTm9kZShrZXksIGRhdGEsIHR5cGUpIHtcbiAgdGhpcy5rZXkgPSBrZXk7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIHRoaXMuc3RhdGUgPSB7fTtcbn1cblxuZXh0ZW5kKE5vZGUucHJvdG90eXBlLCB7XG4gIHNldFN0YXRlOiBmdW5jdGlvbiBzZXRTdGF0ZShzdGF0ZSkge1xuICAgIHZhciBzID0gdGhpcy5zdGF0ZTtcbiAgICBleHRlbmQocywgdHlwZW9mIHN0YXRlID09PSAnZnVuY3Rpb24nID8gc3RhdGUocykgOiBzdGF0ZSk7XG4gIH0sXG4gIHVwZGF0ZURhdGE6IGZ1bmN0aW9uIHVwZGF0ZURhdGEoZGF0YSkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHVwZGF0ZVR5cGU6IGZ1bmN0aW9uIHVwZGF0ZVR5cGUodHlwZSkge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn0pO1xuZXhwb3J0IGRlZmF1bHQgTm9kZTsiLCIvKiBiYXNlZCBvbiByZWFjdC1tb3Rpb24ncyBtZXJnZURpZmYgKGh0dHBzOi8vZ2l0aHViLmNvbS9jaGVuZ2xvdS9yZWFjdC1tb3Rpb24pICovXG5mdW5jdGlvbiBtZXJnZUtleXMoY3Vyck5vZGVLZXlzLCBjdXJyS2V5SW5kZXgsIG5leHROb2RlS2V5cywgbmV4dEtleUluZGV4KSB7XG4gIHZhciBhbGxLZXlzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXh0Tm9kZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBhbGxLZXlzW2ldID0gbmV4dE5vZGVLZXlzW2ldO1xuICB9XG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGN1cnJOb2RlS2V5cy5sZW5ndGg7IF9pKyspIHtcbiAgICBpZiAobmV4dEtleUluZGV4W2N1cnJOb2RlS2V5c1tfaV1dID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGFsbEtleXMucHVzaChjdXJyTm9kZUtleXNbX2ldKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYWxsS2V5cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIG5leHRPcmRlckEgPSBuZXh0S2V5SW5kZXhbYV07XG4gICAgdmFyIG5leHRPcmRlckIgPSBuZXh0S2V5SW5kZXhbYl07XG4gICAgdmFyIGN1cnJPcmRlckEgPSBjdXJyS2V5SW5kZXhbYV07XG4gICAgdmFyIGN1cnJPcmRlckIgPSBjdXJyS2V5SW5kZXhbYl07XG5cbiAgICBpZiAobmV4dE9yZGVyQSAhPSBudWxsICYmIG5leHRPcmRlckIgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5leHRLZXlJbmRleFthXSAtIG5leHRLZXlJbmRleFtiXTtcbiAgICB9IGVsc2UgaWYgKGN1cnJPcmRlckEgIT0gbnVsbCAmJiBjdXJyT3JkZXJCICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBjdXJyS2V5SW5kZXhbYV0gLSBjdXJyS2V5SW5kZXhbYl07XG4gICAgfSBlbHNlIGlmIChuZXh0T3JkZXJBICE9IG51bGwpIHtcbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG5leHROb2RlS2V5cy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgIHZhciBwaXZvdCA9IG5leHROb2RlS2V5c1tfaTJdO1xuXG4gICAgICAgIGlmICghY3VycktleUluZGV4W3Bpdm90XSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHRPcmRlckEgPCBuZXh0S2V5SW5kZXhbcGl2b3RdICYmIGN1cnJPcmRlckIgPiBjdXJyS2V5SW5kZXhbcGl2b3RdKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9IGVsc2UgaWYgKG5leHRPcmRlckEgPiBuZXh0S2V5SW5kZXhbcGl2b3RdICYmIGN1cnJPcmRlckIgPCBjdXJyS2V5SW5kZXhbcGl2b3RdKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgbmV4dE5vZGVLZXlzLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgIHZhciBfcGl2b3QgPSBuZXh0Tm9kZUtleXNbX2kzXTtcblxuICAgICAgaWYgKCFjdXJyS2V5SW5kZXhbX3Bpdm90XSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5leHRPcmRlckIgPCBuZXh0S2V5SW5kZXhbX3Bpdm90XSAmJiBjdXJyT3JkZXJBID4gY3VycktleUluZGV4W19waXZvdF0pIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9IGVsc2UgaWYgKG5leHRPcmRlckIgPiBuZXh0S2V5SW5kZXhbX3Bpdm90XSAmJiBjdXJyT3JkZXJBIDwgY3VycktleUluZGV4W19waXZvdF0pIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1lcmdlS2V5czsiLCJleHBvcnQgdmFyIEVOVEVSID0gJ0VOVEVSJztcbmV4cG9ydCB2YXIgVVBEQVRFID0gJ1VQREFURSc7XG5leHBvcnQgdmFyIExFQVZFID0gJ0xFQVZFJzsiLCJpbXBvcnQgZGVmaW5lUHJvcGVydHkgZnJvbSBcIi4vZGVmaW5lUHJvcGVydHlcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gT2JqZWN0KGFyZ3VtZW50c1tpXSkgOiB7fTtcbiAgICB2YXIgb3duS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG5cbiAgICBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG93bktleXMgPSBvd25LZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7XG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgb3duS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufSIsImltcG9ydCBfb2JqZWN0U3ByZWFkIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RTcHJlYWRcIjtcbmltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgeyBpbnRlcnBvbGF0ZSwgaW50ZXJwb2xhdGVUcmFuc2Zvcm1TdmcgfSBmcm9tICdkMy1pbnRlcnBvbGF0ZSc7XG5leHBvcnQgZnVuY3Rpb24gZ2V0SW50ZXJwb2xhdG9yKGF0dHIpIHtcbiAgaWYgKGF0dHIgPT09ICd0cmFuc2Zvcm0nKSB7XG4gICAgcmV0dXJuIGludGVycG9sYXRlVHJhbnNmb3JtU3ZnO1xuICB9XG5cbiAgcmV0dXJuIGludGVycG9sYXRlO1xufVxuXG5mdW5jdGlvbiBnZXRUd2VlbihuYW1lU3BhY2UsIGF0dHIsIHZhbHVlMSkge1xuICByZXR1cm4gZnVuY3Rpb24gdHdlZW4oKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciB2YWx1ZTAgPSBuYW1lU3BhY2UgPyB0aGlzLnN0YXRlW25hbWVTcGFjZV1bYXR0cl0gOiB0aGlzLnN0YXRlW2F0dHJdO1xuXG4gICAgaWYgKHZhbHVlMCA9PT0gdmFsdWUxKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgaSA9IGdldEludGVycG9sYXRvcihhdHRyKSh2YWx1ZTAsIHZhbHVlMSk7XG4gICAgdmFyIHN0YXRlVHdlZW47XG5cbiAgICBpZiAobmFtZVNwYWNlID09PSBudWxsKSB7XG4gICAgICBzdGF0ZVR3ZWVuID0gZnVuY3Rpb24gc3RhdGVUd2Vlbih0KSB7XG4gICAgICAgIF90aGlzLnNldFN0YXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX2RlZmluZVByb3BlcnR5KHt9LCBhdHRyLCBpKHQpKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZVR3ZWVuID0gZnVuY3Rpb24gc3RhdGVUd2Vlbih0KSB7XG4gICAgICAgIF90aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICAgIHJldHVybiBfZGVmaW5lUHJvcGVydHkoe30sIG5hbWVTcGFjZSwgX29iamVjdFNwcmVhZCh7fSwgc3RhdGVbbmFtZVNwYWNlXSwgX2RlZmluZVByb3BlcnR5KHt9LCBhdHRyLCBpKHQpKSkpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YXRlVHdlZW47XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChuYW1lU3BhY2UsIGF0dHIsIHZhbHVlKSB7XG4gIHJldHVybiBnZXRUd2Vlbi5jYWxsKHRoaXMsIG5hbWVTcGFjZSwgYXR0ciwgdmFsdWUpO1xufSIsImltcG9ydCBfb2JqZWN0U3ByZWFkIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RTcHJlYWRcIjtcbi8vIEFwYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtdHJhbnNpdGlvbi9ibG9iL21hc3Rlci9zcmMvdHJhbnNpdGlvbi9zY2hlZHVsZS5qc1xuaW1wb3J0IHsgdGltZXIsIHRpbWVvdXQgfSBmcm9tICdkMy10aW1lcic7XG52YXIgQ1JFQVRFRCA9IDA7XG52YXIgU0NIRURVTEVEID0gMTtcbnZhciBTVEFSVElORyA9IDI7XG52YXIgU1RBUlRFRCA9IDM7XG52YXIgUlVOTklORyA9IDQ7XG52YXIgRU5ESU5HID0gNTtcbnZhciBFTkRFRCA9IDY7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAobm9kZSwgc3RhdGVLZXksIGlkLCB0aW1pbmcsIHR3ZWVucykge1xuICB2YXIgZXZlbnRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiB7fTtcbiAgdmFyIHNjaGVkdWxlcyA9IG5vZGUuVFJBTlNJVElPTl9TQ0hFRFVMRVM7XG5cbiAgaWYgKCFzY2hlZHVsZXMpIHtcbiAgICBub2RlLlRSQU5TSVRJT05fU0NIRURVTEVTID0ge307IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgfSBlbHNlIGlmIChpZCBpbiBzY2hlZHVsZXMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY29uZmlnID0gX29iamVjdFNwcmVhZCh7XG4gICAgc3RhdGVLZXk6IHN0YXRlS2V5LFxuICAgIGV2ZW50czogZXZlbnRzLFxuICAgIHR3ZWVuczogdHdlZW5zXG4gIH0sIHRpbWluZywge1xuICAgIHRpbWVyOiBudWxsLFxuICAgIHN0YXRlOiBDUkVBVEVEXG4gIH0pO1xuXG4gIGNyZWF0ZShub2RlLCBpZCwgY29uZmlnKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlKG5vZGUsIGlkLCBjb25maWcpIHtcbiAgdmFyIHNjaGVkdWxlcyA9IG5vZGUuVFJBTlNJVElPTl9TQ0hFRFVMRVM7IC8vIEluaXRpYWxpemUgdGhlIHRyYW5zaXRpb24gdGltZXIgd2hlbiB0aGUgdHJhbnNpdGlvbiBpcyBjcmVhdGVkLlxuICAvLyBOb3RlIHRoZSBhY3R1YWwgZGVsYXkgaXMgbm90IGtub3duIHVudGlsIHRoZSBmaXJzdCBjYWxsYmFjayFcblxuICB2YXIgdHJhbnNpdGlvbiA9IF9vYmplY3RTcHJlYWQoe30sIGNvbmZpZyk7XG5cbiAgdmFyIG4gPSB0cmFuc2l0aW9uLnR3ZWVucy5sZW5ndGg7XG4gIHZhciB0d2VlbnMgPSBuZXcgQXJyYXkobik7XG4gIHNjaGVkdWxlc1tpZF0gPSB0cmFuc2l0aW9uO1xuICB0cmFuc2l0aW9uLnRpbWVyID0gdGltZXIoc2NoZWR1bGUsIDAsIHRyYW5zaXRpb24udGltZSk7XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGUoZWxhcHNlZCkge1xuICAgIHRyYW5zaXRpb24uc3RhdGUgPSBTQ0hFRFVMRUQ7XG4gICAgdHJhbnNpdGlvbi50aW1lci5yZXN0YXJ0KHN0YXJ0LCB0cmFuc2l0aW9uLmRlbGF5LCB0cmFuc2l0aW9uLnRpbWUpOyAvLyBJZiB0aGUgZWxhcHNlZCBkZWxheSBpcyBsZXNzIHRoYW4gb3VyIGZpcnN0IHNsZWVwLCBzdGFydCBpbW1lZGlhdGVseS5cblxuICAgIGlmICh0cmFuc2l0aW9uLmRlbGF5IDw9IGVsYXBzZWQpIHtcbiAgICAgIHN0YXJ0KGVsYXBzZWQgLSB0cmFuc2l0aW9uLmRlbGF5KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdGFydChlbGFwc2VkKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICAgIC8vIElmIHRoZSBzdGF0ZSBpcyBub3QgU0NIRURVTEVELCB0aGVuIHdlIHByZXZpb3VzbHkgZXJyb3JlZCBvbiBzdGFydC5cbiAgICBpZiAodHJhbnNpdGlvbi5zdGF0ZSAhPT0gU0NIRURVTEVEKSByZXR1cm4gc3RvcCgpO1xuXG4gICAgZm9yICh2YXIgc2lkIGluIHNjaGVkdWxlcykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgdmFyIHMgPSBzY2hlZHVsZXNbc2lkXTtcblxuICAgICAgaWYgKHMuc3RhdGVLZXkgIT09IHRyYW5zaXRpb24uc3RhdGVLZXkpIHtcbiAgICAgICAgY29udGludWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29udGludWVcbiAgICAgIH0gLy8gV2hpbGUgdGhpcyBlbGVtZW50IGFscmVhZHkgaGFzIGEgc3RhcnRpbmcgdHJhbnNpdGlvbiBkdXJpbmcgdGhpcyBmcmFtZSxcbiAgICAgIC8vIGRlZmVyIHN0YXJ0aW5nIGFuIGludGVycnVwdGluZyB0cmFuc2l0aW9uIHVudGlsIHRoYXQgdHJhbnNpdGlvbiBoYXMgYVxuICAgICAgLy8gY2hhbmNlIHRvIHRpY2sgKGFuZCBwb3NzaWJseSBlbmQpOyBzZWUgZDMvZDMtdHJhbnNpdGlvbiM1NCFcblxuXG4gICAgICBpZiAocy5zdGF0ZSA9PT0gU1RBUlRFRCkgcmV0dXJuIHRpbWVvdXQoc3RhcnQpOyAvLyAxLiBJbnRlcnJ1cHQgdGhlIGFjdGl2ZSB0cmFuc2l0aW9uLCBpZiBhbnkuIGRpc3BhdGNoIHRoZSBpbnRlcnJ1cHQgZXZlbnQuXG4gICAgICAvLyAyLiBDYW5jZWwgYW55IHByZS1lbXB0ZWQgdHJhbnNpdGlvbnMuIE5vIGludGVycnVwdCBldmVudCBpcyBkaXNwYXRjaGVkXG4gICAgICAvLyBiZWNhdXNlIHRoZSBjYW5jZWxsZWQgdHJhbnNpdGlvbnMgbmV2ZXIgc3RhcnRlZC4gTm90ZSB0aGF0IHRoaXMgYWxzb1xuICAgICAgLy8gcmVtb3ZlcyB0aGlzIHRyYW5zaXRpb24gZnJvbSB0aGUgcGVuZGluZyBsaXN0IVxuXG4gICAgICBpZiAocy5zdGF0ZSA9PT0gUlVOTklORykge1xuICAgICAgICBzLnN0YXRlID0gRU5ERUQ7XG4gICAgICAgIHMudGltZXIuc3RvcCgpO1xuXG4gICAgICAgIGlmIChzLmV2ZW50cy5pbnRlcnJ1cHQgJiYgdHlwZW9mIHMuZXZlbnRzLmludGVycnVwdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHMuZXZlbnRzLmludGVycnVwdC5jYWxsKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIHNjaGVkdWxlc1tzaWRdO1xuICAgICAgfSBlbHNlIGlmICgrc2lkIDwgaWQpIHtcbiAgICAgICAgcy5zdGF0ZSA9IEVOREVEO1xuICAgICAgICBzLnRpbWVyLnN0b3AoKTtcbiAgICAgICAgZGVsZXRlIHNjaGVkdWxlc1tzaWRdO1xuICAgICAgfVxuICAgIH0gLy8gRGVmZXIgdGhlIGZpcnN0IHRpY2sgdG8gZW5kIG9mIHRoZSBjdXJyZW50IGZyYW1lOyBzZWUgZDMvZDMjMTU3Ni5cbiAgICAvLyBOb3RlIHRoZSB0cmFuc2l0aW9uIG1heSBiZSBjYW5jZWxlZCBhZnRlciBzdGFydCBhbmQgYmVmb3JlIHRoZSBmaXJzdCB0aWNrIVxuICAgIC8vIE5vdGUgdGhpcyBtdXN0IGJlIHNjaGVkdWxlZCBiZWZvcmUgdGhlIHN0YXJ0IGV2ZW50OyBzZWUgZDMvZDMtdHJhbnNpdGlvbiMxNiFcbiAgICAvLyBBc3N1bWluZyB0aGlzIGlzIHN1Y2Nlc3NmdWwsIHN1YnNlcXVlbnQgY2FsbGJhY2tzIGdvIHN0cmFpZ2h0IHRvIHRpY2suXG5cblxuICAgIHRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRyYW5zaXRpb24uc3RhdGUgPT09IFNUQVJURUQpIHtcbiAgICAgICAgdHJhbnNpdGlvbi5zdGF0ZSA9IFJVTk5JTkc7XG4gICAgICAgIHRyYW5zaXRpb24udGltZXIucmVzdGFydCh0aWNrLCB0cmFuc2l0aW9uLmRlbGF5LCB0cmFuc2l0aW9uLnRpbWUpO1xuICAgICAgICB0aWNrKGVsYXBzZWQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRyYW5zaXRpb24uc3RhdGUgPSBTVEFSVElORztcblxuICAgIGlmICh0cmFuc2l0aW9uLmV2ZW50cy5zdGFydCAmJiB0eXBlb2YgdHJhbnNpdGlvbi5ldmVudHMuc3RhcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRyYW5zaXRpb24uZXZlbnRzLnN0YXJ0LmNhbGwobm9kZSk7XG4gICAgfVxuXG4gICAgaWYgKHRyYW5zaXRpb24uc3RhdGUgIT09IFNUQVJUSU5HKSB7XG4gICAgICAvLyBpbnRlcnJ1cHRlZFxuICAgICAgcmV0dXJuOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gICAgfVxuXG4gICAgdHJhbnNpdGlvbi5zdGF0ZSA9IFNUQVJURUQ7IC8vIEluaXRpYWxpemUgdGhlIHR3ZWVuLCBkZWxldGluZyBudWxsIHR3ZWVuLlxuXG4gICAgdmFyIGogPSAtMTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICB2YXIgcmVzID0gdHJhbnNpdGlvbi50d2VlbnNbaV0uY2FsbChub2RlKTtcblxuICAgICAgaWYgKHJlcykge1xuICAgICAgICB0d2VlbnNbKytqXSA9IHJlcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0d2VlbnMubGVuZ3RoID0gaiArIDE7XG4gIH1cblxuICBmdW5jdGlvbiB0aWNrKGVsYXBzZWQpIHtcbiAgICB2YXIgdCA9IDE7XG5cbiAgICBpZiAoZWxhcHNlZCA8IHRyYW5zaXRpb24uZHVyYXRpb24pIHtcbiAgICAgIHQgPSB0cmFuc2l0aW9uLmVhc2UuY2FsbChudWxsLCBlbGFwc2VkIC8gdHJhbnNpdGlvbi5kdXJhdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYW5zaXRpb24udGltZXIucmVzdGFydChzdG9wKTtcbiAgICAgIHRyYW5zaXRpb24uc3RhdGUgPSBFTkRJTkc7XG4gICAgfVxuXG4gICAgdmFyIGkgPSAtMTtcblxuICAgIHdoaWxlICgrK2kgPCB0d2VlbnMubGVuZ3RoKSB7XG4gICAgICB0d2VlbnNbaV0uY2FsbChudWxsLCB0KTtcbiAgICB9XG5cbiAgICBpZiAodHJhbnNpdGlvbi5zdGF0ZSA9PT0gRU5ESU5HKSB7XG4gICAgICBpZiAodHJhbnNpdGlvbi5ldmVudHMuZW5kICYmIHR5cGVvZiB0cmFuc2l0aW9uLmV2ZW50cy5lbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdHJhbnNpdGlvbi5ldmVudHMuZW5kLmNhbGwobm9kZSk7XG4gICAgICB9XG5cbiAgICAgIHN0b3AoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdG9wKCkge1xuICAgIHRyYW5zaXRpb24uc3RhdGUgPSBFTkRFRDtcbiAgICB0cmFuc2l0aW9uLnRpbWVyLnN0b3AoKTtcbiAgICBkZWxldGUgc2NoZWR1bGVzW2lkXTtcblxuICAgIGZvciAodmFyIGkgaW4gc2NoZWR1bGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGd1YXJkLWZvci1pbiwgbm8tcmVzdHJpY3RlZC1zeW50YXhcblxuXG4gICAgZGVsZXRlIG5vZGUuVFJBTlNJVElPTl9TQ0hFRFVMRVM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgfVxufSIsImltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgX3R5cGVvZiBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdHlwZW9mXCI7XG5pbXBvcnQgX29iamVjdFNwcmVhZCBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0U3ByZWFkXCI7XG5pbXBvcnQgeyBub3cgYXMgdGltZU5vdyB9IGZyb20gJ2QzLXRpbWVyJztcbmltcG9ydCB0d2VlbiBmcm9tICcuL3R3ZWVuJztcbmltcG9ydCBzY2hlZHVsZSBmcm9tICcuL3NjaGVkdWxlJztcblxuZnVuY3Rpb24gb25jZShmdW5jKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRyYW5zaXRpb25FdmVudCgpIHtcbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgIGZ1bmMuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBpZCA9IDA7XG5leHBvcnQgZnVuY3Rpb24gbmV3SWQoKSB7XG4gIHJldHVybiArK2lkO1xufSAvLyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1lYXNlL2Jsb2IvbWFzdGVyL3NyYy9saW5lYXIuanNcblxuZnVuY3Rpb24gbGluZWFyKHQpIHtcbiAgcmV0dXJuICt0O1xufVxuXG5leHBvcnQgdmFyIHByZXNldCA9IHtcbiAgdGltZTogbnVsbCxcbiAgZGVsYXk6IDAsXG4gIGR1cmF0aW9uOiAyNTAsXG4gIGVhc2U6IGxpbmVhclxufTtcblxuZnVuY3Rpb24gc2NoZWR1bGVUcmFuc2l0aW9ucygpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgY29uZmlnID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICB2YXIgdHJhbnNpdGlvbnMgPSBfb2JqZWN0U3ByZWFkKHt9LCBjb25maWcpO1xuXG4gIHZhciBldmVudHMgPSB0cmFuc2l0aW9ucy5ldmVudHMgfHwge307XG4gIGRlbGV0ZSB0cmFuc2l0aW9ucy5ldmVudHM7IC8vIGVhY2ggZXZlbnQgaGFuZGxlciBzaG91bGQgYmUgY2FsbGVkIG9ubHkgb25jZVxuXG4gIE9iamVjdC5rZXlzKGV2ZW50cykuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgIGlmICh0eXBlb2YgZXZlbnRzW2RdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V2ZW50IGhhbmRsZXJzIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBldmVudHNbZF0gPSBvbmNlKGV2ZW50c1tkXSk7XG4gICAgfVxuICB9KTtcbiAgdmFyIHRpbWluZyA9IHRyYW5zaXRpb25zLnRpbWluZyB8fCB7fTtcbiAgZGVsZXRlIHRyYW5zaXRpb25zLnRpbWluZztcbiAgT2JqZWN0LmtleXModHJhbnNpdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKHN0YXRlS2V5KSB7XG4gICAgdmFyIHR3ZWVucyA9IFtdO1xuXG4gICAgaWYgKF90eXBlb2YodHJhbnNpdGlvbnNbc3RhdGVLZXldKSA9PT0gJ29iamVjdCcgJiYgQXJyYXkuaXNBcnJheSh0cmFuc2l0aW9uc1tzdGF0ZUtleV0pID09PSBmYWxzZSkge1xuICAgICAgT2JqZWN0LmtleXModHJhbnNpdGlvbnNbc3RhdGVLZXldKS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgIHZhciB2YWwgPSB0cmFuc2l0aW9uc1tzdGF0ZUtleV1bYXR0cl07XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB0d2VlbnMucHVzaCh0d2Vlbi5jYWxsKF90aGlzLCBzdGF0ZUtleSwgYXR0ciwgdmFsWzBdKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gX2RlZmluZVByb3BlcnR5KHt9LCBzdGF0ZUtleSwgX29iamVjdFNwcmVhZCh7fSwgc3RhdGVbc3RhdGVLZXldLCBfZGVmaW5lUHJvcGVydHkoe30sIGF0dHIsIHZhbFswXSkpKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0d2VlbnMucHVzaCh0d2Vlbi5jYWxsKF90aGlzLCBzdGF0ZUtleSwgYXR0ciwgdmFsWzFdKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgZ2V0UmVzb25hbmNlQ3VzdG9tVHdlZW4gPSBmdW5jdGlvbiBnZXRSZXNvbmFuY2VDdXN0b21Ud2VlbigpIHtcbiAgICAgICAgICAgIHZhciByZXNvbmFuY2VDdXN0b21Ud2VlbiA9IGZ1bmN0aW9uIHJlc29uYW5jZUN1c3RvbVR3ZWVuKHQpIHtcbiAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9kZWZpbmVQcm9wZXJ0eSh7fSwgc3RhdGVLZXksIF9vYmplY3RTcHJlYWQoe30sIHN0YXRlW3N0YXRlS2V5XSwgX2RlZmluZVByb3BlcnR5KHt9LCBhdHRyLCB2YWwodCkpKSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc29uYW5jZUN1c3RvbVR3ZWVuO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB0d2VlbnMucHVzaChnZXRSZXNvbmFuY2VDdXN0b21Ud2Vlbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gX2RlZmluZVByb3BlcnR5KHt9LCBzdGF0ZUtleSwgX29iamVjdFNwcmVhZCh7fSwgc3RhdGVbc3RhdGVLZXldLCBfZGVmaW5lUHJvcGVydHkoe30sIGF0dHIsIHZhbCkpKTtcbiAgICAgICAgICB9KTsgLy8gVGhpcyBhc3N1cmVzIGFueSBleGlzdGluZyB0cmFuc2l0aW9ucyBhcmUgc3RvcHBlZFxuXG5cbiAgICAgICAgICB0d2VlbnMucHVzaCh0d2Vlbi5jYWxsKF90aGlzLCBzdGF0ZUtleSwgYXR0ciwgdmFsKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdmFsID0gdHJhbnNpdGlvbnNbc3RhdGVLZXldO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgdHdlZW5zLnB1c2godHdlZW4uY2FsbChfdGhpcywgbnVsbCwgc3RhdGVLZXksIHZhbFswXSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzLnNldFN0YXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfZGVmaW5lUHJvcGVydHkoe30sIHN0YXRlS2V5LCB2YWxbMF0pO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdHdlZW5zLnB1c2godHdlZW4uY2FsbChfdGhpcywgbnVsbCwgc3RhdGVLZXksIHZhbFsxXSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIGdldFJlc29uYW5jZUN1c3RvbVR3ZWVuID0gZnVuY3Rpb24gZ2V0UmVzb25hbmNlQ3VzdG9tVHdlZW4oKSB7XG4gICAgICAgICAgdmFyIHJlc29uYW5jZUN1c3RvbVR3ZWVuID0gZnVuY3Rpb24gcmVzb25hbmNlQ3VzdG9tVHdlZW4odCkge1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gX2RlZmluZVByb3BlcnR5KHt9LCBzdGF0ZUtleSwgdmFsKHQpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICByZXR1cm4gcmVzb25hbmNlQ3VzdG9tVHdlZW47XG4gICAgICAgIH07XG5cbiAgICAgICAgdHdlZW5zLnB1c2goZ2V0UmVzb25hbmNlQ3VzdG9tVHdlZW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfZGVmaW5lUHJvcGVydHkoe30sIHN0YXRlS2V5LCB2YWwpO1xuICAgICAgICB9KTsgLy8gVGhpcyBhc3N1cmVzIGFueSBleGlzdGluZyB0cmFuc2l0aW9ucyBhcmUgc3RvcHBlZFxuXG5cbiAgICAgICAgdHdlZW5zLnB1c2godHdlZW4uY2FsbChfdGhpcywgbnVsbCwgc3RhdGVLZXksIHZhbCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0aW1pbmdDb25maWcgPSBfb2JqZWN0U3ByZWFkKHt9LCBwcmVzZXQsIHRpbWluZywge1xuICAgICAgdGltZTogdGltZU5vdygpXG4gICAgfSk7XG5cbiAgICBzY2hlZHVsZShfdGhpcywgc3RhdGVLZXksIG5ld0lkKCksIHRpbWluZ0NvbmZpZywgdHdlZW5zLCBldmVudHMpO1xuICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdHJhbnNpdGlvbihjb25maWcpIHtcbiAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnKSkge1xuICAgIGNvbmZpZy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICBzY2hlZHVsZVRyYW5zaXRpb25zLmNhbGwoX3RoaXMyLCBjKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBzY2hlZHVsZVRyYW5zaXRpb25zLmNhbGwodGhpcywgY29uZmlnKTtcbiAgfVxufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHN0b3AoKSB7XG4gIHZhciB0cyA9IHRoaXMuVFJBTlNJVElPTl9TQ0hFRFVMRVM7XG5cbiAgaWYgKHRzKSB7XG4gICAgT2JqZWN0LmtleXModHMpLmZvckVhY2goZnVuY3Rpb24gKHMpIHtcbiAgICAgIHRzW3NdLnRpbWVyLnN0b3AoKTtcbiAgICB9KTtcbiAgfVxufSIsImV4cG9ydCB7IGRlZmF1bHQgYXMgdHJhbnNpdGlvbiB9IGZyb20gJy4vdHJhbnNpdGlvbic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHN0b3AgfSBmcm9tICcuL3N0b3AnOyIsImltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrXCI7XG5pbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzc1wiO1xuaW1wb3J0IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCI7XG5pbXBvcnQgX2dldFByb3RvdHlwZU9mIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9nZXRQcm90b3R5cGVPZlwiO1xuaW1wb3J0IF9pbmhlcml0cyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHNcIjtcbmltcG9ydCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3NlcnRUaGlzSW5pdGlhbGl6ZWRcIjtcbmltcG9ydCBfZGVmaW5lUHJvcGVydHkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5XCI7XG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgcG9seWZpbGwgfSBmcm9tICdyZWFjdC1saWZlY3ljbGVzLWNvbXBhdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgaW50ZXJ2YWwgfSBmcm9tICdkMy10aW1lcic7XG5pbXBvcnQgTm9kZSBmcm9tICcuLi9Ob2RlJztcbmltcG9ydCBtZXJnZUtleXMgZnJvbSAnLi4vY29yZS9tZXJnZUtleXMnO1xuaW1wb3J0IHsgRU5URVIsIFVQREFURSwgTEVBVkUgfSBmcm9tICcuLi9jb3JlL3R5cGVzJztcbmltcG9ydCB7IHRyYW5zaXRpb24sIHN0b3AgfSBmcm9tICcuLi9jb3JlL3RyYW5zaXRpb24nO1xuXG52YXIgTm9kZUdyb3VwID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhOb2RlR3JvdXAsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIE5vZGVHcm91cCgpIHtcbiAgICB2YXIgX2dldFByb3RvdHlwZU9mMjtcblxuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb2RlR3JvdXApO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9nZXRQcm90b3R5cGVPZjIgPSBfZ2V0UHJvdG90eXBlT2YoTm9kZUdyb3VwKSkuY2FsbC5hcHBseShfZ2V0UHJvdG90eXBlT2YyLCBbdGhpc10uY29uY2F0KGFyZ3MpKSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSksIFwic3RhdGVcIiwge1xuICAgICAgbm9kZUtleXM6IFtdLFxuICAgICAgbm9kZUhhc2g6IHt9LFxuICAgICAgbm9kZXM6IFtdLFxuICAgICAgZGF0YTogbnVsbFxuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLCBcImFuaW1hdGVcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF90aGlzJHN0YXRlID0gX3RoaXMuc3RhdGUsXG4gICAgICAgICAgbm9kZUtleXMgPSBfdGhpcyRzdGF0ZS5ub2RlS2V5cyxcbiAgICAgICAgICBub2RlSGFzaCA9IF90aGlzJHN0YXRlLm5vZGVIYXNoO1xuXG4gICAgICBpZiAoX3RoaXMudW5tb3VudGluZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBwZW5kaW5nID0gZmFsc2U7XG4gICAgICB2YXIgbmV4dE5vZGVLZXlzID0gW107XG4gICAgICB2YXIgbGVuZ3RoID0gbm9kZUtleXMubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrID0gbm9kZUtleXNbaV07XG4gICAgICAgIHZhciBuID0gbm9kZUhhc2hba107XG5cbiAgICAgICAgaWYgKG4uVFJBTlNJVElPTl9TQ0hFRFVMRVMpIHtcbiAgICAgICAgICBwZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuLnR5cGUgPT09IExFQVZFICYmICFuLlRSQU5TSVRJT05fU0NIRURVTEVTKSB7XG4gICAgICAgICAgZGVsZXRlIG5vZGVIYXNoW2tdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHROb2RlS2V5cy5wdXNoKGspO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghcGVuZGluZykge1xuICAgICAgICBfdGhpcy5pbnRlcnZhbC5zdG9wKCk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnNldFN0YXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBub2RlS2V5czogbmV4dE5vZGVLZXlzLFxuICAgICAgICAgIG5vZGVzOiBuZXh0Tm9kZUtleXMubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlSGFzaFtrZXldO1xuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSwgXCJpbnRlcnZhbFwiLCBudWxsKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSwgXCJ1bm1vdW50aW5nXCIsIGZhbHNlKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhOb2RlR3JvdXAsIFt7XG4gICAga2V5OiBcImNvbXBvbmVudERpZE1vdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgdGhpcy5zdGFydEludGVydmFsKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBvbmVudERpZFVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICBpZiAocHJldlByb3BzLmRhdGEgIT09IHRoaXMucHJvcHMuZGF0YSAmJiAhdGhpcy51bm1vdW50aW5nKSB7XG4gICAgICAgIHRoaXMuc3RhcnRJbnRlcnZhbCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGFydEludGVydmFsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0SW50ZXJ2YWwoKSB7XG4gICAgICBpZiAoIXRoaXMuaW50ZXJ2YWwpIHtcbiAgICAgICAgdGhpcy5pbnRlcnZhbCA9IGludGVydmFsKHRoaXMuYW5pbWF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmludGVydmFsLnJlc3RhcnQodGhpcy5hbmltYXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50V2lsbFVubW91bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICB2YXIgX3RoaXMkc3RhdGUyID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgICBub2RlS2V5cyA9IF90aGlzJHN0YXRlMi5ub2RlS2V5cyxcbiAgICAgICAgICBub2RlSGFzaCA9IF90aGlzJHN0YXRlMi5ub2RlSGFzaDtcbiAgICAgIHRoaXMudW5tb3VudGluZyA9IHRydWU7XG5cbiAgICAgIGlmICh0aGlzLmludGVydmFsKSB7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWwuc3RvcCgpO1xuICAgICAgfVxuXG4gICAgICBub2RlS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgc3RvcC5jYWxsKG5vZGVIYXNoW2tleV0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgcmVuZGVyZWRDaGlsZHJlbiA9IHRoaXMucHJvcHMuY2hpbGRyZW4odGhpcy5zdGF0ZS5ub2Rlcyk7XG4gICAgICByZXR1cm4gcmVuZGVyZWRDaGlsZHJlbiAmJiBSZWFjdC5DaGlsZHJlbi5vbmx5KHJlbmRlcmVkQ2hpbGRyZW4pO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV4dFByb3BzLCBwcmV2U3RhdGUpIHtcbiAgICAgIGlmIChuZXh0UHJvcHMuZGF0YSAhPT0gcHJldlN0YXRlLmRhdGEpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBuZXh0UHJvcHMuZGF0YSxcbiAgICAgICAgICAgIGtleUFjY2Vzc29yID0gbmV4dFByb3BzLmtleUFjY2Vzc29yLFxuICAgICAgICAgICAgc3RhcnQgPSBuZXh0UHJvcHMuc3RhcnQsXG4gICAgICAgICAgICBlbnRlciA9IG5leHRQcm9wcy5lbnRlcixcbiAgICAgICAgICAgIHVwZGF0ZSA9IG5leHRQcm9wcy51cGRhdGUsXG4gICAgICAgICAgICBsZWF2ZSA9IG5leHRQcm9wcy5sZWF2ZTtcbiAgICAgICAgdmFyIG5vZGVLZXlzID0gcHJldlN0YXRlLm5vZGVLZXlzLFxuICAgICAgICAgICAgbm9kZUhhc2ggPSBwcmV2U3RhdGUubm9kZUhhc2g7XG4gICAgICAgIHZhciBrZXlJbmRleCA9IHt9O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBrZXlJbmRleFtub2RlS2V5c1tpXV0gPSBpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5leHRLZXlJbmRleCA9IHt9O1xuICAgICAgICB2YXIgbmV4dE5vZGVLZXlzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGRhdGEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgdmFyIGQgPSBkYXRhW19pXTtcbiAgICAgICAgICB2YXIgayA9IGtleUFjY2Vzc29yKGQsIF9pKTtcbiAgICAgICAgICBuZXh0S2V5SW5kZXhba10gPSBfaTtcbiAgICAgICAgICBuZXh0Tm9kZUtleXMucHVzaChrKTtcblxuICAgICAgICAgIGlmIChrZXlJbmRleFtrXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBub2RlSGFzaFtrXSA9IG5ldyBOb2RlKGssIGQsIEVOVEVSKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBub2RlS2V5cy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgdmFyIF9rID0gbm9kZUtleXNbX2kyXTtcbiAgICAgICAgICB2YXIgbiA9IG5vZGVIYXNoW19rXTtcblxuICAgICAgICAgIGlmIChuZXh0S2V5SW5kZXhbX2tdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG4udXBkYXRlRGF0YShkYXRhW25leHRLZXlJbmRleFtfa11dKTtcbiAgICAgICAgICAgIG4udXBkYXRlVHlwZShVUERBVEUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuLnVwZGF0ZVR5cGUoTEVBVkUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtZXJnZWROb2RlS2V5cyA9IG1lcmdlS2V5cyhub2RlS2V5cywga2V5SW5kZXgsIG5leHROb2RlS2V5cywgbmV4dEtleUluZGV4KTtcblxuICAgICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBtZXJnZWROb2RlS2V5cy5sZW5ndGg7IF9pMysrKSB7XG4gICAgICAgICAgdmFyIF9rMiA9IG1lcmdlZE5vZGVLZXlzW19pM107XG4gICAgICAgICAgdmFyIF9uID0gbm9kZUhhc2hbX2syXTtcbiAgICAgICAgICB2YXIgX2QgPSBfbi5kYXRhO1xuXG4gICAgICAgICAgaWYgKF9uLnR5cGUgPT09IEVOVEVSKSB7XG4gICAgICAgICAgICBfbi5zZXRTdGF0ZShzdGFydChfZCwgbmV4dEtleUluZGV4W19rMl0pKTtcblxuICAgICAgICAgICAgdHJhbnNpdGlvbi5jYWxsKF9uLCBlbnRlcihfZCwgbmV4dEtleUluZGV4W19rMl0pKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKF9uLnR5cGUgPT09IExFQVZFKSB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uLmNhbGwoX24sIGxlYXZlKF9kLCBrZXlJbmRleFtfazJdKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb24uY2FsbChfbiwgdXBkYXRlKF9kLCBuZXh0S2V5SW5kZXhbX2syXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICBub2RlczogbWVyZ2VkTm9kZUtleXMubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlSGFzaFtrZXldO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIG5vZGVIYXNoOiBub2RlSGFzaCxcbiAgICAgICAgICBub2RlS2V5czogbWVyZ2VkTm9kZUtleXNcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE5vZGVHcm91cDtcbn0oQ29tcG9uZW50KTtcblxuTm9kZUdyb3VwLnByb3BUeXBlcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHtcbiAgLyoqXG4gICAqIEFuIGFycmF5LiAgVGhlIGRhdGEgcHJvcCBpcyB0cmVhdGVkIGFzIGltbXV0YWJsZSBzbyB0aGUgbm9kZXMgd2lsbCBvbmx5IHVwZGF0ZSBpZiBwcmV2LmRhdGEgIT09IG5leHQuZGF0YS5cbiAgICovXG4gIGRhdGE6IFByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLFxuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0aGF0IHJldHVybnMgYSBzdHJpbmcga2V5IGdpdmVuIHRoZSBkYXRhIGFuZCBpdHMgaW5kZXguICBVc2VkIHRvIHRyYWNrIHdoaWNoIG5vZGVzIGFyZSBlbnRlcmluZywgdXBkYXRpbmcgYW5kIGxlYXZpbmcuXG4gICAqL1xuICBrZXlBY2Nlc3NvcjogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcblxuICAvKipcbiAgICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHN0YXJ0aW5nIHN0YXRlLiAgVGhlIGZ1bmN0aW9uIGlzIHBhc3NlZCB0aGUgZGF0YSBhbmQgaW5kZXggYW5kIG11c3QgcmV0dXJuIGFuIG9iamVjdC5cbiAgICovXG4gIHN0YXJ0OiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuXG4gIC8qKlxuICAgKiBBIGZ1bmN0aW9uIHRoYXQgKipyZXR1cm5zIGFuIG9iamVjdCBvciBhcnJheSBvZiBvYmplY3RzKiogZGVzY3JpYmluZyBob3cgdGhlIHN0YXRlIHNob3VsZCB0cmFuc2Zvcm0gb24gZW50ZXIuICBUaGUgZnVuY3Rpb24gaXMgcGFzc2VkIHRoZSBkYXRhIGFuZCBpbmRleC5cbiAgICovXG4gIGVudGVyOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQSBmdW5jdGlvbiB0aGF0ICoqcmV0dXJucyBhbiBvYmplY3Qgb3IgYXJyYXkgb2Ygb2JqZWN0cyoqIGRlc2NyaWJpbmcgaG93IHRoZSBzdGF0ZSBzaG91bGQgdHJhbnNmb3JtIG9uIHVwZGF0ZS4gIFRoZSBmdW5jdGlvbiBpcyBwYXNzZWQgdGhlIGRhdGEgYW5kIGluZGV4LlxuICAgKi9cbiAgdXBkYXRlOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQSBmdW5jdGlvbiB0aGF0ICoqcmV0dXJucyBhbiBvYmplY3Qgb3IgYXJyYXkgb2Ygb2JqZWN0cyoqIGRlc2NyaWJpbmcgaG93IHRoZSBzdGF0ZSBzaG91bGQgdHJhbnNmb3JtIG9uIGxlYXZlLiAgVGhlIGZ1bmN0aW9uIGlzIHBhc3NlZCB0aGUgZGF0YSBhbmQgaW5kZXguXG4gICAqL1xuICBsZWF2ZTogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIEEgZnVuY3Rpb24gdGhhdCByZW5kZXJzIHRoZSBub2Rlcy4gSXQgc2hvdWxkIGFjY2VwdCBhbiBhcnJheSBvZiBub2RlcyBhcyBpdHMgb25seSBhcmd1bWVudC4gIEVhY2ggbm9kZSBpcyBhbiBvYmplY3Qgd2l0aCB0aGUga2V5LCBkYXRhLCBzdGF0ZSBhbmQgYSB0eXBlIG9mICdFTlRFUicsICdVUERBVEUnIG9yICdMRUFWRScuXG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxufSA6IHt9O1xuTm9kZUdyb3VwLmRlZmF1bHRQcm9wcyA9IHtcbiAgZW50ZXI6IGZ1bmN0aW9uIGVudGVyKCkge30sXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKCkge30sXG4gIGxlYXZlOiBmdW5jdGlvbiBsZWF2ZSgpIHt9XG59O1xucG9seWZpbGwoTm9kZUdyb3VwKTtcbmV4cG9ydCBkZWZhdWx0IE5vZGVHcm91cDsiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBOb2RlR3JvdXAgZnJvbSAnLi4vTm9kZUdyb3VwJztcblxudmFyIGtleUFjY2Vzc29yID0gZnVuY3Rpb24ga2V5QWNjZXNzb3IoKSB7XG4gIHJldHVybiAnJCRrZXkkJCc7XG59O1xuXG5mdW5jdGlvbiBBbmltYXRlKHByb3BzKSB7XG4gIHZhciBzaG93ID0gcHJvcHMuc2hvdyxcbiAgICAgIHN0YXJ0ID0gcHJvcHMuc3RhcnQsXG4gICAgICBlbnRlciA9IHByb3BzLmVudGVyLFxuICAgICAgdXBkYXRlID0gcHJvcHMudXBkYXRlLFxuICAgICAgbGVhdmUgPSBwcm9wcy5sZWF2ZSxcbiAgICAgIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG4gIHZhciBkYXRhID0gdHlwZW9mIHN0YXJ0ID09PSAnZnVuY3Rpb24nID8gc3RhcnQoKSA6IHN0YXJ0O1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChOb2RlR3JvdXAsIHtcbiAgICBkYXRhOiBzaG93ID8gW2RhdGFdIDogW10sXG4gICAgc3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcbiAgICBrZXlBY2Nlc3Nvcjoga2V5QWNjZXNzb3IsXG4gICAgZW50ZXI6IHR5cGVvZiBlbnRlciA9PT0gJ2Z1bmN0aW9uJyA/IGVudGVyIDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGVudGVyO1xuICAgIH0sXG4gICAgdXBkYXRlOiB0eXBlb2YgdXBkYXRlID09PSAnZnVuY3Rpb24nID8gdXBkYXRlIDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHVwZGF0ZTtcbiAgICB9LFxuICAgIGxlYXZlOiB0eXBlb2YgbGVhdmUgPT09ICdmdW5jdGlvbicgPyBsZWF2ZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBsZWF2ZTtcbiAgICB9XG4gIH0sIGZ1bmN0aW9uIChub2Rlcykge1xuICAgIGlmICghbm9kZXNbMF0pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciByZW5kZXJlZENoaWxkcmVuID0gY2hpbGRyZW4obm9kZXNbMF0uc3RhdGUpO1xuICAgIHJldHVybiByZW5kZXJlZENoaWxkcmVuICYmIFJlYWN0LkNoaWxkcmVuLm9ubHkocmVuZGVyZWRDaGlsZHJlbik7XG4gIH0pO1xufVxuXG5BbmltYXRlLnByb3BUeXBlcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHtcbiAgLyoqXG4gICAqIEJvb2xlYW4gdmFsdWUgdGhhdCBkZXRlcm1pbmVzIGlmIHRoZSBjaGlsZCBzaG91bGQgYmUgcmVuZGVyZWQgb3Igbm90LlxuICAgKi9cbiAgc2hvdzogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcblxuICAvKipcbiAgICogQW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBvYmVqY3QgdG8gYmUgdXNlZCBhcyB0aGUgc3RhcnRpbmcgc3RhdGUuXG4gICAqL1xuICBzdGFydDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5vYmplY3RdKSxcblxuICAvKipcbiAgICogQW4gb2JqZWN0LCBhcnJheSBvZiBvYmplY3RzLCBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gb2JqZWN0IG9yIGFycmF5IG9mIG9iamVjdHMgZGVzY3JpYmluZyBob3cgdGhlIHN0YXRlIHNob3VsZCB0cmFuc2Zvcm0gb24gZW50ZXIuXG4gICAqL1xuICBlbnRlcjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5hcnJheSwgUHJvcFR5cGVzLm9iamVjdF0pLFxuXG4gIC8qKlxuICAgKiBBbiBvYmplY3QsIGFycmF5IG9mIG9iamVjdHMsIG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBvYmplY3Qgb3IgYXJyYXkgb2Ygb2JqZWN0cyBkZXNjcmliaW5nIGhvdyB0aGUgc3RhdGUgc2hvdWxkIHRyYW5zZm9ybSBvbiB1cGRhdGUuICoqKk5vdGU6KioqIGFsdGhvdWdoIG5vdCByZXF1aXJlZCwgaW4gbW9zdCBjYXNlcyBpdCBtYWtlIHNlbnNlIHRvIHNwZWNpZnkgYW4gdXBkYXRlIHByb3AgdG8gaGFuZGxlIGludGVycnVwdGVkIGVudGVyIGFuZCBsZWF2ZSB0cmFuc2l0aW9ucy5cbiAgICovXG4gIHVwZGF0ZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5hcnJheSwgUHJvcFR5cGVzLm9iamVjdF0pLFxuXG4gIC8qKlxuICAgKiBBbiBvYmplY3QsIGFycmF5IG9mIG9iamVjdHMsIG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBvYmplY3Qgb3IgYXJyYXkgb2Ygb2JqZWN0cyBkZXNjcmliaW5nIGhvdyB0aGUgc3RhdGUgc2hvdWxkIHRyYW5zZm9ybSBvbiBsZWF2ZS5cbiAgICovXG4gIGxlYXZlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLmFycmF5LCBQcm9wVHlwZXMub2JqZWN0XSksXG5cbiAgLyoqXG4gICAqIEEgZnVuY3Rpb24gdGhhdCByZW5kZXJzIHRoZSBub2RlLiAgVGhlIGZ1bmN0aW9uIGlzIHBhc3NlZCB0aGUgZGF0YSBhbmQgc3RhdGUuXG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxufSA6IHt9O1xuQW5pbWF0ZS5kZWZhdWx0UHJvcHMgPSB7XG4gIHNob3c6IHRydWVcbn07XG5leHBvcnQgZGVmYXVsdCBBbmltYXRlOyIsImV4cG9ydCB7IGRlZmF1bHQgYXMgQW5pbWF0ZSB9IGZyb20gJy4vQW5pbWF0ZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE5vZGVHcm91cCB9IGZyb20gJy4vTm9kZUdyb3VwJzsiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjYWxsT3JWYWx1ZShtYXliZUZuKSB7XG4gIGlmICh0eXBlb2YgbWF5YmVGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBtYXliZUZuLmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gIH1cblxuICByZXR1cm4gbWF5YmVGbjtcbn0iLCJpbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IE5vZGVHcm91cCB9IGZyb20gJ3JlYWN0LW1vdmUnO1xuaW1wb3J0IHsgY2hhcnRUaGVtZSB9IGZyb20gJ0BkYXRhLXVpL3RoZW1lJztcbmltcG9ydCB7IEdyb3VwIH0gZnJvbSAnQHZ4L2dyb3VwJztcbmltcG9ydCB7IEJhciB9IGZyb20gJ0B2eC9zaGFwZSc7XG5pbXBvcnQgY2FsbE9yVmFsdWUgZnJvbSAnLi4vLi4vdXRpbHMvY2FsbE9yVmFsdWUnO1xuaW1wb3J0IHsgYmlubmVkRGF0YVNoYXBlIH0gZnJvbSAnLi4vLi4vdXRpbHMvcHJvcFNoYXBlcyc7XG52YXIgcHJvcFR5cGVzID0ge1xuICByYXdEYXRhOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSkpLFxuICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlYWN0L25vLXVudXNlZC1wcm9wLXR5cGVzXG4gIGJpbm5lZERhdGE6IGJpbm5lZERhdGFTaGFwZSxcbiAgZmlsbDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgZmlsbE9wYWNpdHk6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gIGhvcml6b250YWw6IFByb3BUeXBlcy5ib29sLFxuICBzdHJva2U6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMuc3RyaW5nXSksXG4gIHN0cm9rZVdpZHRoOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm51bWJlcl0pLFxuICB2YWx1ZUtleTogUHJvcFR5cGVzLnN0cmluZyxcbiAgb25DbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gIC8vIGxpa2VseSBpbmplY3RlZCBieSBwYXJlbnQgSGlzdG9ncmFtXG4gIGJpblNjYWxlOiBQcm9wVHlwZXMuZnVuYyxcbiAgdmFsdWVTY2FsZTogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uTW91c2VNb3ZlOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25Nb3VzZUxlYXZlOiBQcm9wVHlwZXMuZnVuYyxcbiAga2V5QWNjZXNzb3I6IFByb3BUeXBlcy5mdW5jXG59O1xudmFyIGRlZmF1bHRQcm9wcyA9IHtcbiAgcmF3RGF0YTogW10sXG4gIGJpbm5lZERhdGE6IFtdLFxuICBiaW5TY2FsZTogbnVsbCxcbiAgZmlsbDogY2hhcnRUaGVtZS5jb2xvcnMuZGVmYXVsdCxcbiAgZmlsbE9wYWNpdHk6IDAuNyxcbiAgaG9yaXpvbnRhbDogZmFsc2UsXG4gIG9uQ2xpY2s6IG51bGwsXG4gIG9uTW91c2VNb3ZlOiBudWxsLFxuICBvbk1vdXNlTGVhdmU6IG51bGwsXG4gIHN0cm9rZTogJyNGRkZGRkYnLFxuICBzdHJva2VXaWR0aDogMSxcbiAgdmFsdWVLZXk6ICdjb3VudCcsXG4gIHZhbHVlU2NhbGU6IG51bGwsXG4gIGtleUFjY2Vzc29yOiBmdW5jdGlvbiBrZXlBY2Nlc3NvcihkKSB7XG4gICAgcmV0dXJuIGQuaWQ7XG4gIH1cbn07XG52YXIgSU5ERVhfREVMQVlfTVVMVElQTElFUiA9IDEwO1xuXG52YXIgZ2V0QmluID0gZnVuY3Rpb24gZ2V0QmluKGQpIHtcbiAgcmV0dXJuIHR5cGVvZiBkLmJpbiA9PT0gJ3VuZGVmaW5lZCcgPyBkLmJpbjAgOiBkLmJpbjtcbn07XG5cbnZhciBnZXRCaW4xID0gZnVuY3Rpb24gZ2V0QmluMShkKSB7XG4gIHJldHVybiB0eXBlb2YgZC5iaW4gPT09ICd1bmRlZmluZWQnID8gZC5iaW4xIDogZC5iaW47XG59O1xuXG5mdW5jdGlvbiBBbmltYXRlZEJhclNlcmllcyhfcmVmKSB7XG4gIHZhciBiaW5uZWREYXRhID0gX3JlZi5iaW5uZWREYXRhLFxuICAgICAgdmFsdWVTY2FsZSA9IF9yZWYudmFsdWVTY2FsZSxcbiAgICAgIGJpblNjYWxlID0gX3JlZi5iaW5TY2FsZSxcbiAgICAgIGhvcml6b250YWwgPSBfcmVmLmhvcml6b250YWwsXG4gICAgICBrZXlBY2Nlc3NvciA9IF9yZWYua2V5QWNjZXNzb3IsXG4gICAgICBmaWxsID0gX3JlZi5maWxsLFxuICAgICAgZmlsbE9wYWNpdHkgPSBfcmVmLmZpbGxPcGFjaXR5LFxuICAgICAgb25DbGljayA9IF9yZWYub25DbGljayxcbiAgICAgIG9uTW91c2VNb3ZlID0gX3JlZi5vbk1vdXNlTW92ZSxcbiAgICAgIG9uTW91c2VMZWF2ZSA9IF9yZWYub25Nb3VzZUxlYXZlLFxuICAgICAgc3Ryb2tlID0gX3JlZi5zdHJva2UsXG4gICAgICBzdHJva2VXaWR0aCA9IF9yZWYuc3Ryb2tlV2lkdGgsXG4gICAgICB2YWx1ZUtleSA9IF9yZWYudmFsdWVLZXk7XG4gIHZhciBtYXhCYXJMZW5ndGggPSBNYXRoLm1heC5hcHBseShNYXRoLCB2YWx1ZVNjYWxlLnJhbmdlKCkpOyAvLyBjb21wdXRlIG9uY2UgYW5kIHVzZSB0aHJvdWdob3V0XG5cbiAgdmFyIGJhcldpZHRocyA9IGJpbm5lZERhdGEubWFwKGZ1bmN0aW9uIChfLCBpKSB7XG4gICAgcmV0dXJuIGJpblNjYWxlLmJhbmR3aWR0aCA/IGJpblNjYWxlLmJhbmR3aWR0aCgpIC8vIGNhdGVnb3JpY2FsXG4gICAgOiBNYXRoLmFicyhiaW5TY2FsZShiaW5uZWREYXRhW2ldLmJpbjEpIC0gYmluU2NhbGUoYmlubmVkRGF0YVtpXS5iaW4wKSk7XG4gIH0gLy8gbnVtZXJpY1xuICApO1xuXG4gIHZhciBnZXRWYWx1ZSA9IGZ1bmN0aW9uIGdldFZhbHVlKGQpIHtcbiAgICByZXR1cm4gZFt2YWx1ZUtleV07XG4gIH07XG5cbiAgdmFyIGdldFggPSBob3Jpem9udGFsID8gZ2V0VmFsdWUgOiBnZXRCaW47XG4gIHZhciBnZXRZID0gaG9yaXpvbnRhbCA/IGdldEJpbjEgOiBnZXRWYWx1ZTtcbiAgdmFyIHhTY2FsZSA9IGhvcml6b250YWwgPyB2YWx1ZVNjYWxlIDogYmluU2NhbGU7XG4gIHZhciB5U2NhbGUgPSBob3Jpem9udGFsID8gYmluU2NhbGUgOiB2YWx1ZVNjYWxlO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChOb2RlR3JvdXAsIHtcbiAgICBkYXRhOiBiaW5uZWREYXRhLFxuICAgIGtleUFjY2Vzc29yOiBrZXlBY2Nlc3NvcixcbiAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQoZCwgaSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogaG9yaXpvbnRhbCA/IDAgOiB4U2NhbGUoZ2V0WChkKSksXG4gICAgICAgIHk6IGhvcml6b250YWwgPyB5U2NhbGUoZ2V0WShkKSkgOiBtYXhCYXJMZW5ndGgsXG4gICAgICAgIGZpbGw6IGQuZmlsbCB8fCBjYWxsT3JWYWx1ZShmaWxsLCBkLCBpKSxcbiAgICAgICAgd2lkdGg6IGhvcml6b250YWwgPyAwIDogYmFyV2lkdGhzW2ldLFxuICAgICAgICBoZWlnaHQ6IGhvcml6b250YWwgPyBiYXJXaWR0aHNbaV0gOiAwXG4gICAgICB9O1xuICAgIH0sXG4gICAgZW50ZXI6IGZ1bmN0aW9uIGVudGVyKGQsIGkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IFtob3Jpem9udGFsID8gMCA6IHhTY2FsZShnZXRYKGQpKV0sXG4gICAgICAgIHk6IFt5U2NhbGUoZ2V0WShkKSldLFxuICAgICAgICB3aWR0aDogW2hvcml6b250YWwgPyB4U2NhbGUoZ2V0WChkKSkgOiBiYXJXaWR0aHNbaV1dLFxuICAgICAgICBoZWlnaHQ6IFtob3Jpem9udGFsID8gYmFyV2lkdGhzW2ldIDogbWF4QmFyTGVuZ3RoIC0geVNjYWxlKGdldFkoZCkpXSxcbiAgICAgICAgZmlsbDogW2QuZmlsbCB8fCBjYWxsT3JWYWx1ZShmaWxsLCBkLCBpKV0sXG4gICAgICAgIHN0cm9rZTogW2Quc3Ryb2tlIHx8IGNhbGxPclZhbHVlKHN0cm9rZSwgZCwgaSldLFxuICAgICAgICB0aW1pbmc6IHtcbiAgICAgICAgICBkdXJhdGlvbjogMzAwLFxuICAgICAgICAgIGRlbGF5OiBJTkRFWF9ERUxBWV9NVUxUSVBMSUVSICogaVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoZCwgaSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogW2hvcml6b250YWwgPyAwIDogeFNjYWxlKGdldFgoZCkpXSxcbiAgICAgICAgeTogW3lTY2FsZShnZXRZKGQpKV0sXG4gICAgICAgIHdpZHRoOiBbaG9yaXpvbnRhbCA/IHhTY2FsZShnZXRYKGQpKSA6IGJhcldpZHRoc1tpXV0sXG4gICAgICAgIGhlaWdodDogW2hvcml6b250YWwgPyBiYXJXaWR0aHNbaV0gOiBtYXhCYXJMZW5ndGggLSB5U2NhbGUoZ2V0WShkKSldLFxuICAgICAgICBmaWxsOiBbZC5maWxsIHx8IGNhbGxPclZhbHVlKGZpbGwsIGQsIGkpXSxcbiAgICAgICAgc3Ryb2tlOiBbZC5zdHJva2UgfHwgY2FsbE9yVmFsdWUoc3Ryb2tlLCBkLCBpKV0sXG4gICAgICAgIHRpbWluZzoge1xuICAgICAgICAgIGR1cmF0aW9uOiAzMDAsXG4gICAgICAgICAgZGVsYXk6IElOREVYX0RFTEFZX01VTFRJUExJRVIgKiBpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICBsZWF2ZTogZnVuY3Rpb24gbGVhdmUoZCwgaSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogaG9yaXpvbnRhbCA/IDAgOiB4U2NhbGUoZ2V0WChkKSksXG4gICAgICAgIHk6IGhvcml6b250YWwgPyB5U2NhbGUoZ2V0WShkKSkgOiBtYXhCYXJMZW5ndGgsXG4gICAgICAgIHdpZHRoOiBob3Jpem9udGFsID8gMCA6IGJhcldpZHRoc1tpXSxcbiAgICAgICAgaGVpZ2h0OiBob3Jpem9udGFsID8gYmFyV2lkdGhzW2ldIDogMCxcbiAgICAgICAgdGltaW5nOiB7XG4gICAgICAgICAgZHVyYXRpb246IDMwMCxcbiAgICAgICAgICBkZWxheTogSU5ERVhfREVMQVlfTVVMVElQTElFUiAvIDIgKiBpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9LCBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEdyb3VwLCBudWxsLCBkYXRhLm1hcChmdW5jdGlvbiAobW9kaWZpZWREYXR1bSwgaSkge1xuICAgICAgdmFyIGtleSA9IG1vZGlmaWVkRGF0dW0ua2V5LFxuICAgICAgICAgIHJhd0RhdHVtID0gbW9kaWZpZWREYXR1bS5kYXRhLFxuICAgICAgICAgIGQgPSBtb2RpZmllZERhdHVtLnN0YXRlO1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQmFyLCB7XG4gICAgICAgIGtleTogXCJiYXJcIiArIGtleSxcbiAgICAgICAgeDogZC54LFxuICAgICAgICB5OiBkLnksXG4gICAgICAgIHdpZHRoOiBkLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGQuaGVpZ2h0LFxuICAgICAgICBmaWxsOiBkLmZpbGwsXG4gICAgICAgIHN0cm9rZTogZC5zdHJva2UsXG4gICAgICAgIGZpbGxPcGFjaXR5OiB0eXBlb2YgZmlsbE9wYWNpdHkgPT09ICd1bmRlZmluZWQnID8gY2FsbE9yVmFsdWUoZmlsbE9wYWNpdHksIHJhd0RhdHVtLCBpKSA6IGZpbGxPcGFjaXR5LFxuICAgICAgICBzdHJva2VXaWR0aDogcmF3RGF0dW0uc3Ryb2tlV2lkdGggfHwgY2FsbE9yVmFsdWUoc3Ryb2tlV2lkdGgsIHJhd0RhdHVtLCBpKSxcbiAgICAgICAgb25DbGljazogb25DbGljayAmJiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgb25DbGljayh7XG4gICAgICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICAgICAgZGF0dW06IHJhd0RhdHVtLFxuICAgICAgICAgICAgICBkYXRhOiBiaW5uZWREYXRhLFxuICAgICAgICAgICAgICBjb2xvcjogZC5maWxsLFxuICAgICAgICAgICAgICBpbmRleDogaVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Nb3VzZU1vdmU6IG9uTW91c2VNb3ZlICYmIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBvbk1vdXNlTW92ZSh7XG4gICAgICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICAgICAgZGF0dW06IHJhd0RhdHVtLFxuICAgICAgICAgICAgICBkYXRhOiBiaW5uZWREYXRhLFxuICAgICAgICAgICAgICBjb2xvcjogZC5maWxsLFxuICAgICAgICAgICAgICBpbmRleDogaVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Nb3VzZUxlYXZlOiBvbk1vdXNlTGVhdmUgJiYgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBvbk1vdXNlTGVhdmU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pKTtcbiAgfSk7XG59XG5cbkFuaW1hdGVkQmFyU2VyaWVzLnByb3BUeXBlcyA9IHByb3BUeXBlcztcbkFuaW1hdGVkQmFyU2VyaWVzLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbmV4cG9ydCBkZWZhdWx0IEFuaW1hdGVkQmFyU2VyaWVzOyIsImltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY2hhcnRUaGVtZSB9IGZyb20gJ0BkYXRhLXVpL3RoZW1lJztcbmltcG9ydCB7IEdyb3VwIH0gZnJvbSAnQHZ4L2dyb3VwJztcbmltcG9ydCB7IEJhciB9IGZyb20gJ0B2eC9zaGFwZSc7XG5pbXBvcnQgQW5pbWF0ZWRCYXJTZXJpZXMgZnJvbSAnLi9hbmltYXRlZC9BbmltYXRlZEJhclNlcmllcyc7XG5pbXBvcnQgY2FsbE9yVmFsdWUgZnJvbSAnLi4vdXRpbHMvY2FsbE9yVmFsdWUnO1xuaW1wb3J0IHsgYmlubmVkRGF0YVNoYXBlIH0gZnJvbSAnLi4vdXRpbHMvcHJvcFNoYXBlcyc7XG5leHBvcnQgdmFyIHByb3BUeXBlcyA9IHtcbiAgYW5pbWF0ZWQ6IFByb3BUeXBlcy5ib29sLFxuICByYXdEYXRhOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSkpLFxuICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlYWN0L25vLXVudXNlZC1wcm9wLXR5cGVzXG4gIGJpbm5lZERhdGE6IGJpbm5lZERhdGFTaGFwZSxcbiAgZmlsbDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgZmlsbE9wYWNpdHk6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gIGhvcml6b250YWw6IFByb3BUeXBlcy5ib29sLFxuICBzdHJva2U6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMuc3RyaW5nXSksXG4gIHN0cm9rZVdpZHRoOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm51bWJlcl0pLFxuICB2YWx1ZUtleTogUHJvcFR5cGVzLnN0cmluZyxcbiAgb25DbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gIC8vIGxpa2VseSBpbmplY3RlZCBieSBwYXJlbnQgSGlzdG9ncmFtXG4gIGJpblNjYWxlOiBQcm9wVHlwZXMuZnVuYyxcbiAgdmFsdWVTY2FsZTogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uTW91c2VNb3ZlOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25Nb3VzZUxlYXZlOiBQcm9wVHlwZXMuZnVuY1xufTtcbmV4cG9ydCB2YXIgZGVmYXVsdFByb3BzID0ge1xuICBhbmltYXRlZDogdHJ1ZSxcbiAgcmF3RGF0YTogW10sXG4gIGJpbm5lZERhdGE6IFtdLFxuICBiaW5TY2FsZTogbnVsbCxcbiAgZmlsbDogY2hhcnRUaGVtZS5jb2xvcnMuZGVmYXVsdCxcbiAgZmlsbE9wYWNpdHk6IDAuNyxcbiAgaG9yaXpvbnRhbDogZmFsc2UsXG4gIG9uQ2xpY2s6IG51bGwsXG4gIG9uTW91c2VNb3ZlOiBudWxsLFxuICBvbk1vdXNlTGVhdmU6IG51bGwsXG4gIHN0cm9rZTogJyNGRkZGRkYnLFxuICBzdHJva2VXaWR0aDogMSxcbiAgdmFsdWVLZXk6ICdjb3VudCcsXG4gIHZhbHVlU2NhbGU6IG51bGxcbn07XG5cbmZ1bmN0aW9uIEJhclNlcmllcyhfcmVmKSB7XG4gIHZhciBhbmltYXRlZCA9IF9yZWYuYW5pbWF0ZWQsXG4gICAgICBiaW5uZWREYXRhID0gX3JlZi5iaW5uZWREYXRhLFxuICAgICAgYmluU2NhbGUgPSBfcmVmLmJpblNjYWxlLFxuICAgICAgZmlsbCA9IF9yZWYuZmlsbCxcbiAgICAgIGZpbGxPcGFjaXR5ID0gX3JlZi5maWxsT3BhY2l0eSxcbiAgICAgIGhvcml6b250YWwgPSBfcmVmLmhvcml6b250YWwsXG4gICAgICBvbkNsaWNrID0gX3JlZi5vbkNsaWNrLFxuICAgICAgb25Nb3VzZU1vdmUgPSBfcmVmLm9uTW91c2VNb3ZlLFxuICAgICAgb25Nb3VzZUxlYXZlID0gX3JlZi5vbk1vdXNlTGVhdmUsXG4gICAgICBzdHJva2UgPSBfcmVmLnN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoID0gX3JlZi5zdHJva2VXaWR0aCxcbiAgICAgIHZhbHVlS2V5ID0gX3JlZi52YWx1ZUtleSxcbiAgICAgIHZhbHVlU2NhbGUgPSBfcmVmLnZhbHVlU2NhbGU7XG4gIGlmICghYmluU2NhbGUgfHwgIXZhbHVlU2NhbGUgfHwgIWJpbm5lZERhdGEgfHwgYmlubmVkRGF0YS5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuICB2YXIgbWF4QmFyTGVuZ3RoID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgdmFsdWVTY2FsZS5yYW5nZSgpKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoR3JvdXAsIG51bGwsIGFuaW1hdGVkICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQW5pbWF0ZWRCYXJTZXJpZXMsIHtcbiAgICBiaW5uZWREYXRhOiBiaW5uZWREYXRhLFxuICAgIGJpblNjYWxlOiBiaW5TY2FsZSxcbiAgICBob3Jpem9udGFsOiBob3Jpem9udGFsLFxuICAgIGZpbGw6IGZpbGwsXG4gICAgZmlsbE9wYWNpdHk6IGZpbGxPcGFjaXR5LFxuICAgIG9uQ2xpY2s6IG9uQ2xpY2ssXG4gICAgb25Nb3VzZU1vdmU6IG9uTW91c2VNb3ZlLFxuICAgIG9uTW91c2VMZWF2ZTogb25Nb3VzZUxlYXZlLFxuICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICB2YWx1ZUtleTogdmFsdWVLZXksXG4gICAgdmFsdWVTY2FsZTogdmFsdWVTY2FsZVxuICB9KSwgIWFuaW1hdGVkICYmIGJpbm5lZERhdGEubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgdmFyIGJpblBvc2l0aW9uID0gYmluU2NhbGUoZC5iaW4gfHwgKGhvcml6b250YWwgPyBkLmJpbjEgOiBkLmJpbjApKTtcbiAgICB2YXIgYmFyTGVuZ3RoID0gaG9yaXpvbnRhbCA/IHZhbHVlU2NhbGUoZFt2YWx1ZUtleV0pIDogbWF4QmFyTGVuZ3RoIC0gdmFsdWVTY2FsZShkW3ZhbHVlS2V5XSk7XG4gICAgdmFyIGJhcldpZHRoID0gYmluU2NhbGUuYmFuZHdpZHRoID8gYmluU2NhbGUuYmFuZHdpZHRoKCkgLy8gY2F0ZWdvcmljYWxcbiAgICA6IE1hdGguYWJzKGJpblNjYWxlKGJpbm5lZERhdGFbaV0uYmluMSkgLSBiaW5TY2FsZShiaW5uZWREYXRhW2ldLmJpbjApKTsgLy8gbnVtZXJpY1xuXG4gICAgdmFyIGNvbG9yID0gZC5maWxsIHx8IGNhbGxPclZhbHVlKGZpbGwsIGQsIGkpO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEJhciwge1xuICAgICAga2V5OiBcImJhci1cIiArIGJpblBvc2l0aW9uLFxuICAgICAgeDogaG9yaXpvbnRhbCA/IDAgOiBiaW5Qb3NpdGlvbixcbiAgICAgIHk6IGhvcml6b250YWwgPyBiaW5Qb3NpdGlvbiA6IG1heEJhckxlbmd0aCAtIGJhckxlbmd0aCxcbiAgICAgIHdpZHRoOiBob3Jpem9udGFsID8gYmFyTGVuZ3RoIDogYmFyV2lkdGgsXG4gICAgICBoZWlnaHQ6IGhvcml6b250YWwgPyBiYXJXaWR0aCA6IGJhckxlbmd0aCxcbiAgICAgIGZpbGw6IGNvbG9yLFxuICAgICAgZmlsbE9wYWNpdHk6IHR5cGVvZiBmaWxsT3BhY2l0eSA9PT0gJ3VuZGVmaW5lZCcgPyBjYWxsT3JWYWx1ZShmaWxsT3BhY2l0eSwgZCwgaSkgOiBmaWxsT3BhY2l0eSxcbiAgICAgIHN0cm9rZTogZC5zdHJva2UgfHwgY2FsbE9yVmFsdWUoc3Ryb2tlLCBkLCBpKSxcbiAgICAgIHN0cm9rZVdpZHRoOiBkLnN0cm9rZVdpZHRoIHx8IGNhbGxPclZhbHVlKHN0cm9rZVdpZHRoLCBkLCBpKSxcbiAgICAgIG9uQ2xpY2s6IG9uQ2xpY2sgJiYgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgb25DbGljayh7XG4gICAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgICBkYXRhOiBiaW5uZWREYXRhLFxuICAgICAgICAgICAgZGF0dW06IGQsXG4gICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICBpbmRleDogaVxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIG9uTW91c2VNb3ZlOiBvbk1vdXNlTW92ZSAmJiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBvbk1vdXNlTW92ZSh7XG4gICAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgICBkYXRhOiBiaW5uZWREYXRhLFxuICAgICAgICAgICAgZGF0dW06IGQsXG4gICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICBpbmRleDogaVxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIG9uTW91c2VMZWF2ZTogb25Nb3VzZUxlYXZlICYmIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG9uTW91c2VMZWF2ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSkpO1xufVxuXG5CYXJTZXJpZXMucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xuQmFyU2VyaWVzLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbkJhclNlcmllcy5kaXNwbGF5TmFtZSA9ICdCYXJTZXJpZXMnO1xuZXhwb3J0IGRlZmF1bHQgQmFyU2VyaWVzOyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBOzs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBOzs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBbUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQThCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0VBOzs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2292\n')},2294:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ Ordinal; });\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/react/index.js\nvar react = __webpack_require__(0);\nvar react_default = /*#__PURE__*/__webpack_require__.n(react);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/classnames/index.js\nvar classnames = __webpack_require__(130);\nvar classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);\n\n// EXTERNAL MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/prop-types/index.js\nvar prop_types = __webpack_require__(6);\nvar prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);\n\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/legend/esm/legends/LegendItem.js\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\nLegendItem.propTypes = {\n  flexDirection: prop_types_default.a.string,\n  alignItems: prop_types_default.a.string,\n  margin: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.number]),\n  children: prop_types_default.a.any,\n  display: prop_types_default.a.string\n};\nfunction LegendItem(_ref) {\n  var _ref$flexDirection = _ref.flexDirection,\n      flexDirection = _ref$flexDirection === void 0 ? \'row\' : _ref$flexDirection,\n      _ref$alignItems = _ref.alignItems,\n      alignItems = _ref$alignItems === void 0 ? \'center\' : _ref$alignItems,\n      _ref$margin = _ref.margin,\n      margin = _ref$margin === void 0 ? \'0\' : _ref$margin,\n      _ref$display = _ref.display,\n      display = _ref$display === void 0 ? \'flex\' : _ref$display,\n      children = _ref.children,\n      restProps = _objectWithoutPropertiesLoose(_ref, ["flexDirection", "alignItems", "margin", "display", "children"]);\n\n  return react_default.a.createElement("div", _extends({\n    className: "vx-legend-item",\n    style: {\n      display: display,\n      alignItems: alignItems,\n      flexDirection: flexDirection,\n      margin: margin\n    }\n  }, restProps), children);\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/legend/esm/legends/LegendLabel.js\n\n\nLegendLabel.propTypes = {\n  align: prop_types_default.a.string,\n  label: prop_types_default.a.any,\n  flex: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.number]),\n  margin: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.number]),\n  children: prop_types_default.a.any\n};\nfunction LegendLabel(_ref) {\n  var _ref$flex = _ref.flex,\n      flex = _ref$flex === void 0 ? \'1\' : _ref$flex,\n      label = _ref.label,\n      _ref$margin = _ref.margin,\n      margin = _ref$margin === void 0 ? \'5px 0\' : _ref$margin,\n      _ref$align = _ref.align,\n      align = _ref$align === void 0 ? \'left\' : _ref$align,\n      children = _ref.children;\n  return react_default.a.createElement("div", {\n    className: "vx-legend-label",\n    style: {\n      justifyContent: align,\n      display: \'flex\',\n      flex: flex,\n      margin: margin\n    }\n  }, children || label);\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/legend/esm/shapes/Rect.js\n\n\nfunction Rect_extends() { Rect_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return Rect_extends.apply(this, arguments); }\n\n\nfunction ShapeRect(_ref) {\n  var fill = _ref.fill,\n      width = _ref.width,\n      height = _ref.height,\n      style = _ref.style;\n  return /*#__PURE__*/react_default.a.createElement("div", {\n    style: Rect_extends({\n      width: width,\n      height: height,\n      background: fill\n    }, style)\n  });\n}\nShapeRect.propTypes = {\n  fill: prop_types_default.a.string,\n  width: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.number]),\n  height: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.number])\n};\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/legend/node_modules/@vx/group/esm/Group.js\n\n\nfunction Group_extends() { Group_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return Group_extends.apply(this, arguments); }\n\nfunction Group_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\nfunction Group(_ref) {\n  var _ref$top = _ref.top,\n      top = _ref$top === void 0 ? 0 : _ref$top,\n      _ref$left = _ref.left,\n      left = _ref$left === void 0 ? 0 : _ref$left,\n      transform = _ref.transform,\n      className = _ref.className,\n      children = _ref.children,\n      innerRef = _ref.innerRef,\n      restProps = Group_objectWithoutPropertiesLoose(_ref, ["top", "left", "transform", "className", "children", "innerRef"]);\n\n  return /*#__PURE__*/react_default.a.createElement("g", Group_extends({\n    ref: innerRef,\n    className: classnames_default()(\'vx-group\', className),\n    transform: transform || "translate(" + left + ", " + top + ")"\n  }, restProps), children);\n}\nGroup.propTypes = {\n  top: prop_types_default.a.number,\n  left: prop_types_default.a.number,\n  transform: prop_types_default.a.string,\n  className: prop_types_default.a.string,\n  children: prop_types_default.a.node,\n  innerRef: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.func, prop_types_default.a.object])\n};\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/legend/esm/shapes/Circle.js\n\n\n\nfunction ShapeCircle(_ref) {\n  var fill = _ref.fill,\n      width = _ref.width,\n      height = _ref.height,\n      style = _ref.style;\n  var cleanWidth = typeof width === \'string\' || typeof width === \'undefined\' ? 0 : width;\n  var cleanHeight = typeof height === \'string\' || typeof height === \'undefined\' ? 0 : height;\n  var size = Math.max(cleanWidth, cleanHeight);\n  var radius = size / 2;\n  return /*#__PURE__*/react_default.a.createElement("svg", {\n    width: size,\n    height: size\n  }, /*#__PURE__*/react_default.a.createElement(Group, {\n    top: radius,\n    left: radius\n  }, /*#__PURE__*/react_default.a.createElement("circle", {\n    r: radius,\n    fill: String(fill),\n    style: style\n  })));\n}\nShapeCircle.propTypes = {\n  fill: prop_types_default.a.string,\n  width: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.number]),\n  height: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.number])\n};\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/legend/esm/util/renderShape.js\nfunction renderShape_extends() { renderShape_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return renderShape_extends.apply(this, arguments); }\n\n\n\n\n\nvar NO_OP = function NO_OP() {\n  return undefined;\n};\n\nfunction renderShape(_ref) {\n  var _ref$shape = _ref.shape,\n      shape = _ref$shape === void 0 ? \'rect\' : _ref$shape,\n      _ref$fill = _ref.fill,\n      fill = _ref$fill === void 0 ? NO_OP : _ref$fill,\n      _ref$size = _ref.size,\n      size = _ref$size === void 0 ? NO_OP : _ref$size,\n      width = _ref.width,\n      height = _ref.height,\n      label = _ref.label,\n      _ref$shapeStyle = _ref.shapeStyle,\n      shapeStyle = _ref$shapeStyle === void 0 ? NO_OP : _ref$shapeStyle;\n  var props = {\n    width: width,\n    height: height,\n    label: label,\n    fill: fill(renderShape_extends({}, label)),\n    size: size(renderShape_extends({}, label)),\n    style: shapeStyle(renderShape_extends({}, label))\n  };\n\n  if (typeof shape === \'string\') {\n    if (shape === \'rect\') {\n      return /*#__PURE__*/react_default.a.createElement(ShapeRect, props);\n    }\n\n    return /*#__PURE__*/react_default.a.createElement(ShapeCircle, props);\n  }\n\n  if ( /*#__PURE__*/react_default.a.isValidElement(shape)) {\n    return /*#__PURE__*/react_default.a.cloneElement(shape, props);\n  }\n\n  if (shape) {\n    return /*#__PURE__*/react_default.a.createElement(shape, props);\n  }\n\n  return null;\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/legend/esm/legends/LegendShape.js\nfunction LegendShape_extends() { LegendShape_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return LegendShape_extends.apply(this, arguments); }\n\n\n\n\n\nLegendShape.propTypes = {\n  shape: prop_types_default.a.any,\n  width: prop_types_default.a.any,\n  height: prop_types_default.a.any,\n  margin: prop_types_default.a.any,\n  label: prop_types_default.a.any,\n  fill: prop_types_default.a.any,\n  size: prop_types_default.a.any,\n  shapeStyle: prop_types_default.a.any\n};\nfunction LegendShape(_ref) {\n  var _ref$shape = _ref.shape,\n      shape = _ref$shape === void 0 ? ShapeRect : _ref$shape,\n      width = _ref.width,\n      height = _ref.height,\n      margin = _ref.margin,\n      label = _ref.label,\n      fill = _ref.fill,\n      size = _ref.size,\n      shapeStyle = _ref.shapeStyle;\n  return react_default.a.createElement("div", {\n    className: "vx-legend-shape",\n    style: {\n      display: \'flex\',\n      width: size ? size(LegendShape_extends({}, label)) : width,\n      height: size ? size(LegendShape_extends({}, label)) : height,\n      margin: margin\n    }\n  }, renderShape({\n    shape: shape,\n    label: label,\n    width: width,\n    height: height,\n    fill: fill,\n    shapeStyle: shapeStyle\n  }));\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/legend/esm/util/valueOrIdentity.js\n/** Returns an object\'s value if defined, or the object. */\nfunction valueOrIdentity(_) {\n  if (_ && typeof _ === \'object\' && \'value\' in _ && typeof _.value !== \'undefined\') return _.value;\n  return _;\n}\n/** Returns an object\'s value if defined, or the object, coerced to a string. */\n\nfunction valueOrIdentityString(_) {\n  return String(valueOrIdentity(_));\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/legend/esm/legends/Legend.js\nfunction Legend_extends() { Legend_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return Legend_extends.apply(this, arguments); }\n\nfunction Legend_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\nLegend.propTypes = {\n  className: prop_types_default.a.string,\n  style: prop_types_default.a.any,\n  domain: prop_types_default.a.array,\n  scale: prop_types_default.a.oneOfType([prop_types_default.a.func, prop_types_default.a.object]).isRequired,\n  shapeWidth: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),\n  shapeHeight: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),\n  shapeMargin: prop_types_default.a.any,\n  labelAlign: prop_types_default.a.string,\n  labelFlex: prop_types_default.a.string,\n  labelMargin: prop_types_default.a.string,\n  itemMargin: prop_types_default.a.string,\n  direction: prop_types_default.a.string,\n  itemDirection: prop_types_default.a.string,\n  fill: prop_types_default.a.any,\n  size: prop_types_default.a.any,\n  shape: prop_types_default.a.any,\n  shapeStyle: prop_types_default.a.any,\n  labelFormat: prop_types_default.a.func,\n  labelTransform: prop_types_default.a.func,\n  children: prop_types_default.a.func\n};\nvar defaultStyle = {\n  display: \'flex\'\n};\nfunction Legend(_ref) {\n  var className = _ref.className,\n      _ref$style = _ref.style,\n      style = _ref$style === void 0 ? defaultStyle : _ref$style,\n      shapeStyle = _ref.shapeStyle,\n      scale = _ref.scale,\n      shape = _ref.shape,\n      inputDomain = _ref.domain,\n      _ref$fill = _ref.fill,\n      fill = _ref$fill === void 0 ? valueOrIdentity : _ref$fill,\n      _ref$size = _ref.size,\n      size = _ref$size === void 0 ? valueOrIdentity : _ref$size,\n      _ref$labelFormat = _ref.labelFormat,\n      labelFormat = _ref$labelFormat === void 0 ? valueOrIdentity : _ref$labelFormat,\n      _ref$labelTransform = _ref.labelTransform,\n      labelTransform = _ref$labelTransform === void 0 ? defaultTransform : _ref$labelTransform,\n      _ref$shapeWidth = _ref.shapeWidth,\n      shapeWidth = _ref$shapeWidth === void 0 ? 15 : _ref$shapeWidth,\n      _ref$shapeHeight = _ref.shapeHeight,\n      shapeHeight = _ref$shapeHeight === void 0 ? 15 : _ref$shapeHeight,\n      _ref$shapeMargin = _ref.shapeMargin,\n      shapeMargin = _ref$shapeMargin === void 0 ? \'2px 4px 2px 0\' : _ref$shapeMargin,\n      _ref$labelAlign = _ref.labelAlign,\n      labelAlign = _ref$labelAlign === void 0 ? \'left\' : _ref$labelAlign,\n      _ref$labelFlex = _ref.labelFlex,\n      labelFlex = _ref$labelFlex === void 0 ? \'1\' : _ref$labelFlex,\n      _ref$labelMargin = _ref.labelMargin,\n      labelMargin = _ref$labelMargin === void 0 ? \'0 4px\' : _ref$labelMargin,\n      _ref$itemMargin = _ref.itemMargin,\n      itemMargin = _ref$itemMargin === void 0 ? \'0\' : _ref$itemMargin,\n      _ref$direction = _ref.direction,\n      direction = _ref$direction === void 0 ? \'column\' : _ref$direction,\n      _ref$itemDirection = _ref.itemDirection,\n      itemDirection = _ref$itemDirection === void 0 ? \'row\' : _ref$itemDirection,\n      children = _ref.children,\n      restProps = Legend_objectWithoutPropertiesLoose(_ref, ["className", "style", "shapeStyle", "scale", "shape", "domain", "fill", "size", "labelFormat", "labelTransform", "shapeWidth", "shapeHeight", "shapeMargin", "labelAlign", "labelFlex", "labelMargin", "itemMargin", "direction", "itemDirection", "children"]);\n\n  var domain = inputDomain || scale.domain();\n  var labels = domain.map(labelTransform({\n    scale: scale,\n    labelFormat: labelFormat\n  }));\n  if (children) return children(labels);\n  return react_default.a.createElement("div", {\n    className: classnames_default()(\'vx-legend\', className),\n    style: Legend_extends({}, style, {\n      flexDirection: direction\n    })\n  }, labels.map(function (label, i) {\n    var text = label.text;\n    return react_default.a.createElement(LegendItem, Legend_extends({\n      key: "legend-" + label + "-" + i,\n      margin: itemMargin,\n      flexDirection: itemDirection,\n      label: label\n    }, restProps), react_default.a.createElement(LegendShape, {\n      shape: shape,\n      height: shapeHeight,\n      width: shapeWidth,\n      margin: shapeMargin,\n      label: label,\n      fill: fill,\n      size: size,\n      shapeStyle: shapeStyle\n    }), react_default.a.createElement(LegendLabel, {\n      label: text,\n      flex: labelFlex,\n      margin: labelMargin,\n      align: labelAlign\n    }));\n  }));\n}\n\nfunction defaultTransform(_ref2) {\n  var scale = _ref2.scale,\n      labelFormat = _ref2.labelFormat;\n  return function (d, i) {\n    return {\n      datum: d,\n      index: i,\n      text: "" + labelFormat(d, i),\n      value: scale(d)\n    };\n  };\n}\n// CONCATENATED MODULE: /Users/erik_ritter/repos/github.com/apache-superset/superset-ui/node_modules/@vx/legend/esm/legends/Ordinal.js\n\n\n\n/** Ordinal scales map from strings to an Output type. */\nfunction Ordinal(props) {\n  return /*#__PURE__*/react_default.a.createElement(Legend, props);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjI5NC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0B2eC9sZWdlbmQvZXNtL2xlZ2VuZHMvTGVnZW5kSXRlbS5qcz9lMDkyIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0B2eC9sZWdlbmQvZXNtL2xlZ2VuZHMvTGVnZW5kTGFiZWwuanM/NjhlOSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AdngvbGVnZW5kL2VzbS9zaGFwZXMvUmVjdC5qcz81MmE0Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0B2eC9sZWdlbmQvbm9kZV9tb2R1bGVzL0B2eC9ncm91cC9lc20vR3JvdXAuanM/YmI1OSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AdngvbGVnZW5kL2VzbS9zaGFwZXMvQ2lyY2xlLmpzP2NiODciLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L2xlZ2VuZC9lc20vdXRpbC9yZW5kZXJTaGFwZS5qcz85MGEzIiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0B2eC9sZWdlbmQvZXNtL2xlZ2VuZHMvTGVnZW5kU2hhcGUuanM/MWRlOSIsIndlYnBhY2s6Ly8vL1VzZXJzL2VyaWtfcml0dGVyL3JlcG9zL2dpdGh1Yi5jb20vYXBhY2hlLXN1cGVyc2V0L3N1cGVyc2V0LXVpL25vZGVfbW9kdWxlcy9AdngvbGVnZW5kL2VzbS91dGlsL3ZhbHVlT3JJZGVudGl0eS5qcz9kYWQ3Iiwid2VicGFjazovLy8vVXNlcnMvZXJpa19yaXR0ZXIvcmVwb3MvZ2l0aHViLmNvbS9hcGFjaGUtc3VwZXJzZXQvc3VwZXJzZXQtdWkvbm9kZV9tb2R1bGVzL0B2eC9sZWdlbmQvZXNtL2xlZ2VuZHMvTGVnZW5kLmpzP2UyY2QiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9lcmlrX3JpdHRlci9yZXBvcy9naXRodWIuY29tL2FwYWNoZS1zdXBlcnNldC9zdXBlcnNldC11aS9ub2RlX21vZHVsZXMvQHZ4L2xlZ2VuZC9lc20vbGVnZW5kcy9PcmRpbmFsLmpzP2RmZTMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbkxlZ2VuZEl0ZW0ucHJvcFR5cGVzID0ge1xuICBmbGV4RGlyZWN0aW9uOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBhbGlnbkl0ZW1zOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBtYXJnaW46IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5hbnksXG4gIGRpc3BsYXk6IFByb3BUeXBlcy5zdHJpbmdcbn07XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBMZWdlbmRJdGVtKF9yZWYpIHtcbiAgdmFyIF9yZWYkZmxleERpcmVjdGlvbiA9IF9yZWYuZmxleERpcmVjdGlvbixcbiAgICAgIGZsZXhEaXJlY3Rpb24gPSBfcmVmJGZsZXhEaXJlY3Rpb24gPT09IHZvaWQgMCA/ICdyb3cnIDogX3JlZiRmbGV4RGlyZWN0aW9uLFxuICAgICAgX3JlZiRhbGlnbkl0ZW1zID0gX3JlZi5hbGlnbkl0ZW1zLFxuICAgICAgYWxpZ25JdGVtcyA9IF9yZWYkYWxpZ25JdGVtcyA9PT0gdm9pZCAwID8gJ2NlbnRlcicgOiBfcmVmJGFsaWduSXRlbXMsXG4gICAgICBfcmVmJG1hcmdpbiA9IF9yZWYubWFyZ2luLFxuICAgICAgbWFyZ2luID0gX3JlZiRtYXJnaW4gPT09IHZvaWQgMCA/ICcwJyA6IF9yZWYkbWFyZ2luLFxuICAgICAgX3JlZiRkaXNwbGF5ID0gX3JlZi5kaXNwbGF5LFxuICAgICAgZGlzcGxheSA9IF9yZWYkZGlzcGxheSA9PT0gdm9pZCAwID8gJ2ZsZXgnIDogX3JlZiRkaXNwbGF5LFxuICAgICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgcmVzdFByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZiwgW1wiZmxleERpcmVjdGlvblwiLCBcImFsaWduSXRlbXNcIiwgXCJtYXJnaW5cIiwgXCJkaXNwbGF5XCIsIFwiY2hpbGRyZW5cIl0pO1xuXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9leHRlbmRzKHtcbiAgICBjbGFzc05hbWU6IFwidngtbGVnZW5kLWl0ZW1cIixcbiAgICBzdHlsZToge1xuICAgICAgZGlzcGxheTogZGlzcGxheSxcbiAgICAgIGFsaWduSXRlbXM6IGFsaWduSXRlbXMsXG4gICAgICBmbGV4RGlyZWN0aW9uOiBmbGV4RGlyZWN0aW9uLFxuICAgICAgbWFyZ2luOiBtYXJnaW5cbiAgICB9XG4gIH0sIHJlc3RQcm9wcyksIGNoaWxkcmVuKTtcbn0iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbkxlZ2VuZExhYmVsLnByb3BUeXBlcyA9IHtcbiAgYWxpZ246IFByb3BUeXBlcy5zdHJpbmcsXG4gIGxhYmVsOiBQcm9wVHlwZXMuYW55LFxuICBmbGV4OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gIG1hcmdpbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLm51bWJlcl0pLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLmFueVxufTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIExlZ2VuZExhYmVsKF9yZWYpIHtcbiAgdmFyIF9yZWYkZmxleCA9IF9yZWYuZmxleCxcbiAgICAgIGZsZXggPSBfcmVmJGZsZXggPT09IHZvaWQgMCA/ICcxJyA6IF9yZWYkZmxleCxcbiAgICAgIGxhYmVsID0gX3JlZi5sYWJlbCxcbiAgICAgIF9yZWYkbWFyZ2luID0gX3JlZi5tYXJnaW4sXG4gICAgICBtYXJnaW4gPSBfcmVmJG1hcmdpbiA9PT0gdm9pZCAwID8gJzVweCAwJyA6IF9yZWYkbWFyZ2luLFxuICAgICAgX3JlZiRhbGlnbiA9IF9yZWYuYWxpZ24sXG4gICAgICBhbGlnbiA9IF9yZWYkYWxpZ24gPT09IHZvaWQgMCA/ICdsZWZ0JyA6IF9yZWYkYWxpZ24sXG4gICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW47XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IFwidngtbGVnZW5kLWxhYmVsXCIsXG4gICAgc3R5bGU6IHtcbiAgICAgIGp1c3RpZnlDb250ZW50OiBhbGlnbixcbiAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgIGZsZXg6IGZsZXgsXG4gICAgICBtYXJnaW46IG1hcmdpblxuICAgIH1cbiAgfSwgY2hpbGRyZW4gfHwgbGFiZWwpO1xufSIsImltcG9ydCBfcHQgZnJvbSBcInByb3AtdHlwZXNcIjtcblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFNoYXBlUmVjdChfcmVmKSB7XG4gIHZhciBmaWxsID0gX3JlZi5maWxsLFxuICAgICAgd2lkdGggPSBfcmVmLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQsXG4gICAgICBzdHlsZSA9IF9yZWYuc3R5bGU7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgc3R5bGU6IF9leHRlbmRzKHtcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgYmFja2dyb3VuZDogZmlsbFxuICAgIH0sIHN0eWxlKVxuICB9KTtcbn1cblNoYXBlUmVjdC5wcm9wVHlwZXMgPSB7XG4gIGZpbGw6IF9wdC5zdHJpbmcsXG4gIHdpZHRoOiBfcHQub25lT2ZUeXBlKFtfcHQuc3RyaW5nLCBfcHQubnVtYmVyXSksXG4gIGhlaWdodDogX3B0Lm9uZU9mVHlwZShbX3B0LnN0cmluZywgX3B0Lm51bWJlcl0pXG59OyIsImltcG9ydCBfcHQgZnJvbSBcInByb3AtdHlwZXNcIjtcblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IGN4IGZyb20gJ2NsYXNzbmFtZXMnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gR3JvdXAoX3JlZikge1xuICB2YXIgX3JlZiR0b3AgPSBfcmVmLnRvcCxcbiAgICAgIHRvcCA9IF9yZWYkdG9wID09PSB2b2lkIDAgPyAwIDogX3JlZiR0b3AsXG4gICAgICBfcmVmJGxlZnQgPSBfcmVmLmxlZnQsXG4gICAgICBsZWZ0ID0gX3JlZiRsZWZ0ID09PSB2b2lkIDAgPyAwIDogX3JlZiRsZWZ0LFxuICAgICAgdHJhbnNmb3JtID0gX3JlZi50cmFuc2Zvcm0sXG4gICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIGlubmVyUmVmID0gX3JlZi5pbm5lclJlZixcbiAgICAgIHJlc3RQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIFtcInRvcFwiLCBcImxlZnRcIiwgXCJ0cmFuc2Zvcm1cIiwgXCJjbGFzc05hbWVcIiwgXCJjaGlsZHJlblwiLCBcImlubmVyUmVmXCJdKTtcblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJnXCIsIF9leHRlbmRzKHtcbiAgICByZWY6IGlubmVyUmVmLFxuICAgIGNsYXNzTmFtZTogY3goJ3Z4LWdyb3VwJywgY2xhc3NOYW1lKSxcbiAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSB8fCBcInRyYW5zbGF0ZShcIiArIGxlZnQgKyBcIiwgXCIgKyB0b3AgKyBcIilcIlxuICB9LCByZXN0UHJvcHMpLCBjaGlsZHJlbik7XG59XG5Hcm91cC5wcm9wVHlwZXMgPSB7XG4gIHRvcDogX3B0Lm51bWJlcixcbiAgbGVmdDogX3B0Lm51bWJlcixcbiAgdHJhbnNmb3JtOiBfcHQuc3RyaW5nLFxuICBjbGFzc05hbWU6IF9wdC5zdHJpbmcsXG4gIGNoaWxkcmVuOiBfcHQubm9kZSxcbiAgaW5uZXJSZWY6IF9wdC5vbmVPZlR5cGUoW19wdC5zdHJpbmcsIF9wdC5mdW5jLCBfcHQub2JqZWN0XSlcbn07IiwiaW1wb3J0IF9wdCBmcm9tIFwicHJvcC10eXBlc1wiO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEdyb3VwIH0gZnJvbSAnQHZ4L2dyb3VwJztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFNoYXBlQ2lyY2xlKF9yZWYpIHtcbiAgdmFyIGZpbGwgPSBfcmVmLmZpbGwsXG4gICAgICB3aWR0aCA9IF9yZWYud2lkdGgsXG4gICAgICBoZWlnaHQgPSBfcmVmLmhlaWdodCxcbiAgICAgIHN0eWxlID0gX3JlZi5zdHlsZTtcbiAgdmFyIGNsZWFuV2lkdGggPSB0eXBlb2Ygd2lkdGggPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB3aWR0aCA9PT0gJ3VuZGVmaW5lZCcgPyAwIDogd2lkdGg7XG4gIHZhciBjbGVhbkhlaWdodCA9IHR5cGVvZiBoZWlnaHQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBoZWlnaHQgPT09ICd1bmRlZmluZWQnID8gMCA6IGhlaWdodDtcbiAgdmFyIHNpemUgPSBNYXRoLm1heChjbGVhbldpZHRoLCBjbGVhbkhlaWdodCk7XG4gIHZhciByYWRpdXMgPSBzaXplIC8gMjtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHtcbiAgICB3aWR0aDogc2l6ZSxcbiAgICBoZWlnaHQ6IHNpemVcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoR3JvdXAsIHtcbiAgICB0b3A6IHJhZGl1cyxcbiAgICBsZWZ0OiByYWRpdXNcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjaXJjbGVcIiwge1xuICAgIHI6IHJhZGl1cyxcbiAgICBmaWxsOiBTdHJpbmcoZmlsbCksXG4gICAgc3R5bGU6IHN0eWxlXG4gIH0pKSk7XG59XG5TaGFwZUNpcmNsZS5wcm9wVHlwZXMgPSB7XG4gIGZpbGw6IF9wdC5zdHJpbmcsXG4gIHdpZHRoOiBfcHQub25lT2ZUeXBlKFtfcHQuc3RyaW5nLCBfcHQubnVtYmVyXSksXG4gIGhlaWdodDogX3B0Lm9uZU9mVHlwZShbX3B0LnN0cmluZywgX3B0Lm51bWJlcl0pXG59OyIsImZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVjdFNoYXBlIGZyb20gJy4uL3NoYXBlcy9SZWN0JztcbmltcG9ydCBDaXJjbGVTaGFwZSBmcm9tICcuLi9zaGFwZXMvQ2lyY2xlJztcblxudmFyIE5PX09QID0gZnVuY3Rpb24gTk9fT1AoKSB7XG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZW5kZXJTaGFwZShfcmVmKSB7XG4gIHZhciBfcmVmJHNoYXBlID0gX3JlZi5zaGFwZSxcbiAgICAgIHNoYXBlID0gX3JlZiRzaGFwZSA9PT0gdm9pZCAwID8gJ3JlY3QnIDogX3JlZiRzaGFwZSxcbiAgICAgIF9yZWYkZmlsbCA9IF9yZWYuZmlsbCxcbiAgICAgIGZpbGwgPSBfcmVmJGZpbGwgPT09IHZvaWQgMCA/IE5PX09QIDogX3JlZiRmaWxsLFxuICAgICAgX3JlZiRzaXplID0gX3JlZi5zaXplLFxuICAgICAgc2l6ZSA9IF9yZWYkc2l6ZSA9PT0gdm9pZCAwID8gTk9fT1AgOiBfcmVmJHNpemUsXG4gICAgICB3aWR0aCA9IF9yZWYud2lkdGgsXG4gICAgICBoZWlnaHQgPSBfcmVmLmhlaWdodCxcbiAgICAgIGxhYmVsID0gX3JlZi5sYWJlbCxcbiAgICAgIF9yZWYkc2hhcGVTdHlsZSA9IF9yZWYuc2hhcGVTdHlsZSxcbiAgICAgIHNoYXBlU3R5bGUgPSBfcmVmJHNoYXBlU3R5bGUgPT09IHZvaWQgMCA/IE5PX09QIDogX3JlZiRzaGFwZVN0eWxlO1xuICB2YXIgcHJvcHMgPSB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIGxhYmVsOiBsYWJlbCxcbiAgICBmaWxsOiBmaWxsKF9leHRlbmRzKHt9LCBsYWJlbCkpLFxuICAgIHNpemU6IHNpemUoX2V4dGVuZHMoe30sIGxhYmVsKSksXG4gICAgc3R5bGU6IHNoYXBlU3R5bGUoX2V4dGVuZHMoe30sIGxhYmVsKSlcbiAgfTtcblxuICBpZiAodHlwZW9mIHNoYXBlID09PSAnc3RyaW5nJykge1xuICAgIGlmIChzaGFwZSA9PT0gJ3JlY3QnKSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVjdFNoYXBlLCBwcm9wcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENpcmNsZVNoYXBlLCBwcm9wcyk7XG4gIH1cblxuICBpZiAoIC8qI19fUFVSRV9fKi9SZWFjdC5pc1ZhbGlkRWxlbWVudChzaGFwZSkpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudChzaGFwZSwgcHJvcHMpO1xuICB9XG5cbiAgaWYgKHNoYXBlKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KHNoYXBlLCBwcm9wcyk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn0iLCJmdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBTaGFwZVJlY3QgZnJvbSAnLi4vc2hhcGVzL1JlY3QnO1xuaW1wb3J0IHJlbmRlclNoYXBlIGZyb20gJy4uL3V0aWwvcmVuZGVyU2hhcGUnO1xuTGVnZW5kU2hhcGUucHJvcFR5cGVzID0ge1xuICBzaGFwZTogUHJvcFR5cGVzLmFueSxcbiAgd2lkdGg6IFByb3BUeXBlcy5hbnksXG4gIGhlaWdodDogUHJvcFR5cGVzLmFueSxcbiAgbWFyZ2luOiBQcm9wVHlwZXMuYW55LFxuICBsYWJlbDogUHJvcFR5cGVzLmFueSxcbiAgZmlsbDogUHJvcFR5cGVzLmFueSxcbiAgc2l6ZTogUHJvcFR5cGVzLmFueSxcbiAgc2hhcGVTdHlsZTogUHJvcFR5cGVzLmFueVxufTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIExlZ2VuZFNoYXBlKF9yZWYpIHtcbiAgdmFyIF9yZWYkc2hhcGUgPSBfcmVmLnNoYXBlLFxuICAgICAgc2hhcGUgPSBfcmVmJHNoYXBlID09PSB2b2lkIDAgPyBTaGFwZVJlY3QgOiBfcmVmJHNoYXBlLFxuICAgICAgd2lkdGggPSBfcmVmLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQsXG4gICAgICBtYXJnaW4gPSBfcmVmLm1hcmdpbixcbiAgICAgIGxhYmVsID0gX3JlZi5sYWJlbCxcbiAgICAgIGZpbGwgPSBfcmVmLmZpbGwsXG4gICAgICBzaXplID0gX3JlZi5zaXplLFxuICAgICAgc2hhcGVTdHlsZSA9IF9yZWYuc2hhcGVTdHlsZTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogXCJ2eC1sZWdlbmQtc2hhcGVcIixcbiAgICBzdHlsZToge1xuICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgd2lkdGg6IHNpemUgPyBzaXplKF9leHRlbmRzKHt9LCBsYWJlbCkpIDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IHNpemUgPyBzaXplKF9leHRlbmRzKHt9LCBsYWJlbCkpIDogaGVpZ2h0LFxuICAgICAgbWFyZ2luOiBtYXJnaW5cbiAgICB9XG4gIH0sIHJlbmRlclNoYXBlKHtcbiAgICBzaGFwZTogc2hhcGUsXG4gICAgbGFiZWw6IGxhYmVsLFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICBmaWxsOiBmaWxsLFxuICAgIHNoYXBlU3R5bGU6IHNoYXBlU3R5bGVcbiAgfSkpO1xufSIsIi8qKiBSZXR1cm5zIGFuIG9iamVjdCdzIHZhbHVlIGlmIGRlZmluZWQsIG9yIHRoZSBvYmplY3QuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB2YWx1ZU9ySWRlbnRpdHkoXykge1xuICBpZiAoXyAmJiB0eXBlb2YgXyA9PT0gJ29iamVjdCcgJiYgJ3ZhbHVlJyBpbiBfICYmIHR5cGVvZiBfLnZhbHVlICE9PSAndW5kZWZpbmVkJykgcmV0dXJuIF8udmFsdWU7XG4gIHJldHVybiBfO1xufVxuLyoqIFJldHVybnMgYW4gb2JqZWN0J3MgdmFsdWUgaWYgZGVmaW5lZCwgb3IgdGhlIG9iamVjdCwgY29lcmNlZCB0byBhIHN0cmluZy4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbHVlT3JJZGVudGl0eVN0cmluZyhfKSB7XG4gIHJldHVybiBTdHJpbmcodmFsdWVPcklkZW50aXR5KF8pKTtcbn0iLCJmdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY3ggZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IExlZ2VuZEl0ZW0gZnJvbSAnLi9MZWdlbmRJdGVtJztcbmltcG9ydCBMZWdlbmRMYWJlbCBmcm9tICcuL0xlZ2VuZExhYmVsJztcbmltcG9ydCBMZWdlbmRTaGFwZSBmcm9tICcuL0xlZ2VuZFNoYXBlJztcbmltcG9ydCB2YWx1ZU9ySWRlbnRpdHkgZnJvbSAnLi4vdXRpbC92YWx1ZU9ySWRlbnRpdHknO1xuTGVnZW5kLnByb3BUeXBlcyA9IHtcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBzdHlsZTogUHJvcFR5cGVzLmFueSxcbiAgZG9tYWluOiBQcm9wVHlwZXMuYXJyYXksXG4gIHNjYWxlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm9iamVjdF0pLmlzUmVxdWlyZWQsXG4gIHNoYXBlV2lkdGg6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgc2hhcGVIZWlnaHQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgc2hhcGVNYXJnaW46IFByb3BUeXBlcy5hbnksXG4gIGxhYmVsQWxpZ246IFByb3BUeXBlcy5zdHJpbmcsXG4gIGxhYmVsRmxleDogUHJvcFR5cGVzLnN0cmluZyxcbiAgbGFiZWxNYXJnaW46IFByb3BUeXBlcy5zdHJpbmcsXG4gIGl0ZW1NYXJnaW46IFByb3BUeXBlcy5zdHJpbmcsXG4gIGRpcmVjdGlvbjogUHJvcFR5cGVzLnN0cmluZyxcbiAgaXRlbURpcmVjdGlvbjogUHJvcFR5cGVzLnN0cmluZyxcbiAgZmlsbDogUHJvcFR5cGVzLmFueSxcbiAgc2l6ZTogUHJvcFR5cGVzLmFueSxcbiAgc2hhcGU6IFByb3BUeXBlcy5hbnksXG4gIHNoYXBlU3R5bGU6IFByb3BUeXBlcy5hbnksXG4gIGxhYmVsRm9ybWF0OiBQcm9wVHlwZXMuZnVuYyxcbiAgbGFiZWxUcmFuc2Zvcm06IFByb3BUeXBlcy5mdW5jLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLmZ1bmNcbn07XG52YXIgZGVmYXVsdFN0eWxlID0ge1xuICBkaXNwbGF5OiAnZmxleCdcbn07XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBMZWdlbmQoX3JlZikge1xuICB2YXIgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBfcmVmJHN0eWxlID0gX3JlZi5zdHlsZSxcbiAgICAgIHN0eWxlID0gX3JlZiRzdHlsZSA9PT0gdm9pZCAwID8gZGVmYXVsdFN0eWxlIDogX3JlZiRzdHlsZSxcbiAgICAgIHNoYXBlU3R5bGUgPSBfcmVmLnNoYXBlU3R5bGUsXG4gICAgICBzY2FsZSA9IF9yZWYuc2NhbGUsXG4gICAgICBzaGFwZSA9IF9yZWYuc2hhcGUsXG4gICAgICBpbnB1dERvbWFpbiA9IF9yZWYuZG9tYWluLFxuICAgICAgX3JlZiRmaWxsID0gX3JlZi5maWxsLFxuICAgICAgZmlsbCA9IF9yZWYkZmlsbCA9PT0gdm9pZCAwID8gdmFsdWVPcklkZW50aXR5IDogX3JlZiRmaWxsLFxuICAgICAgX3JlZiRzaXplID0gX3JlZi5zaXplLFxuICAgICAgc2l6ZSA9IF9yZWYkc2l6ZSA9PT0gdm9pZCAwID8gdmFsdWVPcklkZW50aXR5IDogX3JlZiRzaXplLFxuICAgICAgX3JlZiRsYWJlbEZvcm1hdCA9IF9yZWYubGFiZWxGb3JtYXQsXG4gICAgICBsYWJlbEZvcm1hdCA9IF9yZWYkbGFiZWxGb3JtYXQgPT09IHZvaWQgMCA/IHZhbHVlT3JJZGVudGl0eSA6IF9yZWYkbGFiZWxGb3JtYXQsXG4gICAgICBfcmVmJGxhYmVsVHJhbnNmb3JtID0gX3JlZi5sYWJlbFRyYW5zZm9ybSxcbiAgICAgIGxhYmVsVHJhbnNmb3JtID0gX3JlZiRsYWJlbFRyYW5zZm9ybSA9PT0gdm9pZCAwID8gZGVmYXVsdFRyYW5zZm9ybSA6IF9yZWYkbGFiZWxUcmFuc2Zvcm0sXG4gICAgICBfcmVmJHNoYXBlV2lkdGggPSBfcmVmLnNoYXBlV2lkdGgsXG4gICAgICBzaGFwZVdpZHRoID0gX3JlZiRzaGFwZVdpZHRoID09PSB2b2lkIDAgPyAxNSA6IF9yZWYkc2hhcGVXaWR0aCxcbiAgICAgIF9yZWYkc2hhcGVIZWlnaHQgPSBfcmVmLnNoYXBlSGVpZ2h0LFxuICAgICAgc2hhcGVIZWlnaHQgPSBfcmVmJHNoYXBlSGVpZ2h0ID09PSB2b2lkIDAgPyAxNSA6IF9yZWYkc2hhcGVIZWlnaHQsXG4gICAgICBfcmVmJHNoYXBlTWFyZ2luID0gX3JlZi5zaGFwZU1hcmdpbixcbiAgICAgIHNoYXBlTWFyZ2luID0gX3JlZiRzaGFwZU1hcmdpbiA9PT0gdm9pZCAwID8gJzJweCA0cHggMnB4IDAnIDogX3JlZiRzaGFwZU1hcmdpbixcbiAgICAgIF9yZWYkbGFiZWxBbGlnbiA9IF9yZWYubGFiZWxBbGlnbixcbiAgICAgIGxhYmVsQWxpZ24gPSBfcmVmJGxhYmVsQWxpZ24gPT09IHZvaWQgMCA/ICdsZWZ0JyA6IF9yZWYkbGFiZWxBbGlnbixcbiAgICAgIF9yZWYkbGFiZWxGbGV4ID0gX3JlZi5sYWJlbEZsZXgsXG4gICAgICBsYWJlbEZsZXggPSBfcmVmJGxhYmVsRmxleCA9PT0gdm9pZCAwID8gJzEnIDogX3JlZiRsYWJlbEZsZXgsXG4gICAgICBfcmVmJGxhYmVsTWFyZ2luID0gX3JlZi5sYWJlbE1hcmdpbixcbiAgICAgIGxhYmVsTWFyZ2luID0gX3JlZiRsYWJlbE1hcmdpbiA9PT0gdm9pZCAwID8gJzAgNHB4JyA6IF9yZWYkbGFiZWxNYXJnaW4sXG4gICAgICBfcmVmJGl0ZW1NYXJnaW4gPSBfcmVmLml0ZW1NYXJnaW4sXG4gICAgICBpdGVtTWFyZ2luID0gX3JlZiRpdGVtTWFyZ2luID09PSB2b2lkIDAgPyAnMCcgOiBfcmVmJGl0ZW1NYXJnaW4sXG4gICAgICBfcmVmJGRpcmVjdGlvbiA9IF9yZWYuZGlyZWN0aW9uLFxuICAgICAgZGlyZWN0aW9uID0gX3JlZiRkaXJlY3Rpb24gPT09IHZvaWQgMCA/ICdjb2x1bW4nIDogX3JlZiRkaXJlY3Rpb24sXG4gICAgICBfcmVmJGl0ZW1EaXJlY3Rpb24gPSBfcmVmLml0ZW1EaXJlY3Rpb24sXG4gICAgICBpdGVtRGlyZWN0aW9uID0gX3JlZiRpdGVtRGlyZWN0aW9uID09PSB2b2lkIDAgPyAncm93JyA6IF9yZWYkaXRlbURpcmVjdGlvbixcbiAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIHJlc3RQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIFtcImNsYXNzTmFtZVwiLCBcInN0eWxlXCIsIFwic2hhcGVTdHlsZVwiLCBcInNjYWxlXCIsIFwic2hhcGVcIiwgXCJkb21haW5cIiwgXCJmaWxsXCIsIFwic2l6ZVwiLCBcImxhYmVsRm9ybWF0XCIsIFwibGFiZWxUcmFuc2Zvcm1cIiwgXCJzaGFwZVdpZHRoXCIsIFwic2hhcGVIZWlnaHRcIiwgXCJzaGFwZU1hcmdpblwiLCBcImxhYmVsQWxpZ25cIiwgXCJsYWJlbEZsZXhcIiwgXCJsYWJlbE1hcmdpblwiLCBcIml0ZW1NYXJnaW5cIiwgXCJkaXJlY3Rpb25cIiwgXCJpdGVtRGlyZWN0aW9uXCIsIFwiY2hpbGRyZW5cIl0pO1xuXG4gIHZhciBkb21haW4gPSBpbnB1dERvbWFpbiB8fCBzY2FsZS5kb21haW4oKTtcbiAgdmFyIGxhYmVscyA9IGRvbWFpbi5tYXAobGFiZWxUcmFuc2Zvcm0oe1xuICAgIHNjYWxlOiBzY2FsZSxcbiAgICBsYWJlbEZvcm1hdDogbGFiZWxGb3JtYXRcbiAgfSkpO1xuICBpZiAoY2hpbGRyZW4pIHJldHVybiBjaGlsZHJlbihsYWJlbHMpO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBjeCgndngtbGVnZW5kJywgY2xhc3NOYW1lKSxcbiAgICBzdHlsZTogX2V4dGVuZHMoe30sIHN0eWxlLCB7XG4gICAgICBmbGV4RGlyZWN0aW9uOiBkaXJlY3Rpb25cbiAgICB9KVxuICB9LCBsYWJlbHMubWFwKGZ1bmN0aW9uIChsYWJlbCwgaSkge1xuICAgIHZhciB0ZXh0ID0gbGFiZWwudGV4dDtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChMZWdlbmRJdGVtLCBfZXh0ZW5kcyh7XG4gICAgICBrZXk6IFwibGVnZW5kLVwiICsgbGFiZWwgKyBcIi1cIiArIGksXG4gICAgICBtYXJnaW46IGl0ZW1NYXJnaW4sXG4gICAgICBmbGV4RGlyZWN0aW9uOiBpdGVtRGlyZWN0aW9uLFxuICAgICAgbGFiZWw6IGxhYmVsXG4gICAgfSwgcmVzdFByb3BzKSwgUmVhY3QuY3JlYXRlRWxlbWVudChMZWdlbmRTaGFwZSwge1xuICAgICAgc2hhcGU6IHNoYXBlLFxuICAgICAgaGVpZ2h0OiBzaGFwZUhlaWdodCxcbiAgICAgIHdpZHRoOiBzaGFwZVdpZHRoLFxuICAgICAgbWFyZ2luOiBzaGFwZU1hcmdpbixcbiAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgIGZpbGw6IGZpbGwsXG4gICAgICBzaXplOiBzaXplLFxuICAgICAgc2hhcGVTdHlsZTogc2hhcGVTdHlsZVxuICAgIH0pLCBSZWFjdC5jcmVhdGVFbGVtZW50KExlZ2VuZExhYmVsLCB7XG4gICAgICBsYWJlbDogdGV4dCxcbiAgICAgIGZsZXg6IGxhYmVsRmxleCxcbiAgICAgIG1hcmdpbjogbGFiZWxNYXJnaW4sXG4gICAgICBhbGlnbjogbGFiZWxBbGlnblxuICAgIH0pKTtcbiAgfSkpO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0VHJhbnNmb3JtKF9yZWYyKSB7XG4gIHZhciBzY2FsZSA9IF9yZWYyLnNjYWxlLFxuICAgICAgbGFiZWxGb3JtYXQgPSBfcmVmMi5sYWJlbEZvcm1hdDtcbiAgcmV0dXJuIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdHVtOiBkLFxuICAgICAgaW5kZXg6IGksXG4gICAgICB0ZXh0OiBcIlwiICsgbGFiZWxGb3JtYXQoZCwgaSksXG4gICAgICB2YWx1ZTogc2NhbGUoZClcbiAgICB9O1xuICB9O1xufSIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgTGVnZW5kIGZyb20gJy4vTGVnZW5kJztcblxuLyoqIE9yZGluYWwgc2NhbGVzIG1hcCBmcm9tIHN0cmluZ3MgdG8gYW4gT3V0cHV0IHR5cGUuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBPcmRpbmFsKHByb3BzKSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChMZWdlbmQsIHByb3BzKTtcbn0iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2294\n')}}]);